{"sha": "fe9f1beae241821f91cd5801c37d42737a434f5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOWYxYmVhZTI0MTgyMWY5MWNkNTgwMWMzN2Q0MjczN2E0MzRmNWM=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2014-12-22T12:13:09Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2014-12-24T15:08:33Z"}, "message": "clean up `BinaryHeap` code", "tree": {"sha": "bb9b587b33922b6299b2e302bcd5174f7009603a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb9b587b33922b6299b2e302bcd5174f7009603a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe9f1beae241821f91cd5801c37d42737a434f5c", "comment_count": 17, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9f1beae241821f91cd5801c37d42737a434f5c", "html_url": "https://github.com/rust-lang/rust/commit/fe9f1beae241821f91cd5801c37d42737a434f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe9f1beae241821f91cd5801c37d42737a434f5c/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e64a8193b02ce72ef183274994a25eae281cb89c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e64a8193b02ce72ef183274994a25eae281cb89c", "html_url": "https://github.com/rust-lang/rust/commit/e64a8193b02ce72ef183274994a25eae281cb89c"}], "stats": {"total": 201, "additions": 94, "deletions": 107}, "files": [{"sha": "a2f38bb667447bf01bc69748fd00614eafbe7d4a", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 94, "deletions": 107, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f1beae241821f91cd5801c37d42737a434f5c/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f1beae241821f91cd5801c37d42737a434f5c/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=fe9f1beae241821f91cd5801c37d42737a434f5c", "patch": "@@ -11,15 +11,15 @@\n //! A priority queue implemented with a binary heap.\n //!\n //! Insertion and popping the largest element have `O(log n)` time complexity. Checking the largest\n-//! element is `O(1)`. Converting a vector to a priority queue can be done in-place, and has `O(n)`\n-//! complexity. A priority queue can also be converted to a sorted vector in-place, allowing it to\n+//! element is `O(1)`. Converting a vector to a binary heap can be done in-place, and has `O(n)`\n+//! complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to\n //! be used for an `O(n log n)` in-place heapsort.\n //!\n //! # Examples\n //!\n-//! This is a larger example which implements [Dijkstra's algorithm][dijkstra]\n+//! This is a larger example that implements [Dijkstra's algorithm][dijkstra]\n //! to solve the [shortest path problem][sssp] on a [directed graph][dir_graph].\n-//! It showcases how to use the `BinaryHeap` with custom types.\n+//! It shows how to use `BinaryHeap` with custom types.\n //!\n //! [dijkstra]: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n //! [sssp]: http://en.wikipedia.org/wiki/Shortest_path_problem\n@@ -32,7 +32,7 @@\n //! #[deriving(Copy, Eq, PartialEq)]\n //! struct State {\n //!     cost: uint,\n-//!     position: uint\n+//!     position: uint,\n //! }\n //!\n //! // The priority queue depends on `Ord`.\n@@ -55,13 +55,13 @@\n //! // Each node is represented as an `uint`, for a shorter implementation.\n //! struct Edge {\n //!     node: uint,\n-//!     cost: uint\n+//!     cost: uint,\n //! }\n //!\n //! // Dijkstra's shortest path algorithm.\n //!\n //! // Start at `start` and use `dist` to track the current shortest distance\n-//! // to each node. This implementation isn't memory efficient as it may leave duplicate\n+//! // to each node. This implementation isn't memory-efficient as it may leave duplicate\n //! // nodes in the queue. It also uses `uint::MAX` as a sentinel value,\n //! // for a simpler implementation.\n //! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: uint, goal: uint) -> uint {\n@@ -71,21 +71,16 @@\n //!     let mut heap = BinaryHeap::new();\n //!\n //!     // We're at `start`, with a zero cost\n-//!     dist[start] = 0u;\n-//!     heap.push(State { cost: 0u, position: start });\n+//!     dist[start] = 0;\n+//!     heap.push(State { cost: 0, position: start });\n //!\n //!     // Examine the frontier with lower cost nodes first (min-heap)\n-//!     loop {\n-//!         let State { cost, position } = match heap.pop() {\n-//!             None => break, // empty\n-//!             Some(s) => s\n-//!         };\n-//!\n+//!     while let Some(State { cost, position }) = heap.pop() {\n //!         // Alternatively we could have continued to find all shortest paths\n-//!         if position == goal { return cost }\n+//!         if position == goal { return cost; }\n //!\n //!         // Important as we may have already found a better way\n-//!         if cost > dist[position] { continue }\n+//!         if cost > dist[position] { continue; }\n //!\n //!         // For each node we can reach, see if we can find a way with\n //!         // a lower cost going through this node\n@@ -108,7 +103,7 @@\n //! fn main() {\n //!     // This is the directed graph we're going to use.\n //!     // The node numbers correspond to the different states,\n-//!     // and the edge weights symbolises the cost of moving\n+//!     // and the edge weights symbolize the cost of moving\n //!     // from one node to another.\n //!     // Note that the edges are one-way.\n //!     //\n@@ -126,7 +121,7 @@\n //!     //\n //!     // The graph is represented as an adjacency list where each index,\n //!     // corresponding to a node value, has a list of outgoing edges.\n-//!     // Chosen for it's efficiency.\n+//!     // Chosen for its efficiency.\n //!     let graph = vec![\n //!         // Node 0\n //!         vec![Edge { node: 2, cost: 10 },\n@@ -184,10 +179,11 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(4u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n+    pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n     /// This preallocates enough memory for `capacity` elements,\n@@ -198,7 +194,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n+    /// let mut heap = BinaryHeap::with_capacity(10);\n+    /// heap.push(4u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n@@ -214,17 +211,17 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let heap = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n     /// ```\n-    pub fn from_vec(xs: Vec<T>) -> BinaryHeap<T> {\n-        let mut q = BinaryHeap{data: xs,};\n-        let mut n = q.len() / 2;\n+    pub fn from_vec(vec: Vec<T>) -> BinaryHeap<T> {\n+        let mut heap = BinaryHeap { data: vec };\n+        let mut n = heap.len() / 2;\n         while n > 0 {\n             n -= 1;\n-            q.siftdown(n)\n+            heap.sift_down(n);\n         }\n-        q\n+        heap\n     }\n \n-    /// An iterator visiting all values in underlying vector, in\n+    /// Returns an iterator visiting all values in the underlying vector, in\n     /// arbitrary order.\n     ///\n     /// # Examples\n@@ -244,17 +241,17 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out of\n-    /// the binary heap in arbitrary order.  The binary heap cannot be used\n+    /// the binary heap in arbitrary order. The binary heap cannot be used\n     /// after calling this.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in pq.into_iter() {\n+    /// for x in heap.into_iter() {\n     ///     // x has type int, not &int\n     ///     println!(\"{}\", x);\n     /// }\n@@ -264,36 +261,35 @@ impl<T: Ord> BinaryHeap<T> {\n         IntoIter { iter: self.data.into_iter() }\n     }\n \n-    /// Returns the greatest item in a queue, or `None` if it is empty.\n+    /// Returns the greatest item in the binary heap, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n     /// let mut heap = BinaryHeap::new();\n     /// assert_eq!(heap.peek(), None);\n     ///\n     /// heap.push(1i);\n-    /// heap.push(5i);\n-    /// heap.push(2i);\n-    /// assert_eq!(heap.peek(), Some(&5i));\n+    /// heap.push(5);\n+    /// heap.push(2);\n+    /// assert_eq!(heap.peek(), Some(&5));\n     ///\n     /// ```\n     #[stable]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n     }\n \n-    /// Returns the number of elements the queue can hold without reallocating.\n+    /// Returns the number of elements the binary heap can hold without reallocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n-    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n-    /// assert!(heap.capacity() >= 100u);\n+    /// let mut heap = BinaryHeap::with_capacity(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n@@ -313,13 +309,15 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n-    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n-    /// heap.reserve_exact(100u);\n-    /// assert!(heap.capacity() >= 100u);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.reserve_exact(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve_exact(&mut self, additional: uint) { self.data.reserve_exact(additional) }\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        self.data.reserve_exact(additional);\n+    }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the\n     /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n@@ -332,88 +330,82 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n-    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n-    /// heap.reserve(100u);\n-    /// assert!(heap.capacity() >= 100u);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.reserve(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n-        self.data.reserve(additional)\n+        self.data.reserve(additional);\n     }\n \n     /// Discards as much additional capacity as possible.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n-        self.data.shrink_to_fit()\n+        self.data.shrink_to_fit();\n     }\n \n-    /// Removes the greatest item from a queue and returns it, or `None` if it\n+    /// Removes the greatest item from the binary heap and returns it, or `None` if it\n     /// is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n     /// let mut heap = BinaryHeap::from_vec(vec![1i, 3]);\n     ///\n-    /// assert_eq!(heap.pop(), Some(3i));\n-    /// assert_eq!(heap.pop(), Some(1i));\n+    /// assert_eq!(heap.pop(), Some(3));\n+    /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop(&mut self) -> Option<T> {\n-        match self.data.pop() {\n-            None           => { None }\n-            Some(mut item) => {\n-                if !self.is_empty() {\n-                    swap(&mut item, &mut self.data[0]);\n-                    self.siftdown(0);\n-                }\n-                Some(item)\n+        self.data.pop().map(|mut item| {\n+            if !self.is_empty() {\n+                swap(&mut item, &mut self.data[0]);\n+                self.sift_down(0);\n             }\n-        }\n+            item\n+        })\n     }\n \n-    /// Pushes an item onto the queue.\n+    /// Pushes an item onto the binary heap.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n     /// let mut heap = BinaryHeap::new();\n     /// heap.push(3i);\n-    /// heap.push(5i);\n-    /// heap.push(1i);\n+    /// heap.push(5);\n+    /// heap.push(1);\n     ///\n     /// assert_eq!(heap.len(), 3);\n-    /// assert_eq!(heap.peek(), Some(&5i));\n+    /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n-        self.siftup(0, old_len);\n+        self.sift_up(0, old_len);\n     }\n \n-    /// Pushes an item onto a queue then pops the greatest item off the queue in\n+    /// Pushes an item onto the binary heap, then pops the greatest item off the queue in\n     /// an optimized fashion.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n     /// let mut heap = BinaryHeap::new();\n     /// heap.push(1i);\n-    /// heap.push(5i);\n+    /// heap.push(5);\n     ///\n-    /// assert_eq!(heap.push_pop(3i), 5);\n-    /// assert_eq!(heap.push_pop(9i), 9);\n+    /// assert_eq!(heap.push_pop(3), 5);\n+    /// assert_eq!(heap.push_pop(9), 9);\n     /// assert_eq!(heap.len(), 2);\n-    /// assert_eq!(heap.peek(), Some(&3i));\n+    /// assert_eq!(heap.peek(), Some(&3));\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         match self.data.get_mut(0) {\n@@ -425,30 +417,29 @@ impl<T: Ord> BinaryHeap<T> {\n             },\n         }\n \n-        self.siftdown(0);\n+        self.sift_down(0);\n         item\n     }\n \n-    /// Pops the greatest item off a queue then pushes an item onto the queue in\n-    /// an optimized fashion. The push is done regardless of whether the queue\n+    /// Pops the greatest item off the binary heap, then pushes an item onto the queue in\n+    /// an optimized fashion. The push is done regardless of whether the binary heap\n     /// was empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n     /// let mut heap = BinaryHeap::new();\n     ///\n     /// assert_eq!(heap.replace(1i), None);\n-    /// assert_eq!(heap.replace(3i), Some(1i));\n+    /// assert_eq!(heap.replace(3), Some(1));\n     /// assert_eq!(heap.len(), 1);\n-    /// assert_eq!(heap.peek(), Some(&3i));\n+    /// assert_eq!(heap.peek(), Some(&3));\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n             swap(&mut item, &mut self.data[0]);\n-            self.siftdown(0);\n+            self.sift_down(0);\n             Some(item)\n         } else {\n             self.push(item);\n@@ -463,7 +454,6 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    ///\n     /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n     /// let vec = heap.into_vec();\n     ///\n@@ -494,35 +484,34 @@ impl<T: Ord> BinaryHeap<T> {\n         while end > 1 {\n             end -= 1;\n             self.data.swap(0, end);\n-            self.siftdown_range(0, end)\n+            self.sift_down_range(0, end);\n         }\n         self.into_vec()\n     }\n \n-    // The implementations of siftup and siftdown use unsafe blocks in\n+    // The implementations of sift_up and sift_down use unsafe blocks in\n     // order to move an element out of the vector (leaving behind a\n     // zeroed element), shift along the others and move it back into the\n-    // vector over the junk element.  This reduces the constant factor\n+    // vector over the junk element. This reduces the constant factor\n     // compared to using swaps, which involves twice as many moves.\n-    fn siftup(&mut self, start: uint, mut pos: uint) {\n+    fn sift_up(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n             let new = replace(&mut self.data[pos], zeroed());\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n-                if new > self.data[parent] {\n-                    let x = replace(&mut self.data[parent], zeroed());\n-                    ptr::write(&mut self.data[pos], x);\n-                    pos = parent;\n-                    continue\n-                }\n-                break\n+\n+                if new <= self.data[parent] { break; }\n+\n+                let x = replace(&mut self.data[parent], zeroed());\n+                ptr::write(&mut self.data[pos], x);\n+                pos = parent;\n             }\n             ptr::write(&mut self.data[pos], new);\n         }\n     }\n \n-    fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n+    fn sift_down_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n             let new = replace(&mut self.data[pos], zeroed());\n@@ -540,33 +529,31 @@ impl<T: Ord> BinaryHeap<T> {\n             }\n \n             ptr::write(&mut self.data[pos], new);\n-            self.siftup(start, pos);\n+            self.sift_up(start, pos);\n         }\n     }\n \n-    fn siftdown(&mut self, pos: uint) {\n+    fn sift_down(&mut self, pos: uint) {\n         let len = self.len();\n-        self.siftdown_range(pos, len);\n+        self.sift_down_range(pos, len);\n     }\n \n-    /// Returns the length of the queue.\n+    /// Returns the length of the binary heap.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.data.len() }\n \n-    /// Returns true if the queue contains no elements\n+    /// Checks if the binary heap is empty.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Clears the queue, returning an iterator over the removed elements.\n+    /// Clears the binary heap, returning an iterator over the removed elements.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n-        Drain {\n-            iter: self.data.drain(),\n-        }\n+    pub fn drain(&mut self) -> Drain<T> {\n+        Drain { iter: self.data.drain() }\n     }\n \n-    /// Drops all items from the queue.\n+    /// Drops all items from the binary heap.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.drain(); }\n }"}]}