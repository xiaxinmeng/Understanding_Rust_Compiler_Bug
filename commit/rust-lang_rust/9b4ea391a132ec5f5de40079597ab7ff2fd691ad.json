{"sha": "9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "node_id": "C_kwDOAAsO6NoAKDliNGVhMzkxYTEzMmVjNWY1ZGU0MDA3OTU5N2FiN2ZmMmZkNjkxYWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T15:25:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T15:25:31Z"}, "message": "Auto merge of #100569 - matthiaskrgr:rollup-9450lzs, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #100211 (Refuse to codegen an upstream static.)\n - #100277 (Simplify format_args builtin macro implementation.)\n - #100483 (Point to generic or arg if it's the self type of unsatisfied projection predicate)\n - #100506 (change `InlineAsmCtxt` to not talk about `FnCtxt`)\n - #100534 (Make code slightly more uniform)\n - #100566 (Use `create_snapshot_for_diagnostic` instead of `clone` for `Parser`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8a46c02d7aa2be231291370f5a1b8ec96316ebad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a46c02d7aa2be231291370f5a1b8ec96316ebad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "html_url": "https://github.com/rust-lang/rust/commit/9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "html_url": "https://github.com/rust-lang/rust/commit/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c"}, {"sha": "fece51174be4fbd89a08cdbcad4533b856795cae", "url": "https://api.github.com/repos/rust-lang/rust/commits/fece51174be4fbd89a08cdbcad4533b856795cae", "html_url": "https://github.com/rust-lang/rust/commit/fece51174be4fbd89a08cdbcad4533b856795cae"}], "stats": {"total": 521, "additions": 301, "deletions": 220}, "files": [{"sha": "53c13873b1016f65dd6ab38ea06a0d28d419c2d9", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 64, "deletions": 90, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -130,64 +130,46 @@ impl PositionalNamedArgsLint {\n     /// CountIsParam, which contains an index into the arguments.\n     fn maybe_add_positional_named_arg(\n         &mut self,\n-        current_positional_arg: usize,\n-        total_args_length: usize,\n-        format_argument_index: usize,\n+        arg: Option<&FormatArg>,\n         ty: PositionalNamedArgType,\n         cur_piece: usize,\n         inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-        names: &FxHashMap<Symbol, (usize, Span)>,\n         has_formatting: bool,\n     ) {\n-        let start_of_named_args = total_args_length - names.len();\n-        if current_positional_arg >= start_of_named_args {\n-            self.maybe_push(\n-                format_argument_index,\n-                ty,\n-                cur_piece,\n-                inner_span_to_replace,\n-                names,\n-                has_formatting,\n-            )\n+        if let Some(arg) = arg {\n+            if let Some(name) = arg.name {\n+                self.push(name, ty, cur_piece, inner_span_to_replace, has_formatting)\n+            }\n         }\n     }\n \n-    /// Try constructing a PositionalNamedArg struct and pushing it into the vec of positional\n-    /// named arguments. If a named arg associated with `format_argument_index` cannot be found,\n-    /// a new item will not be added as the lint cannot be emitted in this case.\n-    fn maybe_push(\n+    /// Construct a PositionalNamedArg struct and push it into the vec of positional\n+    /// named arguments.\n+    fn push(\n         &mut self,\n-        format_argument_index: usize,\n+        arg_name: Ident,\n         ty: PositionalNamedArgType,\n         cur_piece: usize,\n         inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-        names: &FxHashMap<Symbol, (usize, Span)>,\n         has_formatting: bool,\n     ) {\n-        let named_arg = names\n-            .iter()\n-            .find(|&(_, &(index, _))| index == format_argument_index)\n-            .map(|found| found.clone());\n-\n-        if let Some((&replacement, &(_, positional_named_arg_span))) = named_arg {\n-            // In FormatSpec, `precision_span` starts at the leading `.`, which we want to keep in\n-            // the lint suggestion, so increment `start` by 1 when `PositionalArgumentType` is\n-            // `Precision`.\n-            let inner_span_to_replace = if ty == PositionalNamedArgType::Precision {\n-                inner_span_to_replace\n-                    .map(|is| rustc_parse_format::InnerSpan { start: is.start + 1, end: is.end })\n-            } else {\n-                inner_span_to_replace\n-            };\n-            self.positional_named_args.push(PositionalNamedArg {\n-                ty,\n-                cur_piece,\n-                inner_span_to_replace,\n-                replacement,\n-                positional_named_arg_span,\n-                has_formatting,\n-            });\n-        }\n+        // In FormatSpec, `precision_span` starts at the leading `.`, which we want to keep in\n+        // the lint suggestion, so increment `start` by 1 when `PositionalArgumentType` is\n+        // `Precision`.\n+        let inner_span_to_replace = if ty == PositionalNamedArgType::Precision {\n+            inner_span_to_replace\n+                .map(|is| rustc_parse_format::InnerSpan { start: is.start + 1, end: is.end })\n+        } else {\n+            inner_span_to_replace\n+        };\n+        self.positional_named_args.push(PositionalNamedArg {\n+            ty,\n+            cur_piece,\n+            inner_span_to_replace,\n+            replacement: arg_name.name,\n+            positional_named_arg_span: arg_name.span,\n+            has_formatting,\n+        });\n     }\n }\n \n@@ -211,15 +193,15 @@ struct Context<'a, 'b> {\n     /// * `arg_types` (in JSON): `[[0, 1, 0], [0, 1, 1], [0, 1]]`\n     /// * `arg_unique_types` (in simplified JSON): `[[\"o\", \"x\"], [\"o\", \"x\"], [\"o\", \"x\"]]`\n     /// * `names` (in JSON): `{\"foo\": 2}`\n-    args: Vec<P<ast::Expr>>,\n+    args: Vec<FormatArg>,\n     /// The number of arguments that were added by implicit capturing.\n     num_captured_args: usize,\n     /// Placeholder slot numbers indexed by argument.\n     arg_types: Vec<Vec<usize>>,\n     /// Unique format specs seen for each argument.\n     arg_unique_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<Symbol, (usize, Span)>,\n+    names: FxHashMap<Symbol, usize>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -282,7 +264,7 @@ struct Context<'a, 'b> {\n \n pub struct FormatArg {\n     expr: P<ast::Expr>,\n-    named: bool,\n+    name: Option<Ident>,\n }\n \n /// Parses the arguments from the given list of tokens, returning the diagnostic\n@@ -298,9 +280,9 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, (usize, Span)>)> {\n+) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, usize>)> {\n     let mut args = Vec::<FormatArg>::new();\n-    let mut names = FxHashMap::<Symbol, (usize, Span)>::default();\n+    let mut names = FxHashMap::<Symbol, usize>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -365,9 +347,9 @@ fn parse_args<'a>(\n                 p.bump();\n                 p.expect(&token::Eq)?;\n                 let e = p.parse_expr()?;\n-                if let Some((prev, _)) = names.get(&ident.name) {\n+                if let Some(&prev) = names.get(&ident.name) {\n                     ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n-                        .span_label(args[*prev].expr.span, \"previously here\")\n+                        .span_label(args[prev].expr.span, \"previously here\")\n                         .span_label(e.span, \"duplicate argument\")\n                         .emit();\n                     continue;\n@@ -378,8 +360,8 @@ fn parse_args<'a>(\n                 // if the input is valid, we can simply append to the positional\n                 // args. And remember the names.\n                 let slot = args.len();\n-                names.insert(ident.name, (slot, ident.span));\n-                args.push(FormatArg { expr: e, named: true });\n+                names.insert(ident.name, slot);\n+                args.push(FormatArg { expr: e, name: Some(ident) });\n             }\n             _ => {\n                 let e = p.parse_expr()?;\n@@ -389,12 +371,12 @@ fn parse_args<'a>(\n                         \"positional arguments cannot follow named arguments\",\n                     );\n                     err.span_label(e.span, \"positional arguments must be before named arguments\");\n-                    for pos in names.values() {\n-                        err.span_label(args[pos.0].expr.span, \"named argument\");\n+                    for &pos in names.values() {\n+                        err.span_label(args[pos].expr.span, \"named argument\");\n                     }\n                     err.emit();\n                 }\n-                args.push(FormatArg { expr: e, named: false });\n+                args.push(FormatArg { expr: e, name: None });\n             }\n         }\n     }\n@@ -410,8 +392,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&mut self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup =\n-            |s: &str| self.names.get(&Symbol::intern(s)).unwrap_or(&(0, Span::default())).0;\n+        let lookup = |s: &str| self.names.get(&Symbol::intern(s)).copied().unwrap_or(0);\n \n         match *p {\n             parse::String(_) => {}\n@@ -457,27 +438,21 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos = match arg.position {\n                     parse::ArgumentIs(i) => {\n                         self.unused_names_lint.maybe_add_positional_named_arg(\n-                            i,\n-                            self.args.len(),\n-                            i,\n+                            self.args.get(i),\n                             PositionalNamedArgType::Arg,\n                             self.curpiece,\n                             Some(arg.position_span),\n-                            &self.names,\n                             has_precision || has_width,\n                         );\n \n                         Exact(i)\n                     }\n                     parse::ArgumentImplicitlyIs(i) => {\n                         self.unused_names_lint.maybe_add_positional_named_arg(\n-                            i,\n-                            self.args.len(),\n-                            i,\n+                            self.args.get(i),\n                             PositionalNamedArgType::Arg,\n                             self.curpiece,\n                             None,\n-                            &self.names,\n                             has_precision || has_width,\n                         );\n                         Exact(i)\n@@ -563,13 +538,10 @@ impl<'a, 'b> Context<'a, 'b> {\n             parse::CountImplied | parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.unused_names_lint.maybe_add_positional_named_arg(\n-                    i,\n-                    self.args.len(),\n-                    i,\n+                    self.args.get(i),\n                     named_arg_type,\n                     self.curpiece,\n                     *inner_span,\n-                    &self.names,\n                     true,\n                 );\n                 self.verify_arg_type(Exact(i), Count);\n@@ -622,7 +594,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             );\n             for arg in &self.args {\n                 // Point at the arguments that will be formatted.\n-                e.span_label(arg.span, \"\");\n+                e.span_label(arg.expr.span, \"\");\n             }\n         } else {\n             let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n@@ -692,7 +664,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                         );\n                         if let Some(arg) = self.args.get(pos) {\n                             e.span_label(\n-                                arg.span,\n+                                arg.expr.span,\n                                 \"this parameter corresponds to the precision flag\",\n                             );\n                         }\n@@ -771,7 +743,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 match self.names.get(&name) {\n                     Some(&idx) => {\n                         // Treat as positional arg.\n-                        self.verify_arg_type(Capture(idx.0), ty)\n+                        self.verify_arg_type(Capture(idx), ty)\n                     }\n                     None => {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -787,8 +759,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                                 self.fmtsp\n                             };\n                             self.num_captured_args += 1;\n-                            self.args.push(self.ecx.expr_ident(span, Ident::new(name, span)));\n-                            self.names.insert(name, (idx, span));\n+                            self.args.push(FormatArg {\n+                                expr: self.ecx.expr_ident(span, Ident::new(name, span)),\n+                                name: Some(Ident::new(name, span)),\n+                            });\n+                            self.names.insert(name, idx);\n                             self.verify_arg_type(Capture(idx), ty)\n                         } else {\n                             let msg = format!(\"there is no argument named `{}`\", name);\n@@ -1054,11 +1029,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         // evaluated a single time each, in the order written by the programmer,\n         // and that the surrounding future/generator (if any) is Send whenever\n         // possible.\n-        let no_need_for_match =\n-            nicely_ordered && !original_args.iter().skip(1).any(|e| may_contain_yield_point(e));\n+        let no_need_for_match = nicely_ordered\n+            && !original_args.iter().skip(1).any(|arg| may_contain_yield_point(&arg.expr));\n \n         for (arg_index, arg_ty) in fmt_arg_index_and_ty {\n-            let e = &mut original_args[arg_index];\n+            let e = &mut original_args[arg_index].expr;\n             let span = e.span;\n             let arg = if no_need_for_match {\n                 let expansion_span = e.span.with_ctxt(self.macsp.ctxt());\n@@ -1087,7 +1062,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // span is otherwise unavailable in the MIR used by borrowck).\n                 let heads = original_args\n                     .into_iter()\n-                    .map(|e| self.ecx.expr_addr_of(e.span.with_ctxt(self.macsp.ctxt()), e))\n+                    .map(|arg| {\n+                        self.ecx.expr_addr_of(arg.expr.span.with_ctxt(self.macsp.ctxt()), arg.expr)\n+                    })\n                     .collect();\n \n                 let pat = self.ecx.pat_ident(self.macsp, Ident::new(sym::args, self.macsp));\n@@ -1220,7 +1197,7 @@ pub fn expand_preparsed_format_args(\n     sp: Span,\n     efmt: P<ast::Expr>,\n     args: Vec<FormatArg>,\n-    names: FxHashMap<Symbol, (usize, Span)>,\n+    names: FxHashMap<Symbol, usize>,\n     append_newline: bool,\n ) -> P<ast::Expr> {\n     // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n@@ -1312,16 +1289,17 @@ pub fn expand_preparsed_format_args(\n         if err.should_be_replaced_with_positional_argument {\n             let captured_arg_span =\n                 fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n-            let positional_args = args.iter().filter(|arg| !arg.named).collect::<Vec<_>>();\n+            let n_positional_args =\n+                args.iter().rposition(|arg| arg.name.is_none()).map_or(0, |i| i + 1);\n             if let Ok(arg) = ecx.source_map().span_to_snippet(captured_arg_span) {\n-                let span = match positional_args.last() {\n+                let span = match args[..n_positional_args].last() {\n                     Some(arg) => arg.expr.span,\n                     None => fmt_sp,\n                 };\n                 e.multipart_suggestion_verbose(\n                     \"consider using a positional formatting argument instead\",\n                     vec![\n-                        (captured_arg_span, positional_args.len().to_string()),\n+                        (captured_arg_span, n_positional_args.to_string()),\n                         (span.shrink_to_hi(), format!(\", {}\", arg)),\n                     ],\n                     Applicability::MachineApplicable,\n@@ -1338,11 +1316,9 @@ pub fn expand_preparsed_format_args(\n         .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n         .collect();\n \n-    let named_pos: FxHashSet<usize> = names.values().cloned().map(|(i, _)| i).collect();\n-\n     let mut cx = Context {\n         ecx,\n-        args: args.into_iter().map(|arg| arg.expr).collect(),\n+        args,\n         num_captured_args: 0,\n         arg_types,\n         arg_unique_types,\n@@ -1410,14 +1386,12 @@ pub fn expand_preparsed_format_args(\n         .enumerate()\n         .filter(|(i, ty)| ty.is_empty() && !cx.count_positions.contains_key(&i))\n         .map(|(i, _)| {\n-            let msg = if named_pos.contains(&i) {\n-                // named argument\n+            let msg = if cx.args[i].name.is_some() {\n                 \"named argument never used\"\n             } else {\n-                // positional argument\n                 \"argument never used\"\n             };\n-            (cx.args[i].span, msg)\n+            (cx.args[i].expr.span, msg)\n         })\n         .collect::<Vec<_>>();\n "}, {"sha": "96bbf5802e738c734f6dc9f3298f7dd36a34852b", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1027,6 +1027,11 @@ fn should_codegen_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx>) ->\n         return false;\n     }\n \n+    if let DefKind::Static(_) = tcx.def_kind(def_id) {\n+        // We cannot monomorphize statics from upstream crates.\n+        return false;\n+    }\n+\n     if !tcx.is_mir_available(def_id) {\n         bug!(\"no MIR available for {:?}\", def_id);\n     }"}, {"sha": "018f0ad71efc9b502fa140825e67e0af7f84ca08", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -590,7 +590,7 @@ impl<'a> Parser<'a> {\n             )\n         } else if expected.is_empty() {\n             (\n-                format!(\"unexpected token: {}\", actual),\n+                format!(\"unexpected token: {actual}\"),\n                 (self.prev_token.span, \"unexpected token after this\".to_string()),\n             )\n         } else {\n@@ -1497,7 +1497,7 @@ impl<'a> Parser<'a> {\n         MultiSugg {\n             msg: format!(\"use `{}= 1` instead\", kind.op.chr()),\n             patches: vec![\n-                (pre_span, format!(\"{{ let {} = \", tmp_var)),\n+                (pre_span, format!(\"{{ let {tmp_var} = \")),\n                 (post_span, format!(\"; {} {}= 1; {} }}\", base_src, kind.op.chr(), tmp_var)),\n             ],\n             applicability: Applicability::HasPlaceholders,"}, {"sha": "81d0e4733d0e43faf5ab74d19f1da18e281082d5", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -2309,7 +2309,7 @@ impl<'a> Parser<'a> {\n                 (pat, this.parse_ty_for_param()?)\n             } else {\n                 debug!(\"parse_param_general ident_to_pat\");\n-                let parser_snapshot_before_ty = this.clone();\n+                let parser_snapshot_before_ty = this.create_snapshot_for_diagnostic();\n                 this.eat_incorrect_doc_comment_for_param_type();\n                 let mut ty = this.parse_ty_for_param();\n                 if ty.is_ok()\n@@ -2332,7 +2332,7 @@ impl<'a> Parser<'a> {\n                     // Recover from attempting to parse the argument as a type without pattern.\n                     Err(err) => {\n                         err.cancel();\n-                        *this = parser_snapshot_before_ty;\n+                        this.restore_snapshot(parser_snapshot_before_ty);\n                         this.recover_arg_parse()?\n                     }\n                 }"}, {"sha": "aab60de80ef14e65592dea4556e3495a5e11367a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -58,7 +58,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"FnCtxt::check_asm: {} deferred checks\", deferred_asm_checks.len());\n         for (asm, hir_id) in deferred_asm_checks.drain(..) {\n             let enclosing_id = self.tcx.hir().enclosing_body_owner(hir_id);\n-            InlineAsmCtxt::new_in_fn(self)\n+            let get_operand_ty = |expr| {\n+                let ty = self.typeck_results.borrow().expr_ty_adjusted(expr);\n+                let ty = self.resolve_vars_if_possible(ty);\n+                if ty.has_infer_types_or_consts() {\n+                    assert!(self.is_tainted_by_errors());\n+                    self.tcx.ty_error()\n+                } else {\n+                    self.tcx.erase_regions(ty)\n+                }\n+            };\n+            InlineAsmCtxt::new_in_fn(self.tcx, self.param_env, get_operand_ty)\n                 .check_asm(asm, self.tcx.hir().local_def_id_to_hir_id(enclosing_id));\n         }\n     }\n@@ -1664,12 +1674,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ObligationCauseCode::ImplDerivedObligation(code) => {\n                         code.derived.parent_trait_pred.self_ty().skip_binder().into()\n                     }\n-                    _ if let ty::PredicateKind::Trait(predicate) =\n-                        error.obligation.predicate.kind().skip_binder() =>\n-                    {\n-                        predicate.self_ty().into()\n-                    }\n-                    _ => continue,\n+                    _ => match error.obligation.predicate.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(predicate) => predicate.self_ty().into(),\n+                        ty::PredicateKind::Projection(predicate) => {\n+                            predicate.projection_ty.self_ty().into()\n+                        }\n+                        _ => continue,\n+                    },\n                 };\n             let self_ = self.resolve_vars_if_possible(self_);\n             let ty_matches_self = |ty: Ty<'tcx>| ty.walk().any(|arg| arg == self_);\n@@ -1759,25 +1770,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n             if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = &path.kind {\n                 for error in errors {\n-                    if let ty::PredicateKind::Trait(predicate) =\n-                        error.obligation.predicate.kind().skip_binder()\n+                    let self_ty = match error.obligation.predicate.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(predicate) => predicate.self_ty(),\n+                        ty::PredicateKind::Projection(predicate) => {\n+                            predicate.projection_ty.self_ty()\n+                        }\n+                        _ => continue,\n+                    };\n+                    // If any of the type arguments in this path segment caused the\n+                    // `FulfillmentError`, point at its span (#61860).\n+                    for arg in path\n+                        .segments\n+                        .iter()\n+                        .filter_map(|seg| seg.args.as_ref())\n+                        .flat_map(|a| a.args.iter())\n                     {\n-                        // If any of the type arguments in this path segment caused the\n-                        // `FulfillmentError`, point at its span (#61860).\n-                        for arg in path\n-                            .segments\n-                            .iter()\n-                            .filter_map(|seg| seg.args.as_ref())\n-                            .flat_map(|a| a.args.iter())\n+                        if let hir::GenericArg::Type(hir_ty) = &arg\n+                            && let Some(ty) =\n+                                self.typeck_results.borrow().node_type_opt(hir_ty.hir_id)\n+                            && self.resolve_vars_if_possible(ty) == self_ty\n                         {\n-                            if let hir::GenericArg::Type(hir_ty) = &arg\n-                                && let Some(ty) =\n-                                    self.typeck_results.borrow().node_type_opt(hir_ty.hir_id)\n-                                && self.resolve_vars_if_possible(ty) == predicate.self_ty()\n-                            {\n-                                error.obligation.cause.span = hir_ty.span;\n-                                break;\n-                            }\n+                            error.obligation.cause.span = hir_ty.span;\n+                            break;\n                         }\n                     }\n                 }"}, {"sha": "721ebba6514779066e486d8214ebe3ab2bd76aea", "filename": "compiler/rustc_typeck/src/check/intrinsicck.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -9,7 +9,6 @@ use rustc_session::lint;\n use rustc_span::{Span, Symbol, DUMMY_SP};\n use rustc_target::abi::{Pointer, VariantIdx};\n use rustc_target::asm::{InlineAsmReg, InlineAsmRegClass, InlineAsmRegOrRegClass, InlineAsmType};\n-use rustc_trait_selection::infer::InferCtxtExt;\n \n use super::FnCtxt;\n \n@@ -98,62 +97,65 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         err.emit();\n     }\n+}\n+\n+pub struct InlineAsmCtxt<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    get_operand_ty: Box<dyn Fn(&'tcx hir::Expr<'tcx>) -> Ty<'tcx> + 'a>,\n+}\n+\n+impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n+    pub fn new_global_asm(tcx: TyCtxt<'tcx>) -> Self {\n+        InlineAsmCtxt {\n+            tcx,\n+            param_env: ty::ParamEnv::empty(),\n+            get_operand_ty: Box::new(|e| bug!(\"asm operand in global asm: {e:?}\")),\n+        }\n+    }\n+\n+    pub fn new_in_fn(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        get_operand_ty: impl Fn(&'tcx hir::Expr<'tcx>) -> Ty<'tcx> + 'a,\n+    ) -> Self {\n+        InlineAsmCtxt { tcx, param_env, get_operand_ty: Box::new(get_operand_ty) }\n+    }\n \n     // FIXME(compiler-errors): This could use `<$ty as Pointee>::Metadata == ()`\n     fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n         // Type still may have region variables, but `Sized` does not depend\n         // on those, so just erase them before querying.\n-        if self.tcx.erase_regions(ty).is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n             return true;\n         }\n         if let ty::Foreign(..) = ty.kind() {\n             return true;\n         }\n         false\n     }\n-}\n-\n-pub struct InlineAsmCtxt<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    fcx: Option<&'a FnCtxt<'a, 'tcx>>,\n-}\n-\n-impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n-    pub fn new_global_asm(tcx: TyCtxt<'tcx>) -> Self {\n-        InlineAsmCtxt { tcx, fcx: None }\n-    }\n-\n-    pub fn new_in_fn(fcx: &'a FnCtxt<'a, 'tcx>) -> Self {\n-        InlineAsmCtxt { tcx: fcx.tcx, fcx: Some(fcx) }\n-    }\n \n     fn check_asm_operand_type(\n         &self,\n         idx: usize,\n         reg: InlineAsmRegOrRegClass,\n-        expr: &hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n         template: &[InlineAsmTemplatePiece],\n         is_input: bool,\n-        tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n+        tied_input: Option<(&'tcx hir::Expr<'tcx>, Option<InlineAsmType>)>,\n         target_features: &FxHashSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n-        let fcx = self.fcx.unwrap_or_else(|| span_bug!(expr.span, \"asm operand for global asm\"));\n-        // Check the type against the allowed types for inline asm.\n-        let ty = fcx.typeck_results.borrow().expr_ty_adjusted(expr);\n-        let ty = fcx.resolve_vars_if_possible(ty);\n+        let ty = (self.get_operand_ty)(expr);\n+        if ty.has_infer_types_or_consts() {\n+            bug!(\"inference variable in asm operand ty: {:?} {:?}\", expr, ty);\n+        }\n         let asm_ty_isize = match self.tcx.sess.target.pointer_width {\n             16 => InlineAsmType::I16,\n             32 => InlineAsmType::I32,\n             64 => InlineAsmType::I64,\n             _ => unreachable!(),\n         };\n \n-        // Expect types to be fully resolved, no const or type variables.\n-        if ty.has_infer_types_or_consts() {\n-            assert!(fcx.is_tainted_by_errors());\n-            return None;\n-        }\n-\n         let asm_ty = match *ty.kind() {\n             // `!` is allowed for input but not for output (issue #87802)\n             ty::Never if is_input => return None,\n@@ -167,7 +169,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n             ty::Float(FloatTy::F32) => Some(InlineAsmType::F32),\n             ty::Float(FloatTy::F64) => Some(InlineAsmType::F64),\n             ty::FnPtr(_) => Some(asm_ty_isize),\n-            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if fcx.is_thin_ptr_ty(ty) => {\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if self.is_thin_ptr_ty(ty) => {\n                 Some(asm_ty_isize)\n             }\n             ty::Adt(adt, substs) if adt.repr().simd() => {\n@@ -219,7 +221,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n \n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n-        if !fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, ty, DUMMY_SP) {\n+        if !ty.is_copy_modulo_regions(self.tcx.at(expr.span), self.param_env) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(&format!(\"`{ty}` does not implement the Copy trait\"));\n@@ -240,8 +242,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                 let msg = \"incompatible types for asm inout argument\";\n                 let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n \n-                let in_expr_ty = fcx.typeck_results.borrow().expr_ty_adjusted(in_expr);\n-                let in_expr_ty = fcx.resolve_vars_if_possible(in_expr_ty);\n+                let in_expr_ty = (self.get_operand_ty)(in_expr);\n                 err.span_label(in_expr.span, &format!(\"type `{in_expr_ty}`\"));\n                 err.span_label(expr.span, &format!(\"type `{ty}`\"));\n                 err.note("}, {"sha": "5e094cb4d3379dade5b6370e60588dea744ab561", "filename": "src/test/run-make/issue-85401-static-mir/Makefile", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2FMakefile?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -0,0 +1,16 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+# Regression test for issue #85401\n+# Verify that we do not ICE when trying to access MIR for statics,\n+# but emit an error when linking.\n+\n+OUTPUT_FILE := $(TMPDIR)/build-output\n+\n+all:\n+\t$(RUSTC) --crate-type rlib --crate-name foo -Crelocation-model=pic --edition=2018 foo.rs -Zalways-encode-mir=yes --emit metadata -o $(TMPDIR)/libfoo.rmeta\n+\t$(RUSTC) --crate-type rlib --crate-name bar -Crelocation-model=pic --edition=2018 bar.rs -o $(TMPDIR)/libbar.rlib --extern=foo=$(TMPDIR)/libfoo.rmeta\n+\t$(RUSTC) --crate-type bin --crate-name baz -Crelocation-model=pic --edition=2018 baz.rs -o $(TMPDIR)/baz -L $(TMPDIR) --extern=bar=$(TMPDIR)/libbar.rlib > $(OUTPUT_FILE) 2>&1; [ $$? -eq 1 ]\n+\tcat  $(OUTPUT_FILE)\n+\t$(CGREP) 'crate `foo` required to be available in rlib format, but was not found in this form' < $(OUTPUT_FILE)\n+\t# -v tests are fragile, hopefully this text won't change\n+\t$(CGREP) -v \"internal compiler error\" < $(OUTPUT_FILE)"}, {"sha": "15b12ecf36ff05eb942c53f85b43678a9ebe9ba9", "filename": "src/test/run-make/issue-85401-static-mir/bar.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Fbar.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -0,0 +1,4 @@\n+pub fn bar() {\n+    println!(\"bar {}\", foo::FOO);\n+    foo::foo();\n+}"}, {"sha": "2ff4c51e5d278d9478174f0ca4569b3a19985ffe", "filename": "src/test/run-make/issue-85401-static-mir/baz.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Fbaz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Fbaz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Fbaz.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    bar::bar()\n+}"}, {"sha": "d064c454600ac41affa90a2e59d2201e04eaf231", "filename": "src/test/run-make/issue-85401-static-mir/foo.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-85401-static-mir%2Ffoo.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -0,0 +1,5 @@\n+pub static FOO: &str = \"foo\";\n+\n+pub fn foo() {\n+    println!(\"foo\");\n+}"}, {"sha": "a777e064f1a0ad8cc4617d97fe133660ae780d51", "filename": "src/test/ui/associated-types/associated-types-binding-to-type-defined-in-supertrait.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,10 @@\n error[E0271]: type mismatch resolving `<ModelT as Vehicle>::Color == Blue`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:31:10\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:31:19\n    |\n LL | fn b() { blue_car(ModelT); }\n-   |          ^^^^^^^^ type mismatch resolving `<ModelT as Vehicle>::Color == Blue`\n+   |          -------- ^^^^^^ type mismatch resolving `<ModelT as Vehicle>::Color == Blue`\n+   |          |\n+   |          required by a bound introduced by this call\n    |\n note: expected this to be `Blue`\n   --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:16:40\n@@ -16,10 +18,12 @@ LL | fn blue_car<C:Car<Color=Blue>>(c: C) {\n    |                   ^^^^^^^^^^ required by this bound in `blue_car`\n \n error[E0271]: type mismatch resolving `<ModelU as Vehicle>::Color == Black`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:32:10\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:32:20\n    |\n LL | fn c() { black_car(ModelU); }\n-   |          ^^^^^^^^^ type mismatch resolving `<ModelU as Vehicle>::Color == Black`\n+   |          --------- ^^^^^^ type mismatch resolving `<ModelU as Vehicle>::Color == Black`\n+   |          |\n+   |          required by a bound introduced by this call\n    |\n note: expected this to be `Black`\n   --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:21:40"}, {"sha": "19750fe1f333f74cc0d4cd89dfc0f5a478d95907", "filename": "src/test/ui/associated-types/associated-types-eq-3.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -14,10 +14,12 @@ LL | fn foo2<I: Foo<A = Bar>>(x: I) {\n    |               +++++++++\n \n error[E0271]: type mismatch resolving `<isize as Foo>::A == Bar`\n-  --> $DIR/associated-types-eq-3.rs:38:5\n+  --> $DIR/associated-types-eq-3.rs:38:10\n    |\n LL |     foo1(a);\n-   |     ^^^^ type mismatch resolving `<isize as Foo>::A == Bar`\n+   |     ---- ^ type mismatch resolving `<isize as Foo>::A == Bar`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n note: expected this to be `Bar`\n   --> $DIR/associated-types-eq-3.rs:12:14\n@@ -34,7 +36,9 @@ error[E0271]: type mismatch resolving `<isize as Foo>::A == Bar`\n   --> $DIR/associated-types-eq-3.rs:40:9\n    |\n LL |     baz(&a);\n-   |         ^^ type mismatch resolving `<isize as Foo>::A == Bar`\n+   |     --- ^^ type mismatch resolving `<isize as Foo>::A == Bar`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n note: expected this to be `Bar`\n   --> $DIR/associated-types-eq-3.rs:12:14"}, {"sha": "6cff403b318c193cd0e55e213debb9b6c772a1db", "filename": "src/test/ui/associated-types/associated-types-eq-hr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,8 @@\n error[E0271]: type mismatch resolving `for<'x> <UintStruct as TheTrait<&'x isize>>::A == &'x isize`\n-  --> $DIR/associated-types-eq-hr.rs:87:5\n+  --> $DIR/associated-types-eq-hr.rs:87:11\n    |\n LL |     foo::<UintStruct>();\n-   |     ^^^^^^^^^^^^^^^^^ type mismatch resolving `for<'x> <UintStruct as TheTrait<&'x isize>>::A == &'x isize`\n+   |           ^^^^^^^^^^ type mismatch resolving `for<'x> <UintStruct as TheTrait<&'x isize>>::A == &'x isize`\n    |\n note: expected this to be `&isize`\n   --> $DIR/associated-types-eq-hr.rs:26:14\n@@ -21,10 +21,10 @@ LL |     T: for<'x> TheTrait<&'x isize, A = &'x isize>,\n    |                                    ^^^^^^^^^^^^^ required by this bound in `foo`\n \n error[E0271]: type mismatch resolving `for<'x> <IntStruct as TheTrait<&'x isize>>::A == &'x usize`\n-  --> $DIR/associated-types-eq-hr.rs:91:5\n+  --> $DIR/associated-types-eq-hr.rs:91:11\n    |\n LL |     bar::<IntStruct>();\n-   |     ^^^^^^^^^^^^^^^^ type mismatch resolving `for<'x> <IntStruct as TheTrait<&'x isize>>::A == &'x usize`\n+   |           ^^^^^^^^^ type mismatch resolving `for<'x> <IntStruct as TheTrait<&'x isize>>::A == &'x usize`\n    |\n note: expected this to be `&usize`\n   --> $DIR/associated-types-eq-hr.rs:14:14"}, {"sha": "b1708b96e525403771b8e642a9098f29320d8240", "filename": "src/test/ui/associated-types/associated-types-issue-20346.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-issue-20346.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-issue-20346.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-issue-20346.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,11 +1,13 @@\n error[E0271]: type mismatch resolving `<Adapter<I> as Iterator>::Item == Option<T>`\n-  --> $DIR/associated-types-issue-20346.rs:34:5\n+  --> $DIR/associated-types-issue-20346.rs:34:36\n    |\n LL | fn test_adapter<T, I: Iterator<Item=Option<T>>>(it: I) {\n    |                 - this type parameter\n ...\n LL |     is_iterator_of::<Option<T>, _>(&adapter);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Adapter<I> as Iterator>::Item == Option<T>`\n+   |     ------------------------------ ^^^^^^^^ type mismatch resolving `<Adapter<I> as Iterator>::Item == Option<T>`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n note: expected this to be `Option<T>`\n   --> $DIR/associated-types-issue-20346.rs:23:17"}, {"sha": "89cdba524be23b1ed4cc30f86e621b0ee483f469", "filename": "src/test/ui/associated-types/associated-types-multiple-types-one-trait.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-multiple-types-one-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-multiple-types-one-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-multiple-types-one-trait.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,10 @@\n error[E0271]: type mismatch resolving `<T as Foo>::Y == i32`\n-  --> $DIR/associated-types-multiple-types-one-trait.rs:13:5\n+  --> $DIR/associated-types-multiple-types-one-trait.rs:13:12\n    |\n LL |     want_y(t);\n-   |     ^^^^^^ expected `i32`, found associated type\n+   |     ------ ^ expected `i32`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:         expected type `i32`\n            found associated type `<T as Foo>::Y`\n@@ -17,10 +19,12 @@ LL | fn have_x_want_y<T:Foo<X=u32, Y = i32>>(t: &T)\n    |                             +++++++++\n \n error[E0271]: type mismatch resolving `<T as Foo>::X == u32`\n-  --> $DIR/associated-types-multiple-types-one-trait.rs:18:5\n+  --> $DIR/associated-types-multiple-types-one-trait.rs:18:12\n    |\n LL |     want_x(t);\n-   |     ^^^^^^ expected `u32`, found associated type\n+   |     ------ ^ expected `u32`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:         expected type `u32`\n            found associated type `<T as Foo>::X`"}, {"sha": "f24423dd106669af20debca20e3016509ac3a571", "filename": "src/test/ui/associated-types/issue-87261.stderr", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,10 @@\n error[E0271]: type mismatch resolving `<A as Trait>::Associated == ()`\n-  --> $DIR/issue-87261.rs:56:5\n+  --> $DIR/issue-87261.rs:56:19\n    |\n LL |     accepts_trait(a);\n-   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     ------------- ^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<A as Trait>::Associated`\n@@ -17,10 +19,12 @@ LL |     A: Trait<Associated = ()> + 'static,\n    |             +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<B as Trait>::Associated == ()`\n-  --> $DIR/issue-87261.rs:59:5\n+  --> $DIR/issue-87261.rs:59:19\n    |\n LL |     accepts_trait(b);\n-   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     ------------- ^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<B as Trait>::Associated`\n@@ -33,10 +37,12 @@ LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n    |                           ^^^^^^^^^^^^^^^ required by this bound in `accepts_trait`\n \n error[E0271]: type mismatch resolving `<C as Trait>::Associated == ()`\n-  --> $DIR/issue-87261.rs:62:5\n+  --> $DIR/issue-87261.rs:62:19\n    |\n LL |     accepts_trait(c);\n-   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     ------------- ^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<C as Trait>::Associated`\n@@ -51,10 +57,12 @@ LL |     C: Trait<Associated = ()> + Foo,\n    |             +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<D as Trait>::Associated == ()`\n-  --> $DIR/issue-87261.rs:65:5\n+  --> $DIR/issue-87261.rs:65:19\n    |\n LL |     accepts_trait(d);\n-   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     ------------- ^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<D as Trait>::Associated`\n@@ -67,10 +75,12 @@ LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n    |                           ^^^^^^^^^^^^^^^ required by this bound in `accepts_trait`\n \n error[E0271]: type mismatch resolving `<E as GenericTrait<()>>::Associated == ()`\n-  --> $DIR/issue-87261.rs:68:5\n+  --> $DIR/issue-87261.rs:68:27\n    |\n LL |     accepts_generic_trait(e);\n-   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     --------------------- ^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<E as GenericTrait<()>>::Associated`\n@@ -85,10 +95,12 @@ LL |     E: GenericTrait<(), Associated = ()> + 'static,\n    |                       +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<F as GenericTrait<()>>::Associated == ()`\n-  --> $DIR/issue-87261.rs:71:5\n+  --> $DIR/issue-87261.rs:71:27\n    |\n LL |     accepts_generic_trait(f);\n-   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     --------------------- ^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<F as GenericTrait<()>>::Associated`\n@@ -103,10 +115,12 @@ LL |     F: GenericTrait<(), Associated = ()> + Foo,\n    |                       +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<G as GenericTrait<()>>::Associated == ()`\n-  --> $DIR/issue-87261.rs:74:5\n+  --> $DIR/issue-87261.rs:74:27\n    |\n LL |     accepts_generic_trait(g);\n-   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     --------------------- ^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<G as GenericTrait<()>>::Associated`\n@@ -119,13 +133,15 @@ LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n    |                                              ^^^^^^^^^^^^^^^ required by this bound in `accepts_generic_trait`\n \n error[E0271]: type mismatch resolving `<impl Trait as Trait>::Associated == ()`\n-  --> $DIR/issue-87261.rs:79:5\n+  --> $DIR/issue-87261.rs:79:19\n    |\n LL | fn returns_opaque() -> impl Trait + 'static {\n    |                        -------------------- the found opaque type\n ...\n LL |     accepts_trait(returns_opaque());\n-   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     ------------- ^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<impl Trait as Trait>::Associated`\n@@ -140,13 +156,15 @@ LL | fn returns_opaque() -> impl Trait<Associated = ()> + 'static {\n    |                                  +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n-  --> $DIR/issue-87261.rs:82:5\n+  --> $DIR/issue-87261.rs:82:19\n    |\n LL | fn returns_opaque_derived() -> impl DerivedTrait + 'static {\n    |                                --------------------------- the found opaque type\n ...\n LL |     accepts_trait(returns_opaque_derived());\n-   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     ------------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<impl DerivedTrait as Trait>::Associated`\n@@ -161,13 +179,15 @@ LL | fn returns_opaque_derived() -> impl DerivedTrait<Associated = ()> + 'static\n    |                                                 +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<impl Trait + Foo as Trait>::Associated == ()`\n-  --> $DIR/issue-87261.rs:85:5\n+  --> $DIR/issue-87261.rs:85:19\n    |\n LL | fn returns_opaque_foo() -> impl Trait + Foo {\n    |                            ---------------- the found opaque type\n ...\n LL |     accepts_trait(returns_opaque_foo());\n-   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     ------------- ^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<impl Trait + Foo as Trait>::Associated`\n@@ -182,13 +202,15 @@ LL | fn returns_opaque_foo() -> impl Trait<Associated = ()> + Foo {\n    |                                      +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<impl DerivedTrait + Foo as Trait>::Associated == ()`\n-  --> $DIR/issue-87261.rs:88:5\n+  --> $DIR/issue-87261.rs:88:19\n    |\n LL | fn returns_opaque_derived_foo() -> impl DerivedTrait + Foo {\n    |                                    ----------------------- the found opaque type\n ...\n LL |     accepts_trait(returns_opaque_derived_foo());\n-   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     ------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<impl DerivedTrait + Foo as Trait>::Associated`\n@@ -201,13 +223,15 @@ LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n    |                           ^^^^^^^^^^^^^^^ required by this bound in `accepts_trait`\n \n error[E0271]: type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n-  --> $DIR/issue-87261.rs:91:5\n+  --> $DIR/issue-87261.rs:91:27\n    |\n LL | fn returns_opaque_generic() -> impl GenericTrait<()> + 'static {\n    |                                ------------------------------- the found opaque type\n ...\n LL |     accepts_generic_trait(returns_opaque_generic());\n-   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<impl GenericTrait<()> as GenericTrait<()>>::Associated`\n@@ -222,13 +246,15 @@ LL | fn returns_opaque_generic() -> impl GenericTrait<(), Associated = ()> + 'st\n    |                                                    +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated == ()`\n-  --> $DIR/issue-87261.rs:94:5\n+  --> $DIR/issue-87261.rs:94:27\n    |\n LL | fn returns_opaque_generic_foo() -> impl GenericTrait<()> + Foo {\n    |                                    --------------------------- the found opaque type\n ...\n LL |     accepts_generic_trait(returns_opaque_generic_foo());\n-   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated`\n@@ -243,13 +269,15 @@ LL | fn returns_opaque_generic_foo() -> impl GenericTrait<(), Associated = ()> +\n    |                                                        +++++++++++++++++\n \n error[E0271]: type mismatch resolving `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n-  --> $DIR/issue-87261.rs:97:5\n+  --> $DIR/issue-87261.rs:97:27\n    |\n LL | fn returns_opaque_generic_duplicate() -> impl GenericTrait<()> + GenericTrait<u8> {\n    |                                          ---------------------------------------- the found opaque type\n ...\n LL |     accepts_generic_trait(returns_opaque_generic_duplicate());\n-   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n            found associated type `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated`"}, {"sha": "1e2f4383459e2e40a8d2e16f9ad2eafa549515f1", "filename": "src/test/ui/error-codes/E0271.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ferror-codes%2FE0271.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ferror-codes%2FE0271.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0271.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,10 @@\n error[E0271]: type mismatch resolving `<i8 as Trait>::AssociatedType == u32`\n-  --> $DIR/E0271.rs:10:5\n+  --> $DIR/E0271.rs:10:9\n    |\n LL |     foo(3_i8);\n-   |     ^^^ type mismatch resolving `<i8 as Trait>::AssociatedType == u32`\n+   |     --- ^^^^ type mismatch resolving `<i8 as Trait>::AssociatedType == u32`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n note: expected this to be `u32`\n   --> $DIR/E0271.rs:7:43"}, {"sha": "7c2935d32bfd2a582f10df477a59c8713b958708", "filename": "src/test/ui/generic-associated-types/issue-74684-2.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74684-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74684-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74684-2.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,10 @@\n error[E0271]: type mismatch resolving `<{integer} as Fun>::F<'_> == [u8]`\n-  --> $DIR/issue-74684-2.rs:23:5\n+  --> $DIR/issue-74684-2.rs:23:9\n    |\n LL |     bug(Box::new(x));\n-   |     ^^^ type mismatch resolving `<{integer} as Fun>::F<'_> == [u8]`\n+   |     --- ^^^^^^^^^^^ type mismatch resolving `<{integer} as Fun>::F<'_> == [u8]`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n note: expected this to be `[u8]`\n   --> $DIR/issue-74684-2.rs:10:18"}, {"sha": "e70f6fc3430f67726e0192f0119ffd3657d5cff2", "filename": "src/test/ui/higher-rank-trait-bounds/issue-62203-hrtb-ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.rs?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -36,9 +36,9 @@ trait Ty<'a> {\n \n fn main() {\n     let v = Unit2.m(\n-        //~^ ERROR type mismatch\n         L {\n             //~^ ERROR to be a closure that returns `Unit3`, but it returns `Unit4`\n+            //~| ERROR type mismatch\n             f: |x| {\n                 drop(x);\n                 Unit4"}, {"sha": "51017ffbd41928f12e028bded3ae04f1069ef29d", "filename": "src/test/ui/higher-rank-trait-bounds/issue-62203-hrtb-ice.stderr", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,16 @@\n error[E0271]: type mismatch resolving `for<'r> <L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n-  --> $DIR/issue-62203-hrtb-ice.rs:38:19\n+  --> $DIR/issue-62203-hrtb-ice.rs:39:9\n    |\n-LL |     let v = Unit2.m(\n-   |                   ^ type mismatch resolving `for<'r> <L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n+LL |       let v = Unit2.m(\n+   |                     - required by a bound introduced by this call\n+LL | /         L {\n+LL | |\n+LL | |\n+LL | |             f: |x| {\n+...  |\n+LL | |             },\n+LL | |         },\n+   | |_________^ type mismatch resolving `for<'r> <L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n    |\n note: expected this to be `<_ as Ty<'_>>::V`\n   --> $DIR/issue-62203-hrtb-ice.rs:21:14\n@@ -23,16 +31,15 @@ LL |         F: for<'r> T0<'r, (<Self as Ty<'r>>::V,), O = <B as Ty<'r>>::V>,\n    |                                                   ^^^^^^^^^^^^^^^^^^^^ required by this bound in `T1::m`\n \n error[E0271]: expected `[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]` to be a closure that returns `Unit3`, but it returns `Unit4`\n-  --> $DIR/issue-62203-hrtb-ice.rs:40:9\n+  --> $DIR/issue-62203-hrtb-ice.rs:39:9\n    |\n LL |       let v = Unit2.m(\n    |                     - required by a bound introduced by this call\n-LL |\n LL | /         L {\n LL | |\n+LL | |\n LL | |             f: |x| {\n-LL | |                 drop(x);\n-LL | |                 Unit4\n+...  |\n LL | |             },\n LL | |         },\n    | |_________^ expected struct `Unit3`, found struct `Unit4`"}, {"sha": "1a761ad5441cea3887270de031594c2bb21cc138", "filename": "src/test/ui/intrinsics/const-eval-select-bad.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -52,10 +52,12 @@ LL |     G: FnOnce<ARG, Output = RET> + ~const Destruct,\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n error[E0271]: expected `fn(i32) -> bool {bar}` to be a fn item that returns `i32`, but it returns `bool`\n-  --> $DIR/const-eval-select-bad.rs:29:5\n+  --> $DIR/const-eval-select-bad.rs:29:34\n    |\n LL |     const_eval_select((1,), foo, bar);\n-   |     ^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`\n+   |     -----------------            ^^^ expected `i32`, found `bool`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL"}, {"sha": "00fdb37534613cb828a21a770606928fc317c043", "filename": "src/test/ui/traits/associated_type_bound/check-trait-object-bounds-5.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-5.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,10 @@\n error[E0271]: type mismatch resolving `<i32 as Is>::T == i64`\n-  --> $DIR/check-trait-object-bounds-5.rs:23:5\n+  --> $DIR/check-trait-object-bounds-5.rs:23:12\n    |\n LL |     is_obj(x)\n-   |     ^^^^^^ type mismatch resolving `<i32 as Is>::T == i64`\n+   |     ------ ^ type mismatch resolving `<i32 as Is>::T == i64`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n note: expected this to be `i64`\n   --> $DIR/check-trait-object-bounds-5.rs:9:14"}, {"sha": "9b0975e5ed3c3532e38d2507ccbb1dad0cfb143a", "filename": "src/test/ui/traits/associated_type_bound/check-trait-object-bounds-6.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-6.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,10 @@\n error[E0271]: type mismatch resolving `<i32 as Is>::T == i64`\n-  --> $DIR/check-trait-object-bounds-6.rs:20:5\n+  --> $DIR/check-trait-object-bounds-6.rs:20:12\n    |\n LL |     is_obj(x)\n-   |     ^^^^^^ type mismatch resolving `<i32 as Is>::T == i64`\n+   |     ------ ^ type mismatch resolving `<i32 as Is>::T == i64`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n note: expected this to be `i64`\n   --> $DIR/check-trait-object-bounds-6.rs:9:14"}, {"sha": "cbf09386654472d50aa65a437d43b7f696e4620a", "filename": "src/test/ui/traits/object/enforce-supertrait-projection.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fenforce-supertrait-projection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fenforce-supertrait-projection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fenforce-supertrait-projection.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,12 +1,12 @@\n error[E0271]: type mismatch resolving `<dyn Trait<B = B, A = A> as SuperTrait>::A == B`\n-  --> $DIR/enforce-supertrait-projection.rs:9:5\n+  --> $DIR/enforce-supertrait-projection.rs:9:17\n    |\n LL | fn transmute<A, B>(x: A) -> B {\n    |              -  - expected type parameter\n    |              |\n    |              found type parameter\n LL |     foo::<A, B, dyn Trait<A = A, B = B>>(x)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `B`, found type parameter `A`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `B`, found type parameter `A`\n    |\n    = note: expected type parameter `B`\n               found type parameter `A`"}, {"sha": "0c3d7060dd7c30294ec93937ffa37993c7bf5485", "filename": "src/test/ui/traits/pointee-tail-is-generic-errors.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b4ea391a132ec5f5de40079597ab7ff2fd691ad/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.stderr?ref=9b4ea391a132ec5f5de40079597ab7ff2fd691ad", "patch": "@@ -1,8 +1,8 @@\n error[E0271]: type mismatch resolving `<T as Pointee>::Metadata == ()`\n-  --> $DIR/pointee-tail-is-generic-errors.rs:13:5\n+  --> $DIR/pointee-tail-is-generic-errors.rs:13:15\n    |\n LL |     is_thin::<T>();\n-   |     ^^^^^^^^^^^^ expected `()`, found associated type\n+   |               ^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n            found associated type `<T as Pointee>::Metadata`\n@@ -15,13 +15,13 @@ LL | fn is_thin<T: std::ptr::Pointee<Metadata = ()> + ?Sized>() {}\n    |                                 ^^^^^^^^^^^^^ required by this bound in `is_thin`\n \n error[E0271]: type mismatch resolving `<Opaque as Pointee>::Metadata == ()`\n-  --> $DIR/pointee-tail-is-generic-errors.rs:16:5\n+  --> $DIR/pointee-tail-is-generic-errors.rs:16:15\n    |\n LL | type Opaque = impl std::fmt::Debug + ?Sized;\n    |               ----------------------------- the found opaque type\n ...\n LL |     is_thin::<Opaque>();\n-   |     ^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |               ^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n            found associated type `<Opaque as Pointee>::Metadata`"}]}