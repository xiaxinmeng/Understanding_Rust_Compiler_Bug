{"sha": "5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab", "node_id": "C_kwDOAAsO6NoAKDViNTdlNWNlYzg0YTljM2MyZjYyNDBjOWYwZjQwNzFmMzkxZmU2YWI", "commit": {"author": {"name": "bluthej", "email": "joffrey.bluthe@e.email", "date": "2023-04-09T10:20:59Z"}, "committer": {"name": "bluthej", "email": "joffrey.bluthe@e.email", "date": "2023-04-09T10:33:20Z"}, "message": "Fix false negative with `String` and add tests\n\n`String` is currently not a diagnostic item so it needs special\ntreatment", "tree": {"sha": "1ed5e4da1479317ea7a83e77600e395e7efb12f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ed5e4da1479317ea7a83e77600e395e7efb12f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab", "html_url": "https://github.com/rust-lang/rust/commit/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/comments", "author": {"login": "bluthej", "id": 29771403, "node_id": "MDQ6VXNlcjI5NzcxNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/29771403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluthej", "html_url": "https://github.com/bluthej", "followers_url": "https://api.github.com/users/bluthej/followers", "following_url": "https://api.github.com/users/bluthej/following{/other_user}", "gists_url": "https://api.github.com/users/bluthej/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluthej/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluthej/subscriptions", "organizations_url": "https://api.github.com/users/bluthej/orgs", "repos_url": "https://api.github.com/users/bluthej/repos", "events_url": "https://api.github.com/users/bluthej/events{/privacy}", "received_events_url": "https://api.github.com/users/bluthej/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluthej", "id": 29771403, "node_id": "MDQ6VXNlcjI5NzcxNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/29771403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluthej", "html_url": "https://github.com/bluthej", "followers_url": "https://api.github.com/users/bluthej/followers", "following_url": "https://api.github.com/users/bluthej/following{/other_user}", "gists_url": "https://api.github.com/users/bluthej/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluthej/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluthej/subscriptions", "organizations_url": "https://api.github.com/users/bluthej/orgs", "repos_url": "https://api.github.com/users/bluthej/repos", "events_url": "https://api.github.com/users/bluthej/events{/privacy}", "received_events_url": "https://api.github.com/users/bluthej/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ec542873cde1332baf2a0ed33088ba98eba25cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ec542873cde1332baf2a0ed33088ba98eba25cf", "html_url": "https://github.com/rust-lang/rust/commit/9ec542873cde1332baf2a0ed33088ba98eba25cf"}], "stats": {"total": 782, "additions": 675, "deletions": 107}, "files": [{"sha": "6ce3fdae40749376f47ff0444c2d845d03e80314", "filename": "clippy_lints/src/methods/clear_with_drain.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs?ref=5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab", "patch": "@@ -1,16 +1,17 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::is_range_full;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_hir::{Expr, ExprKind, LangItem, QPath};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n use super::CLEAR_WITH_DRAIN;\n \n-const ACCEPTABLE_TYPES_WITH_ARG: [rustc_span::Symbol; 3] = [sym::String, sym::Vec, sym::VecDeque];\n+// Add `String` here when it is added to diagnostic items\n+const ACCEPTABLE_TYPES_WITH_ARG: [rustc_span::Symbol; 2] = [sym::Vec, sym::VecDeque];\n \n const ACCEPTABLE_TYPES_WITHOUT_ARG: [rustc_span::Symbol; 3] = [sym::BinaryHeap, sym::HashMap, sym::HashSet];\n \n@@ -30,11 +31,14 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span\n fn match_acceptable_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>, types: &[rustc_span::Symbol]) -> bool {\n     let expr_ty = cx.typeck_results().expr_ty(expr).peel_refs();\n     types.iter().any(|&ty| is_type_diagnostic_item(cx, expr_ty, ty))\n+    // String type is a lang item but not a diagnostic item for now so we need a separate check\n+        || is_type_lang_item(cx, expr_ty, LangItem::String)\n }\n \n fn suggest(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span) {\n     if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n-        && let Some(ty_name) = cx.tcx.get_diagnostic_name(adt.did())\n+    // Use `opt_item_name` while `String` is not a diagnostic item\n+        && let Some(ty_name) = cx.tcx.opt_item_name(adt.did())\n     {\n         span_lint_and_sugg(\n             cx,"}, {"sha": "2d9545eeed1972186b3a8b36b1a0ea14be266958", "filename": "tests/ui/clear_with_drain.fixed", "status": "modified", "additions": 291, "deletions": 42, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/tests%2Fui%2Fclear_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/tests%2Fui%2Fclear_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.fixed?ref=5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab", "patch": "@@ -2,108 +2,357 @@\n #![allow(unused)]\n #![warn(clippy::clear_with_drain)]\n \n-use std::collections::BinaryHeap;\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n-use std::collections::VecDeque;\n+use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\n \n-fn range() {\n+fn vec_range() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(0..v.len()); // Yay\n+    let iter = v.drain(0..v.len());\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    let n = v.drain(0..v.len()).count(); // Yay\n+    let n = v.drain(0..v.len()).count();\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(usize::MIN..v.len()); // Yay\n+    let iter = v.drain(usize::MIN..v.len());\n     let n = iter.count();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n }\n \n-fn range_from() {\n+fn vec_range_from() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(0..); // Yay\n+    let iter = v.drain(0..);\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let mut iter = v.drain(0..); // Yay\n+    let mut iter = v.drain(0..);\n     let next = iter.next();\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    let next = v.drain(usize::MIN..).next(); // Yay\n+    let next = v.drain(usize::MIN..).next();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n }\n \n-fn range_full() {\n+fn vec_range_full() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..); // Yay\n+    let iter = v.drain(..);\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    // Yay\n     for x in v.drain(..) {\n         let y = format!(\"x = {x}\");\n     }\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n }\n \n-fn range_to() {\n+fn vec_range_to() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..v.len()); // Yay\n+    let iter = v.drain(..v.len());\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..v.len()); // Yay\n+    let iter = v.drain(..v.len());\n     for x in iter {\n         let y = format!(\"x = {x}\");\n     }\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n }\n \n-fn partial_drains() {\n+fn vec_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n     let mut v = vec![1, 2, 3];\n-    v.drain(1..); // Yay\n+    v.drain(1..);\n     let mut v = vec![1, 2, 3];\n-    v.drain(1..).max(); // Yay\n+    v.drain(1..).max();\n \n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len() - 1); // Yay\n+    v.drain(..v.len() - 1);\n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len() - 1).min(); // Yay\n+    v.drain(..v.len() - 1).min();\n \n     let mut v = vec![1, 2, 3];\n-    v.drain(1..v.len() - 1); // Yay\n+    v.drain(1..v.len() - 1);\n     let mut v = vec![1, 2, 3];\n-    let w: Vec<i8> = v.drain(1..v.len() - 1).collect(); // Yay\n+    let w: Vec<i8> = v.drain(1..v.len() - 1).collect();\n+}\n+\n+fn vec_deque_range() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..deque.len());\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let n = deque.drain(0..deque.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(usize::MIN..deque.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let mut iter = deque.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let next = deque.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    for x in deque.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n }\n \n-fn main() {\n-    let mut deque: VecDeque<_> = [1, 2, 3].into();\n+fn vec_deque_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n     deque.clear();\n+}\n+\n+fn vec_deque_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..).max();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1).min();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let w: Vec<i8> = deque.drain(1..deque.len() - 1).collect();\n+}\n+\n+fn string_range() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..s.len());\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let n = s.drain(0..s.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(usize::MIN..s.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n \n+fn string_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let mut iter = s.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let next = s.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    for x in s.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..).max();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1).min();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    let w: String = s.drain(1..s.len() - 1).collect();\n+}\n+\n+fn hash_set() {\n+    // Do not lint because iterator is assigned\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let iter = set.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let mut iter = set.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let next = set.drain().next();\n+\n+    // Do lint\n     let mut set = HashSet::from([1, 2, 3]);\n     set.clear();\n+}\n \n-    let mut a = HashMap::new();\n-    a.insert(1, \"a\");\n-    a.insert(2, \"b\");\n-    a.clear();\n+fn hash_map() {\n+    // Do not lint because iterator is assigned\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let iter = map.drain();\n \n-    let mut heap = BinaryHeap::from([1, 3]);\n-    heap.clear();\n+    // Do not lint because iterator is assigned and used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let mut iter = map.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let next = map.drain().next();\n \n-    // Not firing for now because `String` is not reckognized by `is_type_diagnostic_item`\n-    let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n-    s.drain(..);\n+    // Do lint\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    map.clear();\n }\n+\n+fn binary_heap() {\n+    // Do not lint because iterator is assigned\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let iter = heap.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let mut iter = heap.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let next = heap.drain().next();\n+\n+    // Do lint\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    heap.clear();\n+}\n+\n+fn main() {}"}, {"sha": "4d60ee46e1865bb12ab1b58cc04491d301052ff5", "filename": "tests/ui/clear_with_drain.rs", "status": "modified", "additions": 291, "deletions": 42, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/tests%2Fui%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/tests%2Fui%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.rs?ref=5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab", "patch": "@@ -2,108 +2,357 @@\n #![allow(unused)]\n #![warn(clippy::clear_with_drain)]\n \n-use std::collections::BinaryHeap;\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n-use std::collections::VecDeque;\n+use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\n \n-fn range() {\n+fn vec_range() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(0..v.len()); // Yay\n+    let iter = v.drain(0..v.len());\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    let n = v.drain(0..v.len()).count(); // Yay\n+    let n = v.drain(0..v.len()).count();\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(usize::MIN..v.len()); // Yay\n+    let iter = v.drain(usize::MIN..v.len());\n     let n = iter.count();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(0..v.len()); // Nay\n+    v.drain(0..v.len());\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(usize::MIN..v.len()); // Nay\n+    v.drain(usize::MIN..v.len());\n }\n \n-fn range_from() {\n+fn vec_range_from() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(0..); // Yay\n+    let iter = v.drain(0..);\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let mut iter = v.drain(0..); // Yay\n+    let mut iter = v.drain(0..);\n     let next = iter.next();\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    let next = v.drain(usize::MIN..).next(); // Yay\n+    let next = v.drain(usize::MIN..).next();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(0..); // Nay\n+    v.drain(0..);\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(usize::MIN..); // Nay\n+    v.drain(usize::MIN..);\n }\n \n-fn range_full() {\n+fn vec_range_full() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..); // Yay\n+    let iter = v.drain(..);\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    // Yay\n     for x in v.drain(..) {\n         let y = format!(\"x = {x}\");\n     }\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(..); // Nay\n+    v.drain(..);\n }\n \n-fn range_to() {\n+fn vec_range_to() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..v.len()); // Yay\n+    let iter = v.drain(..v.len());\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..v.len()); // Yay\n+    let iter = v.drain(..v.len());\n     for x in iter {\n         let y = format!(\"x = {x}\");\n     }\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len()); // Nay\n+    v.drain(..v.len());\n }\n \n-fn partial_drains() {\n+fn vec_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n     let mut v = vec![1, 2, 3];\n-    v.drain(1..); // Yay\n+    v.drain(1..);\n     let mut v = vec![1, 2, 3];\n-    v.drain(1..).max(); // Yay\n+    v.drain(1..).max();\n \n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len() - 1); // Yay\n+    v.drain(..v.len() - 1);\n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len() - 1).min(); // Yay\n+    v.drain(..v.len() - 1).min();\n \n     let mut v = vec![1, 2, 3];\n-    v.drain(1..v.len() - 1); // Yay\n+    v.drain(1..v.len() - 1);\n     let mut v = vec![1, 2, 3];\n-    let w: Vec<i8> = v.drain(1..v.len() - 1).collect(); // Yay\n+    let w: Vec<i8> = v.drain(1..v.len() - 1).collect();\n+}\n+\n+fn vec_deque_range() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..deque.len());\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let n = deque.drain(0..deque.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(usize::MIN..deque.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(0..deque.len());\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(usize::MIN..deque.len());\n+}\n+\n+fn vec_deque_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let mut iter = deque.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let next = deque.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(0..);\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(usize::MIN..);\n }\n \n-fn main() {\n-    let mut deque: VecDeque<_> = [1, 2, 3].into();\n+fn vec_deque_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    for x in deque.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n     deque.drain(..);\n+}\n+\n+fn vec_deque_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len());\n+}\n+\n+fn vec_deque_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..).max();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1).min();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let w: Vec<i8> = deque.drain(1..deque.len() - 1).collect();\n+}\n+\n+fn string_range() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..s.len());\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let n = s.drain(0..s.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(usize::MIN..s.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(0..s.len());\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(usize::MIN..s.len());\n+}\n+\n+fn string_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let mut iter = s.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let next = s.drain(usize::MIN..).next();\n \n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(0..);\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(usize::MIN..);\n+}\n+\n+fn string_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    for x in s.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..);\n+}\n+\n+fn string_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len());\n+}\n+\n+fn string_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..).max();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1).min();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    let w: String = s.drain(1..s.len() - 1).collect();\n+}\n+\n+fn hash_set() {\n+    // Do not lint because iterator is assigned\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let iter = set.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let mut iter = set.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let next = set.drain().next();\n+\n+    // Do lint\n     let mut set = HashSet::from([1, 2, 3]);\n     set.drain();\n+}\n \n-    let mut a = HashMap::new();\n-    a.insert(1, \"a\");\n-    a.insert(2, \"b\");\n-    a.drain();\n+fn hash_map() {\n+    // Do not lint because iterator is assigned\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let iter = map.drain();\n \n-    let mut heap = BinaryHeap::from([1, 3]);\n-    heap.drain();\n+    // Do not lint because iterator is assigned and used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let mut iter = map.drain();\n+    let next = iter.next();\n \n-    // Not firing for now because `String` is not reckognized by `is_type_diagnostic_item`\n-    let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n-    s.drain(..);\n+    // Do not lint because iterator is used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let next = map.drain().next();\n+\n+    // Do lint\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    map.drain();\n+}\n+\n+fn binary_heap() {\n+    // Do not lint because iterator is assigned\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let iter = heap.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let mut iter = heap.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let next = heap.drain().next();\n+\n+    // Do lint\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    heap.drain();\n }\n+\n+fn main() {}"}, {"sha": "20158da1121b78ac54aed8973cd0be2dbeae2404", "filename": "tests/ui/clear_with_drain.stderr", "status": "modified", "additions": 85, "deletions": 19, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/tests%2Fui%2Fclear_with_drain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab/tests%2Fui%2Fclear_with_drain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.stderr?ref=5b57e5cec84a9c3c2f6240c9f0f4071f391fe6ab", "patch": "@@ -1,64 +1,130 @@\n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:22:7\n+  --> $DIR/clear_with_drain.rs:23:7\n    |\n-LL |     v.drain(0..v.len()); // Nay\n+LL |     v.drain(0..v.len());\n    |       ^^^^^^^^^^^^^^^^^ help: try: `clear()`\n    |\n    = note: `-D clippy::clear-with-drain` implied by `-D warnings`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:25:7\n+  --> $DIR/clear_with_drain.rs:27:7\n    |\n-LL |     v.drain(usize::MIN..v.len()); // Nay\n+LL |     v.drain(usize::MIN..v.len());\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:40:7\n+  --> $DIR/clear_with_drain.rs:46:7\n    |\n-LL |     v.drain(0..); // Nay\n+LL |     v.drain(0..);\n    |       ^^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:43:7\n+  --> $DIR/clear_with_drain.rs:50:7\n    |\n-LL |     v.drain(usize::MIN..); // Nay\n+LL |     v.drain(usize::MIN..);\n    |       ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:57:7\n+  --> $DIR/clear_with_drain.rs:66:7\n    |\n-LL |     v.drain(..); // Nay\n+LL |     v.drain(..);\n    |       ^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:71:7\n+  --> $DIR/clear_with_drain.rs:83:7\n    |\n-LL |     v.drain(..v.len()); // Nay\n+LL |     v.drain(..v.len());\n    |       ^^^^^^^^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `VecDeque`\n-  --> $DIR/clear_with_drain.rs:93:11\n+  --> $DIR/clear_with_drain.rs:121:11\n+   |\n+LL |     deque.drain(0..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:125:11\n+   |\n+LL |     deque.drain(usize::MIN..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:144:11\n+   |\n+LL |     deque.drain(0..);\n+   |           ^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:148:11\n+   |\n+LL |     deque.drain(usize::MIN..);\n+   |           ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:164:11\n    |\n LL |     deque.drain(..);\n    |           ^^^^^^^^^ help: try: `clear()`\n \n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:181:11\n+   |\n+LL |     deque.drain(..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:219:7\n+   |\n+LL |     s.drain(0..s.len());\n+   |       ^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:223:7\n+   |\n+LL |     s.drain(usize::MIN..s.len());\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:242:7\n+   |\n+LL |     s.drain(0..);\n+   |       ^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:246:7\n+   |\n+LL |     s.drain(usize::MIN..);\n+   |       ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:262:7\n+   |\n+LL |     s.drain(..);\n+   |       ^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:279:7\n+   |\n+LL |     s.drain(..s.len());\n+   |       ^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n error: `drain` used to clear a `HashSet`\n-  --> $DIR/clear_with_drain.rs:96:9\n+  --> $DIR/clear_with_drain.rs:317:9\n    |\n LL |     set.drain();\n    |         ^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `HashMap`\n-  --> $DIR/clear_with_drain.rs:101:7\n+  --> $DIR/clear_with_drain.rs:336:9\n    |\n-LL |     a.drain();\n-   |       ^^^^^^^ help: try: `clear()`\n+LL |     map.drain();\n+   |         ^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `BinaryHeap`\n-  --> $DIR/clear_with_drain.rs:104:10\n+  --> $DIR/clear_with_drain.rs:355:10\n    |\n LL |     heap.drain();\n    |          ^^^^^^^ help: try: `clear()`\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 21 previous errors\n "}]}