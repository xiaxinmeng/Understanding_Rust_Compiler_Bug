{"sha": "a03d184648c2680b75e3312358efdb1ae0d21a0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwM2QxODQ2NDhjMjY4MGI3NWUzMzEyMzU4ZWZkYjFhZTBkMjFhMGI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-20T12:34:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-20T12:34:24Z"}, "message": "Merge branch 'master' into rustup", "tree": {"sha": "0d7637f6d4a2b43a690dae1f18cf0596c40ee31c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d7637f6d4a2b43a690dae1f18cf0596c40ee31c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a03d184648c2680b75e3312358efdb1ae0d21a0b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcG4xQCRBK7hj4Ov3rIwAAdHIIADPqccEYmVGhMgjctu1V20H7\n13o0EXcZb9bTka8+sGyWcqVaZSRoNn/YpHPzZRgpsWwJvuVIRy9kBOXnRHOXRhz9\nR8KLro2wXetwm7VuH7pgloCdcJatCz8pNKBhv7UK149XUqb8+v+dy+KTwML7Cswr\nGlKDXtQpNCY024c9g2/UWaPEiZsgCTYW7WfBfS8XcAa+o0zn65nYywn0KbL29RbP\nTqLMmmueo8VF4s4KAa8vYInZ2nj6JGNvmYb00F3Tl6RoOeQtZmtAAdH2isVrKPdJ\nzjwyRTJUw64TsuixVipqPRRvKNHZJgrQ9fbAvzS4SpGG5hlHCHUnPisOcmsTC00=\n=21e9\n-----END PGP SIGNATURE-----\n", "payload": "tree 0d7637f6d4a2b43a690dae1f18cf0596c40ee31c\nparent d5820d4d3415e4aab638e347753ea849bcf947ec\nparent 8359898c09e83df958d052ed5ac6722d4955cb0a\nauthor Ralf Jung <post@ralfj.de> 1545309264 +0100\ncommitter GitHub <noreply@github.com> 1545309264 +0100\n\nMerge branch 'master' into rustup"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a03d184648c2680b75e3312358efdb1ae0d21a0b", "html_url": "https://github.com/rust-lang/rust/commit/a03d184648c2680b75e3312358efdb1ae0d21a0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a03d184648c2680b75e3312358efdb1ae0d21a0b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5820d4d3415e4aab638e347753ea849bcf947ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5820d4d3415e4aab638e347753ea849bcf947ec", "html_url": "https://github.com/rust-lang/rust/commit/d5820d4d3415e4aab638e347753ea849bcf947ec"}, {"sha": "8359898c09e83df958d052ed5ac6722d4955cb0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8359898c09e83df958d052ed5ac6722d4955cb0a", "html_url": "https://github.com/rust-lang/rust/commit/8359898c09e83df958d052ed5ac6722d4955cb0a"}], "stats": {"total": 489, "additions": 331, "deletions": 158}, "files": [{"sha": "51b14a1b345bf879f167490d60be800415edfb24", "filename": ".travis.yml", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -12,51 +12,22 @@ os:\n dist: xenial\n \n before_script:\n-# install extra stuff for cross-compilation\n+# Linux: install extra stuff for cross-compilation\n - if [[ \"$TRAVIS_OS_NAME\" == linux ]]; then sudo apt update && sudo apt install gcc-multilib; fi\n-# macOS weirdness (https://github.com/travis-ci/travis-ci/issues/6307, https://github.com/travis-ci/travis-ci/issues/10165)\n-- if [[ \"$TRAVIS_OS_NAME\" == osx ]]; then rvm get stable; fi\n # Compute the rust version we use. We do not use \"language: rust\" to have more control here.\n - |\n   if [[ \"$TRAVIS_EVENT_TYPE\" == cron ]]; then\n     RUST_TOOLCHAIN=nightly\n   else\n     RUST_TOOLCHAIN=$(cat rust-version)\n   fi\n-- |\n-  if [ \"$TRAVIS_OS_NAME\" == osx ]; then\n-    export MIRI_SYSROOT_BASE=~/Library/Caches/miri.miri.miri/\n-  else\n-    export MIRI_SYSROOT_BASE=~/.cache/miri/\n-  fi\n-- |\n-  if [[ \"$TRAVIS_OS_NAME\" == osx ]]; then\n-    FOREIGN_TARGET=i686-apple-darwin\n-  else\n-    FOREIGN_TARGET=i686-unknown-linux-gnu\n-  fi\n # install Rust\n - curl https://build.travis-ci.org/files/rustup-init.sh -sSf | sh -s -- -y --default-toolchain \"$RUST_TOOLCHAIN\"\n - export PATH=$HOME/.cargo/bin:$PATH\n - rustc --version\n \n script:\n-- set -e\n-- |\n-  # Build and install miri\n-  cargo build --release --all-features --all-targets &&\n-  cargo install --all-features --force --path .\n-- |\n-  # Get ourselves a MIR-full libstd for the host and a foreign architecture\n-  cargo miri setup &&\n-  cargo miri setup --target \"$FOREIGN_TARGET\"\n-- |\n-  # Test miri with full MIR, on the host and other architectures\n-  MIRI_SYSROOT=$MIRI_SYSROOT_BASE/HOST cargo test --release --all-features &&\n-  MIRI_SYSROOT=$MIRI_SYSROOT_BASE MIRI_TARGET=$FOREIGN_TARGET cargo test --release --all-features\n-- |\n-  # Test cargo integration\n-  (cd test-cargo-miri && MIRI_SYSROOT=$MIRI_SYSROOT_BASE/HOST ./run-test.py)\n+- ./travis.sh\n \n notifications:\n   email:\n@@ -67,3 +38,4 @@ branches:\n env:\n   global:\n   - RUST_TEST_NOCAPTURE=1\n+  - RUST_BACKTRACE=1"}, {"sha": "6fd45b0c74178dd9230e278809effba4b037d93a", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -39,6 +39,10 @@ directories = { version = \"1.0\", optional = true }\n rustc_version = { version = \"0.2.3\", optional = true }\n env_logger = \"0.5\"\n log = \"0.4\"\n+# A noop dependency that changes in the Rust repository, it's a bit of a hack.\n+# See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n+# for more information.\n+rustc-workspace-hack = \"1.0.0\"\n \n [build-dependencies]\n vergen = \"3\""}, {"sha": "5a615e656d7428bfe97cb19c67638798175db5da", "filename": "README.md", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -39,17 +39,28 @@ example above), overriding it in your project directory as well, or use `rustup\n default nightly` (or `rustup default nightly-YYYY-MM-DD`) to globally make\n `nightly` the default toolchain.\n \n-Now you can run your project in miri:\n+Now you can run your project in Miri:\n \n 1. Run `cargo clean` to eliminate any cached dependencies.  Miri needs your\n    dependencies to be compiled the right way, that would not happen if they have\n    previously already been compiled.\n 2. To run all tests in your project through Miri, use `cargo +nightly miri test`.\n-   **NOTE**: This is currently broken, see the discussion in\n-   [#479](https://github.com/solson/miri/issues/479).\n 3. If you have a binary project, you can run it through Miri using `cargo\n    +nightly miri run`.\n \n+When running code via `cargo miri`, the `cargo-miri` feature is set.  You can\n+use this to exclude test cases that will fail under Miri because they do things\n+Miri does not support:\n+\n+```rust\n+#[cfg(not(feature = \"cargo-miri\"))]\n+#[test]\n+fn does_not_work_on_miri() {\n+    let x = 0u8;\n+    assert!(&x as *const _ as usize % 4 < 4);\n+}\n+```\n+\n ### Common Problems\n \n When using the above instructions, you may encounter a number of confusing compiler"}, {"sha": "a46214a3c45c61b42f71005f5651942a6fcc5590", "filename": "appveyor.yml", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -25,15 +25,19 @@ install:\n build: false\n \n test_script:\n-    - set RUSTFLAGS=-g\n+    - set RUST_TEST_NOCAPTURE=1\n     - set RUST_BACKTRACE=1\n-    # Build miri\n+    # Build and install miri\n     - cargo build --release --all-features --all-targets\n+    - cargo install --all-features --force --path .\n     # Get ourselves a MIR-full libstd, and use it henceforth\n-    - cargo run --release --all-features --bin cargo-miri -- miri setup\n+    - cargo miri setup\n     - set MIRI_SYSROOT=%USERPROFILE%\\AppData\\Local\\miri\\miri\\cache\\HOST\n     # Test miri\n     - cargo test --release --all-features\n+    # Test cargo integration\n+    - cd test-cargo-miri\n+    - python3 run-test.py\n \n notifications:\n     - provider: Email"}, {"sha": "d1ff80dec08afb8b87a74d87d468f7f2cf244212", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -1 +1 @@\n-nightly-2018-12-08\n+nightly-2018-12-18"}, {"sha": "21cc7ee0e398e2ede5ee29f12a3ce33e186f5282", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -3,7 +3,7 @@\n extern crate cargo_metadata;\n \n use std::path::{PathBuf, Path};\n-use std::io::{self, Write};\n+use std::io::{self, Write, BufRead};\n use std::process::Command;\n use std::fs::{self, File};\n \n@@ -114,6 +114,42 @@ fn list_targets() -> impl Iterator<Item=cargo_metadata::Target> {\n     package.targets.into_iter()\n }\n \n+fn xargo_version() -> Option<(u32, u32, u32)> {\n+    let out = Command::new(\"xargo\").arg(\"--version\").output().ok()?;\n+    if !out.status.success() {\n+        return None;\n+    }\n+    // Parse output. The first line looks like \"xargo 0.3.12 (b004f1c 2018-12-13)\".\n+    let line = out.stderr.lines().nth(0)\n+        .expect(\"malformed `xargo --version` output: not at least one line\")\n+        .expect(\"malformed `xargo --version` output: error reading first line\");\n+    let (name, version) = {\n+        let mut split = line.split(' ');\n+        (split.next().expect(\"malformed `xargo --version` output: empty\"),\n+         split.next().expect(\"malformed `xargo --version` output: not at least two words\"))\n+    };\n+    if name != \"xargo\" {\n+        panic!(\"malformed `xargo --version` output: application name is not `xargo`\");\n+    }\n+    let mut version_pieces = version.split('.');\n+    let major = version_pieces.next()\n+        .expect(\"malformed `xargo --version` output: not a major version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: major version is not an integer\");\n+    let minor = version_pieces.next()\n+        .expect(\"malformed `xargo --version` output: not a minor version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: minor version is not an integer\");\n+    let patch = version_pieces.next()\n+        .expect(\"malformed `xargo --version` output: not a patch version piece\")\n+        .parse()\n+        .expect(\"malformed `xargo --version` output: patch version is not an integer\");\n+    if !version_pieces.next().is_none() {\n+        panic!(\"malformed `xargo --version` output: more than three pieces in version\");\n+    }\n+    Some((major, minor, patch))\n+}\n+\n fn ask(question: &str) {\n     let mut buf = String::new();\n     print!(\"{} [Y/n] \", question);\n@@ -134,14 +170,14 @@ fn setup(ask_user: bool) {\n     }\n \n     // First, we need xargo\n-    if Command::new(\"xargo\").arg(\"--version\").output().is_err()\n-    {\n+    let xargo = xargo_version();\n+    if xargo.map_or(true, |v| v < (0, 3, 13)) {\n         if ask_user {\n-            ask(\"It seems you do not have xargo installed. I will run `cargo install xargo`. Proceed?\");\n+            ask(\"It seems you do not have a recent enough xargo installed. I will run `cargo install xargo -f`. Proceed?\");\n         } else {\n-            println!(\"Installing xargo: `cargo install xargo`\");\n+            println!(\"Installing xargo: `cargo install xargo -f`\");\n         }\n-        if !Command::new(\"cargo\").args(&[\"install\", \"xargo\"]).status().unwrap().success() {\n+        if !Command::new(\"cargo\").args(&[\"install\", \"xargo\", \"-f\"]).status().unwrap().success() {\n             show_error(format!(\"Failed to install xargo\"));\n         }\n     }\n@@ -279,9 +315,8 @@ fn main() {\n                 (MiriCommand::Test, \"lib\") => {\n                     // For libraries we call `cargo rustc -- --test <rustc args>`\n                     // Notice now that `--test` is a rustc arg rather than a cargo arg. This tells\n-                    // rustc to build a test harness which calls all #[test] functions. We don't\n-                    // use the harness since we execute each #[test] function's MIR ourselves before\n-                    // compilation even completes, but this option is necessary to build the library.\n+                    // rustc to build a test harness which calls all #[test] functions.\n+                    // We then execute that harness just like any other binary.\n                     if let Err(code) = process(\n                         vec![\"--\".to_string(), \"--test\".to_string()].into_iter().chain(\n                             args,\n@@ -305,8 +340,8 @@ fn main() {\n                 _ => {}\n             }\n         }\n-    } else {\n-        // This arm is executed when cargo-miri runs `cargo rustc` with the `RUSTC` env var set to itself:\n+    } else if let Some(\"rustc\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n+        // This arm is executed when cargo-miri runs `cargo rustc` with the `RUSTC_WRAPPER` env var set to itself:\n         // Dependencies get dispatched to rustc, the final test/binary to miri.\n \n         let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n@@ -332,11 +367,11 @@ fn main() {\n \n         // this conditional check for the --sysroot flag is there so users can call `cargo-miri` directly\n         // without having to pass --sysroot or anything\n+        let rustc_args = std::env::args().skip(2);\n         let mut args: Vec<String> = if std::env::args().any(|s| s == \"--sysroot\") {\n-            std::env::args().skip(1).collect()\n+            rustc_args.collect()\n         } else {\n-            std::env::args()\n-                .skip(1)\n+            rustc_args\n                 .chain(Some(\"--sysroot\".to_owned()))\n                 .chain(Some(sys_root))\n                 .collect()\n@@ -365,6 +400,8 @@ fn main() {\n             Err(ref e) if miri_enabled => panic!(\"error during miri run: {:?}\", e),\n             Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n         }\n+    } else {\n+        show_error(format!(\"Must be called with either `miri` or `rustc` as first argument.\"))\n     }\n }\n \n@@ -383,13 +420,11 @@ where\n         args.push(\"--\".to_owned());\n     }\n     args.push(\"--emit=dep-info,metadata\".to_owned());\n-    args.push(\"--cfg\".to_owned());\n-    args.push(r#\"feature=\"cargo-miri\"\"#.to_owned());\n \n     let path = std::env::current_exe().expect(\"current executable path invalid\");\n     let exit_status = Command::new(\"cargo\")\n         .args(&args)\n-        .env(\"RUSTC\", path)\n+        .env(\"RUSTC_WRAPPER\", path)\n         .spawn()\n         .expect(\"could not run cargo\")\n         .wait()"}, {"sha": "c2255d706339d8d6556f79ea8f1e492cff3709de", "filename": "src/bin/miri.rs", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -23,8 +23,6 @@ use rustc_metadata::cstore::CStore;\n use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n use rustc_driver::driver::{CompileState, CompileController};\n use rustc::session::config::{self, Input, ErrorOutputType};\n-use rustc::hir::{self, itemlikevisit};\n-use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use syntax::ast;\n \n@@ -115,43 +113,12 @@ fn after_analysis<'a, 'tcx>(\n \n     let tcx = state.tcx.unwrap();\n \n-    if std::env::args().any(|arg| arg == \"--test\") {\n-        struct Visitor<'a, 'tcx: 'a> {\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-            state: &'a CompileState<'a, 'tcx>,\n-            validate: bool,\n-        };\n-        impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n-            fn visit_item(&mut self, i: &'hir hir::Item) {\n-                if let hir::ItemKind::Fn(.., body_id) = i.node {\n-                    if i.attrs.iter().any(|attr| {\n-                        attr.name() == \"test\"\n-                    })\n-                    {\n-                        let did = self.tcx.hir().body_owner_def_id(body_id);\n-                        println!(\n-                            \"running test: {}\",\n-                            self.tcx.def_path_debug_str(did),\n-                        );\n-                        miri::eval_main(self.tcx, did, self.validate);\n-                        self.state.session.abort_if_errors();\n-                    }\n-                }\n-            }\n-            fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n-            fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n-        }\n-        state.hir_crate.unwrap().visit_all_item_likes(\n-            &mut Visitor { tcx, state, validate }\n-        );\n-    } else if let Some((entry_node_id, _, _)) = *state.session.entry_fn.borrow() {\n-        let entry_def_id = tcx.hir().local_def_id(entry_node_id);\n-        miri::eval_main(tcx, entry_def_id, validate);\n-\n-        state.session.abort_if_errors();\n-    } else {\n-        println!(\"no main function found, assuming auxiliary build\");\n-    }\n+    let (entry_node_id, _, _) = state.session.entry_fn.borrow().expect(\"no main function found!\");\n+    let entry_def_id = tcx.hir().local_def_id(entry_node_id);\n+\n+    miri::eval_main(tcx, entry_def_id, validate);\n+\n+    state.session.abort_if_errors();\n }\n \n fn init_early_loggers() {"}, {"sha": "16d18dbfe6dc29652687826a3d72054412c99701", "filename": "src/fn_call.rs", "status": "modified", "additions": 99, "deletions": 17, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -398,7 +398,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                         Err(_) => -1,\n                     }\n                 } else {\n-                    warn!(\"Ignored output to FD {}\", fd);\n+                    eprintln!(\"Miri: Ignored output to FD {}\", fd);\n                     n as i64 // pretend it all went well\n                 }; // now result is the value we return back to the program\n                 this.write_scalar(\n@@ -426,6 +426,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 let paths = &[\n                     (&[\"libc\", \"_SC_PAGESIZE\"], Scalar::from_int(4096, dest.layout.size)),\n                     (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], Scalar::from_int(-1, dest.layout.size)),\n+                    (&[\"libc\", \"_SC_NPROCESSORS_ONLN\"], Scalar::from_int(1, dest.layout.size)),\n                 ];\n                 let mut result = None;\n                 for &(path, path_value) in paths {\n@@ -452,6 +453,10 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 }\n             }\n \n+            \"isatty\" => {\n+                this.write_null(dest)?;\n+            }\n+\n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n                 let key_ptr = this.read_scalar(args[0])?.to_ptr()?;\n@@ -508,10 +513,6 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 this.write_null(dest)?;\n             }\n \n-            \"_tlv_atexit\" => {\n-                // FIXME: Register the dtor\n-            },\n-\n             // Determining stack base address\n             \"pthread_attr_init\" | \"pthread_attr_destroy\" | \"pthread_attr_get_np\" |\n             \"pthread_getattr_np\" | \"pthread_self\" | \"pthread_get_stacksize_np\" => {\n@@ -549,30 +550,62 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 this.write_null(dest)?;\n             }\n \n-            // Windows API subs\n+            // macOS API stubs\n+            \"_tlv_atexit\" => {\n+                // FIXME: Register the dtor\n+            },\n+            \"_NSGetArgc\" => {\n+                this.write_scalar(Scalar::Ptr(this.machine.argc.unwrap()), dest)?;\n+            },\n+            \"_NSGetArgv\" => {\n+                this.write_scalar(Scalar::Ptr(this.machine.argv.unwrap()), dest)?;\n+            },\n+\n+            // Windows API stubs\n+            \"SetLastError\" => {\n+                let err = this.read_scalar(args[0])?.to_u32()?;\n+                this.machine.last_error = err;\n+            }\n+            \"GetLastError\" => {\n+                this.write_scalar(Scalar::from_uint(this.machine.last_error, Size::from_bits(32)), dest)?;\n+            }\n+\n             \"AddVectoredExceptionHandler\" => {\n                 // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n                 this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n             },\n             \"InitializeCriticalSection\" |\n             \"EnterCriticalSection\" |\n             \"LeaveCriticalSection\" |\n-            \"DeleteCriticalSection\" |\n-            \"SetLastError\" => {\n-                // Function does not return anything, nothing to do\n+            \"DeleteCriticalSection\" => {\n+                // Nothing to do, not even a return value\n             },\n             \"GetModuleHandleW\" |\n             \"GetProcAddress\" |\n-            \"TryEnterCriticalSection\" => {\n+            \"TryEnterCriticalSection\" |\n+            \"GetConsoleScreenBufferInfo\" |\n+            \"SetConsoleTextAttribute\" => {\n                 // pretend these do not exist/nothing happened, by returning zero\n                 this.write_null(dest)?;\n             },\n-            \"GetLastError\" => {\n-                // this is c::ERROR_CALL_NOT_IMPLEMENTED\n-                this.write_scalar(Scalar::from_int(120, dest.layout.size), dest)?;\n-            },\n+            \"GetSystemInfo\" => {\n+                let system_info = this.deref_operand(args[0])?;\n+                let system_info_ptr = system_info.ptr.to_ptr()?;\n+                // initialize with 0\n+                this.memory_mut().get_mut(system_info_ptr.alloc_id)?\n+                    .write_repeat(tcx, system_info_ptr, 0, system_info.layout.size)?;\n+                // set number of processors to 1\n+                let dword_size = Size::from_bytes(4);\n+                let offset = 2*dword_size + 3*tcx.pointer_size();\n+                this.memory_mut().get_mut(system_info_ptr.alloc_id)?\n+                    .write_scalar(\n+                        tcx,\n+                        system_info_ptr.offset(offset, tcx)?,\n+                        Scalar::from_int(1, dword_size).into(),\n+                        dword_size,\n+                    )?;\n+            }\n \n-            // Windows TLS\n             \"TlsAlloc\" => {\n                 // This just creates a key; Windows does not natively support TLS dtors.\n \n@@ -586,18 +619,67 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n             \"TlsGetValue\" => {\n-                let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n+                let key = this.read_scalar(args[0])?.to_u32()? as u128;\n                 let ptr = this.machine.tls.load_tls(key)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n-                let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n+                let key = this.read_scalar(args[0])?.to_u32()? as u128;\n                 let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n                 this.machine.tls.store_tls(key, new_ptr)?;\n \n                 // Return success (1)\n                 this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n             }\n+            \"GetStdHandle\" => {\n+                let which = this.read_scalar(args[0])?.to_i32()?;\n+                // We just make this the identity function, so we know later in \"WriteFile\"\n+                // which one it is.\n+                this.write_scalar(Scalar::from_int(which, this.pointer_size()), dest)?;\n+            }\n+            \"WriteFile\" => {\n+                let handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let buf = this.read_scalar(args[1])?.not_undef()?;\n+                let n = this.read_scalar(args[2])?.to_u32()?;\n+                let written_place = this.deref_operand(args[3])?;\n+                this.write_null(written_place.into())?; // spec says we always write 0 first\n+                let written = if handle == -11 || handle == -12 {\n+                    // stdout/stderr\n+                    use std::io::{self, Write};\n+\n+                    let buf_cont = this.memory().read_bytes(buf, Size::from_bytes(u64::from(n)))?;\n+                    let res = if handle == -11 {\n+                        io::stdout().write(buf_cont)\n+                    } else {\n+                        io::stderr().write(buf_cont)\n+                    };\n+                    res.ok().map(|n| n as u32)\n+                } else {\n+                    eprintln!(\"Miri: Ignored output to handle {}\", handle);\n+                    Some(n) // pretend it all went well\n+                };\n+                // If there was no error, write back how much was written\n+                if let Some(n) = written {\n+                    this.write_scalar(Scalar::from_uint(n, Size::from_bits(32)), written_place.into())?;\n+                }\n+                // Return whether this was a success\n+                this.write_scalar(\n+                    Scalar::from_int(if written.is_some() { 1 } else { 0 }, dest.layout.size),\n+                    dest,\n+                )?;\n+            }\n+            \"GetConsoleMode\" => {\n+                // Everything is a pipe\n+                this.write_null(dest)?;\n+            }\n+            \"GetEnvironmentVariableW\" => {\n+                // This is not the env var you are looking for\n+                this.machine.last_error = 203; // ERROR_ENVVAR_NOT_FOUND\n+                this.write_null(dest)?;\n+            }\n+            \"GetCommandLineW\" => {\n+                this.write_scalar(Scalar::Ptr(this.machine.cmd_line.unwrap()), dest)?;\n+            }\n \n             // We can't execute anything else\n             _ => {"}, {"sha": "aa652203055023c5fb10f2653617c1d7df1dc896", "filename": "src/lib.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -18,7 +18,7 @@ use std::borrow::Cow;\n use std::env;\n \n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n+use rustc::ty::layout::{TyLayout, LayoutOf, Size, Align};\n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n \n@@ -121,18 +121,56 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n \n     // Second argument (argc): 1\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-    ecx.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n+    let argc = Scalar::from_int(1, dest.layout.size);\n+    ecx.write_scalar(argc, dest)?;\n+    // Store argc for macOS _NSGetArgc\n+    {\n+        let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into())?;\n+        ecx.write_scalar(argc, argc_place.into())?;\n+        ecx.machine.argc = Some(argc_place.ptr.to_ptr()?);\n+    }\n \n     // FIXME: extract main source file path\n     // Third argument (argv): &[b\"foo\"]\n+    const CMD: &str = \"running-in-miri\\0\";\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-    let foo = ecx.memory_mut().allocate_static_bytes(b\"foo\\0\").with_default_tag();\n-    let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n-    let foo_layout = ecx.layout_of(foo_ty)?;\n-    let foo_place = ecx.allocate(foo_layout, MiriMemoryKind::Env.into())?;\n-    ecx.write_scalar(Scalar::Ptr(foo), foo_place.into())?;\n-    ecx.memory_mut().mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n-    ecx.write_scalar(foo_place.ptr, dest)?;\n+    let cmd = ecx.memory_mut().allocate_static_bytes(CMD.as_bytes()).with_default_tag();\n+    let raw_str_layout = ecx.layout_of(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8))?;\n+    let cmd_place = ecx.allocate(raw_str_layout, MiriMemoryKind::Env.into())?;\n+    ecx.write_scalar(Scalar::Ptr(cmd), cmd_place.into())?;\n+    ecx.memory_mut().mark_immutable(cmd_place.to_ptr()?.alloc_id)?;\n+    // Store argv for macOS _NSGetArgv\n+    {\n+        let argv = cmd_place.ptr;\n+        ecx.write_scalar(argv, dest)?;\n+        let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into())?;\n+        ecx.write_scalar(argv, argv_place.into())?;\n+        ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n+    }\n+    // Store cmdline as UTF-16 for Windows GetCommandLineW\n+    {\n+        let tcx = &{ecx.tcx.tcx};\n+        let cmd_utf16: Vec<u16> = CMD.encode_utf16().collect();\n+        let cmd_ptr = ecx.memory_mut().allocate(\n+            Size::from_bytes(cmd_utf16.len() as u64 * 2),\n+            Align::from_bytes(2).unwrap(),\n+            MiriMemoryKind::Env.into(),\n+        )?.with_default_tag();\n+        ecx.machine.cmd_line = Some(cmd_ptr);\n+        // store the UTF-16 string\n+        let char_size = Size::from_bytes(2);\n+        let cmd_alloc = ecx.memory_mut().get_mut(cmd_ptr.alloc_id)?;\n+        let mut cur_ptr = cmd_ptr;\n+        for &c in cmd_utf16.iter() {\n+            cmd_alloc.write_scalar(\n+                tcx,\n+                cur_ptr,\n+                Scalar::from_uint(c, char_size).into(),\n+                char_size,\n+            )?;\n+            cur_ptr = cur_ptr.offset(char_size, tcx)?;\n+        }\n+    }\n \n     assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n \n@@ -253,6 +291,16 @@ pub struct Evaluator<'tcx> {\n     /// Miri does not expose env vars from the host to the emulated program\n     pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Borrow>>,\n \n+    /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n+    /// These are *pointers* to argc/argv because macOS.\n+    /// We also need the full cmdline as one string because Window.\n+    pub(crate) argc: Option<Pointer<Borrow>>,\n+    pub(crate) argv: Option<Pointer<Borrow>>,\n+    pub(crate) cmd_line: Option<Pointer<Borrow>>,\n+\n+    /// Last OS error\n+    pub(crate) last_error: u32,\n+\n     /// TLS state\n     pub(crate) tls: TlsData<'tcx>,\n \n@@ -267,6 +315,10 @@ impl<'tcx> Evaluator<'tcx> {\n     fn new(validate: bool) -> Self {\n         Evaluator {\n             env_vars: HashMap::default(),\n+            argc: None,\n+            argv: None,\n+            cmd_line: None,\n+            last_error: 0,\n             tls: TlsData::default(),\n             validate,\n             stacked_borrows: stacked_borrows::State::default(),"}, {"sha": "7f7f2660c06224c9e9162ca48bde8cecd2b070c8", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -7,11 +7,15 @@\n \n import sys, subprocess\n \n-def test_cargo_miri():\n-    print(\"==> Testing `cargo miri run` <==\")\n+def fail(msg):\n+    print(\"TEST FAIL: {}\".format(msg))\n+    sys.exit(1)\n+\n+def test(name, cmd, stdout_ref, stderr_ref):\n+    print(\"==> Testing `{}` <==\".format(name))\n     ## Call `cargo miri`, capture all output\n     p = subprocess.Popen(\n-        [\"cargo\", \"miri\", \"run\", \"-q\"],\n+        cmd,\n         stdout=subprocess.PIPE,\n         stderr=subprocess.PIPE\n     )\n@@ -25,18 +29,18 @@ def test_cargo_miri():\n     print(stderr, end=\"\")\n     # Test for failures\n     if p.returncode != 0:\n-        sys.exit(1)\n-    if stdout != open('stdout.ref').read():\n-        print(\"stdout does not match reference\")\n-        sys.exit(1)\n-    if stderr != open('stderr.ref').read():\n-        print(\"stderr does not match reference\")\n-        sys.exit(1)\n+        fail(\"Non-zero exit status\")\n+    if stdout != open(stdout_ref).read():\n+        fail(\"stdout does not match reference\")\n+    if stderr != open(stderr_ref).read():\n+        fail(\"stderr does not match reference\")\n+\n+def test_cargo_miri_run():\n+    test(\"cargo miri run\", [\"cargo\", \"miri\", \"run\", \"-q\"], \"stdout.ref\", \"stderr.ref\")\n \n def test_cargo_miri_test():\n-    print(\"==> Testing `cargo miri test` <==\")\n-    subprocess.check_call([\"cargo\", \"miri\", \"test\"])\n+    test(\"cargo miri test\", [\"cargo\", \"miri\", \"test\", \"-q\"], \"test.stdout.ref\", \"test.stderr.ref\")\n \n-test_cargo_miri()\n+test_cargo_miri_run()\n test_cargo_miri_test()\n sys.exit(0)"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "test-cargo-miri/test.stderr.ref", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/test-cargo-miri%2Ftest.stderr.ref", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/test-cargo-miri%2Ftest.stderr.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stderr.ref?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b"}, {"sha": "94fd56b0cd6f35daa5ebb935ad751d0256fa65d3", "filename": "test-cargo-miri/test.stdout.ref", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/test-cargo-miri%2Ftest.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/test-cargo-miri%2Ftest.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -0,0 +1,7 @@\n+\n+running 2 tests\n+test bar ... ok\n+test baz ... ok\n+\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "bd7b2c569a19b2a298b4f60cd0a3b0877661b7cf", "filename": "test-cargo-miri/tests/foo.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/test-cargo-miri%2Ftests%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/test-cargo-miri%2Ftests%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftests%2Ffoo.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -2,3 +2,18 @@\n fn bar() {\n     assert_eq!(4, 4);\n }\n+\n+// Having more than 1 test does seem to make a difference\n+// (i.e., this calls ptr::swap which having just one test does not).\n+#[test]\n+fn baz() {\n+    assert_eq!(5, 5);\n+}\n+\n+// A test that won't work on miri\n+#[cfg(not(feature = \"cargo-miri\"))]\n+#[test]\n+fn does_not_work_on_miri() {\n+    let x = 0u8;\n+    assert!(&x as *const _ as usize % 4 < 4);\n+}"}, {"sha": "f125100f834385b60f35bdd5ba94d0bd77314e43", "filename": "tests/compiletest.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -3,7 +3,7 @@\n #![test_runner(test_runner)]\n \n use std::slice::SliceConcatExt;\n-use std::path::{PathBuf, Path};\n+use std::path::PathBuf;\n use std::env;\n \n use compiletest_rs as compiletest;\n@@ -77,9 +77,7 @@ fn miri_pass(path: &str, target: &str, opt: bool) {\n     flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n     flags.push(\"--edition 2018\".to_owned());\n     if opt {\n-        // FIXME: We use opt level 1 because MIR inlining defeats the validation\n-        // whitelist.\n-        flags.push(\"-Zmir-opt-level=1\".to_owned());\n+        flags.push(\"-Zmir-opt-level=3\".to_owned());\n     }\n \n     let mut config = mk_config(\"ui\");"}, {"sha": "353afb9d32100b81179f460dc8d5204f8c46dfa8", "filename": "tests/run-pass/box-pair-to-vec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fbox-pair-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fbox-pair-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbox-pair-to-vec.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -1,5 +1,3 @@\n-//ignore-msvc: Stdout not implemented on Windows\n-\n #[repr(C)]\n #[derive(Debug)]\n struct PairFoo {"}, {"sha": "b7140d72ac3a632d2bf496cf7eeb794cf23c7f78", "filename": "tests/run-pass/btreemap.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fbtreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fbtreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbtreemap.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Validation disabled due to https://github.com/rust-lang/rust/issues/54957\n-// compile-flags: -Zmiri-disable-validation\n-\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub enum Foo {\n     A(&'static str),"}, {"sha": "5fd65f138aaf92055195e96638a4660febde5c89", "filename": "tests/run-pass/catch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fcatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fcatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcatch.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -1,4 +1,3 @@\n-//ignore-msvc: Stdout not implemented on Windows\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n fn main() {"}, {"sha": "f2ed67385cdc775d3320fb70389d449b339b67c9", "filename": "tests/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fforeign-fn-linkname.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -10,7 +10,7 @@\n \n //ignore-windows: Uses POSIX APIs\n \n-#![feature(libc)]\n+#![feature(rustc_private)]\n #![allow(unused_extern_crates)] // rustc bug https://github.com/rust-lang/rust/issues/56098\n \n extern crate libc;"}, {"sha": "78729b915613af908634833702f458b9e3fe2521", "filename": "tests/run-pass/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fformat.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -1,4 +1,3 @@\n-//ignore-msvc: Stdout not implemented on Windows\n fn main() {\n     println!(\"Hello {}\", 13);\n }"}, {"sha": "6819a2af3ed8f9612d389853308010c5f4aa1271", "filename": "tests/run-pass/function_pointers.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_pointers.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -10,12 +10,12 @@ fn h(i: i32, j: i32) -> i32 {\n     j * i * 7\n }\n \n-fn return_fn_ptr() -> fn() -> i32 {\n+fn return_fn_ptr(f: fn() -> i32) -> fn() -> i32 {\n     f\n }\n \n fn call_fn_ptr() -> i32 {\n-    return_fn_ptr()()\n+    return_fn_ptr(f)()\n }\n \n fn indirect<F: Fn() -> i32>(f: F) -> i32 { f() }\n@@ -41,6 +41,7 @@ fn main() {\n     assert_eq!(indirect3(h), 210);\n     assert_eq!(indirect_mut3(h), 210);\n     assert_eq!(indirect_once3(h), 210);\n-    assert!(return_fn_ptr() == f);\n-    assert!(return_fn_ptr() as unsafe fn() -> i32 == f as fn() -> i32 as unsafe fn() -> i32);\n+    let g = f as fn() -> i32;\n+    assert!(return_fn_ptr(g) == g);\n+    assert!(return_fn_ptr(g) as unsafe fn() -> i32 == g as fn() -> i32 as unsafe fn() -> i32);\n }"}, {"sha": "e7a11a969c037e00a796aafeff6258501ec15e9a", "filename": "tests/run-pass/hello.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fhello.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -1,4 +1,3 @@\n-//ignore-msvc: Stdout not implemented on Windows\n fn main() {\n     println!(\"Hello, world!\");\n }"}, {"sha": "91d17683e39e85ff2d10c7cbff55f3843a15bb4d", "filename": "tests/run-pass/issue-17877.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fissue-17877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fissue-17877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-17877.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //ignore-windows: Causes a stack overflow?!? Likely a rustc bug: https://github.com/rust-lang/rust/issues/53820\n-//Once that bug is fixed, increase the size to 16*1024 and enable on all platforms.\n+//FIXME: Once that bug is fixed, increase the size to 16*1024 and enable on all platforms.\n \n #![feature(slice_patterns)]\n "}, {"sha": "badb833ee800bca94c2420c3dbf2b66e97d3fe29", "filename": "tests/run-pass/issue-3794.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-3794.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//ignore-msvc: Stdout not implemented on Windows\n #![feature(box_syntax)]\n \n trait T {"}, {"sha": "1dab492f9da3bfe4821e19cfc52a7fcf8f9e9d78", "filename": "tests/run-pass/mir_coercions.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fmir_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fmir_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmir_coercions.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -60,7 +60,10 @@ fn main() {\n     let a = [0,1,2];\n     let square_local : fn(u32) -> u32 = square;\n     let (f,g) = fn_coercions(&square_local);\n-    assert_eq!(f as *const (), square as *const());\n+    // cannot use `square as *const ()` because we can't know whether the compiler duplicates\n+    // functions, so two function pointers are only equal if they result from the same function\n+    // to function pointer cast\n+    assert_eq!(f as *const (), square_local as *const());\n     assert_eq!(g(4), 16);\n     assert_eq!(identity_coercion(g)(5), 25);\n "}, {"sha": "62931493aa00c7120e01e53ce42f2fe16866cd95", "filename": "tests/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fregions-mock-trans.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -10,7 +10,7 @@\n \n //ignore-windows: Uses POSIX APIs\n \n-#![feature(libc)]\n+#![feature(rustc_private)]\n \n #![allow(dead_code)]\n "}, {"sha": "aeedb7034ce5e3b9853ab7d9cee38568ca47b9e7", "filename": "tests/run-pass/thread-local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fthread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fthread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthread-local.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -1,6 +1,6 @@\n //ignore-windows: Uses POSIX APIs\n \n-#![feature(libc)]\n+#![feature(rustc_private)]\n extern crate libc;\n \n use std::mem;"}, {"sha": "381169505ec9f50b5bfca110635935372e24ee4a", "filename": "tests/run-pass/vecdeque.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/tests%2Frun-pass%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecdeque.rs?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Validation disabled until https://github.com/rust-lang/rust/pull/56161 lands\n-// compile-flags: -Zmiri-disable-validation\n-\n use std::collections::VecDeque;\n \n fn main() {"}, {"sha": "aded53b1579d647cfad2bb2ff894e21aa8d98035", "filename": "travis.sh", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a03d184648c2680b75e3312358efdb1ae0d21a0b/travis.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a03d184648c2680b75e3312358efdb1ae0d21a0b/travis.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/travis.sh?ref=a03d184648c2680b75e3312358efdb1ae0d21a0b", "patch": "@@ -0,0 +1,30 @@\n+#!/bin/bash\n+set -e\n+\n+# Determine configuration\n+if [ \"$TRAVIS_OS_NAME\" == osx ]; then\n+  export MIRI_SYSROOT_BASE=~/Library/Caches/miri.miri.miri/\n+  FOREIGN_TARGET=i686-apple-darwin\n+else\n+  export MIRI_SYSROOT_BASE=~/.cache/miri/\n+  FOREIGN_TARGET=i686-unknown-linux-gnu\n+fi\n+\n+echo \"Build and install miri\"\n+cargo build --release --all-features --all-targets\n+cargo install --all-features --force --path .\n+echo\n+\n+echo \"Get ourselves a MIR-full libstd for the host and a foreign architecture\"\n+cargo miri setup\n+cargo miri setup --target \"$FOREIGN_TARGET\"\n+echo\n+\n+echo \"Test miri with full MIR, on the host and other architectures\"\n+MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\"/HOST cargo test --release --all-features\n+MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\" MIRI_TARGET=\"$FOREIGN_TARGET\" cargo test --release --all-features\n+echo\n+\n+echo \"Test cargo integration\"\n+(cd test-cargo-miri && MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\"/HOST ./run-test.py)\n+echo"}]}