{"sha": "6e48053d5d0d1c81d9a7e6548cead05c4bbac63d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNDgwNTNkNWQwZDFjODFkOWE3ZTY1NDhjZWFkMDVjNGJiYWM2M2Q=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T02:43:16Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T02:43:16Z"}, "message": "Use iterators in `error_at` and `process_cycle`.\n\nThis makes the code a little faster, presumably because bounds checks\naren't needed on `nodes` accesses. It requires making `scratch` a\n`RefCell`, which is not unreasonable.", "tree": {"sha": "9107bdd1970daabb41945fae0b24f15c2936563e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9107bdd1970daabb41945fae0b24f15c2936563e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e48053d5d0d1c81d9a7e6548cead05c4bbac63d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e48053d5d0d1c81d9a7e6548cead05c4bbac63d", "html_url": "https://github.com/rust-lang/rust/commit/6e48053d5d0d1c81d9a7e6548cead05c4bbac63d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e48053d5d0d1c81d9a7e6548cead05c4bbac63d/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2492b716370dab5216f0123b3ed1cac78f8304e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2492b716370dab5216f0123b3ed1cac78f8304e", "html_url": "https://github.com/rust-lang/rust/commit/e2492b716370dab5216f0123b3ed1cac78f8304e"}], "stats": {"total": 34, "additions": 18, "deletions": 16}, "files": [{"sha": "0fa1f707d7be31eacf118314eaa1dab2cbb03109", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e48053d5d0d1c81d9a7e6548cead05c4bbac63d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e48053d5d0d1c81d9a7e6548cead05c4bbac63d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=6e48053d5d0d1c81d9a7e6548cead05c4bbac63d", "patch": "@@ -76,7 +76,7 @@ use crate::fx::{FxHashMap, FxHashSet};\n use crate::indexed_vec::Idx;\n use crate::newtype_index;\n \n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash;\n@@ -156,7 +156,9 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// comments in `process_obligation` for details.\n     waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n \n-    scratch: Option<Vec<usize>>,\n+    /// A scratch vector reused in various operations, to avoid allocating new\n+    /// vectors.\n+    scratch: RefCell<Vec<usize>>,\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,\n \n@@ -265,7 +267,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             nodes: vec![],\n             done_cache: Default::default(),\n             waiting_cache: Default::default(),\n-            scratch: Some(vec![]),\n+            scratch: RefCell::new(vec![]),\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n         }\n@@ -345,8 +347,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// Converts all remaining obligations to the given error.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n         let mut errors = vec![];\n-        for i in 0..self.nodes.len() {\n-            if let NodeState::Pending = self.nodes[i].state.get() {\n+        for (i, node) in self.nodes.iter().enumerate() {\n+            if let NodeState::Pending = node.state.get() {\n                 let backtrace = self.error_at(i);\n                 errors.push(Error {\n                     error: error.clone(),\n@@ -469,20 +471,20 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// report all cycles between them. This should be called\n     /// after `mark_as_waiting` marks all nodes with pending\n     /// subobligations as NodeState::Waiting.\n-    fn process_cycles<P>(&mut self, processor: &mut P)\n+    fn process_cycles<P>(&self, processor: &mut P)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let mut stack = self.scratch.take().unwrap();\n+        let mut stack = self.scratch.replace(vec![]);\n         debug_assert!(stack.is_empty());\n \n         debug!(\"process_cycles()\");\n \n-        for i in 0..self.nodes.len() {\n+        for (i, node) in self.nodes.iter().enumerate() {\n             // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n             // hot and the state is almost always `Pending` or `Waiting`. It's\n             // a win to handle the no-op cases immediately to avoid the cost of\n             // the function call.\n-            match self.nodes[i].state.get() {\n+            match node.state.get() {\n                 NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n                 _ => self.find_cycles_from_node(&mut stack, processor, i),\n             }\n@@ -491,7 +493,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         debug!(\"process_cycles: complete\");\n \n         debug_assert!(stack.is_empty());\n-        self.scratch = Some(stack);\n+        self.scratch.replace(stack);\n     }\n \n     fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, i: usize)\n@@ -525,8 +527,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    fn error_at(&mut self, mut i: usize) -> Vec<O> {\n-        let mut error_stack = self.scratch.take().unwrap();\n+    fn error_at(&self, mut i: usize) -> Vec<O> {\n+        let mut error_stack = self.scratch.replace(vec![]);\n         let mut trace = vec![];\n \n         loop {\n@@ -554,7 +556,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             );\n         }\n \n-        self.scratch = Some(error_stack);\n+        self.scratch.replace(error_stack);\n         trace\n     }\n \n@@ -608,7 +610,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let nodes_len = self.nodes.len();\n-        let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n+        let mut node_rewrites: Vec<_> = self.scratch.replace(vec![]);\n         node_rewrites.extend(0..nodes_len);\n         let mut dead_nodes = 0;\n \n@@ -658,7 +660,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // No compression needed.\n         if dead_nodes == 0 {\n             node_rewrites.truncate(0);\n-            self.scratch = Some(node_rewrites);\n+            self.scratch.replace(node_rewrites);\n             return if do_completed == DoCompleted::Yes { Some(vec![]) } else { None };\n         }\n \n@@ -682,7 +684,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.apply_rewrites(&node_rewrites);\n \n         node_rewrites.truncate(0);\n-        self.scratch = Some(node_rewrites);\n+        self.scratch.replace(node_rewrites);\n \n         successful\n     }"}]}