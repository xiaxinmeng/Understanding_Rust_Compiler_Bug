{"sha": "c32127675a4a4b3fdf23d06602187accf584b687", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMjEyNzY3NWE0YTRiM2ZkZjIzZDA2NjAyMTg3YWNjZjU4NGI2ODc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-12T08:10:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-12T08:10:52Z"}, "message": "move guaranteed{ne,eq} implementation to compile-time machine", "tree": {"sha": "516d593b481c9c75c669097406f077c37a75e04c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/516d593b481c9c75c669097406f077c37a75e04c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c32127675a4a4b3fdf23d06602187accf584b687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c32127675a4a4b3fdf23d06602187accf584b687", "html_url": "https://github.com/rust-lang/rust/commit/c32127675a4a4b3fdf23d06602187accf584b687", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c32127675a4a4b3fdf23d06602187accf584b687/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f5c76951327b912c8e92e83235430ebd9b349d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5c76951327b912c8e92e83235430ebd9b349d9", "html_url": "https://github.com/rust-lang/rust/commit/0f5c76951327b912c8e92e83235430ebd9b349d9"}], "stats": {"total": 114, "additions": 70, "deletions": 44}, "files": [{"sha": "02e905505c0f5bbffce70e36081bd934e9dbd7a2", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c32127675a4a4b3fdf23d06602187accf584b687/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32127675a4a4b3fdf23d06602187accf584b687/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=c32127675a4a4b3fdf23d06602187accf584b687", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::Mutability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::AssertMessage;\n use rustc_session::Limit;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{sym, Symbol};\n \n use crate::interpret::{\n     self, compile_time_machine, AllocId, Allocation, Frame, GlobalId, ImmTy, InterpCx,\n@@ -176,6 +176,38 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n+impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n+    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> bool {\n+        match (a, b) {\n+            // Comparisons between integers are always known.\n+            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a == b,\n+            // Equality with integers can never be known for sure.\n+            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            // FIXME: return `true` for when both sides are the same pointer, *except* that\n+            // some things (like functions and vtables) do not have stable addresses\n+            // so we need to be careful around them (see e.g. #73722).\n+            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+        }\n+    }\n+\n+    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> bool {\n+        match (a, b) {\n+            // Comparisons between integers are always known.\n+            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a != b,\n+            // Comparisons of abstract pointers with null pointers are known if the pointer\n+            // is in bounds, because if they are in bounds, the pointer can't be null.\n+            (Scalar::Raw { data: 0, .. }, Scalar::Ptr(ptr))\n+            | (Scalar::Ptr(ptr), Scalar::Raw { data: 0, .. }) => !self.memory.ptr_may_be_null(ptr),\n+            // Inequality with integers other than null can never be known for sure.\n+            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            // FIXME: return `true` for at least some comparisons where we can reliably\n+            // determine the result of runtime inequality tests at compile-time.\n+            // Examples include comparison of addresses in different static items.\n+            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+        }\n+    }\n+}\n+\n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     compile_time_machine!(<'mir, 'tcx>);\n \n@@ -234,12 +266,45 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n+        // Shared intrinsics.\n         if ecx.emulate_intrinsic(instance, args, ret)? {\n             return Ok(());\n         }\n-        // An intrinsic that we do not support\n         let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n-        Err(ConstEvalErrKind::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n+\n+        // CTFE-specific intrinsics.\n+        let (dest, ret) = match ret {\n+            None => {\n+                return Err(ConstEvalErrKind::NeedsRfc(format!(\n+                    \"calling intrinsic `{}`\",\n+                    intrinsic_name\n+                ))\n+                .into());\n+            }\n+            Some(p) => p,\n+        };\n+        match intrinsic_name {\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+                let a = ecx.read_immediate(args[0])?.to_scalar()?;\n+                let b = ecx.read_immediate(args[1])?.to_scalar()?;\n+                let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n+                    ecx.guaranteed_eq(a, b)\n+                } else {\n+                    ecx.guaranteed_ne(a, b)\n+                };\n+                ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n+            }\n+            _ => {\n+                return Err(ConstEvalErrKind::NeedsRfc(format!(\n+                    \"calling intrinsic `{}`\",\n+                    intrinsic_name\n+                ))\n+                .into());\n+            }\n+        }\n+\n+        ecx.go_to_block(ret);\n+        Ok(())\n     }\n \n     fn assert_panic("}, {"sha": "47ca71d9642ba0f4851c719fa4c36e380af53eea", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c32127675a4a4b3fdf23d06602187accf584b687/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32127675a4a4b3fdf23d06602187accf584b687/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=c32127675a4a4b3fdf23d06602187accf584b687", "patch": "@@ -88,6 +88,8 @@ crate fn eval_nullary_intrinsic<'tcx>(\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n+    /// Here we implement the intrinsics that are common to all Miri instances; individual machines can add their own\n+    /// intrinsic handling.\n     pub fn emulate_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -328,16 +330,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let offset_ptr = ptr.ptr_wrapping_signed_offset(offset_bytes, self);\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                let a = self.read_immediate(args[0])?.to_scalar()?;\n-                let b = self.read_immediate(args[1])?.to_scalar()?;\n-                let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n-                    self.guaranteed_eq(a, b)\n-                } else {\n-                    self.guaranteed_ne(a, b)\n-                };\n-                self.write_scalar(Scalar::from_bool(cmp), dest)?;\n-            }\n             sym::ptr_offset_from => {\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n                 let b = self.read_immediate(args[1])?.to_scalar()?;\n@@ -448,37 +440,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(true)\n     }\n \n-    fn guaranteed_eq(&mut self, a: Scalar<M::PointerTag>, b: Scalar<M::PointerTag>) -> bool {\n-        match (a, b) {\n-            // Comparisons between integers are always known.\n-            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a == b,\n-            // Equality with integers can never be known for sure.\n-            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n-            // FIXME: return `true` for when both sides are the same pointer, *except* that\n-            // some things (like functions and vtables) do not have stable addresses\n-            // so we need to be careful around them.\n-            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n-        }\n-    }\n-\n-    fn guaranteed_ne(&mut self, a: Scalar<M::PointerTag>, b: Scalar<M::PointerTag>) -> bool {\n-        match (a, b) {\n-            // Comparisons between integers are always known.\n-            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a != b,\n-            // Comparisons of abstract pointers with null pointers are known if the pointer\n-            // is in bounds, because if they are in bounds, the pointer can't be null.\n-            (Scalar::Raw { data: 0, .. }, Scalar::Ptr(ptr))\n-            | (Scalar::Ptr(ptr), Scalar::Raw { data: 0, .. }) => !self.memory.ptr_may_be_null(ptr),\n-            // Inequality with integers other than null can never be known for sure.\n-            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n-            // FIXME: return `true` for at least some comparisons where we can reliably\n-            // determine the result of runtime inequality tests at compile-time.\n-            // Examples include comparison of addresses in static items, for these we can\n-            // give reliable results.\n-            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n-        }\n-    }\n-\n     pub fn exact_div(\n         &mut self,\n         a: ImmTy<'tcx, M::PointerTag>,"}]}