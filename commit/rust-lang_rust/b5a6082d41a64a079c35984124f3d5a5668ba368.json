{"sha": "b5a6082d41a64a079c35984124f3d5a5668ba368", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YTYwODJkNDFhNjRhMDc5YzM1OTg0MTI0ZjNkNWE1NjY4YmEzNjg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-03T19:04:00Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-03T19:04:00Z"}, "message": "Update valgrind.h and memcheck.h to 3.6.0", "tree": {"sha": "df810ecc6c1749f3c781e18678762c893dab52d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df810ecc6c1749f3c781e18678762c893dab52d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5a6082d41a64a079c35984124f3d5a5668ba368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a6082d41a64a079c35984124f3d5a5668ba368", "html_url": "https://github.com/rust-lang/rust/commit/b5a6082d41a64a079c35984124f3d5a5668ba368", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5a6082d41a64a079c35984124f3d5a5668ba368/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbe5dc97687a1d7dd1aaa552c8b84c22765a0e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbe5dc97687a1d7dd1aaa552c8b84c22765a0e9f", "html_url": "https://github.com/rust-lang/rust/commit/dbe5dc97687a1d7dd1aaa552c8b84c22765a0e9f"}], "stats": {"total": 1194, "additions": 1014, "deletions": 180}, "files": [{"sha": "bf95491b9b8cf7e0c3be64507f455bc1f6d857b7", "filename": "src/rt/memcheck.h", "status": "modified", "additions": 33, "deletions": 65, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b5a6082d41a64a079c35984124f3d5a5668ba368/src%2Frt%2Fmemcheck.h", "raw_url": "https://github.com/rust-lang/rust/raw/b5a6082d41a64a079c35984124f3d5a5668ba368/src%2Frt%2Fmemcheck.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemcheck.h?ref=b5a6082d41a64a079c35984124f3d5a5668ba368", "patch": "@@ -13,7 +13,7 @@\n    This file is part of MemCheck, a heavyweight Valgrind tool for\n    detecting memory errors.\n \n-   Copyright (C) 2000-2009 Julian Seward.  All rights reserved.\n+   Copyright (C) 2000-2010 Julian Seward.  All rights reserved.\n \n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n@@ -107,66 +107,48 @@ typedef\n \n /* Mark memory at _qzz_addr as unaddressable for _qzz_len bytes. */\n #define VALGRIND_MAKE_MEM_NOACCESS(_qzz_addr,_qzz_len)           \\\n-   (__extension__({unsigned long _qzz_res;                       \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0 /* default return */, \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,      \\\n                             VG_USERREQ__MAKE_MEM_NOACCESS,       \\\n-                            _qzz_addr, _qzz_len, 0, 0, 0);       \\\n-    _qzz_res;                                                    \\\n-   }))\n+                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n       \n /* Similarly, mark memory at _qzz_addr as addressable but undefined\n    for _qzz_len bytes. */\n #define VALGRIND_MAKE_MEM_UNDEFINED(_qzz_addr,_qzz_len)          \\\n-   (__extension__({unsigned long _qzz_res;                       \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0 /* default return */, \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,      \\\n                             VG_USERREQ__MAKE_MEM_UNDEFINED,      \\\n-                            _qzz_addr, _qzz_len, 0, 0, 0);       \\\n-    _qzz_res;                                                    \\\n-   }))\n+                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n \n /* Similarly, mark memory at _qzz_addr as addressable and defined\n    for _qzz_len bytes. */\n #define VALGRIND_MAKE_MEM_DEFINED(_qzz_addr,_qzz_len)            \\\n-   (__extension__({unsigned long _qzz_res;                       \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0 /* default return */, \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,      \\\n                             VG_USERREQ__MAKE_MEM_DEFINED,        \\\n-                            _qzz_addr, _qzz_len, 0, 0, 0);       \\\n-    _qzz_res;                                                    \\\n-   }))\n+                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n \n /* Similar to VALGRIND_MAKE_MEM_DEFINED except that addressability is\n    not altered: bytes which are addressable are marked as defined,\n    but those which are not addressable are left unchanged. */\n-#define VALGRIND_MAKE_MEM_DEFINED_IF_ADDRESSABLE(_qzz_addr,_qzz_len) \\\n-   (__extension__({unsigned long _qzz_res;                       \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0 /* default return */, \\\n+#define VALGRIND_MAKE_MEM_DEFINED_IF_ADDRESSABLE(_qzz_addr,_qzz_len)     \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,              \\\n                             VG_USERREQ__MAKE_MEM_DEFINED_IF_ADDRESSABLE, \\\n-                            _qzz_addr, _qzz_len, 0, 0, 0);       \\\n-    _qzz_res;                                                    \\\n-   }))\n+                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n \n /* Create a block-description handle.  The description is an ascii\n    string which is included in any messages pertaining to addresses\n    within the specified memory range.  Has no other effect on the\n    properties of the memory range. */\n-#define VALGRIND_CREATE_BLOCK(_qzz_addr,_qzz_len, _qzz_desc)\t \\\n-\t(__extension__({unsigned long _qzz_res;\t\t\t \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0 /* default return */, \\\n-                            VG_USERREQ__CREATE_BLOCK,            \\\n-                            _qzz_addr, _qzz_len, _qzz_desc,      \\\n-                            0, 0);                               \\\n-    _qzz_res;\t\t\t\t\t\t\t \\\n-   }))\n+#define VALGRIND_CREATE_BLOCK(_qzz_addr,_qzz_len, _qzz_desc)\t   \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,        \\\n+                            VG_USERREQ__CREATE_BLOCK,              \\\n+                            (_qzz_addr), (_qzz_len), (_qzz_desc),  \\\n+                            0, 0)\n \n /* Discard a block-description-handle. Returns 1 for an\n    invalid handle, 0 for a valid handle. */\n #define VALGRIND_DISCARD(_qzz_blkindex)                          \\\n-   (__extension__ ({unsigned long _qzz_res;                      \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0 /* default return */, \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,      \\\n                             VG_USERREQ__DISCARD,                 \\\n-                            0, _qzz_blkindex, 0, 0, 0);          \\\n-    _qzz_res;                                                    \\\n-   }))\n+                            0, (_qzz_blkindex), 0, 0, 0)\n \n \n /* Client-code macros to check the state of memory. */\n@@ -175,25 +157,19 @@ typedef\n    If suitable addressibility is not established, Valgrind prints an\n    error message and returns the address of the first offending byte.\n    Otherwise it returns zero. */\n-#define VALGRIND_CHECK_MEM_IS_ADDRESSABLE(_qzz_addr,_qzz_len)    \\\n-   (__extension__({unsigned long _qzz_res;                       \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                      \\\n-                            VG_USERREQ__CHECK_MEM_IS_ADDRESSABLE,\\\n-                            _qzz_addr, _qzz_len, 0, 0, 0);       \\\n-    _qzz_res;                                                    \\\n-   }))\n+#define VALGRIND_CHECK_MEM_IS_ADDRESSABLE(_qzz_addr,_qzz_len)      \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                             \\\n+                            VG_USERREQ__CHECK_MEM_IS_ADDRESSABLE,  \\\n+                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n \n /* Check that memory at _qzz_addr is addressable and defined for\n    _qzz_len bytes.  If suitable addressibility and definedness are not\n    established, Valgrind prints an error message and returns the\n    address of the first offending byte.  Otherwise it returns zero. */\n #define VALGRIND_CHECK_MEM_IS_DEFINED(_qzz_addr,_qzz_len)        \\\n-   (__extension__({unsigned long _qzz_res;                       \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                      \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                           \\\n                             VG_USERREQ__CHECK_MEM_IS_DEFINED,    \\\n-                            _qzz_addr, _qzz_len, 0, 0, 0);       \\\n-    _qzz_res;                                                    \\\n-   }))\n+                            (_qzz_addr), (_qzz_len), 0, 0, 0);\n \n /* Use this macro to force the definedness and addressibility of an\n    lvalue to be checked.  If suitable addressibility and definedness\n@@ -276,15 +252,11 @@ typedef\n    The metadata is not copied in cases 0, 2 or 3 so it should be\n    impossible to segfault your system by using this call.\n */\n-#define VALGRIND_GET_VBITS(zza,zzvbits,zznbytes)                 \\\n-   (__extension__({unsigned long _qzz_res;                       \\\n-    char* czza     = (char*)zza;                                 \\\n-    char* czzvbits = (char*)zzvbits;                             \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                      \\\n-                            VG_USERREQ__GET_VBITS,               \\\n-                            czza, czzvbits, zznbytes, 0, 0 );    \\\n-    _qzz_res;                                                    \\\n-   }))\n+#define VALGRIND_GET_VBITS(zza,zzvbits,zznbytes)                     \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                               \\\n+                                    VG_USERREQ__GET_VBITS,           \\\n+                                    (char*)(zza), (char*)(zzvbits),  \\\n+                                    (zznbytes), 0, 0)\n \n /* Set the validity data for addresses [zza..zza+zznbytes-1], copying it\n    from the provided zzvbits array.  Return values:\n@@ -295,15 +267,11 @@ typedef\n    The metadata is not copied in cases 0, 2 or 3 so it should be\n    impossible to segfault your system by using this call.\n */\n-#define VALGRIND_SET_VBITS(zza,zzvbits,zznbytes)                 \\\n-   (__extension__({unsigned int _qzz_res;                        \\\n-    char* czza     = (char*)zza;                                 \\\n-    char* czzvbits = (char*)zzvbits;                             \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                      \\\n-                            VG_USERREQ__SET_VBITS,               \\\n-                            czza, czzvbits, zznbytes, 0, 0 );    \\\n-    _qzz_res;                                                    \\\n-   }))\n+#define VALGRIND_SET_VBITS(zza,zzvbits,zznbytes)                     \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                               \\\n+                                    VG_USERREQ__SET_VBITS,           \\\n+                                    (char*)(zza), (char*)(zzvbits),  \\\n+                                    (zznbytes), 0, 0 )\n \n #endif\n "}, {"sha": "0bae0aa130eec3cf426bdff3bdd3880c7b308158", "filename": "src/rt/valgrind.h", "status": "modified", "additions": 981, "deletions": 115, "changes": 1096, "blob_url": "https://github.com/rust-lang/rust/blob/b5a6082d41a64a079c35984124f3d5a5668ba368/src%2Frt%2Fvalgrind.h", "raw_url": "https://github.com/rust-lang/rust/raw/b5a6082d41a64a079c35984124f3d5a5668ba368/src%2Frt%2Fvalgrind.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fvalgrind.h?ref=b5a6082d41a64a079c35984124f3d5a5668ba368", "patch": "@@ -12,7 +12,7 @@\n    This file is part of Valgrind, a dynamic binary instrumentation\n    framework.\n \n-   Copyright (C) 2000-2008 Julian Seward.  All rights reserved.\n+   Copyright (C) 2000-2010 Julian Seward.  All rights reserved.\n \n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n@@ -73,6 +73,25 @@\n #ifndef __VALGRIND_H\n #define __VALGRIND_H\n \n+\n+/* ------------------------------------------------------------------ */\n+/* VERSION NUMBER OF VALGRIND                                         */\n+/* ------------------------------------------------------------------ */\n+\n+/* Specify Valgrind's version number, so that user code can\n+   conditionally compile based on our version number.  Note that these\n+   were introduced at version 3.6 and so do not exist in version 3.5\n+   or earlier.  The recommended way to use them to check for \"version\n+   X.Y or later\" is (eg)\n+\n+#if defined(__VALGRIND_MAJOR__) && defined(__VALGRIND_MINOR__)   \\\n+    && (__VALGRIND_MAJOR__ > 3                                   \\\n+        || (__VALGRIND_MAJOR__ == 3 && __VALGRIND_MINOR__ >= 6))\n+*/\n+#define __VALGRIND_MAJOR__    3\n+#define __VALGRIND_MINOR__    6\n+\n+\n #include <stdarg.h>\n \n /* Nb: this file might be included in a file compiled with -ansi.  So\n@@ -84,34 +103,45 @@\n    identifying architectures, which are different to the ones we use\n    within the rest of Valgrind.  Note, __powerpc__ is active for both\n    32 and 64-bit PPC, whereas __powerpc64__ is only active for the\n-   latter (on Linux, that is). */\n+   latter (on Linux, that is).\n+\n+   Misc note: how to find out what's predefined in gcc by default:\n+   gcc -Wp,-dM somefile.c\n+*/\n+#undef PLAT_ppc64_aix5\n+#undef PLAT_ppc32_aix5\n+#undef PLAT_x86_darwin\n+#undef PLAT_amd64_darwin\n+#undef PLAT_x86_win32\n #undef PLAT_x86_linux\n #undef PLAT_amd64_linux\n #undef PLAT_ppc32_linux\n #undef PLAT_ppc64_linux\n-#undef PLAT_ppc32_aix5\n-#undef PLAT_ppc64_aix5\n+#undef PLAT_arm_linux\n \n-#if !defined(_AIX) && defined(__i386__)\n+#if defined(_AIX) && defined(__64BIT__)\n+#  define PLAT_ppc64_aix5 1\n+#elif defined(_AIX) && !defined(__64BIT__)\n+#  define PLAT_ppc32_aix5 1\n+#elif defined(__APPLE__) && defined(__i386__)\n+#  define PLAT_x86_darwin 1\n+#elif defined(__APPLE__) && defined(__x86_64__)\n+#  define PLAT_amd64_darwin 1\n+#elif defined(__MINGW32__) || defined(__CYGWIN32__) || defined(_WIN32) && defined(_M_IX86)\n+#  define PLAT_x86_win32 1\n+#elif defined(__linux__) && defined(__i386__)\n #  define PLAT_x86_linux 1\n-#elif !defined(_AIX) && defined(__x86_64__)\n+#elif defined(__linux__) && defined(__x86_64__)\n #  define PLAT_amd64_linux 1\n-#elif !defined(_AIX) && defined(__powerpc__) && !defined(__powerpc64__)\n+#elif defined(__linux__) && defined(__powerpc__) && !defined(__powerpc64__)\n #  define PLAT_ppc32_linux 1\n-#elif !defined(_AIX) && defined(__powerpc__) && defined(__powerpc64__)\n+#elif defined(__linux__) && defined(__powerpc__) && defined(__powerpc64__)\n #  define PLAT_ppc64_linux 1\n-#elif defined(_AIX) && defined(__64BIT__)\n-#  define PLAT_ppc64_aix5 1\n-#elif defined(_AIX) && !defined(__64BIT__)\n-#  define PLAT_ppc32_aix5 1\n-#endif\n-\n-\n+#elif defined(__linux__) && defined(__arm__)\n+#  define PLAT_arm_linux 1\n+#else\n /* If we're not compiling for our target platform, don't generate\n    any inline asms.  */\n-#if !defined(PLAT_x86_linux) && !defined(PLAT_amd64_linux) \\\n-    && !defined(PLAT_ppc32_linux) && !defined(PLAT_ppc64_linux) \\\n-    && !defined(PLAT_ppc32_aix5) && !defined(PLAT_ppc64_aix5)\n #  if !defined(NVALGRIND)\n #    define NVALGRIND 1\n #  endif\n@@ -172,9 +202,10 @@\n    inline asm stuff to be useful.\n */\n \n-/* ------------------------- x86-linux ------------------------- */\n+/* ------------------------- x86-{linux,darwin} ---------------- */\n \n-#if defined(PLAT_x86_linux)\n+#if defined(PLAT_x86_linux)  ||  defined(PLAT_x86_darwin)  \\\n+    ||  (defined(PLAT_x86_win32) && defined(__GNUC__))\n \n typedef\n    struct { \n@@ -224,11 +255,66 @@ typedef\n                      __SPECIAL_INSTRUCTION_PREAMBLE               \\\n                      /* call-noredir *%EAX */                     \\\n                      \"xchgl %%edx,%%edx\\n\\t\"\n-#endif /* PLAT_x86_linux */\n+#endif /* PLAT_x86_linux || PLAT_x86_darwin || (PLAT_x86_win32 && __GNUC__) */\n+\n+/* ------------------------- x86-Win32 ------------------------- */\n+\n+#if defined(PLAT_x86_win32) && !defined(__GNUC__)\n+\n+typedef\n+   struct { \n+      unsigned int nraddr; /* where's the code? */\n+   }\n+   OrigFn;\n+\n+#if defined(_MSC_VER)\n+\n+#define __SPECIAL_INSTRUCTION_PREAMBLE                            \\\n+                     __asm rol edi, 3  __asm rol edi, 13          \\\n+                     __asm rol edi, 29 __asm rol edi, 19\n+\n+#define VALGRIND_DO_CLIENT_REQUEST(                               \\\n+        _zzq_rlval, _zzq_default, _zzq_request,                   \\\n+        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \\\n+  { volatile uintptr_t _zzq_args[6];                              \\\n+    volatile unsigned int _zzq_result;                            \\\n+    _zzq_args[0] = (uintptr_t)(_zzq_request);                     \\\n+    _zzq_args[1] = (uintptr_t)(_zzq_arg1);                        \\\n+    _zzq_args[2] = (uintptr_t)(_zzq_arg2);                        \\\n+    _zzq_args[3] = (uintptr_t)(_zzq_arg3);                        \\\n+    _zzq_args[4] = (uintptr_t)(_zzq_arg4);                        \\\n+    _zzq_args[5] = (uintptr_t)(_zzq_arg5);                        \\\n+    __asm { __asm lea eax, _zzq_args __asm mov edx, _zzq_default  \\\n+            __SPECIAL_INSTRUCTION_PREAMBLE                        \\\n+            /* %EDX = client_request ( %EAX ) */                  \\\n+            __asm xchg ebx,ebx                                    \\\n+            __asm mov _zzq_result, edx                            \\\n+    }                                                             \\\n+    _zzq_rlval = _zzq_result;                                     \\\n+  }\n+\n+#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                       \\\n+  { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \\\n+    volatile unsigned int __addr;                                 \\\n+    __asm { __SPECIAL_INSTRUCTION_PREAMBLE                        \\\n+            /* %EAX = guest_NRADDR */                             \\\n+            __asm xchg ecx,ecx                                    \\\n+            __asm mov __addr, eax                                 \\\n+    }                                                             \\\n+    _zzq_orig->nraddr = __addr;                                   \\\n+  }\n+\n+#define VALGRIND_CALL_NOREDIR_EAX ERROR\n+\n+#else\n+#error Unsupported compiler.\n+#endif\n+\n+#endif /* PLAT_x86_win32 */\n \n-/* ------------------------ amd64-linux ------------------------ */\n+/* ------------------------ amd64-{linux,darwin} --------------- */\n \n-#if defined(PLAT_amd64_linux)\n+#if defined(PLAT_amd64_linux)  ||  defined(PLAT_amd64_darwin)\n \n typedef\n    struct { \n@@ -278,7 +364,7 @@ typedef\n                      __SPECIAL_INSTRUCTION_PREAMBLE               \\\n                      /* call-noredir *%RAX */                     \\\n                      \"xchgq %%rdx,%%rdx\\n\\t\"\n-#endif /* PLAT_amd64_linux */\n+#endif /* PLAT_amd64_linux || PLAT_amd64_darwin */\n \n /* ------------------------ ppc32-linux ------------------------ */\n \n@@ -406,6 +492,65 @@ typedef\n \n #endif /* PLAT_ppc64_linux */\n \n+/* ------------------------- arm-linux ------------------------- */\n+\n+#if defined(PLAT_arm_linux)\n+\n+typedef\n+   struct { \n+      unsigned int nraddr; /* where's the code? */\n+   }\n+   OrigFn;\n+\n+#define __SPECIAL_INSTRUCTION_PREAMBLE                            \\\n+            \"mov r12, r12, ror #3  ; mov r12, r12, ror #13 \\n\\t\"  \\\n+            \"mov r12, r12, ror #29 ; mov r12, r12, ror #19 \\n\\t\"\n+\n+#define VALGRIND_DO_CLIENT_REQUEST(                               \\\n+        _zzq_rlval, _zzq_default, _zzq_request,                   \\\n+        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \\\n+                                                                  \\\n+  { volatile unsigned int  _zzq_args[6];                          \\\n+    volatile unsigned int  _zzq_result;                           \\\n+    _zzq_args[0] = (unsigned int)(_zzq_request);                  \\\n+    _zzq_args[1] = (unsigned int)(_zzq_arg1);                     \\\n+    _zzq_args[2] = (unsigned int)(_zzq_arg2);                     \\\n+    _zzq_args[3] = (unsigned int)(_zzq_arg3);                     \\\n+    _zzq_args[4] = (unsigned int)(_zzq_arg4);                     \\\n+    _zzq_args[5] = (unsigned int)(_zzq_arg5);                     \\\n+    __asm__ volatile(\"mov r3, %1\\n\\t\" /*default*/                 \\\n+                     \"mov r4, %2\\n\\t\" /*ptr*/                     \\\n+                     __SPECIAL_INSTRUCTION_PREAMBLE               \\\n+                     /* R3 = client_request ( R4 ) */             \\\n+                     \"orr r10, r10, r10\\n\\t\"                      \\\n+                     \"mov %0, r3\"     /*result*/                  \\\n+                     : \"=r\" (_zzq_result)                         \\\n+                     : \"r\" (_zzq_default), \"r\" (&_zzq_args[0])    \\\n+                     : \"cc\",\"memory\", \"r3\", \"r4\");                \\\n+    _zzq_rlval = _zzq_result;                                     \\\n+  }\n+\n+#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                       \\\n+  { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \\\n+    unsigned int __addr;                                          \\\n+    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \\\n+                     /* R3 = guest_NRADDR */                      \\\n+                     \"orr r11, r11, r11\\n\\t\"                      \\\n+                     \"mov %0, r3\"                                 \\\n+                     : \"=r\" (__addr)                              \\\n+                     :                                            \\\n+                     : \"cc\", \"memory\", \"r3\"                       \\\n+                    );                                            \\\n+    _zzq_orig->nraddr = __addr;                                   \\\n+  }\n+\n+#define VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                    \\\n+                     __SPECIAL_INSTRUCTION_PREAMBLE               \\\n+                     /* branch-and-link-to-noredir *%R4 */        \\\n+                     \"orr r12, r12, r12\\n\\t\"\n+\n+#endif /* PLAT_arm_linux */\n+\n /* ------------------------ ppc32-aix5 ------------------------- */\n \n #if defined(PLAT_ppc32_aix5)\n@@ -581,11 +726,15 @@ typedef\n /* Use these to write the name of your wrapper.  NOTE: duplicates\n    VG_WRAP_FUNCTION_Z{U,Z} in pub_tool_redir.h. */\n \n+/* Use an extra level of macroisation so as to ensure the soname/fnname\n+   args are fully macro-expanded before pasting them together. */\n+#define VG_CONCAT4(_aa,_bb,_cc,_dd) _aa##_bb##_cc##_dd\n+\n #define I_WRAP_SONAME_FNNAME_ZU(soname,fnname)                    \\\n-   _vgwZU_##soname##_##fnname\n+   VG_CONCAT4(_vgwZU_,soname,_,fnname)\n \n #define I_WRAP_SONAME_FNNAME_ZZ(soname,fnname)                    \\\n-   _vgwZZ_##soname##_##fnname\n+   VG_CONCAT4(_vgwZZ_,soname,_,fnname)\n \n /* Use this macro from within a wrapper function to collect the\n    context (address and possibly other info) of the original function.\n@@ -612,9 +761,25 @@ typedef\n    do { volatile unsigned long _junk;                             \\\n         CALL_FN_W_WWW(_junk,fnptr,arg1,arg2,arg3); } while (0)\n \n-/* ------------------------- x86-linux ------------------------- */\n+#define CALL_FN_v_WWWW(fnptr, arg1,arg2,arg3,arg4)                \\\n+   do { volatile unsigned long _junk;                             \\\n+        CALL_FN_W_WWWW(_junk,fnptr,arg1,arg2,arg3,arg4); } while (0)\n+\n+#define CALL_FN_v_5W(fnptr, arg1,arg2,arg3,arg4,arg5)             \\\n+   do { volatile unsigned long _junk;                             \\\n+        CALL_FN_W_5W(_junk,fnptr,arg1,arg2,arg3,arg4,arg5); } while (0)\n+\n+#define CALL_FN_v_6W(fnptr, arg1,arg2,arg3,arg4,arg5,arg6)        \\\n+   do { volatile unsigned long _junk;                             \\\n+        CALL_FN_W_6W(_junk,fnptr,arg1,arg2,arg3,arg4,arg5,arg6); } while (0)\n+\n+#define CALL_FN_v_7W(fnptr, arg1,arg2,arg3,arg4,arg5,arg6,arg7)   \\\n+   do { volatile unsigned long _junk;                             \\\n+        CALL_FN_W_7W(_junk,fnptr,arg1,arg2,arg3,arg4,arg5,arg6,arg7); } while (0)\n+\n+/* ------------------------- x86-{linux,darwin} ---------------- */\n \n-#if defined(PLAT_x86_linux)\n+#if defined(PLAT_x86_linux)  ||  defined(PLAT_x86_darwin)\n \n /* These regs are trashed by the hidden call.  No need to mention eax\n    as gcc can already see that, plus causes gcc to bomb. */\n@@ -647,10 +812,11 @@ typedef\n       _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n       _argvec[1] = (unsigned long)(arg1);                         \\\n       __asm__ volatile(                                           \\\n+         \"subl $12, %%esp\\n\\t\"                                    \\\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $4, %%esp\\n\"                                       \\\n+         \"addl $16, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -667,11 +833,12 @@ typedef\n       _argvec[1] = (unsigned long)(arg1);                         \\\n       _argvec[2] = (unsigned long)(arg2);                         \\\n       __asm__ volatile(                                           \\\n+         \"subl $8, %%esp\\n\\t\"                                     \\\n          \"pushl 8(%%eax)\\n\\t\"                                     \\\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $8, %%esp\\n\"                                       \\\n+         \"addl $16, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -689,12 +856,13 @@ typedef\n       _argvec[2] = (unsigned long)(arg2);                         \\\n       _argvec[3] = (unsigned long)(arg3);                         \\\n       __asm__ volatile(                                           \\\n+         \"subl $4, %%esp\\n\\t\"                                     \\\n          \"pushl 12(%%eax)\\n\\t\"                                    \\\n          \"pushl 8(%%eax)\\n\\t\"                                     \\\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $12, %%esp\\n\"                                      \\\n+         \"addl $16, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -739,14 +907,15 @@ typedef\n       _argvec[4] = (unsigned long)(arg4);                         \\\n       _argvec[5] = (unsigned long)(arg5);                         \\\n       __asm__ volatile(                                           \\\n+         \"subl $12, %%esp\\n\\t\"                                    \\\n          \"pushl 20(%%eax)\\n\\t\"                                    \\\n          \"pushl 16(%%eax)\\n\\t\"                                    \\\n          \"pushl 12(%%eax)\\n\\t\"                                    \\\n          \"pushl 8(%%eax)\\n\\t\"                                     \\\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $20, %%esp\\n\"                                      \\\n+         \"addl $32, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -767,6 +936,7 @@ typedef\n       _argvec[5] = (unsigned long)(arg5);                         \\\n       _argvec[6] = (unsigned long)(arg6);                         \\\n       __asm__ volatile(                                           \\\n+         \"subl $8, %%esp\\n\\t\"                                     \\\n          \"pushl 24(%%eax)\\n\\t\"                                    \\\n          \"pushl 20(%%eax)\\n\\t\"                                    \\\n          \"pushl 16(%%eax)\\n\\t\"                                    \\\n@@ -775,7 +945,7 @@ typedef\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $24, %%esp\\n\"                                      \\\n+         \"addl $32, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -798,6 +968,7 @@ typedef\n       _argvec[6] = (unsigned long)(arg6);                         \\\n       _argvec[7] = (unsigned long)(arg7);                         \\\n       __asm__ volatile(                                           \\\n+         \"subl $4, %%esp\\n\\t\"                                     \\\n          \"pushl 28(%%eax)\\n\\t\"                                    \\\n          \"pushl 24(%%eax)\\n\\t\"                                    \\\n          \"pushl 20(%%eax)\\n\\t\"                                    \\\n@@ -807,7 +978,7 @@ typedef\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $28, %%esp\\n\"                                      \\\n+         \"addl $32, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -866,6 +1037,7 @@ typedef\n       _argvec[8] = (unsigned long)(arg8);                         \\\n       _argvec[9] = (unsigned long)(arg9);                         \\\n       __asm__ volatile(                                           \\\n+         \"subl $12, %%esp\\n\\t\"                                    \\\n          \"pushl 36(%%eax)\\n\\t\"                                    \\\n          \"pushl 32(%%eax)\\n\\t\"                                    \\\n          \"pushl 28(%%eax)\\n\\t\"                                    \\\n@@ -877,7 +1049,7 @@ typedef\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $36, %%esp\\n\"                                      \\\n+         \"addl $48, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -903,6 +1075,7 @@ typedef\n       _argvec[9] = (unsigned long)(arg9);                         \\\n       _argvec[10] = (unsigned long)(arg10);                       \\\n       __asm__ volatile(                                           \\\n+         \"subl $8, %%esp\\n\\t\"                                     \\\n          \"pushl 40(%%eax)\\n\\t\"                                    \\\n          \"pushl 36(%%eax)\\n\\t\"                                    \\\n          \"pushl 32(%%eax)\\n\\t\"                                    \\\n@@ -915,7 +1088,7 @@ typedef\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $40, %%esp\\n\"                                      \\\n+         \"addl $48, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -943,6 +1116,7 @@ typedef\n       _argvec[10] = (unsigned long)(arg10);                       \\\n       _argvec[11] = (unsigned long)(arg11);                       \\\n       __asm__ volatile(                                           \\\n+         \"subl $4, %%esp\\n\\t\"                                     \\\n          \"pushl 44(%%eax)\\n\\t\"                                    \\\n          \"pushl 40(%%eax)\\n\\t\"                                    \\\n          \"pushl 36(%%eax)\\n\\t\"                                    \\\n@@ -956,7 +1130,7 @@ typedef\n          \"pushl 4(%%eax)\\n\\t\"                                     \\\n          \"movl (%%eax), %%eax\\n\\t\"  /* target->%eax */            \\\n          VALGRIND_CALL_NOREDIR_EAX                                \\\n-         \"addl $44, %%esp\\n\"                                      \\\n+         \"addl $48, %%esp\\n\"                                      \\\n          : /*out*/   \"=a\" (_res)                                  \\\n          : /*in*/    \"a\" (&_argvec[0])                            \\\n          : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n@@ -1007,18 +1181,90 @@ typedef\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n \n-#endif /* PLAT_x86_linux */\n+#endif /* PLAT_x86_linux || PLAT_x86_darwin */\n \n-/* ------------------------ amd64-linux ------------------------ */\n+/* ------------------------ amd64-{linux,darwin} --------------- */\n \n-#if defined(PLAT_amd64_linux)\n+#if defined(PLAT_amd64_linux)  ||  defined(PLAT_amd64_darwin)\n \n /* ARGREGS: rdi rsi rdx rcx r8 r9 (the rest on stack in R-to-L order) */\n \n /* These regs are trashed by the hidden call. */\n #define __CALLER_SAVED_REGS /*\"rax\",*/ \"rcx\", \"rdx\", \"rsi\",       \\\n                             \"rdi\", \"r8\", \"r9\", \"r10\", \"r11\"\n \n+/* This is all pretty complex.  It's so as to make stack unwinding\n+   work reliably.  See bug 243270.  The basic problem is the sub and\n+   add of 128 of %rsp in all of the following macros.  If gcc believes\n+   the CFA is in %rsp, then unwinding may fail, because what's at the\n+   CFA is not what gcc \"expected\" when it constructs the CFIs for the\n+   places where the macros are instantiated.\n+\n+   But we can't just add a CFI annotation to increase the CFA offset\n+   by 128, to match the sub of 128 from %rsp, because we don't know\n+   whether gcc has chosen %rsp as the CFA at that point, or whether it\n+   has chosen some other register (eg, %rbp).  In the latter case,\n+   adding a CFI annotation to change the CFA offset is simply wrong.\n+\n+   So the solution is to get hold of the CFA using\n+   __builtin_dwarf_cfa(), put it in a known register, and add a\n+   CFI annotation to say what the register is.  We choose %rbp for\n+   this (perhaps perversely), because:\n+\n+   (1) %rbp is already subject to unwinding.  If a new register was\n+       chosen then the unwinder would have to unwind it in all stack\n+       traces, which is expensive, and\n+\n+   (2) %rbp is already subject to precise exception updates in the\n+       JIT.  If a new register was chosen, we'd have to have precise\n+       exceptions for it too, which reduces performance of the\n+       generated code.\n+\n+   However .. one extra complication.  We can't just whack the result\n+   of __builtin_dwarf_cfa() into %rbp and then add %rbp to the\n+   list of trashed registers at the end of the inline assembly\n+   fragments; gcc won't allow %rbp to appear in that list.  Hence\n+   instead we need to stash %rbp in %r15 for the duration of the asm,\n+   and say that %r15 is trashed instead.  gcc seems happy to go with\n+   that.\n+\n+   Oh .. and this all needs to be conditionalised so that it is\n+   unchanged from before this commit, when compiled with older gccs\n+   that don't support __builtin_dwarf_cfa.  Furthermore, since\n+   this header file is freestanding, it has to be independent of\n+   config.h, and so the following conditionalisation cannot depend on\n+   configure time checks.\n+\n+   Although it's not clear from\n+   'defined(__GNUC__) && defined(__GCC_HAVE_DWARF2_CFI_ASM)',\n+   this expression excludes Darwin.\n+   .cfi directives in Darwin assembly appear to be completely\n+   different and I haven't investigated how they work.\n+\n+   For even more entertainment value, note we have to use the\n+   completely undocumented __builtin_dwarf_cfa(), which appears to\n+   really compute the CFA, whereas __builtin_frame_address(0) claims\n+   to but actually doesn't.  See\n+   https://bugs.kde.org/show_bug.cgi?id=243270#c47\n+*/\n+#if defined(__GNUC__) && defined(__GCC_HAVE_DWARF2_CFI_ASM)\n+#  define __FRAME_POINTER                                         \\\n+      ,\"r\"(__builtin_dwarf_cfa())\n+#  define VALGRIND_CFI_PROLOGUE                                   \\\n+      \"movq %%rbp, %%r15\\n\\t\"                                     \\\n+      \"movq %2, %%rbp\\n\\t\"                                        \\\n+      \".cfi_remember_state\\n\\t\"                                   \\\n+      \".cfi_def_cfa rbp, 0\\n\\t\"\n+#  define VALGRIND_CFI_EPILOGUE                                   \\\n+      \"movq %%r15, %%rbp\\n\\t\"                                     \\\n+      \".cfi_restore_state\\n\\t\"\n+#else\n+#  define __FRAME_POINTER\n+#  define VALGRIND_CFI_PROLOGUE\n+#  define VALGRIND_CFI_EPILOGUE\n+#endif\n+\n+\n /* These CALL_FN_ macros assume that on amd64-linux, sizeof(unsigned\n    long) == 8. */\n \n@@ -1050,13 +1296,15 @@ typedef\n       volatile unsigned long _res;                                \\\n       _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1069,14 +1317,16 @@ typedef\n       _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n       _argvec[1] = (unsigned long)(arg1);                         \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"movq 8(%%rax), %%rdi\\n\\t\"                               \\\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1090,15 +1340,17 @@ typedef\n       _argvec[1] = (unsigned long)(arg1);                         \\\n       _argvec[2] = (unsigned long)(arg2);                         \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"movq 16(%%rax), %%rsi\\n\\t\"                              \\\n          \"movq 8(%%rax), %%rdi\\n\\t\"                               \\\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1113,16 +1365,18 @@ typedef\n       _argvec[2] = (unsigned long)(arg2);                         \\\n       _argvec[3] = (unsigned long)(arg3);                         \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"movq 24(%%rax), %%rdx\\n\\t\"                              \\\n          \"movq 16(%%rax), %%rsi\\n\\t\"                              \\\n          \"movq 8(%%rax), %%rdi\\n\\t\"                               \\\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1138,6 +1392,7 @@ typedef\n       _argvec[3] = (unsigned long)(arg3);                         \\\n       _argvec[4] = (unsigned long)(arg4);                         \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"movq 32(%%rax), %%rcx\\n\\t\"                              \\\n          \"movq 24(%%rax), %%rdx\\n\\t\"                              \\\n@@ -1146,9 +1401,10 @@ typedef\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1165,6 +1421,7 @@ typedef\n       _argvec[4] = (unsigned long)(arg4);                         \\\n       _argvec[5] = (unsigned long)(arg5);                         \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"movq 40(%%rax), %%r8\\n\\t\"                               \\\n          \"movq 32(%%rax), %%rcx\\n\\t\"                              \\\n@@ -1174,9 +1431,10 @@ typedef\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1194,6 +1452,7 @@ typedef\n       _argvec[5] = (unsigned long)(arg5);                         \\\n       _argvec[6] = (unsigned long)(arg6);                         \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"movq 48(%%rax), %%r9\\n\\t\"                               \\\n          \"movq 40(%%rax), %%r8\\n\\t\"                               \\\n@@ -1202,11 +1461,12 @@ typedef\n          \"movq 16(%%rax), %%rsi\\n\\t\"                              \\\n          \"movq 8(%%rax), %%rdi\\n\\t\"                               \\\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n-         \"addq $128,%%rsp\\n\\t\"                                    \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n+         \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1226,7 +1486,8 @@ typedef\n       _argvec[6] = (unsigned long)(arg6);                         \\\n       _argvec[7] = (unsigned long)(arg7);                         \\\n       __asm__ volatile(                                           \\\n-         \"subq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n+         \"subq $136,%%rsp\\n\\t\"                                    \\\n          \"pushq 56(%%rax)\\n\\t\"                                    \\\n          \"movq 48(%%rax), %%r9\\n\\t\"                               \\\n          \"movq 40(%%rax), %%r8\\n\\t\"                               \\\n@@ -1237,10 +1498,11 @@ typedef\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $8, %%rsp\\n\"                                       \\\n-         \"addq $128,%%rsp\\n\\t\"                                    \\\n+         \"addq $136,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1261,6 +1523,7 @@ typedef\n       _argvec[7] = (unsigned long)(arg7);                         \\\n       _argvec[8] = (unsigned long)(arg8);                         \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"pushq 64(%%rax)\\n\\t\"                                    \\\n          \"pushq 56(%%rax)\\n\\t\"                                    \\\n@@ -1274,9 +1537,10 @@ typedef\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $16, %%rsp\\n\"                                      \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1298,7 +1562,8 @@ typedef\n       _argvec[8] = (unsigned long)(arg8);                         \\\n       _argvec[9] = (unsigned long)(arg9);                         \\\n       __asm__ volatile(                                           \\\n-         \"subq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n+         \"subq $136,%%rsp\\n\\t\"                                    \\\n          \"pushq 72(%%rax)\\n\\t\"                                    \\\n          \"pushq 64(%%rax)\\n\\t\"                                    \\\n          \"pushq 56(%%rax)\\n\\t\"                                    \\\n@@ -1311,10 +1576,11 @@ typedef\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $24, %%rsp\\n\"                                      \\\n-         \"addq $128,%%rsp\\n\\t\"                                    \\\n+         \"addq $136,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1337,6 +1603,7 @@ typedef\n       _argvec[9] = (unsigned long)(arg9);                         \\\n       _argvec[10] = (unsigned long)(arg10);                       \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"pushq 80(%%rax)\\n\\t\"                                    \\\n          \"pushq 72(%%rax)\\n\\t\"                                    \\\n@@ -1352,9 +1619,10 @@ typedef\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $32, %%rsp\\n\"                                      \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1378,7 +1646,8 @@ typedef\n       _argvec[10] = (unsigned long)(arg10);                       \\\n       _argvec[11] = (unsigned long)(arg11);                       \\\n       __asm__ volatile(                                           \\\n-         \"subq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n+         \"subq $136,%%rsp\\n\\t\"                                    \\\n          \"pushq 88(%%rax)\\n\\t\"                                    \\\n          \"pushq 80(%%rax)\\n\\t\"                                    \\\n          \"pushq 72(%%rax)\\n\\t\"                                    \\\n@@ -1393,10 +1662,11 @@ typedef\n          \"movq (%%rax), %%rax\\n\\t\"  /* target->%rax */            \\\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $40, %%rsp\\n\"                                      \\\n-         \"addq $128,%%rsp\\n\\t\"                                    \\\n+         \"addq $136,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n@@ -1421,6 +1691,7 @@ typedef\n       _argvec[11] = (unsigned long)(arg11);                       \\\n       _argvec[12] = (unsigned long)(arg12);                       \\\n       __asm__ volatile(                                           \\\n+         VALGRIND_CFI_PROLOGUE                                    \\\n          \"subq $128,%%rsp\\n\\t\"                                    \\\n          \"pushq 96(%%rax)\\n\\t\"                                    \\\n          \"pushq 88(%%rax)\\n\\t\"                                    \\\n@@ -1438,14 +1709,15 @@ typedef\n          VALGRIND_CALL_NOREDIR_RAX                                \\\n          \"addq $48, %%rsp\\n\"                                      \\\n          \"addq $128,%%rsp\\n\\t\"                                    \\\n+         VALGRIND_CFI_EPILOGUE                                    \\\n          : /*out*/   \"=a\" (_res)                                  \\\n-         : /*in*/    \"a\" (&_argvec[0])                            \\\n-         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+         : /*in*/    \"a\" (&_argvec[0]) __FRAME_POINTER            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS, \"r15\"   \\\n       );                                                          \\\n       lval = (__typeof__(lval)) _res;                             \\\n    } while (0)\n \n-#endif /* PLAT_amd64_linux */\n+#endif /* PLAT_amd64_linux || PLAT_amd64_darwin */\n \n /* ------------------------ ppc32-linux ------------------------ */\n \n@@ -2438,6 +2710,422 @@ typedef\n \n #endif /* PLAT_ppc64_linux */\n \n+/* ------------------------- arm-linux ------------------------- */\n+\n+#if defined(PLAT_arm_linux)\n+\n+/* These regs are trashed by the hidden call. */\n+#define __CALLER_SAVED_REGS \"r0\", \"r1\", \"r2\", \"r3\",\"r4\",\"r14\"\n+\n+/* These CALL_FN_ macros assume that on arm-linux, sizeof(unsigned\n+   long) == 4. */\n+\n+#define CALL_FN_W_v(lval, orig)                                   \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[1];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"mov %0, r0\\n\"                                           \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_W(lval, orig, arg1)                             \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[2];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"mov %0, r0\\n\"                                           \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\",  __CALLER_SAVED_REGS         \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_WW(lval, orig, arg1,arg2)                       \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[3];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"mov %0, r0\\n\"                                           \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_WWW(lval, orig, arg1,arg2,arg3)                 \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[4];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"mov %0, r0\\n\"                                           \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_WWWW(lval, orig, arg1,arg2,arg3,arg4)           \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[5];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_5W(lval, orig, arg1,arg2,arg3,arg4,arg5)        \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[6];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      _argvec[5] = (unsigned long)(arg5);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #20] \\n\\t\"                                 \\\n+         \"push {r0} \\n\\t\"                                         \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"add sp, sp, #4 \\n\\t\"                                    \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_6W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6)   \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[7];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      _argvec[5] = (unsigned long)(arg5);                         \\\n+      _argvec[6] = (unsigned long)(arg6);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #20] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #24] \\n\\t\"                                 \\\n+         \"push {r0, r1} \\n\\t\"                                     \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"add sp, sp, #8 \\n\\t\"                                    \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_7W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \\\n+                                 arg7)                            \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[8];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      _argvec[5] = (unsigned long)(arg5);                         \\\n+      _argvec[6] = (unsigned long)(arg6);                         \\\n+      _argvec[7] = (unsigned long)(arg7);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #20] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #24] \\n\\t\"                                 \\\n+         \"ldr r2, [%1, #28] \\n\\t\"                                 \\\n+         \"push {r0, r1, r2} \\n\\t\"                                 \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"add sp, sp, #12 \\n\\t\"                                   \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_8W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \\\n+                                 arg7,arg8)                       \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[9];                          \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      _argvec[5] = (unsigned long)(arg5);                         \\\n+      _argvec[6] = (unsigned long)(arg6);                         \\\n+      _argvec[7] = (unsigned long)(arg7);                         \\\n+      _argvec[8] = (unsigned long)(arg8);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #20] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #24] \\n\\t\"                                 \\\n+         \"ldr r2, [%1, #28] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #32] \\n\\t\"                                 \\\n+         \"push {r0, r1, r2, r3} \\n\\t\"                             \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"add sp, sp, #16 \\n\\t\"                                   \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_9W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \\\n+                                 arg7,arg8,arg9)                  \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[10];                         \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      _argvec[5] = (unsigned long)(arg5);                         \\\n+      _argvec[6] = (unsigned long)(arg6);                         \\\n+      _argvec[7] = (unsigned long)(arg7);                         \\\n+      _argvec[8] = (unsigned long)(arg8);                         \\\n+      _argvec[9] = (unsigned long)(arg9);                         \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #20] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #24] \\n\\t\"                                 \\\n+         \"ldr r2, [%1, #28] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #32] \\n\\t\"                                 \\\n+         \"ldr r4, [%1, #36] \\n\\t\"                                 \\\n+         \"push {r0, r1, r2, r3, r4} \\n\\t\"                         \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"add sp, sp, #20 \\n\\t\"                                   \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_10W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \\\n+                                  arg7,arg8,arg9,arg10)           \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[11];                         \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      _argvec[5] = (unsigned long)(arg5);                         \\\n+      _argvec[6] = (unsigned long)(arg6);                         \\\n+      _argvec[7] = (unsigned long)(arg7);                         \\\n+      _argvec[8] = (unsigned long)(arg8);                         \\\n+      _argvec[9] = (unsigned long)(arg9);                         \\\n+      _argvec[10] = (unsigned long)(arg10);                       \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #40] \\n\\t\"                                 \\\n+         \"push {r0} \\n\\t\"                                         \\\n+         \"ldr r0, [%1, #20] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #24] \\n\\t\"                                 \\\n+         \"ldr r2, [%1, #28] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #32] \\n\\t\"                                 \\\n+         \"ldr r4, [%1, #36] \\n\\t\"                                 \\\n+         \"push {r0, r1, r2, r3, r4} \\n\\t\"                         \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"add sp, sp, #24 \\n\\t\"                                   \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_11W(lval, orig, arg1,arg2,arg3,arg4,arg5,       \\\n+                                  arg6,arg7,arg8,arg9,arg10,      \\\n+                                  arg11)                          \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[12];                         \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      _argvec[5] = (unsigned long)(arg5);                         \\\n+      _argvec[6] = (unsigned long)(arg6);                         \\\n+      _argvec[7] = (unsigned long)(arg7);                         \\\n+      _argvec[8] = (unsigned long)(arg8);                         \\\n+      _argvec[9] = (unsigned long)(arg9);                         \\\n+      _argvec[10] = (unsigned long)(arg10);                       \\\n+      _argvec[11] = (unsigned long)(arg11);                       \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #40] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #44] \\n\\t\"                                 \\\n+         \"push {r0, r1} \\n\\t\"                                     \\\n+         \"ldr r0, [%1, #20] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #24] \\n\\t\"                                 \\\n+         \"ldr r2, [%1, #28] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #32] \\n\\t\"                                 \\\n+         \"ldr r4, [%1, #36] \\n\\t\"                                 \\\n+         \"push {r0, r1, r2, r3, r4} \\n\\t\"                         \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"add sp, sp, #28 \\n\\t\"                                   \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\",__CALLER_SAVED_REGS           \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#define CALL_FN_W_12W(lval, orig, arg1,arg2,arg3,arg4,arg5,       \\\n+                                  arg6,arg7,arg8,arg9,arg10,      \\\n+                                  arg11,arg12)                    \\\n+   do {                                                           \\\n+      volatile OrigFn        _orig = (orig);                      \\\n+      volatile unsigned long _argvec[13];                         \\\n+      volatile unsigned long _res;                                \\\n+      _argvec[0] = (unsigned long)_orig.nraddr;                   \\\n+      _argvec[1] = (unsigned long)(arg1);                         \\\n+      _argvec[2] = (unsigned long)(arg2);                         \\\n+      _argvec[3] = (unsigned long)(arg3);                         \\\n+      _argvec[4] = (unsigned long)(arg4);                         \\\n+      _argvec[5] = (unsigned long)(arg5);                         \\\n+      _argvec[6] = (unsigned long)(arg6);                         \\\n+      _argvec[7] = (unsigned long)(arg7);                         \\\n+      _argvec[8] = (unsigned long)(arg8);                         \\\n+      _argvec[9] = (unsigned long)(arg9);                         \\\n+      _argvec[10] = (unsigned long)(arg10);                       \\\n+      _argvec[11] = (unsigned long)(arg11);                       \\\n+      _argvec[12] = (unsigned long)(arg12);                       \\\n+      __asm__ volatile(                                           \\\n+         \"ldr r0, [%1, #40] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #44] \\n\\t\"                                 \\\n+         \"ldr r2, [%1, #48] \\n\\t\"                                 \\\n+         \"push {r0, r1, r2} \\n\\t\"                                 \\\n+         \"ldr r0, [%1, #20] \\n\\t\"                                 \\\n+         \"ldr r1, [%1, #24] \\n\\t\"                                 \\\n+         \"ldr r2, [%1, #28] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #32] \\n\\t\"                                 \\\n+         \"ldr r4, [%1, #36] \\n\\t\"                                 \\\n+         \"push {r0, r1, r2, r3, r4} \\n\\t\"                         \\\n+         \"ldr r0, [%1, #4] \\n\\t\"                                  \\\n+         \"ldr r1, [%1, #8] \\n\\t\"                                  \\\n+         \"ldr r2, [%1, #12] \\n\\t\"                                 \\\n+         \"ldr r3, [%1, #16] \\n\\t\"                                 \\\n+         \"ldr r4, [%1] \\n\\t\"  /* target->r4 */                    \\\n+         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \\\n+         \"add sp, sp, #32 \\n\\t\"                                   \\\n+         \"mov %0, r0\"                                             \\\n+         : /*out*/   \"=r\" (_res)                                  \\\n+         : /*in*/    \"0\" (&_argvec[0])                            \\\n+         : /*trash*/ \"cc\", \"memory\", __CALLER_SAVED_REGS          \\\n+      );                                                          \\\n+      lval = (__typeof__(lval)) _res;                             \\\n+   } while (0)\n+\n+#endif /* PLAT_arm_linux */\n+\n /* ------------------------ ppc32-aix5 ------------------------- */\n \n #if defined(PLAT_ppc32_aix5)\n@@ -3619,30 +4307,95 @@ typedef\n           VG_USERREQ__MEMPOOL_EXISTS   = 0x130a,\n \n           /* Allow printfs to valgrind log. */\n+          /* The first two pass the va_list argument by value, which\n+             assumes it is the same size as or smaller than a UWord,\n+             which generally isn't the case.  Hence are deprecated.\n+             The second two pass the vargs by reference and so are\n+             immune to this problem. */\n+          /* both :: char* fmt, va_list vargs (DEPRECATED) */\n           VG_USERREQ__PRINTF           = 0x1401,\n           VG_USERREQ__PRINTF_BACKTRACE = 0x1402,\n+          /* both :: char* fmt, va_list* vargs */\n+          VG_USERREQ__PRINTF_VALIST_BY_REF = 0x1403,\n+          VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF = 0x1404,\n \n           /* Stack support. */\n           VG_USERREQ__STACK_REGISTER   = 0x1501,\n           VG_USERREQ__STACK_DEREGISTER = 0x1502,\n-          VG_USERREQ__STACK_CHANGE     = 0x1503\n+          VG_USERREQ__STACK_CHANGE     = 0x1503,\n+\n+          /* Wine support */\n+          VG_USERREQ__LOAD_PDB_DEBUGINFO = 0x1601,\n+\n+          /* Querying of debug info. */\n+          VG_USERREQ__MAP_IP_TO_SRCLOC = 0x1701\n    } Vg_ClientRequest;\n \n #if !defined(__GNUC__)\n #  define __extension__ /* */\n #endif\n \n+\n+/*\n+ * VALGRIND_DO_CLIENT_REQUEST_EXPR(): a C expression that invokes a Valgrind\n+ * client request and whose value equals the client request result.\n+ */\n+\n+#if defined(NVALGRIND)\n+\n+#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                               \\\n+        _zzq_default, _zzq_request,                                    \\\n+        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)         \\\n+   (_zzq_default)\n+\n+#else /*defined(NVALGRIND)*/\n+\n+#if defined(_MSC_VER)\n+\n+#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                                \\\n+        _zzq_default, _zzq_request,                                     \\\n+        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)          \\\n+   (vg_VALGRIND_DO_CLIENT_REQUEST_EXPR((uintptr_t)(_zzq_default),       \\\n+        (_zzq_request), (uintptr_t)(_zzq_arg1), (uintptr_t)(_zzq_arg2), \\\n+        (uintptr_t)(_zzq_arg3), (uintptr_t)(_zzq_arg4),                 \\\n+        (uintptr_t)(_zzq_arg5)))\n+\n+static __inline unsigned\n+vg_VALGRIND_DO_CLIENT_REQUEST_EXPR(uintptr_t _zzq_default,\n+                                   unsigned _zzq_request, uintptr_t _zzq_arg1,\n+                                   uintptr_t _zzq_arg2, uintptr_t _zzq_arg3,\n+                                   uintptr_t _zzq_arg4, uintptr_t _zzq_arg5)\n+{\n+    unsigned _zzq_rlval;\n+    VALGRIND_DO_CLIENT_REQUEST(_zzq_rlval, _zzq_default, _zzq_request,\n+                      _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5);\n+    return _zzq_rlval;\n+}\n+\n+#else /*defined(_MSC_VER)*/\n+\n+#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                               \\\n+        _zzq_default, _zzq_request,                                    \\\n+        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)         \\\n+   (__extension__({unsigned int _zzq_rlval;                            \\\n+    VALGRIND_DO_CLIENT_REQUEST(_zzq_rlval, _zzq_default, _zzq_request, \\\n+                _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5) \\\n+    _zzq_rlval;                                                        \\\n+   }))\n+\n+#endif /*defined(_MSC_VER)*/\n+\n+#endif /*defined(NVALGRIND)*/\n+\n+\n /* Returns the number of Valgrinds this code is running under.  That\n    is, 0 if running natively, 1 if running under Valgrind, 2 if\n    running under Valgrind which is running under another Valgrind,\n    etc. */\n-#define RUNNING_ON_VALGRIND  __extension__                        \\\n-   ({unsigned int _qzz_res;                                       \\\n-    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0 /* if not */,          \\\n-                               VG_USERREQ__RUNNING_ON_VALGRIND,   \\\n-                               0, 0, 0, 0, 0);                    \\\n-    _qzz_res;                                                     \\\n-   })\n+#define RUNNING_ON_VALGRIND                                           \\\n+    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* if not */,                   \\\n+                                    VG_USERREQ__RUNNING_ON_VALGRIND,  \\\n+                                    0, 0, 0, 0, 0)                    \\\n \n \n /* Discard translation of code in the range [_qzz_addr .. _qzz_addr +\n@@ -3658,7 +4411,9 @@ typedef\n \n \n /* These requests are for getting Valgrind itself to print something.\n-   Possibly with a backtrace.  This is a really ugly hack. */\n+   Possibly with a backtrace.  This is a really ugly hack.  The return value\n+   is the number of characters printed, excluding the \"**<pid>** \" part at the\n+   start and the backtrace (if present). */\n \n #if defined(NVALGRIND)\n \n@@ -3667,34 +4422,64 @@ typedef\n \n #else /* NVALGRIND */\n \n+#if !defined(_MSC_VER)\n /* Modern GCC will optimize the static routine out if unused,\n    and unused attribute will shut down warnings about it.  */\n static int VALGRIND_PRINTF(const char *format, ...)\n    __attribute__((format(__printf__, 1, 2), __unused__));\n+#endif\n static int\n+#if defined(_MSC_VER)\n+__inline\n+#endif\n VALGRIND_PRINTF(const char *format, ...)\n {\n    unsigned long _qzz_res;\n    va_list vargs;\n    va_start(vargs, format);\n-   VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0, VG_USERREQ__PRINTF,\n-                              (unsigned long)format, (unsigned long)vargs, \n+#if defined(_MSC_VER)\n+   VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,\n+                              VG_USERREQ__PRINTF_VALIST_BY_REF,\n+                              (uintptr_t)format,\n+                              (uintptr_t)&vargs,\n+                              0, 0, 0);\n+#else\n+   VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,\n+                              VG_USERREQ__PRINTF_VALIST_BY_REF,\n+                              (unsigned long)format,\n+                              (unsigned long)&vargs, \n                               0, 0, 0);\n+#endif\n    va_end(vargs);\n    return (int)_qzz_res;\n }\n \n+#if !defined(_MSC_VER)\n static int VALGRIND_PRINTF_BACKTRACE(const char *format, ...)\n    __attribute__((format(__printf__, 1, 2), __unused__));\n+#endif\n static int\n+#if defined(_MSC_VER)\n+__inline\n+#endif\n VALGRIND_PRINTF_BACKTRACE(const char *format, ...)\n {\n    unsigned long _qzz_res;\n    va_list vargs;\n    va_start(vargs, format);\n-   VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0, VG_USERREQ__PRINTF_BACKTRACE,\n-                              (unsigned long)format, (unsigned long)vargs, \n+#if defined(_MSC_VER)\n+   VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,\n+                              VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF,\n+                              (uintptr_t)format,\n+                              (uintptr_t)&vargs,\n                               0, 0, 0);\n+#else\n+   VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,\n+                              VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF,\n+                              (unsigned long)format,\n+                              (unsigned long)&vargs, \n+                              0, 0, 0);\n+#endif\n    va_end(vargs);\n    return (int)_qzz_res;\n }\n@@ -3779,42 +4564,103 @@ VALGRIND_PRINTF_BACKTRACE(const char *format, ...)\n     _qyy_res;                                                     \\\n    })\n \n-/* Mark a block of memory as having been allocated by a malloc()-like\n-   function.  `addr' is the start of the usable block (ie. after any\n-   redzone) `rzB' is redzone size if the allocator can apply redzones;\n-   use '0' if not.  Adding redzones makes it more likely Valgrind will spot\n-   block overruns.  `is_zeroed' indicates if the memory is zeroed, as it is\n-   for calloc().  Put it immediately after the point where a block is\n-   allocated. \n+/* Several Valgrind tools (Memcheck, Massif, Helgrind, DRD) rely on knowing\n+   when heap blocks are allocated in order to give accurate results.  This\n+   happens automatically for the standard allocator functions such as\n+   malloc(), calloc(), realloc(), memalign(), new, new[], free(), delete,\n+   delete[], etc.\n+\n+   But if your program uses a custom allocator, this doesn't automatically\n+   happen, and Valgrind will not do as well.  For example, if you allocate\n+   superblocks with mmap() and then allocates chunks of the superblocks, all\n+   Valgrind's observations will be at the mmap() level and it won't know that\n+   the chunks should be considered separate entities.  In Memcheck's case,\n+   that means you probably won't get heap block overrun detection (because\n+   there won't be redzones marked as unaddressable) and you definitely won't\n+   get any leak detection.\n+\n+   The following client requests allow a custom allocator to be annotated so\n+   that it can be handled accurately by Valgrind.\n+\n+   VALGRIND_MALLOCLIKE_BLOCK marks a region of memory as having been allocated\n+   by a malloc()-like function.  For Memcheck (an illustrative case), this\n+   does two things:\n+\n+   - It records that the block has been allocated.  This means any addresses\n+     within the block mentioned in error messages will be\n+     identified as belonging to the block.  It also means that if the block\n+     isn't freed it will be detected by the leak checker.\n+\n+   - It marks the block as being addressable and undefined (if 'is_zeroed' is\n+     not set), or addressable and defined (if 'is_zeroed' is set).  This\n+     controls how accesses to the block by the program are handled.\n+   \n+   'addr' is the start of the usable block (ie. after any\n+   redzone), 'sizeB' is its size.  'rzB' is the redzone size if the allocator\n+   can apply redzones -- these are blocks of padding at the start and end of\n+   each block.  Adding redzones is recommended as it makes it much more likely\n+   Valgrind will spot block overruns.  `is_zeroed' indicates if the memory is\n+   zeroed (or filled with another predictable value), as is the case for\n+   calloc().\n+   \n+   VALGRIND_MALLOCLIKE_BLOCK should be put immediately after the point where a\n+   heap block -- that will be used by the client program -- is allocated.\n+   It's best to put it at the outermost level of the allocator if possible;\n+   for example, if you have a function my_alloc() which calls\n+   internal_alloc(), and the client request is put inside internal_alloc(),\n+   stack traces relating to the heap block will contain entries for both\n+   my_alloc() and internal_alloc(), which is probably not what you want.\n+\n+   For Memcheck users: if you use VALGRIND_MALLOCLIKE_BLOCK to carve out\n+   custom blocks from within a heap block, B, that has been allocated with\n+   malloc/calloc/new/etc, then block B will be *ignored* during leak-checking\n+   -- the custom blocks will take precedence.\n+\n+   VALGRIND_FREELIKE_BLOCK is the partner to VALGRIND_MALLOCLIKE_BLOCK.  For\n+   Memcheck, it does two things:\n+\n+   - It records that the block has been deallocated.  This assumes that the\n+     block was annotated as having been allocated via\n+     VALGRIND_MALLOCLIKE_BLOCK.  Otherwise, an error will be issued.\n+\n+   - It marks the block as being unaddressable.\n+\n+   VALGRIND_FREELIKE_BLOCK should be put immediately after the point where a\n+   heap block is deallocated.\n+\n+   In many cases, these two client requests will not be enough to get your\n+   allocator working well with Memcheck.  More specifically, if your allocator\n+   writes to freed blocks in any way then a VALGRIND_MAKE_MEM_UNDEFINED call\n+   will be necessary to mark the memory as addressable just before the zeroing\n+   occurs, otherwise you'll get a lot of invalid write errors.  For example,\n+   you'll need to do this if your allocator recycles freed blocks, but it\n+   zeroes them before handing them back out (via VALGRIND_MALLOCLIKE_BLOCK).\n+   Alternatively, if your allocator reuses freed blocks for allocator-internal\n+   data structures, VALGRIND_MAKE_MEM_UNDEFINED calls will also be necessary.\n+\n+   Really, what's happening is a blurring of the lines between the client\n+   program and the allocator... after VALGRIND_FREELIKE_BLOCK is called, the\n+   memory should be considered unaddressable to the client program, but the\n+   allocator knows more than the rest of the client program and so may be able\n+   to safely access it.  Extra client requests are necessary for Valgrind to\n+   understand the distinction between the allocator and the rest of the\n+   program.\n+\n+   Note: there is currently no VALGRIND_REALLOCLIKE_BLOCK client request;  it\n+   has to be emulated with MALLOCLIKE/FREELIKE and memory copying.\n    \n-   If you're using Memcheck: If you're allocating memory via superblocks,\n-   and then handing out small chunks of each superblock, if you don't have\n-   redzones on your small blocks, it's worth marking the superblock with\n-   VALGRIND_MAKE_MEM_NOACCESS when it's created, so that block overruns are\n-   detected.  But if you can put redzones on, it's probably better to not do\n-   this, so that messages for small overruns are described in terms of the\n-   small block rather than the superblock (but if you have a big overrun\n-   that skips over a redzone, you could miss an error this way).  See\n-   memcheck/tests/custom_alloc.c for an example.\n-\n-   WARNING: if your allocator uses malloc() or 'new' to allocate\n-   superblocks, rather than mmap() or brk(), this will not work properly --\n-   you'll likely get assertion failures during leak detection.  This is\n-   because Valgrind doesn't like seeing overlapping heap blocks.  Sorry.\n-\n-   Nb: block must be freed via a free()-like function specified\n-   with VALGRIND_FREELIKE_BLOCK or mismatch errors will occur. */\n+   Ignored if addr == 0.\n+*/\n #define VALGRIND_MALLOCLIKE_BLOCK(addr, sizeB, rzB, is_zeroed)    \\\n    {unsigned int _qzz_res;                                        \\\n     VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                       \\\n                                VG_USERREQ__MALLOCLIKE_BLOCK,      \\\n                                addr, sizeB, rzB, is_zeroed, 0);   \\\n    }\n \n-/* Mark a block of memory as having been freed by a free()-like function.\n-   `rzB' is redzone size;  it must match that given to\n-   VALGRIND_MALLOCLIKE_BLOCK.  Memory not freed will be detected by the leak\n-   checker.  Put it immediately after the point where the block is freed. */\n+/* See the comment for VALGRIND_MALLOCLIKE_BLOCK for details.\n+   Ignored if addr == 0.\n+*/\n #define VALGRIND_FREELIKE_BLOCK(addr, rzB)                        \\\n    {unsigned int _qzz_res;                                        \\\n     VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                       \\\n@@ -3915,11 +4761,31 @@ VALGRIND_PRINTF_BACKTRACE(const char *format, ...)\n                                id, start, end, 0, 0);             \\\n    }\n \n+/* Load PDB debug info for Wine PE image_map. */\n+#define VALGRIND_LOAD_PDB_DEBUGINFO(fd, ptr, total_size, delta)   \\\n+   {unsigned int _qzz_res;                                        \\\n+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                       \\\n+                               VG_USERREQ__LOAD_PDB_DEBUGINFO,    \\\n+                               fd, ptr, total_size, delta, 0);    \\\n+   }\n+\n+/* Map a code address to a source file name and line number.  buf64\n+   must point to a 64-byte buffer in the caller's address space.  The\n+   result will be dumped in there and is guaranteed to be zero\n+   terminated.  If no info is found, the first byte is set to zero. */\n+#define VALGRIND_MAP_IP_TO_SRCLOC(addr, buf64)                    \\\n+   {unsigned int _qzz_res;                                        \\\n+    VALGRIND_DO_CLIENT_REQUEST(_qzz_res, 0,                       \\\n+                               VG_USERREQ__MAP_IP_TO_SRCLOC,      \\\n+                               addr, buf64, 0, 0, 0);             \\\n+   }\n+\n \n #undef PLAT_x86_linux\n #undef PLAT_amd64_linux\n #undef PLAT_ppc32_linux\n #undef PLAT_ppc64_linux\n+#undef PLAT_arm_linux\n #undef PLAT_ppc32_aix5\n #undef PLAT_ppc64_aix5\n "}]}