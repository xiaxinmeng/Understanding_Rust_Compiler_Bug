{"sha": "261abbf45ea8558ee8fb7332606691f136c73982", "node_id": "C_kwDOAAsO6NoAKDI2MWFiYmY0NWVhODU1OGVlOGZiNzMzMjYwNjY5MWYxMzZjNzM5ODI", "commit": {"author": {"name": "Daniel Conley", "email": "himself@danii.dev", "date": "2022-01-28T19:44:17Z"}, "committer": {"name": "Daniel Conley", "email": "himself@danii.dev", "date": "2022-01-28T19:44:17Z"}, "message": "Add Keyword Return Type Highlighting", "tree": {"sha": "a6c8d29fd0e577b963a656a0f94d626263cc3243", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6c8d29fd0e577b963a656a0f94d626263cc3243"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/261abbf45ea8558ee8fb7332606691f136c73982", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE3a0fQwhlargOXuthlMIeegYH8dwFAmH0R5EACgkQlMIeegYH\n8dwtvg/9GOextBulOcuBHUhaVGXi3H6r9cvUJeC5nb5CdoinbiQ/mIpeRXUnz/jy\nadSPW31psHjgBwiBDMGIktJEQFM3d5q9fp11OgowZ4dMROlkJi7AKUHxpEqgG1aZ\nYFngcXBxz/Awdd2sajT34g7gCweIFHwu9Ixjwy9ADEaG/p893Sw4MrB55djiBcKf\nKqIdBgYRyjR81RPGjr8fxmAW/WpBB9t0Ky7y/X1RvkT5wU4oq9B0ZIut5S1AsXDc\nrh8Rj9FgxnvfXvzTLSx8L8yHQM/JUGzgJ5KX5ELaAedcZOgztrUXcYb9PhCgZyS2\nhVLO00uzsnSNXPBZU9eBvJrlKQrfF8ea/EHmBH7ux6f1Ydb/yECyt8rIAPX4Dkqq\nsJvafYMrenjs9myDou3yJJ8l0v1kyLQnNgdUNbl64mZfONLWWcdLbeLd5r/0bCDa\nK8yk0kUiqRqfKCF/OHTLy1DefBp4xVufxv4vCsCi4cfqdgWPKG0KB8pfpO6CvPUp\n2RhceoXfhK1ISB4tkZHXGXsIuSG7N5YBDa4PW/otoGUPurU3bbn2MsJrueee1yOR\nnnYAO5hSc+MaJi86K+8KqGHxEEJkBTE7SUWq1hJHSOK3uoy7j476rPkCkeNSkYi4\nV3uNGbBYxOUJZjGTbgRy8FSSUFezjCtlUDjnDU7E5OfyJMnItI8=\n=ZuCu\n-----END PGP SIGNATURE-----", "payload": "tree a6c8d29fd0e577b963a656a0f94d626263cc3243\nparent 6634eaf13a7e3a2b30f98f6e69af952f2d760df4\nauthor Daniel Conley <himself@danii.dev> 1643399057 -0500\ncommitter Daniel Conley <himself@danii.dev> 1643399057 -0500\n\nAdd Keyword Return Type Highlighting\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/261abbf45ea8558ee8fb7332606691f136c73982", "html_url": "https://github.com/rust-lang/rust/commit/261abbf45ea8558ee8fb7332606691f136c73982", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/261abbf45ea8558ee8fb7332606691f136c73982/comments", "author": {"login": "danii", "id": 39541871, "node_id": "MDQ6VXNlcjM5NTQxODcx", "avatar_url": "https://avatars.githubusercontent.com/u/39541871?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danii", "html_url": "https://github.com/danii", "followers_url": "https://api.github.com/users/danii/followers", "following_url": "https://api.github.com/users/danii/following{/other_user}", "gists_url": "https://api.github.com/users/danii/gists{/gist_id}", "starred_url": "https://api.github.com/users/danii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danii/subscriptions", "organizations_url": "https://api.github.com/users/danii/orgs", "repos_url": "https://api.github.com/users/danii/repos", "events_url": "https://api.github.com/users/danii/events{/privacy}", "received_events_url": "https://api.github.com/users/danii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danii", "id": 39541871, "node_id": "MDQ6VXNlcjM5NTQxODcx", "avatar_url": "https://avatars.githubusercontent.com/u/39541871?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danii", "html_url": "https://github.com/danii", "followers_url": "https://api.github.com/users/danii/followers", "following_url": "https://api.github.com/users/danii/following{/other_user}", "gists_url": "https://api.github.com/users/danii/gists{/gist_id}", "starred_url": "https://api.github.com/users/danii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danii/subscriptions", "organizations_url": "https://api.github.com/users/danii/orgs", "repos_url": "https://api.github.com/users/danii/repos", "events_url": "https://api.github.com/users/danii/events{/privacy}", "received_events_url": "https://api.github.com/users/danii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6634eaf13a7e3a2b30f98f6e69af952f2d760df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6634eaf13a7e3a2b30f98f6e69af952f2d760df4", "html_url": "https://github.com/rust-lang/rust/commit/6634eaf13a7e3a2b30f98f6e69af952f2d760df4"}], "stats": {"total": 109, "additions": 99, "deletions": 10}, "files": [{"sha": "a80d08308ac68c75ae678654ced9764bb50e7e46", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 99, "deletions": 10, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/261abbf45ea8558ee8fb7332606691f136c73982/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/261abbf45ea8558ee8fb7332606691f136c73982/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=261abbf45ea8558ee8fb7332606691f136c73982", "patch": "@@ -239,22 +239,20 @@ pub(super) fn keyword(\n     }\n     let parent = token.parent()?;\n     let famous_defs = FamousDefs(sema, sema.scope(&parent).krate());\n-    let keyword_mod = if token.kind() == T![fn] && ast::FnPtrType::cast(parent).is_some() {\n-        // treat fn keyword inside function pointer type as primitive\n-        format!(\"prim_{}\", token.text())\n-    } else {\n-        // std exposes {}_keyword modules with docstrings on the root to document keywords\n-        format!(\"{}_keyword\", token.text())\n-    };\n-    let doc_owner = find_std_module(&famous_defs, &keyword_mod)?;\n+\n+    // some keywords get fancy type tooltips if they are apart of an expression, which require some extra work\n+    // panic safety: we just checked that token is a keyword, and we have it's parent in scope, so it must have a parent\n+    let KeywordHint { description, documentation, actions } = keyword_hints(sema, token);\n+\n+    let doc_owner = find_std_module(&famous_defs, &documentation)?;\n     let docs = doc_owner.attrs(sema.db).docs()?;\n     let markup = process_markup(\n         sema.db,\n         Definition::Module(doc_owner),\n-        &markup(Some(docs.into()), token.text().into(), None)?,\n+        &markup(Some(docs.into()), description, None)?,\n         config,\n     );\n-    Some(HoverResult { markup, actions: Default::default() })\n+    Some(HoverResult { markup, actions })\n }\n \n pub(super) fn try_for_lint(attr: &ast::Attr, token: &SyntaxToken) -> Option<HoverResult> {\n@@ -500,3 +498,94 @@ fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n     };\n     markup(None, desc, None)\n }\n+\n+struct KeywordHint {\n+    description: String,\n+    documentation: String,\n+    actions: Vec<HoverAction>,\n+}\n+\n+impl KeywordHint {\n+    fn new(description: String, documentation: String) -> Self {\n+        Self { description, documentation, actions: Vec::default() }\n+    }\n+}\n+\n+/// Panics\n+/// ------\n+/// `token` is assumed to:\n+/// - have a parent, and\n+/// - be a keyword\n+fn keyword_hints<'t>(sema: &Semantics<RootDatabase>, token: &'t SyntaxToken) -> KeywordHint {\n+    let parent = token.parent().expect(\"token was assumed to have a parent, but had none\");\n+\n+    macro_rules! create_hint {\n+        ($ty_info:expr, $doc:expr) => {{\n+            let documentation = $doc;\n+            match $ty_info {\n+                Some(ty) => {\n+                    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+                    let mut push_new_def = |item: hir::ModuleDef| {\n+                        if !targets.contains(&item) {\n+                            targets.push(item);\n+                        }\n+                    };\n+                    walk_and_push_ty(sema.db, &ty.original, &mut push_new_def);\n+\n+                    let ty = ty.adjusted();\n+                    let description = format!(\"{}: {}\", token.text(), ty.display(sema.db));\n+\n+                    KeywordHint {\n+                        description,\n+                        documentation,\n+                        actions: vec![HoverAction::goto_type_from_targets(sema.db, targets)],\n+                    }\n+                }\n+                None => KeywordHint {\n+                    description: token.text().to_string(),\n+                    documentation,\n+                    actions: Vec::new(),\n+                },\n+            }\n+        }};\n+    }\n+\n+    match token.kind() {\n+        T![await] | T![loop] | T![match] | T![unsafe] => {\n+            let ty = ast::Expr::cast(parent).and_then(|site| sema.type_of_expr(&site));\n+            create_hint!(ty, format!(\"{}_keyword\", token.text()))\n+        }\n+\n+        T![if] | T![else] => {\n+            fn if_has_else(site: &ast::IfExpr) -> bool {\n+                match site.else_branch() {\n+                    Some(ast::ElseBranch::IfExpr(inner)) => if_has_else(&inner),\n+                    Some(ast::ElseBranch::Block(_)) => true,\n+                    None => false,\n+                }\n+            }\n+\n+            // only include the type if there is an else branch; it isn't worth annotating\n+            // an expression that always returns `()`, is it?\n+            let ty = ast::IfExpr::cast(parent)\n+                .and_then(|site| if_has_else(&site).then(|| site))\n+                .and_then(|site| sema.type_of_expr(&ast::Expr::IfExpr(site)));\n+            create_hint!(ty, format!(\"{}_keyword\", token.text()))\n+        }\n+\n+        T![fn] => {\n+            let module = match ast::FnPtrType::cast(parent) {\n+                // treat fn keyword inside function pointer type as primitive\n+                Some(_) => format!(\"prim_{}\", token.text()),\n+                None => format!(\"{}_keyword\", token.text()),\n+            };\n+            KeywordHint::new(token.text().to_string(), module)\n+        }\n+\n+        kind if kind.is_keyword() => {\n+            KeywordHint::new(token.text().to_string(), format!(\"{}_keyword\", token.text()))\n+        }\n+\n+        _ => panic!(\"{} was assumed to be a keyword, but it wasn't\", token),\n+    }\n+}"}]}