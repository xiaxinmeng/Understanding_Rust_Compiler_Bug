{"sha": "c63f1fe92b99a9828e9f999355213b0b73175aa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2M2YxZmU5MmI5OWE5ODI4ZTlmOTk5MzU1MjEzYjBiNzMxNzVhYTA=", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-07-09T04:04:47Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-07-09T04:04:47Z"}, "message": "Replace associated item bound vars with placeholders when projecting.", "tree": {"sha": "6d25fb3f0128266ebb1f32d6328a7318897d2092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d25fb3f0128266ebb1f32d6328a7318897d2092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c63f1fe92b99a9828e9f999355213b0b73175aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c63f1fe92b99a9828e9f999355213b0b73175aa0", "html_url": "https://github.com/rust-lang/rust/commit/c63f1fe92b99a9828e9f999355213b0b73175aa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c63f1fe92b99a9828e9f999355213b0b73175aa0/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa65b08b1dbaf4b637847646801ebc8c01d7ecbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa65b08b1dbaf4b637847646801ebc8c01d7ecbd", "html_url": "https://github.com/rust-lang/rust/commit/aa65b08b1dbaf4b637847646801ebc8c01d7ecbd"}], "stats": {"total": 640, "additions": 609, "deletions": 31}, "files": [{"sha": "8433b4ecb0ab1fd9315e237fa34d92dacb4dc13e", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -29,6 +29,8 @@ use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_span::symbol::sym;\n \n+use std::collections::BTreeMap;\n+\n pub use rustc_middle::traits::Reveal;\n \n pub type PolyProjectionObligation<'tcx> = Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n@@ -396,6 +398,53 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 normalized_ty\n             }\n \n+            ty::Projection(data) if !data.trait_ref(self.tcx()).has_escaping_bound_vars() => {\n+                // Okay, so you thought the previous branch was hacky. Well, to\n+                // extend upon this, when the *trait ref* doesn't have escaping\n+                // bound vars, but the associated item *does* (can only occur\n+                // with GATs), then we might still be able to project the type.\n+                // For this, we temporarily replace the bound vars with\n+                // placeholders. Note though, that in the case that we still\n+                // can't project for whatever reason (e.g. self type isn't\n+                // known enough), we *can't* register an obligation and return\n+                // an inference variable (since then that obligation would have\n+                // bound vars and that's a can of worms). Instead, we just\n+                // give up and fall back to pretending like we never tried!\n+\n+                let infcx = self.selcx.infcx();\n+                let (data, mapped_regions, mapped_types, mapped_consts, universe_map) =\n+                    BoundVarReplacer::replace_bound_vars(infcx, data);\n+\n+                let normalized_ty = opt_normalize_projection_type(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                )\n+                .ok()\n+                .flatten()\n+                .unwrap_or_else(|| ty);\n+\n+                let normalized_ty = PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    universe_map,\n+                    normalized_ty,\n+                );\n+                debug!(\n+                    ?self.depth,\n+                    ?ty,\n+                    ?normalized_ty,\n+                    obligations.len = ?self.obligations.len(),\n+                    \"AssocTypeNormalizer: normalized type\"\n+                );\n+                normalized_ty\n+            }\n+\n             _ => ty,\n         }\n     }\n@@ -410,6 +459,259 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n }\n \n+pub struct BoundVarReplacer<'me, 'tcx> {\n+    pub infcx: &'me InferCtxt<'me, 'tcx>,\n+    pub mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+    pub mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+    pub mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+    pub universes: BTreeMap<ty::DebruijnIndex, ty::UniverseIndex>,\n+    pub universes_inverse: BTreeMap<ty::UniverseIndex, ty::DebruijnIndex>,\n+    pub current_index: ty::DebruijnIndex,\n+}\n+\n+impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n+    pub fn replace_bound_vars<T: TypeFoldable<'tcx>>(\n+        infcx: &'me InferCtxt<'me, 'tcx>,\n+        value: T,\n+    ) -> (\n+        T,\n+        BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+        BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+        BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+        BTreeMap<ty::UniverseIndex, ty::DebruijnIndex>,\n+    ) {\n+        let mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion> = BTreeMap::new();\n+        let mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy> = BTreeMap::new();\n+        let mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar> = BTreeMap::new();\n+\n+        let mut replacer = BoundVarReplacer {\n+            infcx,\n+            mapped_regions,\n+            mapped_types,\n+            mapped_consts,\n+            universes: BTreeMap::new(),\n+            universes_inverse: BTreeMap::new(),\n+            current_index: ty::INNERMOST,\n+        };\n+\n+        let value = value.super_fold_with(&mut replacer);\n+\n+        (\n+            value,\n+            replacer.mapped_regions,\n+            replacer.mapped_types,\n+            replacer.mapped_consts,\n+            replacer.universes_inverse,\n+        )\n+    }\n+}\n+\n+impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n+        self.current_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.current_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(debruijn, br) => {\n+                let infcx = self.infcx;\n+                let placeholder_db_index =\n+                    ty::DebruijnIndex::from_u32(self.current_index.as_u32() - debruijn.as_u32());\n+                let universe = *self\n+                    .universes\n+                    .entry(placeholder_db_index)\n+                    .or_insert_with(|| infcx.create_next_universe());\n+                self.universes_inverse.insert(universe, placeholder_db_index);\n+                let p = ty::PlaceholderRegion { universe, name: br.kind };\n+                self.mapped_regions.insert(p.clone(), br);\n+                self.infcx.tcx.mk_region(ty::RePlaceholder(p))\n+            }\n+            _ => r,\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match *t.kind() {\n+            ty::Bound(debruijn, bound_ty) => {\n+                let infcx = self.infcx;\n+                let placeholder_db_index =\n+                    ty::DebruijnIndex::from_u32(self.current_index.as_u32() - debruijn.as_u32());\n+                let universe = *self\n+                    .universes\n+                    .entry(placeholder_db_index)\n+                    .or_insert_with(|| infcx.create_next_universe());\n+                self.universes_inverse.insert(universe, placeholder_db_index);\n+                let p = ty::PlaceholderType { universe, name: bound_ty.var };\n+                self.mapped_types.insert(p.clone(), bound_ty);\n+                self.infcx.tcx.mk_ty(ty::Placeholder(p))\n+            }\n+            _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n+            _ => t,\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match *ct {\n+            ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty } => {\n+                let infcx = self.infcx;\n+                let placeholder_db_index =\n+                    ty::DebruijnIndex::from_u32(self.current_index.as_u32() - debruijn.as_u32());\n+                let universe = *self\n+                    .universes\n+                    .entry(placeholder_db_index)\n+                    .or_insert_with(|| infcx.create_next_universe());\n+                self.universes_inverse.insert(universe, placeholder_db_index);\n+                let p = ty::PlaceholderConst {\n+                    universe,\n+                    name: ty::BoundConst { var: bound_const, ty },\n+                };\n+                self.mapped_consts.insert(p.clone(), bound_const);\n+                self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty })\n+            }\n+            _ if ct.has_vars_bound_at_or_above(self.current_index) => ct.super_fold_with(self),\n+            _ => ct,\n+        }\n+    }\n+}\n+\n+pub struct PlaceholderReplacer<'me, 'tcx> {\n+    pub infcx: &'me InferCtxt<'me, 'tcx>,\n+    pub mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+    pub mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+    pub mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+    pub universes_inverse: BTreeMap<ty::UniverseIndex, ty::DebruijnIndex>,\n+    pub current_index: ty::DebruijnIndex,\n+}\n+\n+impl<'me, 'tcx> PlaceholderReplacer<'me, 'tcx> {\n+    pub fn replace_placeholders<T: TypeFoldable<'tcx>>(\n+        infcx: &'me InferCtxt<'me, 'tcx>,\n+        mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+        mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+        mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+        universes_inverse: BTreeMap<ty::UniverseIndex, ty::DebruijnIndex>,\n+        value: T,\n+    ) -> T {\n+        let mut replacer = PlaceholderReplacer {\n+            infcx,\n+            mapped_regions,\n+            mapped_types,\n+            mapped_consts,\n+            universes_inverse,\n+            current_index: ty::INNERMOST,\n+        };\n+        value.super_fold_with(&mut replacer)\n+    }\n+}\n+\n+impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n+        if !t.has_placeholders() && !t.has_infer_regions() {\n+            return t;\n+        }\n+        self.current_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.current_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_region(&mut self, r0: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let r1 = match r0 {\n+            ty::ReVar(_) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n+                .opportunistic_resolve_region(self.infcx.tcx, r0),\n+            _ => r0,\n+        };\n+\n+        let r2 = match *r1 {\n+            ty::RePlaceholder(p) => {\n+                let replace_var = self.mapped_regions.get(&p);\n+                match replace_var {\n+                    Some(replace_var) => {\n+                        let db = self\n+                            .universes_inverse\n+                            .get(&p.universe)\n+                            .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n+                        let index =\n+                            ty::DebruijnIndex::from_u32(db.as_u32() + self.current_index.as_u32());\n+                        self.tcx().mk_region(ty::ReLateBound(index, *replace_var))\n+                    }\n+                    None => r1,\n+                }\n+            }\n+            _ => r1,\n+        };\n+\n+        debug!(?r0, ?r1, ?r2, \"fold_region\");\n+\n+        r2\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match *ty.kind() {\n+            ty::Placeholder(p) => {\n+                let replace_var = self.mapped_types.get(&p);\n+                match replace_var {\n+                    Some(replace_var) => {\n+                        let db = self\n+                            .universes_inverse\n+                            .get(&p.universe)\n+                            .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n+                        let index =\n+                            ty::DebruijnIndex::from_u32(db.as_u32() + self.current_index.as_u32());\n+                        self.tcx().mk_ty(ty::Bound(index, *replace_var))\n+                    }\n+                    None => ty,\n+                }\n+            }\n+\n+            _ if ty.has_placeholders() || ty.has_infer_regions() => ty.super_fold_with(self),\n+            _ => ty,\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const { val: ty::ConstKind::Placeholder(p), ty } = *ct {\n+            let replace_var = self.mapped_consts.get(&p);\n+            match replace_var {\n+                Some(replace_var) => {\n+                    let db = self\n+                        .universes_inverse\n+                        .get(&p.universe)\n+                        .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n+                    let index =\n+                        ty::DebruijnIndex::from_u32(db.as_u32() + self.current_index.as_u32());\n+                    self.tcx()\n+                        .mk_const(ty::Const { val: ty::ConstKind::Bound(index, *replace_var), ty })\n+                }\n+                None => ct,\n+            }\n+        } else {\n+            ct.super_fold_with(self)\n+        }\n+    }\n+}\n+\n /// The guts of `normalize`: normalize a specific projection like `<T\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). If ambiguity arises, which implies that"}, {"sha": "004372dd8b74d86a11a833d9065f83f62493d90b", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -204,6 +204,69 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     }\n                 }\n             }\n+            ty::Projection(data) if !data.trait_ref(self.infcx.tcx).has_escaping_bound_vars() => {\n+                // See note in `rustc_trait_selection::traits::project`\n+\n+                // One other point mentioning: In `traits::project`, if a\n+                // projection can't be normalized, we return an inference variable\n+                // and register an obligation to later resolve that. Here, the query\n+                // will just return ambiguity. In both cases, the effect is the same: we only want\n+                // to return `ty` because there are bound vars that we aren't yet handling in a more\n+                // complete way.\n+\n+                let tcx = self.infcx.tcx;\n+                let infcx = self.infcx;\n+                let (data, mapped_regions, mapped_types, mapped_consts, universe_map) =\n+                    crate::traits::project::BoundVarReplacer::replace_bound_vars(infcx, data);\n+                let data = data.super_fold_with(self);\n+\n+                let mut orig_values = OriginalQueryValues::default();\n+                // HACK(matthewjasper) `'static` is special-cased in selection,\n+                // so we cannot canonicalize it.\n+                let c_data = self\n+                    .infcx\n+                    .canonicalize_hr_query_hack(self.param_env.and(data), &mut orig_values);\n+                debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n+                debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n+                let normalized_ty = match tcx.normalize_projection_ty(c_data) {\n+                    Ok(result) => {\n+                        // We don't expect ambiguity.\n+                        if result.is_ambiguous() {\n+                            self.error = true;\n+                            return ty;\n+                        }\n+                        match self.infcx.instantiate_query_response_and_region_obligations(\n+                            self.cause,\n+                            self.param_env,\n+                            &orig_values,\n+                            result,\n+                        ) {\n+                            Ok(InferOk { value: result, obligations }) => {\n+                                debug!(\"QueryNormalizer: result = {:#?}\", result);\n+                                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n+                                self.obligations.extend(obligations);\n+                                result.normalized_ty\n+                            }\n+                            Err(_) => {\n+                                self.error = true;\n+                                ty\n+                            }\n+                        }\n+                    }\n+                    Err(NoSolution) => {\n+                        self.error = true;\n+                        ty\n+                    }\n+                };\n+                crate::traits::project::PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    universe_map,\n+                    normalized_ty,\n+                )\n+            }\n \n             _ => ty,\n         })();"}, {"sha": "c7a28cd9f3ef4e04799f41d443747ecab3cc0e64", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -406,7 +406,6 @@ fn check_associated_item(\n             }\n             ty::AssocKind::Fn => {\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n-                let sig = fcx.normalize_associated_types_in(span, sig);\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n                     fcx,\n@@ -611,7 +610,6 @@ fn check_item_fn(\n     for_id(tcx, item_id, span).with_fcx(|fcx| {\n         let def_id = tcx.hir().local_def_id(item_id);\n         let sig = tcx.fn_sig(def_id);\n-        let sig = fcx.normalize_associated_types_in(span, sig);\n         let mut implied_bounds = vec![];\n         check_fn_or_method(fcx, ident.span, sig, decl, def_id.to_def_id(), &mut implied_bounds);\n         implied_bounds\n@@ -902,8 +900,8 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     def_id: DefId,\n     implied_bounds: &mut Vec<Ty<'tcx>>,\n ) {\n-    let sig = fcx.normalize_associated_types_in(span, sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, sig);\n+    let sig = fcx.normalize_associated_types_in(span, sig);\n \n     for (&input_ty, ty) in iter::zip(sig.inputs(), hir_decl.inputs) {\n         fcx.register_wf_obligation(input_ty.into(), ty.span, ObligationCauseCode::MiscObligation);\n@@ -1081,8 +1079,8 @@ fn check_method_receiver<'fcx, 'tcx>(\n     let span = fn_sig.decl.inputs[0].span;\n \n     let sig = fcx.tcx.fn_sig(method.def_id);\n-    let sig = fcx.normalize_associated_types_in(span, sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, sig);\n+    let sig = fcx.normalize_associated_types_in(span, sig);\n \n     debug!(\"check_method_receiver: sig={:?}\", sig);\n "}, {"sha": "e8c11a32bf7fdabb47d0fea9e4dd73725e86af4a", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-for-unimpl-trait.rs:10:5\n+  --> $DIR/associated-types-for-unimpl-trait.rs:10:8\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |        ^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "e3be434698ab9897ad8d5be41eda0450692cd8e7", "filename": "src/test/ui/associated-types/associated-types-no-suitable-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `T: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-bound.rs:11:5\n+  --> $DIR/associated-types-no-suitable-bound.rs:11:8\n    |\n LL |     fn uhoh<T>(foo: <T as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `T`\n+   |        ^^^^ the trait `Get` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |"}, {"sha": "9dc3414e9edf0de03844b6a79aa388014848f977", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:5\n+  --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:8\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |        ^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "c2aed3f9de548f953162878e5ed4880a21e2e135", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,19 +1,19 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait.rs:17:5\n+  --> $DIR/associated-types-no-suitable-supertrait.rs:17:8\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |        ^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get {}\n    |                                                              ^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `(T, U): Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait.rs:22:5\n+  --> $DIR/associated-types-no-suitable-supertrait.rs:22:8\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `(T, U)`\n+   |        ^^^^ the trait `Get` is not implemented for `(T, U)`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fb842d968676d40d44105519ac78342f41076a36", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:5\n+  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:8\n    |\n LL |     fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |        ^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "a5abf1ba99d6a05746a7adecc990875bf5690774", "filename": "src/test/ui/associated-types/normalization-debruijn-1.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-1.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -0,0 +1,36 @@\n+// build-pass\n+// edition:2018\n+\n+// Regression test to ensure we handle debruijn indices correctly in projection\n+// normalization under binders. Found in crater run for #85499\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+pub enum Outcome<S, E> {\n+    Success((S, E)),\n+}\n+pub struct Request<'r> {\n+    _marker: std::marker::PhantomData<&'r ()>,\n+}\n+pub trait FromRequest<'r>: Sized {\n+    type Error;\n+    fn from_request<'life0>(\n+        request: &'r Request<'life0>,\n+    ) -> Pin<Box<dyn Future<Output = Outcome<Self, Self::Error>>>>;\n+}\n+impl<'r, T: FromRequest<'r>> FromRequest<'r> for Option<T> {\n+    type Error = ();\n+    fn from_request<'life0>(\n+        request: &'r Request<'life0>,\n+    ) -> Pin<Box<dyn Future<Output = Outcome<Self, Self::Error>>>> {\n+        Box::pin(async move {\n+            let request = request;\n+            match T::from_request(request).await {\n+                _ => todo!(),\n+            }\n+        });\n+        todo!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "abe248e16a19809eda9413821fa813ce7460a176", "filename": "src/test/ui/associated-types/normalization-debruijn-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-2.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -0,0 +1,31 @@\n+// build-pass\n+// edition:2018\n+\n+// Regression test to ensure we handle debruijn indices correctly in projection\n+// normalization under binders. Found in crater run for #85499\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+pub enum Outcome<S, E> {\n+    Success(S),\n+    Failure(E),\n+}\n+pub struct Request<'r> {\n+    _marker: std::marker::PhantomData<&'r ()>,\n+}\n+pub trait FromRequest<'r>: Sized {\n+    type Error;\n+    fn from_request<'life0>(\n+        request: &'r Request<'life0>,\n+    ) -> Pin<Box<dyn Future<Output = Outcome<Self, Self::Error>>>>;\n+}\n+pub struct S<T> {\n+    _marker: std::marker::PhantomData<T>,\n+}\n+impl<'r, T: FromRequest<'r>> S<T> {\n+    pub async fn from_request(request: &'r Request<'_>) {\n+        let _ = T::from_request(request).await;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2bea78cf7bd6931bac3d9da04f8c37f9f83e5871", "filename": "src/test/ui/associated-types/normalization-debruijn-3.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-3.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -0,0 +1,41 @@\n+// build-pass\n+// edition:2018\n+\n+// Regression test to ensure we handle debruijn indices correctly in projection\n+// normalization under binders. Found in crater run for #85499\n+\n+use std::future::{Future, Ready};\n+async fn read() {\n+    let _ = connect(&()).await;\n+}\n+async fn connect<A: ToSocketAddr>(addr: A) {\n+    let _ = addr.to_socket_addr().await;\n+}\n+pub trait ToSocketAddr {\n+    type Future: Future<Output = ()>;\n+    fn to_socket_addr(&self) -> Self::Future;\n+}\n+impl ToSocketAddr for &() {\n+    type Future = Ready<()>;\n+    fn to_socket_addr(&self) -> Self::Future {\n+        unimplemented!()\n+    }\n+}\n+struct Server;\n+impl Server {\n+    fn and_then<F>(self, _fun: F) -> AndThen<F> {\n+        unimplemented!()\n+    }\n+}\n+struct AndThen<F> {\n+    _marker: std::marker::PhantomData<F>,\n+}\n+pub async fn run<F>(_: F) {\n+}\n+fn main() {\n+    let _ = async {\n+        let server = Server;\n+        let verification_route = server.and_then(read);\n+        run(verification_route).await;\n+    };\n+}"}, {"sha": "f8e3f5b58d1b372718e6dd60010ac4524fb1ce76", "filename": "src/test/ui/associated-types/normalization-generality.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-generality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-generality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-generality.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -0,0 +1,36 @@\n+// build-pass\n+\n+// Ensures that we don't regress on \"implementation is not general enough\" when\n+// normalizating under binders.\n+\n+#![feature(no_core)]\n+\n+pub trait Yokeable<'a> {\n+    type Output: 'a;\n+}\n+\n+pub struct Yoke<Y: for<'a> Yokeable<'a>> {\n+    _yokeable: Y,\n+}\n+\n+impl<Y: for<'a> Yokeable<'a>> Yoke<Y> {\n+    pub fn project<'this, P>(\n+        &'this self,\n+        _f: for<'a> fn(<Y as Yokeable<'a>>::Output, &'a ()) -> <P as Yokeable<'a>>::Output,\n+    ) -> Yoke<P>\n+    where\n+        P: for<'a> Yokeable<'a>,\n+    {\n+        unimplemented!()\n+    }\n+}\n+\n+pub fn slice(y: Yoke<&'static ()>) -> Yoke<&'static ()> {\n+    y.project(move |yk, _| yk)\n+}\n+\n+impl<'a, T> Yokeable<'a> for &'static T {\n+    type Output = &'a T;\n+}\n+\n+fn main() {}"}, {"sha": "42f19feb5f132a1644e84276b02ae5cd5b93bfcf", "filename": "src/test/ui/generic-associated-types/issue-76407.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76407.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+#![feature(generic_associated_types)]\n+#![allow(incomplete_features)]\n+\n+trait Marker {}\n+\n+impl Marker for u32 {}\n+\n+trait MyTrait {\n+    type Item<'a>;\n+}\n+\n+struct MyStruct;\n+\n+impl MyTrait for MyStruct {\n+    type Item<'a> = u32;\n+}\n+\n+fn ty_check<T>()\n+where\n+    T: MyTrait,\n+    for<'a> T::Item<'a>: Marker\n+{}\n+\n+fn main() {\n+    ty_check::<MyStruct>();\n+}"}, {"sha": "a905ef4eb13fd823b0a62ff066792ab47d730f5b", "filename": "src/test/ui/generic-associated-types/issue-76826.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76826.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76826.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76826.rs?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -0,0 +1,45 @@\n+// run-pass\n+\n+#![feature(generic_associated_types)]\n+#![allow(incomplete_features)]\n+\n+pub trait Iter {\n+    type Item<'a> where Self: 'a;\n+\n+    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;\n+\n+    fn for_each<F>(mut self, mut f: F)\n+        where Self: Sized, F: for<'a> FnMut(Self::Item<'a>)\n+    {\n+        while let Some(item) = self.next() {\n+            f(item);\n+        }\n+    }\n+}\n+\n+pub struct Windows<T> {\n+    items: Vec<T>,\n+    start: usize,\n+    len: usize,\n+}\n+\n+impl<T> Windows<T> {\n+    pub fn new(items: Vec<T>, len: usize) -> Self {\n+        Self { items, start: 0, len }\n+    }\n+}\n+\n+impl<T> Iter for Windows<T> {\n+    type Item<'a> where T: 'a = &'a mut [T];\n+\n+    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {\n+        let slice = self.items.get_mut(self.start..self.start + self.len)?;\n+        self.start += 1;\n+        Some(slice)\n+    }\n+}\n+\n+fn main() {\n+    Windows::new(vec![1, 2, 3, 4, 5], 3)\n+        .for_each(|slice| println!(\"{:?}\", slice));\n+}"}, {"sha": "8872f51753c94789fa0841a9a635e7d00c3fdfe2", "filename": "src/test/ui/issues/issue-18611.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `isize: HasState` is not satisfied\n-  --> $DIR/issue-18611.rs:1:1\n+  --> $DIR/issue-18611.rs:1:4\n    |\n-LL | / fn add_state(op: <isize as HasState>::State) {\n-LL | |\n-LL | | }\n-   | |_^ the trait `HasState` is not implemented for `isize`\n+LL | fn add_state(op: <isize as HasState>::State) {\n+   |    ^^^^^^^^^ the trait `HasState` is not implemented for `isize`\n \n error: aborting due to previous error\n "}, {"sha": "03e3311e0f39bac7d151723e1276e51e79bcba52", "filename": "src/test/ui/issues/issue-20831-debruijn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,8 +1,8 @@\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/issue-20831-debruijn.rs:28:33\n+  --> $DIR/issue-20831-debruijn.rs:28:8\n    |\n LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^\n    |\n note: first, the lifetime cannot outlive the anonymous lifetime defined on the method body at 28:58...\n   --> $DIR/issue-20831-debruijn.rs:28:58\n@@ -15,10 +15,10 @@ note: ...but the lifetime must also be valid for the lifetime `'a` as defined on\n LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n    |      ^^\n note: ...so that the types are compatible\n-  --> $DIR/issue-20831-debruijn.rs:28:33\n+  --> $DIR/issue-20831-debruijn.rs:28:8\n    |\n LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^\n    = note: expected `Publisher<'_>`\n               found `Publisher<'_>`\n "}, {"sha": "8c7c8918f3fc60d5d63127de280eb492ea3cb8dc", "filename": "src/test/ui/nll/normalization-bounds-error.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,8 +1,8 @@\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'d` due to conflicting requirements\n-  --> $DIR/normalization-bounds-error.rs:12:1\n+  --> $DIR/normalization-bounds-error.rs:12:4\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |    ^^^^^^^^^\n    |\n note: first, the lifetime cannot outlive the lifetime `'d` as defined on the function body at 12:14...\n   --> $DIR/normalization-bounds-error.rs:12:14\n@@ -15,10 +15,10 @@ note: ...but the lifetime must also be valid for the lifetime `'a` as defined on\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n    |                  ^^\n note: ...so that the types are compatible\n-  --> $DIR/normalization-bounds-error.rs:12:1\n+  --> $DIR/normalization-bounds-error.rs:12:4\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |    ^^^^^^^^^\n    = note: expected `Visitor<'d>`\n               found `Visitor<'_>`\n "}, {"sha": "a0eb7d10bd94a0ab61200d679765757bf4369659", "filename": "src/test/ui/wf/wf-foreign-fn-decl-ret.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63f1fe92b99a9828e9f999355213b0b73175aa0/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr?ref=c63f1fe92b99a9828e9f999355213b0b73175aa0", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `(): Foo` is not satisfied\n-  --> $DIR/wf-foreign-fn-decl-ret.rs:11:5\n+  --> $DIR/wf-foreign-fn-decl-ret.rs:11:12\n    |\n LL |     pub fn lint_me() -> <() as Foo>::Assoc;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `()`\n+   |            ^^^^^^^ the trait `Foo` is not implemented for `()`\n \n error[E0277]: the trait bound `u32: Unsatisfied` is not satisfied\n   --> $DIR/wf-foreign-fn-decl-ret.rs:14:32"}]}