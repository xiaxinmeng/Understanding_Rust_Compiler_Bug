{"sha": "53a9d5a1d21c101f1bf6a00655309a37497cca23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYTlkNWExZDIxYzEwMWYxYmY2YTAwNjU1MzA5YTM3NDk3Y2NhMjM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-31T22:23:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-31T23:24:09Z"}, "message": "Start paring down std::str. Issue #855", "tree": {"sha": "add2e9c2ae7c249c624e4e29a37e77a6b5941a35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/add2e9c2ae7c249c624e4e29a37e77a6b5941a35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53a9d5a1d21c101f1bf6a00655309a37497cca23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53a9d5a1d21c101f1bf6a00655309a37497cca23", "html_url": "https://github.com/rust-lang/rust/commit/53a9d5a1d21c101f1bf6a00655309a37497cca23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53a9d5a1d21c101f1bf6a00655309a37497cca23/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "html_url": "https://github.com/rust-lang/rust/commit/cb55ef6e12f72f88ea9f05c84c290dfa95849f03"}], "stats": {"total": 1119, "additions": 398, "deletions": 721}, "files": [{"sha": "5b475e59e4adbdae1e9e5403b8ab78b6dbafb642", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -49,6 +49,12 @@ fn debug_fn<T>(x: &T) { rustrt::debug_fn::<T>(x); }\n fn ptr_cast<T, U>(x: @T) -> @U { ret rustrt::debug_ptrcast::<T, U>(x); }\n \n fn trap(s: str) { rustrt::debug_trap(s); }\n+\n+fn refcount<T>(a: &@T) -> uint {\n+    let p: *uint = unsafe::reinterpret_cast(a);\n+    ret *p;\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "23b14241427dee3b18ba112a27f4992562e9ab2c", "filename": "src/lib/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -87,7 +87,7 @@ obj new_reader(rdr: buf_reader) {\n \n         }\n         let b0 = c0 as u8;\n-        let w = str::utf8_char_width(b0);\n+        let w = istr::utf8_char_width(b0);\n         assert (w > 0u);\n         if w == 1u { ret b0 as char; }\n         let val = 0u;"}, {"sha": "ea597b4f7a1b4c0da75dc1b1a0caa181a838eae5", "filename": "src/lib/istr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Flib%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Flib%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fistr.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -4,7 +4,7 @@ concat, connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars, to_chars,\n char_len, char_at, bytes, is_ascii, shift_byte, pop_byte, unsafe_from_byte,\n unsafe_from_bytes, from_char, char_range_at, str_from_cstr, sbuf,\n-as_buf, push_byte;\n+as_buf, push_byte, utf8_char_width, safe_slice;\n \n export from_estr, to_estr, from_estrs, to_estrs;\n "}, {"sha": "40b8728f0ab3e2c9c0c1d8cd4bbd0a71807833df", "filename": "src/lib/str.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -2,57 +2,57 @@\n import rustrt::sbuf;\n import uint::le;\n export sbuf;\n-export rustrt;\n+// export rustrt;\n export eq;\n export lteq;\n-export hash;\n-export is_utf8;\n-export is_ascii;\n-export alloc;\n+// export hash;\n+// export is_utf8;\n+// export is_ascii;\n+// export alloc;\n export byte_len;\n export buf;\n-export bytes;\n-export unsafe_from_byte;\n-export str_from_cstr;\n-export str_from_buf;\n-export push_utf8_bytes;\n+// export bytes;\n+// export unsafe_from_byte;\n+// export str_from_cstr;\n+// export str_from_buf;\n+// export push_utf8_bytes;\n export from_char;\n-export from_chars;\n-export utf8_char_width;\n-export char_range_at;\n+// export from_chars;\n+// export utf8_char_width;\n+// export char_range_at;\n export char_at;\n export char_len;\n-export to_chars;\n-export push_char;\n-export pop_char;\n-export shift_char;\n-export unshift_char;\n-export refcount;\n-export index;\n-export rindex;\n+// export to_chars;\n+// export push_char;\n+// export pop_char;\n+// export shift_char;\n+// export unshift_char;\n+// export refcount;\n+// export index;\n+// export rindex;\n export find;\n-export starts_with;\n-export ends_with;\n+// export starts_with;\n+// export ends_with;\n export substr;\n-export slice;\n-export shift_byte;\n-export pop_byte;\n-export push_byte;\n-export unshift_byte;\n-export split;\n-export concat;\n-export connect;\n+// export slice;\n+// export shift_byte;\n+// export pop_byte;\n+// export push_byte;\n+// export unshift_byte;\n+// export split;\n+// export concat;\n+// export connect;\n export to_upper;\n-export safe_slice;\n+// export safe_slice;\n export unsafe_from_bytes;\n-export is_empty;\n-export is_not_empty;\n-export is_whitespace;\n-export replace;\n-export char_slice;\n-export trim_left;\n-export trim_right;\n-export trim;\n+// export is_empty;\n+// export is_not_empty;\n+// export is_whitespace;\n+// export replace;\n+// export char_slice;\n+// export trim_left;\n+// export trim_right;\n+// export trim;\n \n native \"rust\" mod rustrt {\n     type sbuf;\n@@ -339,7 +339,7 @@ fn index(s: str, c: u8) -> int {\n }\n \n fn rindex(s: str, c: u8) -> int {\n-    let n: int = str::byte_len(s) as int;\n+    let n: int = byte_len(s) as int;\n     while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n     ret n;\n }\n@@ -390,15 +390,14 @@ fn slice(s: str, begin: uint, end: uint) -> str {\n     // FIXME: Typestate precondition\n \n     assert (begin <= end);\n-    assert (end <= str::byte_len(s));\n+    assert (end <= byte_len(s));\n     ret rustrt::str_slice(s, begin, end);\n }\n \n fn safe_slice(s: str, begin: uint, end: uint) : le(begin, end) -> str {\n-    assert (end <=\n-                str::byte_len(s)); // would need some magic to\n-                                   // make this a precondition\n-\n+    // would need some magic to\n+    // make this a precondition\n+    assert (end <= byte_len(s));\n \n     ret rustrt::str_slice(s, begin, end);\n }\n@@ -441,7 +440,7 @@ fn split(s: str, sep: u8) -> [str] {\n             ends_with_sep = true;\n         } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n     }\n-    if str::byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n+    if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n }\n "}, {"sha": "f66a80aa98e15b8d0584fb204e97f8c761a55caf", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,9 +1,9 @@\n-// error-pattern: Unsatisfied precondition constraint (for example, le(a, b)\n+// error-pattern:precondition constraint (for example, uint::le(a, b)\n use std;\n-import std::str::*;\n+import std::istr::*;\n \n fn main() {\n     let a: uint = 4u;\n     let b: uint = 1u;\n-    log_err safe_slice(\"kitties\", a, b);\n+    log_err safe_slice(~\"kitties\", a, b);\n }"}, {"sha": "d9f1a44828deabf05925d35b885766ba600628b9", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:Unsatisfied precondition constraint (for example, le(b, d\n use std;\n-import std::str::*;\n+import std::istr::*;\n import std::uint::*;\n \n fn main() {\n@@ -16,5 +16,5 @@ fn main() {\n     // the next statement, since it's not true in the\n     // prestate.\n     let d <- a;\n-    log safe_slice(\"kitties\", b, d);\n+    log safe_slice(~\"kitties\", b, d);\n }"}, {"sha": "d1d9e1feed9c73aa6c84f84507f80d24e134a311", "filename": "src/test/run-fail/fn-constraint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,11 +1,11 @@\n // error-pattern:Predicate le(a, b) failed\n use std;\n-import std::str::*;\n+import std::istr::*;\n import std::uint::le;\n \n fn main() {\n     let a: uint = 4u;\n     let b: uint = 1u;\n     check (le(a, b));\n-    log_err safe_slice(\"kitties\", a, b);\n+    log_err safe_slice(~\"kitties\", a, b);\n }"}, {"sha": "28067b6d7cdb5a49596eaee455c70395b2e83d24", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -2,16 +2,17 @@\n \n // -*- rust -*-\n use std;\n-import std::str;\n \n+import std::dbg;\n \n // FIXME: import std::dbg.const_refcount. Currently\n // cross-crate const references don't work.\n const const_refcount: uint = 0x7bad_face_u;\n \n-tag t { make_t(str); clam; }\n+tag t { make_t(@int); clam; }\n \n-fn foo(s: str) {\n+fn foo(s: @int) {\n+    let count = dbg::refcount(s);\n     let x: t = make_t(s); // ref up\n \n     alt x {\n@@ -21,15 +22,15 @@ fn foo(s: str) {\n       }\n       _ { log \"?\"; fail; }\n     }\n-    log str::refcount(s);\n-    assert (str::refcount(s) == const_refcount);\n+    log dbg::refcount(s);\n+    assert (dbg::refcount(s) == count + 1u);\n }\n \n fn main() {\n-    let s: str = \"hi\"; // ref up\n+    let s: @int = @0; // ref up\n \n     foo(s); // ref up then down\n \n-    log str::refcount(s);\n-    assert (str::refcount(s) == const_refcount);\n+    log dbg::refcount(s);\n+    assert (dbg::refcount(s) == 1u);\n }"}, {"sha": "e598c269a8f3ffdb0b5e3e10a8415258d2c5ce35", "filename": "src/test/run-pass/constraint-prop-expr-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::str::*;\n+import std::istr::*;\n import std::uint::*;\n \n fn main() {\n@@ -8,5 +8,5 @@ fn main() {\n     let c: uint = 17u;\n     check (le(a, b));\n     c <- a;\n-    log safe_slice(\"kitties\", c, b);\n+    log safe_slice(~\"kitties\", c, b);\n }"}, {"sha": "16f38f17683820e15ca6c3d5b8980d606b680f7f", "filename": "src/test/run-pass/constraint-prop-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,11 +1,11 @@\n use std;\n-import std::str::*;\n+import std::istr::*;\n import std::uint::*;\n \n fn main() {\n     let a: uint = 1u;\n     let b: uint = 4u;\n     check (le(a, b));\n     let c <- a;\n-    log safe_slice(\"kitties\", c, b);\n+    log safe_slice(~\"kitties\", c, b);\n }"}, {"sha": "9cc0374909602e9a1e0526d9464ef0202d79dda1", "filename": "src/test/run-pass/constraint-prop-swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,11 +1,11 @@\n use std;\n-import std::str::*;\n+import std::istr::*;\n import std::uint::*;\n \n fn main() {\n     let a: uint = 4u;\n     let b: uint = 1u;\n     check (le(b, a));\n     b <-> a;\n-    log safe_slice(\"kitties\", a, b);\n+    log safe_slice(~\"kitties\", a, b);\n }"}, {"sha": "ca3c67cf0483fa9eee3f239c78b8c83109f4bf3a", "filename": "src/test/run-pass/constraint-prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,11 +1,11 @@\n use std;\n-import std::str::*;\n+import std::istr::*;\n import std::uint::*;\n \n fn main() {\n     let a: uint = 1u;\n     let b: uint = 4u;\n     check (le(a, b));\n     let c = b;\n-    log safe_slice(\"kitties\", a, c);\n+    log safe_slice(~\"kitties\", a, c);\n }"}, {"sha": "e9b8b1ac10114ecbe8706fbc69e7ab84db40c132", "filename": "src/test/run-pass/fn-constraint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-constraint.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,10 +1,10 @@\n use std;\n-import std::str::*;\n+import std::istr::*;\n import std::uint::*;\n \n fn main() {\n     let a: uint = 1u;\n     let b: uint = 4u;\n     check (le(a, b));\n-    log safe_slice(\"kitties\", a, b);\n+    log safe_slice(~\"kitties\", a, b);\n }"}, {"sha": "e7e881e5440f59425fc3b2f2f7af2b3dbed21b27", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -9,7 +9,6 @@ use std;\n import option = std::option::t;\n import std::option::some;\n import std::option::none;\n-import std::str;\n import std::istr;\n import std::vec;\n import std::map;\n@@ -20,40 +19,42 @@ import std::comm::send;\n import std::comm::recv;\n import std::comm;\n \n-fn map(filename: str, emit: map_reduce::putter) { emit(filename, \"1\"); }\n+fn map(filename: &istr, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n \n mod map_reduce {\n     export putter;\n     export mapper;\n     export map_reduce;\n \n-    type putter = fn(str, str);\n+    type putter = fn(&istr, &istr);\n \n-    type mapper = fn(str, putter);\n+    type mapper = fn(&istr, putter);\n \n     tag ctrl_proto { find_reducer([u8], chan<int>); mapper_done; }\n \n-    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[str]) {\n-        for i: str in inputs { task::spawn(bind map_task(ctrl, i)); }\n+    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[istr]) {\n+        for i: istr in inputs {\n+            task::spawn(bind map_task(ctrl, i));\n+        }\n     }\n \n-    fn map_task(ctrl: chan<ctrl_proto>, input: str) {\n+    fn map_task(ctrl: chan<ctrl_proto>, input: -istr) {\n \n         let intermediates = map::new_str_hash();\n \n         fn emit(im: &map::hashmap<istr, int>, ctrl: chan<ctrl_proto>,\n-                key: str, val: str) {\n+                key: &istr, val: &istr) {\n             let c;\n-            alt im.find(istr::from_estr(key)) {\n+            alt im.find(key) {\n               some(_c) { c = _c }\n               none. {\n                 let p = port();\n                 log_err \"sending find_reducer\";\n-                send(ctrl, find_reducer(str::bytes(key), chan(p)));\n+                send(ctrl, find_reducer(istr::bytes(key), chan(p)));\n                 log_err \"receiving\";\n                 c = recv(p);\n                 log_err c;\n-                im.insert(istr::from_estr(key), c);\n+                im.insert(key, c);\n               }\n             }\n         }\n@@ -62,7 +63,7 @@ mod map_reduce {\n         send(ctrl, mapper_done);\n     }\n \n-    fn map_reduce(inputs: &[str]) {\n+    fn map_reduce(inputs: &[istr]) {\n         let ctrl = port();\n \n         // This task becomes the master control task. It spawns others\n@@ -93,5 +94,5 @@ mod map_reduce {\n }\n \n fn main() {\n-    map_reduce::map_reduce([\"../src/test/run-pass/hashmap-memory.rs\"]);\n+    map_reduce::map_reduce([~\"../src/test/run-pass/hashmap-memory.rs\"]);\n }"}, {"sha": "737bde7c5f3c25bf6be9646b0240ecc964ee1aca", "filename": "src/test/run-pass/utf8_chars-istr.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Frun-pass%2Futf8_chars-istr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Frun-pass%2Futf8_chars-istr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars-istr.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -1,31 +0,0 @@\n-use std;\n-import std::istr;\n-import std::vec;\n-\n-fn main() {\n-    // Chars of 1, 2, 3, and 4 bytes\n-    let chs: [char] = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n-    let s: istr = istr::from_chars(chs);\n-\n-    assert (istr::byte_len(s) == 10u);\n-    assert (istr::char_len(s) == 4u);\n-    assert (vec::len::<char>(istr::to_chars(s)) == 4u);\n-    assert (istr::eq(istr::from_chars(istr::to_chars(s)), s));\n-    assert (istr::char_at(s, 0u) == 'e');\n-    assert (istr::char_at(s, 1u) == '\u00e9');\n-\n-    assert (istr::is_utf8(istr::bytes(s)));\n-    assert (!istr::is_utf8([0x80_u8]));\n-    assert (!istr::is_utf8([0xc0_u8]));\n-    assert (!istr::is_utf8([0xc0_u8, 0x10_u8]));\n-\n-    let stack = ~\"a\u00d7c\u20ac\";\n-    assert (istr::pop_char(stack) == '\u20ac');\n-    assert (istr::pop_char(stack) == 'c');\n-    istr::push_char(stack, 'u');\n-    assert (istr::eq(stack, ~\"a\u00d7u\"));\n-    assert (istr::shift_char(stack) == 'a');\n-    assert (istr::shift_char(stack) == '\u00d7');\n-    istr::unshift_char(stack, '\u00df');\n-    assert (istr::eq(stack, ~\"\u00dfu\"));\n-}"}, {"sha": "737bde7c5f3c25bf6be9646b0240ecc964ee1aca", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,31 +1,31 @@\n use std;\n-import std::str;\n+import std::istr;\n import std::vec;\n \n fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n     let chs: [char] = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n-    let s: str = str::from_chars(chs);\n+    let s: istr = istr::from_chars(chs);\n \n-    assert (str::byte_len(s) == 10u);\n-    assert (str::char_len(s) == 4u);\n-    assert (vec::len::<char>(str::to_chars(s)) == 4u);\n-    assert (str::eq(str::from_chars(str::to_chars(s)), s));\n-    assert (str::char_at(s, 0u) == 'e');\n-    assert (str::char_at(s, 1u) == '\u00e9');\n+    assert (istr::byte_len(s) == 10u);\n+    assert (istr::char_len(s) == 4u);\n+    assert (vec::len::<char>(istr::to_chars(s)) == 4u);\n+    assert (istr::eq(istr::from_chars(istr::to_chars(s)), s));\n+    assert (istr::char_at(s, 0u) == 'e');\n+    assert (istr::char_at(s, 1u) == '\u00e9');\n \n-    assert (str::is_utf8(str::bytes(s)));\n-    assert (!str::is_utf8([0x80_u8]));\n-    assert (!str::is_utf8([0xc0_u8]));\n-    assert (!str::is_utf8([0xc0_u8, 0x10_u8]));\n+    assert (istr::is_utf8(istr::bytes(s)));\n+    assert (!istr::is_utf8([0x80_u8]));\n+    assert (!istr::is_utf8([0xc0_u8]));\n+    assert (!istr::is_utf8([0xc0_u8, 0x10_u8]));\n \n-    let stack = \"a\u00d7c\u20ac\";\n-    assert (str::pop_char(stack) == '\u20ac');\n-    assert (str::pop_char(stack) == 'c');\n-    str::push_char(stack, 'u');\n-    assert (str::eq(stack, \"a\u00d7u\"));\n-    assert (str::shift_char(stack) == 'a');\n-    assert (str::shift_char(stack) == '\u00d7');\n-    str::unshift_char(stack, '\u00df');\n-    assert (str::eq(stack, \"\u00dfu\"));\n+    let stack = ~\"a\u00d7c\u20ac\";\n+    assert (istr::pop_char(stack) == '\u20ac');\n+    assert (istr::pop_char(stack) == 'c');\n+    istr::push_char(stack, 'u');\n+    assert (istr::eq(stack, ~\"a\u00d7u\"));\n+    assert (istr::shift_char(stack) == 'a');\n+    assert (istr::shift_char(stack) == '\u00d7');\n+    istr::unshift_char(stack, '\u00df');\n+    assert (istr::eq(stack, ~\"\u00dfu\"));\n }"}, {"sha": "c045aa1e49f3a3bfd68ddd811bb2624ed471bff3", "filename": "src/test/run-pass/vec-append.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -1,82 +0,0 @@\n-\n-\n-// -*- rust -*-\n-use std;\n-import std::str;\n-import std::vec;\n-\n-// FIXME: import std::dbg::const_refcount. Currently\n-// cross-crate const references don't work.\n-const const_refcount: uint = 0x7bad_face_u;\n-\n-fn fast_growth() {\n-    let v: [int] = [1, 2, 3, 4, 5];\n-    v += [6, 7, 8, 9, 0];\n-    log v[9];\n-    assert (v[0] == 1);\n-    assert (v[7] == 8);\n-    assert (v[9] == 0);\n-}\n-\n-fn slow_growth() {\n-    let v: [int] = [];\n-    let u: [int] = v;\n-    v += [17];\n-    log v[0];\n-    assert (v[0] == 17);\n-}\n-\n-fn slow_growth2_helper(s: str) { // ref up: s\n-\n-    obj acc(mutable v: [str]) {\n-        fn add(s: &str) { v += [s]; }\n-    }\n-    let ss: str = s; // ref up: s\n-\n-    let mumble: str = \"mrghrm\"; // ref up: mumble\n-\n-    {\n-        /**\n-         * Within this block, mumble goes into a vec that is referenced\n-         * both by the local slot v and the acc's v data field.  When we\n-         * add(s) on the acc, its v undergoes a slow append (allocate a\n-         * new vec, copy over existing elements).  Here we're testing to\n-         * see that this slow path goes over well.  In particular, the\n-         * copy of existing elements should increment the ref count of\n-         * mumble, the existing str in the originally- shared vec.\n-         */\n-\n-        let v: [str] = [mumble]; // ref up: mumble\n-\n-        let a: acc = acc(v);\n-\n-        a.add(s); // ref up: mumble, s\n-\n-        log str::refcount(s);\n-        log str::refcount(mumble);\n-        assert (str::refcount(s) == const_refcount);\n-        assert (str::refcount(mumble) == const_refcount);\n-        log v[0];\n-        log vec::len::<str>(v);\n-        assert (str::eq(v[0], mumble));\n-        assert (vec::len::<str>(v) == 1u);\n-    } // ref down: mumble, s,\n-\n-    log str::refcount(s);\n-    log str::refcount(mumble);\n-    assert (str::refcount(s) == const_refcount);\n-    assert (str::refcount(mumble) == const_refcount);\n-    log mumble;\n-    log ss;\n-}\n-\n-// ref down\n-fn slow_growth2() {\n-    let s: str = \"hi\"; // ref up: s\n-\n-    slow_growth2_helper(s);\n-    log str::refcount(s);\n-    assert (str::refcount(s) == const_refcount);\n-}\n-\n-fn main() { fast_growth(); slow_growth(); slow_growth2(); }"}, {"sha": "32497a8858b0d7e0d237880bcd5e196cf7f0a9f8", "filename": "src/test/stdtest/istr.rs", "status": "removed", "additions": 0, "deletions": 287, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fstdtest%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fstdtest%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fistr.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -1,287 +0,0 @@\n-import std::istr;\n-import std::vec;\n-\n-#[test]\n-fn test_eq() {\n-    assert istr::eq(~\"\", ~\"\");\n-    assert istr::eq(~\"foo\", ~\"foo\");\n-    assert !istr::eq(~\"foo\", ~\"bar\");\n-}\n-\n-#[test]\n-fn test_lteq() {\n-    assert istr::lteq(~\"\", ~\"\");\n-    assert istr::lteq(~\"\", ~\"foo\");\n-    assert istr::lteq(~\"foo\", ~\"foo\");\n-    assert !istr::eq(~\"foo\", ~\"bar\");\n-}\n-\n-#[test]\n-fn test_bytes_len() {\n-    assert (istr::byte_len(~\"\") == 0u);\n-    assert (istr::byte_len(~\"hello world\") == 11u);\n-    assert (istr::byte_len(~\"\\x63\") == 1u);\n-    assert (istr::byte_len(~\"\\xa2\") == 2u);\n-    assert (istr::byte_len(~\"\\u03c0\") == 2u);\n-    assert (istr::byte_len(~\"\\u2620\") == 3u);\n-    assert (istr::byte_len(~\"\\U0001d11e\") == 4u);\n-}\n-\n-#[test]\n-fn test_index_and_rindex() {\n-    assert (istr::index(~\"hello\", 'e' as u8) == 1);\n-    assert (istr::index(~\"hello\", 'o' as u8) == 4);\n-    assert (istr::index(~\"hello\", 'z' as u8) == -1);\n-    assert (istr::rindex(~\"hello\", 'l' as u8) == 3);\n-    assert (istr::rindex(~\"hello\", 'h' as u8) == 0);\n-    assert (istr::rindex(~\"hello\", 'z' as u8) == -1);\n-}\n-\n-#[test]\n-fn test_split() {\n-    fn t(s: &istr, c: char, i: int, k: &istr) {\n-        log ~\"splitting: \" + s;\n-        log i;\n-        let v = istr::split(s, c as u8);\n-        log ~\"split to: \";\n-        for z: istr in v { log z; }\n-        log ~\"comparing: \" + v[i] + ~\" vs. \" + k;\n-        assert (istr::eq(v[i], k));\n-    }\n-    t(~\"abc.hello.there\", '.', 0, ~\"abc\");\n-    t(~\"abc.hello.there\", '.', 1, ~\"hello\");\n-    t(~\"abc.hello.there\", '.', 2, ~\"there\");\n-    t(~\".hello.there\", '.', 0, ~\"\");\n-    t(~\".hello.there\", '.', 1, ~\"hello\");\n-    t(~\"...hello.there.\", '.', 3, ~\"hello\");\n-    t(~\"...hello.there.\", '.', 5, ~\"\");\n-}\n-\n-#[test]\n-fn test_find() {\n-    fn t(haystack: &istr, needle: &istr, i: int) {\n-        let j: int = istr::find(haystack, needle);\n-        log ~\"searched for \" + needle;\n-        log j;\n-        assert (i == j);\n-    }\n-    t(~\"this is a simple\", ~\"is a\", 5);\n-    t(~\"this is a simple\", ~\"is z\", -1);\n-    t(~\"this is a simple\", ~\"\", 0);\n-    t(~\"this is a simple\", ~\"simple\", 10);\n-    t(~\"this\", ~\"simple\", -1);\n-}\n-\n-#[test]\n-fn test_substr() {\n-    fn t(a: &istr, b: &istr, start: int) {\n-        assert (istr::eq(istr::substr(a, start as uint,\n-                                      istr::byte_len(b)), b));\n-    }\n-    t(~\"hello\", ~\"llo\", 2);\n-    t(~\"hello\", ~\"el\", 1);\n-    t(~\"substr should not be a challenge\", ~\"not\", 14);\n-}\n-\n-#[test]\n-fn test_concat() {\n-    fn t(v: &[istr], s: &istr) { assert (istr::eq(istr::concat(v), s)); }\n-    t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n-    let v: [istr] = [];\n-    t(v, ~\"\");\n-    t([~\"hi\"], ~\"hi\");\n-}\n-\n-#[test]\n-fn test_connect() {\n-    fn t(v: &[istr], sep: &istr, s: &istr) {\n-        assert (istr::eq(istr::connect(v, sep), s));\n-    }\n-    t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\" \",\n-      ~\"you know I'm no good\");\n-    let v: [istr] = [];\n-    t(v, ~\" \", ~\"\");\n-    t([~\"hi\"], ~\" \", ~\"hi\");\n-}\n-\n-#[test]\n-fn test_to_upper() {\n-    // to_upper doesn't understand unicode yet,\n-    // but we need to at least preserve it\n-\n-    let unicode = ~\"\\u65e5\\u672c\";\n-    let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n-    let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n-    let actual = istr::to_upper(input);\n-    assert (istr::eq(expected, actual));\n-}\n-\n-#[test]\n-fn test_slice() {\n-    assert (istr::eq(~\"ab\", istr::slice(~\"abc\", 0u, 2u)));\n-    assert (istr::eq(~\"bc\", istr::slice(~\"abc\", 1u, 3u)));\n-    assert (istr::eq(~\"\", istr::slice(~\"abc\", 1u, 1u)));\n-    fn a_million_letter_a() -> istr {\n-        let i = 0;\n-        let rs = ~\"\";\n-        while i < 100000 { rs += ~\"aaaaaaaaaa\"; i += 1; }\n-        ret rs;\n-    }\n-    fn half_a_million_letter_a() -> istr {\n-        let i = 0;\n-        let rs = ~\"\";\n-        while i < 100000 { rs += ~\"aaaaa\"; i += 1; }\n-        ret rs;\n-    }\n-    assert (istr::eq(half_a_million_letter_a(),\n-                    istr::slice(a_million_letter_a(), 0u, 500000u)));\n-}\n-\n-#[test]\n-fn test_starts_with() {\n-    assert (istr::starts_with(~\"\", ~\"\"));\n-    assert (istr::starts_with(~\"abc\", ~\"\"));\n-    assert (istr::starts_with(~\"abc\", ~\"a\"));\n-    assert (!istr::starts_with(~\"a\", ~\"abc\"));\n-    assert (!istr::starts_with(~\"\", ~\"abc\"));\n-}\n-\n-#[test]\n-fn test_ends_with() {\n-    assert (istr::ends_with(~\"\", ~\"\"));\n-    assert (istr::ends_with(~\"abc\", ~\"\"));\n-    assert (istr::ends_with(~\"abc\", ~\"c\"));\n-    assert (!istr::ends_with(~\"a\", ~\"abc\"));\n-    assert (!istr::ends_with(~\"\", ~\"abc\"));\n-}\n-\n-#[test]\n-fn test_is_empty() {\n-    assert (istr::is_empty(~\"\"));\n-    assert (!istr::is_empty(~\"a\"));\n-}\n-\n-#[test]\n-fn test_is_not_empty() {\n-    assert (istr::is_not_empty(~\"a\"));\n-    assert (!istr::is_not_empty(~\"\"));\n-}\n-\n-#[test]\n-fn test_replace() {\n-    let a = ~\"a\";\n-    check (istr::is_not_empty(a));\n-    assert (istr::replace(~\"\", a, ~\"b\") == ~\"\");\n-    assert (istr::replace(~\"a\", a, ~\"b\") == ~\"b\");\n-    assert (istr::replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n-    let test = ~\"test\";\n-    check (istr::is_not_empty(test));\n-    assert (istr::replace(~\" test test \", test, ~\"toast\")\n-            == ~\" toast toast \");\n-    assert (istr::replace(~\" test test \", test, ~\"\") == ~\"   \");\n-}\n-\n-#[test]\n-fn test_char_slice() {\n-    assert (istr::eq(~\"ab\", istr::char_slice(~\"abc\", 0u, 2u)));\n-    assert (istr::eq(~\"bc\", istr::char_slice(~\"abc\", 1u, 3u)));\n-    assert (istr::eq(~\"\", istr::char_slice(~\"abc\", 1u, 1u)));\n-    assert (istr::eq(~\"\\u65e5\", istr::char_slice(~\"\\u65e5\\u672c\", 0u, 1u)));\n-}\n-\n-#[test]\n-fn trim_left() {\n-    assert (istr::trim_left(~\"\") == ~\"\");\n-    assert (istr::trim_left(~\"a\") == ~\"a\");\n-    assert (istr::trim_left(~\"    \") == ~\"\");\n-    assert (istr::trim_left(~\"     blah\") == ~\"blah\");\n-    assert (istr::trim_left(~\"   \\u3000  wut\") == ~\"wut\");\n-    assert (istr::trim_left(~\"hey \") == ~\"hey \");\n-}\n-\n-#[test]\n-fn trim_right() {\n-    assert (istr::trim_right(~\"\") == ~\"\");\n-    assert (istr::trim_right(~\"a\") == ~\"a\");\n-    assert (istr::trim_right(~\"    \") == ~\"\");\n-    assert (istr::trim_right(~\"blah     \") == ~\"blah\");\n-    assert (istr::trim_right(~\"wut   \\u3000  \") == ~\"wut\");\n-    assert (istr::trim_right(~\" hey\") == ~\" hey\");\n-}\n-\n-#[test]\n-fn trim() {\n-    assert (istr::trim(~\"\") == ~\"\");\n-    assert (istr::trim(~\"a\") == ~\"a\");\n-    assert (istr::trim(~\"    \") == ~\"\");\n-    assert (istr::trim(~\"    blah     \") == ~\"blah\");\n-    assert (istr::trim(~\"\\nwut   \\u3000  \") == ~\"wut\");\n-    assert (istr::trim(~\" hey dude \") == ~\"hey dude\");\n-}\n-\n-#[test]\n-fn is_whitespace() {\n-    assert (istr::is_whitespace(~\"\"));\n-    assert (istr::is_whitespace(~\" \"));\n-    assert (istr::is_whitespace(~\"\\u2009\")); // Thin space\n-    assert (istr::is_whitespace(~\"  \\n\\t   \"));\n-    assert (!istr::is_whitespace(~\"   _   \"));\n-}\n-\n-#[test]\n-fn is_ascii() {\n-    assert istr::is_ascii(~\"\");\n-    assert istr::is_ascii(~\"a\");\n-    assert !istr::is_ascii(~\"\\u2009\");\n-}\n-\n-#[test]\n-fn shift_byte() {\n-    let s = ~\"ABC\";\n-    let b = istr::shift_byte(s);\n-    assert s == ~\"BC\";\n-    assert b == 65u8;\n-}\n-\n-#[test]\n-fn pop_byte() {\n-    let s = ~\"ABC\";\n-    let b = istr::pop_byte(s);\n-    assert s == ~\"AB\";\n-    assert b == 67u8;\n-}\n-\n-#[test]\n-fn unsafe_from_bytes() {\n-    let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-    let b = istr::unsafe_from_bytes(a);\n-    assert b == ~\"AAAAAAA\";\n-}\n-\n-#[test]\n-fn str_from_cstr() {\n-    let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-    let b = vec::to_ptr(a);\n-    let c = istr::str_from_cstr(b);\n-    assert c == ~\"AAAAAAA\";\n-}\n-\n-#[test]\n-fn as_buf() {\n-    let a = ~\"Abcdefg\";\n-    let b = istr::as_buf(a, { |buf|\n-        assert *buf == 65u8;\n-        100\n-    });\n-    assert b == 100;\n-}\n-\n-#[test]\n-fn as_buf_small() {\n-    let a = ~\"A\";\n-    let b = istr::as_buf(a, { |buf|\n-        assert *buf == 65u8;\n-        100\n-    });\n-    assert b == 100;\n-}"}, {"sha": "67bd91281654f18adfa2cf5ed9d768eaae26bd27", "filename": "src/test/stdtest/map.rs", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -3,7 +3,6 @@\n // -*- rust -*-\n use std;\n import std::map;\n-import std::str;\n import std::istr;\n import std::uint;\n import std::util;\n@@ -15,8 +14,8 @@ fn test_simple() {\n     fn eq_uint(x: &uint, y: &uint) -> bool { ret x == y; }\n     let hasher_uint: map::hashfn<uint> = util::id;\n     let eqer_uint: map::eqfn<uint> = eq_uint;\n-    let hasher_str: map::hashfn<str> = str::hash;\n-    let eqer_str: map::eqfn<str> = str::eq;\n+    let hasher_str: map::hashfn<istr> = istr::hash;\n+    let eqer_str: map::eqfn<istr> = istr::eq;\n     log \"uint -> uint\";\n     let hm_uu: map::hashmap<uint, uint> =\n         map::mk_hashmap::<uint, uint>(hasher_uint, eqer_uint);\n@@ -30,49 +29,49 @@ fn test_simple() {\n     assert (hm_uu.get(12u) == 14u);\n     assert (!hm_uu.insert(12u, 12u));\n     assert (hm_uu.get(12u) == 12u);\n-    let ten: str = \"ten\";\n-    let eleven: str = \"eleven\";\n-    let twelve: str = \"twelve\";\n+    let ten: istr = ~\"ten\";\n+    let eleven: istr = ~\"eleven\";\n+    let twelve: istr = ~\"twelve\";\n     log \"str -> uint\";\n-    let hm_su: map::hashmap<str, uint> =\n-        map::mk_hashmap::<str, uint>(hasher_str, eqer_str);\n-    assert (hm_su.insert(\"ten\", 12u));\n+    let hm_su: map::hashmap<istr, uint> =\n+        map::mk_hashmap::<istr, uint>(hasher_str, eqer_str);\n+    assert (hm_su.insert(~\"ten\", 12u));\n     assert (hm_su.insert(eleven, 13u));\n-    assert (hm_su.insert(\"twelve\", 14u));\n+    assert (hm_su.insert(~\"twelve\", 14u));\n     assert (hm_su.get(eleven) == 13u);\n-    assert (hm_su.get(\"eleven\") == 13u);\n-    assert (hm_su.get(\"twelve\") == 14u);\n-    assert (hm_su.get(\"ten\") == 12u);\n-    assert (!hm_su.insert(\"twelve\", 14u));\n-    assert (hm_su.get(\"twelve\") == 14u);\n-    assert (!hm_su.insert(\"twelve\", 12u));\n-    assert (hm_su.get(\"twelve\") == 12u);\n+    assert (hm_su.get(~\"eleven\") == 13u);\n+    assert (hm_su.get(~\"twelve\") == 14u);\n+    assert (hm_su.get(~\"ten\") == 12u);\n+    assert (!hm_su.insert(~\"twelve\", 14u));\n+    assert (hm_su.get(~\"twelve\") == 14u);\n+    assert (!hm_su.insert(~\"twelve\", 12u));\n+    assert (hm_su.get(~\"twelve\") == 12u);\n     log \"uint -> str\";\n-    let hm_us: map::hashmap<uint, str> =\n-        map::mk_hashmap::<uint, str>(hasher_uint, eqer_uint);\n-    assert (hm_us.insert(10u, \"twelve\"));\n-    assert (hm_us.insert(11u, \"thirteen\"));\n-    assert (hm_us.insert(12u, \"fourteen\"));\n-    assert (str::eq(hm_us.get(11u), \"thirteen\"));\n-    assert (str::eq(hm_us.get(12u), \"fourteen\"));\n-    assert (str::eq(hm_us.get(10u), \"twelve\"));\n-    assert (!hm_us.insert(12u, \"fourteen\"));\n-    assert (str::eq(hm_us.get(12u), \"fourteen\"));\n-    assert (!hm_us.insert(12u, \"twelve\"));\n-    assert (str::eq(hm_us.get(12u), \"twelve\"));\n+    let hm_us: map::hashmap<uint, istr> =\n+        map::mk_hashmap::<uint, istr>(hasher_uint, eqer_uint);\n+    assert (hm_us.insert(10u, ~\"twelve\"));\n+    assert (hm_us.insert(11u, ~\"thirteen\"));\n+    assert (hm_us.insert(12u, ~\"fourteen\"));\n+    assert (istr::eq(hm_us.get(11u), ~\"thirteen\"));\n+    assert (istr::eq(hm_us.get(12u), ~\"fourteen\"));\n+    assert (istr::eq(hm_us.get(10u), ~\"twelve\"));\n+    assert (!hm_us.insert(12u, ~\"fourteen\"));\n+    assert (istr::eq(hm_us.get(12u), ~\"fourteen\"));\n+    assert (!hm_us.insert(12u, ~\"twelve\"));\n+    assert (istr::eq(hm_us.get(12u), ~\"twelve\"));\n     log \"str -> str\";\n-    let hm_ss: map::hashmap<str, str> =\n-        map::mk_hashmap::<str, str>(hasher_str, eqer_str);\n-    assert (hm_ss.insert(ten, \"twelve\"));\n-    assert (hm_ss.insert(eleven, \"thirteen\"));\n-    assert (hm_ss.insert(twelve, \"fourteen\"));\n-    assert (str::eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n-    assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-    assert (str::eq(hm_ss.get(\"ten\"), \"twelve\"));\n-    assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n-    assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-    assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n-    assert (str::eq(hm_ss.get(\"twelve\"), \"twelve\"));\n+    let hm_ss: map::hashmap<istr, istr> =\n+        map::mk_hashmap::<istr, istr>(hasher_str, eqer_str);\n+    assert (hm_ss.insert(ten, ~\"twelve\"));\n+    assert (hm_ss.insert(eleven, ~\"thirteen\"));\n+    assert (hm_ss.insert(twelve, ~\"fourteen\"));\n+    assert (istr::eq(hm_ss.get(~\"eleven\"), ~\"thirteen\"));\n+    assert (istr::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n+    assert (istr::eq(hm_ss.get(~\"ten\"), ~\"twelve\"));\n+    assert (!hm_ss.insert(~\"twelve\", ~\"fourteen\"));\n+    assert (istr::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n+    assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n+    assert (istr::eq(hm_ss.get(~\"twelve\"), ~\"twelve\"));\n     log \"*** finished test_simple\";\n }\n \n@@ -117,40 +116,40 @@ fn test_growth() {\n         i += 1u;\n     }\n     log \"str -> str\";\n-    let hasher_str: map::hashfn<str> = str::hash;\n-    let eqer_str: map::eqfn<str> = str::eq;\n-    let hm_ss: map::hashmap<str, str> =\n-        map::mk_hashmap::<str, str>(hasher_str, eqer_str);\n+    let hasher_str: map::hashfn<istr> = istr::hash;\n+    let eqer_str: map::eqfn<istr> = istr::eq;\n+    let hm_ss: map::hashmap<istr, istr> =\n+        map::mk_hashmap::<istr, istr>(hasher_str, eqer_str);\n     i = 0u;\n     while i < num_to_insert {\n-        assert (hm_ss.insert(istr::to_estr(uint::to_str(i, 2u)),\n-                             istr::to_estr(uint::to_str(i * i, 2u))));\n+        assert (hm_ss.insert(uint::to_str(i, 2u),\n+                             uint::to_str(i * i, 2u)));\n         log ~\"inserting \\\"\" + uint::to_str(i, 2u) + ~\"\\\" -> \\\"\" +\n                 uint::to_str(i * i, 2u) + ~\"\\\"\";\n         i += 1u;\n     }\n     log \"-----\";\n     i = 0u;\n     while i < num_to_insert {\n-        log \"get(\\\"\" + istr::to_estr(uint::to_str(i, 2u)) + \"\\\") = \\\"\" +\n-                hm_ss.get(istr::to_estr(uint::to_str(i, 2u))) + \"\\\"\";\n-        assert (str::eq(hm_ss.get(istr::to_estr(uint::to_str(i, 2u))),\n-                        istr::to_estr(uint::to_str(i * i, 2u))));\n+        log ~\"get(\\\"\" + uint::to_str(i, 2u) + ~\"\\\") = \\\"\" +\n+                hm_ss.get(uint::to_str(i, 2u)) + ~\"\\\"\";\n+        assert (istr::eq(hm_ss.get(uint::to_str(i, 2u)),\n+                        uint::to_str(i * i, 2u)));\n         i += 1u;\n     }\n-    assert (hm_ss.insert(istr::to_estr(uint::to_str(num_to_insert, 2u)),\n-                         istr::to_estr(uint::to_str(17u, 2u))));\n-    assert (str::eq(hm_ss.get(\n-        istr::to_estr(uint::to_str(num_to_insert, 2u))),\n-                    istr::to_estr(uint::to_str(17u, 2u))));\n+    assert (hm_ss.insert(uint::to_str(num_to_insert, 2u),\n+                         uint::to_str(17u, 2u)));\n+    assert (istr::eq(hm_ss.get(\n+        uint::to_str(num_to_insert, 2u)),\n+                    uint::to_str(17u, 2u)));\n     log \"-----\";\n     hm_ss.rehash();\n     i = 0u;\n     while i < num_to_insert {\n-        log \"get(\\\"\" + istr::to_estr(uint::to_str(i, 2u)) + \"\\\") = \\\"\" +\n-                hm_ss.get(istr::to_estr(uint::to_str(i, 2u))) + \"\\\"\";\n-        assert (str::eq(hm_ss.get(istr::to_estr(uint::to_str(i, 2u))),\n-                        istr::to_estr(uint::to_str(i * i, 2u))));\n+        log ~\"get(\\\"\" + uint::to_str(i, 2u) + ~\"\\\") = \\\"\" +\n+                hm_ss.get(uint::to_str(i, 2u)) + ~\"\\\"\";\n+        assert (istr::eq(hm_ss.get(uint::to_str(i, 2u)),\n+                        uint::to_str(i * i, 2u)));\n         i += 1u;\n     }\n     log \"*** finished test_growth\";\n@@ -249,18 +248,18 @@ fn test_removal() {\n \n #[test]\n fn test_contains_key() {\n-    let key = \"k\";\n-    let map = map::mk_hashmap::<str, str>(str::hash, str::eq);\n+    let key = ~\"k\";\n+    let map = map::mk_hashmap::<istr, istr>(istr::hash, istr::eq);\n     assert (!map.contains_key(key));\n-    map.insert(key, \"val\");\n+    map.insert(key, ~\"val\");\n     assert (map.contains_key(key));\n }\n \n #[test]\n fn test_find() {\n-    let key = \"k\";\n-    let map = map::mk_hashmap::<str, str>(str::hash, str::eq);\n+    let key = ~\"k\";\n+    let map = map::mk_hashmap::<istr, istr>(istr::hash, istr::eq);\n     assert (std::option::is_none(map.find(key)));\n-    map.insert(key, \"val\");\n-    assert (std::option::get(map.find(key)) == \"val\");\n+    map.insert(key, ~\"val\");\n+    assert (std::option::get(map.find(key)) == ~\"val\");\n }"}, {"sha": "8a6f66970d12c8f571eb9771965e37f8a67dc0ca", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -26,7 +26,6 @@ mod sha1;\n mod sort;\n mod str_buf;\n mod str;\n-mod istr;\n mod task;\n mod test;\n mod uint;"}, {"sha": "32497a8858b0d7e0d237880bcd5e196cf7f0a9f8", "filename": "src/test/stdtest/str.rs", "status": "modified", "additions": 200, "deletions": 124, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -1,211 +1,287 @@\n-use std;\n-import std::str;\n+import std::istr;\n+import std::vec;\n+\n+#[test]\n+fn test_eq() {\n+    assert istr::eq(~\"\", ~\"\");\n+    assert istr::eq(~\"foo\", ~\"foo\");\n+    assert !istr::eq(~\"foo\", ~\"bar\");\n+}\n+\n+#[test]\n+fn test_lteq() {\n+    assert istr::lteq(~\"\", ~\"\");\n+    assert istr::lteq(~\"\", ~\"foo\");\n+    assert istr::lteq(~\"foo\", ~\"foo\");\n+    assert !istr::eq(~\"foo\", ~\"bar\");\n+}\n \n #[test]\n fn test_bytes_len() {\n-    assert (str::byte_len(\"\") == 0u);\n-    assert (str::byte_len(\"hello world\") == 11u);\n-    assert (str::byte_len(\"\\x63\") == 1u);\n-    assert (str::byte_len(\"\\xa2\") == 2u);\n-    assert (str::byte_len(\"\\u03c0\") == 2u);\n-    assert (str::byte_len(\"\\u2620\") == 3u);\n-    assert (str::byte_len(\"\\U0001d11e\") == 4u);\n+    assert (istr::byte_len(~\"\") == 0u);\n+    assert (istr::byte_len(~\"hello world\") == 11u);\n+    assert (istr::byte_len(~\"\\x63\") == 1u);\n+    assert (istr::byte_len(~\"\\xa2\") == 2u);\n+    assert (istr::byte_len(~\"\\u03c0\") == 2u);\n+    assert (istr::byte_len(~\"\\u2620\") == 3u);\n+    assert (istr::byte_len(~\"\\U0001d11e\") == 4u);\n }\n \n #[test]\n fn test_index_and_rindex() {\n-    assert (str::index(\"hello\", 'e' as u8) == 1);\n-    assert (str::index(\"hello\", 'o' as u8) == 4);\n-    assert (str::index(\"hello\", 'z' as u8) == -1);\n-    assert (str::rindex(\"hello\", 'l' as u8) == 3);\n-    assert (str::rindex(\"hello\", 'h' as u8) == 0);\n-    assert (str::rindex(\"hello\", 'z' as u8) == -1);\n+    assert (istr::index(~\"hello\", 'e' as u8) == 1);\n+    assert (istr::index(~\"hello\", 'o' as u8) == 4);\n+    assert (istr::index(~\"hello\", 'z' as u8) == -1);\n+    assert (istr::rindex(~\"hello\", 'l' as u8) == 3);\n+    assert (istr::rindex(~\"hello\", 'h' as u8) == 0);\n+    assert (istr::rindex(~\"hello\", 'z' as u8) == -1);\n }\n \n #[test]\n fn test_split() {\n-    fn t(s: &str, c: char, i: int, k: &str) {\n-        log \"splitting: \" + s;\n+    fn t(s: &istr, c: char, i: int, k: &istr) {\n+        log ~\"splitting: \" + s;\n         log i;\n-        let v = str::split(s, c as u8);\n-        log \"split to: \";\n-        for z: str in v { log z; }\n-        log \"comparing: \" + v[i] + \" vs. \" + k;\n-        assert (str::eq(v[i], k));\n+        let v = istr::split(s, c as u8);\n+        log ~\"split to: \";\n+        for z: istr in v { log z; }\n+        log ~\"comparing: \" + v[i] + ~\" vs. \" + k;\n+        assert (istr::eq(v[i], k));\n     }\n-    t(\"abc.hello.there\", '.', 0, \"abc\");\n-    t(\"abc.hello.there\", '.', 1, \"hello\");\n-    t(\"abc.hello.there\", '.', 2, \"there\");\n-    t(\".hello.there\", '.', 0, \"\");\n-    t(\".hello.there\", '.', 1, \"hello\");\n-    t(\"...hello.there.\", '.', 3, \"hello\");\n-    t(\"...hello.there.\", '.', 5, \"\");\n+    t(~\"abc.hello.there\", '.', 0, ~\"abc\");\n+    t(~\"abc.hello.there\", '.', 1, ~\"hello\");\n+    t(~\"abc.hello.there\", '.', 2, ~\"there\");\n+    t(~\".hello.there\", '.', 0, ~\"\");\n+    t(~\".hello.there\", '.', 1, ~\"hello\");\n+    t(~\"...hello.there.\", '.', 3, ~\"hello\");\n+    t(~\"...hello.there.\", '.', 5, ~\"\");\n }\n \n #[test]\n fn test_find() {\n-    fn t(haystack: &str, needle: &str, i: int) {\n-        let j: int = str::find(haystack, needle);\n-        log \"searched for \" + needle;\n+    fn t(haystack: &istr, needle: &istr, i: int) {\n+        let j: int = istr::find(haystack, needle);\n+        log ~\"searched for \" + needle;\n         log j;\n         assert (i == j);\n     }\n-    t(\"this is a simple\", \"is a\", 5);\n-    t(\"this is a simple\", \"is z\", -1);\n-    t(\"this is a simple\", \"\", 0);\n-    t(\"this is a simple\", \"simple\", 10);\n-    t(\"this\", \"simple\", -1);\n+    t(~\"this is a simple\", ~\"is a\", 5);\n+    t(~\"this is a simple\", ~\"is z\", -1);\n+    t(~\"this is a simple\", ~\"\", 0);\n+    t(~\"this is a simple\", ~\"simple\", 10);\n+    t(~\"this\", ~\"simple\", -1);\n }\n \n #[test]\n fn test_substr() {\n-    fn t(a: &str, b: &str, start: int) {\n-        assert (str::eq(str::substr(a, start as uint, str::byte_len(b)), b));\n+    fn t(a: &istr, b: &istr, start: int) {\n+        assert (istr::eq(istr::substr(a, start as uint,\n+                                      istr::byte_len(b)), b));\n     }\n-    t(\"hello\", \"llo\", 2);\n-    t(\"hello\", \"el\", 1);\n-    t(\"substr should not be a challenge\", \"not\", 14);\n+    t(~\"hello\", ~\"llo\", 2);\n+    t(~\"hello\", ~\"el\", 1);\n+    t(~\"substr should not be a challenge\", ~\"not\", 14);\n }\n \n #[test]\n fn test_concat() {\n-    fn t(v: &[str], s: &str) { assert (str::eq(str::concat(v), s)); }\n-    t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n-    let v: [str] = [];\n-    t(v, \"\");\n-    t([\"hi\"], \"hi\");\n+    fn t(v: &[istr], s: &istr) { assert (istr::eq(istr::concat(v), s)); }\n+    t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n+    let v: [istr] = [];\n+    t(v, ~\"\");\n+    t([~\"hi\"], ~\"hi\");\n }\n \n #[test]\n fn test_connect() {\n-    fn t(v: &[str], sep: &str, s: &str) {\n-        assert (str::eq(str::connect(v, sep), s));\n+    fn t(v: &[istr], sep: &istr, s: &istr) {\n+        assert (istr::eq(istr::connect(v, sep), s));\n     }\n-    t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \" \", \"you know I'm no good\");\n-    let v: [str] = [];\n-    t(v, \" \", \"\");\n-    t([\"hi\"], \" \", \"hi\");\n+    t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\" \",\n+      ~\"you know I'm no good\");\n+    let v: [istr] = [];\n+    t(v, ~\" \", ~\"\");\n+    t([~\"hi\"], ~\" \", ~\"hi\");\n }\n \n #[test]\n fn test_to_upper() {\n     // to_upper doesn't understand unicode yet,\n     // but we need to at least preserve it\n \n-    let unicode = \"\\u65e5\\u672c\";\n-    let input = \"abcDEF\" + unicode + \"xyz:.;\";\n-    let expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n-    let actual = str::to_upper(input);\n-    assert (str::eq(expected, actual));\n+    let unicode = ~\"\\u65e5\\u672c\";\n+    let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n+    let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n+    let actual = istr::to_upper(input);\n+    assert (istr::eq(expected, actual));\n }\n \n #[test]\n fn test_slice() {\n-    assert (str::eq(\"ab\", str::slice(\"abc\", 0u, 2u)));\n-    assert (str::eq(\"bc\", str::slice(\"abc\", 1u, 3u)));\n-    assert (str::eq(\"\", str::slice(\"abc\", 1u, 1u)));\n-    fn a_million_letter_a() -> str {\n+    assert (istr::eq(~\"ab\", istr::slice(~\"abc\", 0u, 2u)));\n+    assert (istr::eq(~\"bc\", istr::slice(~\"abc\", 1u, 3u)));\n+    assert (istr::eq(~\"\", istr::slice(~\"abc\", 1u, 1u)));\n+    fn a_million_letter_a() -> istr {\n         let i = 0;\n-        let rs = \"\";\n-        while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n+        let rs = ~\"\";\n+        while i < 100000 { rs += ~\"aaaaaaaaaa\"; i += 1; }\n         ret rs;\n     }\n-    fn half_a_million_letter_a() -> str {\n+    fn half_a_million_letter_a() -> istr {\n         let i = 0;\n-        let rs = \"\";\n-        while i < 100000 { rs += \"aaaaa\"; i += 1; }\n+        let rs = ~\"\";\n+        while i < 100000 { rs += ~\"aaaaa\"; i += 1; }\n         ret rs;\n     }\n-    assert (str::eq(half_a_million_letter_a(),\n-                    str::slice(a_million_letter_a(), 0u, 500000u)));\n+    assert (istr::eq(half_a_million_letter_a(),\n+                    istr::slice(a_million_letter_a(), 0u, 500000u)));\n+}\n+\n+#[test]\n+fn test_starts_with() {\n+    assert (istr::starts_with(~\"\", ~\"\"));\n+    assert (istr::starts_with(~\"abc\", ~\"\"));\n+    assert (istr::starts_with(~\"abc\", ~\"a\"));\n+    assert (!istr::starts_with(~\"a\", ~\"abc\"));\n+    assert (!istr::starts_with(~\"\", ~\"abc\"));\n }\n \n #[test]\n fn test_ends_with() {\n-    assert (str::ends_with(\"\", \"\"));\n-    assert (str::ends_with(\"abc\", \"\"));\n-    assert (str::ends_with(\"abc\", \"c\"));\n-    assert (!str::ends_with(\"a\", \"abc\"));\n-    assert (!str::ends_with(\"\", \"abc\"));\n+    assert (istr::ends_with(~\"\", ~\"\"));\n+    assert (istr::ends_with(~\"abc\", ~\"\"));\n+    assert (istr::ends_with(~\"abc\", ~\"c\"));\n+    assert (!istr::ends_with(~\"a\", ~\"abc\"));\n+    assert (!istr::ends_with(~\"\", ~\"abc\"));\n }\n \n #[test]\n fn test_is_empty() {\n-    assert (str::is_empty(\"\"));\n-    assert (!str::is_empty(\"a\"));\n+    assert (istr::is_empty(~\"\"));\n+    assert (!istr::is_empty(~\"a\"));\n }\n \n #[test]\n fn test_is_not_empty() {\n-    assert (str::is_not_empty(\"a\"));\n-    assert (!str::is_not_empty(\"\"));\n+    assert (istr::is_not_empty(~\"a\"));\n+    assert (!istr::is_not_empty(~\"\"));\n }\n \n #[test]\n fn test_replace() {\n-    let a = \"a\";\n-    check (str::is_not_empty(a));\n-    assert (str::replace(\"\", a, \"b\") == \"\");\n-    assert (str::replace(\"a\", a, \"b\") == \"b\");\n-    assert (str::replace(\"ab\", a, \"b\") == \"bb\");\n-    let test = \"test\";\n-    check (str::is_not_empty(test));\n-    assert (str::replace(\" test test \", test, \"toast\") == \" toast toast \");\n-    assert (str::replace(\" test test \", test, \"\") == \"   \");\n+    let a = ~\"a\";\n+    check (istr::is_not_empty(a));\n+    assert (istr::replace(~\"\", a, ~\"b\") == ~\"\");\n+    assert (istr::replace(~\"a\", a, ~\"b\") == ~\"b\");\n+    assert (istr::replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n+    let test = ~\"test\";\n+    check (istr::is_not_empty(test));\n+    assert (istr::replace(~\" test test \", test, ~\"toast\")\n+            == ~\" toast toast \");\n+    assert (istr::replace(~\" test test \", test, ~\"\") == ~\"   \");\n }\n \n #[test]\n fn test_char_slice() {\n-    assert (str::eq(\"ab\", str::char_slice(\"abc\", 0u, 2u)));\n-    assert (str::eq(\"bc\", str::char_slice(\"abc\", 1u, 3u)));\n-    assert (str::eq(\"\", str::char_slice(\"abc\", 1u, 1u)));\n-    assert (str::eq(\"\\u65e5\", str::char_slice(\"\\u65e5\\u672c\", 0u, 1u)));\n+    assert (istr::eq(~\"ab\", istr::char_slice(~\"abc\", 0u, 2u)));\n+    assert (istr::eq(~\"bc\", istr::char_slice(~\"abc\", 1u, 3u)));\n+    assert (istr::eq(~\"\", istr::char_slice(~\"abc\", 1u, 1u)));\n+    assert (istr::eq(~\"\\u65e5\", istr::char_slice(~\"\\u65e5\\u672c\", 0u, 1u)));\n }\n \n #[test]\n fn trim_left() {\n-    assert (str::trim_left(\"\") == \"\");\n-    assert (str::trim_left(\"a\") == \"a\");\n-    assert (str::trim_left(\"    \") == \"\");\n-    assert (str::trim_left(\"     blah\") == \"blah\");\n-    assert (str::trim_left(\"   \\u3000  wut\") == \"wut\");\n-    assert (str::trim_left(\"hey \") == \"hey \");\n+    assert (istr::trim_left(~\"\") == ~\"\");\n+    assert (istr::trim_left(~\"a\") == ~\"a\");\n+    assert (istr::trim_left(~\"    \") == ~\"\");\n+    assert (istr::trim_left(~\"     blah\") == ~\"blah\");\n+    assert (istr::trim_left(~\"   \\u3000  wut\") == ~\"wut\");\n+    assert (istr::trim_left(~\"hey \") == ~\"hey \");\n }\n \n #[test]\n fn trim_right() {\n-    assert (str::trim_right(\"\") == \"\");\n-    assert (str::trim_right(\"a\") == \"a\");\n-    assert (str::trim_right(\"    \") == \"\");\n-    assert (str::trim_right(\"blah     \") == \"blah\");\n-    assert (str::trim_right(\"wut   \\u3000  \") == \"wut\");\n-    assert (str::trim_right(\" hey\") == \" hey\");\n+    assert (istr::trim_right(~\"\") == ~\"\");\n+    assert (istr::trim_right(~\"a\") == ~\"a\");\n+    assert (istr::trim_right(~\"    \") == ~\"\");\n+    assert (istr::trim_right(~\"blah     \") == ~\"blah\");\n+    assert (istr::trim_right(~\"wut   \\u3000  \") == ~\"wut\");\n+    assert (istr::trim_right(~\" hey\") == ~\" hey\");\n }\n \n #[test]\n fn trim() {\n-    assert (str::trim(\"\") == \"\");\n-    assert (str::trim(\"a\") == \"a\");\n-    assert (str::trim(\"    \") == \"\");\n-    assert (str::trim(\"    blah     \") == \"blah\");\n-    assert (str::trim(\"\\nwut   \\u3000  \") == \"wut\");\n-    assert (str::trim(\" hey dude \") == \"hey dude\");\n+    assert (istr::trim(~\"\") == ~\"\");\n+    assert (istr::trim(~\"a\") == ~\"a\");\n+    assert (istr::trim(~\"    \") == ~\"\");\n+    assert (istr::trim(~\"    blah     \") == ~\"blah\");\n+    assert (istr::trim(~\"\\nwut   \\u3000  \") == ~\"wut\");\n+    assert (istr::trim(~\" hey dude \") == ~\"hey dude\");\n }\n \n #[test]\n fn is_whitespace() {\n-    assert (str::is_whitespace(\"\"));\n-    assert (str::is_whitespace(\" \"));\n-    assert (str::is_whitespace(\"\\u2009\")); // Thin space\n-    assert (str::is_whitespace(\"  \\n\\t   \"));\n-    assert (!str::is_whitespace(\"   _   \"));\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n+    assert (istr::is_whitespace(~\"\"));\n+    assert (istr::is_whitespace(~\" \"));\n+    assert (istr::is_whitespace(~\"\\u2009\")); // Thin space\n+    assert (istr::is_whitespace(~\"  \\n\\t   \"));\n+    assert (!istr::is_whitespace(~\"   _   \"));\n+}\n+\n+#[test]\n+fn is_ascii() {\n+    assert istr::is_ascii(~\"\");\n+    assert istr::is_ascii(~\"a\");\n+    assert !istr::is_ascii(~\"\\u2009\");\n+}\n+\n+#[test]\n+fn shift_byte() {\n+    let s = ~\"ABC\";\n+    let b = istr::shift_byte(s);\n+    assert s == ~\"BC\";\n+    assert b == 65u8;\n+}\n+\n+#[test]\n+fn pop_byte() {\n+    let s = ~\"ABC\";\n+    let b = istr::pop_byte(s);\n+    assert s == ~\"AB\";\n+    assert b == 67u8;\n+}\n+\n+#[test]\n+fn unsafe_from_bytes() {\n+    let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n+    let b = istr::unsafe_from_bytes(a);\n+    assert b == ~\"AAAAAAA\";\n+}\n+\n+#[test]\n+fn str_from_cstr() {\n+    let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+    let b = vec::to_ptr(a);\n+    let c = istr::str_from_cstr(b);\n+    assert c == ~\"AAAAAAA\";\n+}\n+\n+#[test]\n+fn as_buf() {\n+    let a = ~\"Abcdefg\";\n+    let b = istr::as_buf(a, { |buf|\n+        assert *buf == 65u8;\n+        100\n+    });\n+    assert b == 100;\n+}\n+\n+#[test]\n+fn as_buf_small() {\n+    let a = ~\"A\";\n+    let b = istr::as_buf(a, { |buf|\n+        assert *buf == 65u8;\n+        100\n+    });\n+    assert b == 100;\n+}"}, {"sha": "e260a2e8abd852db3bc55aafd6c91e948fb455e5", "filename": "src/test/stdtest/str_buf.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fstr_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fstr_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr_buf.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -2,14 +2,12 @@\n \n // -*- rust -*-\n use std;\n-import std::str;\n+import std::istr;\n \n #[test]\n fn test() {\n-    let s = \"hello\";\n-    let sb = str::buf(s);\n-    let s_cstr = str::str_from_cstr(sb);\n-    assert (str::eq(s_cstr, s));\n-    let s_buf = str::str_from_buf(sb, 5u);\n-    assert (str::eq(s_buf, s));\n+    let s = ~\"hello\";\n+    let sb = istr::as_buf(s, { |b| b });\n+    let s_cstr = istr::str_from_cstr(sb);\n+    assert (istr::eq(s_cstr, s));\n }"}, {"sha": "217b01ed4627db34ae5c3dc20b5f30ac4d0135f9", "filename": "src/test/stdtest/treemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftreemap.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -2,7 +2,7 @@ use std;\n import std::treemap::*;\n import std::option::some;\n import std::option::none;\n-import std::str;\n+import std::istr;\n \n #[test]\n fn init_treemap() {\n@@ -63,12 +63,12 @@ fn traverse_in_order() {\n fn u8_map() {\n     let m = init();\n \n-    let k1 = str::bytes(\"foo\");\n-    let k2 = str::bytes(\"bar\");\n+    let k1 = istr::bytes(~\"foo\");\n+    let k2 = istr::bytes(~\"bar\");\n \n-    insert(m, k1, \"foo\");\n-    insert(m, k2, \"bar\");\n+    insert(m, k1, ~\"foo\");\n+    insert(m, k2, ~\"bar\");\n \n-    assert(find(m, k2) == some(\"bar\"));\n-    assert(find(m, k1) == some(\"foo\"));\n+    assert(find(m, k2) == some(~\"bar\"));\n+    assert(find(m, k1) == some(~\"foo\"));\n }"}, {"sha": "bb8ad337e23fe5c43725a867a6c2fd2e888ff138", "filename": "src/test/stdtest/vec_str_conversions.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a9d5a1d21c101f1bf6a00655309a37497cca23/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs?ref=53a9d5a1d21c101f1bf6a00655309a37497cca23", "patch": "@@ -2,17 +2,17 @@\n \n // -*- rust -*-\n use std;\n-import std::str;\n+import std::istr;\n import std::vec;\n \n #[test]\n fn test_simple() {\n-    let s1: str = \"All mimsy were the borogoves\";\n+    let s1: istr = ~\"All mimsy were the borogoves\";\n \n-    let v: [u8] = str::bytes(s1);\n-    let s2: str = str::unsafe_from_bytes(v);\n+    let v: [u8] = istr::bytes(s1);\n+    let s2: istr = istr::unsafe_from_bytes(v);\n     let i: uint = 0u;\n-    let n1: uint = str::byte_len(s1);\n+    let n1: uint = istr::byte_len(s1);\n     let n2: uint = vec::len::<u8>(v);\n     assert (n1 == n2);\n     while i < n1 {\n@@ -23,6 +23,4 @@ fn test_simple() {\n         assert (a == b);\n         i += 1u;\n     }\n-    log \"refcnt is\";\n-    log str::refcount(s1);\n }"}]}