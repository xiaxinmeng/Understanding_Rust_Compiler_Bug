{"sha": "74c89b023020e4c6b04acfc877a115c95ec7747b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0Yzg5YjAyMzAyMGU0YzZiMDRhY2ZjODc3YTExNWM5NWVjNzc0N2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-30T18:55:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-30T18:55:09Z"}, "message": "Auto merge of #51849 - nikomatsakis:issue-51820-places-conflict, r=eddyb\n\noptimize `places_conflict` to avoid complex vectors etc\n\nFixes #51820", "tree": {"sha": "a90e80266ddb972330b4bd6873d548bc0976955a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a90e80266ddb972330b4bd6873d548bc0976955a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74c89b023020e4c6b04acfc877a115c95ec7747b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74c89b023020e4c6b04acfc877a115c95ec7747b", "html_url": "https://github.com/rust-lang/rust/commit/74c89b023020e4c6b04acfc877a115c95ec7747b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74c89b023020e4c6b04acfc877a115c95ec7747b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8772747c5f3a5809aea9abdb1586613b751db9ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8772747c5f3a5809aea9abdb1586613b751db9ac", "html_url": "https://github.com/rust-lang/rust/commit/8772747c5f3a5809aea9abdb1586613b751db9ac"}, {"sha": "cb349893320008f2cd9fcd42622564fc3b341b2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb349893320008f2cd9fcd42622564fc3b341b2b", "html_url": "https://github.com/rust-lang/rust/commit/cb349893320008f2cd9fcd42622564fc3b341b2b"}], "stats": {"total": 810, "additions": 448, "deletions": 362}, "files": [{"sha": "3aaa3378bb0052fe93c0ea3c82bd4a4215e489dd", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74c89b023020e4c6b04acfc877a115c95ec7747b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c89b023020e4c6b04acfc877a115c95ec7747b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=74c89b023020e4c6b04acfc877a115c95ec7747b", "patch": "@@ -59,6 +59,7 @@ mod flows;\n mod location;\n mod path_utils;\n crate mod place_ext;\n+mod places_conflict;\n mod prefixes;\n mod used_muts;\n mod move_errors;\n@@ -1309,7 +1310,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // that is merged.\n         let sd = if might_be_alive { Deep } else { Shallow(None) };\n \n-        if places_conflict(self.tcx, self.mir, place, root_place, sd) {\n+        if places_conflict::places_conflict(self.tcx, self.mir, place, root_place, sd) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead\n             // of just a span here.\n@@ -1400,7 +1401,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         for i in flow_state.ever_inits.iter_incoming() {\n             let init = self.move_data.inits[i];\n             let init_place = &self.move_data.move_paths[init.path].place;\n-            if places_conflict(self.tcx, self.mir, &init_place, place, Deep) {\n+            if places_conflict::places_conflict(self.tcx, self.mir, &init_place, place, Deep) {\n                 self.report_illegal_reassignment(context, (place, span), init.span, err_place);\n                 break;\n             }"}, {"sha": "8ae98bde003441452bae85e8a9a2f9e551e979f1", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 9, "deletions": 360, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/74c89b023020e4c6b04acfc877a115c95ec7747b/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c89b023020e4c6b04acfc877a115c95ec7747b/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=74c89b023020e4c6b04acfc877a115c95ec7747b", "patch": "@@ -8,22 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Returns true if the borrow represented by `kind` is\n-/// allowed to be split into separate Reservation and\n-/// Activation phases.\n-use borrow_check::ArtificialField;\n use borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseUse};\n-use borrow_check::{Context, Overlap};\n-use borrow_check::{ShallowOrDeep, Deep, Shallow};\n+use borrow_check::places_conflict;\n+use borrow_check::Context;\n+use borrow_check::ShallowOrDeep;\n use dataflow::indexes::BorrowIndex;\n-use rustc::hir;\n use rustc::mir::{BasicBlock, Location, Mir, Place};\n-use rustc::mir::{Projection, ProjectionElem, BorrowKind};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::mir::{ProjectionElem, BorrowKind};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::control_flow_graph::dominators::Dominators;\n-use rustc_data_structures::small_vec::SmallVec;\n-use std::iter;\n \n+/// Returns true if the borrow represented by `kind` is\n+/// allowed to be split into separate Reservation and\n+/// Activation phases.\n pub(super) fn allow_two_phase_borrow<'a, 'tcx, 'gcx: 'tcx>(\n     tcx: &TyCtxt<'a, 'gcx, 'tcx>,\n     kind: BorrowKind\n@@ -64,7 +61,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     for i in candidates {\n         let borrowed = &borrow_set[i];\n \n-        if places_conflict(tcx, mir, &borrowed.borrowed_place, place, access) {\n+        if places_conflict::places_conflict(tcx, mir, &borrowed.borrowed_place, place, access) {\n             debug!(\n                 \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n                 i, borrowed, place, access\n@@ -77,354 +74,6 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     }\n }\n \n-pub(super) fn places_conflict<'a, 'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n-    borrow_place: &Place<'tcx>,\n-    access_place: &Place<'tcx>,\n-    access: ShallowOrDeep,\n-) -> bool {\n-    debug!(\n-        \"places_conflict({:?},{:?},{:?})\",\n-        borrow_place, access_place, access\n-    );\n-\n-    let borrow_components = place_elements(borrow_place);\n-    let access_components = place_elements(access_place);\n-    debug!(\n-        \"places_conflict: components {:?} / {:?}\",\n-        borrow_components, access_components\n-    );\n-\n-    let borrow_components = borrow_components\n-        .into_iter()\n-        .map(Some)\n-        .chain(iter::repeat(None));\n-    let access_components = access_components\n-        .into_iter()\n-        .map(Some)\n-        .chain(iter::repeat(None));\n-    // The borrowck rules for proving disjointness are applied from the \"root\" of the\n-    // borrow forwards, iterating over \"similar\" projections in lockstep until\n-    // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n-    // a monoid and report a conflict if the product ends up not being `Disjoint`.\n-    //\n-    // At each step, if we didn't run out of borrow or place, we know that our elements\n-    // have the same type, and that they only overlap if they are the identical.\n-    //\n-    // For example, if we are comparing these:\n-    // BORROW:  (*x1[2].y).z.a\n-    // ACCESS:  (*x1[i].y).w.b\n-    //\n-    // Then our steps are:\n-    //       x1         |   x1          -- places are the same\n-    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n-    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n-    //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n-    //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n-    //\n-    // Because `zip` does potentially bad things to the iterator inside, this loop\n-    // also handles the case where the access might be a *prefix* of the borrow, e.g.\n-    //\n-    // BORROW:  (*x1[2].y).z.a\n-    // ACCESS:  x1[i].y\n-    //\n-    // Then our steps are:\n-    //       x1         |   x1          -- places are the same\n-    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n-    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n-    //\n-    // -- here we run out of access - the borrow can access a part of it. If this\n-    // is a full deep access, then we *know* the borrow conflicts with it. However,\n-    // if the access is shallow, then we can proceed:\n-    //\n-    //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n-    //                                     are disjoint\n-    //\n-    // Our invariant is, that at each step of the iteration:\n-    //  - If we didn't run out of access to match, our borrow and access are comparable\n-    //    and either equal or disjoint.\n-    //  - If we did run out of accesss, the borrow can access a part of it.\n-    for (borrow_c, access_c) in borrow_components.zip(access_components) {\n-        // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-        debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n-        match (borrow_c, access_c) {\n-            (None, _) => {\n-                // If we didn't run out of access, the borrow can access all of our\n-                // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n-                // so we have a conflict.\n-                //\n-                // If we did, then we still know that the borrow can access a *part*\n-                // of our place that our access cares about (a borrow of `a.b.c`\n-                // with an access to `a.b`), so we still have a conflict.\n-                //\n-                // FIXME: Differs from AST-borrowck; includes drive-by fix\n-                // to #38899. Will probably need back-compat mode flag.\n-                debug!(\"places_conflict: full borrow, CONFLICT\");\n-                return true;\n-            }\n-            (Some(borrow_c), None) => {\n-                // We know that the borrow can access a part of our place. This\n-                // is a conflict if that is a part our access cares about.\n-\n-                let (base, elem) = match borrow_c {\n-                    Place::Projection(box Projection { base, elem }) => (base, elem),\n-                    _ => bug!(\"place has no base?\"),\n-                };\n-                let base_ty = base.ty(mir, tcx).to_ty(tcx);\n-\n-                match (elem, &base_ty.sty, access) {\n-                    (_, _, Shallow(Some(ArtificialField::Discriminant)))\n-                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n-                            // The discriminant and array length are like\n-                            // additional fields on the type; they do not\n-                            // overlap any existing data there. Furthermore,\n-                            // they cannot actually be a prefix of any\n-                            // borrowed place (at least in MIR as it is\n-                            // currently.)\n-                            //\n-                            // e.g. a (mutable) borrow of `a[5]` while we read the\n-                            // array length of `a`.\n-                            debug!(\"places_conflict: implicit field\");\n-                            return false;\n-                        }\n-\n-                    (ProjectionElem::Deref, _, Shallow(None)) => {\n-                        // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n-                        // prefix thereof - the shallow access can't touch anything behind\n-                        // the pointer.\n-                        debug!(\"places_conflict: shallow access behind ptr\");\n-                        return false;\n-                    }\n-                    (\n-                        ProjectionElem::Deref,\n-                        ty::TyRef( _, _, hir::MutImmutable),\n-                        _,\n-                    ) => {\n-                        // the borrow goes through a dereference of a shared reference.\n-                        //\n-                        // I'm not sure why we are tracking these borrows - shared\n-                        // references can *always* be aliased, which means the\n-                        // permission check already account for this borrow.\n-                        debug!(\"places_conflict: behind a shared ref\");\n-                        return false;\n-                    }\n-\n-                    (ProjectionElem::Deref, _, Deep)\n-                        | (ProjectionElem::Field { .. }, _, _)\n-                        | (ProjectionElem::Index { .. }, _, _)\n-                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n-                        | (ProjectionElem::Subslice { .. }, _, _)\n-                        | (ProjectionElem::Downcast { .. }, _, _) => {\n-                            // Recursive case. This can still be disjoint on a\n-                            // further iteration if this a shallow access and\n-                            // there's a deref later on, e.g. a borrow\n-                            // of `*x.y` while accessing `x`.\n-                        }\n-                }\n-            }\n-            (Some(borrow_c), Some(access_c)) => {\n-                match place_element_conflict(tcx, mir, &borrow_c, access_c) {\n-                    Overlap::Arbitrary => {\n-                        // We have encountered different fields of potentially\n-                        // the same union - the borrow now partially overlaps.\n-                        //\n-                        // There is no *easy* way of comparing the fields\n-                        // further on, because they might have different types\n-                        // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n-                        // `.y` come from different structs).\n-                        //\n-                        // We could try to do some things here - e.g. count\n-                        // dereferences - but that's probably not a good\n-                        // idea, at least for now, so just give up and\n-                        // report a conflict. This is unsafe code anyway so\n-                        // the user could always use raw pointers.\n-                        debug!(\"places_conflict: arbitrary -> conflict\");\n-                        return true;\n-                    }\n-                    Overlap::EqualOrDisjoint => {\n-                        // This is the recursive case - proceed to the next element.\n-                    }\n-                    Overlap::Disjoint => {\n-                        // We have proven the borrow disjoint - further\n-                        // projections will remain disjoint.\n-                        debug!(\"places_conflict: disjoint\");\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    unreachable!(\"iter::repeat returned None\")\n-}\n-\n-/// Return all the prefixes of `place` in reverse order, including\n-/// downcasts.\n-fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> SmallVec<[&'a Place<'tcx>; 8]> {\n-    let mut result = SmallVec::new();\n-    let mut place = place;\n-    loop {\n-        result.push(place);\n-        match place {\n-            Place::Projection(interior) => {\n-                place = &interior.base;\n-            }\n-            Place::Local(_) | Place::Static(_) => {\n-                result.reverse();\n-                return result;\n-            }\n-        }\n-    }\n-}\n-\n-// Given that the bases of `elem1` and `elem2` are always either equal\n-// or disjoint (and have the same type!), return the overlap situation\n-// between `elem1` and `elem2`.\n-fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n-    elem1: &Place<'tcx>,\n-    elem2: &Place<'tcx>\n-) -> Overlap {\n-    match (elem1, elem2) {\n-        (Place::Local(l1), Place::Local(l2)) => {\n-            if l1 == l2 {\n-                // the same local - base case, equal\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // different locals - base case, disjoint\n-                debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n-                Overlap::Disjoint\n-            }\n-        }\n-        (Place::Static(static1), Place::Static(static2)) => {\n-            if static1.def_id != static2.def_id {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                Overlap::Disjoint\n-            } else if tcx.is_static(static1.def_id) ==\n-                        Some(hir::Mutability::MutMutable) {\n-                // We ignore mutable statics - they can only be unsafe code.\n-                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                Overlap::Disjoint\n-            } else {\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                Overlap::EqualOrDisjoint\n-            }\n-        }\n-        (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n-            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n-            Overlap::Disjoint\n-        }\n-        (Place::Projection(pi1), Place::Projection(pi2)) => {\n-            match (&pi1.elem, &pi2.elem) {\n-                (ProjectionElem::Deref, ProjectionElem::Deref) => {\n-                    // derefs (e.g. `*x` vs. `*x`) - recur.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n-                    Overlap::EqualOrDisjoint\n-                }\n-                (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n-                    if f1 == f2 {\n-                        // same field (e.g. `a.y` vs. `a.y`) - recur.\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n-                        match ty.sty {\n-                            ty::TyAdt(def, _) if def.is_union() => {\n-                                // Different fields of a union, we are basically stuck.\n-                                debug!(\"place_element_conflict: STUCK-UNION\");\n-                                Overlap::Arbitrary\n-                            }\n-                            _ => {\n-                                // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n-                                debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                                Overlap::Disjoint\n-                            }\n-                        }\n-                    }\n-                }\n-                (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n-                    // different variants are treated as having disjoint fields,\n-                    // even if they occupy the same \"space\", because it's\n-                    // impossible for 2 variants of the same enum to exist\n-                    // (and therefore, to be borrowed) at the same time.\n-                    //\n-                    // Note that this is different from unions - we *do* allow\n-                    // this code to compile:\n-                    //\n-                    // ```\n-                    // fn foo(x: &mut Result<i32, i32>) {\n-                    //     let mut v = None;\n-                    //     if let Ok(ref mut a) = *x {\n-                    //         v = Some(a);\n-                    //     }\n-                    //     // here, you would *think* that the\n-                    //     // *entirety* of `x` would be borrowed,\n-                    //     // but in fact only the `Ok` variant is,\n-                    //     // so the `Err` variant is *entirely free*:\n-                    //     if let Err(ref mut a) = *x {\n-                    //         v = Some(a);\n-                    //     }\n-                    //     drop(v);\n-                    // }\n-                    // ```\n-                    if v1 == v2 {\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                        Overlap::Disjoint\n-                    }\n-                }\n-                (ProjectionElem::Index(..), ProjectionElem::Index(..))\n-                | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n-                | (\n-                    ProjectionElem::ConstantIndex { .. },\n-                    ProjectionElem::ConstantIndex { .. },\n-                )\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n-                    // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n-                    // (if the indexes differ) or equal (if they are the same), so this\n-                    // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n-                    //\n-                    // Note that by construction, MIR at borrowck can't subdivide\n-                    // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n-                    // are only present in slice patterns, and we \"merge together\" nested\n-                    // slice patterns. That means we don't have to think about these. It's\n-                    // probably a good idea to assert this somewhere, but I'm too lazy.\n-                    //\n-                    // FIXME(#8636) we might want to return Disjoint if\n-                    // both projections are constant and disjoint.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n-                    Overlap::EqualOrDisjoint\n-                }\n-\n-                (ProjectionElem::Deref, _)\n-                | (ProjectionElem::Field(..), _)\n-                | (ProjectionElem::Index(..), _)\n-                | (ProjectionElem::ConstantIndex { .. }, _)\n-                | (ProjectionElem::Subslice { .. }, _)\n-                | (ProjectionElem::Downcast(..), _) => bug!(\n-                    \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-                    elem1,\n-                    elem2\n-                ),\n-            }\n-        }\n-        (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n-            \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n-            elem1,\n-            elem2\n-        ),\n-    }\n-}\n-\n pub(super) fn is_active<'tcx>(\n     dominators: &Dominators<BasicBlock>,\n     borrow_data: &BorrowData<'tcx>,"}, {"sha": "24bd675fac28e25f8eda73da69b4c60fbb012eb6", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/74c89b023020e4c6b04acfc877a115c95ec7747b/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c89b023020e4c6b04acfc877a115c95ec7747b/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=74c89b023020e4c6b04acfc877a115c95ec7747b", "patch": "@@ -0,0 +1,436 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::ArtificialField;\n+use borrow_check::Overlap;\n+use borrow_check::{Deep, Shallow, ShallowOrDeep};\n+use rustc::hir;\n+use rustc::mir::{Mir, Place};\n+use rustc::mir::{Projection, ProjectionElem};\n+use rustc::ty::{self, TyCtxt};\n+\n+pub(super) fn places_conflict<'gcx, 'tcx>(\n+    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    borrow_place: &Place<'tcx>,\n+    access_place: &Place<'tcx>,\n+    access: ShallowOrDeep,\n+) -> bool {\n+    debug!(\n+        \"places_conflict({:?},{:?},{:?})\",\n+        borrow_place, access_place, access\n+    );\n+\n+    unroll_place(borrow_place, None, |borrow_components| {\n+        unroll_place(access_place, None, |access_components| {\n+            place_components_conflict(tcx, mir, borrow_components, access_components, access)\n+        })\n+    })\n+}\n+\n+fn place_components_conflict<'gcx, 'tcx>(\n+    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    mut borrow_components: PlaceComponentsIter<'_, 'tcx>,\n+    mut access_components: PlaceComponentsIter<'_, 'tcx>,\n+    access: ShallowOrDeep,\n+) -> bool {\n+    // The borrowck rules for proving disjointness are applied from the \"root\" of the\n+    // borrow forwards, iterating over \"similar\" projections in lockstep until\n+    // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n+    // a monoid and report a conflict if the product ends up not being `Disjoint`.\n+    //\n+    // At each step, if we didn't run out of borrow or place, we know that our elements\n+    // have the same type, and that they only overlap if they are the identical.\n+    //\n+    // For example, if we are comparing these:\n+    // BORROW:  (*x1[2].y).z.a\n+    // ACCESS:  (*x1[i].y).w.b\n+    //\n+    // Then our steps are:\n+    //       x1         |   x1          -- places are the same\n+    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+    //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n+    //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n+    //\n+    // Because `zip` does potentially bad things to the iterator inside, this loop\n+    // also handles the case where the access might be a *prefix* of the borrow, e.g.\n+    //\n+    // BORROW:  (*x1[2].y).z.a\n+    // ACCESS:  x1[i].y\n+    //\n+    // Then our steps are:\n+    //       x1         |   x1          -- places are the same\n+    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+    //\n+    // -- here we run out of access - the borrow can access a part of it. If this\n+    // is a full deep access, then we *know* the borrow conflicts with it. However,\n+    // if the access is shallow, then we can proceed:\n+    //\n+    //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n+    //                                     are disjoint\n+    //\n+    // Our invariant is, that at each step of the iteration:\n+    //  - If we didn't run out of access to match, our borrow and access are comparable\n+    //    and either equal or disjoint.\n+    //  - If we did run out of accesss, the borrow can access a part of it.\n+    loop {\n+        // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+        if let Some(borrow_c) = borrow_components.next() {\n+            debug!(\"places_conflict: borrow_c = {:?}\", borrow_c);\n+\n+            if let Some(access_c) = access_components.next() {\n+                debug!(\"places_conflict: access_c = {:?}\", access_c);\n+\n+                // Borrow and access path both have more components.\n+                //\n+                // Examples:\n+                //\n+                // - borrow of `a.(...)`, access to `a.(...)`\n+                // - borrow of `a.(...)`, access to `b.(...)`\n+                //\n+                // Here we only see the components we have checked so\n+                // far (in our examples, just the first component). We\n+                // check whether the components being borrowed vs\n+                // accessed are disjoint (as in the second example,\n+                // but not the first).\n+                match place_element_conflict(tcx, mir, borrow_c, access_c) {\n+                    Overlap::Arbitrary => {\n+                        // We have encountered different fields of potentially\n+                        // the same union - the borrow now partially overlaps.\n+                        //\n+                        // There is no *easy* way of comparing the fields\n+                        // further on, because they might have different types\n+                        // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                        // `.y` come from different structs).\n+                        //\n+                        // We could try to do some things here - e.g. count\n+                        // dereferences - but that's probably not a good\n+                        // idea, at least for now, so just give up and\n+                        // report a conflict. This is unsafe code anyway so\n+                        // the user could always use raw pointers.\n+                        debug!(\"places_conflict: arbitrary -> conflict\");\n+                        return true;\n+                    }\n+                    Overlap::EqualOrDisjoint => {\n+                        // This is the recursive case - proceed to the next element.\n+                    }\n+                    Overlap::Disjoint => {\n+                        // We have proven the borrow disjoint - further\n+                        // projections will remain disjoint.\n+                        debug!(\"places_conflict: disjoint\");\n+                        return false;\n+                    }\n+                }\n+            } else {\n+                // Borrow path is longer than the access path. Examples:\n+                //\n+                // - borrow of `a.b.c`, access to `a.b`\n+                //\n+                // Here, we know that the borrow can access a part of\n+                // our place. This is a conflict if that is a part our\n+                // access cares about.\n+\n+                let (base, elem) = match borrow_c {\n+                    Place::Projection(box Projection { base, elem }) => (base, elem),\n+                    _ => bug!(\"place has no base?\"),\n+                };\n+                let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+\n+                match (elem, &base_ty.sty, access) {\n+                    (_, _, Shallow(Some(ArtificialField::Discriminant)))\n+                    | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                        // The discriminant and array length are like\n+                        // additional fields on the type; they do not\n+                        // overlap any existing data there. Furthermore,\n+                        // they cannot actually be a prefix of any\n+                        // borrowed place (at least in MIR as it is\n+                        // currently.)\n+                        //\n+                        // e.g. a (mutable) borrow of `a[5]` while we read the\n+                        // array length of `a`.\n+                        debug!(\"places_conflict: implicit field\");\n+                        return false;\n+                    }\n+\n+                    (ProjectionElem::Deref, _, Shallow(None)) => {\n+                        // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                        // prefix thereof - the shallow access can't touch anything behind\n+                        // the pointer.\n+                        debug!(\"places_conflict: shallow access behind ptr\");\n+                        return false;\n+                    }\n+                    (ProjectionElem::Deref, ty::TyRef(_, _, hir::MutImmutable), _) => {\n+                        // the borrow goes through a dereference of a shared reference.\n+                        //\n+                        // I'm not sure why we are tracking these borrows - shared\n+                        // references can *always* be aliased, which means the\n+                        // permission check already account for this borrow.\n+                        debug!(\"places_conflict: behind a shared ref\");\n+                        return false;\n+                    }\n+\n+                    (ProjectionElem::Deref, _, Deep)\n+                    | (ProjectionElem::Field { .. }, _, _)\n+                    | (ProjectionElem::Index { .. }, _, _)\n+                    | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                    | (ProjectionElem::Subslice { .. }, _, _)\n+                    | (ProjectionElem::Downcast { .. }, _, _) => {\n+                        // Recursive case. This can still be disjoint on a\n+                        // further iteration if this a shallow access and\n+                        // there's a deref later on, e.g. a borrow\n+                        // of `*x.y` while accessing `x`.\n+                    }\n+                }\n+            }\n+        } else {\n+            // Borrow path ran out but access path may not\n+            // have. Examples:\n+            //\n+            // - borrow of `a.b`, access to `a.b.c`\n+            // - borrow of `a.b`, access to `a.b`\n+            //\n+            // In the first example, where we didn't run out of\n+            // access, the borrow can access all of our place, so we\n+            // have a conflict.\n+            //\n+            // If the second example, where we did, then we still know\n+            // that the borrow can access a *part* of our place that\n+            // our access cares about, so we still have a conflict.\n+            //\n+            // FIXME: Differs from AST-borrowck; includes drive-by fix\n+            // to #38899. Will probably need back-compat mode flag.\n+            debug!(\"places_conflict: full borrow, CONFLICT\");\n+            return true;\n+        }\n+    }\n+}\n+\n+/// A linked list of places running up the stack; begins with the\n+/// innermost place and extends to projections (e.g., `a.b` would have\n+/// the place `a` with a \"next\" pointer to `a.b`).  Created by\n+/// `unroll_place`.\n+///\n+/// NB: This particular impl strategy is not the most obvious.  It was\n+/// chosen because it makes a measurable difference to NLL\n+/// performance, as this code (`places_conflict`) is somewhat hot.\n+struct PlaceComponents<'p, 'tcx: 'p> {\n+    component: &'p Place<'tcx>,\n+    next: Option<&'p PlaceComponents<'p, 'tcx>>,\n+}\n+\n+impl<'p, 'tcx> PlaceComponents<'p, 'tcx> {\n+    /// Converts a list of `Place` components into an iterator; this\n+    /// iterator yields up a never-ending stream of `Option<&Place>`.\n+    /// These begin with the \"innermst\" place and then with each\n+    /// projection therefrom. So given a place like `a.b.c` it would\n+    /// yield up:\n+    ///\n+    /// ```notrust\n+    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n+    /// ```\n+    fn iter(&self) -> PlaceComponentsIter<'_, 'tcx> {\n+        PlaceComponentsIter { value: Some(self) }\n+    }\n+}\n+\n+/// Iterator over components; see `PlaceComponents::iter` for more\n+/// information.\n+///\n+/// NB: This is not a *true* Rust iterator -- the code above just\n+/// manually invokes `next`. This is because we (sometimes) want to\n+/// keep executing even after `None` has been returned.\n+struct PlaceComponentsIter<'p, 'tcx: 'p> {\n+    value: Option<&'p PlaceComponents<'p, 'tcx>>,\n+}\n+\n+impl<'p, 'tcx> PlaceComponentsIter<'p, 'tcx> {\n+    fn next(&mut self) -> Option<&'p Place<'tcx>> {\n+        if let Some(&PlaceComponents { component, next }) = self.value {\n+            self.value = next;\n+            Some(component)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Recursively \"unroll\" a place into a `PlaceComponents` list,\n+/// invoking `op` with a `PlaceComponentsIter`.\n+fn unroll_place<'tcx, R>(\n+    place: &Place<'tcx>,\n+    next: Option<&PlaceComponents<'_, 'tcx>>,\n+    op: impl FnOnce(PlaceComponentsIter<'_, 'tcx>) -> R,\n+) -> R {\n+    match place {\n+        Place::Projection(interior) => unroll_place(\n+            &interior.base,\n+            Some(&PlaceComponents {\n+                component: place,\n+                next,\n+            }),\n+            op,\n+        ),\n+\n+        Place::Local(_) | Place::Static(_) => {\n+            let list = PlaceComponents {\n+                component: place,\n+                next,\n+            };\n+            op(list.iter())\n+        }\n+    }\n+}\n+\n+// Given that the bases of `elem1` and `elem2` are always either equal\n+// or disjoint (and have the same type!), return the overlap situation\n+// between `elem1` and `elem2`.\n+fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    elem1: &Place<'tcx>,\n+    elem2: &Place<'tcx>,\n+) -> Overlap {\n+    match (elem1, elem2) {\n+        (Place::Local(l1), Place::Local(l2)) => {\n+            if l1 == l2 {\n+                // the same local - base case, equal\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                // different locals - base case, disjoint\n+                debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (Place::Static(static1), Place::Static(static2)) => {\n+            if static1.def_id != static2.def_id {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                Overlap::Disjoint\n+            } else if tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n+                // We ignore mutable statics - they can only be unsafe code.\n+                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                Overlap::Disjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                Overlap::EqualOrDisjoint\n+            }\n+        }\n+        (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n+            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+            Overlap::Disjoint\n+        }\n+        (Place::Projection(pi1), Place::Projection(pi2)) => {\n+            match (&pi1.elem, &pi2.elem) {\n+                (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+                    // derefs (e.g. `*x` vs. `*x`) - recur.\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+                    Overlap::EqualOrDisjoint\n+                }\n+                (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+                    if f1 == f2 {\n+                        // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n+                        match ty.sty {\n+                            ty::TyAdt(def, _) if def.is_union() => {\n+                                // Different fields of a union, we are basically stuck.\n+                                debug!(\"place_element_conflict: STUCK-UNION\");\n+                                Overlap::Arbitrary\n+                            }\n+                            _ => {\n+                                // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                                debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                                Overlap::Disjoint\n+                            }\n+                        }\n+                    }\n+                }\n+                (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+                    // different variants are treated as having disjoint fields,\n+                    // even if they occupy the same \"space\", because it's\n+                    // impossible for 2 variants of the same enum to exist\n+                    // (and therefore, to be borrowed) at the same time.\n+                    //\n+                    // Note that this is different from unions - we *do* allow\n+                    // this code to compile:\n+                    //\n+                    // ```\n+                    // fn foo(x: &mut Result<i32, i32>) {\n+                    //     let mut v = None;\n+                    //     if let Ok(ref mut a) = *x {\n+                    //         v = Some(a);\n+                    //     }\n+                    //     // here, you would *think* that the\n+                    //     // *entirety* of `x` would be borrowed,\n+                    //     // but in fact only the `Ok` variant is,\n+                    //     // so the `Err` variant is *entirely free*:\n+                    //     if let Err(ref mut a) = *x {\n+                    //         v = Some(a);\n+                    //     }\n+                    //     drop(v);\n+                    // }\n+                    // ```\n+                    if v1 == v2 {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::Index(..), ProjectionElem::Index(..))\n+                | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n+                | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n+                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n+                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. })\n+                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                    // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+                    // (if the indexes differ) or equal (if they are the same), so this\n+                    // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n+                    //\n+                    // Note that by construction, MIR at borrowck can't subdivide\n+                    // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n+                    // are only present in slice patterns, and we \"merge together\" nested\n+                    // slice patterns. That means we don't have to think about these. It's\n+                    // probably a good idea to assert this somewhere, but I'm too lazy.\n+                    //\n+                    // FIXME(#8636) we might want to return Disjoint if\n+                    // both projections are constant and disjoint.\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                    Overlap::EqualOrDisjoint\n+                }\n+\n+                (ProjectionElem::Deref, _)\n+                | (ProjectionElem::Field(..), _)\n+                | (ProjectionElem::Index(..), _)\n+                | (ProjectionElem::ConstantIndex { .. }, _)\n+                | (ProjectionElem::Subslice { .. }, _)\n+                | (ProjectionElem::Downcast(..), _) => bug!(\n+                    \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+                    elem1,\n+                    elem2\n+                ),\n+            }\n+        }\n+        (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n+            \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+            elem1,\n+            elem2\n+        ),\n+    }\n+}"}]}