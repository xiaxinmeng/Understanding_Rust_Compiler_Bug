{"sha": "efb68ee21a2680794dd1179ed071b245ade9c91e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYjY4ZWUyMWEyNjgwNzk0ZGQxMTc5ZWQwNzFiMjQ1YWRlOWM5MWU=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-12T04:48:24Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-12T04:48:24Z"}, "message": "Refactor write_snippet_inner()", "tree": {"sha": "db1f7fc07da0f6c75fa19dd85012908e4f87a9ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db1f7fc07da0f6c75fa19dd85012908e4f87a9ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efb68ee21a2680794dd1179ed071b245ade9c91e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efb68ee21a2680794dd1179ed071b245ade9c91e", "html_url": "https://github.com/rust-lang/rust/commit/efb68ee21a2680794dd1179ed071b245ade9c91e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efb68ee21a2680794dd1179ed071b245ade9c91e/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "516f15aba154e2cc66b999d0c9613479f4d53275", "url": "https://api.github.com/repos/rust-lang/rust/commits/516f15aba154e2cc66b999d0c9613479f4d53275", "html_url": "https://github.com/rust-lang/rust/commit/516f15aba154e2cc66b999d0c9613479f4d53275"}], "stats": {"total": 329, "additions": 151, "deletions": 178}, "files": [{"sha": "4e1f2a37ef4476def67c2a06f888ae6f2903e7b5", "filename": "src/missed_spans.rs", "status": "modified", "additions": 151, "deletions": 178, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/efb68ee21a2680794dd1179ed071b245ade9c91e/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb68ee21a2680794dd1179ed071b245ade9c91e/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=efb68ee21a2680794dd1179ed071b245ade9c91e", "patch": "@@ -20,9 +20,28 @@ use shape::{Indent, Shape};\n use utils::{count_newlines, last_line_width, mk_sp};\n use visitor::FmtVisitor;\n \n+struct SnippetStatus {\n+    /// An offset to the current line from the beginnig of the original snippet.\n+    line_start: usize,\n+    /// A length of trailing whitespaces on the current line.\n+    last_wspace: Option<usize>,\n+    /// The current line number.\n+    cur_line: usize,\n+}\n+\n+impl SnippetStatus {\n+    fn new(cur_line: usize) -> Self {\n+        SnippetStatus {\n+            line_start: 0,\n+            last_wspace: None,\n+            cur_line,\n+        }\n+    }\n+}\n+\n impl<'a> FmtVisitor<'a> {\n     fn output_at_start(&self) -> bool {\n-        self.buffer.len() == 0\n+        self.buffer.is_empty()\n     }\n \n     // TODO these format_missing methods are ugly. Refactor and add unit tests\n@@ -77,20 +96,16 @@ impl<'a> FmtVisitor<'a> {\n         let snippet = self.snippet(span);\n         if snippet.trim().is_empty() && !out_of_file_lines_range!(self, span) {\n             // Keep vertical spaces within range.\n-            self.push_vertical_spaces(count_newlines(&snippet));\n-            process_last_snippet(self, \"\", &snippet);\n+            self.push_vertical_spaces(count_newlines(snippet));\n+            process_last_snippet(self, \"\", snippet);\n         } else {\n             self.write_snippet(span, &process_last_snippet);\n         }\n     }\n \n     fn push_vertical_spaces(&mut self, mut newline_count: usize) {\n         // The buffer already has a trailing newline.\n-        let offset = if last_line_width(&self.buffer) == 0 {\n-            0\n-        } else {\n-            1\n-        };\n+        let offset = if self.buffer.ends_with('\\n') { 0 } else { 1 };\n         let newline_upper_bound = self.config.blank_lines_upper_bound() + offset;\n         let newline_lower_bound = self.config.blank_lines_lower_bound() + offset;\n         if newline_count > newline_upper_bound {\n@@ -121,86 +136,7 @@ impl<'a> FmtVisitor<'a> {\n \n         debug!(\"write_snippet `{}`\", snippet);\n \n-        self.write_snippet_inner(big_snippet, big_diff, &snippet, span, process_last_snippet);\n-    }\n-\n-    fn process_comment(\n-        &mut self,\n-        status: &mut SnippetStatus,\n-        snippet: &str,\n-        big_snippet: &str,\n-        offset: usize,\n-        big_diff: usize,\n-        subslice: &str,\n-        file_name: &str,\n-    ) -> bool {\n-        let last_char = big_snippet[..(offset + big_diff)]\n-            .chars()\n-            .rev()\n-            .skip_while(|rev_c| [' ', '\\t'].contains(rev_c))\n-            .next();\n-\n-        let fix_indent = last_char.map_or(true, |rev_c| ['{', '\\n'].contains(&rev_c));\n-\n-        let subslice_num_lines = count_newlines(subslice);\n-        let skip_this_range = !self.config.file_lines().intersects_range(\n-            file_name,\n-            status.cur_line,\n-            status.cur_line + subslice_num_lines,\n-        );\n-\n-        if status.rewrite_next_comment && skip_this_range {\n-            status.rewrite_next_comment = false;\n-        }\n-\n-        if status.rewrite_next_comment {\n-            let comment_indent = if fix_indent {\n-                if let Some('{') = last_char {\n-                    self.push_str(\"\\n\");\n-                }\n-                let indent_str = self.block_indent.to_string(self.config);\n-                self.push_str(&indent_str);\n-                self.block_indent\n-            } else {\n-                self.push_str(\" \");\n-                Indent::from_width(self.config, last_line_width(&self.buffer))\n-            };\n-            let comment_width = ::std::cmp::min(\n-                self.config.comment_width(),\n-                self.config.max_width() - self.block_indent.width(),\n-            );\n-            let comment_shape = Shape::legacy(comment_width, comment_indent);\n-            let comment_str = rewrite_comment(subslice, false, comment_shape, self.config)\n-                .unwrap_or_else(|| String::from(subslice));\n-            self.push_str(&comment_str);\n-\n-            status.last_wspace = None;\n-            status.line_start = offset + subslice.len();\n-\n-            if let Some('/') = subslice.chars().nth(1) {\n-                // check that there are no contained block comments\n-                if !subslice\n-                    .split('\\n')\n-                    .map(|s| s.trim_left())\n-                    .any(|s| s.len() >= 2 && &s[0..2] == \"/*\")\n-                {\n-                    // Add a newline after line comments\n-                    self.push_str(\"\\n\");\n-                }\n-            } else if status.line_start <= snippet.len() {\n-                // For other comments add a newline if there isn't one at the end already\n-                match snippet[status.line_start..].chars().next() {\n-                    Some('\\n') | Some('\\r') => (),\n-                    _ => self.push_str(\"\\n\"),\n-                }\n-            }\n-\n-            status.cur_line += subslice_num_lines;\n-            true\n-        } else {\n-            status.rewrite_next_comment = false;\n-            false\n-        }\n+        self.write_snippet_inner(big_snippet, big_diff, snippet, span, process_last_snippet);\n     }\n \n     fn write_snippet_inner<F>(\n@@ -220,19 +156,6 @@ impl<'a> FmtVisitor<'a> {\n         let file_name = &char_pos.file.name;\n         let mut status = SnippetStatus::new(char_pos.line);\n \n-        fn replace_chars<'a>(string: &'a str) -> Cow<'a, str> {\n-            if string.contains(char::is_whitespace) {\n-                Cow::from(\n-                    string\n-                        .chars()\n-                        .map(|ch| if ch.is_whitespace() { ch } else { 'X' })\n-                        .collect::<String>(),\n-                )\n-            } else {\n-                Cow::from(string)\n-            }\n-        }\n-\n         let snippet = &*match self.config.write_mode() {\n             WriteMode::Coverage => replace_chars(old_snippet),\n             _ => Cow::from(old_snippet),\n@@ -241,98 +164,148 @@ impl<'a> FmtVisitor<'a> {\n         for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n             debug!(\"{:?}: {:?}\", kind, subslice);\n \n-            if let CodeCharKind::Comment = kind {\n-                if self.process_comment(\n+            let newline_count = count_newlines(subslice);\n+            let within_file_lines_range = self.config.file_lines().intersects_range(\n+                file_name,\n+                status.cur_line,\n+                status.cur_line + newline_count,\n+            );\n+\n+            if CodeCharKind::Comment == kind && within_file_lines_range {\n+                // 1: comment.\n+                self.process_comment(\n                     &mut status,\n                     snippet,\n-                    big_snippet,\n+                    &big_snippet[..(offset + big_diff)],\n                     offset,\n-                    big_diff,\n                     subslice,\n-                    file_name,\n-                ) {\n-                    continue;\n-                }\n-            }\n-\n-            let newline_count = count_newlines(&subslice);\n-            if subslice.trim().is_empty() && newline_count > 0\n-                && self.config.file_lines().intersects_range(\n-                    file_name,\n-                    status.cur_line,\n-                    status.cur_line + newline_count,\n-                ) {\n+                );\n+            } else if subslice.trim().is_empty() && newline_count > 0 && within_file_lines_range {\n+                // 2: blank lines.\n                 self.push_vertical_spaces(newline_count);\n                 status.cur_line += newline_count;\n-                status.rewrite_next_comment = true;\n                 status.line_start = offset + newline_count;\n             } else {\n-                for (mut i, c) in subslice.char_indices() {\n-                    i += offset;\n-\n-                    if c == '\\n' {\n-                        if !self.config\n-                            .file_lines()\n-                            .contains_line(file_name, status.cur_line)\n-                        {\n-                            status.last_wspace = None;\n-                        }\n-\n-                        if let Some(lw) = status.last_wspace {\n-                            self.push_str(&snippet[status.line_start..lw]);\n-                            self.push_str(\"\\n\");\n-                        } else {\n-                            self.push_str(&snippet[status.line_start..i + 1]);\n-                        }\n-\n-                        status.cur_line += 1;\n-                        status.line_start = i + 1;\n-                        status.last_wspace = None;\n-                        status.rewrite_next_comment = true;\n-                    } else if c.is_whitespace() {\n-                        if status.last_wspace.is_none() {\n-                            status.last_wspace = Some(i);\n-                        }\n-                    } else if c == ';' {\n-                        if status.last_wspace.is_some() {\n-                            status.line_start = i;\n-                        }\n-\n-                        status.rewrite_next_comment = true;\n-                        status.last_wspace = None;\n-                    } else {\n-                        status.rewrite_next_comment = true;\n-                        status.last_wspace = None;\n-                    }\n-                }\n-\n-                let remaining = snippet[status.line_start..subslice.len() + offset].trim();\n-                if !remaining.is_empty() {\n-                    self.push_str(remaining);\n-                    status.line_start = subslice.len() + offset;\n-                    status.rewrite_next_comment = true;\n-                }\n+                // 3: code which we failed to format or which is not within file-lines range.\n+                self.process_missing_code(&mut status, snippet, subslice, offset, file_name);\n             }\n         }\n \n         process_last_snippet(self, &snippet[status.line_start..], snippet);\n     }\n-}\n \n-struct SnippetStatus {\n-    line_start: usize,\n-    last_wspace: Option<usize>,\n-    rewrite_next_comment: bool,\n-    cur_line: usize,\n-}\n+    fn process_comment(\n+        &mut self,\n+        status: &mut SnippetStatus,\n+        snippet: &str,\n+        big_snippet: &str,\n+        offset: usize,\n+        subslice: &str,\n+    ) {\n+        let last_char = big_snippet\n+            .chars()\n+            .rev()\n+            .skip_while(|rev_c| [' ', '\\t'].contains(rev_c))\n+            .next();\n \n-impl SnippetStatus {\n-    fn new(cur_line: usize) -> Self {\n-        SnippetStatus {\n-            line_start: 0,\n-            last_wspace: None,\n-            rewrite_next_comment: true,\n-            cur_line,\n+        let fix_indent = last_char.map_or(true, |rev_c| ['{', '\\n'].contains(&rev_c));\n+\n+        if fix_indent {\n+            if let Some('{') = last_char {\n+                self.push_str(\"\\n\");\n+            }\n+            let indent_str = self.block_indent.to_string(self.config);\n+            self.push_str(&indent_str);\n+        } else {\n+            self.push_str(\" \");\n+        }\n+\n+        let comment_width = ::std::cmp::min(\n+            self.config.comment_width(),\n+            self.config.max_width() - self.block_indent.width(),\n+        );\n+        let comment_indent = Indent::from_width(self.config, last_line_width(&self.buffer));\n+        let comment_shape = Shape::legacy(comment_width, comment_indent);\n+        let comment_str = rewrite_comment(subslice, false, comment_shape, self.config)\n+            .unwrap_or_else(|| String::from(subslice));\n+        self.push_str(&comment_str);\n+\n+        status.last_wspace = None;\n+        status.line_start = offset + subslice.len();\n+\n+        if let Some('/') = subslice.chars().nth(1) {\n+            // check that there are no contained block comments\n+            if !subslice\n+                .split('\\n')\n+                .map(|s| s.trim_left())\n+                .any(|s| s.len() >= 2 && &s[0..2] == \"/*\")\n+            {\n+                // Add a newline after line comments\n+                self.push_str(\"\\n\");\n+            }\n+        } else if status.line_start <= snippet.len() {\n+            // For other comments add a newline if there isn't one at the end already\n+            match snippet[status.line_start..].chars().next() {\n+                Some('\\n') | Some('\\r') => (),\n+                _ => self.push_str(\"\\n\"),\n+            }\n         }\n+\n+        status.cur_line += count_newlines(subslice);\n     }\n+\n+    fn process_missing_code(\n+        &mut self,\n+        status: &mut SnippetStatus,\n+        snippet: &str,\n+        subslice: &str,\n+        offset: usize,\n+        file_name: &str,\n+    ) {\n+        for (mut i, c) in subslice.char_indices() {\n+            i += offset;\n+\n+            if c == '\\n' {\n+                let skip_this_line = !self.config\n+                    .file_lines()\n+                    .contains_line(file_name, status.cur_line);\n+                if skip_this_line {\n+                    status.last_wspace = None;\n+                }\n+\n+                if let Some(lw) = status.last_wspace {\n+                    self.push_str(&snippet[status.line_start..lw]);\n+                    self.push_str(\"\\n\");\n+                    status.last_wspace = None;\n+                } else {\n+                    self.push_str(&snippet[status.line_start..i + 1]);\n+                }\n+\n+                status.cur_line += 1;\n+                status.line_start = i + 1;\n+            } else if c.is_whitespace() && status.last_wspace.is_none() {\n+                status.last_wspace = Some(i);\n+            } else if c == ';' && status.last_wspace.is_some() {\n+                status.line_start = i;\n+                status.last_wspace = None;\n+            } else {\n+                status.last_wspace = None;\n+            }\n+        }\n+\n+        let remaining = snippet[status.line_start..subslice.len() + offset].trim();\n+        if !remaining.is_empty() {\n+            self.push_str(remaining);\n+            status.line_start = subslice.len() + offset;\n+        }\n+    }\n+}\n+\n+fn replace_chars(string: &str) -> Cow<str> {\n+    Cow::from(\n+        string\n+            .chars()\n+            .map(|ch| if ch.is_whitespace() { ch } else { 'X' })\n+            .collect::<String>(),\n+    )\n }"}]}