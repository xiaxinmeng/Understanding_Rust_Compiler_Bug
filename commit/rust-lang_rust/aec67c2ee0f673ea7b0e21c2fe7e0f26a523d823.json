{"sha": "aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYzY3YzJlZTBmNjczZWE3YjBlMjFjMmZlN2UwZjI2YTUyM2Q4MjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T18:20:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T18:20:31Z"}, "message": "Revert \"std: Re-enable at_exit()\"\n\nThis reverts commit 9e224c2bf18ebf8f871efb2e1aba43ed7970ebb7.\n\nConflicts:\n\tsrc/libstd/sys/windows/os.rs", "tree": {"sha": "032a8ec1398c7334c20b791a4c4c460feb5e2c79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/032a8ec1398c7334c20b791a4c4c460feb5e2c79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "html_url": "https://github.com/rust-lang/rust/commit/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "582cba183f18eea5c40b6c035d63ad449a9e8604", "url": "https://api.github.com/repos/rust-lang/rust/commits/582cba183f18eea5c40b6c035d63ad449a9e8604", "html_url": "https://github.com/rust-lang/rust/commit/582cba183f18eea5c40b6c035d63ad449a9e8604"}], "stats": {"total": 436, "additions": 245, "deletions": 191}, "files": [{"sha": "b30938ae7f57770e1ca517e52a6314052c250ce5", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -177,7 +177,7 @@ use std::mem;\n use std::os;\n use std::rt;\n use std::slice;\n-use std::sync::{Once, ONCE_INIT, StaticMutex, MUTEX_INIT};\n+use std::sync::{Once, ONCE_INIT};\n \n use regex::Regex;\n \n@@ -193,8 +193,6 @@ pub const MAX_LOG_LEVEL: u32 = 255;\n /// The default logging level of a crate if no other is specified.\n const DEFAULT_LOG_LEVEL: u32 = 1;\n \n-static LOCK: StaticMutex = MUTEX_INIT;\n-\n /// An unsafe constant that is the maximum logging level of any module\n /// specified. This is the first line of defense to determining whether a\n /// logging statement should be run.\n@@ -281,18 +279,9 @@ impl Drop for DefaultLogger {\n pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n-    unsafe {\n-        let _g = LOCK.lock();\n-        match FILTER as uint {\n-            0 => {}\n-            1 => panic!(\"cannot log after main thread has exited\"),\n-            n => {\n-                let filter = mem::transmute::<_, &Regex>(n);\n-                if !filter.is_match(args.to_string().as_slice()) {\n-                    return\n-                }\n-            }\n-        }\n+    match unsafe { FILTER.as_ref() } {\n+        Some(filter) if !filter.is_match(args.to_string()[]) => return,\n+        _ => {}\n     }\n \n     // Completely remove the local logger from TLS in case anyone attempts to\n@@ -374,15 +363,9 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n \n     // This assertion should never get tripped unless we're in an at_exit\n     // handler after logging has been torn down and a logging attempt was made.\n+    assert!(unsafe { !DIRECTIVES.is_null() });\n \n-    let _g = LOCK.lock();\n-    unsafe {\n-        assert!(DIRECTIVES as uint != 0);\n-        assert!(DIRECTIVES as uint != 1,\n-                \"cannot log after the main thread has exited\");\n-\n-        enabled(level, module, (*DIRECTIVES).iter())\n-    }\n+    enabled(level, module, unsafe { (*DIRECTIVES).iter() })\n }\n \n fn enabled(level: u32,\n@@ -438,15 +421,14 @@ fn init() {\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n         rt::at_exit(move |:| {\n-            let _g = LOCK.lock();\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n                 mem::transmute(DIRECTIVES);\n-            DIRECTIVES = 1 as *const Vec<directive::LogDirective>;\n+            DIRECTIVES = 0 as *const Vec<directive::LogDirective>;\n \n             if !FILTER.is_null() {\n                 let _filter: Box<Regex> = mem::transmute(FILTER);\n-                FILTER = 1 as *const _;\n+                FILTER = 0 as *const _;\n             }\n         });\n     }"}, {"sha": "43d2e078035a6ef83c60982d836b7e17e261b8bd", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -26,19 +26,29 @@\n //! ```\n \n use self::StdSource::*;\n-use prelude::*;\n \n+use boxed::Box;\n use cell::RefCell;\n+use clone::Clone;\n use failure::LOCAL_STDERR;\n use fmt;\n-use io::{IoResult, IoError, OtherIoError};\n-use io::{standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n+use io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n+         standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n+use kinds::{Sync, Send};\n use libc;\n use mem;\n+use option::Option;\n+use option::Option::{Some, None};\n+use ops::{Deref, DerefMut, FnOnce};\n+use result::Result::{Ok, Err};\n use rt;\n+use slice::SliceExt;\n+use str::StrExt;\n+use string::String;\n use sys::{fs, tty};\n-use sync::{Arc, Mutex, MutexGuard, StaticMutex, MUTEX_INIT};\n+use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};\n use uint;\n+use vec::Vec;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -205,15 +215,14 @@ impl Reader for StdinReader {\n pub fn stdin() -> StdinReader {\n     // We're following the same strategy as kimundi's lazy_static library\n     static mut STDIN: *const StdinReader = 0 as *const StdinReader;\n-    static LOCK: StaticMutex = MUTEX_INIT;\n+    static ONCE: Once = ONCE_INIT;\n \n     unsafe {\n-        let _g = LOCK.lock();\n-        if STDIN as uint == 0 {\n-            // The default buffer capacity is 64k, but apparently windows\n-            // doesn't like 64k reads on stdin. See #13304 for details, but the\n-            // idea is that on windows we use a slightly smaller buffer that's\n-            // been seen to be acceptable.\n+        ONCE.doit(|| {\n+            // The default buffer capacity is 64k, but apparently windows doesn't like\n+            // 64k reads on stdin. See #13304 for details, but the idea is that on\n+            // windows we use a slightly smaller buffer that's been seen to be\n+            // acceptable.\n             let stdin = if cfg!(windows) {\n                 BufferedReader::with_capacity(8 * 1024, stdin_raw())\n             } else {\n@@ -226,15 +235,11 @@ pub fn stdin() -> StdinReader {\n \n             // Make sure to free it at exit\n             rt::at_exit(|| {\n-                let g = LOCK.lock();\n-                let stdin = STDIN;\n-                STDIN = 1 as *const _;\n-                drop(g);\n-                mem::transmute::<_, Box<StdinReader>>(stdin);\n+                mem::transmute::<_, Box<StdinReader>>(STDIN);\n+                STDIN = 0 as *const _;\n             });\n-        } else if STDIN as uint == 1 {\n-            panic!(\"accessing stdin after the main thread has exited\")\n-        }\n+        });\n+\n         (*STDIN).clone()\n     }\n }"}, {"sha": "74c387c5eeaf1aafe95b437b12be97ac58f07ba7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -229,13 +229,13 @@ pub mod thread;\n pub mod sync;\n pub mod comm;\n \n-#[path = \"sys/common/mod.rs\"] mod sys_common;\n-\n #[cfg(unix)]\n #[path = \"sys/unix/mod.rs\"] mod sys;\n #[cfg(windows)]\n #[path = \"sys/windows/mod.rs\"] mod sys;\n \n+#[path = \"sys/common/mod.rs\"] mod sys_common;\n+\n pub mod rt;\n mod failure;\n "}, {"sha": "5823f8453d84a3ffc8f87d7f2efe137db6786932", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -29,8 +29,6 @@ type Queue = Vec<Thunk>;\n static LOCK: Mutex = MUTEX_INIT;\n static mut QUEUE: *mut Queue = 0 as *mut Queue;\n \n-const DTOR_RUN_ITERS: uint = 10;\n-\n unsafe fn init() {\n     if QUEUE.is_null() {\n         let state: Box<Queue> = box Vec::new();\n@@ -51,7 +49,7 @@ pub fn cleanup() {\n     unsafe {\n         LOCK.lock();\n         let queue = QUEUE;\n-        QUEUE = 1u as *mut _;\n+        QUEUE = 1 as *mut _;\n         LOCK.unlock();\n \n         // make sure we're not recursively cleaning up"}, {"sha": "e877dd5c6aab813ba5689070940299b667d5df1a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -92,7 +92,9 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n         // but we just do this to name the main thread and to give it correct\n         // info about the stack bounds.\n         let thread: Thread = NewThread::new(Some(\"<main>\".to_string()));\n-        thread_info::set(sys::thread::guard::main(), thread);\n+        thread_info::set((my_stack_bottom, my_stack_top),\n+                         sys::thread::guard::main(),\n+                         thread);\n \n         // By default, some platforms will send a *signal* when a EPIPE error\n         // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n@@ -131,14 +133,20 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     }\n }\n \n-/// Enqueues a procedure to run when the main thread exits.\n+/// Enqueues a procedure to run when the runtime is cleaned up\n+///\n+/// The procedure passed to this function will be executed as part of the\n+/// runtime cleanup phase. For normal rust programs, this means that it will run\n+/// after all other threads have exited.\n+///\n+/// The procedure is *not* executed with a local `Thread` available to it, so\n+/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n+/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n+/// not meant as a general-purpose \"let's clean everything up\" function.\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-///\n-/// Note that other threads may still be running when `at_exit` routines start\n-/// running.\n-pub fn at_exit<F: FnOnce() + Send>(f: F) {\n+pub fn at_exit<F:FnOnce()+Send>(f: F) {\n     at_exit_imp::push(Thunk::new(f));\n }\n \n@@ -154,5 +162,8 @@ pub fn at_exit<F: FnOnce() + Send>(f: F) {\n pub unsafe fn cleanup() {\n     args::cleanup();\n     sys::stack_overflow::cleanup();\n-    at_exit_imp::cleanup();\n+    // FIXME: (#20012): the resources being cleaned up by at_exit\n+    // currently are not prepared for cleanup to happen asynchronously\n+    // with detached threads using the resources; for now, we leak.\n+    // at_exit_imp::cleanup();\n }"}, {"sha": "c273c52daccadbb5551cbea9a79d6955685271de", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -68,7 +68,7 @@ use intrinsics;\n use libc::c_void;\n use mem;\n use sync::atomic;\n-use sys_common::mutex::{Mutex, MUTEX_INIT};\n+use sync::{Once, ONCE_INIT};\n \n use rt::libunwind as uw;\n \n@@ -540,20 +540,11 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// Doing this split took the LLVM IR line counts of `fn main() { panic!()\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n-fn begin_unwind_inner(msg: Box<Any + Send>,\n-                      file_line: &(&'static str, uint)) -> ! {\n+fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! {\n     // Make sure the default failure handler is registered before we look at the\n     // callbacks.\n-    unsafe {\n-        static LOCK: Mutex = MUTEX_INIT;\n-        static mut INIT: bool = false;\n-        LOCK.lock();\n-        if !INIT {\n-            register(failure::on_fail);\n-            INIT = true;\n-        }\n-        LOCK.unlock();\n-    }\n+    static INIT: Once = ONCE_INIT;\n+    INIT.doit(|| unsafe { register(failure::on_fail); });\n \n     // First, invoke call the user-defined callbacks triggered on thread panic.\n     //"}, {"sha": "9ef1c33312fc8b4ac6c5a6e354ce0caa12bcc0b2", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -20,8 +20,6 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n-#![macro_escape]\n-\n use prelude::*;\n \n use cell::UnsafeCell;\n@@ -70,17 +68,6 @@ struct RaceBox(helper_signal::signal);\n unsafe impl Send for RaceBox {}\n unsafe impl Sync for RaceBox {}\n \n-macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n-    static $name: Helper<$m> = Helper {\n-        lock: ::sync::MUTEX_INIT,\n-        cond: ::sync::CONDVAR_INIT,\n-        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n-        signal: ::cell::UnsafeCell { value: 0 },\n-        initialized: ::cell::UnsafeCell { value: false },\n-        shutdown: ::cell::UnsafeCell { value: false },\n-    };\n-) }\n-\n impl<M: Send> Helper<M> {\n     /// Lazily boots a helper thread, becoming a no-op if the helper has already\n     /// been spawned.\n@@ -97,7 +84,7 @@ impl<M: Send> Helper<M> {\n     {\n         unsafe {\n             let _guard = self.lock.lock().unwrap();\n-            if *self.chan.get() as uint == 0 {\n+            if !*self.initialized.get() {\n                 let (tx, rx) = channel();\n                 *self.chan.get() = mem::transmute(box tx);\n                 let (receive, send) = helper_signal::new();\n@@ -106,17 +93,15 @@ impl<M: Send> Helper<M> {\n                 let receive = RaceBox(receive);\n \n                 let t = f();\n-                Thread::spawn(move || {\n+                Thread::spawn(move |:| {\n                     helper(receive.0, rx, t);\n                     let _g = self.lock.lock().unwrap();\n                     *self.shutdown.get() = true;\n                     self.cond.notify_one()\n                 }).detach();\n \n-                rt::at_exit(move || { self.shutdown() });\n+                rt::at_exit(move|:| { self.shutdown() });\n                 *self.initialized.get() = true;\n-            } else if *self.chan.get() as uint == 1 {\n-                panic!(\"cannot continue usage after shutdown\");\n             }\n         }\n     }\n@@ -131,9 +116,7 @@ impl<M: Send> Helper<M> {\n             // Must send and *then* signal to ensure that the child receives the\n             // message. Otherwise it could wake up and go to sleep before we\n             // send the message.\n-            assert!(*self.chan.get() as uint != 0);\n-            assert!(*self.chan.get() as uint != 1,\n-                    \"cannot continue usage after shutdown\");\n+            assert!(!self.chan.get().is_null());\n             (**self.chan.get()).send(msg);\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n         }\n@@ -146,13 +129,9 @@ impl<M: Send> Helper<M> {\n             // returns.\n             let mut guard = self.lock.lock().unwrap();\n \n-            let ptr = *self.chan.get();\n-            if ptr as uint == 1 {\n-                panic!(\"cannot continue usage after shutdown\");\n-            }\n             // Close the channel by destroying it\n             let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n-            *self.chan.get() = 1 as *mut Sender<M>;\n+            *self.chan.get() = 0 as *mut Sender<M>;\n             drop(chan);\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n "}, {"sha": "dc0ad08cdbef637100a7f8477897af5643ddcedf", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![macro_escape]\n+#![allow(dead_code)]\n \n use io::{mod, IoError, IoResult};\n use prelude::*;"}, {"sha": "567c26956efe94f6c3a1e62d440b7e75b9d46035", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -29,7 +29,6 @@ impl Mutex {\n     /// Behavior is undefined if the mutex is moved after the first method is\n     /// called on the mutex.\n     #[inline]\n-    #[allow(dead_code)] // sys is not exported yet\n     pub unsafe fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n     /// Lock the mutex blocking the current thread until it is available."}, {"sha": "87ec20fbef872268df84480ea187a18b70229fc3", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -23,9 +23,7 @@ use io::{IoResult, IoError};\n use sys::{mod, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n           wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n           decode_error_detailed};\n-use sync::Mutex;\n-#[cfg(not(target_os = \"linux\"))]\n-use sync::MutexGuard;\n+use sync::{Mutex, MutexGuard};\n use sys_common::{mod, keep_going, short_write, timeout};\n use prelude::*;\n use cmp;\n@@ -613,13 +611,11 @@ impl Drop for Inner {\n     fn drop(&mut self) { unsafe { close_sock(self.fd); } }\n }\n \n-#[cfg(not(target_os = \"linux\"))]\n pub struct Guard<'a> {\n     pub fd: sock_t,\n     pub guard: MutexGuard<'a, ()>,\n }\n \n-#[cfg(not(target_os = \"linux\"))]\n #[unsafe_destructor]\n impl<'a> Drop for Guard<'a> {\n     fn drop(&mut self) {"}, {"sha": "df016b9e293b7fb44e20aecd4ccdca1acd94429f", "filename": "src/libstd/sys/common/rwlock.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -26,7 +26,6 @@ impl RWLock {\n     /// Usage of an RWLock is undefined if it is moved after its first use (any\n     /// function calls below).\n     #[inline]\n-    #[allow(dead_code)] // sys is not exported yet\n     pub unsafe fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n \n     /// Acquire shared access to the underlying lock, blocking the current"}, {"sha": "2a88e20c8fa1f1e727cdc1546812e48fa30fde81", "filename": "src/libstd/sys/common/stack.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -121,6 +121,37 @@ pub unsafe fn record_os_managed_stack_bounds(stack_lo: uint, _stack_hi: uint) {\n     record_sp_limit(stack_lo + RED_ZONE);\n }\n \n+#[inline(always)]\n+pub unsafe fn record_rust_managed_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+    // When the old runtime had segmented stacks, it used a calculation that was\n+    // \"limit + RED_ZONE + FUDGE\". The red zone was for things like dynamic\n+    // symbol resolution, llvm function calls, etc. In theory this red zone\n+    // value is 0, but it matters far less when we have gigantic stacks because\n+    // we don't need to be so exact about our stack budget. The \"fudge factor\"\n+    // was because LLVM doesn't emit a stack check for functions < 256 bytes in\n+    // size. Again though, we have giant stacks, so we round all these\n+    // calculations up to the nice round number of 20k.\n+    record_sp_limit(stack_lo + RED_ZONE);\n+\n+    return target_record_stack_bounds(stack_lo, stack_hi);\n+\n+    #[cfg(not(windows))] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}\n+\n+    #[cfg(all(windows, target_arch = \"x86\"))] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+        // stack range is at TIB: %fs:0x04 (top) and %fs:0x08 (bottom)\n+        asm!(\"mov $0, %fs:0x04\" :: \"r\"(stack_hi) :: \"volatile\");\n+        asm!(\"mov $0, %fs:0x08\" :: \"r\"(stack_lo) :: \"volatile\");\n+    }\n+    #[cfg(all(windows, target_arch = \"x86_64\"))] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+        // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n+        asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_hi) :: \"volatile\");\n+        asm!(\"mov $0, %gs:0x10\" :: \"r\"(stack_lo) :: \"volatile\");\n+    }\n+}\n+\n /// Records the current limit of the stack as specified by `end`.\n ///\n /// This is stored in an OS-dependent location, likely inside of the thread"}, {"sha": "dc21feb17a8e83c660788c6d720399debf17cb8c", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -8,15 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_code)] // stack_guard isn't used right now on all platforms\n-\n use core::prelude::*;\n \n use thread::Thread;\n use cell::RefCell;\n use string::String;\n \n struct ThreadInfo {\n+    // This field holds the known bounds of the stack in (lo, hi)\n+    // form. Not all threads necessarily know their precise bounds,\n+    // hence this is optional.\n+    stack_bounds: (uint, uint),\n     stack_guard: uint,\n     thread: Thread,\n }\n@@ -33,6 +35,7 @@ impl ThreadInfo {\n         THREAD_INFO.with(|c| {\n             if c.borrow().is_none() {\n                 *c.borrow_mut() = Some(ThreadInfo {\n+                    stack_bounds: (0, 0),\n                     stack_guard: 0,\n                     thread: NewThread::new(None),\n                 })\n@@ -50,9 +53,10 @@ pub fn stack_guard() -> uint {\n     ThreadInfo::with(|info| info.stack_guard)\n }\n \n-pub fn set(stack_guard: uint, thread: Thread) {\n+pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n     THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n+        stack_bounds: stack_bounds,\n         stack_guard: stack_guard,\n         thread: thread,\n     }));"}, {"sha": "fe7a7d8d0371688540bd19b327340f7a5b268afe", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -55,11 +55,11 @@\n //! ```\n \n #![allow(non_camel_case_types)]\n-#![allow(dead_code)] // sys isn't exported yet\n \n use prelude::*;\n \n use sync::atomic::{mod, AtomicUint};\n+use sync::{Mutex, Once, ONCE_INIT};\n \n use sys::thread_local as imp;\n \n@@ -140,6 +140,9 @@ pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n     key: atomic::INIT_ATOMIC_UINT,\n };\n \n+static INIT_KEYS: Once = ONCE_INIT;\n+static mut KEYS: *mut Mutex<Vec<imp::Key>> = 0 as *mut _;\n+\n impl StaticKey {\n     /// Gets the value associated with this TLS key\n     ///"}, {"sha": "ddae9a132c31483a88b79286e6d3c1c747a872df", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -83,12 +83,12 @@\n /// to symbols. This is a bit of a hokey implementation as-is, but it works for\n /// all unix platforms we support right now, so it at least gets the job done.\n \n-use prelude::*;\n-\n use c_str::CString;\n-use io::IoResult;\n+use io::{IoResult, Writer};\n use libc;\n use mem;\n+use option::Option::{mod, Some, None};\n+use result::Result::{Ok, Err};\n use sync::{StaticMutex, MUTEX_INIT};\n \n use sys_common::backtrace::*;\n@@ -151,7 +151,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     // I/O done here is blocking I/O, not green I/O, so we don't have to\n     // worry about this being a native vs green mutex.\n     static LOCK: StaticMutex = MUTEX_INIT;\n-    let _g = LOCK.lock();\n+    let _g = unsafe { LOCK.lock() };\n \n     try!(writeln!(w, \"stack backtrace:\"));\n \n@@ -241,8 +241,12 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n+    use iter::{Iterator, IteratorExt};\n     use os;\n+    use path::GenericPath;\n+    use ptr::PtrExt;\n     use ptr;\n+    use slice::SliceExt;\n \n     ////////////////////////////////////////////////////////////////////////\n     // libbacktrace.h API"}, {"sha": "c82dacf1e44e9e9b2487497c11f27ae73931b93e", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -10,14 +10,30 @@\n \n #![allow(missing_docs)]\n #![allow(non_camel_case_types)]\n+#![allow(unused_imports)]\n+#![allow(dead_code)]\n+#![allow(unused_unsafe)]\n+#![allow(unused_mut)]\n \n extern crate libc;\n \n+use num;\n use num::{Int, SignedInt};\n use prelude::*;\n use io::{mod, IoResult, IoError};\n use sys_common::mkerr_libc;\n \n+macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n+    static $name: Helper<$m> = Helper {\n+        lock: ::sync::MUTEX_INIT,\n+        cond: ::sync::CONDVAR_INIT,\n+        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n+        signal: ::cell::UnsafeCell { value: 0 },\n+        initialized: ::cell::UnsafeCell { value: false },\n+        shutdown: ::cell::UnsafeCell { value: false },\n+    };\n+) }\n+\n pub mod backtrace;\n pub mod c;\n pub mod ext;"}, {"sha": "81f8659d6ae08b87c79c247655ab1c68a668a1ba", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -11,6 +11,7 @@\n use cell::UnsafeCell;\n use kinds::Sync;\n use sys::sync as ffi;\n+use sys_common::mutex;\n \n pub struct Mutex { inner: UnsafeCell<ffi::pthread_mutex_t> }\n \n@@ -25,7 +26,6 @@ pub const MUTEX_INIT: Mutex = Mutex {\n \n unsafe impl Sync for Mutex {}\n \n-#[allow(dead_code)] // sys isn't exported yet\n impl Mutex {\n     #[inline]\n     pub unsafe fn new() -> Mutex {"}, {"sha": "cafe52f8403b6d312c1d6c66f079d49b7c76a92b", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -10,16 +10,17 @@\n \n //! Implementation of `std::os` functionality for unix systems\n \n-#![allow(unused_imports)] // lots of cfg code here\n-\n use prelude::*;\n \n+use error::{FromError, Error};\n+use fmt;\n use io::{IoError, IoResult};\n-use libc::{mod, c_int, c_char};\n-use os;\n+use libc::{mod, c_int, c_char, c_void};\n use path::BytesContainer;\n use ptr;\n+use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use sys::fs::FileDesc;\n+use os;\n \n use os::TMPBUF_SZ;\n "}, {"sha": "868b460aa5ed3897e807bc667aaf05babd764949", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -145,7 +145,7 @@ impl UnixStream {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: self.inner.lock.lock().unwrap(),\n+            guard: unsafe { self.inner.lock.lock().unwrap() },\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret"}, {"sha": "835f4279d9bc69d3055eaf7431edc130e7c08f20", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -11,7 +11,7 @@ use self::Req::*;\n \n use libc::{mod, pid_t, c_void, c_int};\n use c_str::CString;\n-use io::{IoResult, EndOfFile};\n+use io::{mod, IoResult, IoError, EndOfFile};\n use mem;\n use os;\n use ptr;\n@@ -327,15 +327,15 @@ impl Process {\n         // The actual communication between the helper thread and this thread is\n         // quite simple, just a channel moving data around.\n \n-        HELPER.boot(register_sigchld, waitpid_helper);\n+        unsafe { HELPER.boot(register_sigchld, waitpid_helper) }\n \n         match self.try_wait() {\n             Some(ret) => return Ok(ret),\n             None => {}\n         }\n \n         let (tx, rx) = channel();\n-        HELPER.send(NewChild(self.pid, tx, deadline));\n+        unsafe { HELPER.send(NewChild(self.pid, tx, deadline)); }\n         return match rx.recv_opt() {\n             Ok(e) => Ok(e),\n             Err(()) => Err(timeout(\"wait timed out\")),\n@@ -419,15 +419,8 @@ impl Process {\n                             Ok(NewChild(pid, tx, deadline)) => {\n                                 active.push((pid, tx, deadline));\n                             }\n-                            // Once we've been disconnected it means the main\n-                            // thread is exiting (at_exit has run). We could\n-                            // still have active waiter for other threads, so\n-                            // we're just going to drop them all on the floor.\n-                            // This means that they won't receive a \"you're\n-                            // done\" message in which case they'll be considered\n-                            // as timed out, but more generally errors will\n-                            // start propagating.\n                             Err(comm::Disconnected) => {\n+                                assert!(active.len() == 0);\n                                 break 'outer;\n                             }\n                             Err(comm::Empty) => break,"}, {"sha": "0d63ff14ff26b892a3e0f346598dd60f2cd81b61", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -17,7 +17,6 @@ pub const RWLOCK_INIT: RWLock = RWLock {\n     inner: UnsafeCell { value: ffi::PTHREAD_RWLOCK_INITIALIZER },\n };\n \n-#[allow(dead_code)] // sys isn't exported yet\n impl RWLock {\n     #[inline]\n     pub unsafe fn new() -> RWLock {"}, {"sha": "bcbbb8766b7f47038534f8b574e19be6c9773989", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -34,6 +34,7 @@ impl Drop for Handler {\n \n #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n mod imp {\n+    use core::prelude::*;\n     use sys_common::stack;\n \n     use super::Handler;"}, {"sha": "e2a78947e167ab015c9ea3950b3d5a0b1fda65d3", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -135,6 +135,10 @@ impl TcpAcceptor {\n         Err(sys_common::eof())\n     }\n \n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        net::sockname(self.fd(), libc::getsockname)\n+    }\n+\n     pub fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| sys::timer::now() + a).unwrap_or(0);\n     }"}, {"sha": "c0ef89666c0f59b16885ee4a1ce6369ace8af752", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -100,7 +100,7 @@ pub fn now() -> u64 {\n fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n \n-    let fd = FileDesc::new(input, true);\n+    let mut fd = FileDesc::new(input, true);\n     let mut timeout: libc::timeval = unsafe { mem::zeroed() };\n \n     // active timers are those which are able to be selected upon (and it's a\n@@ -168,15 +168,8 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n             1 => {\n                 loop {\n                     match messages.try_recv() {\n-                        // Once we've been disconnected it means the main thread\n-                        // is exiting (at_exit has run). We could still have\n-                        // active timers for other threads, so we're just going\n-                        // to drop them all on the floor. This is all we can\n-                        // really do, however, to prevent resource leakage. The\n-                        // remaining timers will likely start panicking quickly\n-                        // as they attempt to re-use this thread but are\n-                        // disallowed to do so.\n                         Err(comm::Disconnected) => {\n+                            assert!(active.len() == 0);\n                             break 'outer;\n                         }\n "}, {"sha": "28c17fd4966c09468fe1df7f9570e67cd911ab6e", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -43,4 +43,5 @@ impl TTY {\n     pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         Err(sys_common::unimpl())\n     }\n+    pub fn isatty(&self) -> bool { false }\n }"}, {"sha": "42c8f7705e1fcdf2fbcdce5c43ad091486d2ece2", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -7,22 +7,19 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n-//! As always, windows has something very different than unix, we mainly want\n-//! to avoid having to depend too much on libunwind for windows.\n-//!\n-//! If you google around, you'll find a fair bit of references to built-in\n-//! functions to get backtraces on windows. It turns out that most of these are\n-//! in an external library called dbghelp. I was unable to find this library\n-//! via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n-//! of it.\n-//!\n-//! You'll also find that there's a function called CaptureStackBackTrace\n-//! mentioned frequently (which is also easy to use), but sadly I didn't have a\n-//! copy of that function in my mingw install (maybe it was broken?). Instead,\n-//! this takes the route of using StackWalk64 in order to walk the stack.\n-\n-#![allow(dead_code)] // constants/fields aren't always used on all platforms\n+/// As always, windows has something very different than unix, we mainly want\n+/// to avoid having to depend too much on libunwind for windows.\n+///\n+/// If you google around, you'll find a fair bit of references to built-in\n+/// functions to get backtraces on windows. It turns out that most of these are\n+/// in an external library called dbghelp. I was unable to find this library\n+/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n+/// of it.\n+///\n+/// You'll also find that there's a function called CaptureStackBackTrace\n+/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n+/// copy of that function in my mingw install (maybe it was broken?). Instead,\n+/// this takes the route of using StackWalk64 in order to walk the stack.\n \n use c_str::CString;\n use intrinsics;\n@@ -297,7 +294,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n     static LOCK: StaticMutex = MUTEX_INIT;\n-    let _g = LOCK.lock();\n+    let _g = unsafe { LOCK.lock() };\n \n     // Open up dbghelp.dll, we don't link to it explicitly because it can't\n     // always be found. Additionally, it's nice having fewer dependencies."}, {"sha": "06259d61fcb8413bfa24b78e6cd36ed7352b7a87", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -15,6 +15,7 @@\n #![allow(non_camel_case_types)]\n \n use libc;\n+use prelude::*;\n \n pub const WSADESCRIPTION_LEN: uint = 256;\n pub const WSASYS_STATUS_LEN: uint = 128;"}, {"sha": "3ad439078b9a146767660b3469ca6d93586add35", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -10,17 +10,21 @@\n \n //! Blocking Windows-based file I/O\n \n+use alloc::arc::Arc;\n use libc::{mod, c_int};\n \n-use io;\n+use c_str::CString;\n use mem;\n-use ptr;\n use sys::os::fill_utf16_buf_and_decode;\n+use path;\n+use ptr;\n+use str;\n+use io;\n \n use prelude::*;\n use sys;\n use sys::os;\n-use sys_common::{unimpl, mkerr_libc};\n+use sys_common::{keep_going, eof, mkerr_libc};\n \n use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use io::{IoResult, IoError, FileStat, SeekStyle};\n@@ -441,7 +445,7 @@ pub fn stat(p: &Path) -> IoResult<FileStat> {\n // FIXME: move this to platform-specific modules (for now)?\n pub fn lstat(_p: &Path) -> IoResult<FileStat> {\n     // FIXME: implementation is missing\n-    Err(unimpl())\n+    Err(super::unimpl())\n }\n \n pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {"}, {"sha": "57c284ed6a32699fc9ef11b1a09c196957e8337c", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -11,14 +11,30 @@\n #![allow(missing_docs)]\n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n+#![allow(unused_imports)]\n+#![allow(dead_code)]\n+#![allow(unused_unsafe)]\n+#![allow(unused_mut)]\n \n extern crate libc;\n \n+use num;\n use mem;\n use prelude::*;\n use io::{mod, IoResult, IoError};\n use sync::{Once, ONCE_INIT};\n \n+macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n+    static $name: Helper<$m> = Helper {\n+        lock: ::sync::MUTEX_INIT,\n+        cond: ::sync::CONDVAR_INIT,\n+        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n+        signal: ::cell::UnsafeCell { value: 0 },\n+        initialized: ::cell::UnsafeCell { value: false },\n+        shutdown: ::cell::UnsafeCell { value: false },\n+    };\n+) }\n+\n pub mod backtrace;\n pub mod c;\n pub mod ext;\n@@ -164,6 +180,14 @@ pub fn init_net() {\n     }\n }\n \n+pub fn unimpl() -> IoError {\n+    IoError {\n+        kind: io::IoUnavailable,\n+        desc: \"operation is not implemented\",\n+        detail: None,\n+    }\n+}\n+\n pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n     match s {\n         Some(s) => Ok({"}, {"sha": "e7194df7ac3cb5513b1672d6410ff59b5ccc504b", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -15,6 +15,7 @@\n \n use prelude::*;\n \n+use fmt;\n use io::{IoResult, IoError};\n use iter::repeat;\n use libc::{c_int, c_void};"}, {"sha": "fc3640f260437b8d1f72a1eb1f5ccb6cbbe2add7", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -365,7 +365,7 @@ impl UnixStream {\n         // acquire the lock.\n         //\n         // See comments in close_read() about why this lock is necessary.\n-        let guard = self.inner.lock.lock();\n+        let guard = unsafe { self.inner.lock.lock() };\n         if self.read_closed() {\n             return Err(eof())\n         }\n@@ -441,7 +441,7 @@ impl UnixStream {\n             // going after we woke up.\n             //\n             // See comments in close_read() about why this lock is necessary.\n-            let guard = self.inner.lock.lock();\n+            let guard = unsafe { self.inner.lock.lock() };\n             if self.write_closed() {\n                 return Err(epipe())\n             }\n@@ -516,14 +516,14 @@ impl UnixStream {\n         // close_read() between steps 1 and 2. By atomically executing steps 1\n         // and 2 with a lock with respect to close_read(), we're guaranteed that\n         // no thread will erroneously sit in a read forever.\n-        let _guard = self.inner.lock.lock();\n+        let _guard = unsafe { self.inner.lock.lock() };\n         self.inner.read_closed.store(true, atomic::SeqCst);\n         self.cancel_io()\n     }\n \n     pub fn close_write(&mut self) -> IoResult<()> {\n         // see comments in close_read() for why this lock is necessary\n-        let _guard = self.inner.lock.lock();\n+        let _guard = unsafe { self.inner.lock.lock() };\n         self.inner.write_closed.store(true, atomic::SeqCst);\n         self.cancel_io()\n     }"}, {"sha": "0c2c76077dd5458595987f6b4c7736307110919e", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -8,24 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-\n-use libc::{pid_t, c_void};\n+use libc::{pid_t, c_void, c_int};\n use libc;\n use c_str::CString;\n use io;\n use mem;\n use os;\n use ptr;\n-use io::process::{ProcessExit, ExitStatus};\n+use prelude::*;\n+use io::process::{ProcessExit, ExitStatus, ExitSignal};\n use collections;\n use path::BytesContainer;\n use hash::Hash;\n use io::{IoResult, IoError};\n \n-use sys::timer;\n+use sys::fs;\n+use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval, timer};\n use sys::fs::FileDesc;\n-use sys_common::{AsInner, timeout};\n+use sys_common::helper_thread::Helper;\n+use sys_common::{AsInner, mkerr_libc, timeout};\n \n use io::fs::PathExtensions;\n \n@@ -120,6 +121,8 @@ impl Process {\n         use libc::funcs::extra::msvcrt::get_osfhandle;\n \n         use mem;\n+        use iter::{Iterator, IteratorExt};\n+        use str::StrExt;\n \n         if cfg.gid().is_some() || cfg.uid().is_some() {\n             return Err(IoError {"}, {"sha": "bdf2e0bccb1a07695e27b6ccb86d601854a20d96", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -14,7 +14,7 @@ use ptr;\n use mem;\n use libc;\n use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n-use sys_common::stack;\n+use sys_common::{stack, thread_info};\n \n pub struct Handler {\n     _data: *mut libc::c_void\n@@ -30,6 +30,14 @@ impl Drop for Handler {\n     fn drop(&mut self) {}\n }\n \n+// get_task_info is called from an exception / signal handler.\n+// It returns the guard page of the current task or 0 if that\n+// guard page doesn't exist. None is returned if there's currently\n+// no local task.\n+unsafe fn get_task_guard_page() -> uint {\n+    thread_info::stack_guard()\n+}\n+\n // This is initialized in init() and only read from after\n static mut PAGE_SIZE: uint = 0;\n "}, {"sha": "513c1d38e363492bf5b4111675fafe2453780637", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -14,10 +14,11 @@ use libc;\n use mem;\n use ptr;\n use prelude::*;\n-use super::{last_error, last_net_error, sock_t};\n+use super::{last_error, last_net_error, retry, sock_t};\n use sync::{Arc, atomic};\n+use sys::fs::FileDesc;\n use sys::{mod, c, set_nonblocking, wouldblock, timer};\n-use sys_common::{timeout, eof, net};\n+use sys_common::{mod, timeout, eof, net};\n \n pub use sys_common::net::TcpStream;\n \n@@ -204,6 +205,10 @@ impl TcpAcceptor {\n         Err(eof())\n     }\n \n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        net::sockname(self.socket(), libc::getsockname)\n+    }\n+\n     pub fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }"}, {"sha": "4498f56c00a1e4adcefdc3e1b21885e1bc4587dd", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::prelude::*;\n+\n use boxed::Box;\n use cmp;\n use mem;"}, {"sha": "60b0d584db3a7a6936fa8c1f160c19109739d331", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -137,29 +137,23 @@ unsafe fn init_dtors() {\n     rt::at_exit(move|| {\n         DTOR_LOCK.lock();\n         let dtors = DTORS;\n-        DTORS = 1 as *mut _;\n+        DTORS = 0 as *mut _;\n         mem::transmute::<_, Box<Vec<(Key, Dtor)>>>(dtors);\n-        assert!(DTORS as uint == 1); // can't re-init after destructing\n+        assert!(DTORS.is_null()); // can't re-init after destructing\n         DTOR_LOCK.unlock();\n     });\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n     DTOR_LOCK.lock();\n     init_dtors();\n-    assert!(DTORS as uint != 0);\n-    assert!(DTORS as uint != 1,\n-            \"cannot create new TLS keys after the main thread has exited\");\n     (*DTORS).push((key, dtor));\n     DTOR_LOCK.unlock();\n }\n \n unsafe fn unregister_dtor(key: Key) -> bool {\n     DTOR_LOCK.lock();\n     init_dtors();\n-    assert!(DTORS as uint != 0);\n-    assert!(DTORS as uint != 1,\n-            \"cannot unregister destructors after the main thread has exited\");\n     let ret = {\n         let dtors = &mut *DTORS;\n         let before = dtors.len();\n@@ -238,7 +232,6 @@ unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n     }\n }\n \n-#[allow(dead_code)] // not actually dead\n unsafe fn run_dtors() {\n     let mut any_run = true;\n     for _ in range(0, 5i) {"}, {"sha": "874838950cd12bfcd59f0751d74d64b40de9cbfc", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -26,6 +26,8 @@ use libc;\n use ptr;\n use comm;\n \n+use sys::c;\n+use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n use prelude::*;\n use io::IoResult;\n@@ -78,10 +80,9 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n                             None => {}\n                         }\n                     }\n-                    // See the comment in unix::timer for why we don't have any\n-                    // asserts here and why we're likely just leaving timers on\n-                    // the floor as we exit.\n                     Err(comm::Disconnected) => {\n+                        assert_eq!(objs.len(), 1);\n+                        assert_eq!(chans.len(), 0);\n                         break 'outer;\n                     }\n                     Err(..) => break"}, {"sha": "a88d11eed22bd254645039b56629578c12489620", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -26,6 +26,7 @@\n //! to working in raw UTF-16, with such a wrapper around it.\n \n use super::c::{ReadConsoleW, WriteConsoleW, GetConsoleMode, SetConsoleMode};\n+use super::c::{ERROR_ILLEGAL_CHARACTER};\n use super::c::{ENABLE_ECHO_INPUT, ENABLE_EXTENDED_FLAGS};\n use super::c::{ENABLE_INSERT_MODE, ENABLE_LINE_INPUT};\n use super::c::{ENABLE_PROCESSED_INPUT, ENABLE_QUICK_EDIT_MODE};\n@@ -38,8 +39,6 @@ use prelude::*;\n use ptr;\n use str::from_utf8;\n \n-use sys_common::unimpl;\n-\n fn invalid_encoding() -> IoError {\n     IoError {\n         kind: io::InvalidInput,\n@@ -151,8 +150,11 @@ impl TTY {\n         // Make a CONSOLE_SCREEN_BUFFER_INFO\n         // Call GetConsoleScreenBufferInfo\n         // Maybe call GetLargestConsoleWindowSize instead?\n-        Err(unimpl())\n+        Err(super::unimpl())\n     }\n+\n+    // Let us magically declare this as a TTY\n+    pub fn isatty(&self) -> bool { true }\n }\n \n impl Drop for TTY {"}, {"sha": "a7b3ee996a34dc428bf77bb827feceb2ba5742ef", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=aec67c2ee0f673ea7b0e21c2fe7e0f26a523d823", "patch": "@@ -232,10 +232,13 @@ impl Builder {\n             let my_stack_top = addr as uint;\n             let my_stack_bottom = my_stack_top - stack_size + 1024;\n             unsafe {\n-                stack::record_os_managed_stack_bounds(my_stack_bottom,\n-                                                      my_stack_top);\n-                thread_info::set(imp::guard::current(), their_thread);\n+                stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n             }\n+            thread_info::set(\n+                (my_stack_bottom, my_stack_top),\n+                unsafe { imp::guard::current() },\n+                their_thread\n+            );\n \n             let mut output = None;\n             let f: Thunk<(), T> = if stdout.is_some() || stderr.is_some() {"}]}