{"sha": "04ae50179a802d1d18bb780baa85f55864f56616", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YWU1MDE3OWE4MDJkMWQxOGJiNzgwYmFhODVmNTU4NjRmNTY2MTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-17T14:01:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-17T14:01:48Z"}, "message": "Auto merge of #83090 - jackh726:bound_var_replacer_option, r=varkor\n\nMake functions passed to BoundVarReplacer be optional\n\nThis means we can reuse the bound vars when we don't care to change them", "tree": {"sha": "badd9570cd535b953562ea01d3b2100870a63cdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/badd9570cd535b953562ea01d3b2100870a63cdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04ae50179a802d1d18bb780baa85f55864f56616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04ae50179a802d1d18bb780baa85f55864f56616", "html_url": "https://github.com/rust-lang/rust/commit/04ae50179a802d1d18bb780baa85f55864f56616", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04ae50179a802d1d18bb780baa85f55864f56616/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ce0fedb67fa66d50aa819ef8b12f1d89eb22d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ce0fedb67fa66d50aa819ef8b12f1d89eb22d7d", "html_url": "https://github.com/rust-lang/rust/commit/0ce0fedb67fa66d50aa819ef8b12f1d89eb22d7d"}, {"sha": "ba27cae728dcbf4ccf5f859ad499cec8d2133530", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba27cae728dcbf4ccf5f859ad499cec8d2133530", "html_url": "https://github.com/rust-lang/rust/commit/ba27cae728dcbf4ccf5f859ad499cec8d2133530"}], "stats": {"total": 108, "additions": 53, "deletions": 55}, "files": [{"sha": "a6a1d1f73bb62d6dfebbb926bce2465b8346e2a2", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/04ae50179a802d1d18bb780baa85f55864f56616/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04ae50179a802d1d18bb780baa85f55864f56616/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=04ae50179a802d1d18bb780baa85f55864f56616", "patch": "@@ -439,18 +439,18 @@ struct BoundVarReplacer<'a, 'tcx> {\n     /// the ones we have visited.\n     current_index: ty::DebruijnIndex,\n \n-    fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n-    fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),\n-    fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx> + 'a),\n+    fld_r: Option<&'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a)>,\n+    fld_t: Option<&'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a)>,\n+    fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx> + 'a)>,\n }\n \n impl<'a, 'tcx> BoundVarReplacer<'a, 'tcx> {\n-    fn new<F, G, H>(tcx: TyCtxt<'tcx>, fld_r: &'a mut F, fld_t: &'a mut G, fld_c: &'a mut H) -> Self\n-    where\n-        F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-        G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-        H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n-    {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        fld_r: Option<&'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a)>,\n+        fld_t: Option<&'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a)>,\n+        fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx> + 'a)>,\n+    ) -> Self {\n         BoundVarReplacer { tcx, current_index: ty::INNERMOST, fld_r, fld_t, fld_c }\n     }\n }\n@@ -469,63 +469,58 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n-            ty::Bound(debruijn, bound_ty) => {\n-                if debruijn == self.current_index {\n-                    let fld_t = &mut self.fld_t;\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n+                if let Some(fld_t) = self.fld_t.as_mut() {\n                     let ty = fld_t(bound_ty);\n-                    ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32())\n-                } else {\n-                    t\n+                    return ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32());\n                 }\n             }\n-            _ => {\n-                if !t.has_vars_bound_at_or_above(self.current_index) {\n-                    // Nothing more to substitute.\n-                    t\n-                } else {\n-                    t.super_fold_with(self)\n-                }\n+            _ if t.has_vars_bound_at_or_above(self.current_index) => {\n+                return t.super_fold_with(self);\n             }\n+            _ => {}\n         }\n+        t\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n-                let fld_r = &mut self.fld_r;\n-                let region = fld_r(br);\n-                if let ty::ReLateBound(debruijn1, br) = *region {\n-                    // If the callback returns a late-bound region,\n-                    // that region should always use the INNERMOST\n-                    // debruijn index. Then we adjust it to the\n-                    // correct depth.\n-                    assert_eq!(debruijn1, ty::INNERMOST);\n-                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n-                } else {\n-                    region\n+                if let Some(fld_r) = self.fld_r.as_mut() {\n+                    let region = fld_r(br);\n+                    return if let ty::ReLateBound(debruijn1, br) = *region {\n+                        // If the callback returns a late-bound region,\n+                        // that region should always use the INNERMOST\n+                        // debruijn index. Then we adjust it to the\n+                        // correct depth.\n+                        assert_eq!(debruijn1, ty::INNERMOST);\n+                        self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n+                    } else {\n+                        region\n+                    };\n                 }\n             }\n-            _ => r,\n+            _ => {}\n         }\n+        r\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty } = *ct {\n-            if debruijn == self.current_index {\n-                let fld_c = &mut self.fld_c;\n-                let ct = fld_c(bound_const, ty);\n-                ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32())\n-            } else {\n-                ct\n+        match *ct {\n+            ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n+                if debruijn == self.current_index =>\n+            {\n+                if let Some(fld_c) = self.fld_c.as_mut() {\n+                    let ct = fld_c(bound_const, ty);\n+                    return ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32());\n+                }\n             }\n-        } else {\n-            if !ct.has_vars_bound_at_or_above(self.current_index) {\n-                // Nothing more to substitute.\n-                ct\n-            } else {\n-                ct.super_fold_with(self)\n+            _ if ct.has_vars_bound_at_or_above(self.current_index) => {\n+                return ct.super_fold_with(self);\n             }\n+            _ => {}\n         }\n+        ct\n     }\n }\n \n@@ -550,14 +545,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n-        // identity for bound types and consts\n-        let fld_t = |bound_ty| self.mk_ty(ty::Bound(ty::INNERMOST, bound_ty));\n-        let fld_c = |bound_ct, ty| {\n-            self.mk_const(ty::Const { val: ty::ConstKind::Bound(ty::INNERMOST, bound_ct), ty })\n-        };\n         let mut region_map = BTreeMap::new();\n-        let real_fld_r = |br: ty::BoundRegion| *region_map.entry(br).or_insert_with(|| fld_r(br));\n-        let value = self.replace_escaping_bound_vars(value.skip_binder(), real_fld_r, fld_t, fld_c);\n+        let mut real_fld_r =\n+            |br: ty::BoundRegion| *region_map.entry(br).or_insert_with(|| fld_r(br));\n+        let value = value.skip_binder();\n+        let value = if !value.has_escaping_bound_vars() {\n+            value\n+        } else {\n+            let mut replacer = BoundVarReplacer::new(self, Some(&mut real_fld_r), None, None);\n+            value.fold_with(&mut replacer)\n+        };\n         (value, region_map)\n     }\n \n@@ -580,7 +577,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !value.has_escaping_bound_vars() {\n             value\n         } else {\n-            let mut replacer = BoundVarReplacer::new(self, &mut fld_r, &mut fld_t, &mut fld_c);\n+            let mut replacer =\n+                BoundVarReplacer::new(self, Some(&mut fld_r), Some(&mut fld_t), Some(&mut fld_c));\n             value.fold_with(&mut replacer)\n         }\n     }"}]}