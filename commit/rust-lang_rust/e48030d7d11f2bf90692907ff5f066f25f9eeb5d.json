{"sha": "e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ODAzMGQ3ZDExZjJiZjkwNjkyOTA3ZmY1ZjA2NmYyNWY5ZWViNWQ=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2015-12-01T11:54:43Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2015-12-01T20:21:45Z"}, "message": "Replace uses of int/uint with isize/uzsize in doc examples", "tree": {"sha": "1745962f2b18f481b92d0cb9601987fcea8a37fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1745962f2b18f481b92d0cb9601987fcea8a37fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "html_url": "https://github.com/rust-lang/rust/commit/e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7269f0e9f35bffdffe75e21f9ea141f261c08bf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7269f0e9f35bffdffe75e21f9ea141f261c08bf5", "html_url": "https://github.com/rust-lang/rust/commit/7269f0e9f35bffdffe75e21f9ea141f261c08bf5"}], "stats": {"total": 42, "additions": 22, "deletions": 20}, "files": [{"sha": "df620d4a04e7fd7aaf5544abf44c2389d92ee042", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "patch": "@@ -159,8 +159,8 @@ pub enum RegionResolutionError<'tcx> {\n /// like to indicate so to the user.\n /// For example, the following function\n /// ```\n-/// struct Foo { bar: int }\n-/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b int {\n+/// struct Foo { bar: isize }\n+/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b isize {\n ///    &x.bar\n /// }\n /// ```"}, {"sha": "14c2e1f5aacbf7da0a5b04d7f78fedde0447c40f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "patch": "@@ -1583,7 +1583,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let r = self.should_warn(var);\n             if let Some(name) = r {\n \n-                // annoying: for parameters in funcs like `fn(x: int)\n+                // annoying: for parameters in funcs like `fn(x: isize)\n                 // {ret}`, there is only one node, so asking about\n                 // assigned_on_exit() is not meaningful.\n                 let is_assigned = if ln == self.s.exit_ln {"}, {"sha": "b460c0ec4d0c474a3893351aa03f8eb42271e0d6", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "patch": "@@ -718,8 +718,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     ///\n     /// For example:\n     ///\n-    /// ```\n-    /// let a: int;\n+    /// ```ignore\n+    /// let a: isize;\n     /// a = 10; // ok, even though a is uninitialized\n     ///\n     /// struct Point { x: usize, y: usize }"}, {"sha": "f3addf381e0d0c05f52414061e08a76ea4e1bf25", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "patch": "@@ -486,7 +486,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! come about when variables of `&mut` type are re-borrowed,\n         //! as in this example:\n         //!\n-        //!     fn counter<'a>(v: &'a mut Foo) -> &'a mut uint {\n+        //!     struct Foo { counter: usize }\n+        //!\n+        //!     fn counter<'a>(v: &'a mut Foo) -> &'a mut usize {\n         //!         &mut v.counter\n         //!     }\n         //!"}, {"sha": "c7d9e3de5a19fa112d91fe87133067e7e673b71b", "filename": "src/librustc_trans/trans/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs?ref=e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "patch": "@@ -66,7 +66,7 @@\n //!\n //! ```\n //! struct List {\n-//!     value: int,\n+//!     value: isize,\n //!     tail: Option<Box<List>>,\n //! }\n //! ```"}, {"sha": "795a56b2dcf4773bcf5d4660752ea28b02daa31b", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "patch": "@@ -456,7 +456,7 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Generate a shim function that allows an object type like `SomeTrait` to\n /// implement the type `SomeTrait`. Imagine a trait definition:\n ///\n-///    trait SomeTrait { fn get(&self) -> int; ... }\n+///    trait SomeTrait { fn get(&self) -> isize; ... }\n ///\n /// And a generic bit of code:\n ///\n@@ -468,7 +468,7 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// What is the value of `x` when `foo` is invoked with `T=SomeTrait`?\n /// The answer is that it is a shim function generated by this routine:\n ///\n-///    fn shim(t: &SomeTrait) -> int {\n+///    fn shim(t: &SomeTrait) -> isize {\n ///        // ... call t.get() virtually ...\n ///    }\n ///"}, {"sha": "4f897d91b078e6c732fa4f0c2540293181f8caf8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "patch": "@@ -59,7 +59,7 @@\n //! There are a number of troublesome scenarios in the tests\n //! `region-dependent-*.rs`, but here is one example:\n //!\n-//!     struct Foo { i: int }\n+//!     struct Foo { i: isize }\n //!     struct Bar { foo: Foo  }\n //!     fn get_i(x: &'a Bar) -> &'a int {\n //!        let foo = &x.foo; // Lifetime L1\n@@ -233,8 +233,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Consider this silly example:\n     ///\n     /// ```\n-    /// fn borrow(x: &int) -> &int {x}\n-    /// fn foo(x: @int) -> int {  // block: B\n+    /// fn borrow(x: &int) -> &isize {x}\n+    /// fn foo(x: @int) -> isize {  // block: B\n     ///     let b = borrow(x);    // region: <R0>\n     ///     *b\n     /// }\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Here, the region of `b` will be `<R0>`.  `<R0>` is constrained to be some subregion of the\n     /// block B and some superregion of the call.  If we forced it now, we'd choose the smaller\n     /// region (the call).  But that would make the *b illegal.  Since we don't resolve, the type\n-    /// of b will be `&<R0>.int` and then `*b` will require that `<R0>` be bigger than the let and\n+    /// of b will be `&<R0>.isize` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.fcx.infcx().resolve_type_vars_if_possible(&unresolved_ty)"}, {"sha": "910f3b713cf86fff32a12393c4845833cad6d7f4", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48030d7d11f2bf90692907ff5f066f25f9eeb5d/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=e48030d7d11f2bf90692907ff5f066f25f9eeb5d", "patch": "@@ -172,14 +172,14 @@\n //!\n //! Now imagine that I have an implementation of `ConvertTo` for `Object`:\n //!\n-//!     impl ConvertTo<int> for Object { ... }\n+//!     impl ConvertTo<isize> for Object { ... }\n //!\n //! And I want to call `convertAll` on an array of strings. Suppose\n //! further that for whatever reason I specifically supply the value of\n //! `String` for the type parameter `T`:\n //!\n //!     let mut vector = vec![\"string\", ...];\n-//!     convertAll::<int, String>(vector);\n+//!     convertAll::<isize, String>(vector);\n //!\n //! Is this legal? To put another way, can we apply the `impl` for\n //! `Object` to the type `String`? The answer is yes, but to see why\n@@ -190,25 +190,25 @@\n //! - It will then call the impl of `convertTo()` that is intended\n //!   for use with objects. This has the type:\n //!\n-//!       fn(self: &Object) -> int\n+//!       fn(self: &Object) -> isize\n //!\n //!   It is ok to provide a value for `self` of type `&String` because\n //!   `&String <: &Object`.\n //!\n //! OK, so intuitively we want this to be legal, so let's bring this back\n //! to variance and see whether we are computing the correct result. We\n //! must first figure out how to phrase the question \"is an impl for\n-//! `Object,int` usable where an impl for `String,int` is expected?\"\n+//! `Object,isize` usable where an impl for `String,isize` is expected?\"\n //!\n //! Maybe it's helpful to think of a dictionary-passing implementation of\n //! type classes. In that case, `convertAll()` takes an implicit parameter\n //! representing the impl. In short, we *have* an impl of type:\n //!\n-//!     V_O = ConvertTo<int> for Object\n+//!     V_O = ConvertTo<isize> for Object\n //!\n //! and the function prototype expects an impl of type:\n //!\n-//!     V_S = ConvertTo<int> for String\n+//!     V_S = ConvertTo<isize> for String\n //!\n //! As with any argument, this is legal if the type of the value given\n //! (`V_O`) is a subtype of the type expected (`V_S`). So is `V_O <: V_S`?\n@@ -217,7 +217,7 @@\n //! covariant, it means that:\n //!\n //!     V_O <: V_S iff\n-//!         int <: int\n+//!         isize <: isize\n //!         String <: Object\n //!\n //! These conditions are satisfied and so we are happy."}]}