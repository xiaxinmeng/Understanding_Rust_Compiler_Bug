{"sha": "1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlOWU4MGZkOTFlZjZjNWIzYjE2OTg1NjgyYzEwYmMxY2ExMGU1MTc=", "commit": {"author": {"name": "Josh Stone", "email": "cuviper@gmail.com", "date": "2019-03-28T01:15:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-28T01:15:38Z"}, "message": "Rollup merge of #59439 - Centril:generalize-assign-to-bool-diagnostic, r=oli-obk\n\nGeneralize diagnostic for `x = y` where `bool` is the expected type\n\nExtracted out of https://github.com/rust-lang/rust/pull/59288.\n\nCurrently we special case a diagnostic for `if x = y { ...` since the expected type is `bool` in this case and we instead suggest `if x == y`. This PR generalizes this such that given an expression of form `x = y` (`ExprKind::Assign(..)`) where the expected type is `bool`, we emit a suggestion `x == y`.\n\nr? @oli-obk\n\nLet's do a perf run to make sure this was not the source of regressions in #59288.", "tree": {"sha": "b5f3a8fbed5f16e13e8f76c1abb73ad2c231d07a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5f3a8fbed5f16e13e8f76c1abb73ad2c231d07a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcnCA6CRBK7hj4Ov3rIwAAdHIIADhN2PMT4ccmDdaBoZodY4lG\n1uitxt8tnmnsULGjY3lHBygWWBVMHmesWalL1RDXn4ciOK2mUhyhpmT8PNUTi1hs\ncBUk88LBamSY2QXcbzFECoagUUGPQlmaaPg+DY4diJJbA3NzHbDPl8ah1ehkY5d+\nK3EMMGtb3aTiJjEax0YYK9j9siG3Da4dMY8D969dXOCf/dxr0Fa09U/wKgygkl5C\nxtp5N9/DApR101TAvCdGFTwECPCn+h2pbibxn2oX2yBMoFd1Iuz997BjCYWvjJEb\n/9hEqZJRqjtWGbKGP3mJrkMkWkYTPmkr+lAGlzmYwiDQE8WIFeblpd7IiOg9Jzo=\n=7+ZX\n-----END PGP SIGNATURE-----\n", "payload": "tree b5f3a8fbed5f16e13e8f76c1abb73ad2c231d07a\nparent 99f6de759eea81773d3f97e37334e54f20457c06\nparent ce1c5e0a61ab05bd0a944e27c91e2001844516d9\nauthor Josh Stone <cuviper@gmail.com> 1553735738 -0700\ncommitter GitHub <noreply@github.com> 1553735738 -0700\n\nRollup merge of #59439 - Centril:generalize-assign-to-bool-diagnostic, r=oli-obk\n\nGeneralize diagnostic for `x = y` where `bool` is the expected type\n\nExtracted out of https://github.com/rust-lang/rust/pull/59288.\n\nCurrently we special case a diagnostic for `if x = y { ...` since the expected type is `bool` in this case and we instead suggest `if x == y`. This PR generalizes this such that given an expression of form `x = y` (`ExprKind::Assign(..)`) where the expected type is `bool`, we emit a suggestion `x == y`.\n\nr? @oli-obk\n\nLet's do a perf run to make sure this was not the source of regressions in #59288.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "html_url": "https://github.com/rust-lang/rust/commit/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99f6de759eea81773d3f97e37334e54f20457c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/99f6de759eea81773d3f97e37334e54f20457c06", "html_url": "https://github.com/rust-lang/rust/commit/99f6de759eea81773d3f97e37334e54f20457c06"}, {"sha": "ce1c5e0a61ab05bd0a944e27c91e2001844516d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce1c5e0a61ab05bd0a944e27c91e2001844516d9", "html_url": "https://github.com/rust-lang/rust/commit/ce1c5e0a61ab05bd0a944e27c91e2001844516d9"}], "stats": {"total": 413, "additions": 322, "deletions": 91}, "files": [{"sha": "ac8b639edbfa363556799a79a3579ee8c9d50605", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "patch": "@@ -1233,7 +1233,12 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     augment_error(&mut db);\n                 }\n \n-                db.emit();\n+                if expression.filter(|e| fcx.is_assign_to_bool(e, expected)).is_some() {\n+                    // Error reported in `check_assign` so avoid emitting error again.\n+                    db.delay_as_bug();\n+                } else {\n+                    db.emit();\n+                }\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }"}, {"sha": "60fa266f0bbe1350828f135aeffe57bea4702e05", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "patch": "@@ -119,44 +119,65 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n         let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n \n-        // If the expected type is an enum (Issue #55250) with any variants whose\n-        // sole field is of the found type, suggest such variants. (Issue #42764)\n-        if let ty::Adt(expected_adt, substs) = expected.sty {\n-            if expected_adt.is_enum() {\n-                let mut compatible_variants = expected_adt.variants\n-                    .iter()\n-                    .filter(|variant| variant.fields.len() == 1)\n-                    .filter_map(|variant| {\n-                        let sole_field = &variant.fields[0];\n-                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let variant_path = self.tcx.def_path_str(variant.def_id);\n-                            // FIXME #56861: DRYer prelude filtering\n-                            Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n-                        } else {\n-                            None\n-                        }\n-                    }).peekable();\n-\n-                if compatible_variants.peek().is_some() {\n-                    let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n-                    let suggestions = compatible_variants\n-                        .map(|v| format!(\"{}({})\", v, expr_text));\n-                    err.span_suggestions(\n-                        expr.span,\n-                        \"try using a variant of the expected type\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n+        if self.is_assign_to_bool(expr, expected) {\n+            // Error reported in `check_assign` so avoid emitting error again.\n+            err.delay_as_bug();\n+            return (expected, None)\n         }\n \n+        self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n \n         (expected, Some(err))\n     }\n \n+    /// Returns whether the expected type is `bool` and the expression is `x = y`.\n+    pub fn is_assign_to_bool(&self, expr: &hir::Expr, expected: Ty<'tcx>) -> bool {\n+        if let hir::ExprKind::Assign(..) = expr.node {\n+            return expected == self.tcx.types.bool;\n+        }\n+        false\n+    }\n+\n+    /// If the expected type is an enum (Issue #55250) with any variants whose\n+    /// sole field is of the found type, suggest such variants. (Issue #42764)\n+    fn suggest_compatible_variants(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        expr_ty: Ty<'tcx>,\n+    ) {\n+        if let ty::Adt(expected_adt, substs) = expected.sty {\n+            if !expected_adt.is_enum() {\n+                return;\n+            }\n+\n+            let mut compatible_variants = expected_adt.variants\n+                .iter()\n+                .filter(|variant| variant.fields.len() == 1)\n+                .filter_map(|variant| {\n+                    let sole_field = &variant.fields[0];\n+                    let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                    if self.can_coerce(expr_ty, sole_field_ty) {\n+                        let variant_path = self.tcx.def_path_str(variant.def_id);\n+                        // FIXME #56861: DRYer prelude filtering\n+                        Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n+                    } else {\n+                        None\n+                    }\n+                }).peekable();\n+\n+            if compatible_variants.peek().is_some() {\n+                let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n+                let suggestions = compatible_variants\n+                    .map(|v| format!(\"{}({})\", v, expr_text));\n+                let msg = \"try using a variant of the expected type\";\n+                err.span_suggestions(expr.span, msg, suggestions, Applicability::MaybeIncorrect);\n+            }\n+        }\n+    }\n+\n     pub fn get_conversion_methods(&self, span: Span, expected: Ty<'tcx>, checked_ty: Ty<'tcx>)\n                               -> Vec<AssociatedItem> {\n         let mut methods = self.probe_for_return_type(span,"}, {"sha": "3d904d518ca8e6c300fd12295a8eeb3beef14b83", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "patch": "@@ -246,9 +246,6 @@ pub enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n \n-    /// This expression is an `if` condition, it must resolve to `bool`.\n-    ExpectIfCondition,\n-\n     /// This expression should have the type given (or some subtype).\n     ExpectHasType(Ty<'tcx>),\n \n@@ -328,7 +325,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,\n-            ExpectIfCondition => ExpectIfCondition,\n             ExpectCastableToType(t) => {\n                 ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n             }\n@@ -344,7 +340,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn to_option(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n-            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             ExpectCastableToType(ty) |\n             ExpectHasType(ty) |\n             ExpectRvalueLikeUnsized(ty) => Some(ty),\n@@ -358,7 +353,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn only_has_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n-            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) => None,\n         }\n     }\n@@ -3148,25 +3142,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            // Add help to type error if this is an `if` condition with an assignment.\n-            if let (ExpectIfCondition, &ExprKind::Assign(ref lhs, ref rhs))\n-                 = (expected, &expr.node)\n-            {\n-                let msg = \"try comparing for equality\";\n-                if let (Ok(left), Ok(right)) = (\n-                    self.tcx.sess.source_map().span_to_snippet(lhs.span),\n-                    self.tcx.sess.source_map().span_to_snippet(rhs.span))\n-                {\n-                    err.span_suggestion(\n-                        expr.span,\n-                        msg,\n-                        format!(\"{} == {}\", left, right),\n-                        Applicability::MaybeIncorrect);\n-                } else {\n-                    err.help(msg);\n-                }\n+            if self.is_assign_to_bool(expr, expected_ty) {\n+                // Error reported in `check_assign` so avoid emitting error again.\n+                // FIXME(centril): Consider removing if/when `if` desugars to `match`.\n+                err.delay_as_bug();\n+            } else {\n+                err.emit();\n             }\n-            err.emit();\n         }\n         ty\n     }\n@@ -3337,7 +3319,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let cond_ty = self.check_expr_meets_expectation_or_error(cond_expr, ExpectIfCondition);\n+        let cond_ty = self.check_expr_has_type_or_error(cond_expr, self.tcx.types.bool);\n         let cond_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n@@ -4422,34 +4404,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.types.never\n             }\n             ExprKind::Assign(ref lhs, ref rhs) => {\n-                let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-\n-                let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n-\n-                match expected {\n-                    ExpectIfCondition => {\n-                        self.tcx.sess.delay_span_bug(lhs.span, \"invalid lhs expression in if;\\\n-                                                                expected error elsehwere\");\n-                    }\n-                    _ => {\n-                        // Only check this if not in an `if` condition, as the\n-                        // mistyped comparison help is more appropriate.\n-                        if !lhs.is_place_expr() {\n-                            struct_span_err!(self.tcx.sess, expr.span, E0070,\n-                                                \"invalid left-hand side expression\")\n-                                .span_label(expr.span, \"left-hand of expression not valid\")\n-                                .emit();\n-                        }\n-                    }\n-                }\n-\n-                self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n-\n-                if lhs_ty.references_error() || rhs_ty.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    tcx.mk_unit()\n-                }\n+                self.check_assign(expr, expected, lhs, rhs)\n             }\n             ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n@@ -4750,6 +4705,51 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Type check assignment expression `expr` of form `lhs = rhs`.\n+    /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n+    fn check_assign(\n+        &self,\n+        expr: &'gcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        lhs: &'gcx hir::Expr,\n+        rhs: &'gcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n+        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+\n+        let expected_ty = expected.coercion_target_type(self, expr.span);\n+        if expected_ty == self.tcx.types.bool {\n+            // The expected type is `bool` but this will result in `()` so we can reasonably\n+            // say that the user intended to write `lhs == rhs` instead of `lhs = rhs`.\n+            // The likely cause of this is `if foo = bar { .. }`.\n+            let actual_ty = self.tcx.mk_unit();\n+            let mut err = self.demand_suptype_diag(expr.span, expected_ty, actual_ty).unwrap();\n+            let msg = \"try comparing for equality\";\n+            let left = self.tcx.sess.source_map().span_to_snippet(lhs.span);\n+            let right = self.tcx.sess.source_map().span_to_snippet(rhs.span);\n+            if let (Ok(left), Ok(right)) = (left, right) {\n+                let help = format!(\"{} == {}\", left, right);\n+                err.span_suggestion(expr.span, msg, help, Applicability::MaybeIncorrect);\n+            } else {\n+                err.help(msg);\n+            }\n+            err.emit();\n+        } else if !lhs.is_place_expr() {\n+            struct_span_err!(self.tcx.sess, expr.span, E0070,\n+                                \"invalid left-hand side expression\")\n+                .span_label(expr.span, \"left-hand of expression not valid\")\n+                .emit();\n+        }\n+\n+        self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n+\n+        if lhs_ty.references_error() || rhs_ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            self.tcx.mk_unit()\n+        }\n+    }\n+\n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,"}, {"sha": "03830fea062cf7d660f63c0da91af450a45d703b", "filename": "src/test/ui/type/type-check/assignment-expected-bool.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs?ref=1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "patch": "@@ -0,0 +1,34 @@\n+// The purpose of this text is to ensure that we get good\n+// diagnostics when a `bool` is expected but that due to\n+// an assignment expression `x = y` the type is `()`.\n+\n+fn main() {\n+    let _: bool = 0 = 0; //~ ERROR mismatched types [E0308]\n+\n+    let _: bool = match 0 {\n+        0 => 0 = 0, //~ ERROR mismatched types [E0308]\n+        _ => 0 = 0, //~ ERROR mismatched types [E0308]\n+    };\n+\n+    let _: bool = match true {\n+        true => 0 = 0, //~ ERROR mismatched types [E0308]\n+        _ => (),\n+    };\n+\n+    if 0 = 0 {} //~ ERROR mismatched types [E0308]\n+\n+    let _: bool = if { 0 = 0 } { //~ ERROR mismatched types [E0308]\n+        0 = 0 //~ ERROR mismatched types [E0308]\n+    } else {\n+        0 = 0 //~ ERROR mismatched types [E0308]\n+    };\n+\n+    let _ = (0 = 0) //~ ERROR mismatched types [E0308]\n+        && { 0 = 0 } //~ ERROR mismatched types [E0308]\n+        || (0 = 0); //~ ERROR mismatched types [E0308]\n+\n+    // A test to check that not expecting `bool` behaves well:\n+    let _: usize = 0 = 0;\n+    //~^ ERROR mismatched types [E0308]\n+    //~| ERROR invalid left-hand side expression [E0070]\n+}"}, {"sha": "fed8b913465827c3547b116a6603700163b45988", "filename": "src/test/ui/type/type-check/assignment-expected-bool.stderr", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr?ref=1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "patch": "@@ -0,0 +1,151 @@\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:6:19\n+   |\n+LL |     let _: bool = 0 = 0;\n+   |                   ^^^^^\n+   |                   |\n+   |                   expected bool, found ()\n+   |                   help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:9:14\n+   |\n+LL |         0 => 0 = 0,\n+   |              ^^^^^\n+   |              |\n+   |              expected bool, found ()\n+   |              help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:10:14\n+   |\n+LL |         _ => 0 = 0,\n+   |              ^^^^^\n+   |              |\n+   |              expected bool, found ()\n+   |              help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:14:17\n+   |\n+LL |         true => 0 = 0,\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected bool, found ()\n+   |                 help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:18:8\n+   |\n+LL |     if 0 = 0 {}\n+   |        ^^^^^\n+   |        |\n+   |        expected bool, found ()\n+   |        help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:20:24\n+   |\n+LL |     let _: bool = if { 0 = 0 } {\n+   |                        ^^^^^\n+   |                        |\n+   |                        expected bool, found ()\n+   |                        help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:21:9\n+   |\n+LL |         0 = 0\n+   |         ^^^^^\n+   |         |\n+   |         expected bool, found ()\n+   |         help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:23:9\n+   |\n+LL |         0 = 0\n+   |         ^^^^^\n+   |         |\n+   |         expected bool, found ()\n+   |         help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:26:13\n+   |\n+LL |     let _ = (0 = 0)\n+   |             ^^^^^^^\n+   |             |\n+   |             expected bool, found ()\n+   |             help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:27:14\n+   |\n+LL |         && { 0 = 0 }\n+   |              ^^^^^\n+   |              |\n+   |              expected bool, found ()\n+   |              help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:28:12\n+   |\n+LL |         || (0 = 0);\n+   |            ^^^^^^^\n+   |            |\n+   |            expected bool, found ()\n+   |            help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0070]: invalid left-hand side expression\n+  --> $DIR/assignment-expected-bool.rs:31:20\n+   |\n+LL |     let _: usize = 0 = 0;\n+   |                    ^^^^^ left-hand of expression not valid\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:31:20\n+   |\n+LL |     let _: usize = 0 = 0;\n+   |                    ^^^^^ expected usize, found ()\n+   |\n+   = note: expected type `usize`\n+              found type `()`\n+\n+error: aborting due to 13 previous errors\n+\n+Some errors occurred: E0070, E0308.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "77b122b0a794a779c22dad1ebd69379973c86833", "filename": "src/test/ui/type/type-check/assignment-in-if.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs?ref=1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "patch": "@@ -31,8 +31,13 @@ fn main() {\n         //~^ ERROR mismatched types\n         println!(\"{}\", x);\n     }\n-    if (if true { x = 4 } else { x = 5 }) {\n-        //~^ ERROR mismatched types\n+    if (\n+        if true {\n+            x = 4 //~ ERROR mismatched types\n+        } else {\n+            x = 5 //~ ERROR mismatched types\n+        }\n+    ) {\n         println!(\"{}\", x);\n     }\n }"}, {"sha": "87b8d17c21bcca0a8a3fc9fb631d630f9e6fa42d", "filename": "src/test/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e9e80fd91ef6c5b3b16985682c10bc1ca10e517/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=1e9e80fd91ef6c5b3b16985682c10bc1ca10e517", "patch": "@@ -47,14 +47,29 @@ LL |     if 3 = x {\n               found type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/assignment-in-if.rs:34:8\n+  --> $DIR/assignment-in-if.rs:36:13\n    |\n-LL |     if (if true { x = 4 } else { x = 5 }) {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found ()\n+LL |             x = 4\n+   |             ^^^^^\n+   |             |\n+   |             expected bool, found ()\n+   |             help: try comparing for equality: `x == 4`\n    |\n    = note: expected type `bool`\n               found type `()`\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-in-if.rs:38:13\n+   |\n+LL |             x = 5\n+   |             ^^^^^\n+   |             |\n+   |             expected bool, found ()\n+   |             help: try comparing for equality: `x == 5`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}