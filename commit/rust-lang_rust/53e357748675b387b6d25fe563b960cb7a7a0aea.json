{"sha": "53e357748675b387b6d25fe563b960cb7a7a0aea", "node_id": "C_kwDOAAsO6NoAKDUzZTM1Nzc0ODY3NWIzODdiNmQyNWZlNTYzYjk2MGNiN2E3YTBhZWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-20T22:03:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-20T22:03:17Z"}, "message": "Auto merge of #2601 - DrMeepster:windows_init_once, r=RalfJung\n\nAdd Windows InitOnceBeginInitialize and InitOnceComplete shims\n\nFixes #2595", "tree": {"sha": "dd1fa6ba6127641afe7986a9c5daa98de3509fed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd1fa6ba6127641afe7986a9c5daa98de3509fed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53e357748675b387b6d25fe563b960cb7a7a0aea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53e357748675b387b6d25fe563b960cb7a7a0aea", "html_url": "https://github.com/rust-lang/rust/commit/53e357748675b387b6d25fe563b960cb7a7a0aea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53e357748675b387b6d25fe563b960cb7a7a0aea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dcf51b08f4e066a7a5dc766edd3ddba09c7adab", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dcf51b08f4e066a7a5dc766edd3ddba09c7adab", "html_url": "https://github.com/rust-lang/rust/commit/4dcf51b08f4e066a7a5dc766edd3ddba09c7adab"}, {"sha": "a39629b88f6c1f2044326d94aced180a4015541c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39629b88f6c1f2044326d94aced180a4015541c", "html_url": "https://github.com/rust-lang/rust/commit/a39629b88f6c1f2044326d94aced180a4015541c"}], "stats": {"total": 810, "additions": 616, "deletions": 194}, "files": [{"sha": "0a3daa2d086413e0c6ab6565a020a5ecf8b3a38d", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -1 +1 @@\n-538f118da1409759ba198acc0ff62070bc6d2dce\n+edabf59ca4646b3fc1a961c26431215001043f6a"}, {"sha": "791931901e2a96765ba3ca11f8cce9cf33cfe03e", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -0,0 +1,204 @@\n+use std::collections::VecDeque;\n+use std::num::NonZeroU32;\n+\n+use rustc_index::vec::Idx;\n+\n+use super::sync::EvalContextExtPriv;\n+use super::thread::MachineCallback;\n+use super::vector_clock::VClock;\n+use crate::*;\n+\n+declare_id!(InitOnceId);\n+\n+/// A thread waiting on an InitOnce object.\n+struct InitOnceWaiter<'mir, 'tcx> {\n+    /// The thread that is waiting.\n+    thread: ThreadId,\n+    /// The callback that should be executed, after the thread has been woken up.\n+    callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n+}\n+\n+impl<'mir, 'tcx> std::fmt::Debug for InitOnceWaiter<'mir, 'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"InitOnce\")\n+            .field(\"thread\", &self.thread)\n+            .field(\"callback\", &\"dyn MachineCallback\")\n+            .finish()\n+    }\n+}\n+\n+#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\n+/// The current status of a one time initialization.\n+pub enum InitOnceStatus {\n+    #[default]\n+    Uninitialized,\n+    Begun,\n+    Complete,\n+}\n+\n+/// The one time initialization state.\n+#[derive(Default, Debug)]\n+pub(super) struct InitOnce<'mir, 'tcx> {\n+    status: InitOnceStatus,\n+    waiters: VecDeque<InitOnceWaiter<'mir, 'tcx>>,\n+    data_race: VClock,\n+}\n+\n+impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for waiter in self.waiters.iter() {\n+            waiter.callback.visit_tags(visit);\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn init_once_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, InitOnceId> {\n+        let this = self.eval_context_mut();\n+        this.init_once_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n+    }\n+\n+    /// Provides the closure with the next InitOnceId. Creates that InitOnce if the closure returns None,\n+    /// otherwise returns the value from the closure.\n+    #[inline]\n+    fn init_once_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, InitOnceId>\n+    where\n+        F: FnOnce(\n+            &mut MiriInterpCx<'mir, 'tcx>,\n+            InitOnceId,\n+        ) -> InterpResult<'tcx, Option<InitOnceId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.init_onces.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.init_onces.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n+    #[inline]\n+    fn init_once_status(&mut self, id: InitOnceId) -> InitOnceStatus {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.init_onces[id].status\n+    }\n+\n+    /// Put the thread into the queue waiting for the initialization.\n+    #[inline]\n+    fn init_once_enqueue_and_block(\n+        &mut self,\n+        id: InitOnceId,\n+        thread: ThreadId,\n+        callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n+    ) {\n+        let this = self.eval_context_mut();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_ne!(init_once.status, InitOnceStatus::Complete, \"queueing on complete init once\");\n+        init_once.waiters.push_back(InitOnceWaiter { thread, callback });\n+        this.block_thread(thread);\n+    }\n+\n+    /// Begin initializing this InitOnce. Must only be called after checking that it is currently\n+    /// uninitialized.\n+    #[inline]\n+    fn init_once_begin(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Uninitialized,\n+            \"begining already begun or complete init once\"\n+        );\n+        init_once.status = InitOnceStatus::Begun;\n+    }\n+\n+    #[inline]\n+    fn init_once_complete(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Begun,\n+            \"completing already complete or uninit init once\"\n+        );\n+\n+        init_once.status = InitOnceStatus::Complete;\n+\n+        // Each complete happens-before the end of the wait\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+        }\n+\n+        // Wake up everyone.\n+        // need to take the queue to avoid having `this` be borrowed multiple times\n+        for waiter in std::mem::take(&mut init_once.waiters) {\n+            // End of the wait happens-before woken-up thread.\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_acquire(\n+                    &this.machine.threads.sync.init_onces[id].data_race,\n+                    waiter.thread,\n+                );\n+            }\n+\n+            this.unblock_thread(waiter.thread);\n+\n+            // Call callback, with the woken-up thread as `current`.\n+            this.set_active_thread(waiter.thread);\n+            waiter.callback.call(this)?;\n+            this.set_active_thread(current_thread);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn init_once_fail(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Begun,\n+            \"failing already completed or uninit init once\"\n+        );\n+\n+        // Each complete happens-before the end of the wait\n+        // FIXME: should this really induce synchronization? If we think of it as a lock, then yes,\n+        // but the docs don't talk about such details.\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+        }\n+\n+        // Wake up one waiting thread, so they can go ahead and try to init this.\n+        if let Some(waiter) = init_once.waiters.pop_front() {\n+            // End of the wait happens-before woken-up thread.\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_acquire(\n+                    &this.machine.threads.sync.init_onces[id].data_race,\n+                    waiter.thread,\n+                );\n+            }\n+\n+            this.unblock_thread(waiter.thread);\n+\n+            // Call callback, with the woken-up thread as `current`.\n+            this.set_active_thread(waiter.thread);\n+            waiter.callback.call(this)?;\n+            this.set_active_thread(current_thread);\n+        } else {\n+            // Nobody there to take this, so go back to 'uninit'\n+            init_once.status = InitOnceStatus::Uninitialized;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "45903107f17104d86585317e4b803d3c9bbd1014", "filename": "src/tools/miri/src/concurrency/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fmod.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -1,6 +1,8 @@\n pub mod data_race;\n mod range_object_map;\n+#[macro_use]\n pub mod sync;\n+pub mod init_once;\n pub mod thread;\n mod vector_clock;\n pub mod weak_memory;"}, {"sha": "e76610e7302804c76478e49f9389df4473863ee7", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 88, "deletions": 31, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -7,9 +7,15 @@ use log::trace;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::{Idx, IndexVec};\n \n+use super::init_once::InitOnce;\n use super::vector_clock::VClock;\n use crate::*;\n \n+pub trait SyncId {\n+    fn from_u32(id: u32) -> Self;\n+    fn to_u32(&self) -> u32;\n+}\n+\n /// We cannot use the `newtype_index!` macro because we have to use 0 as a\n /// sentinel value meaning that the identifier is not assigned. This is because\n /// the pthreads static initializers initialize memory with zeros (see the\n@@ -21,11 +27,14 @@ macro_rules! declare_id {\n         #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n         pub struct $name(NonZeroU32);\n \n-        impl $name {\n+        impl SyncId for $name {\n             // Panics if `id == 0`.\n-            pub fn from_u32(id: u32) -> Self {\n+            fn from_u32(id: u32) -> Self {\n                 Self(NonZeroU32::new(id).unwrap())\n             }\n+            fn to_u32(&self) -> u32 {\n+                self.0.get()\n+            }\n         }\n \n         impl Idx for $name {\n@@ -151,16 +160,58 @@ struct FutexWaiter {\n \n /// The state of all synchronization variables.\n #[derive(Default, Debug)]\n-pub(crate) struct SynchronizationState {\n+pub(crate) struct SynchronizationState<'mir, 'tcx> {\n     mutexes: IndexVec<MutexId, Mutex>,\n     rwlocks: IndexVec<RwLockId, RwLock>,\n     condvars: IndexVec<CondvarId, Condvar>,\n     futexes: FxHashMap<u64, Futex>,\n+    pub(super) init_onces: IndexVec<InitOnceId, InitOnce<'mir, 'tcx>>,\n+}\n+\n+impl<'mir, 'tcx> VisitTags for SynchronizationState<'mir, 'tcx> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for init_once in self.init_onces.iter() {\n+            init_once.visit_tags(visit);\n+        }\n+    }\n }\n \n // Private extension trait for local helper methods\n impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+pub(super) trait EvalContextExtPriv<'mir, 'tcx: 'mir>:\n+    crate::MiriInterpCxExt<'mir, 'tcx>\n+{\n+    #[inline]\n+    // Miri sync structures contain zero-initialized ids stored at some offset behind a pointer\n+    fn get_or_create_id<Id: SyncId>(\n+        &mut self,\n+        next_id: Id,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, Option<Id>> {\n+        let this = self.eval_context_mut();\n+        let value_place =\n+            this.deref_operand_and_offset(lock_op, offset, this.machine.layouts.u32)?;\n+\n+        let (old, success) = this\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, this.machine.layouts.u32),\n+                Scalar::from_u32(next_id.to_u32()),\n+                AtomicRwOrd::Relaxed, // deliberately *no* synchronization\n+                AtomicReadOrd::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair();\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(Id::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    }\n+\n     /// Take a reader out of the queue waiting for the lock.\n     /// Returns `true` if some thread got the rwlock.\n     #[inline]\n@@ -210,11 +261,31 @@ trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n // situations.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    #[inline]\n-    /// Create state for a new mutex.\n-    fn mutex_create(&mut self) -> MutexId {\n+    fn mutex_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, MutexId> {\n+        let this = self.eval_context_mut();\n+        this.mutex_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n+    }\n+\n+    fn rwlock_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, RwLockId> {\n+        let this = self.eval_context_mut();\n+        this.rwlock_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n+    }\n+\n+    fn condvar_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, CondvarId> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.mutexes.push(Default::default())\n+        this.condvar_get_or_create(|ecx, next_id| ecx.get_or_create_id(next_id, lock_op, offset))\n     }\n \n     #[inline]\n@@ -301,25 +372,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Put the thread into the queue waiting for the mutex.\n+    #[inline]\n     fn mutex_enqueue_and_block(&mut self, id: MutexId, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.mutex_is_locked(id), \"queing on unlocked mutex\");\n         this.machine.threads.sync.mutexes[id].queue.push_back(thread);\n         this.block_thread(thread);\n     }\n \n-    #[inline]\n-    /// Create state for a new read write lock.\n-    fn rwlock_create(&mut self) -> RwLockId {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks.push(Default::default())\n-    }\n-\n-    #[inline]\n     /// Provides the closure with the next RwLockId. Creates that RwLock if the closure returns None,\n     /// otherwise returns the value from the closure\n+    #[inline]\n     fn rwlock_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, RwLockId>\n     where\n         F: FnOnce(&mut MiriInterpCx<'mir, 'tcx>, RwLockId) -> InterpResult<'tcx, Option<RwLockId>>,\n@@ -349,8 +413,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         rwlock.writer.is_some() || rwlock.readers.is_empty().not()\n     }\n \n-    #[inline]\n     /// Check if write locked.\n+    #[inline]\n     fn rwlock_is_write_locked(&self, id: RwLockId) -> bool {\n         let this = self.eval_context_ref();\n         let rwlock = &this.machine.threads.sync.rwlocks[id];\n@@ -407,17 +471,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         true\n     }\n \n-    #[inline]\n     /// Put the reader in the queue waiting for the lock and block it.\n+    #[inline]\n     fn rwlock_enqueue_and_block_reader(&mut self, id: RwLockId, reader: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_write_locked(id), \"read-queueing on not write locked rwlock\");\n         this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n         this.block_thread(reader);\n     }\n \n-    #[inline]\n     /// Lock by setting the writer that owns the lock.\n+    #[inline]\n     fn rwlock_writer_lock(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(!this.rwlock_is_locked(id), \"the rwlock is already locked\");\n@@ -429,8 +493,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Try to unlock by removing the writer.\n+    #[inline]\n     fn rwlock_writer_unlock(&mut self, id: RwLockId, expected_writer: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n@@ -467,25 +531,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Put the writer in the queue waiting for the lock.\n+    #[inline]\n     fn rwlock_enqueue_and_block_writer(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_locked(id), \"write-queueing on unlocked rwlock\");\n         this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n         this.block_thread(writer);\n     }\n \n-    #[inline]\n-    /// Create state for a new conditional variable.\n-    fn condvar_create(&mut self) -> CondvarId {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.condvars.push(Default::default())\n-    }\n-\n-    #[inline]\n     /// Provides the closure with the next CondvarId. Creates that Condvar if the closure returns None,\n     /// otherwise returns the value from the closure\n+    #[inline]\n     fn condvar_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, CondvarId>\n     where\n         F: FnOnce(\n@@ -504,8 +561,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Is the conditional variable awaited?\n+    #[inline]\n     fn condvar_is_awaited(&mut self, id: CondvarId) -> bool {\n         let this = self.eval_context_mut();\n         !this.machine.threads.sync.condvars[id].waiters.is_empty()"}, {"sha": "3432f10f7a925fc58e3605f5be93dca7f9cc0852", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -30,8 +30,7 @@ pub enum SchedulingAction {\n     Stop,\n }\n \n-/// Timeout callbacks can be created by synchronization primitives to tell the\n-/// scheduler that they should be called once some period of time passes.\n+/// Trait for callbacks that can be executed when some event happens, such as after a timeout.\n pub trait MachineCallback<'mir, 'tcx>: VisitTags {\n     fn call(&self, ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx>;\n }\n@@ -269,7 +268,7 @@ pub struct ThreadManager<'mir, 'tcx> {\n     threads: IndexVec<ThreadId, Thread<'mir, 'tcx>>,\n     /// This field is pub(crate) because the synchronization primitives\n     /// (`crate::sync`) need a way to access it.\n-    pub(crate) sync: SynchronizationState,\n+    pub(crate) sync: SynchronizationState<'mir, 'tcx>,\n     /// A mapping from a thread-local static to an allocation id of a thread\n     /// specific allocation.\n     thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), Pointer<Provenance>>>,\n@@ -303,7 +302,7 @@ impl VisitTags for ThreadManager<'_, '_> {\n             timeout_callbacks,\n             active_thread: _,\n             yield_active_thread: _,\n-            sync: _,\n+            sync,\n         } = self;\n \n         for thread in threads {\n@@ -315,6 +314,7 @@ impl VisitTags for ThreadManager<'_, '_> {\n         for callback in timeout_callbacks.values() {\n             callback.callback.visit_tags(visit);\n         }\n+        sync.visit_tags(visit);\n     }\n }\n "}, {"sha": "479353bb9839e9ea991a5c2c5a22d69df9242577", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -83,34 +83,28 @@ pub use crate::shims::EvalContextExt as _;\n \n pub use crate::clock::{Clock, Instant};\n pub use crate::concurrency::{\n-    data_race::{\n-        AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n-        EvalContextExt as DataRaceEvalContextExt,\n-    },\n-    sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId},\n-    thread::{\n-        EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager,\n-        ThreadState, Time,\n-    },\n+    data_race::{AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, EvalContextExt as _},\n+    init_once::{EvalContextExt as _, InitOnceId},\n+    sync::{CondvarId, EvalContextExt as _, MutexId, RwLockId, SyncId},\n+    thread::{EvalContextExt as _, SchedulingAction, ThreadId, ThreadManager, ThreadState, Time},\n };\n pub use crate::diagnostics::{\n-    report_error, EvalContextExt as DiagnosticsEvalContextExt, NonHaltingDiagnostic,\n-    TerminationInfo,\n+    report_error, EvalContextExt as _, NonHaltingDiagnostic, TerminationInfo,\n };\n pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n-pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n+pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n     AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind, Provenance,\n     ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n-pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n+pub use crate::operator::EvalContextExt as _;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n+    CallId, EvalContextExt as _, Item, Permission, SbTag, Stack, Stacks,\n };\n pub use crate::tag_gc::{EvalContextExt as _, VisitTags};\n "}, {"sha": "bf6c1f8756290528017b55b3204fc546f99479d1", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -274,15 +274,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n                 this.update_environ()?;\n             }\n-            Ok(Scalar::from_i32(1)) // return non-zero on success\n+            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n         } else {\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n             let var_ptr = alloc_env_var_as_wide_str(&name, &value, this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n-            Ok(Scalar::from_i32(1)) // return non-zero on success\n+            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n         }\n     }\n \n@@ -411,14 +411,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.reject_in_isolation(\"`SetCurrentDirectoryW`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n-            return Ok(Scalar::from_i32(0));\n+            return this.eval_windows(\"c\", \"FALSE\");\n         }\n \n         match env::set_current_dir(path) {\n-            Ok(()) => Ok(Scalar::from_i32(1)),\n+            Ok(()) => this.eval_windows(\"c\", \"TRUE\"),\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n-                Ok(Scalar::from_i32(0))\n+                this.eval_windows(\"c\", \"FALSE\")\n             }\n         }\n     }"}, {"sha": "3e1e34c5dbe7bd3921114afea8fdaed10a1728e6", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 21, "deletions": 98, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -19,6 +19,10 @@ use crate::*;\n /// in `pthread_mutexattr_settype` function.\n const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n+const MUTEX_ID_OFFSET: u64 = 4;\n+const RWLOCK_ID_OFFSET: u64 = 4;\n+const CONDVAR_ID_OFFSET: u64 = 4;\n+\n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: Scalar<Provenance>,\n@@ -108,33 +112,6 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n     )\n }\n \n-fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, MutexId> {\n-    let value_place = ecx.deref_operand_and_offset(mutex_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.mutex_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(MutexId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n \n // Our chosen memory layout for the emulated rwlock (does not have to match the platform layout!):\n@@ -149,33 +126,6 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n-fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    rwlock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, RwLockId> {\n-    let value_place = ecx.deref_operand_and_offset(rwlock_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.rwlock_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n // pthread_condattr_t\n \n // Our chosen memory layout for emulation (does not have to match the platform layout!):\n@@ -232,33 +182,6 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n     )\n }\n \n-fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, CondvarId> {\n-    let value_place = ecx.deref_operand_and_offset(cond_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.condvar_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(CondvarId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n@@ -435,7 +358,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -475,7 +398,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -511,7 +434,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread) {\n@@ -545,7 +468,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n \n         if this.mutex_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked mutex\");\n@@ -568,7 +491,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -586,7 +509,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -603,7 +526,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -633,7 +556,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -650,7 +573,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         #[allow(clippy::if_same_then_else)]\n@@ -669,7 +592,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n \n         if this.rwlock_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked rwlock\");\n@@ -772,7 +695,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n         if let Some((thread, mutex)) = this.condvar_signal(id) {\n             post_cond_signal(this, thread, mutex)?;\n         }\n@@ -785,7 +708,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         cond_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n \n         while let Some((thread, mutex)) = this.condvar_signal(id) {\n             post_cond_signal(this, thread, mutex)?;\n@@ -801,8 +724,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n-        let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n@@ -822,8 +745,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.check_no_isolation(\"`pthread_cond_timedwait`\")?;\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n-        let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         // Extract the timeout.\n@@ -899,7 +822,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n         if this.condvar_is_awaited(id) {\n             throw_ub_format!(\"destroying an awaited conditional variable\");\n         }"}, {"sha": "d998bdf420f6c2b8fe0def72193fb9ad724a7aed", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -261,6 +261,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n                 this.write_scalar(ret, dest)?;\n             }\n+            \"InitOnceBeginInitialize\" => {\n+                let [ptr, flags, pending, context] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let result = this.InitOnceBeginInitialize(ptr, flags, pending, context)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"InitOnceComplete\" => {\n+                let [ptr, flags, context] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let result = this.InitOnceComplete(ptr, flags, context)?;\n+                this.write_scalar(result, dest)?;\n+            }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {"}, {"sha": "8064ca566755cc9bbc4c219d7563bf5d77e6a3de", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 127, "deletions": 41, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -1,41 +1,17 @@\n+use crate::concurrency::init_once::InitOnceStatus;\n+use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n-// Locks are pointer-sized pieces of data, initialized to 0.\n-// We use the first 4 bytes to store the RwLockId.\n-\n-fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    lock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, RwLockId> {\n-    let value_place = ecx.deref_operand_and_offset(lock_op, 0, ecx.machine.layouts.u32)?;\n-\n-    ecx.rwlock_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n+const SRWLOCK_ID_OFFSET: u64 = 0;\n+const INIT_ONCE_ID_OFFSET: u64 = 0;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+\n+#[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    #[allow(non_snake_case)]\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -54,13 +30,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn TryAcquireSRWLockExclusive(\n         &mut self,\n         lock_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -72,10 +47,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[allow(non_snake_case)]\n     fn ReleaseSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_writer_unlock(id, active_thread) {\n@@ -88,10 +62,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn AcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -103,13 +76,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn TryAcquireSRWLockShared(\n         &mut self,\n         lock_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -120,10 +92,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[allow(non_snake_case)]\n     fn ReleaseSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_reader_unlock(id, active_thread) {\n@@ -135,4 +106,119 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         Ok(())\n     }\n+\n+    fn InitOnceBeginInitialize(\n+        &mut self,\n+        init_once_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        pending_op: &OpTy<'tcx, Provenance>,\n+        context_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+        let active_thread = this.get_active_thread();\n+\n+        let id = this.init_once_get_or_create_id(init_once_op, INIT_ONCE_ID_OFFSET)?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+        let pending_place = this.deref_operand(pending_op)?.into();\n+        let context = this.read_pointer(context_op)?;\n+\n+        if flags != 0 {\n+            throw_unsup_format!(\"unsupported `dwFlags` {flags} in `InitOnceBeginInitialize`\");\n+        }\n+\n+        if !this.ptr_is_null(context)? {\n+            throw_unsup_format!(\"non-null `lpContext` in `InitOnceBeginInitialize`\");\n+        }\n+\n+        match this.init_once_status(id) {\n+            InitOnceStatus::Uninitialized => {\n+                this.init_once_begin(id);\n+                this.write_scalar(this.eval_windows(\"c\", \"TRUE\")?, &pending_place)?;\n+            }\n+            InitOnceStatus::Begun => {\n+                // Someone else is already on it.\n+                // Block this thread until they are done.\n+                // When we are woken up, set the `pending` flag accordingly.\n+                struct Callback<'tcx> {\n+                    init_once_id: InitOnceId,\n+                    pending_place: PlaceTy<'tcx, Provenance>,\n+                }\n+\n+                impl<'tcx> VisitTags for Callback<'tcx> {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                        let Callback { init_once_id: _, pending_place } = self;\n+                        pending_place.visit_tags(visit);\n+                    }\n+                }\n+\n+                impl<'mir, 'tcx> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                    fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                        let pending = match this.init_once_status(self.init_once_id) {\n+                            InitOnceStatus::Uninitialized =>\n+                                unreachable!(\n+                                    \"status should have either been set to begun or complete\"\n+                                ),\n+                            InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\")?,\n+                            InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\")?,\n+                        };\n+\n+                        this.write_scalar(pending, &self.pending_place)?;\n+\n+                        Ok(())\n+                    }\n+                }\n+\n+                this.init_once_enqueue_and_block(\n+                    id,\n+                    active_thread,\n+                    Box::new(Callback { init_once_id: id, pending_place }),\n+                )\n+            }\n+            InitOnceStatus::Complete =>\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?,\n+        }\n+\n+        // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock).\n+        this.eval_windows(\"c\", \"TRUE\")\n+    }\n+\n+    fn InitOnceComplete(\n+        &mut self,\n+        init_once_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        context_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let id = this.init_once_get_or_create_id(init_once_op, INIT_ONCE_ID_OFFSET)?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+        let context = this.read_pointer(context_op)?;\n+\n+        let success = if flags == 0 {\n+            true\n+        } else if flags == this.eval_windows(\"c\", \"INIT_ONCE_INIT_FAILED\")?.to_u32()? {\n+            false\n+        } else {\n+            throw_unsup_format!(\"unsupported `dwFlags` {flags} in `InitOnceBeginInitialize`\");\n+        };\n+\n+        if !this.ptr_is_null(context)? {\n+            throw_unsup_format!(\"non-null `lpContext` in `InitOnceBeginInitialize`\");\n+        }\n+\n+        if this.init_once_status(id) != InitOnceStatus::Begun {\n+            // The docs do not say anything about this case, but it seems better to not allow it.\n+            throw_ub_format!(\n+                \"calling InitOnceComplete on a one time initialization that has not begun or is already completed\"\n+            );\n+        }\n+\n+        if success {\n+            this.init_once_complete(id)?;\n+        } else {\n+            this.init_once_fail(id)?;\n+        }\n+\n+        this.eval_windows(\"c\", \"TRUE\")\n+    }\n }"}, {"sha": "d3c72c3d028cf70e6b4da81aaa88f3a0226e6169", "filename": "src/tools/miri/tests/pass/concurrency/windows_init_once.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -0,0 +1,138 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::ffi::c_void;\n+use std::ptr::null_mut;\n+use std::thread;\n+\n+#[derive(Copy, Clone)]\n+struct SendPtr<T>(*mut T);\n+\n+unsafe impl<T> Send for SendPtr<T> {}\n+\n+extern \"system\" {\n+    fn InitOnceBeginInitialize(\n+        init: *mut *mut c_void,\n+        flags: u32,\n+        pending: *mut i32,\n+        context: *mut c_void,\n+    ) -> i32;\n+\n+    fn InitOnceComplete(init: *mut *mut c_void, flags: u32, context: *mut c_void) -> i32;\n+}\n+\n+const TRUE: i32 = 1;\n+const FALSE: i32 = 0;\n+\n+const INIT_ONCE_INIT_FAILED: u32 = 4;\n+\n+fn single_thread() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+\n+        assert_eq!(InitOnceComplete(&mut init_once, 0, null_mut()), TRUE);\n+\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, FALSE);\n+    }\n+\n+    let mut init_once = null_mut();\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+\n+        assert_eq!(InitOnceComplete(&mut init_once, INIT_ONCE_INIT_FAILED, null_mut()), TRUE);\n+\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+}\n+\n+fn block_until_complete() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+\n+    let init_once_ptr = SendPtr(&mut init_once);\n+\n+    let waiter = move || unsafe {\n+        let mut pending = 0;\n+\n+        assert_eq!(InitOnceBeginInitialize(init_once_ptr.0, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, FALSE);\n+\n+        println!(\"finished waiting for initialization\");\n+    };\n+\n+    let waiter1 = thread::spawn(waiter);\n+    let waiter2 = thread::spawn(waiter);\n+\n+    // this yield ensures `waiter1` & `waiter2` are blocked on the main thread\n+    thread::yield_now();\n+\n+    println!(\"completing initialization\");\n+\n+    unsafe {\n+        assert_eq!(InitOnceComplete(init_once_ptr.0, 0, null_mut()), TRUE);\n+    }\n+\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+}\n+\n+fn retry_on_fail() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+\n+    let init_once_ptr = SendPtr(&mut init_once);\n+\n+    let waiter = move || unsafe {\n+        let mut pending = 0;\n+\n+        assert_eq!(InitOnceBeginInitialize(init_once_ptr.0, 0, &mut pending, null_mut()), TRUE);\n+\n+        if pending == 1 {\n+            println!(\"retrying initialization\");\n+\n+            assert_eq!(InitOnceComplete(init_once_ptr.0, 0, null_mut()), TRUE);\n+        } else {\n+            println!(\"finished waiting for initialization\");\n+        }\n+    };\n+\n+    let waiter1 = thread::spawn(waiter);\n+    let waiter2 = thread::spawn(waiter);\n+\n+    // this yield ensures `waiter1` & `waiter2` are blocked on the main thread\n+    thread::yield_now();\n+\n+    println!(\"failing initialization\");\n+\n+    unsafe {\n+        assert_eq!(InitOnceComplete(init_once_ptr.0, INIT_ONCE_INIT_FAILED, null_mut()), TRUE);\n+    }\n+\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+}\n+\n+fn main() {\n+    single_thread();\n+    block_until_complete();\n+    retry_on_fail();\n+}"}, {"sha": "f3d5aad8edce24ea33735f11e88daf70663bdbfa", "filename": "src/tools/miri/tests/pass/concurrency/windows_init_once.stdout", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.stdout?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -0,0 +1,6 @@\n+completing initialization\n+finished waiting for initialization\n+finished waiting for initialization\n+failing initialization\n+retrying initialization\n+finished waiting for initialization"}]}