{"sha": "463436ffeb6ba833d00a69fd65c5b22acba9a9d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MzQzNmZmZWI2YmE4MzNkMDBhNjlmZDY1YzViMjJhY2JhOWE5ZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-13T11:06:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-13T11:06:50Z"}, "message": "auto merge of #14167 : cmr/rust/cmplx, r=alexcrichton\n\n[breaking-change]", "tree": {"sha": "d0b3756256571a11d075625d2b67384ad339c3e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0b3756256571a11d075625d2b67384ad339c3e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/463436ffeb6ba833d00a69fd65c5b22acba9a9d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/463436ffeb6ba833d00a69fd65c5b22acba9a9d7", "html_url": "https://github.com/rust-lang/rust/commit/463436ffeb6ba833d00a69fd65c5b22acba9a9d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/463436ffeb6ba833d00a69fd65c5b22acba9a9d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e16243816251d66eb823ba7199259fcaac7d0deb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e16243816251d66eb823ba7199259fcaac7d0deb", "html_url": "https://github.com/rust-lang/rust/commit/e16243816251d66eb823ba7199259fcaac7d0deb"}, {"sha": "2886938169060f7a4e4ef50994bd4908bdcfcb20", "url": "https://api.github.com/repos/rust-lang/rust/commits/2886938169060f7a4e4ef50994bd4908bdcfcb20", "html_url": "https://github.com/rust-lang/rust/commit/2886938169060f7a4e4ef50994bd4908bdcfcb20"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "3a666273d4a8aa13ed9acf42c91a40e6d15d0d43", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/463436ffeb6ba833d00a69fd65c5b22acba9a9d7/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/463436ffeb6ba833d00a69fd65c5b22acba9a9d7/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=463436ffeb6ba833d00a69fd65c5b22acba9a9d7", "patch": "@@ -23,21 +23,21 @@ use std::num::{Zero,One,ToStrRadix};\n \n /// A complex number in Cartesian form.\n #[deriving(Eq,Clone)]\n-pub struct Cmplx<T> {\n+pub struct Complex<T> {\n     /// Real portion of the complex number\n     pub re: T,\n     /// Imaginary portion of the complex number\n     pub im: T\n }\n \n-pub type Complex32 = Cmplx<f32>;\n-pub type Complex64 = Cmplx<f64>;\n+pub type Complex32 = Complex<f32>;\n+pub type Complex64 = Complex<f64>;\n \n-impl<T: Clone + Num> Cmplx<T> {\n-    /// Create a new Cmplx\n+impl<T: Clone + Num> Complex<T> {\n+    /// Create a new Complex\n     #[inline]\n-    pub fn new(re: T, im: T) -> Cmplx<T> {\n-        Cmplx { re: re, im: im }\n+    pub fn new(re: T, im: T) -> Complex<T> {\n+        Complex { re: re, im: im }\n     }\n \n     /**\n@@ -52,41 +52,41 @@ impl<T: Clone + Num> Cmplx<T> {\n \n     /// Returns the complex conjugate. i.e. `re - i im`\n     #[inline]\n-    pub fn conj(&self) -> Cmplx<T> {\n-        Cmplx::new(self.re.clone(), -self.im)\n+    pub fn conj(&self) -> Complex<T> {\n+        Complex::new(self.re.clone(), -self.im)\n     }\n \n \n     /// Multiplies `self` by the scalar `t`.\n     #[inline]\n-    pub fn scale(&self, t: T) -> Cmplx<T> {\n-        Cmplx::new(self.re * t, self.im * t)\n+    pub fn scale(&self, t: T) -> Complex<T> {\n+        Complex::new(self.re * t, self.im * t)\n     }\n \n     /// Divides `self` by the scalar `t`.\n     #[inline]\n-    pub fn unscale(&self, t: T) -> Cmplx<T> {\n-        Cmplx::new(self.re / t, self.im / t)\n+    pub fn unscale(&self, t: T) -> Complex<T> {\n+        Complex::new(self.re / t, self.im / t)\n     }\n \n     /// Returns `1/self`\n     #[inline]\n-    pub fn inv(&self) -> Cmplx<T> {\n+    pub fn inv(&self) -> Complex<T> {\n         let norm_sqr = self.norm_sqr();\n-        Cmplx::new(self.re / norm_sqr,\n+        Complex::new(self.re / norm_sqr,\n                     -self.im / norm_sqr)\n     }\n }\n \n-impl<T: Clone + Float> Cmplx<T> {\n+impl<T: Clone + Float> Complex<T> {\n     /// Calculate |self|\n     #[inline]\n     pub fn norm(&self) -> T {\n         self.re.hypot(self.im)\n     }\n }\n \n-impl<T: Clone + Float> Cmplx<T> {\n+impl<T: Clone + Float> Complex<T> {\n     /// Calculate the principal Arg of self.\n     #[inline]\n     pub fn arg(&self) -> T {\n@@ -100,58 +100,58 @@ impl<T: Clone + Float> Cmplx<T> {\n     }\n     /// Convert a polar representation into a complex number.\n     #[inline]\n-    pub fn from_polar(r: &T, theta: &T) -> Cmplx<T> {\n-        Cmplx::new(*r * theta.cos(), *r * theta.sin())\n+    pub fn from_polar(r: &T, theta: &T) -> Complex<T> {\n+        Complex::new(*r * theta.cos(), *r * theta.sin())\n     }\n }\n \n /* arithmetic */\n // (a + i b) + (c + i d) == (a + c) + i (b + d)\n-impl<T: Clone + Num> Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Add<Complex<T>, Complex<T>> for Complex<T> {\n     #[inline]\n-    fn add(&self, other: &Cmplx<T>) -> Cmplx<T> {\n-        Cmplx::new(self.re + other.re, self.im + other.im)\n+    fn add(&self, other: &Complex<T>) -> Complex<T> {\n+        Complex::new(self.re + other.re, self.im + other.im)\n     }\n }\n // (a + i b) - (c + i d) == (a - c) + i (b - d)\n-impl<T: Clone + Num> Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Sub<Complex<T>, Complex<T>> for Complex<T> {\n     #[inline]\n-    fn sub(&self, other: &Cmplx<T>) -> Cmplx<T> {\n-        Cmplx::new(self.re - other.re, self.im - other.im)\n+    fn sub(&self, other: &Complex<T>) -> Complex<T> {\n+        Complex::new(self.re - other.re, self.im - other.im)\n     }\n }\n // (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n-impl<T: Clone + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Mul<Complex<T>, Complex<T>> for Complex<T> {\n     #[inline]\n-    fn mul(&self, other: &Cmplx<T>) -> Cmplx<T> {\n-        Cmplx::new(self.re*other.re - self.im*other.im,\n+    fn mul(&self, other: &Complex<T>) -> Complex<T> {\n+        Complex::new(self.re*other.re - self.im*other.im,\n                    self.re*other.im + self.im*other.re)\n     }\n }\n \n // (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n //   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Clone + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Div<Complex<T>, Complex<T>> for Complex<T> {\n     #[inline]\n-    fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+    fn div(&self, other: &Complex<T>) -> Complex<T> {\n         let norm_sqr = other.norm_sqr();\n-        Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n+        Complex::new((self.re*other.re + self.im*other.im) / norm_sqr,\n                    (self.im*other.re - self.re*other.im) / norm_sqr)\n     }\n }\n \n-impl<T: Clone + Num> Neg<Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Neg<Complex<T>> for Complex<T> {\n     #[inline]\n-    fn neg(&self) -> Cmplx<T> {\n-        Cmplx::new(-self.re, -self.im)\n+    fn neg(&self) -> Complex<T> {\n+        Complex::new(-self.re, -self.im)\n     }\n }\n \n /* constants */\n-impl<T: Clone + Num> Zero for Cmplx<T> {\n+impl<T: Clone + Num> Zero for Complex<T> {\n     #[inline]\n-    fn zero() -> Cmplx<T> {\n-        Cmplx::new(Zero::zero(), Zero::zero())\n+    fn zero() -> Complex<T> {\n+        Complex::new(Zero::zero(), Zero::zero())\n     }\n \n     #[inline]\n@@ -160,15 +160,15 @@ impl<T: Clone + Num> Zero for Cmplx<T> {\n     }\n }\n \n-impl<T: Clone + Num> One for Cmplx<T> {\n+impl<T: Clone + Num> One for Complex<T> {\n     #[inline]\n-    fn one() -> Cmplx<T> {\n-        Cmplx::new(One::one(), Zero::zero())\n+    fn one() -> Complex<T> {\n+        Complex::new(One::one(), Zero::zero())\n     }\n }\n \n /* string conversions */\n-impl<T: fmt::Show + Num + Ord> fmt::Show for Cmplx<T> {\n+impl<T: fmt::Show + Num + Ord> fmt::Show for Complex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.im < Zero::zero() {\n             write!(f.buf, \"{}-{}i\", self.re, -self.im)\n@@ -178,7 +178,7 @@ impl<T: fmt::Show + Num + Ord> fmt::Show for Cmplx<T> {\n     }\n }\n \n-impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n+impl<T: ToStrRadix + Num + Ord> ToStrRadix for Complex<T> {\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         if self.im < Zero::zero() {\n             format!(\"{}-{}i\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n@@ -192,22 +192,22 @@ impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n mod test {\n     #![allow(non_uppercase_statics)]\n \n-    use super::{Complex64, Cmplx};\n+    use super::{Complex64, Complex};\n     use std::num::{Zero,One,Float};\n \n-    pub static _0_0i : Complex64 = Cmplx { re: 0.0, im: 0.0 };\n-    pub static _1_0i : Complex64 = Cmplx { re: 1.0, im: 0.0 };\n-    pub static _1_1i : Complex64 = Cmplx { re: 1.0, im: 1.0 };\n-    pub static _0_1i : Complex64 = Cmplx { re: 0.0, im: 1.0 };\n-    pub static _neg1_1i : Complex64 = Cmplx { re: -1.0, im: 1.0 };\n-    pub static _05_05i : Complex64 = Cmplx { re: 0.5, im: 0.5 };\n+    pub static _0_0i : Complex64 = Complex { re: 0.0, im: 0.0 };\n+    pub static _1_0i : Complex64 = Complex { re: 1.0, im: 0.0 };\n+    pub static _1_1i : Complex64 = Complex { re: 1.0, im: 1.0 };\n+    pub static _0_1i : Complex64 = Complex { re: 0.0, im: 1.0 };\n+    pub static _neg1_1i : Complex64 = Complex { re: -1.0, im: 1.0 };\n+    pub static _05_05i : Complex64 = Complex { re: 0.5, im: 0.5 };\n     pub static all_consts : [Complex64, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n \n     #[test]\n     fn test_consts() {\n-        // check our constants are what Cmplx::new creates\n+        // check our constants are what Complex::new creates\n         fn test(c : Complex64, r : f64, i: f64) {\n-            assert_eq!(c, Cmplx::new(r,i));\n+            assert_eq!(c, Complex::new(r,i));\n         }\n         test(_0_0i, 0.0, 0.0);\n         test(_1_0i, 1.0, 0.0);\n@@ -246,7 +246,7 @@ mod test {\n     #[test]\n     fn test_conj() {\n         for &c in all_consts.iter() {\n-            assert_eq!(c.conj(), Cmplx::new(c.re, -c.im));\n+            assert_eq!(c.conj(), Complex::new(c.re, -c.im));\n             assert_eq!(c.conj().conj(), c);\n         }\n     }\n@@ -280,7 +280,7 @@ mod test {\n     fn test_polar_conv() {\n         fn test(c: Complex64) {\n             let (r, theta) = c.to_polar();\n-            assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n+            assert!((c - Complex::from_polar(&r, &theta)).norm() < 1e-6);\n         }\n         for &c in all_consts.iter() { test(c); }\n     }"}]}