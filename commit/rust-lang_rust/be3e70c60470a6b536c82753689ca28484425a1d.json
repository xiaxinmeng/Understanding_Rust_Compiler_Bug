{"sha": "be3e70c60470a6b536c82753689ca28484425a1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlM2U3MGM2MDQ3MGE2YjUzNmM4Mjc1MzY4OWNhMjg0ODQ0MjVhMWQ=", "commit": {"author": {"name": "ivan770", "email": "ivan@ivan770.me", "date": "2021-08-08T08:12:40Z"}, "committer": {"name": "ivan770", "email": "ivan@ivan770.me", "date": "2021-08-08T08:12:40Z"}, "message": "Add reference here diagnostic", "tree": {"sha": "543992d482ae6ce7e1eaeae82be103d1bffbe4b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/543992d482ae6ce7e1eaeae82be103d1bffbe4b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be3e70c60470a6b536c82753689ca28484425a1d", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFEBAABCAAuFiEEcPkYW+t8+2SKgl5T2MS9WuTZzE0FAmEPkfkQHGl2YW5AaXZh\nbjc3MC5tZQAKCRDYxL1a5NnMTT4HB/94FOXNtUfCN73z/iKeUcqg7POfuGRTPpo6\nNpjyFaeAYURo48+6QDeeewKp4NP/3PgVqSWGD6i99c10aZmtX+flsgkbRufsJpk8\nDLMO2iR5fxCTw0u4YABM2am0BziAD+dM9MkPOWs4xcdeB4GskpqBx/ZA48cGMDBO\nEFKHJgbvujch4QsF7oGv7g2qhvDYwSVXgdCB5SbGz98yYH6hIILnTMDGs2QxcZ93\nu3ojPv/8lQp4S1ghw0PAhibFEUwycZqt1ag/9ULpuXBzjVMKD6ALfmOjbekZgcGj\nHHS78t1wjjS2quPakgBFxGR4eZRDfdPM9lcRQmu0R9iBdT+CG6Tl\n=7Db7\n-----END PGP SIGNATURE-----", "payload": "tree 543992d482ae6ce7e1eaeae82be103d1bffbe4b7\nparent a9f115b36f9d35a93b16d4b054980b3f3a133f3a\nauthor ivan770 <ivan@ivan770.me> 1628410360 +0200\ncommitter ivan770 <ivan@ivan770.me> 1628410360 +0200\n\nAdd reference here diagnostic\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be3e70c60470a6b536c82753689ca28484425a1d", "html_url": "https://github.com/rust-lang/rust/commit/be3e70c60470a6b536c82753689ca28484425a1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be3e70c60470a6b536c82753689ca28484425a1d/comments", "author": {"login": "ivan770", "id": 14003886, "node_id": "MDQ6VXNlcjE0MDAzODg2", "avatar_url": "https://avatars.githubusercontent.com/u/14003886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivan770", "html_url": "https://github.com/ivan770", "followers_url": "https://api.github.com/users/ivan770/followers", "following_url": "https://api.github.com/users/ivan770/following{/other_user}", "gists_url": "https://api.github.com/users/ivan770/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivan770/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivan770/subscriptions", "organizations_url": "https://api.github.com/users/ivan770/orgs", "repos_url": "https://api.github.com/users/ivan770/repos", "events_url": "https://api.github.com/users/ivan770/events{/privacy}", "received_events_url": "https://api.github.com/users/ivan770/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ivan770", "id": 14003886, "node_id": "MDQ6VXNlcjE0MDAzODg2", "avatar_url": "https://avatars.githubusercontent.com/u/14003886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivan770", "html_url": "https://github.com/ivan770", "followers_url": "https://api.github.com/users/ivan770/followers", "following_url": "https://api.github.com/users/ivan770/following{/other_user}", "gists_url": "https://api.github.com/users/ivan770/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivan770/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivan770/subscriptions", "organizations_url": "https://api.github.com/users/ivan770/orgs", "repos_url": "https://api.github.com/users/ivan770/repos", "events_url": "https://api.github.com/users/ivan770/events{/privacy}", "received_events_url": "https://api.github.com/users/ivan770/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9f115b36f9d35a93b16d4b054980b3f3a133f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f115b36f9d35a93b16d4b054980b3f3a133f3a", "html_url": "https://github.com/rust-lang/rust/commit/a9f115b36f9d35a93b16d4b054980b3f3a133f3a"}], "stats": {"total": 236, "additions": 231, "deletions": 5}, "files": [{"sha": "0f1963e8318e9f93beb52a79b076aeed56b7c77c", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=be3e70c60470a6b536c82753689ca28484425a1d", "patch": "@@ -5,7 +5,7 @@\n //! be expressed in terms of hir types themselves.\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_def::path::ModPath;\n+use hir_def::{path::ModPath, type_ref::Mutability};\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n@@ -28,6 +28,7 @@ macro_rules! diagnostics {\n }\n \n diagnostics![\n+    AddReferenceHere,\n     BreakOutsideOfLoop,\n     InactiveCode,\n     IncorrectCase,\n@@ -154,4 +155,10 @@ pub struct MissingMatchArms {\n     pub arms: AstPtr<ast::MatchArmList>,\n }\n \n+#[derive(Debug)]\n+pub struct AddReferenceHere {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub mutability: Mutability,\n+}\n+\n pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "72d5dbc781d700992be4787147f6dbea4a9a5593", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=be3e70c60470a6b536c82753689ca28484425a1d", "patch": "@@ -82,8 +82,8 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, MacroError,\n-        MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n+        AddReferenceHere, AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase,\n+        MacroError, MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n         MissingUnsafe, NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n         UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedModule, UnresolvedProcMacro,\n@@ -1251,6 +1251,12 @@ impl Function {\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n+                BodyValidationDiagnostic::AddReferenceHere { arg_expr, mutability } => {\n+                    match source_map.expr_syntax(arg_expr) {\n+                        Ok(expr) => acc.push(AddReferenceHere { expr, mutability }.into()),\n+                        Err(SyntheticSyntax) => (),\n+                    }\n+                }\n             }\n         }\n "}, {"sha": "17de5dfe2a5f1a1cbe63118889d78d6150c4058a", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=be3e70c60470a6b536c82753689ca28484425a1d", "patch": "@@ -5,7 +5,8 @@\n use std::{cell::RefCell, sync::Arc};\n \n use hir_def::{\n-    expr::Statement, path::path, resolver::HasResolver, AssocItemId, DefWithBodyId, HasModule,\n+    expr::Statement, path::path, resolver::HasResolver, type_ref::Mutability, AssocItemId,\n+    DefWithBodyId, HasModule,\n };\n use hir_expand::name;\n use itertools::Either;\n@@ -17,7 +18,7 @@ use crate::{\n         self,\n         usefulness::{compute_match_usefulness, expand_pattern, MatchCheckCtx, PatternArena},\n     },\n-    AdtId, InferenceResult, Interner, TyExt, TyKind,\n+    AdtId, InferenceResult, Interner, Ty, TyExt, TyKind,\n };\n \n pub(crate) use hir_def::{\n@@ -50,6 +51,10 @@ pub enum BodyValidationDiagnostic {\n     MissingMatchArms {\n         match_expr: ExprId,\n     },\n+    AddReferenceHere {\n+        arg_expr: ExprId,\n+        mutability: Mutability,\n+    },\n }\n \n impl BodyValidationDiagnostic {\n@@ -118,6 +123,22 @@ impl ExprValidator {\n                 self.validate_missing_tail_expr(body.body_expr, *id);\n             }\n         }\n+\n+        let infer = &self.infer;\n+        let diagnostics = &mut self.diagnostics;\n+\n+        infer\n+            .expr_type_mismatches()\n+            .filter_map(|(expr, mismatch)| {\n+                let (expr_without_ref, mutability) =\n+                    check_missing_refs(infer, expr, &mismatch.expected)?;\n+\n+                Some((expr_without_ref, mutability))\n+            })\n+            .for_each(|(arg_expr, mutability)| {\n+                diagnostics\n+                    .push(BodyValidationDiagnostic::AddReferenceHere { arg_expr, mutability });\n+            });\n     }\n \n     fn check_for_filter_map_next(&mut self, db: &dyn HirDatabase) {\n@@ -491,3 +512,30 @@ fn types_of_subpatterns_do_match(pat: PatId, body: &Body, infer: &InferenceResul\n     walk(pat, body, infer, &mut has_type_mismatches);\n     !has_type_mismatches\n }\n+\n+fn check_missing_refs(\n+    infer: &InferenceResult,\n+    arg: ExprId,\n+    param: &Ty,\n+) -> Option<(ExprId, Mutability)> {\n+    let arg_ty = infer.type_of_expr.get(arg)?;\n+\n+    let reference_one = arg_ty.as_reference();\n+    let reference_two = param.as_reference();\n+\n+    match (reference_one, reference_two) {\n+        (None, Some((referenced_ty, _, mutability))) if referenced_ty == arg_ty => {\n+            Some((arg, Mutability::from_mutable(matches!(mutability, chalk_ir::Mutability::Mut))))\n+        }\n+        (None, Some((referenced_ty, _, mutability))) => match referenced_ty.kind(&Interner) {\n+            TyKind::Slice(subst) if matches!(arg_ty.kind(&Interner), TyKind::Array(arr_subst, _) if arr_subst == subst) => {\n+                Some((\n+                    arg,\n+                    Mutability::from_mutable(matches!(mutability, chalk_ir::Mutability::Mut)),\n+                ))\n+            }\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "db24fd6cce368e3e89d0fd03ecb32cf7421a79a9", "filename": "crates/ide_diagnostics/src/handlers/add_reference_here.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fadd_reference_here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fadd_reference_here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fadd_reference_here.rs?ref=be3e70c60470a6b536c82753689ca28484425a1d", "patch": "@@ -0,0 +1,163 @@\n+use hir::db::AstDatabase;\n+use ide_db::source_change::SourceChange;\n+use syntax::AstNode;\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: add-reference-here\n+//\n+// This diagnostic is triggered when there's a missing referencing of expression.\n+pub(crate) fn add_reference_here(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::AddReferenceHere,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"add-reference-here\",\n+        \"add reference here\",\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::AddReferenceHere) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let arg_expr = d.expr.value.to_node(&root);\n+\n+    let arg_with_ref = format!(\"&{}{}\", d.mutability.as_keyword_for_ref(), arg_expr.syntax());\n+\n+    let arg_range = arg_expr.syntax().text_range();\n+    let edit = TextEdit::replace(arg_range, arg_with_ref);\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+\n+    Some(vec![fix(\"add_reference_here\", \"Add reference here\", source_change, arg_range)])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn missing_reference() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    test(123);\n+       //^^^ \ud83d\udca1 error: add reference here\n+}\n+fn test(arg: &i32) {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_to_int() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    test(123$0);\n+}\n+fn test(arg: &i32) {}\n+            \"#,\n+            r#\"\n+fn main() {\n+    test(&123);\n+}\n+fn test(arg: &i32) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_mutable_reference_to_int() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    test($0123);\n+}\n+fn test(arg: &mut i32) {}\n+            \"#,\n+            r#\"\n+fn main() {\n+    test(&mut 123);\n+}\n+fn test(arg: &mut i32) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_to_array() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    test($0[1, 2, 3]);\n+}\n+fn test(arg: &[i32]) {}\n+            \"#,\n+            r#\"\n+fn main() {\n+    test(&[1, 2, 3]);\n+}\n+fn test(arg: &[i32]) {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_to_method_call() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    Test.call_by_ref($0123);\n+}\n+struct Test;\n+impl Test {\n+    fn call_by_ref(&self, arg: &i32) {}\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    Test.call_by_ref(&123);\n+}\n+struct Test;\n+impl Test {\n+    fn call_by_ref(&self, arg: &i32) {}\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_reference_to_let_stmt() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    let test: &i32 = $0123;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let test: &i32 = &123;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_mutable_reference_to_let_stmt() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    let test: &mut i32 = $0123;\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let test: &mut i32 = &mut 123;\n+}\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "9cb34d5a1a58048b4ca3ee8e3122ce85e7d8d99c", "filename": "crates/ide_diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3e70c60470a6b536c82753689ca28484425a1d/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Flib.rs?ref=be3e70c60470a6b536c82753689ca28484425a1d", "patch": "@@ -24,6 +24,7 @@\n //! don't yet have a great pattern for how to do them properly.\n \n mod handlers {\n+    pub(crate) mod add_reference_here;\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n@@ -176,6 +177,7 @@ pub fn diagnostics(\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n+            AnyDiagnostic::AddReferenceHere(d) => handlers::add_reference_here::add_reference_here(&ctx, &d),\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),"}]}