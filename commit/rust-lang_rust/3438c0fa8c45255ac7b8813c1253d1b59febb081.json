{"sha": "3438c0fa8c45255ac7b8813c1253d1b59febb081", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MzhjMGZhOGM0NTI1NWFjN2I4ODEzYzEyNTNkMWI1OWZlYmIwODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T02:21:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-17T02:21:38Z"}, "message": "Auto merge of #42613 - stepancheg:lossy, r=alexcrichton\n\nAvoid allocations in Display for OsStr and Path\n\n#38879", "tree": {"sha": "337c31166169d73940c6bc8962a89d6bf56b561f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/337c31166169d73940c6bc8962a89d6bf56b561f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3438c0fa8c45255ac7b8813c1253d1b59febb081", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3438c0fa8c45255ac7b8813c1253d1b59febb081", "html_url": "https://github.com/rust-lang/rust/commit/3438c0fa8c45255ac7b8813c1253d1b59febb081", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3438c0fa8c45255ac7b8813c1253d1b59febb081/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1169a1fb1386be5b640b0ca38f362c162fd33c8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1169a1fb1386be5b640b0ca38f362c162fd33c8b", "html_url": "https://github.com/rust-lang/rust/commit/1169a1fb1386be5b640b0ca38f362c162fd33c8b"}, {"sha": "ac96fd77874bb7968b7d82bed5a410d3941bc4c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac96fd77874bb7968b7d82bed5a410d3941bc4c8", "html_url": "https://github.com/rust-lang/rust/commit/ac96fd77874bb7968b7d82bed5a410d3941bc4c8"}], "stats": {"total": 584, "additions": 450, "deletions": 134}, "files": [{"sha": "2cb81029f95e2a1ea89d9fb4aad1ca5111456057", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 22, "deletions": 99, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -61,8 +61,8 @@ use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n use core::ops::{self, Add, AddAssign, Index, IndexMut};\n use core::ptr;\n-use core::str as core_str;\n use core::str::pattern::Pattern;\n+use std_unicode::lossy;\n use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n \n use borrow::{Cow, ToOwned};\n@@ -533,111 +533,34 @@ impl String {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n-        let mut i;\n-        match str::from_utf8(v) {\n-            Ok(s) => return Cow::Borrowed(s),\n-            Err(e) => i = e.valid_up_to(),\n-        }\n+        let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n \n-        const TAG_CONT_U8: u8 = 128;\n-        const REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n-        let total = v.len();\n-        fn unsafe_get(xs: &[u8], i: usize) -> u8 {\n-            unsafe { *xs.get_unchecked(i) }\n-        }\n-        fn safe_get(xs: &[u8], i: usize, total: usize) -> u8 {\n-            if i >= total { 0 } else { unsafe_get(xs, i) }\n-        }\n+        let (first_valid, first_broken) = if let Some(chunk) = iter.next() {\n+            let lossy::Utf8LossyChunk { valid, broken } = chunk;\n+            if valid.len() == v.len() {\n+                debug_assert!(broken.is_empty());\n+                return Cow::Borrowed(valid);\n+            }\n+            (valid, broken)\n+        } else {\n+            return Cow::Borrowed(\"\");\n+        };\n \n-        let mut res = String::with_capacity(total);\n+        const REPLACEMENT: &'static str = \"\\u{FFFD}\";\n \n-        if i > 0 {\n-            unsafe { res.as_mut_vec().extend_from_slice(&v[..i]) };\n+        let mut res = String::with_capacity(v.len());\n+        res.push_str(first_valid);\n+        if !first_broken.is_empty() {\n+            res.push_str(REPLACEMENT);\n         }\n \n-        // subseqidx is the index of the first byte of the subsequence we're\n-        // looking at.  It's used to copy a bunch of contiguous good codepoints\n-        // at once instead of copying them one by one.\n-        let mut subseqidx = i;\n-\n-        while i < total {\n-            let i_ = i;\n-            let byte = unsafe_get(v, i);\n-            i += 1;\n-\n-            macro_rules! error { () => ({\n-                unsafe {\n-                    if subseqidx != i_ {\n-                        res.as_mut_vec().extend_from_slice(&v[subseqidx..i_]);\n-                    }\n-                    subseqidx = i;\n-                    res.as_mut_vec().extend_from_slice(REPLACEMENT);\n-                }\n-            })}\n-\n-            if byte < 128 {\n-                // subseqidx handles this\n-            } else {\n-                let w = core_str::utf8_char_width(byte);\n-\n-                match w {\n-                    2 => {\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    3 => {\n-                        match (byte, safe_get(v, i, total)) {\n-                            (0xE0, 0xA0...0xBF) => (),\n-                            (0xE1...0xEC, 0x80...0xBF) => (),\n-                            (0xED, 0x80...0x9F) => (),\n-                            (0xEE...0xEF, 0x80...0xBF) => (),\n-                            _ => {\n-                                error!();\n-                                continue;\n-                            }\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    4 => {\n-                        match (byte, safe_get(v, i, total)) {\n-                            (0xF0, 0x90...0xBF) => (),\n-                            (0xF1...0xF3, 0x80...0xBF) => (),\n-                            (0xF4, 0x80...0x8F) => (),\n-                            _ => {\n-                                error!();\n-                                continue;\n-                            }\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                        if safe_get(v, i, total) & 192 != TAG_CONT_U8 {\n-                            error!();\n-                            continue;\n-                        }\n-                        i += 1;\n-                    }\n-                    _ => {\n-                        error!();\n-                        continue;\n-                    }\n-                }\n+        for lossy::Utf8LossyChunk { valid, broken } in iter {\n+            res.push_str(valid);\n+            if !broken.is_empty() {\n+                res.push_str(REPLACEMENT);\n             }\n         }\n-        if subseqidx < total {\n-            unsafe { res.as_mut_vec().extend_from_slice(&v[subseqidx..total]) };\n-        }\n+\n         Cow::Owned(res)\n     }\n "}, {"sha": "f54d79c201f4869ae9fa01b0d499e89f97a85d3b", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use borrow::{Borrow, Cow};\n-use fmt::{self, Debug};\n+use fmt;\n use mem;\n use ops;\n use cmp;\n@@ -312,8 +312,8 @@ impl Default for OsString {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Debug for OsString {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+impl fmt::Debug for OsString {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, formatter)\n     }\n }\n@@ -669,9 +669,15 @@ impl Hash for OsStr {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Debug for OsStr {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.inner.fmt(formatter)\n+impl fmt::Debug for OsStr {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.inner, formatter)\n+    }\n+}\n+\n+impl OsStr {\n+    pub(crate) fn display(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.inner, formatter)\n     }\n }\n "}, {"sha": "42a54ed6d754c9dfbcafd38641eff8ffc723252e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -2281,8 +2281,8 @@ impl AsRef<OsStr> for Path {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Path {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.inner.fmt(formatter)\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.inner, formatter)\n     }\n }\n \n@@ -2314,14 +2314,14 @@ pub struct Display<'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> fmt::Debug for Display<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.path.to_string_lossy(), f)\n+        fmt::Debug::fmt(&self.path, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> fmt::Display for Display<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.path.to_string_lossy(), f)\n+        self.path.inner.display(f)\n     }\n }\n "}, {"sha": "c54286353a92f9c9b60ac3656993e5b1e8455f7b", "filename": "src/libstd/sys/redox/os_str.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -12,10 +12,11 @@\n /// a `Vec<u8>`/`[u8]`.\n \n use borrow::Cow;\n-use fmt::{self, Debug};\n+use fmt;\n use str;\n use mem;\n use sys_common::{AsInner, IntoInner};\n+use std_unicode::lossy::Utf8Lossy;\n \n #[derive(Clone, Hash)]\n pub struct Buf {\n@@ -26,15 +27,27 @@ pub struct Slice {\n     pub inner: [u8]\n }\n \n-impl Debug for Slice {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.to_string_lossy().fmt(formatter)\n+impl fmt::Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n     }\n }\n \n-impl Debug for Buf {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.as_slice().fmt(formatter)\n+impl fmt::Display for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n+    }\n+}\n+\n+impl fmt::Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl fmt::Display for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.as_slice(), formatter)\n     }\n }\n "}, {"sha": "777db17e3e164d322ef4cfe649093f07ca2a287c", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -12,10 +12,11 @@\n /// a `Vec<u8>`/`[u8]`.\n \n use borrow::Cow;\n-use fmt::{self, Debug};\n+use fmt;\n use str;\n use mem;\n use sys_common::{AsInner, IntoInner};\n+use std_unicode::lossy::Utf8Lossy;\n \n #[derive(Clone, Hash)]\n pub struct Buf {\n@@ -26,15 +27,27 @@ pub struct Slice {\n     pub inner: [u8]\n }\n \n-impl Debug for Slice {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.to_string_lossy().fmt(formatter)\n+impl fmt::Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n     }\n }\n \n-impl Debug for Buf {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.as_slice().fmt(formatter)\n+impl fmt::Display for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n+    }\n+}\n+\n+impl fmt::Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl fmt::Display for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.as_slice(), formatter)\n     }\n }\n "}, {"sha": "3eb4582718b517d9b83eda92eca5e1160b21bf41", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -12,7 +12,7 @@\n /// wrapper around the \"WTF-8\" encoding; see the `wtf8` module for more.\n \n use borrow::Cow;\n-use fmt::{self, Debug};\n+use fmt;\n use sys_common::wtf8::{Wtf8, Wtf8Buf};\n use mem;\n use sys_common::{AsInner, IntoInner};\n@@ -34,19 +34,31 @@ impl AsInner<Wtf8> for Buf {\n     }\n }\n \n-impl Debug for Buf {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.as_slice().fmt(formatter)\n+impl fmt::Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl fmt::Display for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.as_slice(), formatter)\n     }\n }\n \n pub struct Slice {\n     pub inner: Wtf8\n }\n \n-impl Debug for Slice {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        self.inner.fmt(formatter)\n+impl fmt::Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.inner, formatter)\n+    }\n+}\n+\n+impl fmt::Display for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.inner, formatter)\n     }\n }\n "}, {"sha": "4e4a6e77d124205ee36d9236b4fce1d257bbd4b8", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -39,7 +39,7 @@ use slice;\n use str;\n use sys_common::AsInner;\n \n-const UTF8_REPLACEMENT_CHARACTER: &'static [u8] = b\"\\xEF\\xBF\\xBD\";\n+const UTF8_REPLACEMENT_CHARACTER: &'static str = \"\\u{FFFD}\";\n \n /// A Unicode code point: from U+0000 to U+10FFFF.\n ///\n@@ -339,7 +339,7 @@ impl Wtf8Buf {\n                 Some((surrogate_pos, _)) => {\n                     pos = surrogate_pos + 3;\n                     self.bytes[surrogate_pos..pos]\n-                        .copy_from_slice(UTF8_REPLACEMENT_CHARACTER);\n+                        .copy_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());\n                 },\n                 None => return unsafe { String::from_utf8_unchecked(self.bytes) }\n             }\n@@ -438,6 +438,30 @@ impl fmt::Debug for Wtf8 {\n     }\n }\n \n+impl fmt::Display for Wtf8 {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        let wtf8_bytes = &self.bytes;\n+        let mut pos = 0;\n+        loop {\n+            match self.next_surrogate(pos) {\n+                Some((surrogate_pos, _)) => {\n+                    formatter.write_str(unsafe {\n+                        str::from_utf8_unchecked(&wtf8_bytes[pos .. surrogate_pos])\n+                    })?;\n+                    formatter.write_str(UTF8_REPLACEMENT_CHARACTER)?;\n+                    pos = surrogate_pos + 3;\n+                },\n+                None => {\n+                    formatter.write_str(unsafe {\n+                        str::from_utf8_unchecked(&wtf8_bytes[pos..])\n+                    })?;\n+                    return Ok(());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl Wtf8 {\n     /// Creates a WTF-8 slice from a UTF-8 `&str` slice.\n     ///\n@@ -516,13 +540,13 @@ impl Wtf8 {\n         let wtf8_bytes = &self.bytes;\n         let mut utf8_bytes = Vec::with_capacity(self.len());\n         utf8_bytes.extend_from_slice(&wtf8_bytes[..surrogate_pos]);\n-        utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER);\n+        utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());\n         let mut pos = surrogate_pos + 3;\n         loop {\n             match self.next_surrogate(pos) {\n                 Some((surrogate_pos, _)) => {\n                     utf8_bytes.extend_from_slice(&wtf8_bytes[pos .. surrogate_pos]);\n-                    utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER);\n+                    utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());\n                     pos = surrogate_pos + 3;\n                 },\n                 None => {\n@@ -1200,6 +1224,20 @@ mod tests {\n         assert_eq!(string.to_string_lossy(), expected);\n     }\n \n+    #[test]\n+    fn wtf8_display() {\n+        fn d(b: &[u8]) -> String {\n+            format!(\"{}\", &unsafe { Wtf8::from_bytes_unchecked(b) })\n+        }\n+\n+        assert_eq!(\"\", d(\"\".as_bytes()));\n+        assert_eq!(\"a\u00e9 \ud83d\udca9\", d(\"a\u00e9 \ud83d\udca9\".as_bytes()));\n+\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(\"a\u00e9 \ud83d\udca9\ufffd\", d(string.as_inner()));\n+    }\n+\n     #[test]\n     fn wtf8_encode_wide() {\n         let mut string = Wtf8Buf::from_str(\"a\u00e9 \");"}, {"sha": "b3346dbe2fb1240ddd1033907e169134b2ad4442", "filename": "src/libstd_unicode/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2FCargo.toml?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -9,5 +9,9 @@ path = \"lib.rs\"\n test = false\n bench = false\n \n+[[test]]\n+name = \"std_unicode_tests\"\n+path = \"tests/lib.rs\"\n+\n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "98624800b4c6c15c2529fb97496b32efe40006b1", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -34,6 +34,8 @@\n \n #![feature(char_escape_debug)]\n #![feature(core_char_ext)]\n+#![feature(str_internals)]\n+#![feature(core_intrinsics)]\n #![feature(decode_utf8)]\n #![feature(fused)]\n #![feature(fn_traits)]\n@@ -45,6 +47,7 @@\n mod tables;\n mod u_str;\n pub mod char;\n+pub mod lossy;\n \n #[allow(deprecated)]\n pub mod str {"}, {"sha": "b914cbcf4b85f8a7bf15941610300bfd5b30743c", "filename": "src/libstd_unicode/lossy.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flossy.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -0,0 +1,198 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::str as core_str;\n+use core::fmt;\n+use core::fmt::Write;\n+use char;\n+use core::intrinsics;\n+\n+\n+/// Lossy UTF-8 string.\n+#[unstable(feature = \"str_internals\", issue = \"0\")]\n+pub struct Utf8Lossy {\n+    bytes: [u8]\n+}\n+\n+impl Utf8Lossy {\n+    pub fn from_str(s: &str) -> &Utf8Lossy {\n+        Utf8Lossy::from_bytes(s.as_bytes())\n+    }\n+\n+    pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n+        unsafe { intrinsics::transmute(bytes) }\n+    }\n+\n+    pub fn chunks(&self) -> Utf8LossyChunksIter {\n+        Utf8LossyChunksIter { source: &self.bytes }\n+    }\n+}\n+\n+\n+/// Iterator over lossy UTF-8 string\n+#[unstable(feature = \"str_internals\", issue = \"0\")]\n+pub struct Utf8LossyChunksIter<'a> {\n+    source: &'a [u8],\n+}\n+\n+#[unstable(feature = \"str_internals\", issue = \"0\")]\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct Utf8LossyChunk<'a> {\n+    /// Sequence of valid chars.\n+    /// Can be empty between broken UTF-8 chars.\n+    pub valid: &'a str,\n+    /// Single broken char, empty if none.\n+    /// Empty iff iterator item is last.\n+    pub broken: &'a [u8],\n+}\n+\n+impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n+    type Item = Utf8LossyChunk<'a>;\n+\n+    fn next(&mut self) -> Option<Utf8LossyChunk<'a>> {\n+        if self.source.len() == 0 {\n+            return None;\n+        }\n+\n+        const TAG_CONT_U8: u8 = 128;\n+        fn unsafe_get(xs: &[u8], i: usize) -> u8 {\n+            unsafe { *xs.get_unchecked(i) }\n+        }\n+        fn safe_get(xs: &[u8], i: usize) -> u8 {\n+            if i >= xs.len() { 0 } else { unsafe_get(xs, i) }\n+        }\n+\n+        let mut i = 0;\n+        while i < self.source.len() {\n+            let i_ = i;\n+\n+            let byte = unsafe_get(self.source, i);\n+            i += 1;\n+\n+            if byte < 128 {\n+\n+            } else {\n+                let w = core_str::utf8_char_width(byte);\n+\n+                macro_rules! error { () => ({\n+                    unsafe {\n+                        let r = Utf8LossyChunk {\n+                            valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n+                            broken: &self.source[i_..i],\n+                        };\n+                        self.source = &self.source[i..];\n+                        return Some(r);\n+                    }\n+                })}\n+\n+                match w {\n+                    2 => {\n+                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n+                            error!();\n+                        }\n+                        i += 1;\n+                    }\n+                    3 => {\n+                        match (byte, safe_get(self.source, i)) {\n+                            (0xE0, 0xA0 ... 0xBF) => (),\n+                            (0xE1 ... 0xEC, 0x80 ... 0xBF) => (),\n+                            (0xED, 0x80 ... 0x9F) => (),\n+                            (0xEE ... 0xEF, 0x80 ... 0xBF) => (),\n+                            _ => {\n+                                error!();\n+                            }\n+                        }\n+                        i += 1;\n+                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n+                            error!();\n+                        }\n+                        i += 1;\n+                    }\n+                    4 => {\n+                        match (byte, safe_get(self.source, i)) {\n+                            (0xF0, 0x90 ... 0xBF) => (),\n+                            (0xF1 ... 0xF3, 0x80 ... 0xBF) => (),\n+                            (0xF4, 0x80 ... 0x8F) => (),\n+                            _ => {\n+                                error!();\n+                            }\n+                        }\n+                        i += 1;\n+                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n+                            error!();\n+                        }\n+                        i += 1;\n+                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n+                            error!();\n+                        }\n+                        i += 1;\n+                    }\n+                    _ => {\n+                        error!();\n+                    }\n+                }\n+            }\n+        }\n+\n+        let r = Utf8LossyChunk {\n+            valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n+            broken: &[],\n+        };\n+        self.source = &[];\n+        return Some(r);\n+    }\n+}\n+\n+\n+impl fmt::Display for Utf8Lossy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for Utf8LossyChunk { valid, broken } in self.chunks() {\n+            f.write_str(valid)?;\n+            if !broken.is_empty() {\n+                f.write_char(char::REPLACEMENT_CHARACTER)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl fmt::Debug for Utf8Lossy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_char('\"')?;\n+\n+        for Utf8LossyChunk { valid, broken } in self.chunks() {\n+\n+            // Valid part.\n+            // Here we partially parse UTF-8 again which is suboptimal.\n+            {\n+                let mut from = 0;\n+                for (i, c) in valid.char_indices() {\n+                    let esc = c.escape_debug();\n+                    // If char needs escaping, flush backlog so far and write, else skip\n+                    if esc.len() != 1 {\n+                        f.write_str(&valid[from..i])?;\n+                        for c in esc {\n+                            f.write_char(c)?;\n+                        }\n+                        from = i + c.len_utf8();\n+                    }\n+                }\n+                f.write_str(&valid[from..])?;\n+            }\n+\n+            // Broken parts of string as hex escape.\n+            for &b in broken {\n+                write!(f, \"\\\\x{:02x}\", b)?;\n+            }\n+        }\n+\n+        f.write_char('\"')\n+    }\n+}"}, {"sha": "9535ec18763e663e4cbc4f5b674571d24bb29170", "filename": "src/libstd_unicode/tests/lib.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftests%2Flib.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(str_internals, unicode)]\n+\n+extern crate std_unicode;\n+\n+mod lossy;"}, {"sha": "e05d06685563557857049463af15e816ec447514", "filename": "src/libstd_unicode/tests/lossy.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2Ftests%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3438c0fa8c45255ac7b8813c1253d1b59febb081/src%2Flibstd_unicode%2Ftests%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftests%2Flossy.rs?ref=3438c0fa8c45255ac7b8813c1253d1b59febb081", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std_unicode::lossy::*;\n+\n+#[test]\n+fn chunks() {\n+    let mut iter = Utf8Lossy::from_bytes(b\"hello\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"hello\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes()).chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC2 There\\xFF Goodbye\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC2\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xFF\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC0\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xE6\\x83\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xF5foo\\xF5\\x80bar\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF5\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF5\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF1\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF1\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF1\\x80\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF4\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF4\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF4\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF0\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\\u{10000}bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+\n+    // surrogates\n+    let mut iter = Utf8Lossy::from_bytes(b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\").chunks();\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xED\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xA0\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xED\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\", }), iter.next());\n+    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\", }), iter.next());\n+    assert_eq!(None, iter.next());\n+}\n+\n+#[test]\n+fn display() {\n+    assert_eq!(\n+        \"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\",\n+        &format!(\"{}\", Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\")));\n+}\n+\n+#[test]\n+fn debug() {\n+    assert_eq!(\n+        \"\\\"Hello\\\\xc0\\\\x80 There\\\\xe6\\\\x83 Goodbye\\\\u{10d4ea}\\\"\",\n+        &format!(\"{:?}\", Utf8Lossy::from_bytes(\n+            b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\\xf4\\x8d\\x93\\xaa\")));\n+}"}]}