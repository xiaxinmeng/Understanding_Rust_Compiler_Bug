{"sha": "18144b66e1515fa1391b7c7034ba55c47511fb9e", "node_id": "C_kwDOAAsO6NoAKDE4MTQ0YjY2ZTE1MTVmYTEzOTFiN2M3MDM0YmE1NWM0NzUxMWZiOWU", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2021-05-10T04:13:02Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2023-02-07T09:37:55Z"}, "message": "Create initial version of opt", "tree": {"sha": "295a8fa1dd69af0a5f73dd6181e8d1208e8f4a2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/295a8fa1dd69af0a5f73dd6181e8d1208e8f4a2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18144b66e1515fa1391b7c7034ba55c47511fb9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18144b66e1515fa1391b7c7034ba55c47511fb9e", "html_url": "https://github.com/rust-lang/rust/commit/18144b66e1515fa1391b7c7034ba55c47511fb9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18144b66e1515fa1391b7c7034ba55c47511fb9e/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d", "html_url": "https://github.com/rust-lang/rust/commit/dffea43fc1102bdfe16d88ed412c23d4f0f08d9d"}], "stats": {"total": 212, "additions": 212, "deletions": 0}, "files": [{"sha": "b742b7a45e66e13af4917862a50b3c68af58a1c2", "filename": "compiler/rustc_mir/src/transform/large_enums.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/18144b66e1515fa1391b7c7034ba55c47511fb9e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flarge_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18144b66e1515fa1391b7c7034ba55c47511fb9e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flarge_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Flarge_enums.rs?ref=18144b66e1515fa1391b7c7034ba55c47511fb9e", "patch": "@@ -0,0 +1,212 @@\n+use crate::transform::MirPass;\n+use crate::util::patch::MirPatch;\n+use rustc_data_structures::stable_map::FxHashMap;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, Const, List, Ty, TyCtxt};\n+use rustc_span::def_id::DefId;\n+use rustc_target::abi::{Size, Variants};\n+\n+/// A pass that seeks to optimize unnecessary moves of large enum types, if there is a large\n+/// enough discrepanc between them\n+pub struct EnumSizeOpt<const DISCREPANCY: u64>;\n+\n+impl<'tcx, const D: u64> MirPass<'tcx> for EnumSizeOpt<D> {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        self.optim(tcx, body);\n+    }\n+}\n+\n+impl<const D: u64> EnumSizeOpt<D> {\n+    fn candidate<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        body_did: DefId,\n+    ) -> Option<(Size, u64, Vec<Size>)> {\n+        match ty.kind() {\n+            ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n+                let p_e = tcx.param_env(body_did);\n+                // FIXME(jknodt) handle error better below\n+                let layout = tcx.layout_of(p_e.and(ty)).unwrap();\n+                let variants = &layout.variants;\n+                match variants {\n+                    Variants::Single { .. } => None,\n+                    Variants::Multiple { variants, .. } if variants.len() <= 1 => None,\n+                    Variants::Multiple { variants, .. } => {\n+                        let min = variants.iter().map(|v| v.size).min().unwrap();\n+                        let max = variants.iter().map(|v| v.size).max().unwrap();\n+                        if max.bytes() - min.bytes() < D {\n+                            return None;\n+                        }\n+                        Some((\n+                            layout.size,\n+                            variants.len() as u64,\n+                            variants.iter().map(|v| v.size).collect(),\n+                        ))\n+                    }\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+    fn optim(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let mut match_cache = FxHashMap::default();\n+        let body_did = body.source.def_id();\n+        let mut patch = MirPatch::new(body);\n+        let (bbs, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        for bb in bbs {\n+            bb.expand_statements(|st| {\n+                match &st.kind {\n+                    StatementKind::Assign(box (\n+                        lhs,\n+                        Rvalue::Use(Operand::Copy(rhs) | Operand::Move(rhs)),\n+                    )) => {\n+                        let ty = lhs.ty(local_decls, tcx).ty;\n+                        let (total_size, num_variants, sizes) =\n+                            if let Some((ts, nv, s)) = match_cache.get(ty) {\n+                                (*ts, *nv, s)\n+                            } else if let Some((ts, nv, s)) = Self::candidate(tcx, ty, body_did) {\n+                                // FIXME(jknodt) use entry API.\n+                                match_cache.insert(ty, (ts, nv, s));\n+                                let (ts, nv, s) = match_cache.get(ty).unwrap();\n+                                (*ts, *nv, s)\n+                            } else {\n+                                return None;\n+                            };\n+\n+                        let source_info = st.source_info;\n+                        let span = source_info.span;\n+\n+                        let tmp_ty = tcx.mk_ty(ty::Array(\n+                            tcx.types.usize,\n+                            Const::from_usize(tcx, num_variants),\n+                        ));\n+\n+                        let new_local = patch.new_temp(tmp_ty, span);\n+                        let store_live =\n+                            Statement { source_info, kind: StatementKind::StorageLive(new_local) };\n+\n+                        let place = Place { local: new_local, projection: List::empty() };\n+                        let mut data =\n+                            vec![0; std::mem::size_of::<usize>() * num_variants as usize];\n+                        data.copy_from_slice(unsafe { std::mem::transmute(&sizes[..]) });\n+                        let alloc = interpret::Allocation::from_bytes(\n+                            data,\n+                            tcx.data_layout.ptr_sized_integer().align(&tcx.data_layout).abi,\n+                        );\n+                        let alloc = tcx.intern_const_alloc(alloc);\n+                        let constant_vals = Constant {\n+                            span,\n+                            user_ty: None,\n+                            literal: ConstantKind::Val(\n+                                interpret::ConstValue::ByRef { alloc, offset: Size::ZERO },\n+                                tmp_ty,\n+                            ),\n+                        };\n+                        let rval = Rvalue::Use(Operand::Constant(box (constant_vals)));\n+\n+                        let const_assign = Statement {\n+                            source_info,\n+                            kind: StatementKind::Assign(box (place, rval)),\n+                        };\n+\n+                        // FIXME(jknodt) do I need to add a storage live here for this place?\n+                        let discr_place = Place {\n+                            local: patch.new_temp(tcx.types.usize, span),\n+                            projection: List::empty(),\n+                        };\n+\n+                        let store_discr = Statement {\n+                            source_info,\n+                            kind: StatementKind::Assign(box (\n+                                discr_place,\n+                                Rvalue::Discriminant(*rhs),\n+                            )),\n+                        };\n+\n+                        // FIXME(jknodt) do I need to add a storage live here for this place?\n+                        let size_place = Place {\n+                            local: patch.new_temp(tcx.types.usize, span),\n+                            projection: List::empty(),\n+                        };\n+\n+                        let store_size = Statement {\n+                            source_info,\n+                            kind: StatementKind::Assign(box (\n+                                size_place,\n+                                Rvalue::Use(Operand::Copy(Place {\n+                                    local: discr_place.local,\n+                                    projection: tcx\n+                                        .intern_place_elems(&[PlaceElem::Index(size_place.local)]),\n+                                })),\n+                            )),\n+                        };\n+\n+                        // FIXME(jknodt) do I need to add a storage live here for this place?\n+                        let dst = Place {\n+                            local: patch.new_temp(tcx.mk_mut_ptr(tcx.types.u8), span),\n+                            projection: List::empty(),\n+                        };\n+\n+                        let dst_ptr = Statement {\n+                            source_info,\n+                            kind: StatementKind::Assign(box (\n+                                dst,\n+                                Rvalue::AddressOf(Mutability::Mut, *lhs),\n+                            )),\n+                        };\n+\n+                        // FIXME(jknodt) do I need to add a storage live here for this place?\n+                        let src = Place {\n+                            local: patch.new_temp(tcx.mk_imm_ptr(tcx.types.u8), span),\n+                            projection: List::empty(),\n+                        };\n+\n+                        let src_ptr = Statement {\n+                            source_info,\n+                            kind: StatementKind::Assign(box (\n+                                src,\n+                                Rvalue::AddressOf(Mutability::Mut, *rhs),\n+                            )),\n+                        };\n+\n+                        let copy_bytes = Statement {\n+                            source_info,\n+                            kind: StatementKind::CopyNonOverlapping(box CopyNonOverlapping {\n+                                src: Operand::Copy(src),\n+                                dst: Operand::Copy(src),\n+                                count: Operand::Constant(\n+                                    box (Constant {\n+                                        span,\n+                                        user_ty: None,\n+                                        literal: ConstantKind::Val(\n+                                            interpret::ConstValue::from_u64(total_size.bytes()),\n+                                            tcx.types.usize,\n+                                        ),\n+                                    }),\n+                                ),\n+                            }),\n+                        };\n+\n+                        let store_dead =\n+                            Statement { source_info, kind: StatementKind::StorageDead(new_local) };\n+                        let iter = std::array::IntoIter::new([\n+                            store_live,\n+                            const_assign,\n+                            store_discr,\n+                            store_size,\n+                            dst_ptr,\n+                            src_ptr,\n+                            copy_bytes,\n+                            store_dead,\n+                        ]);\n+\n+                        st.make_nop();\n+                        Some(iter)\n+                    }\n+                    _ => return None,\n+                }\n+            });\n+        }\n+        patch.apply(body);\n+    }\n+}"}]}