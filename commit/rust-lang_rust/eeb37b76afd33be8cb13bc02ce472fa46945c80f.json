{"sha": "eeb37b76afd33be8cb13bc02ce472fa46945c80f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYjM3Yjc2YWZkMzNiZThjYjEzYmMwMmNlNDcyZmE0Njk0NWM4MGY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-09T11:42:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:07Z"}, "message": "De-@ reachable.", "tree": {"sha": "562b5bfd823c10b7db25511998e85c7a350f2f46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/562b5bfd823c10b7db25511998e85c7a350f2f46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb37b76afd33be8cb13bc02ce472fa46945c80f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb37b76afd33be8cb13bc02ce472fa46945c80f", "html_url": "https://github.com/rust-lang/rust/commit/eeb37b76afd33be8cb13bc02ce472fa46945c80f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb37b76afd33be8cb13bc02ce472fa46945c80f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c42ef31dc7f3469bce7f6844069882b0029580e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c42ef31dc7f3469bce7f6844069882b0029580e", "html_url": "https://github.com/rust-lang/rust/commit/6c42ef31dc7f3469bce7f6844069882b0029580e"}], "stats": {"total": 217, "additions": 69, "deletions": 148}, "files": [{"sha": "6c1c38aa897336f4ca63804b7615e6e213d16ef6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=eeb37b76afd33be8cb13bc02ce472fa46945c80f", "patch": "@@ -276,7 +276,7 @@ pub struct CrateAnalysis {\n     public_items: middle::privacy::PublicItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n-    reachable: @RefCell<NodeSet>,\n+    reachable: NodeSet,\n }\n \n /// Run the resolution, typechecking, region checking and other\n@@ -377,16 +377,13 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         time(time_passes, \"reachability checking\", (), |_|\n              reachable::find_reachable(&ty_cx, method_map, &exported_items));\n \n-    {\n-        let reachable_map = reachable_map.borrow();\n-        time(time_passes, \"death checking\", (), |_| {\n-             middle::dead::check_crate(&ty_cx,\n-                                       method_map,\n-                                       &exported_items,\n-                                       reachable_map.get(),\n-                                       krate)\n-        });\n-    }\n+    time(time_passes, \"death checking\", (), |_| {\n+        middle::dead::check_crate(&ty_cx,\n+                                  method_map,\n+                                  &exported_items,\n+                                  &reachable_map,\n+                                  krate)\n+    });\n \n     time(time_passes, \"lint checking\", (), |_|\n          lint::check_crate(&ty_cx, method_map, &exported_items, krate));"}, {"sha": "44a0fb61b243384b8f9c96d9749a22863a7ec22d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 41, "deletions": 91, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=eeb37b76afd33be8cb13bc02ce472fa46945c80f", "patch": "@@ -20,7 +20,6 @@ use middle::typeck;\n use middle::privacy;\n use util::nodemap::NodeSet;\n \n-use std::cell::RefCell;\n use std::vec_ng::Vec;\n use collections::HashSet;\n use syntax::ast;\n@@ -90,27 +89,19 @@ struct ReachableContext<'a> {\n     // methods they've been resolved to.\n     method_map: typeck::MethodMap,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: @RefCell<NodeSet>,\n+    reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @RefCell<Vec<ast::NodeId> >,\n+    worklist: Vec<ast::NodeId>,\n }\n \n-struct MarkSymbolVisitor<'a> {\n-    worklist: @RefCell<Vec<ast::NodeId>>,\n-    method_map: typeck::MethodMap,\n-    tcx: &'a ty::ctxt,\n-    reachable_symbols: @RefCell<NodeSet>,\n-}\n-\n-impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n+impl<'a> Visitor<()> for ReachableContext<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n \n         match expr.node {\n             ast::ExprPath(_) => {\n-                let def_map = self.tcx.def_map.borrow();\n-                let def = match def_map.get().find(&expr.id) {\n+                let def = match self.tcx.def_map.borrow().get().find(&expr.id) {\n                     Some(&def) => def,\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n@@ -120,29 +111,22 @@ impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n \n                 let def_id = def_id_of_def(def);\n                 if is_local(def_id) {\n-                    if ReachableContext::\n-                        def_id_represents_local_inlined_item(self.tcx, def_id) {\n-                            {\n-                                let mut worklist = self.worklist.borrow_mut();\n-                                worklist.get().push(def_id.node)\n-                            }\n+                    if self.def_id_represents_local_inlined_item(def_id) {\n+                        self.worklist.push(def_id.node)\n                     } else {\n                         match def {\n                             // If this path leads to a static, then we may have\n                             // to do some work to figure out whether the static\n                             // is indeed reachable (address_insignificant\n                             // statics are *never* reachable).\n                             ast::DefStatic(..) => {\n-                                let mut worklist = self.worklist.borrow_mut();\n-                                worklist.get().push(def_id.node);\n+                                self.worklist.push(def_id.node);\n                             }\n \n                             // If this wasn't a static, then this destination is\n                             // surely reachable.\n                             _ => {\n-                                let mut reachable_symbols =\n-                                    self.reachable_symbols.borrow_mut();\n-                                reachable_symbols.get().insert(def_id.node);\n+                                self.reachable_symbols.insert(def_id.node);\n                             }\n                         }\n                     }\n@@ -153,13 +137,10 @@ impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n                 match self.method_map.borrow().get().get(&method_call).origin {\n                     typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n-                            if ReachableContext::\n-                                def_id_represents_local_inlined_item(\n-                                    self.tcx,\n-                                    def_id) {\n-                                self.worklist.borrow_mut().get().push(def_id.node)\n+                            if self.def_id_represents_local_inlined_item(def_id) {\n+                                self.worklist.push(def_id.node)\n                             }\n-                            self.reachable_symbols.borrow_mut().get().insert(def_id.node);\n+                            self.reachable_symbols.insert(def_id.node);\n                         }\n                     }\n                     _ => {}\n@@ -183,21 +164,20 @@ impl<'a> ReachableContext<'a> {\n         ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n-            reachable_symbols: @RefCell::new(NodeSet::new()),\n-            worklist: @RefCell::new(Vec::new()),\n+            reachable_symbols: NodeSet::new(),\n+            worklist: Vec::new(),\n         }\n     }\n \n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n-    fn def_id_represents_local_inlined_item(tcx: &ty::ctxt, def_id: ast::DefId)\n-                                            -> bool {\n+    fn def_id_represents_local_inlined_item(&self, def_id: ast::DefId) -> bool {\n         if def_id.krate != ast::LOCAL_CRATE {\n             return false\n         }\n \n         let node_id = def_id.node;\n-        match tcx.map.find(node_id) {\n+        match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n                     ast::ItemFn(..) => item_might_be_inlined(item),\n@@ -215,11 +195,11 @@ impl<'a> ReachableContext<'a> {\n                         attributes_specify_inlining(method.attrs.as_slice()) {\n                     true\n                 } else {\n-                    let impl_did = tcx.map.get_parent_did(node_id);\n+                    let impl_did = self.tcx.map.get_parent_did(node_id);\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n                     assert!(impl_did.krate == ast::LOCAL_CRATE);\n-                    match tcx.map.expect_item(impl_did.node).node {\n+                    match self.tcx.map.expect_item(impl_did.node).node {\n                         ast::ItemImpl(ref generics, _, _, _) => {\n                             generics_require_inlining(generics)\n                         }\n@@ -232,40 +212,21 @@ impl<'a> ReachableContext<'a> {\n         }\n     }\n \n-    // Helper function to set up a visitor for `propagate()` below.\n-    fn init_visitor(&self) -> MarkSymbolVisitor<'a> {\n-        let (worklist, method_map) = (self.worklist, self.method_map);\n-        let (tcx, reachable_symbols) = (self.tcx, self.reachable_symbols);\n-\n-        MarkSymbolVisitor {\n-            worklist: worklist,\n-            method_map: method_map,\n-            tcx: tcx,\n-            reachable_symbols: reachable_symbols,\n-        }\n-    }\n-\n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n-    fn propagate(&self) {\n-        let mut visitor = self.init_visitor();\n+    fn propagate(&mut self) {\n         let mut scanned = HashSet::new();\n         loop {\n-            let search_item = {\n-                let mut worklist = self.worklist.borrow_mut();\n-                if worklist.get().len() == 0 {\n-                    break\n-                }\n-                let search_item = worklist.get().pop().unwrap();\n-                if scanned.contains(&search_item) {\n-                    continue\n-                }\n-                search_item\n-            };\n+            if self.worklist.len() == 0 {\n+                break\n+            }\n+            let search_item = self.worklist.pop().unwrap();\n+            if scanned.contains(&search_item) {\n+                continue\n+            }\n \n             scanned.insert(search_item);\n             match self.tcx.map.find(search_item) {\n-                Some(ref item) => self.propagate_node(item, search_item,\n-                                                  &mut visitor),\n+                Some(ref item) => self.propagate_node(item, search_item),\n                 None if search_item == ast::CRATE_NODE_ID => {}\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n@@ -276,9 +237,8 @@ impl<'a> ReachableContext<'a> {\n         }\n     }\n \n-    fn propagate_node(&self, node: &ast_map::Node,\n-                      search_item: ast::NodeId,\n-                      visitor: &mut MarkSymbolVisitor) {\n+    fn propagate_node(&mut self, node: &ast_map::Node,\n+                      search_item: ast::NodeId) {\n         if !self.tcx.sess.building_library.get() {\n             // If we are building an executable, then there's no need to flag\n             // anything as external except for `extern fn` types. These\n@@ -289,9 +249,7 @@ impl<'a> ReachableContext<'a> {\n                 ast_map::NodeItem(item) => {\n                     match item.node {\n                         ast::ItemFn(_, ast::ExternFn, _, _, _) => {\n-                            let mut reachable_symbols =\n-                                self.reachable_symbols.borrow_mut();\n-                            reachable_symbols.get().insert(search_item);\n+                            self.reachable_symbols.insert(search_item);\n                         }\n                         _ => {}\n                     }\n@@ -303,16 +261,15 @@ impl<'a> ReachableContext<'a> {\n             // continue to participate in linkage after this product is\n             // produced. In this case, we traverse the ast node, recursing on\n             // all reachable nodes from this one.\n-            let mut reachable_symbols = self.reachable_symbols.borrow_mut();\n-            reachable_symbols.get().insert(search_item);\n+            self.reachable_symbols.insert(search_item);\n         }\n \n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n                     ast::ItemFn(_, _, _, _, search_block) => {\n                         if item_might_be_inlined(item) {\n-                            visit::walk_block(visitor, search_block, ())\n+                            visit::walk_block(self, search_block, ())\n                         }\n                     }\n \n@@ -321,9 +278,7 @@ impl<'a> ReachableContext<'a> {\n                     ast::ItemStatic(..) => {\n                         if attr::contains_name(item.attrs.as_slice(),\n                                                \"address_insignificant\") {\n-                            let mut reachable_symbols =\n-                                self.reachable_symbols.borrow_mut();\n-                            reachable_symbols.get().remove(&search_item);\n+                            self.reachable_symbols.remove(&search_item);\n                         }\n                     }\n \n@@ -348,14 +303,14 @@ impl<'a> ReachableContext<'a> {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::Provided(ref method) => {\n-                        visit::walk_block(visitor, method.body, ())\n+                        visit::walk_block(self, method.body, ())\n                     }\n                 }\n             }\n             ast_map::NodeMethod(method) => {\n                 let did = self.tcx.map.get_parent_did(search_item);\n                 if method_might_be_inlined(self.tcx, method, did) {\n-                    visit::walk_block(visitor, method.body, ())\n+                    visit::walk_block(self, method.body, ())\n                 }\n             }\n             // Nothing to recurse on for these\n@@ -375,13 +330,10 @@ impl<'a> ReachableContext<'a> {\n     // FIXME(pcwalton): This is a conservative overapproximation, but fixing\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n-    fn mark_destructors_reachable(&self) {\n-        let destructor_for_type = self.tcx.destructor_for_type.borrow();\n-        for (_, destructor_def_id) in destructor_for_type.get().iter() {\n+    fn mark_destructors_reachable(&mut self) {\n+        for (_, destructor_def_id) in self.tcx.destructor_for_type.borrow().get().iter() {\n             if destructor_def_id.krate == ast::LOCAL_CRATE {\n-                let mut reachable_symbols = self.reachable_symbols\n-                                                .borrow_mut();\n-                reachable_symbols.get().insert(destructor_def_id.node);\n+                self.reachable_symbols.insert(destructor_def_id.node);\n             }\n         }\n     }\n@@ -390,27 +342,25 @@ impl<'a> ReachableContext<'a> {\n pub fn find_reachable(tcx: &ty::ctxt,\n                       method_map: typeck::MethodMap,\n                       exported_items: &privacy::ExportedItems)\n-                      -> @RefCell<NodeSet> {\n-    let reachable_context = ReachableContext::new(tcx, method_map);\n+                      -> NodeSet {\n+    let mut reachable_context = ReachableContext::new(tcx, method_map);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as\n     //         a result of the privacy pass along with all local lang items. If\n     //         other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    let mut worklist = reachable_context.worklist.borrow_mut();\n     for &id in exported_items.iter() {\n-        worklist.get().push(id);\n+        reachable_context.worklist.push(id);\n     }\n     for (_, item) in tcx.lang_items.items() {\n         match *item {\n             Some(did) if is_local(did) => {\n-                worklist.get().push(did.node);\n+                reachable_context.worklist.push(did.node);\n             }\n             _ => {}\n         }\n     }\n-    drop(worklist);\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     reachable_context.propagate();"}, {"sha": "6dff780cc3c883a293fa5e21a0af7a76101ddddd", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=eeb37b76afd33be8cb13bc02ce472fa46945c80f", "patch": "@@ -1785,16 +1785,10 @@ pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n \n fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n-    {\n-        let mut item_symbols = ccx.item_symbols.borrow_mut();\n-        item_symbols.get().insert(node_id, sym);\n-    }\n+    ccx.item_symbols.borrow_mut().get().insert(node_id, sym);\n \n-    {\n-        let reachable = ccx.reachable.borrow();\n-        if !reachable.get().contains(&node_id) {\n-            lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n-        }\n+    if !ccx.reachable.contains(&node_id) {\n+        lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     }\n \n     if is_entry_fn(ccx.sess(), node_id) && !ccx.sess().building_library.get() {\n@@ -1995,27 +1989,17 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n                                 });\n \n-                                {\n-                                    let reachable = ccx.reachable.borrow();\n-                                    if !reachable.get().contains(&id) {\n-                                        lib::llvm::SetLinkage(\n-                                            g,\n-                                            lib::llvm::InternalLinkage);\n-                                    }\n+                                if !ccx.reachable.contains(&id) {\n+                                    lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n                                 }\n \n                                 // Apply the `unnamed_addr` attribute if\n                                 // requested\n                                 if attr::contains_name(i.attrs.as_slice(),\n-                                                       \"address_insignificant\"){\n-                                    {\n-                                        let reachable =\n-                                            ccx.reachable.borrow();\n-                                        if reachable.get().contains(&id) {\n-                                            ccx.sess().span_bug(i.span,\n-                                                \"insignificant static is \\\n-                                                 reachable\");\n-                                        }\n+                                                       \"address_insignificant\") {\n+                                    if ccx.reachable.contains(&id) {\n+                                        ccx.sess().span_bug(i.span,\n+                                            \"insignificant static is reachable\");\n                                     }\n                                     lib::llvm::SetUnnamedAddr(g, true);\n \n@@ -2180,11 +2164,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             // foreign items (extern fns and extern statics) don't have internal\n             // linkage b/c that doesn't quite make sense. Otherwise items can\n             // have internal linkage if they're not reachable.\n-            {\n-                let reachable = ccx.reachable.borrow();\n-                if !foreign && !reachable.get().contains(&id) {\n-                    lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n-                }\n+            if !foreign && !ccx.reachable.contains(&id) {\n+                lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n             }\n \n             let mut item_vals = ccx.item_vals.borrow_mut();\n@@ -2557,7 +2538,7 @@ pub fn trans_crate(krate: ast::Crate,\n                                  analysis.maps,\n                                  Sha256::new(),\n                                  link_meta,\n-                                 analysis.reachable);\n+                                 &analysis.reachable);\n     {\n         let _icx = push_ctxt(\"text\");\n         trans_mod(ccx, &krate.module);\n@@ -2627,13 +2608,9 @@ pub fn trans_crate(krate: ast::Crate,\n     let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n \n-    let mut reachable: Vec<~str> = {\n-        let reachable_map = ccx.reachable.borrow();\n-        reachable_map.get().iter().filter_map(|id| {\n-            let item_symbols = ccx.item_symbols.borrow();\n-            item_symbols.get().find(id).map(|s| s.to_owned())\n-        }).collect()\n-    };\n+    let mut reachable: Vec<~str> = ccx.reachable.iter().filter_map(|id| {\n+        ccx.item_symbols.borrow().get().find(id).map(|s| s.to_owned())\n+    }).collect();\n \n     // Make sure that some other crucial symbols are not eliminated from the\n     // module. This includes the main function, the crate map (used for debug\n@@ -2647,12 +2624,12 @@ pub fn trans_crate(krate: ast::Crate,\n     reachable.push(~\"rust_eh_personality\"); // referenced from .eh_frame section on some platforms\n     reachable.push(~\"rust_eh_personality_catch\"); // referenced from rt/rust_try.ll\n \n-    return CrateTranslation {\n+    CrateTranslation {\n         context: llcx,\n         module: llmod,\n         link: link_meta,\n         metadata_module: ccx.metadata_llmod,\n         metadata: metadata,\n         reachable: reachable,\n-    };\n+    }\n }"}, {"sha": "1d257cfefcc8bc53535763c2c103d0d7a08f047f", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=eeb37b76afd33be8cb13bc02ce472fa46945c80f", "patch": "@@ -48,7 +48,7 @@ pub struct CrateContext<'a> {\n     intrinsics: HashMap<&'static str, ValueRef>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n     exp_map2: resolve::ExportMap2,\n-    reachable: @RefCell<NodeSet>,\n+    reachable: &'a NodeSet,\n     item_symbols: RefCell<NodeMap<~str>>,\n     link_meta: LinkMeta,\n     drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n@@ -123,7 +123,7 @@ impl<'a> CrateContext<'a> {\n                maps: astencode::Maps,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n-               reachable: @RefCell<NodeSet>)\n+               reachable: &'a NodeSet)\n                -> CrateContext<'a> {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();"}, {"sha": "a917cdd7df75b1bc8f5d66191d44afd98e5550bd", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb37b76afd33be8cb13bc02ce472fa46945c80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=eeb37b76afd33be8cb13bc02ce472fa46945c80f", "patch": "@@ -652,10 +652,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     // (by being externally visible or by being inlined into something externally visible). It might\n     // better to use the `exported_items` set from `driver::CrateAnalysis` in the future, but (atm)\n     // this set is not available in the translation pass.\n-    let is_local_to_unit = {\n-        let reachable = cx.reachable.borrow();\n-        !reachable.get().contains(&fn_ast_id)\n-    };\n+    let is_local_to_unit = !cx.reachable.contains(&fn_ast_id);\n \n     let fn_metadata = function_name.with_c_str(|function_name| {\n                           linkage_name.with_c_str(|linkage_name| {"}]}