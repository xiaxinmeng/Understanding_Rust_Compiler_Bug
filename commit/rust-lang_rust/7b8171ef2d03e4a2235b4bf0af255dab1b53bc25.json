{"sha": "7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiODE3MWVmMmQwM2U0YTIyMzViNGJmMGFmMjU1ZGFiMWI1M2JjMjU=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-18T00:03:27Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-18T00:46:31Z"}, "message": "Added liveness analysis for protocols, and removed warnings about empty states.", "tree": {"sha": "54194e622a33eacd1c3e04db66304a7c1e60fad0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54194e622a33eacd1c3e04db66304a7c1e60fad0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "html_url": "https://github.com/rust-lang/rust/commit/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c858eb06546ce2be77fd284f707f76cb820c6211", "url": "https://api.github.com/repos/rust-lang/rust/commits/c858eb06546ce2be77fd284f707f76cb820c6211", "html_url": "https://github.com/rust-lang/rust/commit/c858eb06546ce2be77fd284f707f76cb820c6211"}], "stats": {"total": 149, "additions": 130, "deletions": 19}, "files": [{"sha": "f7efe70b5dcf1e07f545053be33ece6b1a8404a5", "filename": "src/libcore/future.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -81,7 +81,7 @@ fn from_port<A:send>(-port: future_pipe::client::waiting<A>) -> future<A> {\n         port_ <-> *port;\n         let port = option::unwrap(port_);\n         alt recv(port) {\n-          future_pipe::completed(data, _next) { #move(data) }\n+          future_pipe::completed(data) { #move(data) }\n         }\n     }\n }\n@@ -135,10 +135,8 @@ fn with<A,B>(future: future<A>, blk: fn(A) -> B) -> B {\n \n proto! future_pipe {\n     waiting:recv<T:send> {\n-        completed(T) -> terminated\n+        completed(T) -> !\n     }\n-\n-    terminated:send { }\n }\n \n #[test]"}, {"sha": "1a3d5e0811392d2c98b5019a0302611eebd9db66", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -253,6 +253,14 @@ impl methods for bitv {\n     fn each(f: fn(bool) -> bool) { each(self, f) }\n     fn each_storage(f: fn(&uint) -> bool) { each_storage(self, f) }\n     fn eq_vec(v: ~[uint]) -> bool { eq_vec(self, v) }\n+\n+    fn ones(f: fn(uint) -> bool) {\n+        for uint::range(0, self.nbits) |i| {\n+            if self.get(i) {\n+                if !f(i) { break }\n+            }\n+        }\n+    }\n }\n \n impl of to_str::to_str for bitv {"}, {"sha": "5a1462cea3097e0a18837f14ab52b60187a28105", "filename": "src/libsyntax/ext/pipes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -27,6 +27,9 @@ fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n     // check for errors\n     visit(proto, cx);\n \n+    // do analysis\n+    liveness::analyze(proto, cx);\n+\n     // compile\n     base::mr_item(proto.compile(cx))\n }"}, {"sha": "4f80399252021b1287bf76d6c7996518d6200927", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -0,0 +1,91 @@\n+/*\n+\n+Liveness analysis for protocols. This is useful for a lot of possible\n+optimizations.\n+\n+This analysis computes the \"co-live\" relationship between\n+states. Co-live is defined inductively as follows.\n+\n+1. u is co-live with v if u can transition to v in one message.\n+\n+2. u is co-live with v if there exists a w such that u and w are\n+co-live, w and v are co-live, and u and w have the same direction.\n+\n+This relationship approximates when it is safe to store two states in\n+the same memory location. If there is no u such u is co-live with\n+itself, then the protocol is bounded.\n+\n+(These assertions could use proofs)\n+\n+In addition, this analysis does reachability, to warn when we have\n+useless states.\n+\n+The algorithm is a fixpoint computation. For each state, we initialize\n+a bitvector containing whether it is co-live with each other state. At\n+first we use rule (1) above to set each vector. Then we iterate\n+updating the states using rule (2) until there are no changes.\n+\n+*/\n+\n+import dvec::extensions;\n+\n+import std::bitv::{bitv, methods};\n+\n+import proto::methods;\n+import ast_builder::empty_span;\n+\n+fn analyze(proto: protocol, _cx: ext_ctxt) {\n+    #debug(\"initializing colive analysis\");\n+    let num_states = proto.num_states();\n+    let colive = do (copy proto.states).map_to_vec |state| {\n+        let bv = bitv(num_states, false);\n+        for state.reachable |s| {\n+            bv.set(s.id, true);\n+        }\n+        bv\n+    };\n+\n+    let mut i = 0;\n+    let mut changed = true;\n+    while changed {\n+        changed = false;\n+        #debug(\"colive iteration %?\", i);\n+        for colive.eachi |i, this_colive| {\n+            let this = proto.get_state_by_id(i);\n+            for this_colive.ones |j| {\n+                let next = proto.get_state_by_id(j);\n+                if this.dir == next.dir {\n+                    changed = changed || this_colive.union(colive[j]);\n+                }\n+            }\n+        }\n+        i += 1;\n+    }\n+\n+    #debug(\"colive analysis complete\");\n+\n+    // Determine if we're bounded\n+    let mut self_live = ~[];\n+    for colive.eachi |i, bv| {\n+        if bv.get(i) {\n+            vec::push(self_live, proto.get_state_by_id(i))\n+        }\n+    }\n+\n+    if self_live.len() > 0 {\n+        let states = str::connect(self_live.map(|s| *s.name), ~\" \");\n+\n+        #debug(\"protocol %s is unbounded due to loops involving: %s\",\n+               *proto.name, states);\n+\n+        // Someday this will be configurable with a warning\n+        //cx.span_warn(empty_span(),\n+        //              #fmt(\"protocol %s is unbounded due to loops \\\n+        //                    involving these states: %s\",\n+        //                   *proto.name,\n+        //                   states));\n+    }\n+    else {\n+        #debug(\"protocol %s is bounded. yay!\", *proto.name);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "e9070c79b558ffdbee52b1190712ddb4ab543569", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -55,6 +55,7 @@ impl methods for message {\n \n enum state {\n     state_(@{\n+        id: uint,\n         name: ident,\n         dir: direction,\n         ty_params: ~[ast::ty_param],\n@@ -81,6 +82,20 @@ impl methods for state {\n         cx.ty_path_ast_builder\n             (path(self.name).add_tys(cx.ty_vars(self.ty_params)))\n     }\n+\n+    /// Iterate over the states that can be reached in one message\n+    /// from this state.\n+    fn reachable(f: fn(state) -> bool) {\n+        for self.messages.each |m| {\n+            alt m {\n+              message(_, _, _, some({state: id, _})) {\n+                let state = self.proto.get_state(id);\n+                if !f(state) { break }\n+              }\n+              _ { }\n+            }\n+        }\n+    }\n }\n \n enum protocol {\n@@ -104,6 +119,8 @@ impl methods for protocol {\n         self.states.find(|i| i.name == name).get()\n     }\n \n+    fn get_state_by_id(id: uint) -> state { self.states[id] }\n+\n     fn has_state(name: ident) -> bool {\n         self.states.find(|i| i.name == name) != none\n     }\n@@ -113,6 +130,7 @@ impl methods for protocol {\n         let messages = dvec();\n \n         let state = state_(@{\n+            id: self.states.len(),\n             name: name,\n             dir: dir,\n             ty_params: ty_params,\n@@ -127,6 +145,8 @@ impl methods for protocol {\n     fn filename() -> ~str {\n         ~\"proto://\" + *self.name\n     }\n+\n+    fn num_states() -> uint { self.states.len() }\n }\n \n trait visitor<Tproto, Tstate, Tmessage> {"}, {"sha": "10ff0d336c2d35166f9923b1aa6d46f1de83d98d", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -87,5 +87,6 @@ mod ext {\n         mod pipec;\n         mod proto;\n         mod check;\n+        mod liveness;\n     }\n }"}, {"sha": "db8cde820ac43884b9715039c14870b6ae76128b", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -11,16 +11,14 @@ import pipes::{try_recv, recv};\n \n proto! oneshot {\n     waiting:send {\n-        signal -> signaled\n+        signal -> !\n     }\n-\n-    signaled:send { }\n }\n \n fn main() {\n     let iotask = uv::global_loop::get();\n     \n-    let c = pipes::spawn_service(oneshot::init, |p| { \n+    pipes::spawn_service(oneshot::init, |p| { \n         alt try_recv(p) {\n           some(*) { fail }\n           none { }\n@@ -36,8 +34,6 @@ fn main() {\n \n // Make sure the right thing happens during failure.\n fn failtest() {\n-    let iotask = uv::global_loop::get();\n-    \n     let (c, p) = oneshot::init();\n \n     do task::spawn_with(c) |_c| { "}, {"sha": "4515262743419d4f10be0fd529e6e1e75d2c611b", "filename": "src/test/run-pass/pipe-peek.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-peek.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -6,10 +6,8 @@ import std::uv;\n \n proto! oneshot {\n     waiting:send {\n-        signal -> signaled\n+        signal -> !\n     }\n-\n-    signaled:send { }\n }\n \n fn main() {"}, {"sha": "056b0cb477a681f25e1233d1227a7f78022c58b1", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -11,8 +11,6 @@ proto! oneshot {\n     waiting:send {\n         signal -> !\n     }\n-\n-    signaled:send { }\n }\n \n proto! stream {"}, {"sha": "3ef0f4a4a641021397d9714b3d42f930fa1411ff", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b8171ef2d03e4a2235b4bf0af255dab1b53bc25/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=7b8171ef2d03e4a2235b4bf0af255dab1b53bc25", "patch": "@@ -7,10 +7,8 @@ import pipes::recv;\n \n proto! oneshot {\n     waiting:send {\n-        signal -> signaled\n+        signal -> !\n     }\n-\n-    signaled:send { }\n }\n \n fn main() {\n@@ -19,7 +17,7 @@ fn main() {\n     let c = pipes::spawn_service(oneshot::init, |p| { recv(p); });\n \n     let iotask = uv::global_loop::get();\n-    sleep(iotask, 5000);\n+    sleep(iotask, 500);\n     \n     signal(c);\n }\n\\ No newline at end of file"}]}