{"sha": "4b3262f514066ef8ac5ad82b445f111b91fe3990", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMzI2MmY1MTQwNjZlZjhhYzVhZDgyYjQ0NWYxMTFiOTFmZTM5OTA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-01T03:39:37Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-01T03:39:37Z"}, "message": "Add a test module to comments", "tree": {"sha": "7b9b66b220df7cb851e0f12cdffffa12cf0af0e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b9b66b220df7cb851e0f12cdffffa12cf0af0e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b3262f514066ef8ac5ad82b445f111b91fe3990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3262f514066ef8ac5ad82b445f111b91fe3990", "html_url": "https://github.com/rust-lang/rust/commit/4b3262f514066ef8ac5ad82b445f111b91fe3990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b3262f514066ef8ac5ad82b445f111b91fe3990/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d24e91e3a2aeb0014fa041e474c84ad109213e", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d24e91e3a2aeb0014fa041e474c84ad109213e", "html_url": "https://github.com/rust-lang/rust/commit/71d24e91e3a2aeb0014fa041e474c84ad109213e"}], "stats": {"total": 140, "additions": 74, "deletions": 66}, "files": [{"sha": "f692337cacc45176f55e1943485a6751add4564c", "filename": "src/comment.rs", "status": "modified", "additions": 74, "deletions": 66, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/4b3262f514066ef8ac5ad82b445f111b91fe3990/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3262f514066ef8ac5ad82b445f111b91fe3990/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=4b3262f514066ef8ac5ad82b445f111b91fe3990", "patch": "@@ -93,26 +93,6 @@ fn left_trim_comment_line<'a>(line: &'a str) -> &'a str {\n     }\n }\n \n-#[test]\n-fn format_comments() {\n-    assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, 100));\n-    assert_eq!(\"// comment\\n// on a\", rewrite_comment(\"// comment on a\", false, 10, 0));\n-\n-    assert_eq!(\"//  A multi line comment\\n            // between args.\",\n-               rewrite_comment(\"//  A multi line comment\\n             // between args.\",\n-                               false,\n-                               60,\n-                               12));\n-\n-    let input = \"// comment\";\n-    let expected = \"/* com\\n                                                                      \\\n-                    * men\\n                                                                      \\\n-                    * t */\";\n-    assert_eq!(expected, rewrite_comment(input, true, 9, 69));\n-\n-    assert_eq!(\"/* trimmed */\", rewrite_comment(\"/*   trimmed    */\", true, 100, 100));\n-}\n-\n pub trait FindUncommented {\n     fn find_uncommented(&self, pat: &str) -> Option<usize>;\n }\n@@ -142,31 +122,6 @@ impl FindUncommented for str {\n     }\n }\n \n-#[test]\n-fn test_find_uncommented() {\n-    fn check(haystack: &str, needle: &str, expected: Option<usize>) {\n-        println!(\"haystack {:?}, needle: {:?}\", haystack, needle);\n-        assert_eq!(expected, haystack.find_uncommented(needle));\n-    }\n-\n-    check(\"/*/ */test\", \"test\", Some(6));\n-    check(\"//test\\ntest\", \"test\", Some(7));\n-    check(\"/* comment only */\", \"whatever\", None);\n-    check(\"/* comment */ some text /* more commentary */ result\", \"result\", Some(46));\n-    check(\"sup // sup\", \"p\", Some(2));\n-    check(\"sup\", \"x\", None);\n-    check(\"\u03c0? /**/ \u03c0 is nice!\", \"\u03c0 is nice\", Some(9));\n-    check(\"/*sup yo? \\n sup*/ sup\", \"p\", Some(20));\n-    check(\"hel/*lohello*/lo\", \"hello\", None);\n-    check(\"acb\", \"ab\", None);\n-    check(\",/*A*/ \", \",\", Some(0));\n-    check(\"abc\", \"abc\", Some(0));\n-    check(\"/* abc */\", \"abc\", None);\n-    check(\"/**/abc/* */\", \"abc\", Some(4));\n-    check(\"\\\"/* abc */\\\"\", \"abc\", Some(4));\n-    check(\"\\\"/* abc\", \"abc\", Some(4));\n-}\n-\n // Returns the first byte position after the first comment. The given string\n // is expected to be prefixed by a comment, including delimiters.\n // Good: \"/* /* inner */ outer */ code();\"\n@@ -204,27 +159,6 @@ pub fn contains_comment(text: &str) -> bool {\n     CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment )\n }\n \n-pub fn uncommented(text: &str) -> String {\n-    CharClasses::new(text.chars()).filter_map(|(s, c)| match s {\n-        CodeCharKind::Normal => Some(c),\n-        CodeCharKind::Comment => None\n-    }).collect()\n-}\n-\n-#[test]\n-fn test_uncommented() {\n-    assert_eq!(&uncommented(\"abc/*...*/\"), \"abc\");\n-    assert_eq!(&uncommented(\"// .... /* \\n../* /* *** / */ */a/* // */c\\n\"), \"..ac\\n\");\n-    assert_eq!(&uncommented(\"abc \\\" /* */\\\" qsdf\"), \"abc \\\" /* */\\\" qsdf\");\n-}\n-\n-#[test]\n-fn test_contains_comment() {\n-    assert_eq!(contains_comment(\"abc\"), false);\n-    assert_eq!(contains_comment(\"abc // qsdf\"), true);\n-    assert_eq!(contains_comment(\"abc /* kqsdf\"), true);\n-    assert_eq!(contains_comment(\"abc \\\" /* */\\\" qsdf\"), false);\n-}\n \n struct CharClasses<T>\n     where T: Iterator,\n@@ -358,3 +292,77 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n         return Some((CodeCharKind::Normal, item));\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented};\n+\n+    #[test]\n+    fn format_comments() {\n+        assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, 100));\n+        assert_eq!(\"// comment\\n// on a\", rewrite_comment(\"// comment on a\", false, 10, 0));\n+\n+        assert_eq!(\"//  A multi line comment\\n            // between args.\",\n+                   rewrite_comment(\"//  A multi line comment\\n             // between args.\",\n+                                   false,\n+                                   60,\n+                                   12));\n+\n+        let input = \"// comment\";\n+        let expected = \"/* com\\n                                                                      \\\n+                        * men\\n                                                                      \\\n+                        * t */\";\n+        assert_eq!(expected, rewrite_comment(input, true, 9, 69));\n+\n+        assert_eq!(\"/* trimmed */\", rewrite_comment(\"/*   trimmed    */\", true, 100, 100));\n+    }\n+\n+    // This is probably intended to be a non-test fn, but it is not used. I'm\n+    // keeping it around unless it helps us test stuff.\n+    fn uncommented(text: &str) -> String {\n+        CharClasses::new(text.chars()).filter_map(|(s, c)| match s {\n+            CodeCharKind::Normal => Some(c),\n+            CodeCharKind::Comment => None\n+        }).collect()\n+    }\n+\n+    #[test]\n+    fn test_uncommented() {\n+        assert_eq!(&uncommented(\"abc/*...*/\"), \"abc\");\n+        assert_eq!(&uncommented(\"// .... /* \\n../* /* *** / */ */a/* // */c\\n\"), \"..ac\\n\");\n+        assert_eq!(&uncommented(\"abc \\\" /* */\\\" qsdf\"), \"abc \\\" /* */\\\" qsdf\");\n+    }\n+\n+    #[test]\n+    fn test_contains_comment() {\n+        assert_eq!(contains_comment(\"abc\"), false);\n+        assert_eq!(contains_comment(\"abc // qsdf\"), true);\n+        assert_eq!(contains_comment(\"abc /* kqsdf\"), true);\n+        assert_eq!(contains_comment(\"abc \\\" /* */\\\" qsdf\"), false);\n+    }\n+\n+    #[test]\n+    fn test_find_uncommented() {\n+        fn check(haystack: &str, needle: &str, expected: Option<usize>) {\n+            println!(\"haystack {:?}, needle: {:?}\", haystack, needle);\n+            assert_eq!(expected, haystack.find_uncommented(needle));\n+        }\n+\n+        check(\"/*/ */test\", \"test\", Some(6));\n+        check(\"//test\\ntest\", \"test\", Some(7));\n+        check(\"/* comment only */\", \"whatever\", None);\n+        check(\"/* comment */ some text /* more commentary */ result\", \"result\", Some(46));\n+        check(\"sup // sup\", \"p\", Some(2));\n+        check(\"sup\", \"x\", None);\n+        check(\"\u03c0? /**/ \u03c0 is nice!\", \"\u03c0 is nice\", Some(9));\n+        check(\"/*sup yo? \\n sup*/ sup\", \"p\", Some(20));\n+        check(\"hel/*lohello*/lo\", \"hello\", None);\n+        check(\"acb\", \"ab\", None);\n+        check(\",/*A*/ \", \",\", Some(0));\n+        check(\"abc\", \"abc\", Some(0));\n+        check(\"/* abc */\", \"abc\", None);\n+        check(\"/**/abc/* */\", \"abc\", Some(4));\n+        check(\"\\\"/* abc */\\\"\", \"abc\", Some(4));\n+        check(\"\\\"/* abc\", \"abc\", Some(4));\n+    }\n+}"}]}