{"sha": "0c8d143515a19b04a404765ecb8145a183dc2186", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOGQxNDM1MTVhMTliMDRhNDA0NzY1ZWNiODE0NWExODNkYzIxODY=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T08:28:14Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:22Z"}, "message": "move into_iter_on_ref and single_char_pattern to their own modules", "tree": {"sha": "1614f4382d9f38301bb43a8d5176125770bdae57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1614f4382d9f38301bb43a8d5176125770bdae57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c8d143515a19b04a404765ecb8145a183dc2186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c8d143515a19b04a404765ecb8145a183dc2186", "html_url": "https://github.com/rust-lang/rust/commit/0c8d143515a19b04a404765ecb8145a183dc2186", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c8d143515a19b04a404765ecb8145a183dc2186/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "805aa47f43ab9b61a69f63682176604cdcda8fae", "url": "https://api.github.com/repos/rust-lang/rust/commits/805aa47f43ab9b61a69f63682176604cdcda8fae", "html_url": "https://github.com/rust-lang/rust/commit/805aa47f43ab9b61a69f63682176604cdcda8fae"}], "stats": {"total": 132, "additions": 74, "deletions": 58}, "files": [{"sha": "d94b243404c36ef8761524f80d4ca1e23a62bc05", "filename": "clippy_lints/src/methods/into_iter_on_ref.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0c8d143515a19b04a404765ecb8145a183dc2186/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8d143515a19b04a404765ecb8145a183dc2186/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=0c8d143515a19b04a404765ecb8145a183dc2186", "patch": "@@ -0,0 +1,42 @@\n+use crate::utils::{has_iter_method, match_trait_method, paths, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::source_map::Span;\n+\n+use super::INTO_ITER_ON_REF;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_>, method_span: Span) {\n+    if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n+        return;\n+    }\n+    if let Some((kind, method_name)) = ty_has_iter_method(cx, self_ref_ty) {\n+        span_lint_and_sugg(\n+            cx,\n+            INTO_ITER_ON_REF,\n+            method_span,\n+            &format!(\n+                \"this `.into_iter()` call is equivalent to `.{}()` and will not consume the `{}`\",\n+                method_name, kind,\n+            ),\n+            \"call directly\",\n+            method_name.to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(&'static str, &'static str)> {\n+    has_iter_method(cx, self_ref_ty).map(|ty_name| {\n+        let mutbl = match self_ref_ty.kind() {\n+            ty::Ref(_, _, mutbl) => mutbl,\n+            _ => unreachable!(),\n+        };\n+        let method_name = match mutbl {\n+            hir::Mutability::Not => \"iter\",\n+            hir::Mutability::Mut => \"iter_mut\",\n+        };\n+        (ty_name, method_name)\n+    })\n+}"}, {"sha": "28e2d896e6cdbb1ac45a52c76017eac6facb77d1", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 9, "deletions": 58, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0c8d143515a19b04a404765ecb8145a183dc2186/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8d143515a19b04a404765ecb8145a183dc2186/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=0c8d143515a19b04a404765ecb8145a183dc2186", "patch": "@@ -9,6 +9,7 @@ mod get_unwrap;\n mod implicit_clone;\n mod inefficient_to_string;\n mod inspect_for_each;\n+mod into_iter_on_ref;\n mod iter_cloned_collect;\n mod iter_count;\n mod iter_next_slice;\n@@ -21,6 +22,7 @@ mod ok_expect;\n mod option_as_ref_deref;\n mod option_map_unwrap_or;\n mod single_char_insert_string;\n+mod single_char_pattern;\n mod single_char_push_string;\n mod skip_while_next;\n mod string_extend_chars;\n@@ -53,12 +55,11 @@ use rustc_typeck::hir_ty_to_ty;\n use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    contains_return, contains_ty, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro,\n-    is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath,\n-    match_trait_method, match_type, meets_msrv, method_calls, method_chain_args, path_to_local_id, paths,\n-    remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, strip_pat_refs, sugg, walk_ptrs_ty_depth,\n-    SpanlessEq,\n+    contains_return, contains_ty, get_parent_expr, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of,\n+    is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_trait_method,\n+    match_type, meets_msrv, method_calls, method_chain_args, path_to_local_id, paths, remove_blocks, return_ty,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, strip_pat_refs, sugg, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1789,12 +1790,12 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     ty::Ref(_, ty, _) if *ty.kind() == ty::Str => {\n                         for &(method, pos) in &PATTERN_METHODS {\n                             if method_call.ident.name.as_str() == method && args.len() > pos {\n-                                lint_single_char_pattern(cx, expr, &args[pos]);\n+                                single_char_pattern::check(cx, expr, &args[pos]);\n                             }\n                         }\n                     },\n                     ty::Ref(..) if method_call.ident.name == sym::into_iter => {\n-                        lint_into_iter(cx, expr, self_ty, *method_span);\n+                        into_iter_on_ref::check(cx, expr, self_ty, *method_span);\n                     },\n                     _ => (),\n                 }\n@@ -3202,22 +3203,6 @@ fn get_hint_if_single_char_arg(\n     }\n }\n \n-/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-fn lint_single_char_pattern(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    if let Some(hint) = get_hint_if_single_char_arg(cx, arg, &mut applicability) {\n-        span_lint_and_sugg(\n-            cx,\n-            SINGLE_CHAR_PATTERN,\n-            arg.span,\n-            \"single-character string constant used as pattern\",\n-            \"try using a `char` instead\",\n-            hint,\n-            applicability,\n-        );\n-    }\n-}\n-\n /// Checks for the `USELESS_ASREF` lint.\n fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n@@ -3254,40 +3239,6 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n     }\n }\n \n-fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(Symbol, &'static str)> {\n-    has_iter_method(cx, self_ref_ty).map(|ty_name| {\n-        let mutbl = match self_ref_ty.kind() {\n-            ty::Ref(_, _, mutbl) => mutbl,\n-            _ => unreachable!(),\n-        };\n-        let method_name = match mutbl {\n-            hir::Mutability::Not => \"iter\",\n-            hir::Mutability::Mut => \"iter_mut\",\n-        };\n-        (ty_name, method_name)\n-    })\n-}\n-\n-fn lint_into_iter(cx: &LateContext<'_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_>, method_span: Span) {\n-    if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n-        return;\n-    }\n-    if let Some((kind, method_name)) = ty_has_iter_method(cx, self_ref_ty) {\n-        span_lint_and_sugg(\n-            cx,\n-            INTO_ITER_ON_REF,\n-            method_span,\n-            &format!(\n-                \"this `.into_iter()` call is equivalent to `.{}()` and will not consume the `{}`\",\n-                method_name, kind,\n-            ),\n-            \"call directly\",\n-            method_name.to_string(),\n-            Applicability::MachineApplicable,\n-        );\n-    }\n-}\n-\n const FN_HEADER: hir::FnHeader = hir::FnHeader {\n     unsafety: hir::Unsafety::Normal,\n     constness: hir::Constness::NotConst,"}, {"sha": "61cbc9d2f0a6296d83d1b58af359380e9fdedd5e", "filename": "clippy_lints/src/methods/single_char_pattern.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0c8d143515a19b04a404765ecb8145a183dc2186/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8d143515a19b04a404765ecb8145a183dc2186/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=0c8d143515a19b04a404765ecb8145a183dc2186", "patch": "@@ -0,0 +1,23 @@\n+use crate::methods::get_hint_if_single_char_arg;\n+use crate::utils::span_lint_and_sugg;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SINGLE_CHAR_PATTERN;\n+\n+/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n+pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(hint) = get_hint_if_single_char_arg(cx, arg, &mut applicability) {\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_PATTERN,\n+            arg.span,\n+            \"single-character string constant used as pattern\",\n+            \"try using a `char` instead\",\n+            hint,\n+            applicability,\n+        );\n+    }\n+}"}]}