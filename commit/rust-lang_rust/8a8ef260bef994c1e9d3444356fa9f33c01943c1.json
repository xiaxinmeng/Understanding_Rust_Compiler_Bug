{"sha": "8a8ef260bef994c1e9d3444356fa9f33c01943c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhOGVmMjYwYmVmOTk0YzFlOWQzNDQ0MzU2ZmE5ZjMzYzAxOTQzYzE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-12-08T18:00:39Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-12-19T20:17:53Z"}, "message": "proc_macro: Validate tokens coming from the compiler again", "tree": {"sha": "241136ef9641ac0c4d8eb3a223857fff204100f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/241136ef9641ac0c4d8eb3a223857fff204100f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a8ef260bef994c1e9d3444356fa9f33c01943c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8ef260bef994c1e9d3444356fa9f33c01943c1", "html_url": "https://github.com/rust-lang/rust/commit/8a8ef260bef994c1e9d3444356fa9f33c01943c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a8ef260bef994c1e9d3444356fa9f33c01943c1/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a384089402cb4b90674554467b7a506a00a5d59", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a384089402cb4b90674554467b7a506a00a5d59", "html_url": "https://github.com/rust-lang/rust/commit/4a384089402cb4b90674554467b7a506a00a5d59"}], "stats": {"total": 128, "additions": 56, "deletions": 72}, "files": [{"sha": "ebba5c81fe077d455a931def3bb59bb53556591c", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a8ef260bef994c1e9d3444356fa9f33c01943c1/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8ef260bef994c1e9d3444356fa9f33c01943c1/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=8a8ef260bef994c1e9d3444356fa9f33c01943c1", "patch": "@@ -729,11 +729,6 @@ impl Punct {\n     /// which can be further configured with the `set_span` method below.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(ch: char, spacing: Spacing) -> Punct {\n-        const LEGAL_CHARS: &[char] = &['=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^',\n-                                       '&', '|', '@', '.', ',', ';', ':', '#', '$', '?', '\\''];\n-        if !LEGAL_CHARS.contains(&ch) {\n-            panic!(\"unsupported character `{:?}`\", ch)\n-        }\n         Punct(bridge::client::Punct::new(ch, spacing))\n     }\n \n@@ -800,16 +795,6 @@ impl fmt::Debug for Punct {\n pub struct Ident(bridge::client::Ident);\n \n impl Ident {\n-    fn is_valid(string: &str) -> bool {\n-        let mut chars = string.chars();\n-        if let Some(start) = chars.next() {\n-            (start == '_' || start.is_xid_start())\n-                && chars.all(|cont| cont == '_' || cont.is_xid_continue())\n-        } else {\n-            false\n-        }\n-    }\n-\n     /// Creates a new `Ident` with the given `string` as well as the specified\n     /// `span`.\n     /// The `string` argument must be a valid identifier permitted by the\n@@ -831,18 +816,12 @@ impl Ident {\n     /// tokens, requires a `Span` to be specified at construction.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(string: &str, span: Span) -> Ident {\n-        if !Ident::is_valid(string) {\n-            panic!(\"`{:?}` is not a valid identifier\", string)\n-        }\n         Ident(bridge::client::Ident::new(string, span.0, false))\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n     #[unstable(feature = \"proc_macro_raw_ident\", issue = \"54723\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n-        if !Ident::is_valid(string) {\n-            panic!(\"`{:?}` is not a valid identifier\", string)\n-        }\n         Ident(bridge::client::Ident::new(string, span.0, true))\n     }\n "}, {"sha": "ea4a8afc0aabd19ff764d1eba9328ddd8f0f6992", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 56, "deletions": 51, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/8a8ef260bef994c1e9d3444356fa9f33c01943c1/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8ef260bef994c1e9d3444356fa9f33c01943c1/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=8a8ef260bef994c1e9d3444356fa9f33c01943c1", "patch": "@@ -81,29 +81,23 @@ impl FromInternal<(TokenStream, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     $($field $(: $value)*,)*\n                     span,\n                 })\n-            )\n+            );\n+            ($ty:ident::$method:ident($($value:expr),*)) => (\n+                TokenTree::$ty(self::$ty::$method($($value,)* span))\n+            );\n         }\n         macro_rules! op {\n             ($a:expr) => {\n-                tt!(Punct { ch: $a, joint })\n+                tt!(Punct::new($a, joint))\n             };\n             ($a:expr, $b:expr) => {{\n-                stack.push(tt!(Punct { ch: $b, joint }));\n-                tt!(Punct {\n-                    ch: $a,\n-                    joint: true\n-                })\n+                stack.push(tt!(Punct::new($b, joint)));\n+                tt!(Punct::new($a, true))\n             }};\n             ($a:expr, $b:expr, $c:expr) => {{\n-                stack.push(tt!(Punct { ch: $c, joint }));\n-                stack.push(tt!(Punct {\n-                    ch: $b,\n-                    joint: true\n-                }));\n-                tt!(Punct {\n-                    ch: $a,\n-                    joint: true\n-                })\n+                stack.push(tt!(Punct::new($c, joint)));\n+                stack.push(tt!(Punct::new($b, true)));\n+                tt!(Punct::new($a, true))\n             }};\n         }\n \n@@ -156,20 +150,11 @@ impl FromInternal<(TokenStream, &'_ ParseSess, &'_ mut Vec<Self>)>\n             Question => op!('?'),\n             SingleQuote => op!('\\''),\n \n-            Ident(ident, is_raw) => tt!(Ident {\n-                sym: ident.name,\n-                is_raw\n-            }),\n+            Ident(ident, is_raw) => tt!(Ident::new(ident.name, is_raw)),\n             Lifetime(ident) => {\n                 let ident = ident.without_first_quote();\n-                stack.push(tt!(Ident {\n-                    sym: ident.name,\n-                    is_raw: false\n-                }));\n-                tt!(Punct {\n-                    ch: '\\'',\n-                    joint: true\n-                })\n+                stack.push(tt!(Ident::new(ident.name, false)));\n+                tt!(Punct::new('\\'', true))\n             }\n             Literal(lit, suffix) => tt!(Literal { lit, suffix }),\n             DocComment(c) => {\n@@ -193,15 +178,9 @@ impl FromInternal<(TokenStream, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     span: DelimSpan::from_single(span),\n                 }));\n                 if style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Punct {\n-                        ch: '!',\n-                        joint: false\n-                    }));\n+                    stack.push(tt!(Punct::new('!', false)));\n                 }\n-                tt!(Punct {\n-                    ch: '#',\n-                    joint: false\n-                })\n+                tt!(Punct::new('#', false))\n             }\n \n             Interpolated(_) => {\n@@ -237,7 +216,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n                 )\n                 .into();\n             }\n-            TokenTree::Ident(self::Ident { sym, span, is_raw }) => {\n+            TokenTree::Ident(self::Ident { sym, is_raw, span }) => {\n                 let token = Ident(ast::Ident::new(sym, span), is_raw);\n                 return tokenstream::TokenTree::Token(span, token).into();\n             }\n@@ -338,11 +317,48 @@ pub struct Punct {\n     span: Span,\n }\n \n+impl Punct {\n+    fn new(ch: char, joint: bool, span: Span) -> Punct {\n+        const LEGAL_CHARS: &[char] = &['=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^',\n+                                       '&', '|', '@', '.', ',', ';', ':', '#', '$', '?', '\\''];\n+        if !LEGAL_CHARS.contains(&ch) {\n+            panic!(\"unsupported character `{:?}`\", ch)\n+        }\n+        Punct { ch, joint, span }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Ident {\n     sym: Symbol,\n-    span: Span,\n     is_raw: bool,\n+    span: Span,\n+}\n+\n+impl Ident {\n+    fn is_valid(string: &str) -> bool {\n+        let mut chars = string.chars();\n+        if let Some(start) = chars.next() {\n+            (start == '_' || start.is_xid_start())\n+                && chars.all(|cont| cont == '_' || cont.is_xid_continue())\n+        } else {\n+            false\n+        }\n+    }\n+    fn new(sym: Symbol, is_raw: bool, span: Span) -> Ident {\n+        let string = sym.as_str().get();\n+        if !Self::is_valid(string) {\n+            panic!(\"`{:?}` is not a valid identifier\", string)\n+        }\n+        if is_raw {\n+            let normalized_sym = Symbol::intern(string);\n+            if normalized_sym == keywords::Underscore.name() ||\n+               ast::Ident::with_empty_ctxt(normalized_sym).is_path_segment_keyword() {\n+                panic!(\"`{:?}` is not a valid raw identifier\", string)\n+            }\n+        }\n+        Ident { sym, is_raw, span }\n+    }\n }\n \n // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n@@ -492,11 +508,7 @@ impl server::Group for Rustc<'_> {\n \n impl server::Punct for Rustc<'_> {\n     fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n-        Punct {\n-            ch,\n-            joint: spacing == Spacing::Joint,\n-            span: server::Span::call_site(self),\n-        }\n+        Punct::new(ch, spacing == Spacing::Joint, server::Span::call_site(self))\n     }\n     fn as_char(&mut self, punct: Self::Punct) -> char {\n         punct.ch\n@@ -518,14 +530,7 @@ impl server::Punct for Rustc<'_> {\n \n impl server::Ident for Rustc<'_> {\n     fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n-        let sym = Symbol::intern(string);\n-        if is_raw\n-            && (sym == keywords::Underscore.name()\n-                || ast::Ident::with_empty_ctxt(sym).is_path_segment_keyword())\n-        {\n-            panic!(\"`{:?}` is not a valid raw identifier\", string)\n-        }\n-        Ident { sym, span, is_raw }\n+        Ident::new(Symbol::intern(string), is_raw, span)\n     }\n     fn span(&mut self, ident: Self::Ident) -> Self::Span {\n         ident.span"}]}