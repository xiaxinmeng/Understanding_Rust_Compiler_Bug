{"sha": "cdeef61425ec177d2eb0f84d02a9d25000c954dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZWVmNjE0MjVlYzE3N2QyZWIwZjg0ZDAyYTlkMjUwMDBjOTU0ZGQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-26T18:42:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T06:44:37Z"}, "message": "move some Scalar helpers from miri here, and use them where appropriate", "tree": {"sha": "ee29ad9a7ce00e11c9996b35dc35163d5f4a7721", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee29ad9a7ce00e11c9996b35dc35163d5f4a7721"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdeef61425ec177d2eb0f84d02a9d25000c954dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdeef61425ec177d2eb0f84d02a9d25000c954dd", "html_url": "https://github.com/rust-lang/rust/commit/cdeef61425ec177d2eb0f84d02a9d25000c954dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdeef61425ec177d2eb0f84d02a9d25000c954dd/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29e6aabcebe3bdb507df22a6233024711412b343", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e6aabcebe3bdb507df22a6233024711412b343", "html_url": "https://github.com/rust-lang/rust/commit/29e6aabcebe3bdb507df22a6233024711412b343"}], "stats": {"total": 391, "additions": 210, "deletions": 181}, "files": [{"sha": "da5216bd1befe840b30aeefa828fc96be838c77f", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -85,9 +85,14 @@ pub struct GlobalId<'tcx> {\n pub trait PointerArithmetic: layout::HasDataLayout {\n     // These are not supposed to be overridden.\n \n+    #[inline(always)]\n+    fn pointer_size(self) -> Size {\n+        self.data_layout().pointer_size\n+    }\n+\n     //// Trunace the given value to the pointer size; also return whether there was an overflow\n     fn truncate_to_ptr(self, val: u128) -> (u64, bool) {\n-        let max_ptr_plus_1 = 1u128 << self.data_layout().pointer_size.bits();\n+        let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n         ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n     }\n "}, {"sha": "11a4f8b884e7f1b46d3fa910e801f3e807563053", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -14,7 +14,7 @@ use ty::layout::{HasDataLayout, Size};\n use ty::subst::Substs;\n use hir::def_id::DefId;\n \n-use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend};\n+use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n /// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n@@ -58,6 +58,7 @@ impl<'tcx> ConstValue<'tcx> {\n         self.try_to_scalar()?.to_ptr().ok()\n     }\n \n+    #[inline]\n     pub fn new_slice(\n         val: Scalar,\n         len: u64,\n@@ -69,23 +70,27 @@ impl<'tcx> ConstValue<'tcx> {\n         }.into())\n     }\n \n+    #[inline]\n     pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {\n         ConstValue::ScalarPair(val, Scalar::Ptr(vtable).into())\n     }\n }\n \n impl<'tcx> Scalar {\n+    #[inline]\n     pub fn ptr_null(cx: impl HasDataLayout) -> Self {\n         Scalar::Bits {\n             bits: 0,\n             size: cx.data_layout().pointer_size.bytes() as u8,\n         }\n     }\n \n+    #[inline]\n     pub fn zst() -> Self {\n         Scalar::Bits { bits: 0, size: 0 }\n     }\n \n+    #[inline]\n     pub fn ptr_signed_offset(self, i: i64, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n@@ -100,6 +105,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn ptr_offset(self, i: Size, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n@@ -114,6 +120,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn ptr_wrapping_signed_offset(self, i: i64, cx: impl HasDataLayout) -> Self {\n         let layout = cx.data_layout();\n         match self {\n@@ -128,6 +135,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn is_null_ptr(self, cx: impl HasDataLayout) -> bool {\n         match self {\n             Scalar::Bits { bits, size } =>  {\n@@ -138,14 +146,53 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n+    pub fn is_null(self) -> bool {\n+        match self {\n+            Scalar::Bits { bits, .. } => bits == 0,\n+            Scalar::Ptr(_) => false\n+        }\n+    }\n+\n+    #[inline]\n     pub fn from_bool(b: bool) -> Self {\n         Scalar::Bits { bits: b as u128, size: 1 }\n     }\n \n+    #[inline]\n     pub fn from_char(c: char) -> Self {\n         Scalar::Bits { bits: c as u128, size: 4 }\n     }\n \n+    #[inline]\n+    pub fn from_uint(i: impl Into<u128>, size: Size) -> Self {\n+        let i = i.into();\n+        debug_assert_eq!(truncate(i, size), i,\n+                    \"Unsigned value {} does not fit in {} bits\", i, size.bits());\n+        Scalar::Bits { bits: i, size: size.bytes() as u8 }\n+    }\n+\n+    #[inline]\n+    pub fn from_int(i: impl Into<i128>, size: Size) -> Self {\n+        let i = i.into();\n+        // `into` performed sign extension, we have to truncate\n+        let truncated = truncate(i as u128, size);\n+        debug_assert_eq!(sign_extend(truncated, size) as i128, i,\n+                    \"Signed value {} does not fit in {} bits\", i, size.bits());\n+        Scalar::Bits { bits: truncated, size: size.bytes() as u8 }\n+    }\n+\n+    #[inline]\n+    pub fn from_f32(f: f32) -> Self {\n+        Scalar::Bits { bits: f.to_bits() as u128, size: 4 }\n+    }\n+\n+    #[inline]\n+    pub fn from_f64(f: f64) -> Self {\n+        Scalar::Bits { bits: f.to_bits() as u128, size: 8 }\n+    }\n+\n+    #[inline]\n     pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -157,6 +204,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         match self {\n             Scalar::Bits { bits: 0, .. } => err!(InvalidNullPointerUsage),\n@@ -165,13 +213,15 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn is_bits(self) -> bool {\n         match self {\n             Scalar::Bits { .. } => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_ptr(self) -> bool {\n         match self {\n             Scalar::Ptr(_) => true,\n@@ -209,6 +259,13 @@ impl<'tcx> Scalar {\n         Ok(b as u32)\n     }\n \n+    pub fn to_u64(self) -> EvalResult<'static, u64> {\n+        let sz = Size::from_bits(64);\n+        let b = self.to_bits(sz)?;\n+        assert_eq!(b as u64 as u128, b);\n+        Ok(b as u64)\n+    }\n+\n     pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         assert_eq!(b as u64 as u128, b);\n@@ -231,12 +288,30 @@ impl<'tcx> Scalar {\n         Ok(b as i32)\n     }\n \n+    pub fn to_i64(self) -> EvalResult<'static, i64> {\n+        let sz = Size::from_bits(64);\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n+        assert_eq!(b as i64 as i128, b);\n+        Ok(b as i64)\n+    }\n+\n     pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n         assert_eq!(b as i64 as i128, b);\n         Ok(b as i64)\n     }\n+\n+    #[inline]\n+    pub fn to_f32(self) -> EvalResult<'static, f32> {\n+        Ok(f32::from_bits(self.to_u32()?))\n+    }\n+\n+    #[inline]\n+    pub fn to_f64(self) -> EvalResult<'static, f64> {\n+        Ok(f64::from_bits(self.to_u64()?))\n+    }\n }\n \n impl From<Pointer> for Scalar {\n@@ -308,6 +383,16 @@ impl<'tcx> ScalarMaybeUndef {\n         self.not_undef()?.to_char()\n     }\n \n+    #[inline(always)]\n+    pub fn to_f32(self) -> EvalResult<'tcx, f32> {\n+        self.not_undef()?.to_f32()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_f64(self) -> EvalResult<'tcx, f64> {\n+        self.not_undef()?.to_f64()\n+    }\n+\n     #[inline(always)]\n     pub fn to_u8(self) -> EvalResult<'tcx, u8> {\n         self.not_undef()?.to_u8()\n@@ -318,6 +403,11 @@ impl<'tcx> ScalarMaybeUndef {\n         self.not_undef()?.to_u32()\n     }\n \n+    #[inline(always)]\n+    pub fn to_u64(self) -> EvalResult<'tcx, u64> {\n+        self.not_undef()?.to_u64()\n+    }\n+\n     #[inline(always)]\n     pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n         self.not_undef()?.to_usize(cx)\n@@ -333,6 +423,11 @@ impl<'tcx> ScalarMaybeUndef {\n         self.not_undef()?.to_i32()\n     }\n \n+    #[inline(always)]\n+    pub fn to_i64(self) -> EvalResult<'tcx, i64> {\n+        self.not_undef()?.to_i64()\n+    }\n+\n     #[inline(always)]\n     pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, i64> {\n         self.not_undef()?.to_isize(cx)"}, {"sha": "9bbaa0e7ef699007e06424acec28ff8dd608ece9", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 40, "deletions": 62, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -14,8 +14,7 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n-    Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind,\n-    truncate, sign_extend\n+    Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind, truncate\n };\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n@@ -70,10 +69,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n                                 return self.write_scalar(\n-                                    Scalar::Bits {\n-                                        bits: discr_val,\n-                                        size: dst_layout.size.bytes() as u8,\n-                                    },\n+                                    Scalar::from_uint(discr_val, dst_layout.size),\n                                     dest);\n                             }\n                         }\n@@ -198,41 +194,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_layout.ty.sty {\n             Int(_) | Uint(_) => {\n                 let v = self.truncate(v, dest_layout);\n-                Ok(Scalar::Bits {\n-                    bits: v,\n-                    size: dest_layout.size.bytes() as u8,\n-                })\n+                Ok(Scalar::from_uint(v, dest_layout.size))\n             }\n \n-            Float(FloatTy::F32) if signed => Ok(Scalar::Bits {\n-                bits: Single::from_i128(v as i128).value.to_bits(),\n-                size: 4,\n-            }),\n-            Float(FloatTy::F64) if signed => Ok(Scalar::Bits {\n-                bits: Double::from_i128(v as i128).value.to_bits(),\n-                size: 8,\n-            }),\n-            Float(FloatTy::F32) => Ok(Scalar::Bits {\n-                bits: Single::from_u128(v).value.to_bits(),\n-                size: 4,\n-            }),\n-            Float(FloatTy::F64) => Ok(Scalar::Bits {\n-                bits: Double::from_u128(v).value.to_bits(),\n-                size: 8,\n-            }),\n+            Float(FloatTy::F32) if signed => Ok(Scalar::from_uint(\n+                Single::from_i128(v as i128).value.to_bits(),\n+                Size::from_bits(32)\n+            )),\n+            Float(FloatTy::F64) if signed => Ok(Scalar::from_uint(\n+                Double::from_i128(v as i128).value.to_bits(),\n+                Size::from_bits(64)\n+            )),\n+            Float(FloatTy::F32) => Ok(Scalar::from_uint(\n+                Single::from_u128(v).value.to_bits(),\n+                Size::from_bits(32)\n+            )),\n+            Float(FloatTy::F64) => Ok(Scalar::from_uint(\n+                Double::from_u128(v).value.to_bits(),\n+                Size::from_bits(64)\n+            )),\n \n             Char => {\n-                assert_eq!(v as u8 as u128, v);\n-                Ok(Scalar::Bits { bits: v, size: 4 })\n+                // `u8` to `char` cast\n+                debug_assert_eq!(v as u8 as u128, v);\n+                Ok(Scalar::from_uint(v, Size::from_bytes(4)))\n             },\n \n             // No alignment check needed for raw pointers.\n             // But we have to truncate to target ptr size.\n             RawPtr(_) => {\n-                Ok(Scalar::Bits {\n-                    bits: self.memory.truncate_to_ptr(v).0 as u128,\n-                    size: self.memory.pointer_size().bytes() as u8,\n-                })\n+                Ok(Scalar::from_uint(\n+                    self.truncate_to_ptr(v).0,\n+                    self.pointer_size(),\n+                ))\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n@@ -251,56 +245,40 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_ty.sty {\n             // float -> uint\n             Uint(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n+                let width = t.bit_width().unwrap_or(self.pointer_size().bits() as usize);\n                 let v = match fty {\n                     FloatTy::F32 => Single::from_bits(bits).to_u128(width).value,\n                     FloatTy::F64 => Double::from_bits(bits).to_u128(width).value,\n                 };\n                 // This should already fit the bit width\n-                Ok(Scalar::Bits {\n-                    bits: v,\n-                    size: (width / 8) as u8,\n-                })\n+                Ok(Scalar::from_uint(v, Size::from_bits(width as u64)))\n             },\n             // float -> int\n             Int(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n+                let width = t.bit_width().unwrap_or(self.pointer_size().bits() as usize);\n                 let v = match fty {\n                     FloatTy::F32 => Single::from_bits(bits).to_i128(width).value,\n                     FloatTy::F64 => Double::from_bits(bits).to_i128(width).value,\n                 };\n-                // We got an i128, but we may need something smaller. We have to truncate ourselves.\n-                let truncated = truncate(v as u128, Size::from_bits(width as u64));\n-                assert_eq!(sign_extend(truncated, Size::from_bits(width as u64)) as i128, v,\n-                    \"truncating and extending changed the value?!?\");\n-                Ok(Scalar::Bits {\n-                    bits: truncated,\n-                    size: (width / 8) as u8,\n-                })\n+                Ok(Scalar::from_int(v, Size::from_bits(width as u64)))\n             },\n             // f64 -> f32\n             Float(FloatTy::F32) if fty == FloatTy::F64 => {\n-                Ok(Scalar::Bits {\n-                    bits: Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n-                    size: 4,\n-                })\n+                Ok(Scalar::from_uint(\n+                    Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n+                    Size::from_bits(32),\n+                ))\n             },\n             // f32 -> f64\n             Float(FloatTy::F64) if fty == FloatTy::F32 => {\n-                Ok(Scalar::Bits {\n-                    bits: Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n-                    size: 8,\n-                })\n+                Ok(Scalar::from_uint(\n+                    Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n+                    Size::from_bits(64),\n+                ))\n             },\n             // identity cast\n-            Float(FloatTy:: F64) => Ok(Scalar::Bits {\n-                bits,\n-                size: 8,\n-            }),\n-            Float(FloatTy:: F32) => Ok(Scalar::Bits {\n-                bits,\n-                size: 4,\n-            }),\n+            Float(FloatTy:: F64) => Ok(Scalar::from_uint(bits, Size::from_bits(64))),\n+            Float(FloatTy:: F32) => Ok(Scalar::from_uint(bits, Size::from_bits(32))),\n             _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n         }\n     }"}, {"sha": "6e144ba7ed2ee7627e74d0b9fd87f5518127f916", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -270,7 +270,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'\n }\n \n impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n+{\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout"}, {"sha": "db27df3723c0e9090856444365982b5ad1eddbad", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -41,7 +41,7 @@ fn numeric_intrinsic<'tcx>(\n         \"bswap\" => (bits << extra).swap_bytes(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n     };\n-    Ok(Scalar::Bits { bits: bits_out, size: size.bytes() as u8 })\n+    Ok(Scalar::from_uint(bits_out, size))\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -59,30 +59,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = self.layout_of(elem_ty)?.align.abi();\n-                let align_val = Scalar::Bits {\n-                    bits: elem_align as u128,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n+                let align_val = Scalar::from_uint(elem_align, dest.layout.size);\n                 self.write_scalar(align_val, dest)?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = self.layout_of(ty)?.size.bytes() as u128;\n-                let size_val = Scalar::Bits {\n-                    bits: size,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n+                let size_val = Scalar::from_uint(size, dest.layout.size);\n                 self.write_scalar(size_val, dest)?;\n             }\n \n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let type_id = self.tcx.type_id_hash(ty) as u128;\n-                let id_val = Scalar::Bits {\n-                    bits: type_id,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n+                let id_val = Scalar::from_uint(type_id, dest.layout.size);\n                 self.write_scalar(id_val, dest)?;\n             }\n             \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {"}, {"sha": "4063447fbb151bcb8d50201a9dd2112c12296e0a", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -23,7 +23,8 @@ use std::ptr;\n use rustc::ty::{self, Instance, query::TyCtxtAt};\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n use rustc::mir::interpret::{Pointer, AllocId, Allocation, ScalarMaybeUndef, GlobalId,\n-                            EvalResult, Scalar, EvalErrorKind, AllocType, truncate};\n+                            EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n+                            truncate};\n pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n@@ -60,6 +61,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a Memory<'a, 'm\n         &self.tcx.data_layout\n     }\n }\n+impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+    for &'b &'c mut Memory<'a, 'mir, 'tcx, M>\n+{\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n \n impl<'a, 'mir, 'tcx, M> Eq for Memory<'a, 'mir, 'tcx, M>\n     where M: Machine<'mir, 'tcx>,\n@@ -277,14 +286,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn pointer_size(&self) -> Size {\n-        self.tcx.data_layout.pointer_size\n-    }\n-\n-    pub fn endianness(&self) -> layout::Endian {\n-        self.tcx.data_layout.endian\n-    }\n-\n     /// Check that the pointer is aligned AND non-NULL. This supports scalars\n     /// for the benefit of other parts of miri that need to check alignment even for ZST.\n     pub fn check_align(&self, ptr: Scalar, required_align: Align) -> EvalResult<'tcx> {\n@@ -773,7 +774,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n         // Make sure we don't read part of a pointer as a pointer\n         self.check_relocation_edges(ptr, size)?;\n-        let endianness = self.endianness();\n         // get_bytes_unchecked tests alignment\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n@@ -784,7 +784,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n         // Now we do the actual reading\n-        let bits = read_target_uint(endianness, bytes).unwrap();\n+        let bits = read_target_uint(self.tcx.data_layout.endian, bytes).unwrap();\n         // See if we got a pointer\n         if size != self.pointer_size() {\n             if self.relocations(ptr, size)?.len() != 0 {\n@@ -801,10 +801,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         }\n         // We don't. Just return the bits.\n-        Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-            bits,\n-            size: size.bytes() as u8,\n-        }))\n+        Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n     pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align)\n@@ -820,8 +817,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         val: ScalarMaybeUndef,\n         type_size: Size,\n     ) -> EvalResult<'tcx> {\n-        let endianness = self.endianness();\n-\n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n             ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n@@ -835,16 +830,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, type_size.bytes());\n-                assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n                     \"Unexpected value of size {} when writing to memory\", size);\n                 bits\n             },\n         };\n \n         {\n             // get_bytes_mut checks alignment\n+            let endian = self.tcx.data_layout.endian;\n             let dst = self.get_bytes_mut(ptr, type_size, ptr_align)?;\n-            write_target_uint(endianness, dst, bytes).unwrap();\n+            write_target_uint(endian, dst, bytes).unwrap();\n         }\n \n         // See if we have to also write a relocation"}, {"sha": "b2a668b961f16e90b317a8de3f9c4477d197cb9a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -42,10 +42,7 @@ impl<'tcx> Value {\n         len: u64,\n         cx: impl HasDataLayout\n     ) -> Self {\n-        Value::ScalarPair(val.into(), Scalar::Bits {\n-            bits: len as u128,\n-            size: cx.data_layout().pointer_size.bytes() as u8,\n-        }.into())\n+        Value::ScalarPair(val.into(), Scalar::from_uint(len, cx.data_layout().pointer_size).into())\n     }\n \n     pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {"}, {"sha": "4f4f00e320a9614e2ac83e67bb58dee7eedd955b", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout};\n+use rustc::ty::{self, layout::{Size, TyLayout}};\n use syntax::ast::FloatTy;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n@@ -105,10 +105,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ($ty:path, $size:expr) => {{\n                 let l = <$ty>::from_bits(l);\n                 let r = <$ty>::from_bits(r);\n-                let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n-                    bits: res.value.to_bits(),\n-                    size: $size,\n-                };\n+                let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>|\n+                    Scalar::from_uint(res.value.to_bits(), Size::from_bytes($size));\n                 let val = match bin_op {\n                     Eq => Scalar::from_bool(l == r),\n                     Ne => Scalar::from_bool(l != r),\n@@ -169,10 +167,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n             };\n             let truncated = self.truncate(result, left_layout);\n-            return Ok((Scalar::Bits {\n-                bits: truncated,\n-                size: size.bytes() as u8,\n-            }, oflo));\n+            return Ok((Scalar::from_uint(truncated, size), oflo));\n         }\n \n         // For the remaining ops, the types must be the same on both sides\n@@ -220,7 +215,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     Rem | Div => {\n                         // int_min / -1\n                         if r == -1 && l == (1 << (size.bits() - 1)) {\n-                            return Ok((Scalar::Bits { bits: l, size: size.bytes() as u8 }, true));\n+                            return Ok((Scalar::from_uint(l, size), true));\n                         }\n                     },\n                     _ => {},\n@@ -232,16 +227,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     let max = 1 << (size.bits() - 1);\n                     oflo = result >= max || result < -max;\n                 }\n+                // this may be out-of-bounds for the result type, so we have to truncate ourselves\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::Bits {\n-                    bits: truncated,\n-                    size: size.bytes() as u8,\n-                }, oflo));\n+                return Ok((Scalar::from_uint(truncated, size), oflo));\n             }\n         }\n \n-        let size = left_layout.size.bytes() as u8;\n+        let size = left_layout.size;\n \n         // only ints left\n         let val = match bin_op {\n@@ -253,11 +246,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Gt => Scalar::from_bool(l > r),\n             Ge => Scalar::from_bool(l >= r),\n \n-            BitOr => Scalar::Bits { bits: l | r, size },\n-            BitAnd => Scalar::Bits { bits: l & r, size },\n-            BitXor => Scalar::Bits { bits: l ^ r, size },\n+            BitOr => Scalar::from_uint(l | r, size),\n+            BitAnd => Scalar::from_uint(l & r, size),\n+            BitXor => Scalar::from_uint(l ^ r, size),\n \n             Add | Sub | Mul | Rem | Div => {\n+                debug_assert!(!left_layout.abi.is_signed());\n                 let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n                     Add => u128::overflowing_add,\n                     Sub => u128::overflowing_sub,\n@@ -270,10 +264,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let (result, oflo) = op(l, r);\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::Bits {\n-                    bits: truncated,\n-                    size,\n-                }, oflo || truncated != result));\n+                return Ok((Scalar::from_uint(truncated, size), oflo || truncated != result));\n             }\n \n             _ => {\n@@ -373,7 +364,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     (Neg, FloatTy::F64) => Double::to_bits(-Double::from_bits(val)),\n                     _ => bug!(\"Invalid float op {:?}\", un_op)\n                 };\n-                Ok(Scalar::Bits { bits: res, size: layout.size.bytes() as u8 })\n+                Ok(Scalar::from_uint(res, layout.size))\n             }\n             _ => {\n                 assert!(layout.ty.is_integral());\n@@ -386,10 +377,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n                 };\n                 // res needs tuncating\n-                Ok(Scalar::Bits {\n-                    bits: self.truncate(res, layout),\n-                    size: layout.size.bytes() as u8,\n-                })\n+                Ok(Scalar::from_uint(self.truncate(res, layout), layout.size))\n             }\n         }\n     }"}, {"sha": "5bf6b2b46b7a6f6975be33a88d4145925d20ccbf", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{\n-    GlobalId, Scalar, EvalResult, Pointer, ScalarMaybeUndef\n+    GlobalId, Scalar, EvalResult, Pointer, ScalarMaybeUndef, PointerArithmetic\n };\n use super::{EvalContext, Machine, Value, ValTy, Operand, OpTy, MemoryKind};\n \n@@ -344,10 +344,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::Array(inner, _) =>\n                 (None, self.tcx.mk_array(inner, inner_len)),\n             ty::Slice(..) => {\n-                let len = Scalar::Bits {\n-                    bits: inner_len.into(),\n-                    size: self.memory.pointer_size().bytes() as u8\n-                };\n+                let len = Scalar::from_uint(inner_len, self.pointer_size());\n                 (Some(len), base.layout.ty)\n             }\n             _ =>\n@@ -716,10 +713,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let discr_val = (discr_val << shift) >> shift;\n \n                 let discr_dest = self.place_field(dest, 0)?;\n-                self.write_scalar(Scalar::Bits {\n-                    bits: discr_val,\n-                    size: size.bytes() as u8,\n-                }, discr_dest)?;\n+                self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -733,10 +727,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         self.place_field(dest, 0)?;\n                     let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n-                    self.write_scalar(Scalar::Bits {\n-                        bits: niche_value,\n-                        size: niche_dest.layout.size.bytes() as u8,\n-                    }, niche_dest)?;\n+                    self.write_scalar(\n+                        Scalar::from_uint(niche_value, niche_dest.layout.size),\n+                        niche_dest\n+                    )?;\n                 }\n             }\n         }\n@@ -766,11 +760,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let layout = self.layout_of(ty)?;\n \n         // More sanity checks\n-        let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n-        assert_eq!(size, layout.size);\n-        assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n-        // FIXME: More checks for the vtable? We could make sure it is exactly\n-        // the one one would expect for this type.\n+        if cfg!(debug_assertions) {\n+            let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n+            assert_eq!(size, layout.size);\n+            assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n+        }\n \n         let mplace = MPlaceTy {\n             mplace: MemPlace { extra: None, ..*mplace },"}, {"sha": "114ef093ec2fddd90327a2cfcbfe9326b36ad91c", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -14,7 +14,7 @@\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n-use rustc::mir::interpret::{EvalResult, Scalar};\n+use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n \n use super::{EvalContext, Machine};\n \n@@ -269,12 +269,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let src = self.eval_place(place)?;\n                 let mplace = self.force_allocation(src)?;\n                 let len = mplace.len(&self)?;\n-                let size = self.memory.pointer_size().bytes() as u8;\n+                let size = self.pointer_size();\n                 self.write_scalar(\n-                    Scalar::Bits {\n-                        bits: len as u128,\n-                        size,\n-                    },\n+                    Scalar::from_uint(len, size),\n                     dest,\n                 )?;\n             }\n@@ -294,12 +291,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n-                let size = self.memory.pointer_size().bytes() as u8;\n+                let size = self.pointer_size();\n                 self.write_scalar(\n-                    Scalar::Bits {\n-                        bits: layout.size.bytes() as u128,\n-                        size,\n-                    },\n+                    Scalar::from_uint(layout.size.bytes(), size),\n                     dest,\n                 )?;\n             }\n@@ -313,11 +307,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Discriminant(ref place) => {\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant(self.place_to_op(place)?)?.0;\n-                let size = dest.layout.size.bytes() as u8;\n-                self.write_scalar(Scalar::Bits {\n-                    bits: discr_val,\n-                    size,\n-                }, dest)?;\n+                let size = dest.layout.size;\n+                self.write_scalar(Scalar::from_uint(discr_val, size), dest)?;\n             }\n         }\n "}, {"sha": "8fc7c11c6ab8fca7b560e5adf7e34e7cede82e67", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::layout::LayoutOf;\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, Scalar};\n+use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n use super::{\n     EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup\n };\n@@ -60,10 +60,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op\n-                    let const_int = Scalar::Bits {\n-                        bits: const_int,\n-                        size: discr.layout.size.bytes() as u8\n-                    };\n+                    let const_int = Scalar::from_uint(const_int, discr.layout.size);\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n                         discr,\n                         ValTy { value: Value::Scalar(const_int.into()), layout: discr.layout }\n@@ -411,7 +408,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n                 let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n                 let vtable = ptr.vtable()?;"}, {"sha": "0e09f65f0a8eaba3b4f370b13cfbfa582401ed7f", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n-use rustc::mir::interpret::{Scalar, Pointer, EvalResult};\n+use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n \n use syntax::ast::Mutability;\n \n@@ -35,7 +35,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi();\n \n-        let ptr_size = self.memory.pointer_size();\n+        let ptr_size = self.pointer_size();\n         let ptr_align = self.tcx.data_layout.pointer_align;\n         let methods = self.tcx.vtable_methods(trait_ref);\n         let vtable = self.memory.allocate(\n@@ -49,15 +49,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::Bits {\n-            bits: size as u128,\n-            size: ptr_size.bytes() as u8,\n-        }.into())?;\n+        self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::from_uint(size, ptr_size).into())?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized(align_ptr, ptr_align, Scalar::Bits {\n-            bits: align as u128,\n-            size: ptr_size.bytes() as u8,\n-        }.into())?;\n+        self.memory.write_ptr_sized(align_ptr, ptr_align,\n+            Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n@@ -97,7 +92,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         vtable: Pointer,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        let pointer_size = self.memory.pointer_size();\n+        let pointer_size = self.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n         let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?,pointer_align)?\n             .to_bits(pointer_size)? as u64;"}, {"sha": "ef2ae8f5337c6285ade520bd185e436796765f40", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeef61425ec177d2eb0f84d02a9d25000c954dd/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=cdeef61425ec177d2eb0f84d02a9d25000c954dd", "patch": "@@ -15,7 +15,7 @@ use rustc::ty::layout::{self, Size, Primitive};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocType, EvalResult, ScalarMaybeUndef, EvalErrorKind\n+    Scalar, AllocType, EvalResult, ScalarMaybeUndef, EvalErrorKind, PointerArithmetic\n };\n \n use super::{\n@@ -118,7 +118,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 bits\n             },\n             Scalar::Ptr(_) => {\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n                 return if lo > hi {\n                     if lo - hi == 1 {\n@@ -376,6 +376,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                         \"non-pointer vtable in fat pointer\", path\n                                     ),\n                             }\n+                            // FIXME: More checks for the vtable.\n                         }\n                         ty::Slice(..) | ty::Str => {\n                             match ptr.extra.unwrap().to_usize(self) {"}]}