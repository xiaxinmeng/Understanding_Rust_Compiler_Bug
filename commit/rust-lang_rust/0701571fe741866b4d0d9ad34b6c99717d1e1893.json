{"sha": "0701571fe741866b4d0d9ad34b6c99717d1e1893", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MDE1NzFmZTc0MTg2NmI0ZDBkOWFkMzRiNmM5OTcxN2QxZTE4OTM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T03:32:45Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-14T01:34:37Z"}, "message": "Implement `macro_rules!` placeholders and the macro scope map", "tree": {"sha": "d8008de798ec028f2bc5781fa3bf38a6629c729d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8008de798ec028f2bc5781fa3bf38a6629c729d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0701571fe741866b4d0d9ad34b6c99717d1e1893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0701571fe741866b4d0d9ad34b6c99717d1e1893", "html_url": "https://github.com/rust-lang/rust/commit/0701571fe741866b4d0d9ad34b6c99717d1e1893", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0701571fe741866b4d0d9ad34b6c99717d1e1893/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e", "html_url": "https://github.com/rust-lang/rust/commit/a15dfca54f1b6e54226797fa12fe0d7a2bf9252e"}], "stats": {"total": 151, "additions": 127, "deletions": 24}, "files": [{"sha": "d4465822229e953baf1e4d8e38a76138d85cbbd7", "filename": "src/librustc_resolve/assign_ids.rs", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=0701571fe741866b4d0d9ad34b6c99717d1e1893", "patch": "@@ -11,20 +11,27 @@\n use Resolver;\n use rustc::session::Session;\n use syntax::ast;\n-use syntax::fold::Folder;\n+use syntax::ext::mtwt;\n+use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::util::move_map::MoveMap;\n+use syntax::util::small_vector::SmallVector;\n+\n+use std::collections::HashMap;\n+use std::mem;\n \n impl<'a> Resolver<'a> {\n     pub fn assign_node_ids(&mut self, krate: ast::Crate) -> ast::Crate {\n         NodeIdAssigner {\n             sess: self.session,\n+            macros_at_scope: &mut self.macros_at_scope,\n         }.fold_crate(krate)\n     }\n }\n \n struct NodeIdAssigner<'a> {\n     sess: &'a Session,\n+    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<ast::Mrk>>,\n }\n \n impl<'a> Folder for NodeIdAssigner<'a> {\n@@ -38,22 +45,48 @@ impl<'a> Folder for NodeIdAssigner<'a> {\n             block.id = self.new_id(block.id);\n \n             let stmt = block.stmts.pop();\n-            block.stmts = block.stmts.move_flat_map(|s| self.fold_stmt(s).into_iter());\n-            if let Some(ast::Stmt { node: ast::StmtKind::Expr(expr), span, .. }) = stmt {\n+            let mut macros = Vec::new();\n+            block.stmts = block.stmts.move_flat_map(|stmt| {\n+                if let ast::StmtKind::Item(ref item) = stmt.node {\n+                    if let ast::ItemKind::Mac(..) = item.node {\n+                        macros.push(mtwt::outer_mark(item.ident.ctxt));\n+                        return None;\n+                    }\n+                }\n+\n+                let stmt = self.fold_stmt(stmt).pop().unwrap();\n+                if !macros.is_empty() {\n+                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n+                }\n+                Some(stmt)\n+            });\n+\n+            stmt.and_then(|mut stmt| {\n                 // Avoid wasting a node id on a trailing expression statement,\n                 // which shares a HIR node with the expression itself.\n-                let expr = self.fold_expr(expr);\n-                block.stmts.push(ast::Stmt {\n-                    id: expr.id,\n-                    node: ast::StmtKind::Expr(expr),\n-                    span: span,\n-                });\n-            } else if let Some(stmt) = stmt {\n-                block.stmts.extend(self.fold_stmt(stmt));\n-            }\n+                if let ast::StmtKind::Expr(expr) = stmt.node {\n+                    let expr = self.fold_expr(expr);\n+                    stmt.id = expr.id;\n+                    stmt.node = ast::StmtKind::Expr(expr);\n+                    Some(stmt)\n+                } else {\n+                    self.fold_stmt(stmt).pop()\n+                }\n+            }).map(|stmt| {\n+                if !macros.is_empty() {\n+                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n+                }\n+                block.stmts.push(stmt);\n+            });\n \n             block\n         })\n     }\n-}\n \n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        match item.node {\n+            ast::ItemKind::Mac(..) => SmallVector::zero(),\n+            _ => fold::noop_fold_item(item, self),\n+        }\n+    }\n+}"}, {"sha": "d94a22eb94df44e3880cb4c63895bb9b1e669799", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0701571fe741866b4d0d9ad34b6c99717d1e1893", "patch": "@@ -53,6 +53,7 @@ use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n+use syntax::ext::mtwt;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::parse::token::{self, keywords};\n@@ -651,6 +652,9 @@ enum RibKind<'a> {\n \n     // We passed through a module.\n     ModuleRibKind(Module<'a>),\n+\n+    // We passed through a `macro_rules!` statement with the given expansion\n+    MacroDefinition(ast::Mrk),\n }\n \n #[derive(Copy, Clone)]\n@@ -927,6 +931,10 @@ pub struct Resolver<'a> {\n \n     pub definitions: Definitions,\n \n+    // Maps the node id of a statement to the expansions of the `macro_rules!`s\n+    // immediately above the statement (if appropriate).\n+    macros_at_scope: HashMap<NodeId, Vec<ast::Mrk>>,\n+\n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n@@ -1113,6 +1121,7 @@ impl<'a> Resolver<'a> {\n             session: session,\n \n             definitions: Definitions::new(),\n+            macros_at_scope: HashMap::new(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1421,6 +1430,16 @@ impl<'a> Resolver<'a> {\n                     };\n                 }\n             }\n+\n+            if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n+                // If an invocation of this macro created `ident`, give up on `ident`\n+                // and switch to `ident`'s source from the macro definition.\n+                if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n+                    if mac == source_macro {\n+                        ident = source_ident;\n+                    }\n+                }\n+            }\n         }\n \n         None\n@@ -2069,6 +2088,7 @@ impl<'a> Resolver<'a> {\n         let orig_module = self.current_module;\n         let anonymous_module = self.module_map.get(&block.id).cloned(); // clones a reference\n \n+        let mut num_value_ribs = 1;\n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");\n             self.value_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n@@ -2079,11 +2099,22 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Descend into the block.\n-        visit::walk_block(self, block);\n+        for stmt in &block.stmts {\n+            if let Some(marks) = self.macros_at_scope.remove(&stmt.id) {\n+                num_value_ribs += marks.len() as u32;\n+                for mark in marks {\n+                    self.value_ribs.push(Rib::new(MacroDefinition(mark)));\n+                }\n+            }\n+\n+            self.visit_stmt(stmt);\n+        }\n \n         // Move back up.\n         self.current_module = orig_module;\n-        self.value_ribs.pop();\n+        for _ in 0 .. num_value_ribs {\n+            self.value_ribs.pop();\n+        }\n         if let Some(_) = anonymous_module {\n             self.type_ribs.pop();\n         }\n@@ -2497,7 +2528,7 @@ impl<'a> Resolver<'a> {\n             Def::Local(_, node_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | ModuleRibKind(..) => {\n+                        NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n@@ -2546,7 +2577,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | MethodRibKind(_) | ClosureRibKind(..) |\n-                        ModuleRibKind(..) => {\n+                        ModuleRibKind(..) | MacroDefinition(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind => {"}, {"sha": "10b66d08955414512022316b875589e6ccc36363", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0701571fe741866b4d0d9ad34b6c99717d1e1893", "patch": "@@ -15,7 +15,7 @@ use attr::HasAttrs;\n use ext::mtwt;\n use attr;\n use attr::AttrMetaMethods;\n-use codemap::{Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{dummy_spanned, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n use ext::base::*;\n@@ -105,6 +105,23 @@ pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n     }\n }\n \n+struct MacroScopePlaceholder;\n+impl MacResult for MacroScopePlaceholder {\n+    fn make_items(self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n+        Some(SmallVector::one(P(ast::Item {\n+            ident: keywords::Invalid.ident(),\n+            attrs: Vec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::ItemKind::Mac(dummy_spanned(ast::Mac_ {\n+                path: ast::Path { span: syntax_pos::DUMMY_SP, global: false, segments: Vec::new() },\n+                tts: Vec::new(),\n+            })),\n+            vis: ast::Visibility::Inherited,\n+            span: syntax_pos::DUMMY_SP,\n+        })))\n+    }\n+}\n+\n /// Expand a macro invocation. Returns the result of expansion.\n fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attribute>, span: Span,\n                        fld: &mut MacroExpander) -> T\n@@ -143,6 +160,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n         };\n \n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n+        let marked_tts = mark_tts(&tts, mark);\n         match *extension {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n@@ -161,7 +179,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     },\n                 });\n \n-                let marked_tts = mark_tts(&tts, mark);\n                 Some(expandfun.expand(fld.cx, call_site, &marked_tts))\n             }\n \n@@ -181,7 +198,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     }\n                 });\n \n-                let marked_tts = mark_tts(&tts, mark);\n                 Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n             }\n \n@@ -210,15 +226,14 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     span: call_site,\n                     imported_from: None,\n                     use_locally: true,\n-                    body: tts,\n+                    body: marked_tts,\n                     export: attr::contains_name(&attrs, \"macro_export\"),\n                     allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n                     attrs: attrs,\n                 });\n \n                 // macro_rules! has a side effect but expands to nothing.\n-                fld.cx.bt_pop();\n-                None\n+                Some(Box::new(MacroScopePlaceholder))\n             }\n \n             MultiDecorator(..) | MultiModifier(..) => {\n@@ -343,6 +358,12 @@ fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector\n     match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n+                if match it.node {\n+                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n+                    _ => unreachable!(),\n+                } {\n+                    return SmallVector::one(Annotatable::Item(it));\n+                }\n                 it.and_then(|it| match it.node {\n                     ItemKind::Mac(mac) =>\n                         expand_mac_invoc(mac, Some(it.ident), it.attrs, it.span, fld),"}, {"sha": "ac5bac58d2a9acb1f6df234b04ad11563154b01d", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=0701571fe741866b4d0d9ad34b6c99717d1e1893", "patch": "@@ -17,7 +17,7 @@\n \n pub use self::SyntaxContext_::*;\n \n-use ast::{Mrk, SyntaxContext};\n+use ast::{Ident, Mrk, SyntaxContext};\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n@@ -112,6 +112,20 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     })\n }\n \n+/// If `ident` is macro expanded, return the source ident from the macro definition\n+/// and the mark of the expansion that created the macro definition.\n+pub fn source(ident: Ident) -> Option<(Ident /* source ident */, Mrk /* source macro */)> {\n+    with_sctable(|sctable| {\n+        let ctxts = sctable.table.borrow();\n+        if let Mark(_expansion_mark, macro_ctxt) = ctxts[ident.ctxt.0 as usize] {\n+            if let Mark(definition_mark, orig_ctxt) = ctxts[macro_ctxt.0 as usize] {\n+                return Some((Ident::new(ident.name, orig_ctxt), definition_mark));\n+            }\n+        }\n+        None\n+    })\n+}\n+\n #[cfg(test)]\n mod tests {\n     use ast::{EMPTY_CTXT, Ident, Mrk, Name, SyntaxContext};"}, {"sha": "327696e87b08e26fc98ddbc9725f42a1c0a45580", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701571fe741866b4d0d9ad34b6c99717d1e1893/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=0701571fe741866b4d0d9ad34b6c99717d1e1893", "patch": "@@ -185,6 +185,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         mod_folded\n     }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n struct EntryPointCleaner {\n@@ -234,6 +236,8 @@ impl fold::Folder for EntryPointCleaner {\n \n         SmallVector::one(folded)\n     }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,"}]}