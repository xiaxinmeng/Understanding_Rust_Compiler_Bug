{"sha": "a90453a178069b890aa3877009fa99968dc85c09", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MDQ1M2ExNzgwNjliODkwYWEzODc3MDA5ZmE5OTk2OGRjODVjMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T04:17:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T04:17:30Z"}, "message": "Auto merge of #25320 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #25254, #25272, #25278, #25282, #25283, #25288, #25292, #25302, #25304, #25314\n- Failed merges:", "tree": {"sha": "49b97d0b5f6741912f13ccd6e7f148b951fe73b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49b97d0b5f6741912f13ccd6e7f148b951fe73b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a90453a178069b890aa3877009fa99968dc85c09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a90453a178069b890aa3877009fa99968dc85c09", "html_url": "https://github.com/rust-lang/rust/commit/a90453a178069b890aa3877009fa99968dc85c09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a90453a178069b890aa3877009fa99968dc85c09/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b88e8f63eeaf557c916a0a1e73150b028c44c52", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b88e8f63eeaf557c916a0a1e73150b028c44c52", "html_url": "https://github.com/rust-lang/rust/commit/4b88e8f63eeaf557c916a0a1e73150b028c44c52"}, {"sha": "28b923c4770b23c4b7b892f2161e020770d1706f", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b923c4770b23c4b7b892f2161e020770d1706f", "html_url": "https://github.com/rust-lang/rust/commit/28b923c4770b23c4b7b892f2161e020770d1706f"}], "stats": {"total": 816, "additions": 765, "deletions": 51}, "files": [{"sha": "750179622746936820b0b088fb3ee99035330a63", "filename": "src/doc/reference.md", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -31,23 +31,27 @@ You may also be interested in the [grammar].\n \n ## Unicode productions\n \n-A few productions in Rust's grammar permit Unicode code points outside the ASCII\n-range. We define these productions in terms of character properties specified\n-in the Unicode standard, rather than in terms of ASCII-range code points. The\n-section [Special Unicode Productions](#special-unicode-productions) lists these\n-productions.\n+A few productions in Rust's grammar permit Unicode code points outside the\n+ASCII range. We define these productions in terms of character properties\n+specified in the Unicode standard, rather than in terms of ASCII-range code\n+points. The grammar has a [Special Unicode Productions][unicodeproductions]\n+section that lists these productions.\n+\n+[unicodeproductions]: grammar.html#special-unicode-productions\n \n ## String table productions\n \n Some rules in the grammar &mdash; notably [unary\n operators](#unary-operator-expressions), [binary\n-operators](#binary-operator-expressions), and [keywords](#keywords) &mdash; are\n+operators](#binary-operator-expressions), and [keywords][keywords] &mdash; are\n given in a simplified form: as a listing of a table of unquoted, printable\n whitespace-separated strings. These cases form a subset of the rules regarding\n the [token](#tokens) rule, and are assumed to be the result of a\n lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n disjunction of all such string table entries.\n \n+[keywords]: grammar.html#keywords\n+\n When such a string enclosed in double-quotes (`\"`) occurs inside the grammar,\n it is an implicit reference to a single member of such a string table\n production. See [tokens](#tokens) for more information.\n@@ -75,7 +79,7 @@ An identifier is any nonempty Unicode[^non_ascii_idents] string of the following\n - The first character has property `XID_start`\n - The remaining characters have property `XID_continue`\n \n-that does _not_ occur in the set of [keywords](#keywords).\n+that does _not_ occur in the set of [keywords][keywords].\n \n > **Note**: `XID_start` and `XID_continue` as character properties cover the\n > character ranges used to form the more familiar C and Java language-family\n@@ -401,7 +405,7 @@ Symbols are a general class of printable [token](#tokens) that play structural\n roles in a variety of grammar productions. They are catalogued here for\n completeness as the set of remaining miscellaneous printable tokens that do not\n otherwise appear as [unary operators](#unary-operator-expressions), [binary\n-operators](#binary-operator-expressions), or [keywords](#keywords).\n+operators](#binary-operator-expressions), or [keywords][keywords].\n \n \n ## Paths\n@@ -547,7 +551,7 @@ _name_ s that occur in its body. At the \"current layer\", they all must repeat\n the same number of times, so ` ( $( $i:ident ),* ; $( $j:ident ),* ) => ( $(\n ($i,$j) ),* )` is valid if given the argument `(a,b,c ; d,e,f)`, but not\n `(a,b,c ; d,e)`. The repetition walks through the choices at that layer in\n-lockstep, so the former input transcribes to `( (a,d), (b,e), (c,f) )`.\n+lockstep, so the former input transcribes to `(a,d), (b,e), (c,f)`.\n \n Nested repetitions are allowed.\n \n@@ -611,7 +615,7 @@ module needs its own source file: [module definitions](#modules) can be nested\n within one file.\n \n Each source file contains a sequence of zero or more `item` definitions, and\n-may optionally begin with any number of [attributes](#Items and attributes)\n+may optionally begin with any number of [attributes](#items-and-attributes)\n that apply to the containing module, most of which influence the behavior of\n the compiler. The anonymous crate module can have additional attributes that\n apply to the crate as a whole.\n@@ -653,7 +657,7 @@ There are several kinds of item:\n * [`use` declarations](#use-declarations)\n * [modules](#modules)\n * [functions](#functions)\n-* [type aliases](#type-aliases)\n+* [type definitions](grammar.html#type-definitions)\n * [structures](#structures)\n * [enumerations](#enumerations)\n * [constant items](#constant-items)\n@@ -773,7 +777,7 @@ extern crate std as ruststd; // linking to 'std' under another name\n A _use declaration_ creates one or more local name bindings synonymous with\n some other [path](#paths). Usually a `use` declaration is used to shorten the\n path required to refer to a module item. These declarations may appear at the\n-top of [modules](#modules) and [blocks](#blocks).\n+top of [modules](#modules) and [blocks](grammar.html#block-expressions).\n \n > **Note**: Unlike in many languages,\n > `use` declarations in Rust do *not* declare linkage dependency with external crates.\n@@ -1144,9 +1148,7 @@ let px: i32 = match p { Point(x, _) => x };\n ```\n \n A _unit-like struct_ is a structure without any fields, defined by leaving off\n-the list of fields entirely. Such types will have a single value, just like\n-the [unit value `()`](#unit-and-boolean-literals) of the unit type. For\n-example:\n+the list of fields entirely. Such types will have a single value. For example:\n \n ```\n struct Cookie;\n@@ -2436,11 +2438,6 @@ comma:\n (0); // zero in parentheses\n ```\n \n-### Unit expressions\n-\n-The expression `()` denotes the _unit value_, the only value of the type with\n-the same name.\n-\n ### Structure expressions\n \n There are several forms of structure expressions. A _structure expression_\n@@ -3281,7 +3278,7 @@ constructor or `struct` field may refer, directly or indirectly, to the\n enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n \n * Recursive types must include a nominal type in the recursion\n-  (not mere [type definitions](#type-definitions),\n+  (not mere [type definitions](grammar.html#type-definitions),\n    or other structural types such as [arrays](#array,-and-slice-types) or [tuples](#tuple-types)).\n * A recursive `enum` item must have at least one non-recursive constructor\n   (in order to give the recursion a basis case)."}, {"sha": "127e097c34f7db03ef946a34e4fd8f168821ca31", "filename": "src/doc/trpl/compiler-plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -176,7 +176,7 @@ for a full example, the core of which is reproduced here:\n \n ```ignore\n declare_lint!(TEST_LINT, Warn,\n-              \"Warn about items named 'lintme'\")\n+              \"Warn about items named 'lintme'\");\n \n struct Pass;\n "}, {"sha": "1527d9cf978df96af30197592a36ab15f1cd015a", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -127,12 +127,12 @@ fn grow(&self) -> Circle {\n We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n circle to any arbitrary size.\n \n-# Static methods\n+# Associated functions\n \n-You can also define static methods that do not take a `self` parameter. Here\u2019s a\n-pattern that\u2019s very common in Rust code:\n+You can also define associated functions that do not take a `self` parameter.\n+Here\u2019s a pattern that\u2019s very common in Rust code:\n \n-```\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,"}, {"sha": "7b1cd7dc8093b3646730023c36a5a12c5e1570c5", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 568, "deletions": 1, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -1,3 +1,570 @@\n % The Stack and the Heap\n \n-Coming Soon\n+As a systems language, Rust operates at a low level. If you\u2019re coming from a\n+high-level language, there are some aspects of systems programming that you may\n+not be familiar with. The most important one is how memory works, with a stack\n+and a heap. If you\u2019re familiar with how C-like languages use stack allocation,\n+this chapter will be a refresher. If you\u2019re not, you\u2019ll learn about this more\n+general concept, but with a Rust-y focus.\n+\n+# Memory management\n+\n+These two terms are about memory management. The stack and the heap are\n+abstractions that help you determine when to allocate and deallocate memory.\n+\n+Here\u2019s a high-level comparison:\n+\n+The stack is very fast, and is where memory is allocated in Rust by default.\n+But the allocation is local to a function call, and is limited in size. The\n+heap, on the other hand, is slower, and is explicitly allocated by your\n+program. But it\u2019s effectively unlimited in size, and is globally accessible.\n+\n+# The Stack\n+\n+Let\u2019s talk about this Rust program:\n+\n+```rust\n+fn main() {\n+    let x = 42;\n+}\n+```\n+\n+This program has one variable binding, `x`. This memory needs to be allocated\n+from somewhere. Rust \u2018stack allocates\u2019 by default, which means that basic\n+values \u2018go on the stack\u2019. What does that mean?\n+\n+Well, when a function gets called, some memory gets allocated for all of its\n+local variables and some other information. This is called a \u2018stack frame\u2019, and\n+for the purpose of this tutorial, we\u2019re going to ignore the extra information\n+and just consider the local variables we\u2019re allocating. So in this case, when\n+`main()` is run, we\u2019ll allocate a single 32-bit integer for our stack frame.\n+This is automatically handled for you, as you can see, we didn\u2019t have to write\n+any special Rust code or anything.\n+\n+When the function is over, its stack frame gets deallocated. This happens\n+automatically, we didn\u2019t have to do anything special here.\n+\n+That\u2019s all there is for this simple program. The key thing to understand here\n+is that stack allocation is very, very fast. Since we know all the local\n+variables we have ahead of time, we can grab the memory all at once. And since\n+we\u2019ll throw them all away at the same time as well, we can get rid of it very\n+fast too.\n+\n+The downside is that we can\u2019t keep values around if we need them for longer\n+than a single function. We also haven\u2019t talked about what that name, \u2018stack\u2019\n+means. To do that, we need a slightly more complicated example:\n+\n+```rust\n+fn foo() {\n+    let y = 5;\n+    let z = 100;\n+}\n+\n+fn main() {\n+    let x = 42;\n+\n+    foo();\n+}\n+```\n+\n+This program has three variables total: two in `foo()`, one in `main()`. Just\n+as before, when `main()` is called, a single integer is allocated for its stack\n+frame. But before we can show what happens when `foo()` is called, we need to\n+visualize what\u2019s going on with memory. Your operating system presents a view of\n+memory to your program that\u2019s pretty simple: a huge list of addresses, from 0\n+to a large number, representing how much RAM your computer has. For example, if\n+you have a gigabyte of RAM, your addresses go from `0` to `1,073,741,824`. That\n+number comes from 2<sup>30</sup>, the number of bytes in a gigabyte.\n+\n+This memory is kind of like a giant array: addresses start at zero and go\n+up to the final number. So here\u2019s a diagram of our first stack frame:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+We\u2019ve got `x` located at address `0`, with the value `42`.\n+\n+When `foo()` is called, a new stack frame is allocated:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 2       | z    | 100   |\n+| 1       | y    | 5     |\n+| 0       | x    | 42    |\n+\n+Because `0` was taken by the first frame, `1` and `2` are used for `foo()`\u2019s\n+stack frame. It grows upward, the more functions we call.\n+\n+\n+There\u2019s some important things we have to take note of here. The numbers 0, 1,\n+and 2 are all solely for illustrative purposes, and bear no relationship to the\n+actual numbers the computer will actually use. In particular, the series of\n+addresses are in reality going to be separated by some number of bytes that\n+separate each address, and that separation may even exceed the size of the\n+value being stored.\n+\n+After `foo()` is over, its frame is deallocated:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+And then, after `main()`, even this last value goes away. Easy!\n+\n+It\u2019s called a \u2018stack\u2019 because it works like a stack of dinner plates: the first\n+plate you put down is the last plate to pick back up. Stacks are sometimes\n+called \u2018last in, first out queues\u2019 for this reason, as the last value you put\n+on the stack is the first one you retrieve from it.\n+\n+Let\u2019s try a three-deep example:\n+\n+```rust\n+fn bar() {\n+    let i = 6;\n+}\n+\n+fn foo() {\n+    let a = 5;\n+    let b = 100;\n+    let c = 1;\n+\n+    bar();\n+}\n+\n+fn main() {\n+    let x = 42;\n+\n+    foo();\n+}\n+```\n+\n+Okay, first, we call `main()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+Next up, `main()` calls `foo()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+And then `foo()` calls `bar()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 4       | i    | 6     |\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+Whew! Our stack is growing tall.\n+\n+After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n+`main()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+And then `foo()` ends, leaving just `main()`\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+And then we\u2019re done. Getting the hang of it? It\u2019s like piling up dishes: you\n+add to the top, you take away from the top.\n+\n+# The Heap\n+\n+Now, this works pretty well, but not everything can work like this. Sometimes,\n+you need to pass some memory between different functions, or keep it alive for\n+longer than a single function\u2019s execution. For this, we can use the heap.\n+\n+In Rust, you can allocate memory on the heap with the [`Box<T>` type][box].\n+Here\u2019s an example:\n+\n+```rust\n+fn main() {\n+    let x = Box::new(5);\n+    let y = 42;\n+}\n+```\n+\n+[box]: ../std/boxed/index.html\n+\n+Here\u2019s what happens in memory when `main()` is called:\n+\n+| Address | Name | Value  |\n++---------+------+--------+\n+| 1       | y    | 42     |\n+| 0       | x    | ?????? |\n+\n+We allocate space for two variables on the stack. `y` is `42`, as it always has\n+been, but what about `x`? Well, `x` is a `Box<i32>`, and boxes allocate memory\n+on the heap. The actual value of the box is a structure which has a pointer to\n+\u2018the heap\u2019. When we start executing the function, and `Box::new()` is called,\n+it allocates some memory for the heap, and puts `5` there. The memory now looks\n+like this:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 5              |\n+| ...             | ...  | ...            |\n+| 1               | y    | 42             |\n+| 0               | x    | 2<sup>30</sup> |\n+\n+We have 2<sup>30</sup> in our hypothetical computer with 1GB of RAM. And since\n+our stack grows from zero, the easiest place to allocate memory is from the\n+other end. So our first value is at the highest place in memory. And the value\n+of the struct at `x` has a [raw pointer][rawpointer] to the place we\u2019ve\n+allocated on the heap, so the value of `x` is 2<sup>30</sup>, the memory\n+location we\u2019ve asked for.\n+\n+[rawpointer]: raw-pointers.html\n+\n+We haven\u2019t really talked too much about what it actually means to allocate and\n+deallocate memory in these contexts. Getting into very deep detail is out of\n+the scope of this tutorial, but what\u2019s important to point out here is that\n+the heap isn\u2019t just a stack that grows from the opposite end. We\u2019ll have an\n+example of this later in the book, but because the heap can be allocated and\n+freed in any order, it can end up with \u2018holes\u2019. Here\u2019s a diagram of the memory\n+layout of a program which has been running for a while now:\n+\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+| 2<sup>30</sup>       |      | 5                    |\n+| (2<sup>30</sup>) - 1 |      |                      |\n+| (2<sup>30</sup>) - 2 |      |                      |\n+| (2<sup>30</sup>) - 3 |      | 42                   |\n+| ...                  | ...  | ...                  |\n+| 3                    | y    | (2<sup>30</sup>) - 3 |\n+| 2                    | y    | 42                   |\n+| 1                    | y    | 42                   |\n+| 0                    | x    | 2<sup>30</sup>       |\n+\n+In this case, we\u2019ve allocated four things on the heap, but deallocated two of\n+them. There\u2019s a gap between 2<sup>30</sup> and (2<sup>30</sup>) - 3 which isn\u2019t\n+currently being used. The specific details of how and why this happens depends\n+on what kind of strategy you use to manage the heap. Different programs can use\n+different \u2018memory allocators\u2019, which are libraries that manage this for you.\n+Rust programs use [jemalloc][jemalloc] for this purpose.\n+\n+[jemalloc]: http://www.canonware.com/jemalloc/\n+\n+Anyway, back to our example. Since this memory is on the heap, it can stay\n+alive longer than the function which allocates the box. In this case, however,\n+it doesn\u2019t.[^moving] When the function is over, we need to free the stack frame\n+for `main()`. `Box<T>`, though, has a trick up its sleve: [Drop][drop]. The\n+implementation of `Drop` for `Box` deallocates the memory that was allocated\n+when it was created. Great! So when `x` goes away, it first frees the memory\n+allocated on the heap:\n+\n+| Address | Name | Value  |\n++---------+------+--------+\n+| 1       | y    | 42     |\n+| 0       | x    | ?????? |\n+\n+[drop]: drop.html\n+[moving]: We can make the memory live longer by transferring ownership,\n+          sometimes called \u2018moving out of the box\u2019. More complex examples will\n+          be covered later.\n+\n+\n+And then the stack frame goes away, freeing all of our memory.\n+\n+# Arguments and borrowing\n+\n+We\u2019ve got some basic examples with the stack and the heap going, but what about\n+function arguments and borrowing? Here\u2019s a small Rust program:\n+\n+```rust\n+fn foo(i: &i32) {\n+    let z = 42;\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = &x;\n+\n+    foo(y);\n+}\n+```\n+\n+When we enter `main()`, memory looks like this:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 1       | y    | 0     |\n+| 0       | x    | 5     |\n+\n+`x` is a plain old `5`, and `y` is a reference to `x`. So its value is the\n+memory location that `x` lives at, which in this case is `0`.\n+\n+What about when we call `foo()`, passing `y` as an argument?\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | z    | 42    |\n+| 2       | i    | 0     |\n+| 1       | y    | 0     |\n+| 0       | x    | 5     |\n+\n+Stack frames aren\u2019t just for local bindings, they\u2019re for arguments too. So in\n+this case, we need to have both `i`, our argument, and `z`, our local variable\n+binding. `i` is a copy of the argument, `y`. Since `y`\u2019s value is `0`, so is\n+`i`\u2019s.\n+\n+This is one reason why borrowing a variable doesn\u2019t deallocate any memory: the\n+value of a reference is just a pointer to a memory location. If we got rid of\n+the underlying memory, things wouldn\u2019t work very well.\n+\n+# A complex example\n+\n+Okay, let\u2019s go through this complex program step-by-step:\n+\n+```rust\n+fn foo(x: &i32) {\n+    let y = 10;\n+    let z = &y;\n+\n+    baz(z);\n+    bar(x, z);\n+}\n+\n+fn bar(a: &i32, b: &i32) {\n+    let c = 5;\n+    let d = Box::new(5);\n+    let e = &d;\n+\n+    baz(e);\n+}\n+\n+fn baz(f: &i32) {\n+    let g = 100;\n+}\n+\n+fn main() {\n+    let h = 3;\n+    let i = Box::new(20);\n+    let j = &h;\n+\n+    foo(j);\n+}\n+```\n+\n+First, we call `main()`:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+We allocate memory for `j`, `i`, and `h`. `i` is on the heap, and so has a\n+value pointing there.\n+\n+Next, at the end of `main()`, `foo()` gets called:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+Space gets allocated for `x`, `y`, and `z`. The argument `x` has the same value\n+as `j`, since that\u2019s what we passed it in. It\u2019s a pointer to the `0` address,\n+since `j` points at `h`.\n+\n+Next, `foo()` calls `baz()`, passing `z`:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 7               | g    | 100            |\n+| 6               | f    | 4              |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+We\u2019ve allocated memory for `f` and `g`. `baz()` is very short, so when it\u2019s\n+over, we get rid of its stack frame:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+Next, `foo()` calls `bar()` with `x` and `z`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+We end up allocating another value on the heap, and so we have to subtract one\n+from 2<sup>30</sup>. It\u2019s easier to just write that than `1,073,741,823`. In any\n+case, we set up the variables as usual.\n+\n+At the end of `bar()`, it calls `baz()`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 12                   | g    | 100                  |\n+| 11                   | f    | 4                    |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+With this, we\u2019re at our deepest point! Whew! Congrats for following along this\n+far.\n+\n+After `baz()` is over, we get rid of `f` and `g`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+Next, we return from `bar()`. `d` in this case is a `Box<T>`, so it also frees\n+what it points to: (2<sup>30</sup>) - 1.\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+|  2<sup>30</sup> |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+And after that, `foo()` returns:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+|  2<sup>30</sup> |      | 20             |\n+| ...             | ...  | ...            |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+And then, finally, `main()`, which cleans the rest up. When `i` is `Drop`ped,\n+it will clean up the last of the heap too.\n+\n+# What do other languages do?\n+\n+Most languages with a garbage collector heap-allocate by default. This means\n+that every value is boxed. There are a number of reasons why this is done, but\n+they\u2019re out of scope for this tutorial. There are some possible optimizations\n+that don\u2019t make it true 100% of the time, too. Rather than relying on the stack\n+and `Drop` to clean up memory, the garbage collector deals with the heap\n+instead.\n+\n+# Which to use?\n+\n+So if the stack is faster and easier to manage, why do we need the heap? A big\n+reason is that Stack-allocation alone means you only have LIFO semantics for\n+reclaiming storage. Heap-allocation is strictly more general, allowing storage\n+to be taken from and returned to the pool in arbitrary order, but at a\n+complexity cost.\n+\n+Generally, you should prefer stack allocation, and so, Rust stack-allocates by\n+default. The LIFO model of the stack is simpler, at a fundamental level. This\n+has two big impacts: runtime efficiency and semantic impact.\n+\n+## Runtime Efficiency.\n+\n+Managing the memory for the stack is trivial: The machine just\n+increments or decrements a single value, the so-called \u201cstack pointer\u201d.\n+Managing memory for the heap is non-trivial: heap-allocated memory is freed at\n+arbitrary points, and each block of heap-allocated memory can be of arbitrary\n+size, the memory manager must generally work much harder to identify memory for\n+reuse.\n+\n+If you\u2019d like to dive into this topic in greater detail, [this paper][wilson]\n+is a great introduction.\n+\n+[wilson]: http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf\n+\n+## Semantic impact \n+\n+Stack-allocation impacts the Rust language itself, and thus the developer\u2019s\n+mental model. The LIFO semantics is what drives how the Rust language handles\n+automatic memory management. Even the deallocation of a uniquely-owned\n+heap-allocated box can be driven by the stack-based LIFO semantics, as\n+discussed throughout this chapter. The flexibility (i.e. expressiveness) of non\n+LIFO-semantics means that in general the compiler cannot automatically infer at\n+compile-time where memory should be freed; it has to rely on dynamic protocols,\n+potentially from outside the language itself, to drive deallocation (reference\n+counting, as used by `Rc<T>` and `Arc<T>`, is one example of this).\n+\n+When taken to the extreme, the increased expressive power of heap allocation\n+comes at the cost of either significant runtime support (e.g. in the form of a\n+garbage collector) or significant programmer effort (in the form of explicit\n+memory management calls that require verification not provided by the Rust\n+compiler)."}, {"sha": "e155dc86f3251d497b43cea25c82ae1d503e9bd1", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -8,6 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::{isize, usize};\n+\n+#[inline(always)]\n+fn check_size_and_alignment(size: usize, align: usize) {\n+    debug_assert!(size != 0);\n+    debug_assert!(size <= isize::MAX as usize, \"Tried to allocate too much: {} bytes\", size);\n+    debug_assert!(usize::is_power_of_two(align), \"Invalid alignment of allocation: {}\", align);\n+}\n+\n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n \n /// Return a pointer to `size` bytes of memory aligned to `align`.\n@@ -19,6 +28,7 @@\n /// size on the platform.\n #[inline]\n pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+    check_size_and_alignment(size, align);\n     imp::allocate(size, align)\n }\n \n@@ -38,6 +48,7 @@ pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n+    check_size_and_alignment(size, align);\n     imp::reallocate(ptr, old_size, size, align)\n }\n \n@@ -56,6 +67,7 @@ pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usiz\n #[inline]\n pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n                                  align: usize) -> usize {\n+    check_size_and_alignment(size, align);\n     imp::reallocate_inplace(ptr, old_size, size, align)\n }\n "}, {"sha": "8ec4a68f2b14b7c6334a24f8a10cd33676d61fd9", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -1537,7 +1537,7 @@ impl BitSet {\n         bit_vec.nbits = trunc_len * u32::BITS;\n     }\n \n-    /// Iterator over each u32 stored in the `BitSet`.\n+    /// Iterator over each usize stored in the `BitSet`.\n     ///\n     /// # Examples\n     ///\n@@ -1558,7 +1558,7 @@ impl BitSet {\n         SetIter {set: self, next_idx: 0}\n     }\n \n-    /// Iterator over each u32 stored in `self` union `other`.\n+    /// Iterator over each usize stored in `self` union `other`.\n     /// See [union_with](#method.union_with) for an efficient in-place version.\n     ///\n     /// # Examples\n@@ -1658,7 +1658,7 @@ impl BitSet {\n         })\n     }\n \n-    /// Iterator over each u32 stored in the symmetric difference of `self` and `other`.\n+    /// Iterator over each usize stored in the symmetric difference of `self` and `other`.\n     /// See [symmetric_difference_with](#method.symmetric_difference_with) for\n     /// an efficient in-place version.\n     ///"}, {"sha": "0f1e55544e1af5f5a02a158c2cbda5aa36ac6f4d", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -745,13 +745,15 @@ variable.\n \n For example:\n \n+```\n let x: i32 = \"I am not a number!\";\n //     ~~~   ~~~~~~~~~~~~~~~~~~~~\n //      |             |\n //      |    initializing expression;\n //      |    compiler infers type `&str`\n //      |\n //    type `i32` assigned to variable `x`\n+```\n \"##,\n \n E0309: r##\"\n@@ -760,6 +762,7 @@ how long the data stored within them is guaranteed to be live. This lifetime\n must be as long as the data needs to be alive, and missing the constraint that\n denotes this will cause this error.\n \n+```\n // This won't compile because T is not constrained, meaning the data\n // stored in it is not guaranteed to last as long as the reference\n struct Foo<'a, T> {\n@@ -770,6 +773,7 @@ struct Foo<'a, T> {\n struct Foo<'a, T: 'a> {\n     foo: &'a T\n }\n+```\n \"##,\n \n E0310: r##\"\n@@ -778,6 +782,7 @@ how long the data stored within them is guaranteed to be live. This lifetime\n must be as long as the data needs to be alive, and missing the constraint that\n denotes this will cause this error.\n \n+```\n // This won't compile because T is not constrained to the static lifetime\n // the reference needs\n struct Foo<T> {\n@@ -788,6 +793,7 @@ struct Foo<T> {\n struct Foo<T: 'static> {\n     foo: &'static T\n }\n+```\n \"##\n \n }"}, {"sha": "54ec1aace92112fe16a1109126004b15fdbacdc6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -1603,7 +1603,8 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                         Some(i as usize)),\n                         _ => {\n                             span_err!(tcx.sess, ast_ty.span, E0249,\n-                                      \"expected constant expr for array length\");\n+                                      \"expected constant integer expression \\\n+                                       for array length\");\n                             this.tcx().types.err\n                         }\n                     }"}, {"sha": "ea872d1014425e9b6f0e31deef6f8d8a16d7f35d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 150, "deletions": 19, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -150,6 +150,148 @@ attribute. Such a function must have the following type signature:\n ```\n fn(isize, *const *const u8) -> isize\n ```\n+\"##,\n+\n+E0184: r##\"\n+Explicitly implementing both Drop and Copy for a type is currently disallowed.\n+This feature can make some sense in theory, but the current implementation is\n+incorrect and can lead to memory unsafety (see [issue #20126][iss20126]), so\n+it has been disabled for now.\n+\n+[iss20126]: https://github.com/rust-lang/rust/issues/20126\n+\"##,\n+\n+E0204: r##\"\n+An attempt to implement the `Copy` trait for a struct failed because one of the\n+fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n+mentioned field. Note that this may not be possible, as in the example of\n+\n+```\n+struct Foo {\n+    foo : Vec<u32>,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```\n+#[derive(Copy)]\n+struct Foo<'a> {\n+    ty: &'a mut bool,\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n+differs from the behavior for `&T`, which is `Copy` when `T` is `Copy`).\n+\"##,\n+\n+E0205: r##\"\n+An attempt to implement the `Copy` trait for an enum failed because one of the\n+variants does not implement `Copy`. To fix this, you must implement `Copy` for\n+the mentioned variant. Note that this may not be possible, as in the example of\n+\n+```\n+enum Foo {\n+    Bar(Vec<u32>),\n+    Baz,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```\n+#[derive(Copy)]\n+enum Foo<'a> {\n+    Bar(&'a mut bool),\n+    Baz\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n+differs from the behavior for `&T`, which is `Copy` when `T` is `Copy`).\n+\"##,\n+\n+E0206: r##\"\n+You can only implement `Copy` for a struct or enum. Both of the following\n+examples will fail, because neither `i32` (primitive type) nor `&'static Bar`\n+(reference to `Bar`) is a struct or enum:\n+\n+```\n+type Foo = i32;\n+impl Copy for Foo { } // error\n+\n+#[derive(Copy, Clone)]\n+struct Bar;\n+impl Copy for &'static Bar { } // error\n+```\n+\"##,\n+\n+E0243: r##\"\n+This error indicates that not enough type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below is defined to be generic in `T`, but the\n+type parameter is missing in the definition of `Bar`:\n+\n+```\n+struct Foo<T> { x: T }\n+\n+struct Bar { x: Foo }\n+```\n+\"##,\n+\n+E0244: r##\"\n+This error indicates that too many type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below has no type parameters, but is supplied\n+with two in the definition of `Bar`:\n+\n+```\n+struct Foo { x: bool }\n+\n+struct Bar<S, T> { x: Foo<S, T> }\n+```\n+\"##,\n+\n+E0249: r##\"\n+This error indicates a constant expression for the array length was found, but\n+it was not an integer (signed or unsigned) expression.\n+\n+Some examples of code that produces this error are:\n+\n+```\n+const A: [u32; \"hello\"] = []; // error\n+const B: [u32; true] = []; // error\n+const C: [u32; 0.0] = []; // error\n+\"##,\n+\n+E0250: r##\"\n+This means there was an error while evaluating the expression for the length of\n+a fixed-size array type.\n+\n+Some examples of code that produces this error are:\n+\n+```\n+// divide by zero in the length expression\n+const A: [u32; 1/0] = [];\n+\n+// Rust currently will not evaluate the function `foo` at compile time\n+fn foo() -> usize { 12 }\n+const B: [u32; foo()] = [];\n+\n+// it is an error to try to add `u8` and `f64`\n+use std::{f64, u8};\n+const C: [u32; u8::MAX + f64::EPSILON] = [];\n+```\n \"##\n \n }\n@@ -164,18 +306,18 @@ register_diagnostics! {\n     E0030,\n     E0031,\n     E0033,\n-    E0034,\n-    E0035,\n-    E0036,\n-    E0038,\n+    E0034, // multiple applicable methods in scope\n+    E0035, // does not take type parameters\n+    E0036, // incorrect number of type parameters given for this method\n+    E0038, // cannot convert to a trait object because trait is not object-safe\n     E0040, // explicit use of destructor method\n-    E0044,\n-    E0045,\n+    E0044, // foreign items may not have type parameters\n+    E0045, // variadic function must have C calling convention\n     E0049,\n     E0050,\n     E0053,\n-    E0055,\n-    E0057,\n+    E0055, // method has an incompatible type for trait\n+    E0057, // method has an incompatible type for trait\n     E0059,\n     E0060,\n     E0061,\n@@ -232,7 +374,6 @@ register_diagnostics! {\n     E0178,\n     E0182,\n     E0183,\n-    E0184,\n     E0185,\n     E0186,\n     E0187, // can't infer the kind of the closure\n@@ -254,12 +395,6 @@ register_diagnostics! {\n     E0202, // associated items are not allowed in inherent impls\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n-    E0204, // trait `Copy` may not be implemented for this type; field\n-           // does not implement `Copy`\n-    E0205, // trait `Copy` may not be implemented for this type; variant\n-           // does not implement `copy`\n-    E0206, // trait `Copy` may not be implemented for this type; type is\n-           // not a structure or enumeration\n     E0207, // type parameter is not constrained by the impl trait, self type, or predicate\n     E0208,\n     E0209, // builtin traits can only be implemented on structs or enums\n@@ -296,14 +431,10 @@ register_diagnostics! {\n     E0240,\n     E0241,\n     E0242, // internal error looking up a definition\n-    E0243, // wrong number of type arguments\n-    E0244, // wrong number of type arguments\n     E0245, // not a trait\n     E0246, // illegal recursive type\n     E0247, // found module name used as a type\n     E0248, // found value name used as a type\n-    E0249, // expected constant expr for array length\n-    E0250, // expected constant expr for array length\n     E0318, // can't create default impls for traits outside their crates\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck"}, {"sha": "934b3156357d64e09a2ea574c78c6be9027ff9d4", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a90453a178069b890aa3877009fa99968dc85c09/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=a90453a178069b890aa3877009fa99968dc85c09", "patch": "@@ -1199,7 +1199,7 @@ impl Into<OsString> for PathBuf {\n /// absolute, and so on. More details about the overall approach can be found in\n /// the module documentation.\n ///\n-/// This is an *unsized* type, meaning that it must always be used with behind a\n+/// This is an *unsized* type, meaning that it must always be used behind a\n /// pointer like `&` or `Box`.\n ///\n /// # Examples"}]}