{"sha": "251f0c6090e98a2367e14a5505e849d9c883b5a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MWYwYzYwOTBlOThhMjM2N2UxNGE1NTA1ZTg0OWQ5Yzg4M2I1YTU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-02T19:05:10Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-02T19:05:10Z"}, "message": "`replace_match_with_if_let` works on more binary matches", "tree": {"sha": "bf97c5bc6c6f22774aac448c9eb902f3ba36544c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf97c5bc6c6f22774aac448c9eb902f3ba36544c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/251f0c6090e98a2367e14a5505e849d9c883b5a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/251f0c6090e98a2367e14a5505e849d9c883b5a5", "html_url": "https://github.com/rust-lang/rust/commit/251f0c6090e98a2367e14a5505e849d9c883b5a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/251f0c6090e98a2367e14a5505e849d9c883b5a5/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1819525f57c31da6632cd81d16f7eb0f54805e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1819525f57c31da6632cd81d16f7eb0f54805e6", "html_url": "https://github.com/rust-lang/rust/commit/f1819525f57c31da6632cd81d16f7eb0f54805e6"}], "stats": {"total": 165, "additions": 141, "deletions": 24}, "files": [{"sha": "b1c5f44213c2436235b6a5e3644b16b50003a67b", "filename": "crates/ide_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 137, "deletions": 24, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/251f0c6090e98a2367e14a5505e849d9c883b5a5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251f0c6090e98a2367e14a5505e849d9c883b5a5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=251f0c6090e98a2367e14a5505e849d9c883b5a5", "patch": "@@ -176,48 +176,47 @@ fn make_else_arm(\n // ```\n pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_expr: ast::MatchExpr = ctx.find_node_at_offset()?;\n+\n     let mut arms = match_expr.match_arm_list()?.arms();\n-    let first_arm = arms.next()?;\n-    let second_arm = arms.next()?;\n+    let (first_arm, second_arm) = (arms.next()?, arms.next()?);\n     if arms.next().is_some() || first_arm.guard().is_some() || second_arm.guard().is_some() {\n         return None;\n     }\n-    let condition_expr = match_expr.expr()?;\n-    let (if_let_pat, then_expr, else_expr) = if is_pat_wildcard_or_sad(&ctx.sema, &first_arm.pat()?)\n-    {\n-        (second_arm.pat()?, second_arm.expr()?, first_arm.expr()?)\n-    } else if is_pat_wildcard_or_sad(&ctx.sema, &second_arm.pat()?) {\n-        (first_arm.pat()?, first_arm.expr()?, second_arm.expr()?)\n-    } else {\n-        return None;\n-    };\n+\n+    let (if_let_pat, then_expr, else_expr) = pick_pattern_and_expr_order(\n+        &ctx.sema,\n+        first_arm.pat()?,\n+        second_arm.pat()?,\n+        first_arm.expr()?,\n+        second_arm.expr()?,\n+    )?;\n+    let scrutinee = match_expr.expr()?;\n \n     let target = match_expr.syntax().text_range();\n     acc.add(\n         AssistId(\"replace_match_with_if_let\", AssistKind::RefactorRewrite),\n         \"Replace with if let\",\n         target,\n         move |edit| {\n-            let condition = make::condition(condition_expr, Some(if_let_pat));\n+            let condition = make::condition(scrutinee, Some(if_let_pat));\n             let then_block = match then_expr.reset_indent() {\n                 ast::Expr::BlockExpr(block) => block,\n                 expr => make::block_expr(iter::empty(), Some(expr)),\n             };\n             let else_expr = match else_expr {\n-                ast::Expr::BlockExpr(block)\n-                    if block.statements().count() == 0 && block.tail_expr().is_none() =>\n-                {\n-                    None\n-                }\n-                ast::Expr::TupleExpr(tuple) if tuple.fields().count() == 0 => None,\n+                ast::Expr::BlockExpr(block) if block.is_empty() => None,\n+                ast::Expr::TupleExpr(tuple) if tuple.fields().next().is_none() => None,\n                 expr => Some(expr),\n             };\n             let if_let_expr = make::expr_if(\n                 condition,\n                 then_block,\n-                else_expr.map(|else_expr| {\n-                    ast::ElseBranch::Block(make::block_expr(iter::empty(), Some(else_expr)))\n-                }),\n+                else_expr\n+                    .map(|expr| match expr {\n+                        ast::Expr::BlockExpr(block) => block,\n+                        expr => (make::block_expr(iter::empty(), Some(expr))),\n+                    })\n+                    .map(ast::ElseBranch::Block),\n             )\n             .indent(IndentLevel::from_node(match_expr.syntax()));\n \n@@ -226,11 +225,50 @@ pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext)\n     )\n }\n \n-fn is_pat_wildcard_or_sad(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n+/// Pick the pattern for the if let condition and return the expressions for the `then` body and `else` body in that order.\n+fn pick_pattern_and_expr_order(\n+    sema: &hir::Semantics<RootDatabase>,\n+    pat: ast::Pat,\n+    pat2: ast::Pat,\n+    expr: ast::Expr,\n+    expr2: ast::Expr,\n+) -> Option<(ast::Pat, ast::Expr, ast::Expr)> {\n+    let res = match (pat, pat2) {\n+        (ast::Pat::WildcardPat(_), _) => return None,\n+        (pat, sad_pat) if is_sad_pat(sema, &sad_pat) => (pat, expr, expr2),\n+        (sad_pat, pat) if is_sad_pat(sema, &sad_pat) => (pat, expr2, expr),\n+        (pat, pat2) => match (binds_name(&pat), binds_name(&pat2)) {\n+            (true, true) => return None,\n+            (true, false) => (pat, expr, expr2),\n+            (false, true) => (pat2, expr2, expr),\n+            (false, false) => (pat, expr, expr2),\n+        },\n+    };\n+    Some(res)\n+}\n+\n+fn binds_name(pat: &ast::Pat) -> bool {\n+    let binds_name_v = |pat| binds_name(&pat);\n+    match pat {\n+        ast::Pat::IdentPat(_) => true,\n+        ast::Pat::MacroPat(_) => true,\n+        ast::Pat::OrPat(pat) => pat.pats().any(binds_name_v),\n+        ast::Pat::SlicePat(pat) => pat.pats().any(binds_name_v),\n+        ast::Pat::TuplePat(it) => it.fields().any(binds_name_v),\n+        ast::Pat::TupleStructPat(it) => it.fields().any(binds_name_v),\n+        ast::Pat::RecordPat(it) => it\n+            .record_pat_field_list()\n+            .map_or(false, |rpfl| rpfl.fields().flat_map(|rpf| rpf.pat()).any(binds_name_v)),\n+        ast::Pat::RefPat(pat) => pat.pat().map_or(false, binds_name_v),\n+        ast::Pat::BoxPat(pat) => pat.pat().map_or(false, binds_name_v),\n+        ast::Pat::ParenPat(pat) => pat.pat().map_or(false, binds_name_v),\n+        _ => false,\n+    }\n+}\n+fn is_sad_pat(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n     sema.type_of_pat(pat)\n         .and_then(|ty| TryEnum::from_ty(sema, &ty))\n-        .map(|it| it.sad_pattern().syntax().text() == pat.syntax().text())\n-        .unwrap_or_else(|| matches!(pat, ast::Pat::WildcardPat(_)))\n+        .map_or(false, |it| it.sad_pattern().syntax().text() == pat.syntax().text())\n }\n \n #[cfg(test)]\n@@ -662,4 +700,79 @@ fn main() {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn replace_match_with_if_let_exhaustive() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn print_source(def_source: ModuleSource) {\n+    match def_so$0urce {\n+        ModuleSource::SourceFile(..) => { println!(\"source file\"); }\n+        ModuleSource::Module(..) => { println!(\"module\"); }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn print_source(def_source: ModuleSource) {\n+    if let ModuleSource::SourceFile(..) = def_source { println!(\"source file\"); } else { println!(\"module\"); }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_match_with_if_let_prefer_name_bind() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn foo() {\n+    match $0Foo(0) {\n+        Foo(_) => (),\n+        Bar(bar) => println!(\"bar {}\", bar),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    if let Bar(bar) = Foo(0) {\n+        println!(\"bar {}\", bar)\n+    }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn foo() {\n+    match $0Foo(0) {\n+        Bar(bar) => println!(\"bar {}\", bar),\n+        Foo(_) => (),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    if let Bar(bar) = Foo(0) {\n+        println!(\"bar {}\", bar)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_match_with_if_let_rejects_double_name_bindings() {\n+        check_assist_not_applicable(\n+            replace_match_with_if_let,\n+            r#\"\n+fn foo() {\n+    match $0Foo(0) {\n+        Foo(foo) => println!(\"bar {}\", foo),\n+        Bar(bar) => println!(\"bar {}\", bar),\n+    }\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "d8c5c4e76fbe53abce007dc99b399895ca4d83ba", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/251f0c6090e98a2367e14a5505e849d9c883b5a5/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251f0c6090e98a2367e14a5505e849d9c883b5a5/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=251f0c6090e98a2367e14a5505e849d9c883b5a5", "patch": "@@ -49,6 +49,10 @@ impl ast::BlockExpr {\n     pub fn items(&self) -> AstChildren<ast::Item> {\n         support::children(self.syntax())\n     }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.statements().next().is_none() && self.tail_expr().is_none()\n+    }\n }\n \n impl ast::Expr {"}]}