{"sha": "941615748d9000e66ff4400ae519dc60410a11f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MTYxNTc0OGQ5MDAwZTY2ZmY0NDAwYWU1MTlkYzYwNDEwYTExZjc=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-07T22:32:14Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-08T17:47:05Z"}, "message": "fix panic in match checking when tuple enum missing pattern", "tree": {"sha": "05606f6755f1ac7d46e38784fb8b2952a7153f99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05606f6755f1ac7d46e38784fb8b2952a7153f99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/941615748d9000e66ff4400ae519dc60410a11f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/941615748d9000e66ff4400ae519dc60410a11f7", "html_url": "https://github.com/rust-lang/rust/commit/941615748d9000e66ff4400ae519dc60410a11f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/941615748d9000e66ff4400ae519dc60410a11f7/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4762c6d9c66dc1b6be9b9010dbe787ef8d69530a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4762c6d9c66dc1b6be9b9010dbe787ef8d69530a", "html_url": "https://github.com/rust-lang/rust/commit/4762c6d9c66dc1b6be9b9010dbe787ef8d69530a"}], "stats": {"total": 60, "additions": 45, "deletions": 15}, "files": [{"sha": "037db5cf8ab4d5dfc2a9a4fae40e2682aad282da", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/941615748d9000e66ff4400ae519dc60410a11f7/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941615748d9000e66ff4400ae519dc60410a11f7/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=941615748d9000e66ff4400ae519dc60410a11f7", "patch": "@@ -235,7 +235,10 @@ impl From<PatId> for PatIdOrWild {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n-pub struct MatchCheckNotImplemented;\n+pub enum MatchCheckErr {\n+    NotImplemented,\n+    MalformedMatchArm,\n+}\n \n /// The return type of `is_useful` is either an indication of usefulness\n /// of the match arm, or an error in the case the match statement\n@@ -244,7 +247,7 @@ pub struct MatchCheckNotImplemented;\n ///\n /// The `std::result::Result` type is used here rather than a custom enum\n /// to allow the use of `?`.\n-pub type MatchCheckResult<T> = Result<T, MatchCheckNotImplemented>;\n+pub type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n \n #[derive(Debug)]\n /// A row in a Matrix.\n@@ -335,29 +338,36 @@ impl PatStack {\n                     Expr::Literal(Literal::Bool(_)) => None,\n                     // perhaps this is actually unreachable given we have\n                     // already checked that these match arms have the appropriate type?\n-                    _ => return Err(MatchCheckNotImplemented),\n+                    _ => return Err(MatchCheckErr::NotImplemented),\n                 }\n             }\n             (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n             (Pat::Path(_), Constructor::Enum(constructor)) => {\n-                // enums with no associated data become `Pat::Path`\n+                // unit enum variants become `Pat::Path`\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *constructor) {\n                     None\n                 } else {\n                     Some(self.to_tail())\n                 }\n             }\n-            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(constructor)) => {\n+            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(enum_constructor)) => {\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n-                if !enum_variant_matches(cx, pat_id, *constructor) {\n+                if !enum_variant_matches(cx, pat_id, *enum_constructor) {\n                     None\n                 } else {\n+                    // If the enum variant matches, then we need to confirm\n+                    // that the number of patterns aligns with the expected\n+                    // number of patterns for that enum variant.\n+                    if pat_ids.len() != constructor.arity(cx)? {\n+                        return Err(MatchCheckErr::MalformedMatchArm);\n+                    }\n+\n                     Some(self.replace_head_with(pat_ids))\n                 }\n             }\n-            (Pat::Or(_), _) => return Err(MatchCheckNotImplemented),\n-            (_, _) => return Err(MatchCheckNotImplemented),\n+            (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n+            (_, _) => return Err(MatchCheckErr::NotImplemented),\n         };\n \n         Ok(result)\n@@ -514,7 +524,7 @@ pub(crate) fn is_useful(\n         return if any_useful {\n             Ok(Usefulness::Useful)\n         } else if found_unimplemented {\n-            Err(MatchCheckNotImplemented)\n+            Err(MatchCheckErr::NotImplemented)\n         } else {\n             Ok(Usefulness::NotUseful)\n         };\n@@ -567,7 +577,7 @@ pub(crate) fn is_useful(\n                 }\n \n                 if found_unimplemented {\n-                    Err(MatchCheckNotImplemented)\n+                    Err(MatchCheckErr::NotImplemented)\n                 } else {\n                     Ok(Usefulness::NotUseful)\n                 }\n@@ -604,7 +614,7 @@ impl Constructor {\n                 match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n                     VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n                     VariantData::Unit => 0,\n-                    _ => return Err(MatchCheckNotImplemented),\n+                    _ => return Err(MatchCheckErr::NotImplemented),\n                 }\n             }\n         };\n@@ -637,20 +647,20 @@ fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Opt\n         Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n         Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n             Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n-            _ => return Err(MatchCheckNotImplemented),\n+            _ => return Err(MatchCheckErr::NotImplemented),\n         },\n         Pat::TupleStruct { .. } | Pat::Path(_) => {\n             let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n             let variant_id =\n-                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckNotImplemented)?;\n+                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::NotImplemented)?;\n             match variant_id {\n                 VariantId::EnumVariantId(enum_variant_id) => {\n                     Some(Constructor::Enum(enum_variant_id))\n                 }\n-                _ => return Err(MatchCheckNotImplemented),\n+                _ => return Err(MatchCheckErr::NotImplemented),\n             }\n         }\n-        _ => return Err(MatchCheckNotImplemented),\n+        _ => return Err(MatchCheckErr::NotImplemented),\n     };\n \n     Ok(res)\n@@ -1324,6 +1334,26 @@ mod tests {\n         check_diagnostic(content);\n     }\n \n+    #[test]\n+    fn malformed_match_arm_tuple_enum_missing_pattern() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B(u32),\n+            }\n+            fn test_fn() {\n+                match Either::A {\n+                    Either::A => (),\n+                    Either::B() => (),\n+                }\n+            }\n+        \";\n+\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_not_in_scope() {\n         let content = r\""}]}