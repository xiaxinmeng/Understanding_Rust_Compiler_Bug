{"sha": "3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjOTBhZTg0MDRiNmI4M2JjM2NiYTM1ODQwZGRmN2VkZDUwMGNjODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-24T01:24:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-24T01:24:38Z"}, "message": "Auto merge of #73293 - Aaron1011:feature/macro-rules-arg-capture, r=petrochenkov\n\nAlways capture tokens for `macro_rules!` arguments\n\nWhen we invoke a proc-macro, the `TokenStream` we pass to it may contain 'interpolated' AST fragments, represented by `rustc_ast::token::Nonterminal`. In order to correctly, pass a `Nonterminal` to a proc-macro, we need to have 'captured' its `TokenStream` at the time the AST was parsed.\n\nCurrently, we perform this capturing when attributes are present on items and expressions, since we will end up using a `Nonterminal` to pass the item/expr to any proc-macro attributes it is annotated with. However, `Nonterminal`s are also introduced by the expansion of metavariables in `macro_rules!` macros. Since these metavariables may be passed to proc-macros, we need to have tokens available to avoid the need to pretty-print and reparse (see https://github.com/rust-lang/rust/issues/43081).\n\nThis PR unconditionally performs token capturing for AST items and expressions that are passed to a `macro_rules!` invocation. We cannot know in advance if captured item/expr will be passed to proc-macro, so this is needed to ensure that tokens will always be available when they are needed.\n\nThis ensures that proc-macros will receive tokens with proper `Spans` (both location and hygiene) in more cases. Like all work on https://github.com/rust-lang/rust/issues/43081, this will cause regressions in proc-macros that were relying on receiving tokens with dummy spans.\n\nIn this case, Crater revealed only one regression: the [Pear](https://github.com/SergioBenitez/Pear) crate (a helper for [rocket](https://github.com/SergioBenitez/Rocket)), which was previously [fixed](https://github.com/SergioBenitez/Pear/pull/25) as part of https://github.com/rust-lang/rust/pull/73084.\n\nThis regression manifests itself as the following error:\n\n```\n[INFO] [stdout] error: proc macro panicked\n[INFO] [stdout]    --> /opt/rustwide/cargo-home/registry/src/github.com-1ecc6299db9ec823/rocket_http-0.4.5/src/parse/uri/parser.rs:119:34\n[INFO] [stdout]     |\n[INFO] [stdout] 119 |             let path_and_query = pear_try!(path_and_query(is_pchar));\n[INFO] [stdout]     |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[INFO] [stdout]     |\n[INFO] [stdout]     = help: message: called `Option::unwrap()` on a `None` value\n[INFO] [stdout]     = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\nIt can be fixed by running `cargo update -p pear`, which updates your `Cargo.lock` to use the latest version of Pear (which includes a bugfix for the regression).\n\nSplit out from https://github.com/rust-lang/rust/pull/73084/", "tree": {"sha": "b768a42791cc9834b6e40ab9d16f0208a24d8088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b768a42791cc9834b6e40ab9d16f0208a24d8088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "html_url": "https://github.com/rust-lang/rust/commit/3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "html_url": "https://github.com/rust-lang/rust/commit/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6"}, {"sha": "74599cd362076816755f087876949c85d8ed92fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/74599cd362076816755f087876949c85d8ed92fc", "html_url": "https://github.com/rust-lang/rust/commit/74599cd362076816755f087876949c85d8ed92fc"}], "stats": {"total": 210, "additions": 205, "deletions": 5}, "files": [{"sha": "968f7c8e273a36ae6a557085f42c2476e5662bbe", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -866,18 +866,39 @@ fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Result<Nonterminal, (\n }\n \n fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a, Nonterminal> {\n+    // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n+    // needs to have them force-captured here.\n+    // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n+    // which requires having captured tokens available. Since we cannot determine\n+    // in advance whether or not a proc-macro will be (transitively) invoked,\n+    // we always capture tokens for any `Nonterminal` which needs them.\n     Ok(match name {\n-        sym::item => match p.parse_item()? {\n-            Some(i) => token::NtItem(i),\n-            None => return Err(p.struct_span_err(p.token.span, \"expected an item keyword\")),\n+        sym::item => match p.collect_tokens(|this| this.parse_item())? {\n+            (Some(mut item), tokens) => {\n+                // If we captured tokens during parsing (due to outer attributes),\n+                // use those.\n+                if item.tokens.is_none() {\n+                    item.tokens = Some(tokens);\n+                }\n+                token::NtItem(item)\n+            }\n+            (None, _) => return Err(p.struct_span_err(p.token.span, \"expected an item keyword\")),\n         },\n         sym::block => token::NtBlock(p.parse_block()?),\n         sym::stmt => match p.parse_stmt()? {\n             Some(s) => token::NtStmt(s),\n             None => return Err(p.struct_span_err(p.token.span, \"expected a statement\")),\n         },\n         sym::pat => token::NtPat(p.parse_pat(None)?),\n-        sym::expr => token::NtExpr(p.parse_expr()?),\n+        sym::expr => {\n+            let (mut expr, tokens) = p.collect_tokens(|this| this.parse_expr())?;\n+            // If we captured tokens during parsing (due to outer attributes),\n+            // use those.\n+            if expr.tokens.is_none() {\n+                expr.tokens = Some(tokens);\n+            }\n+            token::NtExpr(expr)\n+        }\n         sym::literal => token::NtLiteral(p.parse_literal_maybe_minus()?),\n         sym::ty => token::NtTy(p.parse_ty()?),\n         // this could be handled like a token, since it is one"}, {"sha": "7811d5fb741b27d946b6ce57c6856d8d2b4977d5", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -1151,7 +1151,7 @@ impl<'a> Parser<'a> {\n     /// This restriction shouldn't be an issue in practice,\n     /// since this function is used to record the tokens for\n     /// a parsed AST item, which always has matching delimiters.\n-    fn collect_tokens<R>(\n+    pub fn collect_tokens<R>(\n         &mut self,\n         f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n     ) -> PResult<'a, (R, TokenStream)> {"}, {"sha": "6331608fbe54353ff8f425c4ef6b54a003f5a455", "filename": "src/test/ui/proc-macro/auxiliary/first-second.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ffirst-second.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ffirst-second.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ffirst-second.rs?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -0,0 +1,20 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenTree, Group, Delimiter};\n+\n+#[proc_macro_attribute]\n+pub fn first(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    let tokens: TokenStream = \"#[derive(Second)]\".parse().unwrap();\n+    let wrapped = TokenTree::Group(Group::new(Delimiter::None, item.into_iter().collect()));\n+    tokens.into_iter().chain(std::iter::once(wrapped)).collect()\n+}\n+\n+#[proc_macro_derive(Second)]\n+pub fn second(item: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}, {"sha": "d4494a5aff2e9216ef9ffb29b270f48705fbac6a", "filename": "src/test/ui/proc-macro/auxiliary/recollect.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Frecollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Frecollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Frecollect.rs?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -0,0 +1,12 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn recollect(tokens: TokenStream) -> TokenStream {\n+    tokens.into_iter().collect()\n+}"}, {"sha": "338e436df500fa223cd0e75db6aa3a6af7befb97", "filename": "src/test/ui/proc-macro/auxiliary/weird-hygiene.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fweird-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fweird-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fweird-hygiene.rs?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -0,0 +1,48 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenTree, Group};\n+\n+fn find_my_ident(tokens: TokenStream) -> Option<TokenStream> {\n+    for token in tokens {\n+        if let TokenTree::Ident(ident) = &token {\n+            if ident.to_string() == \"hidden_ident\" {\n+                return Some(vec![token].into_iter().collect())\n+            }\n+        } else if let TokenTree::Group(g) = token {\n+            if let Some(stream) = find_my_ident(g.stream()) {\n+                return Some(stream)\n+            }\n+        }\n+    }\n+    return None;\n+}\n+\n+\n+#[proc_macro_derive(WeirdDerive)]\n+pub fn weird_derive(item: TokenStream) -> TokenStream {\n+    let my_ident = find_my_ident(item).expect(\"Missing 'my_ident'!\");\n+    let tokens: TokenStream = \"call_it!();\".parse().unwrap();\n+    let final_call = tokens.into_iter().map(|tree| {\n+        if let TokenTree::Group(g) = tree {\n+            return Group::new(g.delimiter(), my_ident.clone()).into()\n+        } else {\n+            return tree\n+        }\n+    }).collect();\n+    final_call\n+}\n+\n+#[proc_macro]\n+pub fn recollect(item: TokenStream) -> TokenStream {\n+    item.into_iter().collect()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn recollect_attr(_attr: TokenStream, mut item: TokenStream) -> TokenStream {\n+    item.into_iter().collect()\n+}"}, {"sha": "a404ddace9bbe8b6ab5c9fcb067718aea93a6096", "filename": "src/test/ui/proc-macro/capture-macro-rules-invoke.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-macro-rules-invoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-macro-rules-invoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcapture-macro-rules-invoke.rs?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -0,0 +1,22 @@\n+// aux-build:test-macros.rs\n+// check-pass\n+\n+extern crate test_macros;\n+use test_macros::recollect;\n+\n+macro_rules! use_expr {\n+    ($expr:expr) => {\n+        recollect!($expr)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+struct Foo;\n+impl Foo {\n+    #[allow(dead_code)]\n+    fn use_self(self) {\n+        drop(use_expr!(self));\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5b4d577a1acc42a8919f6ae802169044b46e1fe6", "filename": "src/test/ui/proc-macro/macro-rules-derive.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-derive.rs?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -0,0 +1,20 @@\n+// aux-build:first-second.rs\n+// FIXME: The spans here are bad, see PR #73084\n+\n+extern crate first_second;\n+use first_second::*;\n+\n+macro_rules! produce_it {\n+    ($name:ident) => {\n+        #[first] //~ ERROR cannot find type\n+        struct $name {\n+            field: MissingType\n+        }\n+    }\n+}\n+\n+produce_it!(MyName);\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "4b72d29fe8ae068ee0796a62ab3263dcd5dcb1ed", "filename": "src/test/ui/proc-macro/macro-rules-derive.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-derive.stderr?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `MissingType` in this scope\n+  --> $DIR/macro-rules-derive.rs:9:9\n+   |\n+LL |         #[first]\n+   |         ^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "3f48191b5b26e42c69f67b830a9f78c5461c0979", "filename": "src/test/ui/proc-macro/weird-hygiene.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fweird-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c90ae8404b6b83bc3cba35840ddf7edd500cc86/src%2Ftest%2Fui%2Fproc-macro%2Fweird-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fweird-hygiene.rs?ref=3c90ae8404b6b83bc3cba35840ddf7edd500cc86", "patch": "@@ -0,0 +1,48 @@\n+// aux-build:weird-hygiene.rs\n+// check-pass\n+// FIXME: This should actually error, see PR #73084\n+\n+#![feature(stmt_expr_attributes)]\n+#![feature(proc_macro_hygiene)]\n+\n+extern crate weird_hygiene;\n+use weird_hygiene::*;\n+\n+macro_rules! other {\n+    ($tokens:expr) => {\n+        macro_rules! call_it {\n+            ($outer_ident:ident) => {\n+                macro_rules! inner {\n+                    () => {\n+                        $outer_ident;\n+                    }\n+                }\n+            }\n+        }\n+\n+        #[derive(WeirdDerive)]\n+        enum MyEnum {\n+            Value = (stringify!($tokens + hidden_ident), 1).1\n+        }\n+\n+        inner!();\n+    }\n+}\n+\n+macro_rules! invoke_it {\n+    ($token:expr) => {\n+        #[recollect_attr] {\n+            $token;\n+            hidden_ident\n+        }\n+    }\n+}\n+\n+fn main() {\n+    // `other` and `invoke_it` are both macro_rules! macros,\n+    // so it should be impossible for them to ever see `hidden_ident`,\n+    // even if they invoke a proc macro.\n+    let hidden_ident = \"Hello1\";\n+    other!(50);\n+    invoke_it!(25);\n+}"}]}