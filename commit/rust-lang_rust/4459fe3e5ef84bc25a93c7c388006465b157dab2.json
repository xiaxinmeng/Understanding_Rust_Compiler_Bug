{"sha": "4459fe3e5ef84bc25a93c7c388006465b157dab2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NTlmZTNlNWVmODRiYzI1YTkzYzdjMzg4MDA2NDY1YjE1N2RhYjI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-04T16:47:59Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-05T04:29:27Z"}, "message": "Revise `VecPerParamSpace` to use a one Vec rather than three.\n\nIn my informal measurements, this brings the peak memory usage when\nbuilding librustc from 1662M down to 1502M.  Since 1662 - 1502 = 160,\nthis may not recover the entirety of the observed memory regression\n(250M) from PR #14604.  (However, according to my local measurements,\nthe regression when building librustc was more like 209M, so perhaps\nthis will still recover the lions share of the lost memory.)", "tree": {"sha": "132525dc504dd2da26e5a76c31b16b79e019104c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/132525dc504dd2da26e5a76c31b16b79e019104c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4459fe3e5ef84bc25a93c7c388006465b157dab2", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4459fe3e5ef84bc25a93c7c388006465b157dab2", "html_url": "https://github.com/rust-lang/rust/commit/4459fe3e5ef84bc25a93c7c388006465b157dab2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4459fe3e5ef84bc25a93c7c388006465b157dab2/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "952dded81a0a5c51ce802ae6753dd69f45e9ce61", "url": "https://api.github.com/repos/rust-lang/rust/commits/952dded81a0a5c51ce802ae6753dd69f45e9ce61", "html_url": "https://github.com/rust-lang/rust/commit/952dded81a0a5c51ce802ae6753dd69f45e9ce61"}], "stats": {"total": 157, "additions": 116, "deletions": 41}, "files": [{"sha": "4684bd3532ec13ebb9daedfbb227b958c0da7031", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 116, "deletions": 41, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/4459fe3e5ef84bc25a93c7c388006465b157dab2/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4459fe3e5ef84bc25a93c7c388006465b157dab2/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=4459fe3e5ef84bc25a93c7c388006465b157dab2", "patch": "@@ -15,7 +15,6 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n-use std::iter::Chain;\n use std::mem;\n use std::raw;\n use std::slice::{Items, MutItems};\n@@ -191,8 +190,8 @@ impl Substs {\n     }\n \n     pub fn with_method_from(self, substs: &Substs) -> Substs {\n-        self.with_method((*substs.types.get_vec(FnSpace)).clone(),\n-                         (*substs.regions().get_vec(FnSpace)).clone())\n+        self.with_method(Vec::from_slice(substs.types.get_slice(FnSpace)),\n+                         Vec::from_slice(substs.regions().get_slice(FnSpace)))\n     }\n \n     pub fn with_method(self,\n@@ -261,19 +260,44 @@ impl ParamSpace {\n  */\n #[deriving(PartialEq, Eq, Clone, Hash, Encodable, Decodable)]\n pub struct VecPerParamSpace<T> {\n-    vecs: (Vec<T>, Vec<T>, Vec<T>)\n+    // This was originally represented as a tuple with one Vec<T> for\n+    // each variant of ParamSpace, and that remains the abstraction\n+    // that it provides to its clients.\n+    //\n+    // Here is how the representation corresponds to the abstraction\n+    // i.e. the \"abstraction function\" AF:\n+    //\n+    // AF(self) = (self.content.slice_to(self.type_limit),\n+    //             self.content.slice(self.type_limit, self.self_limit),\n+    //             self.content.slice_from(self.self_limit))\n+    type_limit: uint,\n+    self_limit: uint,\n+    content: Vec<T>,\n }\n \n impl<T:Clone> VecPerParamSpace<T> {\n     pub fn push_all(&mut self, space: ParamSpace, values: &[T]) {\n-        self.get_mut_vec(space).push_all(values);\n+        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n+        for t in values.iter() {\n+            self.push(space, t.clone());\n+        }\n     }\n }\n \n impl<T> VecPerParamSpace<T> {\n+    fn limits(&self, space: ParamSpace) -> (uint, uint) {\n+        match space {\n+            TypeSpace => (0, self.type_limit),\n+            SelfSpace => (self.type_limit, self.self_limit),\n+            FnSpace => (self.self_limit, self.content.len()),\n+        }\n+    }\n+\n     pub fn empty() -> VecPerParamSpace<T> {\n         VecPerParamSpace {\n-            vecs: (Vec::new(), Vec::new(), Vec::new())\n+            type_limit: 0,\n+            self_limit: 0,\n+            content: Vec::new()\n         }\n     }\n \n@@ -282,8 +306,15 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n+        let type_limit = t.len();\n+        let self_limit = t.len() + s.len();\n+        let mut content = t;\n+        content.push_all_move(s);\n+        content.push_all_move(f);\n         VecPerParamSpace {\n-            vecs: (t, s, f)\n+            type_limit: type_limit,\n+            self_limit: self_limit,\n+            content: content,\n         }\n     }\n \n@@ -295,75 +326,98 @@ impl<T> VecPerParamSpace<T> {\n         result\n     }\n \n+    /// Appends `value` to the vector associated with `space`.\n+    ///\n+    /// Unlike the `push` method in `Vec`, this should not be assumed\n+    /// to be a cheap operation (even when amortized over many calls).\n     pub fn push(&mut self, space: ParamSpace, value: T) {\n-        self.get_mut_vec(space).push(value);\n+        let (_, limit) = self.limits(space);\n+        match space {\n+            TypeSpace => { self.type_limit += 1; self.self_limit += 1; }\n+            SelfSpace => { self.self_limit += 1; }\n+            FnSpace   => {}\n+        }\n+        self.content.insert(limit, value);\n     }\n \n     pub fn pop(&mut self, space: ParamSpace) -> Option<T> {\n-        self.get_mut_vec(space).pop()\n+        let (start, limit) = self.limits(space);\n+        if start == limit {\n+            None\n+        } else {\n+            match space {\n+                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; }\n+                SelfSpace => { self.self_limit -= 1; }\n+                FnSpace   => {}\n+            }\n+            self.content.remove(limit - 1)\n+        }\n     }\n \n     pub fn truncate(&mut self, space: ParamSpace, len: uint) {\n-        self.get_mut_vec(space).truncate(len)\n+        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n+        while self.len(space) > len {\n+            self.pop(space);\n+        }\n     }\n \n     pub fn replace(&mut self, space: ParamSpace, elems: Vec<T>) {\n-        *self.get_mut_vec(space) = elems;\n+        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n+        self.truncate(space, 0);\n+        for t in elems.move_iter() {\n+            self.push(space, t);\n+        }\n     }\n \n     pub fn get_self<'a>(&'a self) -> Option<&'a T> {\n-        let v = self.get_vec(SelfSpace);\n+        let v = self.get_slice(SelfSpace);\n         assert!(v.len() <= 1);\n-        if v.len() == 0 { None } else { Some(v.get(0)) }\n+        if v.len() == 0 { None } else { Some(&v[0]) }\n     }\n \n     pub fn len(&self, space: ParamSpace) -> uint {\n-        self.get_vec(space).len()\n+        self.get_slice(space).len()\n     }\n \n     pub fn is_empty_in(&self, space: ParamSpace) -> bool {\n-        self.get_vec(space).len() == 0\n+        self.len(space) == 0\n     }\n \n     pub fn get_slice<'a>(&'a self, space: ParamSpace) -> &'a [T] {\n-        self.get_vec(space).as_slice()\n-    }\n-\n-    fn get_vec<'a>(&'a self, space: ParamSpace) -> &'a Vec<T> {\n-        self.vecs.get(space as uint).unwrap()\n+        let (start, limit) = self.limits(space);\n+        self.content.slice(start, limit)\n     }\n \n-    fn get_mut_vec<'a>(&'a mut self, space: ParamSpace) -> &'a mut Vec<T> {\n-        self.vecs.get_mut(space as uint).unwrap()\n+    fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n+        let (start, limit) = self.limits(space);\n+        self.content.mut_slice(start, limit)\n     }\n \n     pub fn opt_get<'a>(&'a self,\n                        space: ParamSpace,\n                        index: uint)\n                        -> Option<&'a T> {\n-        let v = self.get_vec(space);\n-        if index < v.len() { Some(v.get(index)) } else { None }\n+        let v = self.get_slice(space);\n+        if index < v.len() { Some(&v[index]) } else { None }\n     }\n \n     pub fn get<'a>(&'a self, space: ParamSpace, index: uint) -> &'a T {\n-        self.get_vec(space).get(index)\n+        &self.get_slice(space)[index]\n     }\n \n     pub fn get_mut<'a>(&'a mut self,\n                        space: ParamSpace,\n                        index: uint) -> &'a mut T {\n-        self.get_mut_vec(space).get_mut(index)\n+        &mut self.get_mut_slice(space)[index]\n     }\n \n-    pub fn iter<'a>(&'a self) -> Chain<Items<'a,T>,\n-                                       Chain<Items<'a,T>,\n-                                             Items<'a,T>>> {\n-        let (ref r, ref s, ref f) = self.vecs;\n-        r.iter().chain(s.iter().chain(f.iter()))\n+    pub fn iter<'a>(&'a self) -> Items<'a,T> {\n+        self.content.iter()\n     }\n \n     pub fn all_vecs(&self, pred: |&[T]| -> bool) -> bool {\n-        self.vecs.iter().map(|v|v.as_slice()).all(pred)\n+        let spaces = [TypeSpace, SelfSpace, FnSpace];\n+        spaces.iter().all(|&space| { pred(self.get_slice(space)) })\n     }\n \n     pub fn all(&self, pred: |&T| -> bool) -> bool {\n@@ -379,9 +433,13 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn map<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n-        VecPerParamSpace::new(self.vecs.ref0().iter().map(|p| pred(p)).collect(),\n-                              self.vecs.ref1().iter().map(|p| pred(p)).collect(),\n-                              self.vecs.ref2().iter().map(|p| pred(p)).collect())\n+        // FIXME (#15418): this could avoid allocating the intermediate\n+        // Vec's, but note that the values of type_limit and self_limit\n+        // also need to be kept in sync during construction.\n+        VecPerParamSpace::new(\n+            self.get_slice(TypeSpace).iter().map(|p| pred(p)).collect(),\n+            self.get_slice(SelfSpace).iter().map(|p| pred(p)).collect(),\n+            self.get_slice(FnSpace).iter().map(|p| pred(p)).collect())\n     }\n \n     pub fn map_rev<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n@@ -394,29 +452,46 @@ impl<T> VecPerParamSpace<T> {\n          * can be run to a fixed point\n          */\n \n-        let mut fns: Vec<U> = self.vecs.ref2().iter().rev().map(|p| pred(p)).collect();\n+        let mut fns: Vec<U> = self.get_slice(FnSpace).iter().rev().map(|p| pred(p)).collect();\n \n         // NB: Calling foo.rev().map().rev() causes the calls to map\n         // to occur in the wrong order. This was somewhat surprising\n         // to me, though it makes total sense.\n         fns.reverse();\n \n-        let mut selfs: Vec<U> = self.vecs.ref1().iter().rev().map(|p| pred(p)).collect();\n+        let mut selfs: Vec<U> = self.get_slice(SelfSpace).iter().rev().map(|p| pred(p)).collect();\n         selfs.reverse();\n-        let mut tys: Vec<U> = self.vecs.ref0().iter().rev().map(|p| pred(p)).collect();\n+        let mut tys: Vec<U> = self.get_slice(TypeSpace).iter().rev().map(|p| pred(p)).collect();\n         tys.reverse();\n         VecPerParamSpace::new(tys, selfs, fns)\n     }\n \n     pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {\n-        self.vecs\n+        // FIXME (#15418): this does two traversals when in principle\n+        // one would suffice.  i.e. change to use `move_iter`.\n+        let VecPerParamSpace { type_limit, self_limit, content } = self;\n+        let mut i = 0;\n+        let (prefix, fn_vec) = content.partition(|_| {\n+            let on_left = i < self_limit;\n+            i += 1;\n+            on_left\n+        });\n+\n+        let mut i = 0;\n+        let (type_vec, self_vec) = prefix.partition(|_| {\n+            let on_left = i < type_limit;\n+            i += 1;\n+            on_left\n+        });\n+\n+        (type_vec, self_vec, fn_vec)\n     }\n \n     pub fn with_vec(mut self, space: ParamSpace, vec: Vec<T>)\n                     -> VecPerParamSpace<T>\n     {\n-        assert!(self.get_vec(space).is_empty());\n-        *self.get_mut_vec(space) = vec;\n+        assert!(self.is_empty_in(space));\n+        self.replace(space, vec);\n         self\n     }\n }"}]}