{"sha": "a3278a16d31198d45c710c3c4dde433fc77d8d90", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMjc4YTE2ZDMxMTk4ZDQ1YzcxMGMzYzRkZGU0MzNmYzc3ZDhkOTA=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-02-28T14:03:21Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-02-28T14:13:24Z"}, "message": "Fix `manual_map`: do not expand macros in suggestions", "tree": {"sha": "a73ad88d81c820b8b6345a98ae2f40eb99928f21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a73ad88d81c820b8b6345a98ae2f40eb99928f21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3278a16d31198d45c710c3c4dde433fc77d8d90", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmA7pQwACgkQ2lnoZDo37QY9wwD7Bvbp+gW97TA/5tPdhEHE0Eoz\nNxerhbSXh71xhKymW04A/27PmIEdlf7PWevVfAo65XzvTB9o7ymIruDhpVVzc3cG\n=Tr5n\n-----END PGP SIGNATURE-----", "payload": "tree a73ad88d81c820b8b6345a98ae2f40eb99928f21\nparent 09a827ac735b138a06f3ac140a1c465b05a92ed1\nauthor Jason Newcomb <jsnewcomb@pm.me> 1614521001 -0500\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1614521604 -0500\n\nFix `manual_map`: do not expand macros in suggestions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3278a16d31198d45c710c3c4dde433fc77d8d90", "html_url": "https://github.com/rust-lang/rust/commit/a3278a16d31198d45c710c3c4dde433fc77d8d90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3278a16d31198d45c710c3c4dde433fc77d8d90/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09a827ac735b138a06f3ac140a1c465b05a92ed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/09a827ac735b138a06f3ac140a1c465b05a92ed1", "html_url": "https://github.com/rust-lang/rust/commit/09a827ac735b138a06f3ac140a1c465b05a92ed1"}], "stats": {"total": 218, "additions": 146, "deletions": 72}, "files": [{"sha": "983a10e8eaa2298fc3474582d44527c4f9d3e5f5", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 80, "deletions": 69, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/a3278a16d31198d45c710c3c4dde433fc77d8d90/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3278a16d31198d45c710c3c4dde433fc77d8d90/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=a3278a16d31198d45c710c3c4dde433fc77d8d90", "patch": "@@ -3,7 +3,8 @@ use crate::{\n     matches::MATCH_AS_REF,\n     utils::{\n         can_partially_move_ty, is_allowed, is_type_diagnostic_item, match_def_path, match_var, paths,\n-        peel_hir_expr_refs, peel_mid_ty_refs_is_mutable, snippet_with_applicability, span_lint_and_sugg,\n+        peel_hir_expr_refs, peel_mid_ty_refs_is_mutable, snippet_with_applicability, snippet_with_context,\n+        span_lint_and_sugg,\n     },\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n@@ -16,7 +17,10 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{\n+    symbol::{sym, Ident},\n+    SyntaxContext,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usages of `match` which could be implemented using `map`\n@@ -56,43 +60,46 @@ impl LateLintPass<'_> for ManualMap {\n         {\n             let (scrutinee_ty, ty_ref_count, ty_mutability) =\n                 peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-            if !is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n-                || !is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type)\n+            if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+                && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n             {\n                 return;\n             }\n \n-            let (some_expr, some_pat, pat_ref_count, is_wild_none) =\n-                match (try_parse_pattern(cx, arm1.pat), try_parse_pattern(cx, arm2.pat)) {\n-                    (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n-                        if is_none_expr(cx, arm1.body) =>\n-                    {\n-                        (arm2.body, pattern, ref_count, true)\n-                    },\n-                    (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n-                        if is_none_expr(cx, arm1.body) =>\n-                    {\n-                        (arm2.body, pattern, ref_count, false)\n-                    },\n-                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n-                        if is_none_expr(cx, arm2.body) =>\n-                    {\n-                        (arm1.body, pattern, ref_count, true)\n-                    },\n-                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n-                        if is_none_expr(cx, arm2.body) =>\n-                    {\n-                        (arm1.body, pattern, ref_count, false)\n-                    },\n-                    _ => return,\n-                };\n+            let expr_ctxt = expr.span.ctxt();\n+            let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+                try_parse_pattern(cx, arm1.pat, expr_ctxt),\n+                try_parse_pattern(cx, arm2.pat, expr_ctxt),\n+            ) {\n+                (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n+                    if is_none_expr(cx, arm1.body) =>\n+                {\n+                    (arm2.body, pattern, ref_count, true)\n+                },\n+                (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n+                    if is_none_expr(cx, arm1.body) =>\n+                {\n+                    (arm2.body, pattern, ref_count, false)\n+                },\n+                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n+                    if is_none_expr(cx, arm2.body) =>\n+                {\n+                    (arm1.body, pattern, ref_count, true)\n+                },\n+                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n+                    if is_none_expr(cx, arm2.body) =>\n+                {\n+                    (arm1.body, pattern, ref_count, false)\n+                },\n+                _ => return,\n+            };\n \n             // Top level or patterns aren't allowed in closures.\n             if matches!(some_pat.kind, PatKind::Or(_)) {\n                 return;\n             }\n \n-            let some_expr = match get_some_expr(cx, some_expr) {\n+            let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n                 Some(expr) => expr,\n                 None => return,\n             };\n@@ -119,47 +126,50 @@ impl LateLintPass<'_> for ManualMap {\n \n             let mut app = Applicability::MachineApplicable;\n \n-            // Remove address-of expressions from the scrutinee. `as_ref` will be called,\n-            // the type is copyable, or the option is being passed by value.\n+            // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+            // it's being passed by value.\n             let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-            let scrutinee_str = snippet_with_applicability(cx, scrutinee.span, \"_\", &mut app);\n-            let scrutinee_str = if expr.precedence().order() < PREC_POSTFIX {\n-                // Parens are needed to chain method calls.\n-                format!(\"({})\", scrutinee_str)\n-            } else {\n-                scrutinee_str.into()\n-            };\n+            let scrutinee_str = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+            let scrutinee_str =\n+                if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+                    format!(\"({})\", scrutinee_str)\n+                } else {\n+                    scrutinee_str.into()\n+                };\n \n             let body_str = if let PatKind::Binding(annotation, _, some_binding, None) = some_pat.kind {\n-                if let Some(func) = can_pass_as_func(cx, some_binding, some_expr) {\n-                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                } else {\n-                    if match_var(some_expr, some_binding.name)\n-                        && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                        && binding_ref.is_some()\n-                    {\n-                        return;\n-                    }\n+                match can_pass_as_func(cx, some_binding, some_expr) {\n+                    Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+                        snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+                    },\n+                    _ => {\n+                        if match_var(some_expr, some_binding.name)\n+                            && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                            && binding_ref.is_some()\n+                        {\n+                            return;\n+                        }\n \n-                    // `ref` and `ref mut` annotations were handled earlier.\n-                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                        \"mut \"\n-                    } else {\n-                        \"\"\n-                    };\n-                    format!(\n-                        \"|{}{}| {}\",\n-                        annotation,\n-                        some_binding,\n-                        snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n-                    )\n+                        // `ref` and `ref mut` annotations were handled earlier.\n+                        let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                            \"mut \"\n+                        } else {\n+                            \"\"\n+                        };\n+                        format!(\n+                            \"|{}{}| {}\",\n+                            annotation,\n+                            some_binding,\n+                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n+                        )\n+                    },\n                 }\n             } else if !is_wild_none && explicit_ref.is_none() {\n                 // TODO: handle explicit reference annotations.\n                 format!(\n                     \"|{}| {}\",\n-                    snippet_with_applicability(cx, some_pat.span, \"..\", &mut app),\n-                    snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n+                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app),\n+                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n                 )\n             } else {\n                 // Refutable bindings and mixed reference annotations can't be handled by `map`.\n@@ -246,11 +256,11 @@ enum OptionPat<'a> {\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) -> Option<OptionPat<'tcx>> {\n-    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize) -> Option<OptionPat<'tcx>> {\n+fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n             PatKind::Path(QPath::Resolved(None, path))\n                 if path\n                     .res\n@@ -263,18 +273,19 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) -> Option<Optio\n                 if path\n                     .res\n                     .opt_def_id()\n-                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME)) =>\n+                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME))\n+                    && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n             _ => None,\n         }\n     }\n-    f(cx, pat, 0)\n+    f(cx, pat, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxContext) -> Option<&'tcx Expr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n         ExprKind::Call(\n@@ -283,7 +294,7 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx E\n                 ..\n             },\n             [arg],\n-        ) => {\n+        ) if ctxt == expr.span.ctxt() => {\n             if match_def_path(cx, path.res.opt_def_id()?, &paths::OPTION_SOME) {\n                 Some(arg)\n             } else {\n@@ -297,7 +308,7 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx E\n                 ..\n             },\n             _,\n-        ) => get_some_expr(cx, expr),\n+        ) => get_some_expr(cx, expr, ctxt),\n         _ => None,\n     }\n }"}, {"sha": "5d1093ea0404041b051b8019b92dc9a0ec046937", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a3278a16d31198d45c710c3c4dde433fc77d8d90/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3278a16d31198d45c710c3c4dde433fc77d8d90/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=a3278a16d31198d45c710c3c4dde433fc77d8d90", "patch": "@@ -73,11 +73,11 @@ use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnKind, MacroKind};\n+use rustc_span::hygiene::{self, ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Pos, Span, SyntaxContext, DUMMY_SP};\n use rustc_target::abi::Integer;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use smallvec::SmallVec;\n@@ -758,6 +758,35 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n     reindent_multiline(snip, true, indent)\n }\n \n+/// Same as `snippet_with_applicability`, but first walks the span up to the given context. This\n+/// will result in the macro call, rather then the expansion, if the span is from a child context.\n+/// If the span is not from a child context, it will be used directly instead.\n+///\n+/// e.g. Given the expression `&vec![]`, getting a snippet from the span for `vec![]` as a HIR node\n+/// would result in `box []`. If given the context of the address of expression, this function will\n+/// correctly get a snippet of `vec![]`.\n+pub fn snippet_with_context(\n+    cx: &LateContext<'_>,\n+    span: Span,\n+    outer: SyntaxContext,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    let outer_span = hygiene::walk_chain(span, outer);\n+    let span = if outer_span.ctxt() == outer {\n+        outer_span\n+    } else {\n+        // The span is from a macro argument, and the outer context is the macro using the argument\n+        if *applicability != Applicability::Unspecified {\n+            *applicability = Applicability::MaybeIncorrect;\n+        }\n+        // TODO: get the argument span.\n+        span\n+    };\n+\n+    snippet_with_applicability(cx, span, default, applicability)\n+}\n+\n /// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n /// line.\n ///"}, {"sha": "e6fa10d22e1eb3ec400273f9c4416c61577333d6", "filename": "tests/ui/manual_map_option.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3278a16d31198d45c710c3c4dde433fc77d8d90/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3278a16d31198d45c710c3c4dde433fc77d8d90/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=a3278a16d31198d45c710c3c4dde433fc77d8d90", "patch": "@@ -110,4 +110,9 @@ fn main() {\n             }\n         }\n     }\n+\n+    // #6811\n+    Some(0).map(|x| vec![x]);\n+\n+    option_env!(\"\").map(String::from);\n }"}, {"sha": "7c2100299a7199f788b08b4dad6db6e9c70e2224", "filename": "tests/ui/manual_map_option.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3278a16d31198d45c710c3c4dde433fc77d8d90/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3278a16d31198d45c710c3c4dde433fc77d8d90/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=a3278a16d31198d45c710c3c4dde433fc77d8d90", "patch": "@@ -162,4 +162,15 @@ fn main() {\n             }\n         }\n     }\n+\n+    // #6811\n+    match Some(0) {\n+        Some(x) => Some(vec![x]),\n+        None => None,\n+    };\n+\n+    match option_env!(\"\") {\n+        Some(x) => Some(String::from(x)),\n+        None => None,\n+    };\n }"}, {"sha": "2d13213cf679b3d5bf3e0591ae033d29bed6b2df", "filename": "tests/ui/manual_map_option.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3278a16d31198d45c710c3c4dde433fc77d8d90/tests%2Fui%2Fmanual_map_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3278a16d31198d45c710c3c4dde433fc77d8d90/tests%2Fui%2Fmanual_map_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.stderr?ref=a3278a16d31198d45c710c3c4dde433fc77d8d90", "patch": "@@ -154,5 +154,23 @@ LL | |         None => None,\n LL | |     };\n    | |_____^ help: try this: `Some((String::new(), \"test\")).as_ref().map(|(x, y)| (y, x))`\n \n-error: aborting due to 17 previous errors\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:167:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(x) => Some(vec![x]),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| vec![x])`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:172:5\n+   |\n+LL | /     match option_env!(\"\") {\n+LL | |         Some(x) => Some(String::from(x)),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `option_env!(\"\").map(String::from)`\n+\n+error: aborting due to 19 previous errors\n "}]}