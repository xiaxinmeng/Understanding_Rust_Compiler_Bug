{"sha": "430575b61a95fc559f5021e246c04c3468acd1d6", "node_id": "C_kwDOAAsO6NoAKDQzMDU3NWI2MWE5NWZjNTU5ZjUwMjFlMjQ2YzA0YzM0NjhhY2QxZDY", "commit": {"author": {"name": "Elliot Bobrow", "email": "elliotgreybobrow@gmail.com", "date": "2022-04-06T16:28:49Z"}, "committer": {"name": "Elliot Bobrow", "email": "elliotgreybobrow@gmail.com", "date": "2022-05-17T03:20:49Z"}, "message": "add `manual_find` lint for function return case", "tree": {"sha": "e396859feb8db8a778cf5d415ef153f81e755b32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e396859feb8db8a778cf5d415ef153f81e755b32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/430575b61a95fc559f5021e246c04c3468acd1d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/430575b61a95fc559f5021e246c04c3468acd1d6", "html_url": "https://github.com/rust-lang/rust/commit/430575b61a95fc559f5021e246c04c3468acd1d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/430575b61a95fc559f5021e246c04c3468acd1d6/comments", "author": {"login": "ebobrow", "id": 77182873, "node_id": "MDQ6VXNlcjc3MTgyODcz", "avatar_url": "https://avatars.githubusercontent.com/u/77182873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebobrow", "html_url": "https://github.com/ebobrow", "followers_url": "https://api.github.com/users/ebobrow/followers", "following_url": "https://api.github.com/users/ebobrow/following{/other_user}", "gists_url": "https://api.github.com/users/ebobrow/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebobrow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebobrow/subscriptions", "organizations_url": "https://api.github.com/users/ebobrow/orgs", "repos_url": "https://api.github.com/users/ebobrow/repos", "events_url": "https://api.github.com/users/ebobrow/events{/privacy}", "received_events_url": "https://api.github.com/users/ebobrow/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebobrow", "id": 77182873, "node_id": "MDQ6VXNlcjc3MTgyODcz", "avatar_url": "https://avatars.githubusercontent.com/u/77182873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebobrow", "html_url": "https://github.com/ebobrow", "followers_url": "https://api.github.com/users/ebobrow/followers", "following_url": "https://api.github.com/users/ebobrow/following{/other_user}", "gists_url": "https://api.github.com/users/ebobrow/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebobrow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebobrow/subscriptions", "organizations_url": "https://api.github.com/users/ebobrow/orgs", "repos_url": "https://api.github.com/users/ebobrow/repos", "events_url": "https://api.github.com/users/ebobrow/events{/privacy}", "received_events_url": "https://api.github.com/users/ebobrow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6206086dd5a83477131094b1f0ef61b10e7ced42", "url": "https://api.github.com/repos/rust-lang/rust/commits/6206086dd5a83477131094b1f0ef61b10e7ced42", "html_url": "https://github.com/rust-lang/rust/commit/6206086dd5a83477131094b1f0ef61b10e7ced42"}], "stats": {"total": 875, "additions": 844, "deletions": 31}, "files": [{"sha": "0011f50da20bd4618b8bee0551ce369a2ad2cd56", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -3384,6 +3384,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_bits`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n+[`manual_find`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n [`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n [`manual_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_map"}, {"sha": "844008254a8d749f70a3b41e3ac46ecc7deb5c46", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -109,6 +109,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(loops::FOR_KV_MAP),\n     LintId::of(loops::FOR_LOOPS_OVER_FALLIBLES),\n     LintId::of(loops::ITER_NEXT_LOOP),\n+    LintId::of(loops::MANUAL_FIND),\n     LintId::of(loops::MANUAL_FLATTEN),\n     LintId::of(loops::MANUAL_MEMCPY),\n     LintId::of(loops::MISSING_SPIN_LOOP),"}, {"sha": "64f5b2df0043c8f183163f12a9396e2b3aa10704", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -21,6 +21,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(lifetimes::EXTRA_UNUSED_LIFETIMES),\n     LintId::of(lifetimes::NEEDLESS_LIFETIMES),\n     LintId::of(loops::EXPLICIT_COUNTER_LOOP),\n+    LintId::of(loops::MANUAL_FIND),\n     LintId::of(loops::MANUAL_FLATTEN),\n     LintId::of(loops::SINGLE_ELEMENT_LOOP),\n     LintId::of(loops::WHILE_LET_LOOP),"}, {"sha": "d5ddb95d25f8ac5a6ab495e21d43e6d16ac23551", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -222,6 +222,7 @@ store.register_lints(&[\n     loops::FOR_KV_MAP,\n     loops::FOR_LOOPS_OVER_FALLIBLES,\n     loops::ITER_NEXT_LOOP,\n+    loops::MANUAL_FIND,\n     loops::MANUAL_FLATTEN,\n     loops::MANUAL_MEMCPY,\n     loops::MISSING_SPIN_LOOP,"}, {"sha": "33736d6d4e650691e6f9a394b2d2f7b8def212e0", "filename": "clippy_lints/src/loops/manual_find.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -0,0 +1,158 @@\n+use super::utils::make_iterator_snippet;\n+use super::MANUAL_FIND;\n+use clippy_utils::{\n+    diagnostics::span_lint_and_then, higher, is_lang_ctor, path_res, peel_blocks_with_stmt,\n+    source::snippet_with_applicability, ty::implements_trait,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    def::Res, lang_items::LangItem, BindingAnnotation, Block, Expr, ExprKind, HirId, Node, Pat, PatKind, Stmt, StmtKind,\n+};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    span: Span,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    let inner_expr = peel_blocks_with_stmt(body);\n+    // Check for the specific case that the result is returned and optimize suggestion for that (more\n+    // cases can be added later)\n+    if_chain! {\n+        if let Some(higher::If { cond, then, r#else: None, }) = higher::If::hir(inner_expr);\n+        if let Some(binding_id) = get_binding(pat);\n+        if let ExprKind::Block(block, _) = then.kind;\n+        if let [stmt] = block.stmts;\n+        if let StmtKind::Semi(semi) = stmt.kind;\n+        if let ExprKind::Ret(Some(ret_value)) = semi.kind;\n+        if let ExprKind::Call(Expr { kind: ExprKind::Path(ctor), .. }, [inner_ret]) = ret_value.kind;\n+        if is_lang_ctor(cx, ctor, LangItem::OptionSome);\n+        if path_res(cx, inner_ret) == Res::Local(binding_id);\n+        if let Some((last_stmt, last_ret)) = last_stmt_and_ret(cx, expr);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let mut snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+            // Checks if `pat` is a single reference to a binding (`&x`)\n+            let is_ref_to_binding =\n+                matches!(pat.kind, PatKind::Ref(inner, _) if matches!(inner.kind, PatKind::Binding(..)));\n+            // If `pat` is not a binding or a reference to a binding (`x` or `&x`)\n+            // we need to map it to the binding returned by the function (i.e. `.map(|(x, _)| x)`)\n+            if !(matches!(pat.kind, PatKind::Binding(..)) || is_ref_to_binding) {\n+                snippet.push_str(\n+                    &format!(\n+                        \".map(|{}| {})\",\n+                        snippet_with_applicability(cx, pat.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, inner_ret.span, \"..\", &mut applicability),\n+                    )[..],\n+                );\n+            }\n+            let ty = cx.typeck_results().expr_ty(inner_ret);\n+            if cx.tcx.lang_items().copy_trait().map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n+                snippet.push_str(\n+                    &format!(\n+                        \".find(|{}{}| {})\",\n+                        \"&\".repeat(1 + usize::from(is_ref_to_binding)),\n+                        snippet_with_applicability(cx, inner_ret.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, cond.span, \"..\", &mut applicability),\n+                    )[..],\n+                );\n+                if is_ref_to_binding {\n+                    snippet.push_str(\".copied()\");\n+                }\n+            } else {\n+                applicability = Applicability::MaybeIncorrect;\n+                snippet.push_str(\n+                    &format!(\n+                        \".find(|{}| {})\",\n+                        snippet_with_applicability(cx, inner_ret.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, cond.span, \"..\", &mut applicability),\n+                    )[..],\n+                );\n+            }\n+            // Extends to `last_stmt` to include semicolon in case of `return None;`\n+            let lint_span = span.to(last_stmt.span).to(last_ret.span);\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_FIND,\n+                lint_span,\n+                \"manual implementation of `Iterator::find`\",\n+                |diag| {\n+                    if applicability == Applicability::MaybeIncorrect {\n+                        diag.note(\"you may need to dereference some variables\");\n+                    }\n+                    diag.span_suggestion(\n+                        lint_span,\n+                        \"replace with an iterator\",\n+                        snippet,\n+                        applicability,\n+                    );\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn get_binding(pat: &Pat<'_>) -> Option<HirId> {\n+    let mut hir_id = None;\n+    let mut count = 0;\n+    pat.each_binding(|annotation, id, _, _| {\n+        count += 1;\n+        if count > 1 {\n+            hir_id = None;\n+            return;\n+        }\n+        if let BindingAnnotation::Unannotated = annotation {\n+            hir_id = Some(id);\n+        }\n+    });\n+    hir_id\n+}\n+\n+// Returns the last statement and last return if function fits format for lint\n+fn last_stmt_and_ret<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<(&'tcx Stmt<'tcx>, &'tcx Expr<'tcx>)> {\n+    // Returns last non-return statement and the last return\n+    fn extract<'tcx>(block: &Block<'tcx>) -> Option<(&'tcx Stmt<'tcx>, &'tcx Expr<'tcx>)> {\n+        if let [.., last_stmt] = block.stmts {\n+            if let Some(ret) = block.expr {\n+                return Some((last_stmt, ret));\n+            }\n+            if_chain! {\n+                if let [.., snd_last, _] = block.stmts;\n+                if let StmtKind::Semi(last_expr) = last_stmt.kind;\n+                if let ExprKind::Ret(Some(ret)) = last_expr.kind;\n+                then {\n+                    return Some((snd_last, ret));\n+                }\n+            }\n+        }\n+        None\n+    }\n+    let mut parent_iter = cx.tcx.hir().parent_iter(expr.hir_id);\n+    if_chain! {\n+        // This should be the loop\n+        if let Some((node_hir, Node::Stmt(..))) = parent_iter.next();\n+        // This should be the funciton body\n+        if let Some((_, Node::Block(block))) = parent_iter.next();\n+        if let Some((last_stmt, last_ret)) = extract(block);\n+        if last_stmt.hir_id == node_hir;\n+        if let ExprKind::Path(path) = &last_ret.kind;\n+        if is_lang_ctor(cx, path, LangItem::OptionNone);\n+        if let Some((_, Node::Expr(_block))) = parent_iter.next();\n+        // This includes the function header\n+        if let Some((_, func)) = parent_iter.next();\n+        if func.fn_kind().is_some();\n+        then {\n+            Some((block.stmts.last().unwrap(), last_ret))\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "2f5d176b2de0b2ae69bbd931f0969577c57ed395", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -5,6 +5,7 @@ mod explicit_iter_loop;\n mod for_kv_map;\n mod for_loops_over_fallibles;\n mod iter_next_loop;\n+mod manual_find;\n mod manual_flatten;\n mod manual_memcpy;\n mod missing_spin_loop;\n@@ -597,6 +598,37 @@ declare_clippy_lint! {\n     \"An empty busy waiting loop\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for manual implementations of Iterator::find\n+    ///\n+    /// ### Why is this bad?\n+    /// It doesn't affect performance, but using `find` is shorter and easier to read.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn example(arr: Vec<i32>) -> Option<i32> {\n+    ///     for el in arr {\n+    ///         if el == 1 {\n+    ///             return Some(el);\n+    ///         }\n+    ///     }\n+    ///     None\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn example(arr: Vec<i32>) -> Option<i32> {\n+    ///     arr.into_iter().find(|&el| el == 1)\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub MANUAL_FIND,\n+    complexity,\n+    \"manual implementation of `Iterator::find`\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     MANUAL_FLATTEN,\n@@ -617,6 +649,7 @@ declare_lint_pass!(Loops => [\n     SAME_ITEM_PUSH,\n     SINGLE_ELEMENT_LOOP,\n     MISSING_SPIN_LOOP,\n+    MANUAL_FIND,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -692,6 +725,7 @@ fn check_for_loop<'tcx>(\n     single_element_loop::check(cx, pat, arg, body, expr);\n     same_item_push::check(cx, pat, arg, body, expr);\n     manual_flatten::check(cx, pat, arg, body, span);\n+    manual_find::check(cx, pat, arg, body, span, expr);\n }\n \n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {"}, {"sha": "4a3edbb9d37ce4ded7d476bbd8b2db2e790657c5", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -159,12 +159,10 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n \n #[must_use]\n fn get_exemptions(interned_name: &str) -> Option<&'static [&'static str]> {\n-    for &list in ALLOWED_TO_BE_SIMILAR {\n-        if allowed_to_be_similar(interned_name, list) {\n-            return Some(list);\n-        }\n-    }\n-    None\n+    ALLOWED_TO_BE_SIMILAR\n+        .iter()\n+        .find(|&&list| allowed_to_be_similar(interned_name, list))\n+        .copied()\n }\n \n #[must_use]"}, {"sha": "257fe045f78a1d0d07f9724f184bb773c05f2bfd", "filename": "tests/ui/manual_find.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_find.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -0,0 +1,22 @@\n+#![allow(unused)]\n+#![warn(clippy::manual_find)]\n+\n+fn vec_string(strings: Vec<String>) -> Option<String> {\n+    for s in strings {\n+        if s == String::new() {\n+            return Some(s);\n+        }\n+    }\n+    None\n+}\n+\n+fn tuple(arr: Vec<(String, i32)>) -> Option<String> {\n+    for (s, _) in arr {\n+        if s == String::new() {\n+            return Some(s);\n+        }\n+    }\n+    None\n+}\n+\n+fn main() {}"}, {"sha": "da0fd4aaef7d6d47296145a61d987151e98a898b", "filename": "tests/ui/manual_find.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_find.stderr?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -0,0 +1,29 @@\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find.rs:5:5\n+   |\n+LL | /     for s in strings {\n+LL | |         if s == String::new() {\n+LL | |             return Some(s);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `strings.into_iter().find(|s| s == String::new())`\n+   |\n+   = note: `-D clippy::manual-find` implied by `-D warnings`\n+   = note: you may need to dereference some variables\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find.rs:14:5\n+   |\n+LL | /     for (s, _) in arr {\n+LL | |         if s == String::new() {\n+LL | |             return Some(s);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().map(|(s, _)| s).find(|s| s == String::new())`\n+   |\n+   = note: you may need to dereference some variables\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "36d1644c22bdac4f2897be042e13ecba34d1420d", "filename": "tests/ui/manual_find_fixable.fixed", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_find_fixable.fixed?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -0,0 +1,182 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_return)]\n+#![warn(clippy::manual_find)]\n+\n+use std::collections::HashMap;\n+\n+const ARRAY: &[u32; 5] = &[2, 7, 1, 9, 3];\n+\n+fn lookup(n: u32) -> Option<u32> {\n+    ARRAY.iter().find(|&&v| v == n).copied()\n+}\n+\n+fn with_pat(arr: Vec<(u32, u32)>) -> Option<u32> {\n+    arr.into_iter().map(|(a, _)| a).find(|&a| a % 2 == 0)\n+}\n+\n+struct Data {\n+    name: String,\n+    is_true: bool,\n+}\n+fn with_struct(arr: Vec<Data>) -> Option<Data> {\n+    arr.into_iter().find(|el| el.name.len() == 10)\n+}\n+\n+struct Tuple(usize, usize);\n+fn with_tuple_struct(arr: Vec<Tuple>) -> Option<usize> {\n+    arr.into_iter().map(|Tuple(a, _)| a).find(|&a| a >= 3)\n+}\n+\n+struct A;\n+impl A {\n+    fn should_keep(&self) -> bool {\n+        true\n+    }\n+}\n+fn with_method_call(arr: Vec<A>) -> Option<A> {\n+    arr.into_iter().find(|el| el.should_keep())\n+}\n+\n+fn with_closure(arr: Vec<u32>) -> Option<u32> {\n+    let f = |el: u32| -> u32 { el + 10 };\n+    arr.into_iter().find(|&el| f(el) == 20)\n+}\n+\n+fn with_closure2(arr: HashMap<String, i32>) -> Option<i32> {\n+    let f = |el: i32| -> bool { el == 10 };\n+    arr.values().find(|&&el| f(el)).copied()\n+}\n+\n+fn with_bool(arr: Vec<Data>) -> Option<Data> {\n+    arr.into_iter().find(|el| el.is_true)\n+}\n+\n+fn with_side_effects(arr: Vec<u32>) -> Option<u32> {\n+    for v in arr {\n+        if v == 1 {\n+            println!(\"side effect\");\n+            return Some(v);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_else(arr: Vec<u32>) -> Option<u32> {\n+    for el in arr {\n+        if el % 2 == 0 {\n+            return Some(el);\n+        } else {\n+            println!(\"{}\", el);\n+        }\n+    }\n+    None\n+}\n+\n+fn tuple_with_ref(v: [(u8, &u8); 3]) -> Option<u8> {\n+    v.into_iter().map(|(_, &x)| x).find(|&x| x > 10)\n+}\n+\n+fn ref_to_tuple_with_ref(v: &[(u8, &u8)]) -> Option<u8> {\n+    v.iter().map(|&(_, &x)| x).find(|&x| x > 10)\n+}\n+\n+fn explicit_ret(arr: Vec<i32>) -> Option<i32> {\n+    arr.into_iter().find(|&x| x >= 5)\n+}\n+\n+fn plus_one(a: i32) -> Option<i32> {\n+    Some(a + 1)\n+}\n+fn fn_instead_of_some(a: &[i32]) -> Option<i32> {\n+    for &x in a {\n+        if x == 1 {\n+            return plus_one(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn for_in_condition(a: &[i32], b: bool) -> Option<i32> {\n+    if b {\n+        for &x in a {\n+            if x == 1 {\n+                return Some(x);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn intermediate_statements(a: &[i32]) -> Option<i32> {\n+    for &x in a {\n+        if x == 1 {\n+            return Some(x);\n+        }\n+    }\n+\n+    println!(\"side effect\");\n+\n+    None\n+}\n+\n+fn mixed_binding_modes(arr: Vec<(i32, String)>) -> Option<i32> {\n+    for (x, mut s) in arr {\n+        if x == 1 && s.as_mut_str().len() == 2 {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn as_closure() {\n+    #[rustfmt::skip]\n+    let f = |arr: Vec<i32>| -> Option<i32> {\n+        arr.into_iter().find(|&x| x < 1)\n+    };\n+}\n+\n+fn in_block(a: &[i32]) -> Option<i32> {\n+    let should_be_none = {\n+        for &x in a {\n+            if x == 1 {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    };\n+\n+    assert!(should_be_none.is_none());\n+\n+    should_be_none\n+}\n+\n+// Not handled yet\n+fn mut_binding(v: Vec<String>) -> Option<String> {\n+    for mut s in v {\n+        if s.as_mut_str().len() > 1 {\n+            return Some(s);\n+        }\n+    }\n+    None\n+}\n+\n+fn subpattern(v: Vec<[u32; 32]>) -> Option<[u32; 32]> {\n+    for a @ [first, ..] in v {\n+        if a[12] == first {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+fn two_bindings(v: Vec<(u8, u8)>) -> Option<u8> {\n+    for (a, n) in v {\n+        if a == n {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+fn main() {}"}, {"sha": "ed277ddaa722d2767acdaafdae6c7aaf9697d827", "filename": "tests/ui/manual_find_fixable.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_find_fixable.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -0,0 +1,242 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_return)]\n+#![warn(clippy::manual_find)]\n+\n+use std::collections::HashMap;\n+\n+const ARRAY: &[u32; 5] = &[2, 7, 1, 9, 3];\n+\n+fn lookup(n: u32) -> Option<u32> {\n+    for &v in ARRAY {\n+        if v == n {\n+            return Some(v);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_pat(arr: Vec<(u32, u32)>) -> Option<u32> {\n+    for (a, _) in arr {\n+        if a % 2 == 0 {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+struct Data {\n+    name: String,\n+    is_true: bool,\n+}\n+fn with_struct(arr: Vec<Data>) -> Option<Data> {\n+    for el in arr {\n+        if el.name.len() == 10 {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+struct Tuple(usize, usize);\n+fn with_tuple_struct(arr: Vec<Tuple>) -> Option<usize> {\n+    for Tuple(a, _) in arr {\n+        if a >= 3 {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+struct A;\n+impl A {\n+    fn should_keep(&self) -> bool {\n+        true\n+    }\n+}\n+fn with_method_call(arr: Vec<A>) -> Option<A> {\n+    for el in arr {\n+        if el.should_keep() {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_closure(arr: Vec<u32>) -> Option<u32> {\n+    let f = |el: u32| -> u32 { el + 10 };\n+    for el in arr {\n+        if f(el) == 20 {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_closure2(arr: HashMap<String, i32>) -> Option<i32> {\n+    let f = |el: i32| -> bool { el == 10 };\n+    for &el in arr.values() {\n+        if f(el) {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_bool(arr: Vec<Data>) -> Option<Data> {\n+    for el in arr {\n+        if el.is_true {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_side_effects(arr: Vec<u32>) -> Option<u32> {\n+    for v in arr {\n+        if v == 1 {\n+            println!(\"side effect\");\n+            return Some(v);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_else(arr: Vec<u32>) -> Option<u32> {\n+    for el in arr {\n+        if el % 2 == 0 {\n+            return Some(el);\n+        } else {\n+            println!(\"{}\", el);\n+        }\n+    }\n+    None\n+}\n+\n+fn tuple_with_ref(v: [(u8, &u8); 3]) -> Option<u8> {\n+    for (_, &x) in v {\n+        if x > 10 {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn ref_to_tuple_with_ref(v: &[(u8, &u8)]) -> Option<u8> {\n+    for &(_, &x) in v {\n+        if x > 10 {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn explicit_ret(arr: Vec<i32>) -> Option<i32> {\n+    for x in arr {\n+        if x >= 5 {\n+            return Some(x);\n+        }\n+    }\n+    return None;\n+}\n+\n+fn plus_one(a: i32) -> Option<i32> {\n+    Some(a + 1)\n+}\n+fn fn_instead_of_some(a: &[i32]) -> Option<i32> {\n+    for &x in a {\n+        if x == 1 {\n+            return plus_one(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn for_in_condition(a: &[i32], b: bool) -> Option<i32> {\n+    if b {\n+        for &x in a {\n+            if x == 1 {\n+                return Some(x);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn intermediate_statements(a: &[i32]) -> Option<i32> {\n+    for &x in a {\n+        if x == 1 {\n+            return Some(x);\n+        }\n+    }\n+\n+    println!(\"side effect\");\n+\n+    None\n+}\n+\n+fn mixed_binding_modes(arr: Vec<(i32, String)>) -> Option<i32> {\n+    for (x, mut s) in arr {\n+        if x == 1 && s.as_mut_str().len() == 2 {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn as_closure() {\n+    #[rustfmt::skip]\n+    let f = |arr: Vec<i32>| -> Option<i32> {\n+        for x in arr {\n+            if x < 1 {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    };\n+}\n+\n+fn in_block(a: &[i32]) -> Option<i32> {\n+    let should_be_none = {\n+        for &x in a {\n+            if x == 1 {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    };\n+\n+    assert!(should_be_none.is_none());\n+\n+    should_be_none\n+}\n+\n+// Not handled yet\n+fn mut_binding(v: Vec<String>) -> Option<String> {\n+    for mut s in v {\n+        if s.as_mut_str().len() > 1 {\n+            return Some(s);\n+        }\n+    }\n+    None\n+}\n+\n+fn subpattern(v: Vec<[u32; 32]>) -> Option<[u32; 32]> {\n+    for a @ [first, ..] in v {\n+        if a[12] == first {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+fn two_bindings(v: Vec<(u8, u8)>) -> Option<u8> {\n+    for (a, n) in v {\n+        if a == n {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+fn main() {}"}, {"sha": "dbc4ff69a740b8780e77b9d51ebcd6aa08f75906", "filename": "tests/ui/manual_find_fixable.stderr", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fmanual_find_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_find_fixable.stderr?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -0,0 +1,142 @@\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:11:5\n+   |\n+LL | /     for &v in ARRAY {\n+LL | |         if v == n {\n+LL | |             return Some(v);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `ARRAY.iter().find(|&&v| v == n).copied()`\n+   |\n+   = note: `-D clippy::manual-find` implied by `-D warnings`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:20:5\n+   |\n+LL | /     for (a, _) in arr {\n+LL | |         if a % 2 == 0 {\n+LL | |             return Some(a);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().map(|(a, _)| a).find(|&a| a % 2 == 0)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:33:5\n+   |\n+LL | /     for el in arr {\n+LL | |         if el.name.len() == 10 {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().find(|el| el.name.len() == 10)`\n+   |\n+   = note: you may need to dereference some variables\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:43:5\n+   |\n+LL | /     for Tuple(a, _) in arr {\n+LL | |         if a >= 3 {\n+LL | |             return Some(a);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().map(|Tuple(a, _)| a).find(|&a| a >= 3)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:58:5\n+   |\n+LL | /     for el in arr {\n+LL | |         if el.should_keep() {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().find(|el| el.should_keep())`\n+   |\n+   = note: you may need to dereference some variables\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:68:5\n+   |\n+LL | /     for el in arr {\n+LL | |         if f(el) == 20 {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().find(|&el| f(el) == 20)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:78:5\n+   |\n+LL | /     for &el in arr.values() {\n+LL | |         if f(el) {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.values().find(|&&el| f(el)).copied()`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:87:5\n+   |\n+LL | /     for el in arr {\n+LL | |         if el.is_true {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().find(|el| el.is_true)`\n+   |\n+   = note: you may need to dereference some variables\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:117:5\n+   |\n+LL | /     for (_, &x) in v {\n+LL | |         if x > 10 {\n+LL | |             return Some(x);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `v.into_iter().map(|(_, &x)| x).find(|&x| x > 10)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:126:5\n+   |\n+LL | /     for &(_, &x) in v {\n+LL | |         if x > 10 {\n+LL | |             return Some(x);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `v.iter().map(|&(_, &x)| x).find(|&x| x > 10)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:135:5\n+   |\n+LL | /     for x in arr {\n+LL | |         if x >= 5 {\n+LL | |             return Some(x);\n+LL | |         }\n+LL | |     }\n+LL | |     return None;\n+   | |________________^ help: replace with an iterator: `arr.into_iter().find(|&x| x >= 5)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:190:9\n+   |\n+LL | /         for x in arr {\n+LL | |             if x < 1 {\n+LL | |                 return Some(x);\n+LL | |             }\n+LL | |         }\n+LL | |         None\n+   | |____________^ help: replace with an iterator: `arr.into_iter().find(|&x| x < 1)`\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "e9ff64431e19d154f614b9128a63028bb52c1ae3", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -6,7 +6,8 @@\n     unreachable_code,\n     unused_mut,\n     dead_code,\n-    clippy::equatable_if_let\n+    clippy::equatable_if_let,\n+    clippy::manual_find\n )]\n \n fn base() {"}, {"sha": "03da39526b2fdd735098337004d9becf9c35b8bc", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -6,7 +6,8 @@\n     unreachable_code,\n     unused_mut,\n     dead_code,\n-    clippy::equatable_if_let\n+    clippy::equatable_if_let,\n+    clippy::manual_find\n )]\n \n fn base() {"}, {"sha": "42859243855a6920d7ce5fdae686ae969dbbd0cf", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/430575b61a95fc559f5021e246c04c3468acd1d6/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=430575b61a95fc559f5021e246c04c3468acd1d6", "patch": "@@ -1,141 +1,141 @@\n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:14:5\n+  --> $DIR/while_let_on_iterator.rs:15:5\n    |\n LL |     while let Option::Some(x) = iter.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in iter`\n    |\n    = note: `-D clippy::while-let-on-iterator` implied by `-D warnings`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:19:5\n+  --> $DIR/while_let_on_iterator.rs:20:5\n    |\n LL |     while let Some(x) = iter.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:24:5\n+  --> $DIR/while_let_on_iterator.rs:25:5\n    |\n LL |     while let Some(_) = iter.next() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:100:9\n+  --> $DIR/while_let_on_iterator.rs:101:9\n    |\n LL |         while let Some([..]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [..] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:107:9\n+  --> $DIR/while_let_on_iterator.rs:108:9\n    |\n LL |         while let Some([_x]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [_x] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:120:9\n+  --> $DIR/while_let_on_iterator.rs:121:9\n    |\n LL |         while let Some(x @ [_]) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x @ [_] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:140:9\n+  --> $DIR/while_let_on_iterator.rs:141:9\n    |\n LL |         while let Some(_) = y.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in y`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:197:9\n+  --> $DIR/while_let_on_iterator.rs:198:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:208:5\n+  --> $DIR/while_let_on_iterator.rs:209:5\n    |\n LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:210:9\n+  --> $DIR/while_let_on_iterator.rs:211:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:219:9\n+  --> $DIR/while_let_on_iterator.rs:220:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:228:9\n+  --> $DIR/while_let_on_iterator.rs:229:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:245:9\n+  --> $DIR/while_let_on_iterator.rs:246:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:260:13\n+  --> $DIR/while_let_on_iterator.rs:261:13\n    |\n LL |             while let Some(i) = self.0.next() {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in self.0.by_ref()`\n \n error: manual `!RangeInclusive::contains` implementation\n-  --> $DIR/while_let_on_iterator.rs:261:20\n+  --> $DIR/while_let_on_iterator.rs:262:20\n    |\n LL |                 if i < 3 || i > 7 {\n    |                    ^^^^^^^^^^^^^^ help: use: `!(3..=7).contains(&i)`\n    |\n    = note: `-D clippy::manual-range-contains` implied by `-D warnings`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:292:13\n+  --> $DIR/while_let_on_iterator.rs:293:13\n    |\n LL |             while let Some(i) = self.0.0.0.next() {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in self.0.0.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:321:5\n+  --> $DIR/while_let_on_iterator.rs:322:5\n    |\n LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:333:9\n+  --> $DIR/while_let_on_iterator.rs:334:9\n    |\n LL |         while let Some(x) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:347:5\n+  --> $DIR/while_let_on_iterator.rs:348:5\n    |\n LL |     while let Some(x) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:358:5\n+  --> $DIR/while_let_on_iterator.rs:359:5\n    |\n LL |     while let Some(x) = it.0.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:393:5\n+  --> $DIR/while_let_on_iterator.rs:394:5\n    |\n LL |     while let Some(x) = s.x.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in s.x.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:400:5\n+  --> $DIR/while_let_on_iterator.rs:401:5\n    |\n LL |     while let Some(x) = x[0].next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in x[0].by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:407:5\n+  --> $DIR/while_let_on_iterator.rs:408:5\n    |\n LL |     while let Some(..) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`"}]}