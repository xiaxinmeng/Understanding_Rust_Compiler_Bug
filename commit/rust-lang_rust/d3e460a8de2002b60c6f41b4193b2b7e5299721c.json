{"sha": "d3e460a8de2002b60c6f41b4193b2b7e5299721c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZTQ2MGE4ZGUyMDAyYjYwYzZmNDFiNDE5M2IyYjdlNTI5OTcyMWM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-07T16:05:45Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-07T16:05:45Z"}, "message": "Merge pull request #744 from mcarton/rustup\n\n[WIP] Rustup to rustc 1.9.0-nightly (998a6720b 2016-03-07)", "tree": {"sha": "748ed803d61bc0372b076e93244c5b6245549936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748ed803d61bc0372b076e93244c5b6245549936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3e460a8de2002b60c6f41b4193b2b7e5299721c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e460a8de2002b60c6f41b4193b2b7e5299721c", "html_url": "https://github.com/rust-lang/rust/commit/d3e460a8de2002b60c6f41b4193b2b7e5299721c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3e460a8de2002b60c6f41b4193b2b7e5299721c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2abb775de5bed06722ef0d9d14488d6e8777842f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2abb775de5bed06722ef0d9d14488d6e8777842f", "html_url": "https://github.com/rust-lang/rust/commit/2abb775de5bed06722ef0d9d14488d6e8777842f"}, {"sha": "4683cb1af364374ad9e33a0bc2d7eda91f44a385", "url": "https://api.github.com/repos/rust-lang/rust/commits/4683cb1af364374ad9e33a0bc2d7eda91f44a385", "html_url": "https://github.com/rust-lang/rust/commit/4683cb1af364374ad9e33a0bc2d7eda91f44a385"}], "stats": {"total": 209, "additions": 158, "deletions": 51}, "files": [{"sha": "97dcb20390bb737062235578a885720c43ac62b7", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.46\"\n+version = \"0.0.47\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\","}, {"sha": "e41402ef85a797082ecda712a1daef1c36f37576", "filename": "src/loops.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -10,10 +10,13 @@ use rustc_front::hir::*;\n use rustc_front::intravisit::{Visitor, walk_expr, walk_block, walk_decl};\n use std::borrow::Cow;\n use std::collections::HashMap;\n+use syntax::ast;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro,\n-            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, walk_ptrs_ty};\n+            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then,\n+            unsugar_range, walk_ptrs_ty};\n use utils::{BTREEMAP_PATH, HASHMAP_PATH, LL_PATH, OPTION_PATH, RESULT_PATH, VEC_PATH};\n+use utils::UnsugaredRange;\n \n /// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index.\n ///\n@@ -323,10 +326,9 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n /// Check for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n-    if let ExprRange(Some(ref l), ref r) = arg.node {\n+    if let Some(UnsugaredRange { start: Some(ref start), ref end, .. }) = unsugar_range(&arg) {\n         // the var must be a single name\n         if let PatKind::Ident(_, ref ident, _) = pat.node {\n-\n             let mut visitor = VarVisitor {\n                 cx: cx,\n                 var: ident.node.name,\n@@ -348,19 +350,19 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                     return;\n                 }\n \n-                let starts_at_zero = is_integer_literal(l, 0);\n+                let starts_at_zero = is_integer_literal(start, 0);\n \n                 let skip: Cow<_> = if starts_at_zero {\n                     \"\".into()\n                 } else {\n-                    format!(\".skip({})\", snippet(cx, l.span, \"..\")).into()\n+                    format!(\".skip({})\", snippet(cx, start.span, \"..\")).into()\n                 };\n \n-                let take: Cow<_> = if let Some(ref r) = *r {\n-                    if is_len_call(&r, &indexed) {\n+                let take: Cow<_> = if let Some(ref end) = *end {\n+                    if is_len_call(&end, &indexed) {\n                         \"\".into()\n                     } else {\n-                        format!(\".take({})\", snippet(cx, r.span, \"..\")).into()\n+                        format!(\".take({})\", snippet(cx, end.span, \"..\")).into()\n                     }\n                 } else {\n                     \"\".into()\n@@ -416,27 +418,27 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n \n fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n-    if let ExprRange(Some(ref start_expr), Some(ref stop_expr)) = arg.node {\n+    if let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), limits }) = unsugar_range(&arg) {\n         // ...and both sides are compile-time constant integers...\n-        if let Ok(start_idx) = eval_const_expr_partial(&cx.tcx, start_expr, ExprTypeChecked, None) {\n-            if let Ok(stop_idx) = eval_const_expr_partial(&cx.tcx, stop_expr, ExprTypeChecked, None) {\n-                // ...and the start index is greater than the stop index,\n+        if let Ok(start_idx) = eval_const_expr_partial(&cx.tcx, start, ExprTypeChecked, None) {\n+            if let Ok(end_idx) = eval_const_expr_partial(&cx.tcx, end, ExprTypeChecked, None) {\n+                // ...and the start index is greater than the end index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n-                let (sup, eq) = match (start_idx, stop_idx) {\n-                    (ConstVal::Int(start_idx), ConstVal::Int(stop_idx)) => {\n-                        (start_idx > stop_idx, start_idx == stop_idx)\n+                let (sup, eq) = match (start_idx, end_idx) {\n+                    (ConstVal::Int(start_idx), ConstVal::Int(end_idx)) => {\n+                        (start_idx > end_idx, start_idx == end_idx)\n                     }\n-                    (ConstVal::Uint(start_idx), ConstVal::Uint(stop_idx)) => {\n-                        (start_idx > stop_idx, start_idx == stop_idx)\n+                    (ConstVal::Uint(start_idx), ConstVal::Uint(end_idx)) => {\n+                        (start_idx > end_idx, start_idx == end_idx)\n                     }\n                     _ => (false, false),\n                 };\n \n                 if sup {\n-                    let start_snippet = snippet(cx, start_expr.span, \"_\");\n-                    let stop_snippet = snippet(cx, stop_expr.span, \"_\");\n+                    let start_snippet = snippet(cx, start.span, \"_\");\n+                    let end_snippet = snippet(cx, end.span, \"_\");\n \n                     span_lint_and_then(cx,\n                                        REVERSE_RANGE_LOOP,\n@@ -447,9 +449,9 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                                                               \"consider using the following if \\\n                                                                you are attempting to iterate \\\n                                                                over this range in reverse\",\n-                                                              format!(\"({}..{}).rev()` \", stop_snippet, start_snippet));\n+                                                              format!(\"({}..{}).rev()` \", end_snippet, start_snippet));\n                                        });\n-                } else if eq {\n+                } else if eq && limits != ast::RangeLimits::Closed {\n                     // if they are equal, it's also problematic - this loop\n                     // will never run.\n                     span_lint(cx,"}, {"sha": "59f7be94c2371219ac27ebc6dd9cb43f0c8a482e", "filename": "src/no_effect.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fno_effect.rs?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -23,15 +23,11 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n     match expr.node {\n         Expr_::ExprLit(..) |\n         Expr_::ExprClosure(..) |\n-        Expr_::ExprRange(None, None) |\n         Expr_::ExprPath(..) => true,\n         Expr_::ExprIndex(ref a, ref b) |\n-        Expr_::ExprRange(Some(ref a), Some(ref b)) |\n         Expr_::ExprBinary(_, ref a, ref b) => has_no_effect(cx, a) && has_no_effect(cx, b),\n         Expr_::ExprVec(ref v) |\n         Expr_::ExprTup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n-        Expr_::ExprRange(Some(ref inner), None) |\n-        Expr_::ExprRange(None, Some(ref inner)) |\n         Expr_::ExprRepeat(ref inner, _) |\n         Expr_::ExprCast(ref inner, _) |\n         Expr_::ExprType(ref inner, _) |\n@@ -55,6 +51,13 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n                 _ => false,\n             }\n         }\n+        Expr_::ExprBlock(ref block) => {\n+            block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n+                has_no_effect(cx, expr)\n+            } else {\n+                false\n+            }\n+        }\n         _ => false,\n     }\n }"}, {"sha": "766d98b4e0b9fd331d07148855ce321e928f4229", "filename": "src/ranges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{is_integer_literal, match_type, snippet};\n+use utils::{is_integer_literal, match_type, snippet, unsugar_range, UnsugaredRange};\n \n /// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n ///\n@@ -47,17 +47,17 @@ impl LateLintPass for StepByZero {\n                               instead\")\n             } else if name.as_str() == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n-                let zip_arg = &args[1].node;\n+                let zip_arg = &args[1];\n                 if_let_chain! {\n                     [\n                         // .iter() call\n                         let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n                         iter_name.as_str() == \"iter\",\n                         // range expression in .zip() call: 0..x.len()\n-                        let ExprRange(Some(ref from), Some(ref to)) = *zip_arg,\n-                        is_integer_literal(from, 0),\n+                        let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(zip_arg),\n+                        is_integer_literal(start, 0),\n                         // .len() call\n-                        let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = to.node,\n+                        let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n                         len_name.as_str() == \"len\" && len_args.len() == 1,\n                         // .iter() and .len() called on same Path\n                         let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,"}, {"sha": "0bd054a839a7192ba9ed4cb04cbd97103e0cf917", "filename": "src/utils/hir.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -109,14 +109,16 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 !self.ignore_fn && lname.node == rname.node && ltys.is_empty() && rtys.is_empty() &&\n                 self.eq_exprs(largs, rargs)\n             }\n-            (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n-                both(lb, rb, |l, r| self.eq_expr(l, r)) && both(le, re, |l, r| self.eq_expr(l, r))\n-            }\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n                 both(lqself, rqself, |l, r| self.eq_qself(l, r)) && self.eq_path(lsubpath, rsubpath)\n             }\n+            (&ExprStruct(ref lpath, ref lf, ref lo), &ExprStruct(ref rpath, ref rf, ref ro)) => {\n+                self.eq_path(lpath, rpath) &&\n+                    both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n+                    over(lf, rf, |l, r| self.eq_field(l, r))\n+            }\n             (&ExprTup(ref ltup), &ExprTup(ref rtup)) => self.eq_exprs(ltup, rtup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),\n             (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => lop == rop && self.eq_expr(le, re),\n@@ -132,6 +134,10 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         over(left, right, |l, r| self.eq_expr(l, r))\n     }\n \n+    fn eq_field(&self, left: &Field, right: &Field) -> bool {\n+        left.name.node == right.name.node && self.eq_expr(&left.expr, &right.expr)\n+    }\n+\n     /// Check whether two patterns are the same.\n     pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n@@ -375,16 +381,6 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(&name.node);\n                 self.hash_exprs(args);\n             }\n-            ExprRange(ref b, ref e) => {\n-                let c: fn(_, _) -> _ = ExprRange;\n-                c.hash(&mut self.s);\n-                if let Some(ref b) = *b {\n-                    self.hash_expr(b);\n-                }\n-                if let Some(ref e) = *e {\n-                    self.hash_expr(e);\n-                }\n-            }\n             ExprRepeat(ref e, ref l) => {\n                 let c: fn(_, _) -> _ = ExprRepeat;\n                 c.hash(&mut self.s);"}, {"sha": "b001d9530eddf0034995cbd9a129f4623fdcc9e4", "filename": "src/utils/mod.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -9,7 +9,7 @@ use std::borrow::Cow;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::str::FromStr;\n-use syntax::ast::{self, LitKind};\n+use syntax::ast::{self, LitKind, RangeLimits};\n use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n@@ -40,6 +40,12 @@ pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedLis\n pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RANGE_FROM_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FULL_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n+pub const RANGE_INCLUSIVE_NON_EMPTY_PATH: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n+pub const RANGE_PATH: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n+pub const RANGE_TO_INCLUSIVE_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const REGEX_NEW_PATH: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n@@ -673,3 +679,55 @@ pub fn camel_case_from(s: &str) -> usize {\n     }\n     last_i\n }\n+\n+/// Represents a range akin to `ast::ExprKind::Range`.\n+pub struct UnsugaredRange<'a> {\n+    pub start: Option<&'a Expr>,\n+    pub end: Option<&'a Expr>,\n+    pub limits: RangeLimits,\n+}\n+\n+/// Unsugar a `hir` range.\n+pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n+    // To be removed when ranges get stable.\n+    fn unwrap_unstable(expr: &Expr) -> &Expr {\n+        if let ExprBlock(ref block) = expr.node {\n+            if block.rules == BlockCheckMode::PushUnstableBlock || block.rules == BlockCheckMode::PopUnstableBlock {\n+                if let Some(ref expr) = block.expr {\n+                    return expr;\n+                }\n+            }\n+        }\n+\n+        expr\n+    }\n+\n+    fn get_field<'a>(name: &str, fields: &'a [Field]) -> Option<&'a Expr> {\n+        let expr = &fields.iter()\n+                          .find(|field| field.name.node.as_str() == name)\n+                          .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n+                          .expr;\n+\n+        Some(unwrap_unstable(expr))\n+    }\n+\n+    if let ExprStruct(ref path, ref fields, None) = unwrap_unstable(&expr).node {\n+        if match_path(path, &RANGE_FROM_PATH) {\n+            Some(UnsugaredRange { start: get_field(\"start\", fields), end: None, limits: RangeLimits::HalfOpen })\n+        } else if match_path(path, &RANGE_FULL_PATH) {\n+            Some(UnsugaredRange { start: None, end: None, limits: RangeLimits::HalfOpen })\n+        } else if match_path(path, &RANGE_INCLUSIVE_NON_EMPTY_PATH) {\n+            Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n+        } else if match_path(path, &RANGE_PATH) {\n+            Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+        } else if match_path(path, &RANGE_TO_INCLUSIVE_PATH) {\n+            Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n+        } else if match_path(path, &RANGE_TO_PATH) {\n+            Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "c1e1ba68b3e71d2659ff670ed8da045f91dd666d", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -1,4 +1,4 @@\n-#![feature(plugin)]\n+#![feature(plugin, inclusive_range_syntax)]\n #![plugin(clippy)]\n \n #![allow(dead_code, no_effect)]\n@@ -10,16 +10,46 @@\n fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }\n \n+struct Foo {\n+    bar: u8,\n+}\n+\n #[deny(if_same_then_else)]\n #[deny(match_same_arms)]\n fn if_same_then_else() -> Result<&'static str, ()> {\n     if true {\n+        Foo { bar: 42 };\n+        0..10;\n+        ..;\n+        0..;\n+        ..10;\n+        0...10;\n         foo();\n     }\n     else { //~ERROR this `if` has identical blocks\n+        Foo { bar: 42 };\n+        0..10;\n+        ..;\n+        0..;\n+        ..10;\n+        0...10;\n         foo();\n     }\n \n+    if true {\n+        Foo { bar: 42 };\n+    }\n+    else {\n+        Foo { bar: 43 };\n+    }\n+\n+    if true {\n+        0..10;\n+    }\n+    else {\n+        0...10;\n+    }\n+\n     if true {\n         foo();\n         foo();"}, {"sha": "0853ae83cd7d7202ce18427230309bb3f2bf5742", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -1,4 +1,4 @@\n-#![feature(plugin, step_by)]\n+#![feature(plugin, step_by, inclusive_range_syntax)]\n #![plugin(clippy)]\n \n use std::collections::*;\n@@ -118,11 +118,21 @@ fn main() {\n         println!(\"{}\", vec[i]);\n     }\n \n+    for i in 0...MAX_LEN {\n+        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(MAX_LEN)`\n+        println!(\"{}\", vec[i]);\n+    }\n+\n     for i in 5..10 {\n         //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(10).skip(5)`\n         println!(\"{}\", vec[i]);\n     }\n \n+    for i in 5...10 {\n+        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(10).skip(5)`\n+        println!(\"{}\", vec[i]);\n+    }\n+\n     for i in 5..vec.len() {\n         //~^ ERROR `i` is used to index `vec`. Consider using `for (i, item) in vec.iter().enumerate().skip(5)`\n         println!(\"{} {}\", vec[i], i);\n@@ -140,6 +150,13 @@ fn main() {\n         println!(\"{}\", i);\n     }\n \n+    for i in 10...0 {\n+        //~^ERROR this range is empty so this for loop will never run\n+        //~|HELP consider\n+        //~|SUGGESTION (0..10).rev()\n+        println!(\"{}\", i);\n+    }\n+\n     for i in MAX_LEN..0 { //~ERROR this range is empty so this for loop will never run\n         //~|HELP consider\n         //~|SUGGESTION (0..MAX_LEN).rev()\n@@ -150,15 +167,15 @@ fn main() {\n         println!(\"{}\", i);\n     }\n \n-    for i in 0..10 { // not an error, the start index is less than the end index\n+    for i in 5...5 { // not an error, this is the range with only one element \u201c5\u201d\n         println!(\"{}\", i);\n     }\n \n-    for i in -10..0 { // not an error\n+    for i in 0..10 { // not an error, the start index is less than the end index\n         println!(\"{}\", i);\n     }\n \n-    for i in (10..0).rev() { // not an error, this is an established idiom for looping backwards on a range\n+    for i in -10..0 { // not an error\n         println!(\"{}\", i);\n     }\n "}, {"sha": "344c82f3307568fe2c20572bf37d9551438a134e", "filename": "tests/compile-fail/no_effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3e460a8de2002b60c6f41b4193b2b7e5299721c/tests%2Fcompile-fail%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e460a8de2002b60c6f41b4193b2b7e5299721c/tests%2Fcompile-fail%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fno_effect.rs?ref=d3e460a8de2002b60c6f41b4193b2b7e5299721c", "patch": "@@ -1,4 +1,4 @@\n-#![feature(plugin, box_syntax)]\n+#![feature(plugin, box_syntax, inclusive_range_syntax)]\n #![plugin(clippy)]\n \n #![deny(no_effect)]\n@@ -39,6 +39,7 @@ fn main() {\n     5..; //~ERROR statement with no effect\n     ..5; //~ERROR statement with no effect\n     5..6; //~ERROR statement with no effect\n+    5...6; //~ERROR statement with no effect\n     [42, 55]; //~ERROR statement with no effect\n     [42, 55][1]; //~ERROR statement with no effect\n     (42, 55).1; //~ERROR statement with no effect"}]}