{"sha": "7f1e166899a90226480d564549c36a395e2d8f47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMWUxNjY4OTlhOTAyMjY0ODBkNTY0NTQ5YzM2YTM5NWUyZDhmNDc=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T07:50:32Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T10:09:54Z"}, "message": "Simplify loop conditions in RUNNING and add comments", "tree": {"sha": "0960c76be784795c60707b359b5ce2aa4d6c5e4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0960c76be784795c60707b359b5ce2aa4d6c5e4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f1e166899a90226480d564549c36a395e2d8f47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f1e166899a90226480d564549c36a395e2d8f47", "html_url": "https://github.com/rust-lang/rust/commit/7f1e166899a90226480d564549c36a395e2d8f47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f1e166899a90226480d564549c36a395e2d8f47/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ab812c18176dece9058d2dc0639a0eeb5f42c7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ab812c18176dece9058d2dc0639a0eeb5f42c7d", "html_url": "https://github.com/rust-lang/rust/commit/2ab812c18176dece9058d2dc0639a0eeb5f42c7d"}], "stats": {"total": 46, "additions": 29, "deletions": 17}, "files": [{"sha": "7a660daf2cbae339689f9a126a5160a4960a6406", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7f1e166899a90226480d564549c36a395e2d8f47/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f1e166899a90226480d564549c36a395e2d8f47/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=7f1e166899a90226480d564549c36a395e2d8f47", "patch": "@@ -354,7 +354,7 @@ impl Once {\n         // SeqCst minimizes the chances of something going wrong.\n         let mut state_and_queue = self.state_and_queue.load(Ordering::SeqCst);\n \n-        'outer: loop {\n+        loop {\n             match state_and_queue {\n                 // If we're complete, then there's nothing to do, we just\n                 // jettison out as we shouldn't run the closure.\n@@ -401,33 +401,45 @@ impl Once {\n                 // not RUNNING.\n                 _ => {\n                     assert!(state_and_queue & STATE_MASK == RUNNING);\n+                    // Create the node for our current thread that we are going to try to slot\n+                    // in at the head of the linked list.\n                     let mut node = Waiter {\n                         thread: Some(thread::current()),\n                         signaled: AtomicBool::new(false),\n                         next: ptr::null_mut(),\n                     };\n                     let me = &mut node as *mut Waiter as usize;\n-                    assert!(me & STATE_MASK == 0);\n+                    assert!(me & STATE_MASK == 0); // We assume pointers have 2 free bits that\n+                                                   // we can use for state.\n+\n+                    // Try to slide in the node at the head of the linked list.\n+                    // Run in a loop where we make sure the status is still RUNNING, and that\n+                    // another thread did not just replace the head of the linked list.\n+                    let mut old_head_and_status = state_and_queue;\n+                    loop {\n+                        if old_head_and_status & STATE_MASK != RUNNING {\n+                            return; // No need anymore to enqueue ourselves.\n+                        }\n \n-                    while state_and_queue & STATE_MASK == RUNNING {\n-                        node.next = (state_and_queue & !STATE_MASK) as *mut Waiter;\n-                        let old = self.state_and_queue.compare_and_swap(state_and_queue,\n+                        node.next = (old_head_and_status & !STATE_MASK) as *mut Waiter;\n+                        let old = self.state_and_queue.compare_and_swap(old_head_and_status,\n                                                                         me | RUNNING,\n-                                                                        Ordering::SeqCst);\n-                        if old != state_and_queue {\n-                            state_and_queue = old;\n-                            continue\n+                                                                        Ordering::Release);\n+                        if old == old_head_and_status {\n+                            break; // Success!\n                         }\n+                        old_head_and_status = old;\n+                    }\n \n-                        // Once we've enqueued ourselves, wait in a loop.\n-                        // Afterwards reload the state and continue with what we\n-                        // were doing from before.\n-                        while !node.signaled.load(Ordering::SeqCst) {\n-                            thread::park();\n-                        }\n-                        state_and_queue = self.state_and_queue.load(Ordering::SeqCst);\n-                        continue 'outer\n+                    // We have enqueued ourselves, now lets wait.\n+                    // It is important not to return before being signaled, otherwise we would\n+                    // drop our `Waiter` node and leave a hole in the linked list (and a\n+                    // dangling reference). Guard against spurious wakeups by reparking\n+                    // ourselves until we are signaled.\n+                    while !node.signaled.load(Ordering::SeqCst) {\n+                        thread::park();\n                     }\n+                    state_and_queue = self.state_and_queue.load(Ordering::SeqCst);\n                 }\n             }\n         }"}]}