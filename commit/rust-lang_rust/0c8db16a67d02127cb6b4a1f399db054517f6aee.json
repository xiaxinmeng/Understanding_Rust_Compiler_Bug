{"sha": "0c8db16a67d02127cb6b4a1f399db054517f6aee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOGRiMTZhNjdkMDIxMjdjYjZiNGExZjM5OWRiMDU0NTE3ZjZhZWU=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2020-11-13T17:24:26Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-01-22T16:41:56Z"}, "message": "Add `core::stream::Stream`\n\nThis patch adds the `core::stream` submodule and implements `core::stream::Stream` in accordance with RFC2996.\n\nAdd feedback from @camelid", "tree": {"sha": "3bb4424dddad5e7715b1f7187b6691c475967618", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bb4424dddad5e7715b1f7187b6691c475967618"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c8db16a67d02127cb6b4a1f399db054517f6aee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c8db16a67d02127cb6b4a1f399db054517f6aee", "html_url": "https://github.com/rust-lang/rust/commit/0c8db16a67d02127cb6b4a1f399db054517f6aee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c8db16a67d02127cb6b4a1f399db054517f6aee/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc01bb624a960533e049fdb98d0489ff2a8de06", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc01bb624a960533e049fdb98d0489ff2a8de06", "html_url": "https://github.com/rust-lang/rust/commit/bbc01bb624a960533e049fdb98d0489ff2a8de06"}], "stats": {"total": 347, "additions": 347, "deletions": 0}, "files": [{"sha": "e586ff8990215bcb160216826022682667a04f84", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=0c8db16a67d02127cb6b4a1f399db054517f6aee", "patch": "@@ -149,6 +149,7 @@ use core::ops::{\n };\n use core::pin::Pin;\n use core::ptr::{self, Unique};\n+use core::stream::Stream;\n use core::task::{Context, Poll};\n \n use crate::alloc::{handle_alloc_error, AllocError, Allocator, Global, Layout, WriteCloneIntoRaw};\n@@ -1618,3 +1619,16 @@ where\n         F::poll(Pin::new(&mut *self), cx)\n     }\n }\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: ?Sized + Stream + Unpin> Stream for Box<S> {\n+    type Item = S::Item;\n+\n+    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        Pin::new(&mut **self).poll_next(cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n+}"}, {"sha": "e524eb05fcdd753f0c16257cad4bed9ae948048a", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=0c8db16a67d02127cb6b4a1f399db054517f6aee", "patch": "@@ -82,6 +82,7 @@\n #![feature(array_windows)]\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n+#![feature(async_stream)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_sanitize)]"}, {"sha": "a4395ab57e8a1edf5787186e900585d3862be171", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=0c8db16a67d02127cb6b4a1f399db054517f6aee", "patch": "@@ -254,6 +254,8 @@ pub mod panicking;\n pub mod pin;\n pub mod raw;\n pub mod result;\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+pub mod stream;\n pub mod sync;\n \n pub mod fmt;"}, {"sha": "48cca4972929af21e8d5ef2bfe751b73fb5df1ef", "filename": "library/core/src/stream/mod.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fcore%2Fsrc%2Fstream%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fcore%2Fsrc%2Fstream%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstream%2Fmod.rs?ref=0c8db16a67d02127cb6b4a1f399db054517f6aee", "patch": "@@ -0,0 +1,154 @@\n+//! Composable asynchronous iteration.\n+//!\n+//! If futures are asynchronous values, then streams are asynchronous\n+//! iterators. If you've found yourself with an asynchronous collection of some kind,\n+//! and needed to perform an operation on the elements of said collection,\n+//! you'll quickly run into 'streams'. Streams are heavily used in idiomatic\n+//! asynchronous Rust code, so it's worth becoming familiar with them.\n+//!\n+//! Before explaining more, let's talk about how this module is structured:\n+//!\n+//! # Organization\n+//!\n+//! This module is largely organized by type:\n+//!\n+//! * [Traits] are the core portion: these traits define what kind of streams\n+//!   exist and what you can do with them. The methods of these traits are worth\n+//!   putting some extra study time into.\n+//! * Functions provide some helpful ways to create some basic streams.\n+//! * [Structs] are often the return types of the various methods on this\n+//!   module's traits. You'll usually want to look at the method that creates\n+//!   the `struct`, rather than the `struct` itself. For more detail about why,\n+//!   see '[Implementing Stream](#implementing-stream)'.\n+//!\n+//! [Traits]: #traits\n+//! [Structs]: #structs\n+//!\n+//! That's it! Let's dig into streams.\n+//!\n+//! # Stream\n+//!\n+//! The heart and soul of this module is the [`Stream`] trait. The core of\n+//! [`Stream`] looks like this:\n+//!\n+//! ```\n+//! # use core::task::{Context, Poll};\n+//! # use core::pin::Pin;\n+//! trait Stream {\n+//!     type Item;\n+//!     fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n+//! }\n+//! ```\n+//!\n+//! Unlike `Iterator`, `Stream` makes a distinction between the [`poll_next`]\n+//! method which is used when implementing a `Stream`, and the [`next`] method\n+//! which is used when consuming a stream. Consumers of `Stream` only need to\n+//! consider [`next`], which when called, returns a future which yields\n+//! yields [`Option`][`<Item>`].\n+//!\n+//! The future returned by [`next`] will yield `Some(Item)` as long as there are\n+//! elements, and once they've all been exhausted, will yield `None` to indicate\n+//! that iteration is finished. If we're waiting on something asynchronous to\n+//! resolve, the future will wait until the stream is ready to yield again.\n+//!\n+//! Individual streams may choose to resume iteration, and so calling [`next`]\n+//! again may or may not eventually yield `Some(Item)` again at some point.\n+//!\n+//! [`Stream`]'s full definition includes a number of other methods as well,\n+//! but they are default methods, built on top of [`poll_next`], and so you get\n+//! them for free.\n+//!\n+//! [`Poll`]: super::task::Poll\n+//! [`poll_next`]: Stream::poll_next\n+//! [`next`]: Stream::next\n+//! [`<Item>`]: Stream::Item\n+//!\n+//! # Implementing Stream\n+//!\n+//! Creating a stream of your own involves two steps: creating a `struct` to\n+//! hold the stream's state, and then implementing [`Stream`] for that\n+//! `struct`.\n+//!\n+//! Let's make a stream named `Counter` which counts from `1` to `5`:\n+//!\n+//! ```no_run\n+//! #![feature(async_stream)]\n+//! # use core::stream::Stream;\n+//! # use core::task::{Context, Poll};\n+//! # use core::pin::Pin;\n+//!\n+//! // First, the struct:\n+//!\n+//! /// A stream which counts from one to five\n+//! struct Counter {\n+//!     count: usize,\n+//! }\n+//!\n+//! // we want our count to start at one, so let's add a new() method to help.\n+//! // This isn't strictly necessary, but is convenient. Note that we start\n+//! // `count` at zero, we'll see why in `poll_next()`'s implementation below.\n+//! impl Counter {\n+//!     fn new() -> Counter {\n+//!         Counter { count: 0 }\n+//!     }\n+//! }\n+//!\n+//! // Then, we implement `Stream` for our `Counter`:\n+//!\n+//! impl Stream for Counter {\n+//!     // we will be counting with usize\n+//!     type Item = usize;\n+//!\n+//!     // poll_next() is the only required method\n+//!     fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+//!         // Increment our count. This is why we started at zero.\n+//!         self.count += 1;\n+//!\n+//!         // Check to see if we've finished counting or not.\n+//!         if self.count < 6 {\n+//!             Poll::Ready(Some(self.count))\n+//!         } else {\n+//!             Poll::Ready(None)\n+//!         }\n+//!     }\n+//! }\n+//!\n+//! // And now we can use it!\n+//! # async fn run() {\n+//! #\n+//! let mut counter = Counter::new();\n+//!\n+//! let x = counter.next().await.unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().await.unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().await.unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().await.unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().await.unwrap();\n+//! println!(\"{}\", x);\n+//! #\n+//! }\n+//! ```\n+//!\n+//! This will print `1` through `5`, each on their own line.\n+//!\n+//! # Laziness\n+//!\n+//! Streams are *lazy*. This means that just creating a stream doesn't _do_ a\n+//! whole lot. Nothing really happens until you call [`next`]. This is sometimes a\n+//! source of confusion when creating a stream solely for its side effects. The\n+//! compiler will warn us about this kind of behavior:\n+//!\n+//! ```text\n+//! warning: unused result that must be used: streams do nothing unless polled\n+//! ```\n+\n+mod stream;\n+\n+pub use stream::{Next, Stream};"}, {"sha": "3f92c2e8c1c024ab8518774abcc1ae51ab63917d", "filename": "library/core/src/stream/stream/mod.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs?ref=0c8db16a67d02127cb6b4a1f399db054517f6aee", "patch": "@@ -0,0 +1,129 @@\n+mod next;\n+\n+pub use next::Next;\n+\n+use crate::ops::DerefMut;\n+use crate::pin::Pin;\n+use crate::task::{Context, Poll};\n+\n+/// An interface for dealing with asynchronous iterators.\n+///\n+/// This is the main stream trait. For more about the concept of streams\n+/// generally, please see the [module-level documentation]. In particular, you\n+/// may want to know how to [implement `Stream`][impl].\n+///\n+/// [module-level documentation]: index.html\n+/// [impl]: index.html#implementing-stream\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+#[must_use = \"streams do nothing unless polled\"]\n+pub trait Stream {\n+    /// The type of items yielded by the stream.\n+    type Item;\n+\n+    /// Attempt to pull out the next value of this stream, registering the\n+    /// current task for wakeup if the value is not yet available, and returning\n+    /// `None` if the stream is exhausted.\n+    ///\n+    /// # Return value\n+    ///\n+    /// There are several possible return values, each indicating a distinct\n+    /// stream state:\n+    ///\n+    /// - `Poll::Pending` means that this stream's next value is not ready\n+    /// yet. Implementations will ensure that the current task will be notified\n+    /// when the next value may be ready.\n+    ///\n+    /// - `Poll::Ready(Some(val))` means that the stream has successfully\n+    /// produced a value, `val`, and may produce further values on subsequent\n+    /// `poll_next` calls.\n+    ///\n+    /// - `Poll::Ready(None)` means that the stream has terminated, and\n+    /// `poll_next` should not be invoked again.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Once a stream has finished (returned `Ready(None)` from `poll_next`), calling its\n+    /// `poll_next` method again may panic, block forever, or cause other kinds of\n+    /// problems; the `Stream` trait places no requirements on the effects of\n+    /// such a call. However, as the `poll_next` method is not marked `unsafe`,\n+    /// Rust's usual rules apply: calls must never cause undefined behavior\n+    /// (memory corruption, incorrect use of `unsafe` functions, or the like),\n+    /// regardless of the stream's state.\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n+\n+    /// Returns the bounds on the remaining length of the stream.\n+    ///\n+    /// Specifically, `size_hint()` returns a tuple where the first element\n+    /// is the lower bound, and the second element is the upper bound.\n+    ///\n+    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n+    /// A [`None`] here means that either there is no known upper bound, or the\n+    /// upper bound is larger than [`usize`].\n+    ///\n+    /// # Implementation notes\n+    ///\n+    /// It is not enforced that a stream implementation yields the declared\n+    /// number of elements. A buggy stream may yield less than the lower bound\n+    /// or more than the upper bound of elements.\n+    ///\n+    /// `size_hint()` is primarily intended to be used for optimizations such as\n+    /// reserving space for the elements of the stream, but must not be\n+    /// trusted to e.g., omit bounds checks in unsafe code. An incorrect\n+    /// implementation of `size_hint()` should not lead to memory safety\n+    /// violations.\n+    ///\n+    /// That said, the implementation should provide a correct estimation,\n+    /// because otherwise it would be a violation of the trait's protocol.\n+    ///\n+    /// The default implementation returns `(0, `[`None`]`)` which is correct for any\n+    /// stream.\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, None)\n+    }\n+\n+    /// Advances the stream and returns a future which yields the next value.\n+    ///\n+    /// The returned future yields [`None`] when iteration is finished.\n+    /// Individual stream implementations may choose to resume iteration, and so\n+    /// calling `next()` again may or may not eventually start yielding\n+    /// [`Some(Item)`] again at some point.\n+    ///\n+    /// [`Some(Item)`]: Some\n+    fn next(&mut self) -> Next<'_, Self>\n+    where\n+        Self: Unpin,\n+    {\n+        Next::new(self)\n+    }\n+}\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: ?Sized + Stream + Unpin> Stream for &mut S {\n+    type Item = S::Item;\n+\n+    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        S::poll_next(Pin::new(&mut **self), cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<P> Stream for Pin<P>\n+where\n+    P: DerefMut + Unpin,\n+    P::Target: Stream,\n+{\n+    type Item = <P::Target as Stream>::Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        self.get_mut().as_mut().poll_next(cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n+}"}, {"sha": "e25d44228e781aee25410b8f3dd437fe485b26b5", "filename": "library/core/src/stream/stream/next.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fnext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fnext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fnext.rs?ref=0c8db16a67d02127cb6b4a1f399db054517f6aee", "patch": "@@ -0,0 +1,30 @@\n+use crate::future::Future;\n+use crate::pin::Pin;\n+use crate::stream::Stream;\n+use crate::task::{Context, Poll};\n+\n+/// A future which advances the stream and returns the next value.\n+///\n+/// This `struct` is created by [`Stream::next`]. See its documentation for more.\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+#[derive(Debug)]\n+#[must_use = \"futures do nothing unless you `.await` or poll them\"]\n+pub struct Next<'a, S: ?Sized> {\n+    stream: &'a mut S,\n+}\n+\n+impl<'a, S: ?Sized> Next<'a, S> {\n+    /// Create a new instance of `Next`.\n+    pub(crate) fn new(stream: &'a mut S) -> Self {\n+        Self { stream }\n+    }\n+}\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: Stream + Unpin + ?Sized> Future for Next<'_, S> {\n+    type Output = Option<S::Item>;\n+\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Pin::new(&mut *self.stream).poll_next(cx)\n+    }\n+}"}, {"sha": "f739fffd1c04c66461c94d6eba8dfe13251db6b8", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=0c8db16a67d02127cb6b4a1f399db054517f6aee", "patch": "@@ -224,6 +224,7 @@\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n+#![feature(async_stream)]\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n@@ -448,6 +449,8 @@ pub use core::ptr;\n pub use core::raw;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::result;\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+pub use core::stream;\n #[stable(feature = \"i128\", since = \"1.26.0\")]\n #[allow(deprecated, deprecated_in_future)]\n pub use core::u128;"}, {"sha": "66e363bf67b8b3a2e14fc19ede5b97a81cbabcaf", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8db16a67d02127cb6b4a1f399db054517f6aee/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=0c8db16a67d02127cb6b4a1f399db054517f6aee", "patch": "@@ -12,6 +12,7 @@ use crate::panicking;\n use crate::pin::Pin;\n use crate::ptr::{NonNull, Unique};\n use crate::rc::Rc;\n+use crate::stream::Stream;\n use crate::sync::atomic;\n use crate::sync::{Arc, Mutex, RwLock};\n use crate::task::{Context, Poll};\n@@ -340,6 +341,19 @@ impl<F: Future> Future for AssertUnwindSafe<F> {\n     }\n }\n \n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: Stream> Stream for AssertUnwindSafe<S> {\n+    type Item = S::Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<S::Item>> {\n+        unsafe { self.map_unchecked_mut(|x| &mut x.0) }.poll_next(cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n /// Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n ///\n /// This function will return `Ok` with the closure's result if the closure"}]}