{"sha": "079d9b10515f4d9016e32fa539f1792143e13b03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3OWQ5YjEwNTE1ZjRkOTAxNmUzMmZhNTM5ZjE3OTIxNDNlMTNiMDM=", "commit": {"author": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-03-17T15:57:31Z"}, "committer": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-03-17T15:57:31Z"}, "message": "Forward Iterator::{ne, lt, le, gt, ge} to Iterator::{eq, partial_cmp}", "tree": {"sha": "d19391ac464ccd7ee79468674f99106708fefc3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d19391ac464ccd7ee79468674f99106708fefc3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/079d9b10515f4d9016e32fa539f1792143e13b03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/079d9b10515f4d9016e32fa539f1792143e13b03", "html_url": "https://github.com/rust-lang/rust/commit/079d9b10515f4d9016e32fa539f1792143e13b03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/079d9b10515f4d9016e32fa539f1792143e13b03/comments", "author": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "070cebd0aa76702eaaf7c7f340615805f661e937", "url": "https://api.github.com/repos/rust-lang/rust/commits/070cebd0aa76702eaaf7c7f340615805f661e937", "html_url": "https://github.com/rust-lang/rust/commit/070cebd0aa76702eaaf7c7f340615805f661e937"}], "stats": {"total": 114, "additions": 18, "deletions": 96}, "files": [{"sha": "84db233c630faea1faf638780ad233b6aa2d1346", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 18, "deletions": 96, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/079d9b10515f4d9016e32fa539f1792143e13b03/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/079d9b10515f4d9016e32fa539f1792143e13b03/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=079d9b10515f4d9016e32fa539f1792143e13b03", "patch": "@@ -2435,145 +2435,67 @@ pub trait Iterator {\n     /// Determines if the elements of this `Iterator` are unequal to those of\n     /// another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn ne<I>(mut self, other: I) -> bool where\n+    fn ne<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialEq<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => return other.next().is_some(),\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return true,\n-                Some(val) => val,\n-            };\n-\n-            if x != y { return true }\n-        }\n+        !self.eq(other)\n     }\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less than those of another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn lt<I>(mut self, other: I) -> bool where\n+    fn lt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => return other.next().is_some(),\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return false,\n-                Some(val) => val,\n-            };\n-\n-            match x.partial_cmp(&y) {\n-                Some(Ordering::Less) => return true,\n-                Some(Ordering::Equal) => (),\n-                Some(Ordering::Greater) => return false,\n-                None => return false,\n-            }\n+        match self.partial_cmp(other) {\n+            Some(Ordering::Less) => true,\n+            _ => false,\n         }\n     }\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less or equal to those of another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn le<I>(mut self, other: I) -> bool where\n+    fn le<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => { other.next(); return true; },\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return false,\n-                Some(val) => val,\n-            };\n-\n-            match x.partial_cmp(&y) {\n-                Some(Ordering::Less) => return true,\n-                Some(Ordering::Equal) => (),\n-                Some(Ordering::Greater) => return false,\n-                None => return false,\n-            }\n+        match self.partial_cmp(other) {\n+            Some(Ordering::Less) | Some(Ordering::Equal) => true,\n+            _ => false,\n         }\n     }\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than those of another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn gt<I>(mut self, other: I) -> bool where\n+    fn gt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => { other.next(); return false; },\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return true,\n-                Some(val) => val,\n-            };\n-\n-            match x.partial_cmp(&y) {\n-                Some(Ordering::Less) => return false,\n-                Some(Ordering::Equal) => (),\n-                Some(Ordering::Greater) => return true,\n-                None => return false,\n-            }\n+        match self.partial_cmp(other) {\n+            Some(Ordering::Greater) => true,\n+            _ => false,\n         }\n     }\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than or equal to those of another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn ge<I>(mut self, other: I) -> bool where\n+    fn ge<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => return other.next().is_none(),\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return true,\n-                Some(val) => val,\n-            };\n-\n-            match x.partial_cmp(&y) {\n-                Some(Ordering::Less) => return false,\n-                Some(Ordering::Equal) => (),\n-                Some(Ordering::Greater) => return true,\n-                None => return false,\n-            }\n+        match self.partial_cmp(other) {\n+            Some(Ordering::Greater) | Some(Ordering::Equal) => true,\n+            _ => false,\n         }\n     }\n "}]}