{"sha": "add9031dd5c2814195df163b1d35a853876c64f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZDkwMzFkZDVjMjgxNDE5NWRmMTYzYjFkMzVhODUzODc2YzY0ZjY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-30T19:02:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-30T19:02:40Z"}, "message": "rustc: Use interior vectors for record types", "tree": {"sha": "fe4ea2bc4c0453c1d07f6c8e10e66047ed16390a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe4ea2bc4c0453c1d07f6c8e10e66047ed16390a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/add9031dd5c2814195df163b1d35a853876c64f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/add9031dd5c2814195df163b1d35a853876c64f6", "html_url": "https://github.com/rust-lang/rust/commit/add9031dd5c2814195df163b1d35a853876c64f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/add9031dd5c2814195df163b1d35a853876c64f6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e", "html_url": "https://github.com/rust-lang/rust/commit/fd0d1cb7d8e56d2fc8f2e8128e534bee0dde7d1e"}], "stats": {"total": 51, "additions": 24, "deletions": 27}, "files": [{"sha": "9a18cabd587ce1b1497c1669b21e07cb5f181c63", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=add9031dd5c2814195df163b1d35a853876c64f6", "patch": "@@ -198,14 +198,14 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('R') {\n             assert (next(st) as char == '[');\n-            let vec[ty::field] fields = [];\n+            let ty::field[] fields = ~[];\n             while (peek(st) as char != ']') {\n                 auto name = \"\";\n                 while (peek(st) as char != '=') {\n                     name += str::unsafe_from_byte(next(st));\n                 }\n                 st.pos = st.pos + 1u;\n-                fields += [rec(ident=name, mt=parse_mt(st, sd))];\n+                fields += ~[rec(ident=name, mt=parse_mt(st, sd))];\n             }\n             st.pos = st.pos + 1u;\n             ret ty::mk_rec(st.tcx, fields);"}, {"sha": "b7022b3d20ec269b92d39eeb315d9c69c7eeaf60", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=add9031dd5c2814195df163b1d35a853876c64f6", "patch": "@@ -5901,7 +5901,7 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n             base_val = base_res.val;\n         }\n     }\n-    let vec[ty::field] ty_fields = [];\n+    let ty::field[] ty_fields = ~[];\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_rec(?flds)) { ty_fields = flds; }\n     }"}, {"sha": "84f2dcbc67db4b722903d12c71fad86e54416fef", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=add9031dd5c2814195df163b1d35a853876c64f6", "patch": "@@ -265,7 +265,7 @@ tag sty {\n     ty_chan(t);\n     ty_task;\n     ty_tup(mt[]);\n-    ty_rec(vec[field]);\n+    ty_rec(field[]);\n     ty_fn(ast::proto, vec[arg], t, controlflow, vec[@constr_def]);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n@@ -595,7 +595,7 @@ fn mk_imm_tup(&ctxt cx, &t[] tys) -> t {\n     ret mk_tup(cx, mts);\n }\n \n-fn mk_rec(&ctxt cx, &vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n+fn mk_rec(&ctxt cx, &field[] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_fn(&ctxt cx, &ast::proto proto, &vec[arg] args, &t ty, &controlflow cf,\n          &vec[@constr_def] constrs) -> t {\n@@ -784,11 +784,11 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n             ty = copy_cname(cx, mk_tup(cx, new_mts), ty);\n         }\n         case (ty_rec(?fields)) {\n-            let vec[field] new_fields = [];\n+            let field[] new_fields = ~[];\n             for (field fl in fields) {\n                 auto new_ty = fold_ty(cx, fld, fl.mt.ty);\n                 auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n-                new_fields += [rec(ident=fl.ident, mt=new_mt)];\n+                new_fields += ~[rec(ident=fl.ident, mt=new_mt)];\n             }\n             ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n         }\n@@ -1124,7 +1124,7 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n         }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n-            while (i < vec::len[field](fields)) {\n+            while (i < ivec::len[field](fields)) {\n                 if (type_has_dynamic_size(cx, fields.(i).mt.ty)) { ret true; }\n                 i += 1u;\n             }\n@@ -1576,8 +1576,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_rec(?flds_a)) {\n             alt (b) {\n                 case (ty_rec(?flds_b)) {\n-                    auto len = vec::len[field](flds_a);\n-                    if (len != vec::len[field](flds_b)) { ret false; }\n+                    auto len = ivec::len[field](flds_a);\n+                    if (len != ivec::len[field](flds_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto fld_a = flds_a.(i);\n@@ -1917,7 +1917,7 @@ fn field_num(&session::session sess, &span sp, &ast::ident id) -> uint {\n }\n \n fn field_idx(&session::session sess, &span sp, &ast::ident id,\n-             &vec[field] fields) -> uint {\n+             &field[] fields) -> uint {\n     let uint i = 0u;\n     for (field f in fields) { if (str::eq(f.ident, id)) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n@@ -2531,8 +2531,8 @@ mod unify {\n             case (ty::ty_rec(?expected_fields)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_rec(?actual_fields)) {\n-                        auto expected_len = vec::len[field](expected_fields);\n-                        auto actual_len = vec::len[field](actual_fields);\n+                        auto expected_len = ivec::len[field](expected_fields);\n+                        auto actual_len = ivec::len[field](actual_fields);\n                         if (expected_len != actual_len) {\n                             auto err =\n                                 terr_record_size(expected_len, actual_len);\n@@ -2541,7 +2541,7 @@ mod unify {\n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n \n-                        let vec[field] result_fields = [];\n+                        let field[] result_fields = ~[];\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_field = expected_fields.(i);\n@@ -2567,10 +2567,8 @@ mod unify {\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     auto mt = rec(ty=rty, mut=mut);\n-                                    vec::push[field](result_fields,\n-                                                     rec(mt=mt\n-                                                         with\n-                                                             expected_field));\n+                                    result_fields +=\n+                                        ~[rec(mt=mt with expected_field)];\n                                 }\n                                 case (_) { ret result; }\n                             }"}, {"sha": "7c3116a4092e257173ade2b44feb8c73a19b5803", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=add9031dd5c2814195df163b1d35a853876c64f6", "patch": "@@ -302,10 +302,10 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             typ = ty::mk_tup(tcx, flds);\n         }\n         case (ast::ty_rec(?fields)) {\n-            let vec[field] flds = [];\n+            let field[] flds = ~[];\n             for (ast::ty_field f in fields) {\n                 auto tm = ast_mt_to_mt(tcx, getter, f.node.mt);\n-                vec::push[field](flds, rec(ident=f.node.ident, mt=tm));\n+                flds += ~[rec(ident=f.node.ident, mt=tm)];\n             }\n             typ = ty::mk_rec(tcx, flds);\n         }\n@@ -1954,13 +1954,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (none) {/* no-op */ }\n                 case (some(?b_0)) { check_expr(fcx, b_0); }\n             }\n-            let vec[field] fields_t = [];\n+            let field[] fields_t = ~[];\n             for (ast::field f in fields) {\n                 check_expr(fcx, f.node.expr);\n                 auto expr_t = expr_ty(fcx.ccx.tcx, f.node.expr);\n                 auto expr_mt = rec(ty=expr_t, mut=f.node.mut);\n-                vec::push[field](fields_t,\n-                                 rec(ident=f.node.ident, mt=expr_mt));\n+                fields_t += ~[rec(ident=f.node.ident, mt=expr_mt)];\n             }\n             alt (base) {\n                 case (none) {\n@@ -1970,7 +1969,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (some(?bexpr)) {\n                     check_expr(fcx, bexpr);\n                     auto bexpr_t = expr_ty(fcx.ccx.tcx, bexpr);\n-                    let vec[field] base_fields = [];\n+                    let field[] base_fields = ~[];\n                     alt (structure_of(fcx, expr.span, bexpr_t)) {\n                         case (ty::ty_rec(?flds)) { base_fields = flds; }\n                         case (_) {\n@@ -2017,7 +2016,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     let uint ix =\n                         ty::field_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                       fields);\n-                    if (ix >= vec::len[ty::field](fields)) {\n+                    if (ix >= ivec::len[ty::field](fields)) {\n                         fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on record\");\n                     }"}, {"sha": "86a0060cf77d2644f8f5f17ca0d620a074c50fd1", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add9031dd5c2814195df163b1d35a853876c64f6/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=add9031dd5c2814195df163b1d35a853876c64f6", "patch": "@@ -112,8 +112,8 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             s += \"tup(\" + str::connect(strs, \",\") + \")\";\n         }\n         case (ty_rec(?elems)) {\n-            auto f = bind field_to_str(cx, _);\n-            auto strs = vec::map[field, str](f, elems);\n+            let vec[str] strs = [];\n+            for (field fld in elems) { strs += [field_to_str(cx, fld)]; }\n             s += \"rec(\" + str::connect(strs, \",\") + \")\";\n         }\n         case (ty_tag(?id, ?tps)) {"}]}