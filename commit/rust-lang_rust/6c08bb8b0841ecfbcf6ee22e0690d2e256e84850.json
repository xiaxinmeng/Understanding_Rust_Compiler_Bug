{"sha": "6c08bb8b0841ecfbcf6ee22e0690d2e256e84850", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMDhiYjhiMDg0MWVjZmJjZjZlZTIyZTA2OTBkMmUyNTZlODQ4NTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-04-06T22:20:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-04-06T22:20:57Z"}, "message": "proc_macro: Improve Debug representations\n\nThis commit improves the `fmt::Debug` output of `proc_macro` data structures by\nprimarily focusing on the representation exposed by `proc_macro` rather than the\ncompiler's own internal representation. This cuts down quite a bit on assorted\nwrapper types and ensure a relatively clean output.\n\nCloses #49720", "tree": {"sha": "5ab96cc90a66bc66a6f622f093cd5a29a027c10b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab96cc90a66bc66a6f622f093cd5a29a027c10b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c08bb8b0841ecfbcf6ee22e0690d2e256e84850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c08bb8b0841ecfbcf6ee22e0690d2e256e84850", "html_url": "https://github.com/rust-lang/rust/commit/6c08bb8b0841ecfbcf6ee22e0690d2e256e84850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c08bb8b0841ecfbcf6ee22e0690d2e256e84850/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a143462783cec88b7b733e8aa09990bfeb59f754", "url": "https://api.github.com/repos/rust-lang/rust/commits/a143462783cec88b7b733e8aa09990bfeb59f754", "html_url": "https://github.com/rust-lang/rust/commit/a143462783cec88b7b733e8aa09990bfeb59f754"}], "stats": {"total": 98, "additions": 63, "deletions": 35}, "files": [{"sha": "257a8a72b1c7ca364e843e95c318b2ef6d074aad", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 57, "deletions": 26, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6c08bb8b0841ecfbcf6ee22e0690d2e256e84850/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c08bb8b0841ecfbcf6ee22e0690d2e256e84850/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=6c08bb8b0841ecfbcf6ee22e0690d2e256e84850", "patch": "@@ -127,7 +127,8 @@ impl fmt::Display for TokenStream {\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Debug for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.0.fmt(f)\n+        f.write_str(\"TokenStream \")?;\n+        f.debug_list().entries(self.clone()).finish()\n     }\n }\n \n@@ -222,7 +223,7 @@ pub fn quote_span(span: Span) -> TokenStream {\n \n /// A region of source code, along with macro expansion information.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub struct Span(syntax_pos::Span);\n \n macro_rules! diagnostic_method {\n@@ -334,6 +335,16 @@ impl Span {\n     diagnostic_method!(help, Level::Help);\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl fmt::Debug for Span {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?} bytes({}...{})\",\n+               self.0.ctxt(),\n+               self.0.lo().0,\n+               self.0.hi().0)\n+    }\n+}\n+\n /// A line-column pair representing the start or end of a `Span`.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -422,7 +433,7 @@ impl PartialEq<FileName> for SourceFile {\n \n /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub enum TokenTree {\n     /// A delimited tokenstream\n     Group(Group),\n@@ -463,6 +474,20 @@ impl TokenTree {\n     }\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl fmt::Debug for TokenTree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // Each of these has the name in the struct type in the derived debug,\n+        // so don't bother with an extra layer of indirection\n+        match *self {\n+            TokenTree::Group(ref tt) => tt.fmt(f),\n+            TokenTree::Term(ref tt) => tt.fmt(f),\n+            TokenTree::Op(ref tt) => tt.fmt(f),\n+            TokenTree::Literal(ref tt) => tt.fmt(f),\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<Group> for TokenTree {\n     fn from(g: Group) -> TokenTree {\n@@ -717,7 +742,8 @@ impl fmt::Display for Term {\n #[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct Literal {\n-    token: token::Token,\n+    lit: token::Lit,\n+    suffix: Option<ast::Name>,\n     span: Span,\n }\n \n@@ -734,10 +760,9 @@ macro_rules! suffixed_int_literals {\n         /// below.\n         #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n         pub fn $name(n: $kind) -> Literal {\n-            let lit = token::Lit::Integer(Symbol::intern(&n.to_string()));\n-            let ty = Some(Symbol::intern(stringify!($kind)));\n             Literal {\n-                token: token::Literal(lit, ty),\n+                lit: token::Lit::Integer(Symbol::intern(&n.to_string())),\n+                suffix: Some(Symbol::intern(stringify!($kind))),\n                 span: Span::call_site(),\n             }\n         }\n@@ -759,9 +784,9 @@ macro_rules! unsuffixed_int_literals {\n         /// below.\n         #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n         pub fn $name(n: $kind) -> Literal {\n-            let lit = token::Lit::Integer(Symbol::intern(&n.to_string()));\n             Literal {\n-                token: token::Literal(lit, None),\n+                lit: token::Lit::Integer(Symbol::intern(&n.to_string())),\n+                suffix: None,\n                 span: Span::call_site(),\n             }\n         }\n@@ -814,9 +839,9 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        let lit = token::Lit::Float(Symbol::intern(&n.to_string()));\n         Literal {\n-            token: token::Literal(lit, None),\n+            lit: token::Lit::Float(Symbol::intern(&n.to_string())),\n+            suffix: None,\n             span: Span::call_site(),\n         }\n     }\n@@ -837,9 +862,9 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        let lit = token::Lit::Float(Symbol::intern(&n.to_string()));\n         Literal {\n-            token: token::Literal(lit, Some(Symbol::intern(\"f32\"))),\n+            lit: token::Lit::Float(Symbol::intern(&n.to_string())),\n+            suffix: Some(Symbol::intern(\"f32\")),\n             span: Span::call_site(),\n         }\n     }\n@@ -859,9 +884,9 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        let lit = token::Lit::Float(Symbol::intern(&n.to_string()));\n         Literal {\n-            token: token::Literal(lit, None),\n+            lit: token::Lit::Float(Symbol::intern(&n.to_string())),\n+            suffix: None,\n             span: Span::call_site(),\n         }\n     }\n@@ -882,9 +907,9 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        let lit = token::Lit::Float(Symbol::intern(&n.to_string()));\n         Literal {\n-            token: token::Literal(lit, Some(Symbol::intern(\"f64\"))),\n+            lit: token::Lit::Float(Symbol::intern(&n.to_string())),\n+            suffix: Some(Symbol::intern(\"f64\")),\n             span: Span::call_site(),\n         }\n     }\n@@ -897,7 +922,8 @@ impl Literal {\n             escaped.extend(ch.escape_debug());\n         }\n         Literal {\n-            token: token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None),\n+            lit: token::Lit::Str_(Symbol::intern(&escaped)),\n+            suffix: None,\n             span: Span::call_site(),\n         }\n     }\n@@ -908,7 +934,8 @@ impl Literal {\n         let mut escaped = String::new();\n         escaped.extend(ch.escape_unicode());\n         Literal {\n-            token: token::Literal(token::Lit::Char(Symbol::intern(&escaped)), None),\n+            lit: token::Lit::Char(Symbol::intern(&escaped)),\n+            suffix: None,\n             span: Span::call_site(),\n         }\n     }\n@@ -919,7 +946,8 @@ impl Literal {\n         let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n             .map(Into::<char>::into).collect::<String>();\n         Literal {\n-            token: token::Literal(token::Lit::ByteStr(Symbol::intern(&string)), None),\n+            lit: token::Lit::ByteStr(Symbol::intern(&string)),\n+            suffix: None,\n             span: Span::call_site(),\n         }\n     }\n@@ -1055,7 +1083,7 @@ impl TokenTree {\n             Ident(ident, true) => {\n                 tt!(Term::new(&format!(\"r#{}\", ident), Span(span)))\n             }\n-            Literal(..) => tt!(self::Literal { token, span: Span(span) }),\n+            Literal(lit, suffix) => tt!(self::Literal { lit, suffix, span: Span(span) }),\n             DocComment(c) => {\n                 let style = comments::doc_comment_style(&c.as_str());\n                 let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n@@ -1111,33 +1139,36 @@ impl TokenTree {\n                 return TokenTree::Token(tt.span.0, token).into();\n             }\n             self::TokenTree::Literal(self::Literal {\n-                token: Literal(Lit::Integer(ref a), b),\n+                lit: Lit::Integer(ref a),\n+                suffix,\n                 span,\n             })\n                 if a.as_str().starts_with(\"-\") =>\n             {\n                 let minus = BinOp(BinOpToken::Minus);\n                 let integer = Symbol::intern(&a.as_str()[1..]);\n-                let integer = Literal(Lit::Integer(integer), b);\n+                let integer = Literal(Lit::Integer(integer), suffix);\n                 let a = TokenTree::Token(span.0, minus);\n                 let b = TokenTree::Token(span.0, integer);\n                 return vec![a, b].into_iter().collect()\n             }\n             self::TokenTree::Literal(self::Literal {\n-                token: Literal(Lit::Float(ref a), b),\n+                lit: Lit::Float(ref a),\n+                suffix,\n                 span,\n             })\n                 if a.as_str().starts_with(\"-\") =>\n             {\n                 let minus = BinOp(BinOpToken::Minus);\n                 let float = Symbol::intern(&a.as_str()[1..]);\n-                let float = Literal(Lit::Float(float), b);\n+                let float = Literal(Lit::Float(float), suffix);\n                 let a = TokenTree::Token(span.0, minus);\n                 let b = TokenTree::Token(span.0, float);\n                 return vec![a, b].into_iter().collect()\n             }\n             self::TokenTree::Literal(tt) => {\n-                return TokenTree::Token(tt.span.0, tt.token).into()\n+                let token = Literal(tt.lit, tt.suffix);\n+                return TokenTree::Token(tt.span.0, token).into()\n             }\n         };\n "}, {"sha": "a0ec692809499f47152482115a5ea40ccd791fc9", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c08bb8b0841ecfbcf6ee22e0690d2e256e84850/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c08bb8b0841ecfbcf6ee22e0690d2e256e84850/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=6c08bb8b0841ecfbcf6ee22e0690d2e256e84850", "patch": "@@ -208,13 +208,15 @@ macro_rules! literals {\n                 match self {\n                     $(LiteralKind::$i => {\n                         Literal {\n-                            token: token::Literal(token::Lit::$i(sym), suffix),\n+                            lit: token::Lit::$i(sym),\n+                            suffix,\n                             span: contents.span,\n                         }\n                     })*\n                     $(LiteralKind::$raw(n) => {\n                         Literal {\n-                            token: token::Literal(token::Lit::$raw(sym, n), suffix),\n+                            lit: token::Lit::$raw(sym, n),\n+                            suffix,\n                             span: contents.span,\n                         }\n                     })*\n@@ -224,16 +226,11 @@ macro_rules! literals {\n \n         impl Literal {\n             fn kind_contents_and_suffix(self) -> (LiteralKind, Term, Option<Term>) {\n-                let (lit, suffix) = match self.token {\n-                    token::Literal(lit, suffix) => (lit, suffix),\n-                    _ => panic!(\"unsupported literal {:?}\", self.token),\n-                };\n-\n-                let (kind, contents) = match lit {\n+                let (kind, contents) = match self.lit {\n                     $(token::Lit::$i(contents) => (LiteralKind::$i, contents),)*\n                     $(token::Lit::$raw(contents, n) => (LiteralKind::$raw(n), contents),)*\n                 };\n-                let suffix = suffix.map(|sym| Term::new(&sym.as_str(), self.span()));\n+                let suffix = self.suffix.map(|sym| Term::new(&sym.as_str(), self.span()));\n                 (kind, Term::new(&contents.as_str(), self.span()), suffix)\n             }\n         }"}]}