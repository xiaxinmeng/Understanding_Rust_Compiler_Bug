{"sha": "318726b301db2a0718d05f166d3d6c578273189c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxODcyNmIzMDFkYjJhMDcxOGQwNWYxNjZkM2Q2YzU3ODI3MzE4OWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-17T00:44:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-17T00:44:24Z"}, "message": "Auto merge of #71131 - pnkfelix:issue-69798-dont-reuse-post-lto-products-when-exports-change, r=nagisa\n\nDo not reuse post LTO products when exports change\n\nDo not reuse post lto products when exports change\n\nGeneralizes code from PR #67020, which handled case when imports change.\n\nFix #69798", "tree": {"sha": "8999b4fd86140661d8699e8d75ece7ca3d8dd872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8999b4fd86140661d8699e8d75ece7ca3d8dd872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/318726b301db2a0718d05f166d3d6c578273189c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/318726b301db2a0718d05f166d3d6c578273189c", "html_url": "https://github.com/rust-lang/rust/commit/318726b301db2a0718d05f166d3d6c578273189c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/318726b301db2a0718d05f166d3d6c578273189c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "868b51be6f29d5b43d37c5d65bac1482d3a50ad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/868b51be6f29d5b43d37c5d65bac1482d3a50ad8", "html_url": "https://github.com/rust-lang/rust/commit/868b51be6f29d5b43d37c5d65bac1482d3a50ad8"}, {"sha": "d05ae3a375917cf96ada5bd23f7927636db747e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d05ae3a375917cf96ada5bd23f7927636db747e7", "html_url": "https://github.com/rust-lang/rust/commit/d05ae3a375917cf96ada5bd23f7927636db747e7"}], "stats": {"total": 143, "additions": 121, "deletions": 22}, "files": [{"sha": "e21cdee961dc61c5d02b4d508495cf3a4b1e869f", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 69, "deletions": 22, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/318726b301db2a0718d05f166d3d6c578273189c/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318726b301db2a0718d05f166d3d6c578273189c/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=318726b301db2a0718d05f166d3d6c578273189c", "patch": "@@ -463,15 +463,18 @@ fn thin_lto(\n                 // If previous imports have been deleted, or we get an IO error\n                 // reading the file storing them, then we'll just use `None` as the\n                 // prev_import_map, which will force the code to be recompiled.\n-                let prev =\n-                    if path.exists() { ThinLTOImports::load_from_file(&path).ok() } else { None };\n-                let curr = ThinLTOImports::from_thin_lto_data(data);\n+                let prev = if path.exists() {\n+                    ThinLTOImportMaps::load_from_file(&path).ok()\n+                } else {\n+                    None\n+                };\n+                let curr = ThinLTOImportMaps::from_thin_lto_data(data);\n                 (Some(path), prev, curr)\n             } else {\n                 // If we don't compile incrementally, we don't need to load the\n                 // import data from LLVM.\n                 assert!(green_modules.is_empty());\n-                let curr = ThinLTOImports::default();\n+                let curr = ThinLTOImportMaps::default();\n                 (None, None, curr)\n             };\n         info!(\"thin LTO import map loaded\");\n@@ -497,10 +500,14 @@ fn thin_lto(\n             let module_name = module_name_to_str(module_name);\n \n             // If (1.) the module hasn't changed, and (2.) none of the modules\n-            // it imports from has changed, *and* (3.) the import-set itself has\n-            // not changed from the previous compile when it was last\n-            // ThinLTO'ed, then we can re-use the post-ThinLTO version of the\n-            // module. Otherwise, freshly perform LTO optimization.\n+            // it imports from nor exports to have changed, *and* (3.) the\n+            // import and export sets themselves have not changed from the\n+            // previous compile when it was last ThinLTO'ed, then we can re-use\n+            // the post-ThinLTO version of the module. Otherwise, freshly\n+            // perform LTO optimization.\n+            //\n+            // (Note that globally, the export set is just the inverse of the\n+            // import set.)\n             //\n             // This strategy means we can always save the computed imports as\n             // canon: when we reuse the post-ThinLTO version, condition (3.)\n@@ -509,19 +516,30 @@ fn thin_lto(\n             // version, the current import set *is* the correct one, since we\n             // are doing the ThinLTO in this current compilation cycle.)\n             //\n-            // See rust-lang/rust#59535.\n+            // For more discussion, see rust-lang/rust#59535 (where the import\n+            // issue was discovered) and rust-lang/rust#69798 (where the\n+            // analogous export issue was discovered).\n             if let (Some(prev_import_map), true) =\n                 (prev_import_map.as_ref(), green_modules.contains_key(module_name))\n             {\n                 assert!(cgcx.incr_comp_session_dir.is_some());\n \n-                let prev_imports = prev_import_map.modules_imported_by(module_name);\n-                let curr_imports = curr_import_map.modules_imported_by(module_name);\n+                let prev_imports = prev_import_map.imports_of(module_name);\n+                let curr_imports = curr_import_map.imports_of(module_name);\n+                let prev_exports = prev_import_map.exports_of(module_name);\n+                let curr_exports = curr_import_map.exports_of(module_name);\n                 let imports_all_green = curr_imports\n                     .iter()\n                     .all(|imported_module| green_modules.contains_key(imported_module));\n+                let exports_all_green = curr_exports\n+                    .iter()\n+                    .all(|exported_module| green_modules.contains_key(exported_module));\n \n-                if imports_all_green && equivalent_as_sets(prev_imports, curr_imports) {\n+                if imports_all_green\n+                    && equivalent_as_sets(prev_imports, curr_imports)\n+                    && exports_all_green\n+                    && equivalent_as_sets(prev_exports, curr_exports)\n+                {\n                     let work_product = green_modules[module_name].clone();\n                     copy_jobs.push(work_product);\n                     info!(\" - {}: re-used\", module_name);\n@@ -881,17 +899,32 @@ pub unsafe fn optimize_thin_module(\n     Ok(module)\n }\n \n+/// Summarizes module import/export relationships used by LLVM's ThinLTO pass.\n+///\n+/// Note that we tend to have two such instances of `ThinLTOImportMaps` in use:\n+/// one loaded from a file that represents the relationships used during the\n+/// compilation associated with the incremetnal build artifacts we are\n+/// attempting to reuse, and another constructed via `from_thin_lto_data`, which\n+/// captures the relationships of ThinLTO in the current compilation.\n #[derive(Debug, Default)]\n-pub struct ThinLTOImports {\n+pub struct ThinLTOImportMaps {\n     // key = llvm name of importing module, value = list of modules it imports from\n     imports: FxHashMap<String, Vec<String>>,\n+    // key = llvm name of exporting module, value = list of modules it exports to\n+    exports: FxHashMap<String, Vec<String>>,\n }\n \n-impl ThinLTOImports {\n-    fn modules_imported_by(&self, llvm_module_name: &str) -> &[String] {\n+impl ThinLTOImportMaps {\n+    /// Returns modules imported by `llvm_module_name` during some ThinLTO pass.\n+    fn imports_of(&self, llvm_module_name: &str) -> &[String] {\n         self.imports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n     }\n \n+    /// Returns modules exported by `llvm_module_name` during some ThinLTO pass.\n+    fn exports_of(&self, llvm_module_name: &str) -> &[String] {\n+        self.exports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n+    }\n+\n     fn save_to_file(&self, path: &Path) -> io::Result<()> {\n         use std::io::Write;\n         let file = File::create(path)?;\n@@ -906,16 +939,20 @@ impl ThinLTOImports {\n         Ok(())\n     }\n \n-    fn load_from_file(path: &Path) -> io::Result<ThinLTOImports> {\n+    fn load_from_file(path: &Path) -> io::Result<ThinLTOImportMaps> {\n         use std::io::BufRead;\n         let mut imports = FxHashMap::default();\n-        let mut current_module = None;\n-        let mut current_imports = vec![];\n+        let mut exports: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+        let mut current_module: Option<String> = None;\n+        let mut current_imports: Vec<String> = vec![];\n         let file = File::open(path)?;\n         for line in io::BufReader::new(file).lines() {\n             let line = line?;\n             if line.is_empty() {\n                 let importing_module = current_module.take().expect(\"Importing module not set\");\n+                for imported in &current_imports {\n+                    exports.entry(imported.clone()).or_default().push(importing_module.clone());\n+                }\n                 imports.insert(importing_module, mem::replace(&mut current_imports, vec![]));\n             } else if line.starts_with(' ') {\n                 // Space marks an imported module\n@@ -927,17 +964,17 @@ impl ThinLTOImports {\n                 current_module = Some(line.trim().to_string());\n             }\n         }\n-        Ok(ThinLTOImports { imports })\n+        Ok(ThinLTOImportMaps { imports, exports })\n     }\n \n     /// Loads the ThinLTO import map from ThinLTOData.\n-    unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImports {\n+    unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImportMaps {\n         unsafe extern \"C\" fn imported_module_callback(\n             payload: *mut libc::c_void,\n             importing_module_name: *const libc::c_char,\n             imported_module_name: *const libc::c_char,\n         ) {\n-            let map = &mut *(payload as *mut ThinLTOImports);\n+            let map = &mut *(payload as *mut ThinLTOImportMaps);\n             let importing_module_name = CStr::from_ptr(importing_module_name);\n             let importing_module_name = module_name_to_str(&importing_module_name);\n             let imported_module_name = CStr::from_ptr(imported_module_name);\n@@ -951,8 +988,18 @@ impl ThinLTOImports {\n                 .get_mut(importing_module_name)\n                 .unwrap()\n                 .push(imported_module_name.to_owned());\n+\n+            if !map.exports.contains_key(imported_module_name) {\n+                map.exports.insert(imported_module_name.to_owned(), vec![]);\n+            }\n+\n+            map.exports\n+                .get_mut(imported_module_name)\n+                .unwrap()\n+                .push(importing_module_name.to_owned());\n         }\n-        let mut map = ThinLTOImports::default();\n+\n+        let mut map = ThinLTOImportMaps::default();\n         llvm::LLVMRustGetThinLTOModuleImports(\n             data,\n             imported_module_callback,"}, {"sha": "4d48a5f0ac528e2d138504350b4a2463abed0447", "filename": "src/test/incremental/thinlto/cgu_invalidated_when_export_added.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/318726b301db2a0718d05f166d3d6c578273189c/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_export_added.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318726b301db2a0718d05f166d3d6c578273189c/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_export_added.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_export_added.rs?ref=318726b301db2a0718d05f166d3d6c578273189c", "patch": "@@ -0,0 +1,26 @@\n+// revisions: cfail1 cfail2\n+// build-pass\n+\n+// rust-lang/rust#69798:\n+//\n+// This is analgous to cgu_invalidated_when_import_added, but it covers a\n+// problem uncovered where a change to the *export* set caused a link failure\n+// when reusing post-LTO optimized object code.\n+\n+pub struct Foo {}\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"Dropping Foo\");\n+    }\n+}\n+#[no_mangle]\n+pub extern \"C\" fn run() {\n+    thread_local! { pub static FOO : Foo = Foo { } ; }\n+\n+    #[cfg(cfail2)]\n+    {\n+        FOO.with(|_f| ())\n+    }\n+}\n+\n+pub fn main() { run() }"}, {"sha": "e85b4856f3a96ef98297eec55e1f042c73e50b2e", "filename": "src/test/incremental/thinlto/cgu_invalidated_when_export_removed.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/318726b301db2a0718d05f166d3d6c578273189c/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_export_removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318726b301db2a0718d05f166d3d6c578273189c/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_export_removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_when_export_removed.rs?ref=318726b301db2a0718d05f166d3d6c578273189c", "patch": "@@ -0,0 +1,26 @@\n+// revisions: cfail1 cfail2\n+// build-pass\n+\n+// rust-lang/rust#69798:\n+//\n+// This is analgous to cgu_invalidated_when_export_added, but it covers the\n+// other direction. This is analogous to cgu_invalidated_when_import_added: we\n+// include it, because it may uncover bugs in variant implementation strategies.\n+\n+pub struct Foo {}\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"Dropping Foo\");\n+    }\n+}\n+#[no_mangle]\n+pub extern \"C\" fn run() {\n+    thread_local! { pub static FOO : Foo = Foo { } ; }\n+\n+    #[cfg(cfail1)]\n+    {\n+        FOO.with(|_f| ())\n+    }\n+}\n+\n+pub fn main() { run() }"}]}