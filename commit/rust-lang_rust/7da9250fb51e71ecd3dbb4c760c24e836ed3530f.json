{"sha": "7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYTkyNTBmYjUxZTcxZWNkM2RiYjRjNzYwYzI0ZTgzNmVkMzUzMGY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-04T14:22:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-04T14:22:00Z"}, "message": "Remove `Res::Label`\n\nPaths can never resolve to labels", "tree": {"sha": "5cfdf5d81bc7515770a171bba307ab3c0ec7f047", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cfdf5d81bc7515770a171bba307ab3c0ec7f047"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "html_url": "https://github.com/rust-lang/rust/commit/7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ddd1dc587615a0dc76cef80ff7d88a1b4bc28e", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ddd1dc587615a0dc76cef80ff7d88a1b4bc28e", "html_url": "https://github.com/rust-lang/rust/commit/85ddd1dc587615a0dc76cef80ff7d88a1b4bc28e"}], "stats": {"total": 47, "additions": 24, "deletions": 23}, "files": [{"sha": "0719eb701a984be99d7d4404ccbcf57f0a20c133", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "patch": "@@ -142,7 +142,6 @@ pub enum Res<Id = hir::HirId> {\n     Upvar(Id,           // `HirId` of closed over local\n           usize,        // index in the `freevars` list of the closure\n           ast::NodeId), // expr node that creates the closure\n-    Label(ast::NodeId),\n \n     // Macro namespace\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n@@ -349,7 +348,6 @@ impl<Id> Res<Id> {\n \n             Res::Local(..) |\n             Res::Upvar(..) |\n-            Res::Label(..)  |\n             Res::PrimTy(..) |\n             Res::SelfTy(..) |\n             Res::SelfCtor(..) |\n@@ -377,7 +375,6 @@ impl<Id> Res<Id> {\n             Res::PrimTy(..) => \"builtin type\",\n             Res::Local(..) => \"local variable\",\n             Res::Upvar(..) => \"closure capture\",\n-            Res::Label(..) => \"label\",\n             Res::SelfTy(..) => \"self type\",\n             Res::ToolMod => \"tool module\",\n             Res::NonMacroAttr(attr_kind) => attr_kind.descr(),\n@@ -405,7 +402,6 @@ impl<Id> Res<Id> {\n                 index,\n                 closure\n             ),\n-            Res::Label(id) => Res::Label(id),\n             Res::SelfTy(a, b) => Res::SelfTy(a, b),\n             Res::ToolMod => Res::ToolMod,\n             Res::NonMacroAttr(attr_kind) => Res::NonMacroAttr(attr_kind),"}, {"sha": "fc3987a4b1918408faa295fa885a7eb92dfadf6c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "patch": "@@ -151,6 +151,9 @@ pub trait Resolver {\n     /// Obtain per-namespace resolutions for `use` statement with the given `NoedId`.\n     fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n \n+    /// Obtain resolution for a label with the given `NodeId`.\n+    fn get_label_res(&mut self, id: NodeId) -> Option<NodeId>;\n+\n     /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n@@ -1246,7 +1249,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n         let target_id = match destination {\n             Some((id, _)) => {\n-                if let Res::Label(loop_id) = self.expect_full_res(id) {\n+                if let Some(loop_id) = self.resolver.get_label_res(id) {\n                     Ok(self.lower_node_id(loop_id))\n                 } else {\n                     Err(hir::LoopIdError::UnresolvedLabel)"}, {"sha": "0be26451ae4ae0fb7c891c0e35fd54cc031614a2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "patch": "@@ -1071,13 +1071,13 @@ enum RibKind<'a> {\n /// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n-struct Rib<'a> {\n-    bindings: FxHashMap<Ident, Res>,\n+struct Rib<'a, R = Res> {\n+    bindings: FxHashMap<Ident, R>,\n     kind: RibKind<'a>,\n }\n \n-impl<'a> Rib<'a> {\n-    fn new(kind: RibKind<'a>) -> Rib<'a> {\n+impl<'a, R> Rib<'a, R> {\n+    fn new(kind: RibKind<'a>) -> Rib<'a, R> {\n         Rib {\n             bindings: Default::default(),\n             kind,\n@@ -1638,7 +1638,7 @@ pub struct Resolver<'a> {\n     ribs: PerNS<Vec<Rib<'a>>>,\n \n     /// The current set of local scopes, for labels.\n-    label_ribs: Vec<Rib<'a>>,\n+    label_ribs: Vec<Rib<'a, NodeId>>,\n \n     /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n@@ -1663,6 +1663,8 @@ pub struct Resolver<'a> {\n     partial_res_map: NodeMap<PartialRes>,\n     /// Resolutions for import nodes, which have multiple resolutions in different namespaces.\n     import_res_map: NodeMap<PerNS<Option<Res>>>,\n+    /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n+    label_res_map: NodeMap<NodeId>,\n \n     pub freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n@@ -1841,6 +1843,10 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         self.import_res_map.get(&id).cloned().unwrap_or_default()\n     }\n \n+    fn get_label_res(&mut self, id: NodeId) -> Option<NodeId> {\n+        self.label_res_map.get(&id).cloned()\n+    }\n+\n     fn definitions(&mut self) -> &mut Definitions {\n         &mut self.definitions\n     }\n@@ -2024,6 +2030,7 @@ impl<'a> Resolver<'a> {\n \n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n+            label_res_map: Default::default(),\n             freevars: Default::default(),\n             freevars_seen: Default::default(),\n             export_map: FxHashMap::default(),\n@@ -2490,7 +2497,7 @@ impl<'a> Resolver<'a> {\n     ///\n     /// Stops after meeting a closure.\n     fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n-        where P: Fn(&Rib<'_>, Ident) -> Option<R>\n+        where P: Fn(&Rib<'_, NodeId>, Ident) -> Option<R>\n     {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n@@ -4332,10 +4339,9 @@ impl<'a> Resolver<'a> {\n     {\n         if let Some(label) = label {\n             self.unused_labels.insert(id, label.ident.span);\n-            let res = Res::Label(id);\n             self.with_label_rib(|this| {\n                 let ident = label.ident.modern_and_legacy();\n-                this.label_ribs.last_mut().unwrap().bindings.insert(ident, res);\n+                this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n             });\n         } else {\n@@ -4366,10 +4372,10 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                let res = self.search_label(label.ident, |rib, ident| {\n+                let node_id = self.search_label(label.ident, |rib, ident| {\n                     rib.bindings.get(&ident.modern_and_legacy()).cloned()\n                 });\n-                match res {\n+                match node_id {\n                     None => {\n                         // Search again for close matches...\n                         // Picks the first label that is \"close enough\", which is not necessarily\n@@ -4390,13 +4396,10 @@ impl<'a> Resolver<'a> {\n                                       ResolutionError::UndeclaredLabel(&label.ident.as_str(),\n                                                                        close_match));\n                     }\n-                    Some(Res::Label(id)) => {\n+                    Some(node_id) => {\n                         // Since this res is a label, it is never read.\n-                        self.record_partial_res(expr.id, PartialRes::new(Res::Label(id)));\n-                        self.unused_labels.remove(&id);\n-                    }\n-                    Some(_) => {\n-                        span_bug!(expr.span, \"label wasn't mapped to a label res!\");\n+                        self.label_res_map.insert(expr.id, node_id);\n+                        self.unused_labels.remove(&node_id);\n                     }\n                 }\n "}, {"sha": "f3e0fb32ec2dc28777ad61c03e79a3938fa8e700", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "patch": "@@ -796,7 +796,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             Res::PrimTy(..) |\n             Res::SelfTy(..) |\n-            Res::Label(..) |\n             Res::Def(HirDefKind::Macro(..), _) |\n             Res::ToolMod |\n             Res::NonMacroAttr(..) |"}, {"sha": "fa12d9c49dfc37ce383ade4ff37af9f88269c2d8", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7da9250fb51e71ecd3dbb4c760c24e836ed3530f/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "patch": "@@ -579,7 +579,7 @@ impl Sig for ast::Path {\n         let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n \n         let (name, start, end) = match res {\n-            Res::Label(..) | Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => {\n+            Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => {\n                 return Ok(Signature {\n                     text: pprust::path_to_string(self),\n                     defs: vec![],"}]}