{"sha": "0fbfc3e76916521b509b63286296dd0762170d34", "node_id": "C_kwDOAAsO6NoAKDBmYmZjM2U3NjkxNjUyMWI1MDliNjMyODYyOTZkZDA3NjIxNzBkMzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T05:26:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T05:26:35Z"}, "message": "Auto merge of #89518 - a1phyr:unix_file_vectored_at, r=workingjubilee\n\nAdd vectored positioned I/O on Unix\n\nAdd methods for vectored I/O with an offset on `File` for `unix` under `#![feature(unix_file_vectored_at)]`.\n\nThe new methods are wrappers around `preadv` and `pwritev`.\n\nTracking issue: #89517", "tree": {"sha": "1a534602c12a95b1e9b3dcab7aa2c43946830b3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a534602c12a95b1e9b3dcab7aa2c43946830b3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fbfc3e76916521b509b63286296dd0762170d34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fbfc3e76916521b509b63286296dd0762170d34", "html_url": "https://github.com/rust-lang/rust/commit/0fbfc3e76916521b509b63286296dd0762170d34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fbfc3e76916521b509b63286296dd0762170d34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70adb4e5b4c8f8bde4ade0edcb0435ff7bf31281", "url": "https://api.github.com/repos/rust-lang/rust/commits/70adb4e5b4c8f8bde4ade0edcb0435ff7bf31281", "html_url": "https://github.com/rust-lang/rust/commit/70adb4e5b4c8f8bde4ade0edcb0435ff7bf31281"}, {"sha": "92f35b32b212f7fdd1fe6cd5f85a7d41577d146f", "url": "https://api.github.com/repos/rust-lang/rust/commits/92f35b32b212f7fdd1fe6cd5f85a7d41577d146f", "html_url": "https://github.com/rust-lang/rust/commit/92f35b32b212f7fdd1fe6cd5f85a7d41577d146f"}], "stats": {"total": 279, "additions": 276, "deletions": 3}, "files": [{"sha": "a0e664acd130aae44f9df6c13803b9893ee1445c", "filename": "library/std/src/os/unix/fs.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0fbfc3e76916521b509b63286296dd0762170d34/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbfc3e76916521b509b63286296dd0762170d34/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs?ref=0fbfc3e76916521b509b63286296dd0762170d34", "patch": "@@ -17,6 +17,10 @@ use crate::sealed::Sealed;\n #[allow(unused_imports)]\n use io::{Read, Write};\n \n+// Tests for this module\n+#[cfg(test)]\n+mod tests;\n+\n /// Unix-specific extensions to [`fs::File`].\n #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n pub trait FileExt {\n@@ -54,6 +58,16 @@ pub trait FileExt {\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n \n+    /// Like `read_at`, except that it reads into a slice of buffers.\n+    ///\n+    /// Data is copied to fill each buffer in order, with the final buffer\n+    /// written to possibly being only partially filled. This method must behave\n+    /// equivalently to a single call to read with concatenated buffers.\n+    #[unstable(feature = \"unix_file_vectored_at\", issue = \"89517\")]\n+    fn read_vectored_at(&self, bufs: &mut [io::IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        io::default_read_vectored(|b| self.read_at(b, offset), bufs)\n+    }\n+\n     /// Reads the exact number of byte required to fill `buf` from the given offset.\n     ///\n     /// The offset is relative to the start of the file and thus independent\n@@ -155,6 +169,16 @@ pub trait FileExt {\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n \n+    /// Like `write_at`, except that it writes from a slice of buffers.\n+    ///\n+    /// Data is copied from each buffer in order, with the final buffer read\n+    /// from possibly being only partially consumed. This method must behave as\n+    /// a call to `write_at` with the buffers concatenated would.\n+    #[unstable(feature = \"unix_file_vectored_at\", issue = \"89517\")]\n+    fn write_vectored_at(&self, bufs: &[io::IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        io::default_write_vectored(|b| self.write_at(b, offset), bufs)\n+    }\n+\n     /// Attempts to write an entire buffer starting from a given offset.\n     ///\n     /// The offset is relative to the start of the file and thus independent\n@@ -218,9 +242,15 @@ impl FileExt for fs::File {\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n         self.as_inner().read_at(buf, offset)\n     }\n+    fn read_vectored_at(&self, bufs: &mut [io::IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        self.as_inner().read_vectored_at(bufs, offset)\n+    }\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n         self.as_inner().write_at(buf, offset)\n     }\n+    fn write_vectored_at(&self, bufs: &[io::IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        self.as_inner().write_vectored_at(bufs, offset)\n+    }\n }\n \n /// Unix-specific extensions to [`fs::Permissions`]."}, {"sha": "67f607bd4683735e3508f3eed425d7c9216922ac", "filename": "library/std/src/os/unix/fs/tests.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0fbfc3e76916521b509b63286296dd0762170d34/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbfc3e76916521b509b63286296dd0762170d34/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs%2Ftests.rs?ref=0fbfc3e76916521b509b63286296dd0762170d34", "patch": "@@ -0,0 +1,57 @@\n+use super::*;\n+\n+#[test]\n+fn read_vectored_at() {\n+    let msg = b\"preadv is working!\";\n+    let dir = crate::sys_common::io::test::tmpdir();\n+\n+    let filename = dir.join(\"preadv.txt\");\n+    {\n+        let mut file = fs::File::create(&filename).unwrap();\n+        file.write_all(msg).unwrap();\n+    }\n+    {\n+        let file = fs::File::open(&filename).unwrap();\n+        let mut buf0 = [0; 4];\n+        let mut buf1 = [0; 3];\n+\n+        let mut iovec = [io::IoSliceMut::new(&mut buf0), io::IoSliceMut::new(&mut buf1)];\n+\n+        let n = file.read_vectored_at(&mut iovec, 4).unwrap();\n+\n+        assert!(n == 4 || n == 7);\n+        assert_eq!(&buf0, b\"dv i\");\n+\n+        if n == 7 {\n+            assert_eq!(&buf1, b\"s w\");\n+        }\n+    }\n+}\n+\n+#[test]\n+fn write_vectored_at() {\n+    let msg = b\"pwritev is not working!\";\n+    let dir = crate::sys_common::io::test::tmpdir();\n+\n+    let filename = dir.join(\"preadv.txt\");\n+    {\n+        let mut file = fs::File::create(&filename).unwrap();\n+        file.write_all(msg).unwrap();\n+    }\n+    let expected = {\n+        let file = fs::File::options().write(true).open(&filename).unwrap();\n+        let buf0 = b\"    \";\n+        let buf1 = b\"great  \";\n+\n+        let iovec = [io::IoSlice::new(buf0), io::IoSlice::new(buf1)];\n+\n+        let n = file.write_vectored_at(&iovec, 11).unwrap();\n+\n+        assert!(n == 4 || n == 11);\n+\n+        if n == 4 { b\"pwritev is     working!\" } else { b\"pwritev is     great  !\" }\n+    };\n+\n+    let content = fs::read(&filename).unwrap();\n+    assert_eq!(&content, expected);\n+}"}, {"sha": "9874af4d3e2419614ac5df00b83fc6947dad1fe6", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 181, "deletions": 3, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/0fbfc3e76916521b509b63286296dd0762170d34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbfc3e76916521b509b63286296dd0762170d34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=0fbfc3e76916521b509b63286296dd0762170d34", "patch": "@@ -98,7 +98,7 @@ impl FileDesc {\n         let ret = cvt(unsafe {\n             libc::readv(\n                 self.as_raw_fd(),\n-                bufs.as_ptr() as *const libc::iovec,\n+                bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n                 cmp::min(bufs.len(), max_iov()) as libc::c_int,\n             )\n         })?;\n@@ -107,7 +107,7 @@ impl FileDesc {\n \n     #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        return crate::io::default_read_vectored(|b| self.read(b), bufs);\n+        io::default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     #[inline]\n@@ -153,6 +153,95 @@ impl FileDesc {\n         Ok(())\n     }\n \n+    #[cfg(any(\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+    ))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::preadv(\n+                self.as_raw_fd(),\n+                bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"netbsd\",\n+    )))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        io::default_read_vectored(|b| self.read_at(b, offset), bufs)\n+    }\n+\n+    // We support some old Android versions that do not have `preadv` in libc,\n+    // so we use weak linkage and fallback to a direct syscall if not available.\n+    //\n+    // On 32-bit targets, we don't want to deal with weird ABI issues around\n+    // passing 64-bits parameters to syscalls, so we fallback to the default\n+    // implementation if `preadv` is not available.\n+    #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::syscall! {\n+            fn preadv(\n+                fd: libc::c_int,\n+                iovec: *const libc::iovec,\n+                n_iovec: libc::c_int,\n+                offset: off64_t\n+            ) -> isize\n+        }\n+\n+        let ret = cvt(unsafe {\n+            preadv(\n+                self.as_raw_fd(),\n+                bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    // We support old MacOS and iOS versions that do not have `preadv`. There is\n+    // no `syscall` possible in these platform.\n+    #[cfg(any(\n+        all(target_os = \"android\", target_pointer_width = \"32\"),\n+        target_os = \"ios\",\n+        target_os = \"macos\",\n+    ))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::weak!(fn preadv64(libc::c_int, *const libc::iovec, libc::c_int, off64_t) -> isize);\n+\n+        match preadv64.get() {\n+            Some(preadv) => {\n+                let ret = cvt(unsafe {\n+                    preadv(\n+                        self.as_raw_fd(),\n+                        bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n+                        cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                        offset as _,\n+                    )\n+                })?;\n+                Ok(ret as usize)\n+            }\n+            None => io::default_read_vectored(|b| self.read_at(b, offset), bufs),\n+        }\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::write(\n@@ -178,7 +267,7 @@ impl FileDesc {\n \n     #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        return crate::io::default_write_vectored(|b| self.write(b), bufs);\n+        io::default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     #[inline]\n@@ -203,6 +292,95 @@ impl FileDesc {\n         }\n     }\n \n+    #[cfg(any(\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+    ))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::pwritev(\n+                self.as_raw_fd(),\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"netbsd\",\n+    )))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        io::default_write_vectored(|b| self.write_at(b, offset), bufs)\n+    }\n+\n+    // We support some old Android versions that do not have `pwritev` in libc,\n+    // so we use weak linkage and fallback to a direct syscall if not available.\n+    //\n+    // On 32-bit targets, we don't want to deal with weird ABI issues around\n+    // passing 64-bits parameters to syscalls, so we fallback to the default\n+    // implementation if `pwritev` is not available.\n+    #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::syscall! {\n+            fn pwritev(\n+                fd: libc::c_int,\n+                iovec: *const libc::iovec,\n+                n_iovec: libc::c_int,\n+                offset: off64_t\n+            ) -> isize\n+        }\n+\n+        let ret = cvt(unsafe {\n+            pwritev(\n+                self.as_raw_fd(),\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    // We support old MacOS and iOS versions that do not have `pwritev`. There is\n+    // no `syscall` possible in these platform.\n+    #[cfg(any(\n+        all(target_os = \"android\", target_pointer_width = \"32\"),\n+        target_os = \"ios\",\n+        target_os = \"macos\",\n+    ))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::weak!(fn pwritev64(libc::c_int, *const libc::iovec, libc::c_int, off64_t) -> isize);\n+\n+        match pwritev64.get() {\n+            Some(pwritev) => {\n+                let ret = cvt(unsafe {\n+                    pwritev(\n+                        self.as_raw_fd(),\n+                        bufs.as_ptr() as *const libc::iovec,\n+                        cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                        offset as _,\n+                    )\n+                })?;\n+                Ok(ret as usize)\n+            }\n+            None => io::default_write_vectored(|b| self.write_at(b, offset), bufs),\n+        }\n+    }\n+\n     #[cfg(not(any(\n         target_env = \"newlib\",\n         target_os = \"solaris\","}, {"sha": "7566fafda24a9fbdfbea2d6bee72ad3dd65b2773", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fbfc3e76916521b509b63286296dd0762170d34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbfc3e76916521b509b63286296dd0762170d34/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=0fbfc3e76916521b509b63286296dd0762170d34", "patch": "@@ -1132,6 +1132,10 @@ impl File {\n         self.0.read_buf(cursor)\n     }\n \n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        self.0.read_vectored_at(bufs, offset)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n@@ -1149,6 +1153,10 @@ impl File {\n         self.0.write_at(buf, offset)\n     }\n \n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        self.0.write_vectored_at(bufs, offset)\n+    }\n+\n     pub fn flush(&self) -> io::Result<()> {\n         Ok(())\n     }"}]}