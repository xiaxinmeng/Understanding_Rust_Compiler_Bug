{"sha": "02e40d910a2cd6b3c83c645fb28bc0f474016095", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZTQwZDkxMGEyY2Q2YjNjODNjNjQ1ZmIyOGJjMGY0NzQwMTYwOTU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-17T12:20:35Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-17T12:20:35Z"}, "message": "Rollup merge of #33044 - petrochenkov:prefix, r=eddyb\n\nsyntax: Parse import prefixes as paths\n\nFixes https://github.com/rust-lang/rust/issues/10415\n\nr? @eddyb\n(This partially intersects with https://github.com/rust-lang/rust/pull/33041)", "tree": {"sha": "2707ef563375a1201bce68f2a7c72cb181ee9260", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2707ef563375a1201bce68f2a7c72cb181ee9260"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02e40d910a2cd6b3c83c645fb28bc0f474016095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02e40d910a2cd6b3c83c645fb28bc0f474016095", "html_url": "https://github.com/rust-lang/rust/commit/02e40d910a2cd6b3c83c645fb28bc0f474016095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02e40d910a2cd6b3c83c645fb28bc0f474016095/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4046f396ed74ed1a5b86f219ff725e97d91ffc9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4046f396ed74ed1a5b86f219ff725e97d91ffc9b", "html_url": "https://github.com/rust-lang/rust/commit/4046f396ed74ed1a5b86f219ff725e97d91ffc9b"}, {"sha": "e7bc939f1ee2ada3e3f679fd42c8e08d8a22996f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7bc939f1ee2ada3e3f679fd42c8e08d8a22996f", "html_url": "https://github.com/rust-lang/rust/commit/e7bc939f1ee2ada3e3f679fd42c8e08d8a22996f"}], "stats": {"total": 358, "additions": 224, "deletions": 134}, "files": [{"sha": "15ad049cbe3d454dfc32ffb114320c3d4d8395d4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -28,9 +28,9 @@ use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::{self, VariantKind};\n \n-use syntax::ast::Name;\n+use syntax::ast::{Name, NodeId};\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::{special_idents, SELF_KEYWORD_NAME, SUPER_KEYWORD_NAME};\n+use syntax::parse::token::keywords;\n use syntax::codemap::{Span, DUMMY_SP};\n \n use rustc::hir;\n@@ -100,6 +100,37 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         block.stmts.iter().any(is_item)\n     }\n \n+    fn sanity_check_import(&self, view_path: &hir::ViewPath, id: NodeId) {\n+        let path = match view_path.node {\n+            ViewPathSimple(_, ref path) |\n+            ViewPathGlob (ref path) |\n+            ViewPathList(ref path, _) => path\n+        };\n+\n+        // Check for type parameters\n+        let found_param = path.segments.iter().any(|segment| {\n+            !segment.parameters.types().is_empty() ||\n+            !segment.parameters.lifetimes().is_empty() ||\n+            !segment.parameters.bindings().is_empty()\n+        });\n+        if found_param {\n+            self.session.span_err(path.span,\n+                                  \"type or lifetime parameter is found in import path\");\n+        }\n+\n+        // Checking for special identifiers in path\n+        // prevent `self` or `super` at beginning of global path\n+        if path.global && path.segments.len() > 0 {\n+            let first = path.segments[0].identifier.name;\n+            if first == keywords::Super.to_name() || first == keywords::SelfValue.to_name() {\n+                self.session.add_lint(\n+                    lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH, id, path.span,\n+                    format!(\"expected identifier, found keyword `{}`\", first)\n+                );\n+            }\n+        }\n+    }\n+\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, parent_ref: &mut Module<'b>) {\n         let parent = *parent_ref;\n@@ -114,10 +145,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let is_global;\n                 let module_path: Vec<Name> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n-                        is_global = full_path.global;\n                         full_path.segments\n                                  .split_last()\n                                  .unwrap()\n@@ -129,30 +158,17 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n-                        is_global = module_ident_path.global;\n                         module_ident_path.segments\n                                          .iter()\n                                          .map(|seg| seg.identifier.name)\n                                          .collect()\n                     }\n                 };\n \n-                // Checking for special identifiers in path\n-                // prevent `self` or `super` at beginning of global path\n-                if is_global && (module_path.first() == Some(&SELF_KEYWORD_NAME) ||\n-                                 module_path.first() == Some(&SUPER_KEYWORD_NAME)) {\n-                    self.session.add_lint(\n-                        lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH,\n-                        item.id,\n-                        item.span,\n-                        format!(\"expected identifier, found keyword `{}`\",\n-                                module_path.first().unwrap().as_str()));\n-                }\n+                self.sanity_check_import(view_path, item.id);\n \n                 // Build up the import directives.\n-                let is_prelude = item.attrs.iter().any(|attr| {\n-                    attr.name() == special_idents::prelude_import.name.as_str()\n-                });\n+                let is_prelude = item.attrs.iter().any(|attr| attr.name() == \"prelude_import\");\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {"}, {"sha": "f3d3bbd9f99052160c6f685d6160f896b2fb820f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 63, "deletions": 111, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -81,6 +81,8 @@ type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n pub enum PathParsingMode {\n     /// A path with no type parameters; e.g. `foo::bar::Baz`\n     NoTypesAllowed,\n+    /// Same as `NoTypesAllowed`, but may end with `::{` or `::*`, which are left unparsed\n+    ImportPrefix,\n     /// A path with a lifetime and type parameters, with no double colons\n     /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n     LifetimeAndTypesWithoutColons,\n@@ -591,20 +593,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_path_list_item(&mut self) -> PResult<'a, ast::PathListItem> {\n-        let lo = self.span.lo;\n-        let node = if self.eat_keyword(keywords::SelfValue) {\n-            let rename = self.parse_rename()?;\n-            ast::PathListItemKind::Mod { id: ast::DUMMY_NODE_ID, rename: rename }\n-        } else {\n-            let ident = self.parse_ident()?;\n-            let rename = self.parse_rename()?;\n-            ast::PathListItemKind::Ident { name: ident, rename: rename, id: ast::DUMMY_NODE_ID }\n-        };\n-        let hi = self.last_span.hi;\n-        Ok(spanned(lo, hi, node))\n-    }\n-\n     /// Check if the next token is `tok`, and return `true` if so.\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n@@ -1763,8 +1751,8 @@ impl<'a> Parser<'a> {\n             LifetimeAndTypesWithColons => {\n                 self.parse_path_segments_with_colons()?\n             }\n-            NoTypesAllowed => {\n-                self.parse_path_segments_without_types()?\n+            NoTypesAllowed | ImportPrefix => {\n+                self.parse_path_segments_without_types(mode == ImportPrefix)?\n             }\n         };\n         path.segments.extend(segments);\n@@ -1801,8 +1789,8 @@ impl<'a> Parser<'a> {\n             LifetimeAndTypesWithColons => {\n                 self.parse_path_segments_with_colons()?\n             }\n-            NoTypesAllowed => {\n-                self.parse_path_segments_without_types()?\n+            NoTypesAllowed | ImportPrefix => {\n+                self.parse_path_segments_without_types(mode == ImportPrefix)?\n             }\n         };\n \n@@ -1920,7 +1908,8 @@ impl<'a> Parser<'a> {\n \n     /// Examples:\n     /// - `a::b::c`\n-    pub fn parse_path_segments_without_types(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_without_types(&mut self, import_prefix: bool)\n+                                             -> PResult<'a, Vec<ast::PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n@@ -1932,9 +1921,11 @@ impl<'a> Parser<'a> {\n                 parameters: ast::PathParameters::none()\n             });\n \n-            // If we do not see a `::`, stop.\n-            if !self.eat(&token::ModSep) {\n+            // If we do not see a `::` or see `::{`/`::*`, stop.\n+            if !self.check(&token::ModSep) || import_prefix && self.is_import_coupler() {\n                 return Ok(segments);\n+            } else {\n+                self.bump();\n             }\n         }\n     }\n@@ -6127,106 +6118,67 @@ impl<'a> Parser<'a> {\n         self.parse_item_(attrs, true, false)\n     }\n \n+    fn parse_path_list_items(&mut self) -> PResult<'a, Vec<ast::PathListItem>> {\n+        self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n+                                 &token::CloseDelim(token::Brace),\n+                                 SeqSep::trailing_allowed(token::Comma), |this| {\n+            let lo = this.span.lo;\n+            let node = if this.eat_keyword(keywords::SelfValue) {\n+                let rename = this.parse_rename()?;\n+                ast::PathListItemKind::Mod { id: ast::DUMMY_NODE_ID, rename: rename }\n+            } else {\n+                let ident = this.parse_ident()?;\n+                let rename = this.parse_rename()?;\n+                ast::PathListItemKind::Ident { name: ident, rename: rename, id: ast::DUMMY_NODE_ID }\n+            };\n+            let hi = this.last_span.hi;\n+            Ok(spanned(lo, hi, node))\n+        })\n+    }\n+\n+    /// `::{` or `::*`\n+    fn is_import_coupler(&mut self) -> bool {\n+        self.check(&token::ModSep) &&\n+            self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace) ||\n+                                   *t == token::BinOp(token::Star))\n+    }\n \n-    /// Matches view_path : MOD? non_global_path as IDENT\n-    /// | MOD? non_global_path MOD_SEP LBRACE RBRACE\n-    /// | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n-    /// | MOD? non_global_path MOD_SEP STAR\n-    /// | MOD? non_global_path\n+    /// Matches ViewPath:\n+    /// MOD_SEP? non_global_path\n+    /// MOD_SEP? non_global_path as IDENT\n+    /// MOD_SEP? non_global_path MOD_SEP STAR\n+    /// MOD_SEP? non_global_path MOD_SEP LBRACE item_seq RBRACE\n+    /// MOD_SEP? LBRACE item_seq RBRACE\n     fn parse_view_path(&mut self) -> PResult<'a, P<ViewPath>> {\n         let lo = self.span.lo;\n-\n-        // Allow a leading :: because the paths are absolute either way.\n-        // This occurs with \"use $crate::...\" in macros.\n-        let is_global = self.eat(&token::ModSep);\n-\n-        if self.check(&token::OpenDelim(token::Brace)) {\n-            // use {foo,bar}\n-            let idents = self.parse_unspanned_seq(\n-                &token::OpenDelim(token::Brace),\n-                &token::CloseDelim(token::Brace),\n-                SeqSep::trailing_allowed(token::Comma),\n-                |p| p.parse_path_list_item())?;\n-            let path = ast::Path {\n+        if self.check(&token::OpenDelim(token::Brace)) || self.is_import_coupler() {\n+            // `{foo, bar}` or `::{foo, bar}`\n+            let prefix = ast::Path {\n+                global: self.eat(&token::ModSep),\n+                segments: Vec::new(),\n                 span: mk_sp(lo, self.span.hi),\n-                global: is_global,\n-                segments: Vec::new()\n             };\n-            return Ok(P(spanned(lo, self.span.hi, ViewPathList(path, idents))));\n-        }\n-\n-        let first_ident = self.parse_ident()?;\n-        let mut path = vec!(first_ident);\n-        if let token::ModSep = self.token {\n-            // foo::bar or foo::{a,b,c} or foo::*\n-            while self.check(&token::ModSep) {\n+            let items = self.parse_path_list_items()?;\n+            Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n+        } else {\n+            let prefix = self.parse_path(ImportPrefix)?;\n+            if self.is_import_coupler() {\n+                // `foo::bar::{a, b}` or `foo::bar::*`\n                 self.bump();\n-\n-                match self.token {\n-                  token::Ident(..) => {\n-                    let ident = self.parse_ident()?;\n-                    path.push(ident);\n-                  }\n-\n-                  // foo::bar::{a,b,c}\n-                  token::OpenDelim(token::Brace) => {\n-                    let idents = self.parse_unspanned_seq(\n-                        &token::OpenDelim(token::Brace),\n-                        &token::CloseDelim(token::Brace),\n-                        SeqSep::trailing_allowed(token::Comma),\n-                        |p| p.parse_path_list_item()\n-                    )?;\n-                    let path = ast::Path {\n-                        span: mk_sp(lo, self.span.hi),\n-                        global: is_global,\n-                        segments: path.into_iter().map(|identifier| {\n-                            ast::PathSegment {\n-                                identifier: identifier,\n-                                parameters: ast::PathParameters::none(),\n-                            }\n-                        }).collect()\n-                    };\n-                    return Ok(P(spanned(lo, self.span.hi, ViewPathList(path, idents))));\n-                  }\n-\n-                  // foo::bar::*\n-                  token::BinOp(token::Star) => {\n+                if self.check(&token::BinOp(token::Star)) {\n                     self.bump();\n-                    let path = ast::Path {\n-                        span: mk_sp(lo, self.span.hi),\n-                        global: is_global,\n-                        segments: path.into_iter().map(|identifier| {\n-                            ast::PathSegment {\n-                                identifier: identifier,\n-                                parameters: ast::PathParameters::none(),\n-                            }\n-                        }).collect()\n-                    };\n-                    return Ok(P(spanned(lo, self.span.hi, ViewPathGlob(path))));\n-                  }\n-\n-                  // fall-through for case foo::bar::;\n-                  token::Semi => {\n-                    self.span_err(self.span, \"expected identifier or `{` or `*`, found `;`\");\n-                  }\n-\n-                  _ => break\n+                    Ok(P(spanned(lo, self.span.hi, ViewPathGlob(prefix))))\n+                } else {\n+                    let items = self.parse_path_list_items()?;\n+                    Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n                 }\n+            } else {\n+                // `foo::bar` or `foo::bar as baz`\n+                let rename = self.parse_rename()?.\n+                                  unwrap_or(prefix.segments.last().unwrap().identifier);\n+                Ok(P(spanned(lo, self.last_span.hi, ViewPathSimple(rename, prefix))))\n             }\n         }\n-        let mut rename_to = path[path.len() - 1];\n-        let path = ast::Path {\n-            span: mk_sp(lo, self.last_span.hi),\n-            global: is_global,\n-            segments: path.into_iter().map(|identifier| {\n-                ast::PathSegment {\n-                    identifier: identifier,\n-                    parameters: ast::PathParameters::none(),\n-                }\n-            }).collect()\n-        };\n-        rename_to = self.parse_rename()?.unwrap_or(rename_to);\n-        Ok(P(spanned(lo, self.last_span.hi, ViewPathSimple(rename_to, path))))\n     }\n \n     fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {"}, {"sha": "beb15a11a969533c20682d69ec1493fa8961b5cf", "filename": "src/test/compile-fail/import-prefix-macro-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-1.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub mod b {\n+        pub mod c {\n+            pub struct S;\n+            pub struct Z;\n+        }\n+    }\n+}\n+\n+macro_rules! import {\n+    ($p: path) => (use $p {S, Z}); //~ERROR expected one of `::`, `;`, or `as`, found `{`\n+}\n+\n+import! { a::b::c }\n+\n+fn main() {}"}, {"sha": "56c6273aa9a29e12edbf61e655128df3926019bc", "filename": "src/test/compile-fail/import-prefix-macro-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-prefix-macro-2.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub mod b {\n+        pub mod c {\n+            pub struct S;\n+            pub struct Z;\n+        }\n+    }\n+}\n+\n+macro_rules! import {\n+    ($p: path) => (use ::$p {S, Z}); //~ERROR  expected identifier, found `a::b::c`\n+}\n+\n+import! { a::b::c }\n+\n+fn main() {}"}, {"sha": "66d4d6d06211da6fec00b0aeff66c7ec3db90d34", "filename": "src/test/compile-fail/import-ty-params.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-ty-params.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub mod b {\n+        pub mod c {\n+            pub struct S<T>(T);\n+        }\n+    }\n+}\n+\n+macro_rules! import {\n+    ($p: path) => (use $p;);\n+}\n+\n+import! { a::b::c::S<u8> } //~ERROR type or lifetime parameter is found in import path\n+\n+fn main() {}"}, {"sha": "613f54eb331349d907c4c46b2f1d69a3243648ea", "filename": "src/test/compile-fail/self_type_keyword-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fself_type_keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fself_type_keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword-2.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::Self as Foo; //~ ERROR unresolved import `self::Self`\n+\n+pub fn main() {}"}, {"sha": "b28f48bb1056e2f6e09588c2280582f7662cb5b7", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -39,9 +39,6 @@ pub fn main() {\n     }\n }\n \n-use self::Self as Foo;\n-//~^ ERROR expected identifier, found keyword `Self`\n-\n use std::option::Option as Self;\n //~^ ERROR expected identifier, found keyword `Self`\n "}, {"sha": "e6a10d43e2994331be2f33b408a42193de398e9a", "filename": "src/test/parse-fail/use-ends-with-mod-sep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fparse-fail%2Fuse-ends-with-mod-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Fparse-fail%2Fuse-ends-with-mod-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fuse-ends-with-mod-sep.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-use std::any::; //~ ERROR expected identifier or `{` or `*`, found `;`\n+use std::any::; //~ ERROR expected identifier, found `;`"}, {"sha": "cfe4ff78e6258d13b9aa9888119601b3add2915a", "filename": "src/test/run-pass/import-prefix-macro.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Frun-pass%2Fimport-prefix-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e40d910a2cd6b3c83c645fb28bc0f474016095/src%2Ftest%2Frun-pass%2Fimport-prefix-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-prefix-macro.rs?ref=02e40d910a2cd6b3c83c645fb28bc0f474016095", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {\n+    pub mod b {\n+        pub mod c {\n+            pub struct S;\n+            pub struct Z;\n+        }\n+        pub struct W;\n+    }\n+}\n+\n+macro_rules! import {\n+    (1 $p: path) => (use $p;);\n+    (2 $p: path) => (use $p::{Z};);\n+    (3 $p: path) => (use $p::*;);\n+}\n+\n+import! { 1 a::b::c::S }\n+import! { 2 a::b::c }\n+import! { 3 a::b }\n+\n+fn main() {\n+    let s = S;\n+    let z = Z;\n+    let w = W;\n+}"}]}