{"sha": "0fe3bcfd3524a023a11c95d0615178e897f72200", "node_id": "C_kwDOAAsO6NoAKDBmZTNiY2ZkMzUyNGEwMjNhMTFjOTVkMDYxNTE3OGU4OTdmNzIyMDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-04T12:57:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-04T12:57:04Z"}, "message": "Auto merge of #12808 - Veykril:check-workspace, r=Veykril\n\nfeat: Only flycheck workspace that belongs to saved file\n\nSupercedes https://github.com/rust-lang/rust-analyzer/pull/11038\n\nThere is still the problem that all the diagnostics are cleared, only clearing diagnostics of the relevant workspace isn't easily doable though I think, will have to dig into that", "tree": {"sha": "4f4499d9577c4f89f485d33f967835ecddf24d22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f4499d9577c4f89f485d33f967835ecddf24d22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fe3bcfd3524a023a11c95d0615178e897f72200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fe3bcfd3524a023a11c95d0615178e897f72200", "html_url": "https://github.com/rust-lang/rust/commit/0fe3bcfd3524a023a11c95d0615178e897f72200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fe3bcfd3524a023a11c95d0615178e897f72200/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6a9fbfd00aa6c587b40ce4dbb58da871b6e8aff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a9fbfd00aa6c587b40ce4dbb58da871b6e8aff", "html_url": "https://github.com/rust-lang/rust/commit/c6a9fbfd00aa6c587b40ce4dbb58da871b6e8aff"}, {"sha": "df7f755e3b08e58a30bdbb39685bea76be7762ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/df7f755e3b08e58a30bdbb39685bea76be7762ba", "html_url": "https://github.com/rust-lang/rust/commit/df7f755e3b08e58a30bdbb39685bea76be7762ba"}], "stats": {"total": 146, "additions": 123, "deletions": 23}, "files": [{"sha": "3347940ec6d639015304407bdd708dcff184c2bb", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=0fe3bcfd3524a023a11c95d0615178e897f72200", "patch": "@@ -57,6 +57,7 @@ pub struct FlycheckHandle {\n     // XXX: drop order is significant\n     sender: Sender<Restart>,\n     _thread: jod_thread::JoinHandle,\n+    id: usize,\n }\n \n impl FlycheckHandle {\n@@ -72,18 +73,22 @@ impl FlycheckHandle {\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");\n-        FlycheckHandle { sender, _thread: thread }\n+        FlycheckHandle { id, sender, _thread: thread }\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n     pub fn update(&self) {\n         self.sender.send(Restart).unwrap();\n     }\n+\n+    pub fn id(&self) -> usize {\n+        self.id\n+    }\n }\n \n pub enum Message {\n     /// Request adding a diagnostic with fixes included to a file\n-    AddDiagnostic { workspace_root: AbsPathBuf, diagnostic: Diagnostic },\n+    AddDiagnostic { id: usize, workspace_root: AbsPathBuf, diagnostic: Diagnostic },\n \n     /// Request check progress notification to client\n     Progress {\n@@ -96,8 +101,9 @@ pub enum Message {\n impl fmt::Debug for Message {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Message::AddDiagnostic { workspace_root, diagnostic } => f\n+            Message::AddDiagnostic { id, workspace_root, diagnostic } => f\n                 .debug_struct(\"AddDiagnostic\")\n+                .field(\"id\", id)\n                 .field(\"workspace_root\", workspace_root)\n                 .field(\"diagnostic_code\", &diagnostic.code.as_ref().map(|it| &it.code))\n                 .finish(),\n@@ -183,7 +189,7 @@ impl FlycheckActor {\n                     }\n                 }\n                 Event::CheckEvent(None) => {\n-                    tracing::debug!(\"flycheck finished\");\n+                    tracing::debug!(flycheck_id = self.id, \"flycheck finished\");\n \n                     // Watcher finished\n                     let cargo_handle = self.cargo_handle.take().unwrap();\n@@ -203,6 +209,7 @@ impl FlycheckActor {\n \n                     CargoMessage::Diagnostic(msg) => {\n                         self.send(Message::AddDiagnostic {\n+                            id: self.id,\n                             workspace_root: self.workspace_root.clone(),\n                             diagnostic: msg,\n                         });"}, {"sha": "6ae23ac841adaa6a7f97d8841c57aec96f2d2439", "filename": "crates/paths/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Fpaths%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Fpaths%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2Fsrc%2Flib.rs?ref=0fe3bcfd3524a023a11c95d0615178e897f72200", "patch": "@@ -106,6 +106,14 @@ impl AsRef<Path> for AbsPath {\n     }\n }\n \n+impl ToOwned for AbsPath {\n+    type Owned = AbsPathBuf;\n+\n+    fn to_owned(&self) -> Self::Owned {\n+        AbsPathBuf(self.0.to_owned())\n+    }\n+}\n+\n impl<'a> TryFrom<&'a Path> for &'a AbsPath {\n     type Error = &'a Path;\n     fn try_from(path: &'a Path) -> Result<&'a AbsPath, &'a Path> {"}, {"sha": "09150c77d7dd1d9de53adaff2a67382132e32711", "filename": "crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=0fe3bcfd3524a023a11c95d0615178e897f72200", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::lsp_ext;\n \n-pub(crate) type CheckFixes = Arc<FxHashMap<FileId, Vec<Fix>>>;\n+pub(crate) type CheckFixes = Arc<FxHashMap<usize, FxHashMap<FileId, Vec<Fix>>>>;\n \n #[derive(Debug, Default, Clone)]\n pub struct DiagnosticsMapConfig {\n@@ -22,7 +22,7 @@ pub(crate) struct DiagnosticCollection {\n     // FIXME: should be FxHashMap<FileId, Vec<ra_id::Diagnostic>>\n     pub(crate) native: FxHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n     // FIXME: should be Vec<flycheck::Diagnostic>\n-    pub(crate) check: FxHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n+    pub(crate) check: FxHashMap<usize, FxHashMap<FileId, Vec<lsp_types::Diagnostic>>>,\n     pub(crate) check_fixes: CheckFixes,\n     changes: FxHashSet<FileId>,\n }\n@@ -35,9 +35,19 @@ pub(crate) struct Fix {\n }\n \n impl DiagnosticCollection {\n-    pub(crate) fn clear_check(&mut self) {\n+    pub(crate) fn clear_check(&mut self, flycheck_id: usize) {\n+        if let Some(it) = Arc::make_mut(&mut self.check_fixes).get_mut(&flycheck_id) {\n+            it.clear();\n+        }\n+        if let Some(it) = self.check.get_mut(&flycheck_id) {\n+            self.changes.extend(it.drain().map(|(key, _value)| key));\n+        }\n+    }\n+\n+    pub(crate) fn clear_check_all(&mut self) {\n         Arc::make_mut(&mut self.check_fixes).clear();\n-        self.changes.extend(self.check.drain().map(|(key, _value)| key))\n+        self.changes\n+            .extend(self.check.values_mut().flat_map(|it| it.drain().map(|(key, _value)| key)))\n     }\n \n     pub(crate) fn clear_native_for(&mut self, file_id: FileId) {\n@@ -47,19 +57,20 @@ impl DiagnosticCollection {\n \n     pub(crate) fn add_check_diagnostic(\n         &mut self,\n+        flycheck_id: usize,\n         file_id: FileId,\n         diagnostic: lsp_types::Diagnostic,\n         fix: Option<Fix>,\n     ) {\n-        let diagnostics = self.check.entry(file_id).or_default();\n+        let diagnostics = self.check.entry(flycheck_id).or_default().entry(file_id).or_default();\n         for existing_diagnostic in diagnostics.iter() {\n             if are_diagnostics_equal(existing_diagnostic, &diagnostic) {\n                 return;\n             }\n         }\n \n         let check_fixes = Arc::make_mut(&mut self.check_fixes);\n-        check_fixes.entry(file_id).or_default().extend(fix);\n+        check_fixes.entry(flycheck_id).or_default().entry(file_id).or_default().extend(fix);\n         diagnostics.push(diagnostic);\n         self.changes.insert(file_id);\n     }\n@@ -89,7 +100,8 @@ impl DiagnosticCollection {\n         file_id: FileId,\n     ) -> impl Iterator<Item = &lsp_types::Diagnostic> {\n         let native = self.native.get(&file_id).into_iter().flatten();\n-        let check = self.check.get(&file_id).into_iter().flatten();\n+        let check =\n+            self.check.values().filter_map(move |it| it.get(&file_id)).into_iter().flatten();\n         native.chain(check)\n     }\n "}, {"sha": "932a31e08f6fa4ac67badb51e8bc2c88093c23ec", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=0fe3bcfd3524a023a11c95d0615178e897f72200", "patch": "@@ -192,6 +192,7 @@ impl GlobalState {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();\n                     if reload::should_refresh_for_change(&path, file.change_kind) {\n+                        tracing::warn!(\"fetch-fiel_change\");\n                         self.fetch_workspaces_queue\n                             .request_op(format!(\"vfs file change: {}\", path.display()));\n                     }\n@@ -201,6 +202,7 @@ impl GlobalState {\n                     }\n                 }\n \n+                // Clear native diagnostics when their file gets deleted\n                 if !file.exists() {\n                     self.diagnostics.clear_native_for(file.file_id);\n                 }"}, {"sha": "47daa732d5d3254ab779a9af4ae2091697c0bd13", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=0fe3bcfd3524a023a11c95d0615178e897f72200", "patch": "@@ -1094,7 +1094,9 @@ pub(crate) fn handle_code_action(\n     }\n \n     // Fixes from `cargo check`.\n-    for fix in snap.check_fixes.get(&frange.file_id).into_iter().flatten() {\n+    for fix in\n+        snap.check_fixes.values().filter_map(|it| it.get(&frange.file_id)).into_iter().flatten()\n+    {\n         // FIXME: this mapping is awkward and shouldn't exist. Refactor\n         // `snap.check_fixes` to not convert to LSP prematurely.\n         let intersect_fix_range = fix"}, {"sha": "b504c248782667752c8adfb5f10d8cbe1ecef11a", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 79, "deletions": 10, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=0fe3bcfd3524a023a11c95d0615178e897f72200", "patch": "@@ -2,13 +2,15 @@\n //! requests/replies and notifications back to the client.\n use std::{\n     fmt,\n+    ops::Deref,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n \n use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n-use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n+use ide_db::base_db::{SourceDatabase, SourceDatabaseExt, VfsPath};\n+use itertools::Itertools;\n use lsp_server::{Connection, Notification, Request};\n use lsp_types::notification::Notification as _;\n use vfs::{ChangeKind, FileId};\n@@ -371,7 +373,7 @@ impl GlobalState {\n                 let _p = profile::span(\"GlobalState::handle_event/flycheck\");\n                 loop {\n                     match task {\n-                        flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n+                        flycheck::Message::AddDiagnostic { id, workspace_root, diagnostic } => {\n                             let snap = self.snapshot();\n                             let diagnostics =\n                                 crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n@@ -383,6 +385,7 @@ impl GlobalState {\n                             for diag in diagnostics {\n                                 match url_to_file_id(&self.vfs.read().0, &diag.url) {\n                                     Ok(file_id) => self.diagnostics.add_check_diagnostic(\n+                                        id,\n                                         file_id,\n                                         diag.diagnostic,\n                                         diag.fix,\n@@ -400,7 +403,7 @@ impl GlobalState {\n                         flycheck::Message::Progress { id, progress } => {\n                             let (state, message) = match progress {\n                                 flycheck::Progress::DidStart => {\n-                                    self.diagnostics.clear_check();\n+                                    self.diagnostics.clear_check(id);\n                                     (Progress::Begin, None)\n                                 }\n                                 flycheck::Progress::DidCheckCrate(target) => {\n@@ -444,7 +447,10 @@ impl GlobalState {\n         let memdocs_added_or_removed = self.mem_docs.take_changes();\n \n         if self.is_quiescent() {\n-            if !was_quiescent {\n+            if !was_quiescent\n+                && !self.fetch_workspaces_queue.op_requested()\n+                && !self.fetch_build_data_queue.op_requested()\n+            {\n                 for flycheck in &self.flycheck {\n                     flycheck.update();\n                 }\n@@ -734,13 +740,76 @@ impl GlobalState {\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidSaveTextDocument>(|this, params| {\n-                for flycheck in &this.flycheck {\n-                    flycheck.update();\n+                let mut updated = false;\n+                if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    let (vfs, _) = &*this.vfs.read();\n+                    if let Some(file_id) = vfs.file_id(&vfs_path) {\n+                        let analysis = this.analysis_host.analysis();\n+                        // Crates containing or depending on the saved file\n+                        let crate_ids: Vec<_> = analysis\n+                            .crate_for(file_id)?\n+                            .into_iter()\n+                            .flat_map(|id| {\n+                                this.analysis_host\n+                                    .raw_database()\n+                                    .crate_graph()\n+                                    .transitive_rev_deps(id)\n+                            })\n+                            .sorted()\n+                            .unique()\n+                            .collect();\n+\n+                        let crate_root_paths: Vec<_> = crate_ids\n+                            .iter()\n+                            .filter_map(|&crate_id| {\n+                                analysis\n+                                    .crate_root(crate_id)\n+                                    .map(|file_id| {\n+                                        vfs.file_path(file_id).as_path().map(ToOwned::to_owned)\n+                                    })\n+                                    .transpose()\n+                            })\n+                            .collect::<ide::Cancellable<_>>()?;\n+                        let crate_root_paths: Vec<_> =\n+                            crate_root_paths.iter().map(Deref::deref).collect();\n+\n+                        // Find all workspaces that have at least one target containing the saved file\n+                        let workspace_ids =\n+                            this.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n+                                project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n+                                    cargo.packages().any(|pkg| {\n+                                        cargo[pkg].targets.iter().any(|&it| {\n+                                            crate_root_paths.contains(&cargo[it].root.as_path())\n+                                        })\n+                                    })\n+                                }\n+                                project_model::ProjectWorkspace::Json { project, .. } => project\n+                                    .crates()\n+                                    .any(|(c, _)| crate_ids.iter().any(|&crate_id| crate_id == c)),\n+                                project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n+                            });\n+\n+                        // Find and trigger corresponding flychecks\n+                        for flycheck in &this.flycheck {\n+                            for (id, _) in workspace_ids.clone() {\n+                                if id == flycheck.id() {\n+                                    updated = true;\n+                                    flycheck.update();\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if let Some(abs_path) = vfs_path.as_path() {\n+                        if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n+                            this.fetch_workspaces_queue\n+                                .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n+                        }\n+                    }\n                 }\n-                if let Ok(abs_path) = from_proto::abs_path(&params.text_document.uri) {\n-                    if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n-                        this.fetch_workspaces_queue\n-                            .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n+                if !updated {\n+                    for flycheck in &this.flycheck {\n+                        flycheck.update();\n                     }\n                 }\n                 Ok(())"}, {"sha": "c90291eb5e29ad337dba58b8117eeed2bffbf76d", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe3bcfd3524a023a11c95d0615178e897f72200/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=0fe3bcfd3524a023a11c95d0615178e897f72200", "patch": "@@ -458,7 +458,7 @@ impl GlobalState {\n             Some(it) => it,\n             None => {\n                 self.flycheck = Vec::new();\n-                self.diagnostics.clear_check();\n+                self.diagnostics.clear_check_all();\n                 return;\n             }\n         };"}]}