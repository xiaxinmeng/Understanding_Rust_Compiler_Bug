{"sha": "6af388b25050bca26710be7e4030e17bf6d8d2f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZjM4OGIyNTA1MGJjYTI2NzEwYmU3ZTQwMzBlMTdiZjZkOGQyZjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-20T08:41:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-20T08:41:17Z"}, "message": "Auto merge of #68847 - ecstatic-morse:const-impl, r=oli-obk\n\nAllow trait methods to be called on concrete types in a const context\n\nThis partially implements [RFC 2632](https://github.com/rust-lang/rfcs/pull/2632) by const-checking methods inside an `impl const` block and allowing those methods to be called on concrete types. Calling trait methods on type parameters in a const context is not yet allowed. Implementing this will require much more work. Since we are only concerned with methods on concrete types, we are able to take advantage of the machinery in `Instance::resolve`, which is doing most of the work.\n\nThis also propagates `#[rustc_const_unstable]` from parent items to child items, making that attribute behave like `#[stable]` and `#[unstable]` do. This allows trait methods to be marked as unstably const.\n\ncc #67792 #57563\ncc @rust-lang/wg-const-eval\nr? @oli-obk", "tree": {"sha": "7126a3429ceb0e584cdcca8b7b75ecaaebf88d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7126a3429ceb0e584cdcca8b7b75ecaaebf88d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6af388b25050bca26710be7e4030e17bf6d8d2f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6af388b25050bca26710be7e4030e17bf6d8d2f7", "html_url": "https://github.com/rust-lang/rust/commit/6af388b25050bca26710be7e4030e17bf6d8d2f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6af388b25050bca26710be7e4030e17bf6d8d2f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de362d88ea17ab23ca2483cb798bc7aeb81a48f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/de362d88ea17ab23ca2483cb798bc7aeb81a48f5", "html_url": "https://github.com/rust-lang/rust/commit/de362d88ea17ab23ca2483cb798bc7aeb81a48f5"}, {"sha": "19801b12c950f727a4e6938a87b0b2fdece73c07", "url": "https://api.github.com/repos/rust-lang/rust/commits/19801b12c950f727a4e6938a87b0b2fdece73c07", "html_url": "https://github.com/rust-lang/rust/commit/19801b12c950f727a4e6938a87b0b2fdece73c07"}], "stats": {"total": 818, "additions": 597, "deletions": 221}, "files": [{"sha": "3cee10f1356bf5d17de7d5b775a6148d46835099", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -279,6 +279,14 @@ rustc_queries! {\n             desc { |tcx| \"checking if item is const fn: `{}`\", tcx.def_path_str(key) }\n         }\n \n+        /// Returns `true` if this is a const `impl`. **Do not call this function manually.**\n+        ///\n+        /// This query caches the base data for the `is_const_impl` helper function, which also\n+        /// takes into account stability attributes (e.g., `#[rustc_const_unstable]`).\n+        query is_const_impl_raw(key: DefId) -> bool {\n+            desc { |tcx| \"checking if item is const impl: `{}`\", tcx.def_path_str(key) }\n+        }\n+\n         query asyncness(key: DefId) -> hir::IsAsync {\n             desc { |tcx| \"checking if the function is async: `{}`\", tcx.def_path_str(key) }\n         }"}, {"sha": "ad7221b16b2d95d372410da3dbe136f0fd17ea2a", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -66,15 +66,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl { constness, ref of_trait, .. } = item.kind {\n-                    if let Const::Yes(span) = constness {\n-                        this.lctx\n-                            .diagnostic()\n-                            .struct_span_err(item.span, \"const trait impls are not yet implemented\")\n-                            .span_label(span, \"const because of this\")\n-                            .emit();\n-                    }\n-\n+                if let ItemKind::Impl { ref of_trait, .. } = item.kind {\n                     this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n                 } else {\n                     visit::walk_item(this, item);"}, {"sha": "27efcd508414af0e557eae07e995f42dd73ba53c", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 77, "deletions": 53, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_attr as attr;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::abi::Abi;\n \n@@ -82,72 +82,96 @@ pub fn is_min_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-pub fn provide(providers: &mut Providers<'_>) {\n-    /// Const evaluability whitelist is here to check evaluability at the\n-    /// top level beforehand.\n-    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n-        if tcx.is_closure(def_id) {\n-            return None;\n-        }\n+pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n+    let parent_id = tcx.hir().get_parent_did(hir_id);\n+    if !parent_id.is_top_level_module() {\n+        is_const_impl_raw(tcx, LocalDefId::from_def_id(parent_id))\n+    } else {\n+        false\n+    }\n+}\n \n-        match tcx.fn_sig(def_id).abi() {\n-            Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n-                Some(tcx.lookup_const_stability(def_id).is_some())\n-            }\n-            _ => None,\n+/// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n+/// said intrinsic is on the whitelist for being const callable.\n+fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let hir_id =\n+        tcx.hir().as_local_hir_id(def_id).expect(\"Non-local call to local provider is_const_fn\");\n+\n+    let node = tcx.hir().get(hir_id);\n+\n+    if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n+        whitelisted\n+    } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n+        if fn_like.constness() == hir::Constness::Const {\n+            return true;\n         }\n-    }\n \n-    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n-    /// said intrinsic is on the whitelist for being const callable.\n-    fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        let hir_id = tcx\n-            .hir()\n-            .as_local_hir_id(def_id)\n-            .expect(\"Non-local call to local provider is_const_fn\");\n+        // If the function itself is not annotated with `const`, it may still be a `const fn`\n+        // if it resides in a const trait impl.\n+        is_parent_const_impl_raw(tcx, hir_id)\n+    } else if let hir::Node::Ctor(_) = node {\n+        true\n+    } else {\n+        false\n+    }\n+}\n \n-        let node = tcx.hir().get(hir_id);\n+/// Const evaluability whitelist is here to check evaluability at the\n+/// top level beforehand.\n+fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n+    if tcx.is_closure(def_id) {\n+        return None;\n+    }\n \n-        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n-            whitelisted\n-        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n-            fn_like.constness() == hir::Constness::Const\n-        } else if let hir::Node::Ctor(_) = node {\n-            true\n-        } else {\n-            false\n+    match tcx.fn_sig(def_id).abi() {\n+        Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n+            Some(tcx.lookup_const_stability(def_id).is_some())\n         }\n+        _ => None,\n     }\n+}\n \n-    fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        is_const_fn(tcx, def_id)\n-            && match tcx.lookup_const_stability(def_id) {\n-                Some(stab) => {\n-                    if cfg!(debug_assertions) && stab.promotable {\n-                        let sig = tcx.fn_sig(def_id);\n-                        assert_eq!(\n-                            sig.unsafety(),\n-                            hir::Unsafety::Normal,\n-                            \"don't mark const unsafe fns as promotable\",\n-                            // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n-                        );\n-                    }\n-                    stab.promotable\n+/// Checks whether the given item is an `impl` that has a `const` modifier.\n+fn is_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(hir_id);\n+    matches!(\n+        node,\n+        hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Impl { constness: hir::Constness::Const, .. },\n+            ..\n+        })\n+    )\n+}\n+\n+fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    is_const_fn(tcx, def_id)\n+        && match tcx.lookup_const_stability(def_id) {\n+            Some(stab) => {\n+                if cfg!(debug_assertions) && stab.promotable {\n+                    let sig = tcx.fn_sig(def_id);\n+                    assert_eq!(\n+                        sig.unsafety(),\n+                        hir::Unsafety::Normal,\n+                        \"don't mark const unsafe fns as promotable\",\n+                        // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n+                    );\n                 }\n-                None => false,\n+                stab.promotable\n             }\n-    }\n+            None => false,\n+        }\n+}\n \n-    fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        is_const_fn(tcx, def_id)\n-            && tcx\n-                .lookup_const_stability(def_id)\n-                .map(|stab| stab.allow_const_fn_ptr)\n-                .unwrap_or(false)\n-    }\n+fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    is_const_fn(tcx, def_id)\n+        && tcx.lookup_const_stability(def_id).map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)\n+}\n \n+pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         is_const_fn_raw,\n+        is_const_impl_raw: |tcx, def_id| is_const_impl_raw(tcx, LocalDefId::from_def_id(def_id)),\n         is_promotable_const_fn,\n         const_fn_is_allowed_fn_ptr,\n         ..*providers"}, {"sha": "1553f826c7e4bb04c28127f997eede114bd05d60", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -4,7 +4,7 @@ use rustc::middle::lang_items;\n use rustc::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::*;\n use rustc::ty::cast::CastTy;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Instance, InstanceDef, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_hir::{def_id::DefId, HirId};\n use rustc_index::bit_set::BitSet;\n@@ -502,8 +502,8 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             TerminatorKind::Call { func, .. } => {\n                 let fn_ty = func.ty(*self.body, self.tcx);\n \n-                let def_id = match fn_ty.kind {\n-                    ty::FnDef(def_id, _) => def_id,\n+                let (def_id, substs) = match fn_ty.kind {\n+                    ty::FnDef(def_id, substs) => (def_id, substs),\n \n                     ty::FnPtr(_) => {\n                         self.check_op(ops::FnCallIndirect);\n@@ -520,6 +520,20 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                     return;\n                 }\n \n+                // See if this is a trait method for a concrete type whose impl of that trait is\n+                // `const`.\n+                if self.tcx.features().const_trait_impl {\n+                    let instance = Instance::resolve(self.tcx, self.param_env, def_id, substs);\n+                    debug!(\"Resolving ({:?}) -> {:?}\", def_id, instance);\n+                    if let Some(func) = instance {\n+                        if let InstanceDef::Item(def_id) = func.def {\n+                            if is_const_fn(self.tcx, def_id) {\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+\n                 if is_lang_panic_fn(self.tcx, def_id) {\n                     self.check_op(ops::Panic);\n                 } else if let Some(feature) = is_unstable_const_fn(self.tcx, def_id) {"}, {"sha": "5a99ee27301ad02393bcbe0fdee95aa50cefcc0d", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -10,6 +10,14 @@ use std::borrow::Cow;\n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n+    // Prevent const trait methods from being annotated as `stable`.\n+    if tcx.features().staged_api {\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n+            return Err((body.span, \"trait methods cannot be stable const fn\".into()));\n+        }\n+    }\n+\n     let mut current = def_id;\n     loop {\n         let predicates = tcx.predicates_of(current);"}, {"sha": "d9296deb1d963911339375d0eaa8f6a9ac3b66a5", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 173, "deletions": 118, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -9,7 +9,7 @@ use rustc::session::parse::feature_err;\n use rustc::session::Session;\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n-use rustc_attr::{self as attr, Stability};\n+use rustc_attr::{self as attr, ConstStability, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -41,6 +41,7 @@ struct Annotator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n+    parent_const_stab: Option<&'tcx ConstStability>,\n     parent_depr: Option<DeprecationEntry>,\n     in_trait_impl: bool,\n }\n@@ -58,144 +59,197 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     ) where\n         F: FnOnce(&mut Self),\n     {\n-        if self.tcx.features().staged_api {\n-            // This crate explicitly wants staged API.\n-            debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n-            if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-                self.tcx.sess.span_err(\n-                    item_sp,\n-                    \"`#[deprecated]` cannot be used in staged API; \\\n-                                                 use `#[rustc_deprecated]` instead\",\n-                );\n+        if !self.tcx.features().staged_api {\n+            self.forbid_staged_api_attrs(hir_id, attrs, item_sp, kind, visit_children);\n+            return;\n+        }\n+\n+        // This crate explicitly wants staged API.\n+\n+        debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n+        if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n+            self.tcx.sess.span_err(\n+                item_sp,\n+                \"`#[deprecated]` cannot be used in staged API; \\\n+                                             use `#[rustc_deprecated]` instead\",\n+            );\n+        }\n+\n+        let (stab, const_stab) = attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n+\n+        let const_stab = const_stab.map(|const_stab| {\n+            let const_stab = self.tcx.intern_const_stability(const_stab);\n+            self.index.const_stab_map.insert(hir_id, const_stab);\n+            const_stab\n+        });\n+\n+        if const_stab.is_none() {\n+            debug!(\"annotate: const_stab not found, parent = {:?}\", self.parent_const_stab);\n+            if let Some(parent) = self.parent_const_stab {\n+                if parent.level.is_unstable() {\n+                    self.index.const_stab_map.insert(hir_id, parent);\n+                }\n             }\n-            let (stab, const_stab) =\n-                attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n-            if let Some(const_stab) = const_stab {\n-                let const_stab = self.tcx.intern_const_stability(const_stab);\n-                self.index.const_stab_map.insert(hir_id, const_stab);\n+        }\n+\n+        let stab = stab.map(|mut stab| {\n+            // Error if prohibited, or can't inherit anything from a container.\n+            if kind == AnnotationKind::Prohibited\n+                || (kind == AnnotationKind::Container\n+                    && stab.level.is_stable()\n+                    && stab.rustc_depr.is_none())\n+            {\n+                self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n             }\n-            if let Some(mut stab) = stab {\n-                // Error if prohibited, or can't inherit anything from a container.\n-                if kind == AnnotationKind::Prohibited\n-                    || (kind == AnnotationKind::Container\n-                        && stab.level.is_stable()\n-                        && stab.rustc_depr.is_none())\n-                {\n-                    self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n-                }\n \n-                debug!(\"annotate: found {:?}\", stab);\n-                // If parent is deprecated and we're not, inherit this by merging\n-                // deprecated_since and its reason.\n-                if let Some(parent_stab) = self.parent_stab {\n-                    if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n-                        stab.rustc_depr = parent_stab.rustc_depr\n-                    }\n+            debug!(\"annotate: found {:?}\", stab);\n+            // If parent is deprecated and we're not, inherit this by merging\n+            // deprecated_since and its reason.\n+            if let Some(parent_stab) = self.parent_stab {\n+                if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n+                    stab.rustc_depr = parent_stab.rustc_depr\n                 }\n+            }\n \n-                let stab = self.tcx.intern_stability(stab);\n-\n-                // Check if deprecated_since < stable_since. If it is,\n-                // this is *almost surely* an accident.\n-                if let (\n-                    &Some(attr::RustcDeprecation { since: dep_since, .. }),\n-                    &attr::Stable { since: stab_since },\n-                ) = (&stab.rustc_depr, &stab.level)\n+            let stab = self.tcx.intern_stability(stab);\n+\n+            // Check if deprecated_since < stable_since. If it is,\n+            // this is *almost surely* an accident.\n+            if let (\n+                &Some(attr::RustcDeprecation { since: dep_since, .. }),\n+                &attr::Stable { since: stab_since },\n+            ) = (&stab.rustc_depr, &stab.level)\n+            {\n+                // Explicit version of iter::order::lt to handle parse errors properly\n+                for (dep_v, stab_v) in\n+                    dep_since.as_str().split('.').zip(stab_since.as_str().split('.'))\n                 {\n-                    // Explicit version of iter::order::lt to handle parse errors properly\n-                    for (dep_v, stab_v) in\n-                        dep_since.as_str().split('.').zip(stab_since.as_str().split('.'))\n-                    {\n-                        if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n-                            match dep_v.cmp(&stab_v) {\n-                                Ordering::Less => {\n-                                    self.tcx.sess.span_err(\n-                                        item_sp,\n-                                        \"An API can't be stabilized \\\n-                                                                     after it is deprecated\",\n-                                    );\n-                                    break;\n-                                }\n-                                Ordering::Equal => continue,\n-                                Ordering::Greater => break,\n+                    if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n+                        match dep_v.cmp(&stab_v) {\n+                            Ordering::Less => {\n+                                self.tcx.sess.span_err(\n+                                    item_sp,\n+                                    \"An API can't be stabilized \\\n+                                                                 after it is deprecated\",\n+                                );\n+                                break;\n                             }\n-                        } else {\n-                            // Act like it isn't less because the question is now nonsensical,\n-                            // and this makes us not do anything else interesting.\n-                            self.tcx.sess.span_err(\n-                                item_sp,\n-                                \"Invalid stability or deprecation \\\n-                                                             version found\",\n-                            );\n-                            break;\n+                            Ordering::Equal => continue,\n+                            Ordering::Greater => break,\n                         }\n+                    } else {\n+                        // Act like it isn't less because the question is now nonsensical,\n+                        // and this makes us not do anything else interesting.\n+                        self.tcx.sess.span_err(\n+                            item_sp,\n+                            \"Invalid stability or deprecation \\\n+                                                         version found\",\n+                        );\n+                        break;\n                     }\n                 }\n-\n-                self.index.stab_map.insert(hir_id, stab);\n-\n-                let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n-                visit_children(self);\n-                self.parent_stab = orig_parent_stab;\n-            } else {\n-                debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n-                if let Some(stab) = self.parent_stab {\n-                    if stab.level.is_unstable() {\n-                        self.index.stab_map.insert(hir_id, stab);\n-                    }\n-                }\n-                visit_children(self);\n-            }\n-        } else {\n-            // Emit errors for non-staged-api crates.\n-            let unstable_attrs = [\n-                sym::unstable,\n-                sym::stable,\n-                sym::rustc_deprecated,\n-                sym::rustc_const_unstable,\n-                sym::rustc_const_stable,\n-            ];\n-            for attr in attrs {\n-                let name = attr.name_or_empty();\n-                if unstable_attrs.contains(&name) {\n-                    attr::mark_used(attr);\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        attr.span,\n-                        E0734,\n-                        \"stability attributes may not be used outside of the standard library\",\n-                    )\n-                    .emit();\n-                }\n             }\n \n-            // Propagate unstability.  This can happen even for non-staged-api crates in case\n-            // -Zforce-unstable-if-unmarked is set.\n+            self.index.stab_map.insert(hir_id, stab);\n+            stab\n+        });\n+\n+        if stab.is_none() {\n+            debug!(\"annotate: stab not found, parent = {:?}\", self.parent_stab);\n             if let Some(stab) = self.parent_stab {\n                 if stab.level.is_unstable() {\n                     self.index.stab_map.insert(hir_id, stab);\n                 }\n             }\n+        }\n \n-            if let Some(depr) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-                if kind == AnnotationKind::Prohibited {\n-                    self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n-                }\n+        self.recurse_with_stability_attrs(stab, const_stab, visit_children);\n+    }\n+\n+    fn recurse_with_stability_attrs(\n+        &mut self,\n+        stab: Option<&'tcx Stability>,\n+        const_stab: Option<&'tcx ConstStability>,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        // These will be `Some` if this item changes the corresponding stability attribute.\n+        let mut replaced_parent_stab = None;\n+        let mut replaced_parent_const_stab = None;\n+\n+        if let Some(stab) = stab {\n+            replaced_parent_stab = Some(replace(&mut self.parent_stab, Some(stab)));\n+        }\n+        if let Some(const_stab) = const_stab {\n+            replaced_parent_const_stab =\n+                Some(replace(&mut self.parent_const_stab, Some(const_stab)));\n+        }\n \n-                // `Deprecation` is just two pointers, no need to intern it\n-                let depr_entry = DeprecationEntry::local(depr, hir_id);\n-                self.index.depr_map.insert(hir_id, depr_entry.clone());\n-\n-                let orig_parent_depr = replace(&mut self.parent_depr, Some(depr_entry));\n-                visit_children(self);\n-                self.parent_depr = orig_parent_depr;\n-            } else if let Some(parent_depr) = self.parent_depr.clone() {\n-                self.index.depr_map.insert(hir_id, parent_depr);\n-                visit_children(self);\n-            } else {\n-                visit_children(self);\n+        f(self);\n+\n+        if let Some(orig_parent_stab) = replaced_parent_stab {\n+            self.parent_stab = orig_parent_stab;\n+        }\n+        if let Some(orig_parent_const_stab) = replaced_parent_const_stab {\n+            self.parent_const_stab = orig_parent_const_stab;\n+        }\n+    }\n+\n+    fn forbid_staged_api_attrs(\n+        &mut self,\n+        hir_id: HirId,\n+        attrs: &[Attribute],\n+        item_sp: Span,\n+        kind: AnnotationKind,\n+        visit_children: impl FnOnce(&mut Self),\n+    ) {\n+        // Emit errors for non-staged-api crates.\n+        let unstable_attrs = [\n+            sym::unstable,\n+            sym::stable,\n+            sym::rustc_deprecated,\n+            sym::rustc_const_unstable,\n+            sym::rustc_const_stable,\n+        ];\n+        for attr in attrs {\n+            let name = attr.name_or_empty();\n+            if unstable_attrs.contains(&name) {\n+                attr::mark_used(attr);\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    attr.span,\n+                    E0734,\n+                    \"stability attributes may not be used outside of the standard library\",\n+                )\n+                .emit();\n+            }\n+        }\n+\n+        // Propagate unstability.  This can happen even for non-staged-api crates in case\n+        // -Zforce-unstable-if-unmarked is set.\n+        if let Some(stab) = self.parent_stab {\n+            if stab.level.is_unstable() {\n+                self.index.stab_map.insert(hir_id, stab);\n             }\n         }\n+\n+        if let Some(depr) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n+            if kind == AnnotationKind::Prohibited {\n+                self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n+            }\n+\n+            // `Deprecation` is just two pointers, no need to intern it\n+            let depr_entry = DeprecationEntry::local(depr, hir_id);\n+            self.index.depr_map.insert(hir_id, depr_entry.clone());\n+\n+            let orig_parent_depr = replace(&mut self.parent_depr, Some(depr_entry));\n+            visit_children(self);\n+            self.parent_depr = orig_parent_depr;\n+        } else if let Some(parent_depr) = self.parent_depr.clone() {\n+            self.index.depr_map.insert(hir_id, parent_depr);\n+            visit_children(self);\n+        } else {\n+            visit_children(self);\n+        }\n     }\n }\n \n@@ -376,6 +430,7 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n             tcx,\n             index: &mut index,\n             parent_stab: None,\n+            parent_const_stab: None,\n             parent_depr: None,\n             in_trait_impl: false,\n         };"}, {"sha": "194929fa2871784c4e0d84500c651abfccaa7422", "filename": "src/test/ui/rfc-2632-const-trait-impl/assoc-type.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,28 @@\n+// ignore-test\n+\n+// FIXME: This test should fail since, within a const impl of `Foo`, the bound on `Foo::Bar` should\n+// require a const impl of `Add` for the associated type.\n+\n+#![allow(incomplete_features)]\n+#![feature(const_trait_impl)]\n+#![feature(const_fn)]\n+\n+struct NonConstAdd(i32);\n+\n+impl std::ops::Add for NonConstAdd {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        NonConstAdd(self.0 + rhs.0)\n+    }\n+}\n+\n+trait Foo {\n+    type Bar: std::ops::Add;\n+}\n+\n+impl const Foo for NonConstAdd {\n+    type Bar = NonConstAdd;\n+}\n+\n+fn main() {}"}, {"sha": "8e6ef12810c2ccddc0091b3cfabd19b20448df4d", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-const-trait-method-fail.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,30 @@\n+#![allow(incomplete_features)]\n+#![feature(const_trait_impl)]\n+#![feature(const_fn)]\n+\n+pub trait Plus {\n+    fn plus(self, rhs: Self) -> Self;\n+}\n+\n+impl const Plus for i32 {\n+    fn plus(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Plus for u32 {\n+    fn plus(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+pub const fn add_i32(a: i32, b: i32) -> i32 {\n+    a.plus(b) // ok\n+}\n+\n+pub const fn add_u32(a: u32, b: u32) -> u32 {\n+    a.plus(b)\n+    //~^ ERROR calls in constant functions are limited to constant functions\n+}\n+\n+fn main() {}"}, {"sha": "0c320d54c766d9b1222d368d9d221b3b5e3d632c", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-const-trait-method-fail.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,9 @@\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/call-const-trait-method-fail.rs:26:5\n+   |\n+LL |     a.plus(b)\n+   |     ^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "6a2112ea554903c46d9acf086338e2c84f7fc4c7", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-const-trait-method-pass.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,41 @@\n+// run-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(const_trait_impl)]\n+#![feature(const_fn)]\n+\n+struct Int(i32);\n+\n+impl const std::ops::Add for Int {\n+    type Output = Int;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Int(self.0.plus(rhs.0))\n+    }\n+}\n+\n+impl const PartialEq for Int {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.0 == rhs.0\n+    }\n+}\n+\n+pub trait Plus {\n+    fn plus(self, rhs: Self) -> Self;\n+}\n+\n+impl const Plus for i32 {\n+    fn plus(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+pub const fn add_i32(a: i32, b: i32) -> i32 {\n+    a.plus(b)\n+}\n+\n+const ADD_INT: Int = Int(1i32) + Int(2i32);\n+\n+fn main() {\n+    assert!(ADD_INT == Int(3i32));\n+}"}, {"sha": "e148ad9a0ee14d217381b80a355a2bbec35615a6", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-and-non-const-impl.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,33 @@\n+#![allow(incomplete_features)]\n+#![feature(const_trait_impl)]\n+\n+pub struct Int(i32);\n+\n+impl const std::ops::Add for i32 {\n+    //~^ ERROR conflicting implementations of trait\n+    //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl std::ops::Add for Int {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Int(self.0 + rhs.0)\n+    }\n+}\n+\n+impl const std::ops::Add for Int {\n+    //~^ ERROR conflicting implementations of trait\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Int(self.0 + rhs.0)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b57472d9595f9da068573eb34505f9f786cc7df9", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-and-non-const-impl.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,34 @@\n+error[E0119]: conflicting implementations of trait `std::ops::Add` for type `i32`:\n+  --> $DIR/const-and-non-const-impl.rs:6:1\n+   |\n+LL | impl const std::ops::Add for i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: conflicting implementation in crate `core`:\n+           - impl std::ops::Add for i32;\n+\n+error[E0119]: conflicting implementations of trait `std::ops::Add` for type `Int`:\n+  --> $DIR/const-and-non-const-impl.rs:24:1\n+   |\n+LL | impl std::ops::Add for Int {\n+   | -------------------------- first implementation here\n+...\n+LL | impl const std::ops::Add for Int {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Int`\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/const-and-non-const-impl.rs:6:1\n+   |\n+LL | impl const std::ops::Add for i32 {\n+   | ^^^^^^^^^^^-------------^^^^^---\n+   | |          |                 |\n+   | |          |                 `i32` is not defined in the current crate\n+   | |          `i32` is not defined in the current crate\n+   | impl doesn't use only types from inside the current crate\n+   |\n+   = note: define and implement a trait or new type instead\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0117, E0119.\n+For more information about an error, try `rustc --explain E0117`."}, {"sha": "3278f35bad2b227df7076f0d734798c9f004fcc9", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-check-fns-in-const-impl.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,16 @@\n+#![allow(incomplete_features)]\n+#![feature(const_trait_impl)]\n+\n+struct S;\n+trait T {\n+    fn foo();\n+}\n+\n+fn non_const() {}\n+\n+impl const T for S {\n+    fn foo() { non_const() }\n+    //~^ ERROR can only call other `const fn`\n+}\n+\n+fn main() {}"}, {"sha": "7fe3a9fd8522cf4cd4ace5fecf173b7c6a04e2a7", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-check-fns-in-const-impl.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,12 @@\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const non_const` is not stable as `const fn`\n+  --> $DIR/const-check-fns-in-const-impl.rs:12:16\n+   |\n+LL |     fn foo() { non_const() }\n+   |                ^^^^^^^^^^^\n+   |\n+   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "d1ab99e33e99254d62b174e84c8364b28d997367", "filename": "src/test/ui/rfc-2632-const-trait-impl/feature-gate.gated.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.gated.stderr?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -1,10 +1,8 @@\n-error: const trait impls are not yet implemented\n-  --> $DIR/feature-gate.rs:9:1\n+error: fatal error triggered by #[rustc_error]\n+  --> $DIR/feature-gate.rs:14:1\n    |\n-LL | impl const T for S {}\n-   | ^^^^^-----^^^^^^^^^^^\n-   |      |\n-   |      const because of this\n+LL | fn main() {}\n+   | ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d9772431941d373ab5bab07cad3741c6203971e4", "filename": "src/test/ui/rfc-2632-const-trait-impl/feature-gate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -3,11 +3,12 @@\n \n #![cfg_attr(gated, feature(const_trait_impl))]\n #![allow(incomplete_features)]\n+#![feature(rustc_attrs)]\n \n struct S;\n trait T {}\n impl const T for S {}\n //[stock]~^ ERROR const trait impls are experimental\n-//[stock,gated]~^^ ERROR const trait impls are not yet implemented\n \n-fn main() {}\n+#[rustc_error]\n+fn main() {} //[gated]~ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "724090e49cd415ed8e3d2e0ea502eb159a7e67e1", "filename": "src/test/ui/rfc-2632-const-trait-impl/feature-gate.stock.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.stock.stderr?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -1,20 +1,12 @@\n error[E0658]: const trait impls are experimental\n-  --> $DIR/feature-gate.rs:9:6\n+  --> $DIR/feature-gate.rs:10:6\n    |\n LL | impl const T for S {}\n    |      ^^^^^\n    |\n    = note: see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\n    = help: add `#![feature(const_trait_impl)]` to the crate attributes to enable\n \n-error: const trait impls are not yet implemented\n-  --> $DIR/feature-gate.rs:9:1\n-   |\n-LL | impl const T for S {}\n-   | ^^^^^-----^^^^^^^^^^^\n-   |      |\n-   |      const because of this\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "7829ffe2a38d9e1f0678d64d54046d301a9c0b3c", "filename": "src/test/ui/rfc-2632-const-trait-impl/generic-bound.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,32 @@\n+// run-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(const_trait_impl)]\n+#![feature(const_fn)]\n+\n+use std::marker::PhantomData;\n+\n+struct S<T>(PhantomData<T>);\n+\n+impl<T> Copy for S<T> {}\n+impl<T> Clone for S<T> {\n+    fn clone(&self) -> Self {\n+        S(PhantomData)\n+    }\n+}\n+\n+impl<T> const std::ops::Add for S<T> {\n+    type Output = Self;\n+\n+    fn add(self, _: Self) -> Self {\n+        S(std::marker::PhantomData)\n+    }\n+}\n+\n+const fn twice<T: std::ops::Add>(arg: S<T>) -> S<T> {\n+    arg + arg\n+}\n+\n+fn main() {\n+    let _ = twice(S(PhantomData::<i32>));\n+}"}, {"sha": "04123a532bd9faaf386bab563e5a96e022b1bd87", "filename": "src/test/ui/rfc-2632-const-trait-impl/inherent-impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -8,10 +8,8 @@ trait T {}\n \n impl const S {}\n //~^ ERROR inherent impls cannot be `const`\n-//~| ERROR const trait impls are not yet implemented\n \n impl const T {}\n //~^ ERROR inherent impls cannot be `const`\n-//~| ERROR const trait impls are not yet implemented\n \n fn main() {}"}, {"sha": "3ea58a3728a5dc3d2cabd73e76b4852baf6aa3da", "filename": "src/test/ui/rfc-2632-const-trait-impl/inherent-impl.stderr", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -9,7 +9,7 @@ LL | impl const S {}\n    = note: only trait implementations may be annotated with `const`\n \n error: inherent impls cannot be `const`\n-  --> $DIR/inherent-impl.rs:13:1\n+  --> $DIR/inherent-impl.rs:12:1\n    |\n LL | impl const T {}\n    | ^^^^^-----^^^^^\n@@ -18,21 +18,5 @@ LL | impl const T {}\n    |\n    = note: only trait implementations may be annotated with `const`\n \n-error: const trait impls are not yet implemented\n-  --> $DIR/inherent-impl.rs:9:1\n-   |\n-LL | impl const S {}\n-   | ^^^^^-----^^^^^\n-   |      |\n-   |      const because of this\n-\n-error: const trait impls are not yet implemented\n-  --> $DIR/inherent-impl.rs:13:1\n-   |\n-LL | impl const T {}\n-   | ^^^^^-----^^^^^\n-   |      |\n-   |      const because of this\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "03a6fb51503b50c31048dca48cbb6a913353fb91", "filename": "src/test/ui/rfc-2632-const-trait-impl/stability.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.rs?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,43 @@\n+#![allow(incomplete_features)]\n+#![feature(allow_internal_unstable)]\n+#![feature(const_add)]\n+#![feature(const_trait_impl)]\n+#![feature(staged_api)]\n+\n+pub struct Int(i32);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl const std::ops::Sub for Int {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        //~^ ERROR trait methods cannot be stable const fn\n+        Int(self.0 - rhs.0)\n+    }\n+}\n+\n+#[rustc_const_unstable(feature = \"const_add\", issue = \"none\")]\n+impl const std::ops::Add for Int {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Int(self.0 + rhs.0)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub const fn foo() -> Int {\n+    Int(1i32) + Int(2i32)\n+    //~^ ERROR can only call other `const fn` within a `const fn`\n+}\n+\n+// ok\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"bar\", issue = \"none\")]\n+pub const fn bar() -> Int {\n+    Int(1i32) + Int(2i32)\n+}\n+\n+fn main() {}"}, {"sha": "1ecff62955b99b98f2677cc1cb90897bba9b8e8b", "filename": "src/test/ui/rfc-2632-const-trait-impl/stability.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af388b25050bca26710be7e4030e17bf6d8d2f7/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstability.stderr?ref=6af388b25050bca26710be7e4030e17bf6d8d2f7", "patch": "@@ -0,0 +1,24 @@\n+error[E0723]: trait methods cannot be stable const fn\n+  --> $DIR/stability.rs:14:5\n+   |\n+LL | /     fn sub(self, rhs: Self) -> Self {\n+LL | |\n+LL | |         Int(self.0 - rhs.0)\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const <Int as std::ops::Add>::add` is not stable as `const fn`\n+  --> $DIR/stability.rs:32:5\n+   |\n+LL |     Int(1i32) + Int(2i32)\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0723`."}]}