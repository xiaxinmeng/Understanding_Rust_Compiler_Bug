{"sha": "89e1db3d6ce37946afd7115dfcce510261537a85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZTFkYjNkNmNlMzc5NDZhZmQ3MTE1ZGZjY2U1MTAyNjE1MzdhODU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-06T01:34:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-10T23:13:13Z"}, "message": "libstd: Change `atomically` to use RAII.", "tree": {"sha": "4ae3327b50138f2f416165a99576372676c22643", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ae3327b50138f2f416165a99576372676c22643"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89e1db3d6ce37946afd7115dfcce510261537a85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89e1db3d6ce37946afd7115dfcce510261537a85", "html_url": "https://github.com/rust-lang/rust/commit/89e1db3d6ce37946afd7115dfcce510261537a85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89e1db3d6ce37946afd7115dfcce510261537a85/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bd80f74505a3eb7c44753c69cbe253ff566d5c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd80f74505a3eb7c44753c69cbe253ff566d5c1", "html_url": "https://github.com/rust-lang/rust/commit/6bd80f74505a3eb7c44753c69cbe253ff566d5c1"}], "stats": {"total": 132, "additions": 78, "deletions": 54}, "files": [{"sha": "2b1e7865a735fe899102237848e2512d86a79075", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89e1db3d6ce37946afd7115dfcce510261537a85/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e1db3d6ce37946afd7115dfcce510261537a85/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=89e1db3d6ce37946afd7115dfcce510261537a85", "patch": "@@ -565,7 +565,7 @@ impl<'self, T: Send> SelectPortInner<T> for &'self Port<T> {\n impl<'self, T: Send> SelectPort<T> for &'self Port<T> { }\n \n pub struct SharedChan<T> {\n-    // Just like Chan, but a shared AtomicOption instead of Cell\n+    // Just like Chan, but a shared AtomicOption\n     priv next: UnsafeArc<AtomicOption<StreamChanOne<T>>>\n }\n \n@@ -716,7 +716,6 @@ mod test {\n     use super::*;\n     use option::*;\n     use rt::test::*;\n-    use cell::Cell;\n     use num::Times;\n     use rt::util;\n \n@@ -1113,7 +1112,7 @@ mod test {\n \n     #[test]\n     fn send_deferred() {\n-        use unstable::sync::atomically;\n+        use unstable::sync::atomic;\n \n         // Tests no-rescheduling of send_deferred on all types of channels.\n         do run_in_newsched_task {\n@@ -1129,15 +1128,12 @@ mod test {\n             let p_mp = mp.clone();\n             do spawntask { p_mp.recv(); }\n \n-            let cs = Cell::new((cone, cstream, cshared, mp));\n             unsafe {\n-                atomically(|| {\n-                    let (cone, cstream, cshared, mp) = cs.take();\n-                    cone.send_deferred(());\n-                    cstream.send_deferred(());\n-                    cshared.send_deferred(());\n-                    mp.send_deferred(());\n-                })\n+                let _guard = atomic();\n+                cone.send_deferred(());\n+                cstream.send_deferred(());\n+                cshared.send_deferred(());\n+                mp.send_deferred(());\n             }\n         }\n     }"}, {"sha": "42a696eaf7ea7a88883857853b8a23a8e3737428", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/89e1db3d6ce37946afd7115dfcce510261537a85/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e1db3d6ce37946afd7115dfcce510261537a85/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=89e1db3d6ce37946afd7115dfcce510261537a85", "patch": "@@ -140,7 +140,7 @@ pub mod dl {\n     use path;\n     use ptr;\n     use str;\n-    use unstable::sync::atomically;\n+    use unstable::sync::atomic;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -158,25 +158,24 @@ pub mod dl {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n-            // sequence. `atomically` asserts that we don't do anything that\n+            // sequence. `atomic` asserts that we don't do anything that\n             // would cause this task to be descheduled, which could deadlock\n             // the scheduler if it happens while the lock is held.\n             // FIXME #9105 use a Rust mutex instead of C++ mutexes.\n-            atomically(|| {\n-                lock.lock();\n-                let _old_error = dlerror();\n-\n-                let result = f();\n-\n-                let last_error = dlerror();\n-                let ret = if ptr::null() == last_error {\n-                    Ok(result)\n-                } else {\n-                    Err(str::raw::from_c_str(last_error))\n-                };\n-                lock.unlock();\n-                ret\n-            })\n+            let _guard = atomic();\n+            lock.lock();\n+            let _old_error = dlerror();\n+\n+            let result = f();\n+\n+            let last_error = dlerror();\n+            let ret = if ptr::null() == last_error {\n+                Ok(result)\n+            } else {\n+                Err(str::raw::from_c_str(last_error))\n+            };\n+            lock.unlock();\n+            ret\n         }\n     }\n \n@@ -209,7 +208,7 @@ pub mod dl {\n     use libc;\n     use path;\n     use ptr;\n-    use unstable::sync::atomically;\n+    use unstable::sync::atomic;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -226,18 +225,17 @@ pub mod dl {\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         unsafe {\n-            atomically(|| {\n-                SetLastError(0);\n+            let _guard = atomic();\n+            SetLastError(0);\n \n-                let result = f();\n+            let result = f();\n \n-                let error = os::errno();\n-                if 0 == error {\n-                    Ok(result)\n-                } else {\n-                    Err(format!(\"Error code {}\", error))\n-                }\n-            })\n+            let error = os::errno();\n+            if 0 == error {\n+                Ok(result)\n+            } else {\n+                Err(format!(\"Error code {}\", error))\n+            }\n         }\n     }\n "}, {"sha": "2dd5515bdbc8e75ada0505975f7a0b721b7ed5d4", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/89e1db3d6ce37946afd7115dfcce510261537a85/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89e1db3d6ce37946afd7115dfcce510261537a85/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=89e1db3d6ce37946afd7115dfcce510261537a85", "patch": "@@ -14,7 +14,6 @@ use ptr;\n use option::{Option,Some,None};\n use task;\n use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,Relaxed,SeqCst};\n-use unstable::finally::Finally;\n use unstable::mutex::Mutex;\n use ops::Drop;\n use clone::Clone;\n@@ -295,17 +294,44 @@ impl<T> Drop for UnsafeArc<T>{\n \n /****************************************************************************/\n \n+pub struct AtomicGuard {\n+    on: bool,\n+}\n+\n+impl Drop for AtomicGuard {\n+    fn drop(&mut self) {\n+        use rt::task::{Task, GreenTask, SchedTask};\n+        use rt::local::Local;\n+\n+        if self.on {\n+            unsafe {\n+                let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n+                match task_opt {\n+                    Some(t) => {\n+                        match (*t).task_type {\n+                            GreenTask(_) => (*t).death.allow_deschedule(),\n+                            SchedTask => {}\n+                        }\n+                    }\n+                    None => {}\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /**\n- * Enables a runtime assertion that no operation in the argument closure shall\n- * use scheduler operations (deschedule, recv, spawn, etc). This is for use with\n- * pthread mutexes, which may block the entire scheduler thread, rather than\n- * just one task, and is hence prone to deadlocks if mixed with descheduling.\n+ * Enables a runtime assertion that no operation while the returned guard is\n+ * live uses scheduler operations (deschedule, recv, spawn, etc). This is for\n+ * use with pthread mutexes, which may block the entire scheduler thread,\n+ * rather than just one task, and is hence prone to deadlocks if mixed with\n+ * descheduling.\n  *\n  * NOTE: THIS DOES NOT PROVIDE LOCKING, or any sort of critical-section\n  * synchronization whatsoever. It only makes sense to use for CPU-local issues.\n  */\n // FIXME(#8140) should not be pub\n-pub unsafe fn atomically<U>(f: || -> U) -> U {\n+pub unsafe fn atomic() -> AtomicGuard {\n     use rt::task::{Task, GreenTask, SchedTask};\n     use rt::local::Local;\n \n@@ -314,15 +340,19 @@ pub unsafe fn atomically<U>(f: || -> U) -> U {\n         Some(t) => {\n             match (*t).task_type {\n                 GreenTask(_) => {\n-                    (|| {\n-                        (*t).death.inhibit_deschedule();\n-                        f()\n-                    }).finally(|| (*t).death.allow_deschedule())\n+                    (*t).death.inhibit_deschedule();\n+                    return AtomicGuard {\n+                        on: true,\n+                    };\n                 }\n-                SchedTask => f()\n+                SchedTask => {}\n             }\n         }\n-        None => f()\n+        None => {}\n+    }\n+\n+    AtomicGuard {\n+        on: false,\n     }\n }\n \n@@ -481,7 +511,7 @@ mod tests {\n     use comm;\n     use option::*;\n     use prelude::*;\n-    use super::{Exclusive, UnsafeArc, atomically};\n+    use super::{Exclusive, UnsafeArc, atomic};\n     use task;\n     use mem::size_of;\n \n@@ -493,10 +523,10 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_atomically() {\n+    fn test_atomic() {\n         // NB. The whole runtime will abort on an 'atomic-sleep' violation,\n         // so we can't really test for the converse behaviour.\n-        unsafe { atomically(|| ()) } task::deschedule(); // oughtn't fail\n+        unsafe { let _ = atomic(); } // oughtn't fail\n     }\n \n     #[test]"}]}