{"sha": "91d799eab0d7f6784fb4366182b5007cf055519d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZDc5OWVhYjBkN2Y2Nzg0ZmI0MzY2MTgyYjUwMDdjZjA1NTUxOWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-19T21:57:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-25T16:33:15Z"}, "message": "msvc: Implement runtime support for unwinding\n\nNow that LLVM has been updated, the only remaining roadblock to implementing\nunwinding for MSVC is to fill out the runtime support in `std::rt::unwind::seh`.\nThis commit does precisely that, fixing up some other bits and pieces along the\nway:\n\n* The `seh` unwinding module now uses `RaiseException` to initiate a panic.\n* The `rust_try.ll` file was rewritten for MSVC (as it's quite different) and is\n  located at `rust_try_msvc_64.ll`, only included on MSVC builds for now.\n* The personality function for all landing pads generated by LLVM is hard-wired\n  to `__C_specific_handler` instead of the standard `rust_eh_personality` lang\n  item. This is required to get LLVM to emit SEH unwinding information instead\n  of DWARF unwinding information. This also means that on MSVC the\n  `rust_eh_personality` function is entirely unused (but is defined as it's a\n  lang item).\n\nMore details about how panicking works on SEH can be found in the\n`rust_try_msvc_64.ll` or `seh.rs` files, but I'm always open to adding more\ncomments!\n\nA key aspect of this PR is missing, however, which is that **unwinding is still\nturned off by default for MSVC**. There is a [bug in llvm][llvm-bug] which\ncauses optimizations to inline enough landing pads that LLVM chokes. If the\ncompiler is optimized at `-O1` (where inlining isn't enabled) then it can\nbootstrap with unwinding enabled, but when optimized at `-O2` (inlining is\nenabled) then it hits a fatal LLVM error.\n\n[llvm-bug]: https://llvm.org/bugs/show_bug.cgi?id=23884", "tree": {"sha": "55e7a492bc92ed35982c7065767e04dfb59ddca3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55e7a492bc92ed35982c7065767e04dfb59ddca3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91d799eab0d7f6784fb4366182b5007cf055519d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91d799eab0d7f6784fb4366182b5007cf055519d", "html_url": "https://github.com/rust-lang/rust/commit/91d799eab0d7f6784fb4366182b5007cf055519d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91d799eab0d7f6784fb4366182b5007cf055519d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ec520a531b544079690f8178a7660421e8a713a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec520a531b544079690f8178a7660421e8a713a", "html_url": "https://github.com/rust-lang/rust/commit/1ec520a531b544079690f8178a7660421e8a713a"}], "stats": {"total": 242, "additions": 227, "deletions": 15}, "files": [{"sha": "6513cf107726a63735b2cda209ab98793fbe250f", "filename": "mk/rt.mk", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91d799eab0d7f6784fb4366182b5007cf055519d/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/91d799eab0d7f6784fb4366182b5007cf055519d/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=91d799eab0d7f6784fb4366182b5007cf055519d", "patch": "@@ -53,9 +53,12 @@ NATIVE_DEPS_hoedown_$(1) := hoedown/src/autolink.c \\\n NATIVE_DEPS_miniz_$(1) = miniz.c\n NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n \t\t\trust_android_dummy.c\n-NATIVE_DEPS_rustrt_native_$(1) := \\\n-\t\t\trust_try.ll \\\n-\t\t\tarch/$$(HOST_$(1))/record_sp.S\n+NATIVE_DEPS_rustrt_native_$(1) := arch/$$(HOST_$(1))/record_sp.S\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+NATIVE_DEPS_rustrt_native_$(1) += rust_try_msvc_64.ll\n+else\n+NATIVE_DEPS_rustrt_native_$(1) += rust_try.ll\n+endif\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c\n NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n "}, {"sha": "b7e761fa4b991d62c603e6e60c98dac72f63a13d", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91d799eab0d7f6784fb4366182b5007cf055519d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d799eab0d7f6784fb4366182b5007cf055519d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=91d799eab0d7f6784fb4366182b5007cf055519d", "patch": "@@ -856,18 +856,36 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         // this function, so we just codegen a generic reference to it. We don't\n         // specify any of the types for the function, we just make it a symbol\n         // that LLVM can later use.\n+        //\n+        // Note that MSVC is a little special here in that we don't use the\n+        // `eh_personality` lang item at all. Currently LLVM has support for\n+        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n+        // *name of the personality function* to decide what kind of unwind side\n+        // tables/landing pads to emit. It looks like Dwarf is used by default,\n+        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n+        // an \"exception\", but for MSVC we want to force SEH. This means that we\n+        // can't actually have the personality function be our standard\n+        // `rust_eh_personality` function, but rather we wired it up to the\n+        // CRT's custom `__C_specific_handler` personality funciton, which\n+        // forces LLVM to consider landing pads as \"landing pads for SEH\".\n+        let target = &self.ccx.sess().target.target;\n         let llpersonality = match pad_bcx.tcx().lang_items.eh_personality() {\n-            Some(def_id) => {\n+            Some(def_id) if !target.options.is_like_msvc => {\n                 callee::trans_fn_ref(pad_bcx.ccx(), def_id, ExprId(0),\n                                      pad_bcx.fcx.param_substs).val\n             }\n-            None => {\n+            _ => {\n                 let mut personality = self.ccx.eh_personality().borrow_mut();\n                 match *personality {\n                     Some(llpersonality) => llpersonality,\n                     None => {\n+                        let name = if target.options.is_like_msvc {\n+                            \"__C_specific_handler\"\n+                        } else {\n+                            \"rust_eh_personality\"\n+                        };\n                         let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n-                        let f = declare::declare_cfn(self.ccx, \"rust_eh_personality\", fty,\n+                        let f = declare::declare_cfn(self.ccx, name, fty,\n                                                      self.ccx.tcx().types.i32);\n                         *personality = Some(f);\n                         f"}, {"sha": "632ab4f8e253750c23028b7d71fe2f1dabfa5ad4", "filename": "src/libstd/rt/unwind/seh.rs", "status": "modified", "additions": 122, "deletions": 9, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/91d799eab0d7f6784fb4366182b5007cf055519d/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d799eab0d7f6784fb4366182b5007cf055519d/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fseh.rs?ref=91d799eab0d7f6784fb4366182b5007cf055519d", "patch": "@@ -8,23 +8,136 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n+//!\n+//! On Windows (currently only on MSVC), the default exception handling\n+//! mechanism is Structured Exception Handling (SEH). This is quite different\n+//! than Dwarf-based exception handling (e.g. what other unix platforms use) in\n+//! terms of compiler internals, so LLVM is required to have a good deal of\n+//! extra support for SEH. Currently this support is somewhat lacking, so what's\n+//! here is the bare bones of SEH support.\n+//!\n+//! In a nutshell, what happens here is:\n+//!\n+//! 1. The `panic` function calls the standard Windows function `RaiseException`\n+//!    with a Rust-specific code, triggering the unwinding process.\n+//! 2. All landing pads generated by the compiler (just \"cleanup\" landing pads)\n+//!    use the personality function `__C_specific_handler`, a function in the\n+//!    CRT, and the unwinding code in Windows will use this personality function\n+//!    to execute all cleanup code on the stack.\n+//! 3. Eventually the \"catch\" code in `rust_try` (located in\n+//!    src/rt/rust_try_msvc_64.ll) is executed, which will ensure that the\n+//!    exception being caught is indeed a Rust exception, returning control back\n+//!    into Rust.\n+//!\n+//! Some specific differences from the gcc-based exception handling are:\n+//!\n+//! * Rust has no custom personality function, it is instead *always*\n+//!   __C_specific_handler, so the filtering is done in a C++-like manner\n+//!   instead of in the personality function itself. Note that the specific\n+//!   syntax for this (found in the rust_try_msvc_64.ll) is taken from an LLVM\n+//!   test case for SEH.\n+//! * We've got some data to transmit across the unwinding boundary,\n+//!   specifically a `Box<Any + Send + 'static>`. In Dwarf-based unwinding this\n+//!   data is part of the payload of the exception, but I have not currently\n+//!   figured out how to do this with LLVM's bindings. Judging by some comments\n+//!   in the LLVM test cases this may not even be possible currently with LLVM,\n+//!   so this is just abandoned entirely. Instead the data is stored in a\n+//!   thread-local in `panic` and retrieved during `cleanup`.\n+//!\n+//! So given all that, the bindings here are pretty small,\n+\n+#![allow(bad_style)]\n+\n use prelude::v1::*;\n \n use any::Any;\n-use intrinsics;\n-use libc::c_void;\n+use libc::{c_ulong, DWORD, c_void};\n+use sys_common::thread_local::StaticKey;\n+\n+//                        0x R U S T\n+const RUST_PANIC: DWORD = 0x52555354;\n+static PANIC_DATA: StaticKey = StaticKey::new(None);\n+\n+// This function is provided by kernel32.dll\n+extern \"system\" {\n+    fn RaiseException(dwExceptionCode: DWORD,\n+                      dwExceptionFlags: DWORD,\n+                      nNumberOfArguments: DWORD,\n+                      lpArguments: *const c_ulong);\n+}\n+\n+#[repr(C)]\n+pub struct EXCEPTION_POINTERS {\n+    ExceptionRecord: *mut EXCEPTION_RECORD,\n+    ContextRecord: *mut CONTEXT,\n+}\n+\n+enum CONTEXT {}\n+\n+#[repr(C)]\n+struct EXCEPTION_RECORD {\n+    ExceptionCode: DWORD,\n+    ExceptionFlags: DWORD,\n+    ExceptionRecord: *mut _EXCEPTION_RECORD,\n+    ExceptionAddress: *mut c_void,\n+    NumberParameters: DWORD,\n+    ExceptionInformation: [*mut c_ulong; EXCEPTION_MAXIMUM_PARAMETERS],\n+}\n \n-pub unsafe fn panic(_data: Box<Any + Send + 'static>) -> ! {\n-    intrinsics::abort();\n+enum _EXCEPTION_RECORD {}\n+\n+const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n+\n+pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n+    // See module docs above for an explanation of why `data` is stored in a\n+    // thread local instead of being passed as an argument to the\n+    // `RaiseException` function (which can in theory carry along arbitrary\n+    // data).\n+    let exception = Box::new(data);\n+    rtassert!(PANIC_DATA.get().is_null());\n+    PANIC_DATA.set(Box::into_raw(exception) as *mut u8);\n+\n+    RaiseException(RUST_PANIC, 0, 0, 0 as *const _);\n+    rtabort!(\"could not unwind stack\");\n }\n \n-pub unsafe fn cleanup(_ptr: *mut c_void) -> Box<Any + Send + 'static> {\n-    intrinsics::abort();\n+pub unsafe fn cleanup(ptr: *mut c_void) -> Box<Any + Send + 'static> {\n+    // The `ptr` here actually corresponds to the code of the exception, and our\n+    // real data is stored in our thread local.\n+    rtassert!(ptr as DWORD == RUST_PANIC);\n+\n+    let data = PANIC_DATA.get() as *mut Box<Any + Send + 'static>;\n+    PANIC_DATA.set(0 as *mut u8);\n+    rtassert!(!data.is_null());\n+\n+    *Box::from_raw(data)\n }\n \n+// This is required by the compiler to exist (e.g. it's a lang item), but it's\n+// never actually called by the compiler because __C_specific_handler is the\n+// personality function that is always used. Hence this is just an aborting\n+// stub.\n #[lang = \"eh_personality\"]\n-#[no_mangle]\n-pub extern fn rust_eh_personality() {}\n+fn rust_eh_personality() {\n+    unsafe { ::intrinsics::abort() }\n+}\n \n+// This is a function referenced from `rust_try_msvc_64.ll` which is used to\n+// filter the exceptions being caught by that function.\n+//\n+// In theory local variables can be accessed through the `rbp` parameter of this\n+// function, but a comment in an LLVM test case indicates that this is not\n+// implemented in LLVM, so this is just an idempotent function which doesn't\n+// ferry along any other information.\n+//\n+// This function just takes a look at the current EXCEPTION_RECORD being thrown\n+// to ensure that it's code is RUST_PANIC, which was set by the call to\n+// `RaiseException` above in the `panic` function.\n #[no_mangle]\n-pub extern fn rust_eh_personality_catch() {}\n+pub extern fn __rust_try_filter(eh_ptrs: *mut EXCEPTION_POINTERS,\n+                                _rbp: *mut c_void) -> i32 {\n+    unsafe {\n+        ((*(*eh_ptrs).ExceptionRecord).ExceptionCode == RUST_PANIC) as i32\n+    }\n+}"}, {"sha": "bda136d84780b98d503b03a2826a1cf34fc083d9", "filename": "src/rt/rust_try_msvc_64.ll", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/91d799eab0d7f6784fb4366182b5007cf055519d/src%2Frt%2Frust_try_msvc_64.ll", "raw_url": "https://github.com/rust-lang/rust/raw/91d799eab0d7f6784fb4366182b5007cf055519d/src%2Frt%2Frust_try_msvc_64.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try_msvc_64.ll?ref=91d799eab0d7f6784fb4366182b5007cf055519d", "patch": "@@ -0,0 +1,78 @@\n+; Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+; file at the top-level directory of this distribution and at\n+; http://rust-lang.org/COPYRIGHT.\n+;\n+; Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+; http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+; <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+; option. This file may not be copied, modified, or distributed\n+; except according to those terms.\n+\n+; 64-bit MSVC's definition of the `rust_try` function. This function can't be\n+; defined in Rust as it's a \"try-catch\" block that's not expressible in Rust's\n+; syntax, so we're using LLVM to produce an object file with the associated\n+; handler.\n+;\n+; To use the correct system implementation details, this file is separate from\n+; the standard rust_try.ll as we need specifically use the __C_specific_handler\n+; personality function or otherwise LLVM doesn't emit SEH handling tables.\n+; There's also a few fiddly bits about SEH right now in LLVM that require us to\n+; structure this a fairly particular way!\n+;\n+; See also: src/libstd/rt/unwind/seh.rs\n+\n+define i8* @rust_try(void (i8*)* %f, i8* %env) {\n+    invoke void %f(i8* %env)\n+        to label %normal\n+        unwind label %catch\n+\n+normal:\n+    ret i8* null\n+\n+; Here's where most of the magic happens, this is the only landing pad in rust\n+; tagged with \"catch\" to indicate that we're catching an exception. The other\n+; catch handlers in rust_try.ll just catch *all* exceptions, but that's because\n+; most exceptions are already filtered out by their personality function.\n+;\n+; For MSVC we're just using a standard personality function that we can't\n+; customize, so we need to do the exception filtering ourselves, and this is\n+; currently performed by the `__rust_try_filter` function. This function,\n+; specified in the landingpad instruction, will be invoked by Windows SEH\n+; routines and will return whether the exception in question can be caught (aka\n+; the Rust runtime is the one that threw the exception).\n+;\n+; To get this to compile (currently LLVM segfaults if it's not in this\n+; particular structure), when the landingpad is executing we test to make sure\n+; that the ID of the exception being thrown is indeed the one that we were\n+; expecting. If it's not, we resume the exception, and otherwise we return the\n+; pointer that we got\n+;\n+; Full disclosure: It's not clear to me what this `llvm.eh.typeid` stuff is\n+; doing *other* then just allowing LLVM to compile this file without\n+; segfaulting. I would expect the entire landing pad to just be:\n+;\n+;     %vals = landingpad ...\n+;     %ehptr = extractvalue { i8*, i32 } %vals, 0\n+;     ret i8* %ehptr\n+;\n+; but apparently LLVM chokes on this, so we do the more complicated thing to\n+; placate it.\n+catch:\n+    %vals = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @__C_specific_handler to i8*)\n+        catch i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*)\n+    %ehptr = extractvalue { i8*, i32 } %vals, 0\n+    %sel = extractvalue { i8*, i32 } %vals, 1\n+    %filter_sel = call i32 @llvm.eh.typeid.for(i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*))\n+    %is_filter = icmp eq i32 %sel, %filter_sel\n+    br i1 %is_filter, label %catch-return, label %catch-resume\n+\n+catch-return:\n+    ret i8* %ehptr\n+\n+catch-resume:\n+    resume { i8*, i32 } %vals\n+}\n+\n+declare i32 @__C_specific_handler(...)\n+declare i32 @__rust_try_filter(i8*, i8*)\n+declare i32 @llvm.eh.typeid.for(i8*) readnone nounwind"}]}