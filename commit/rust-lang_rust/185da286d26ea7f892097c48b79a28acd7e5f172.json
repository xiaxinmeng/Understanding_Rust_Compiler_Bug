{"sha": "185da286d26ea7f892097c48b79a28acd7e5f172", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NWRhMjg2ZDI2ZWE3Zjg5MjA5N2M0OGI3OWEyOGFjZDdlNWYxNzI=", "commit": {"author": {"name": "ivan770", "email": "leshenko.ivan770@gmail.com", "date": "2021-02-13T11:07:47Z"}, "committer": {"name": "ivan770", "email": "leshenko.ivan770@gmail.com", "date": "2021-02-13T11:07:47Z"}, "message": "Moved CodeLens to ide crate", "tree": {"sha": "925bdb4be5377544323989476b0d30e091287ea5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/925bdb4be5377544323989476b0d30e091287ea5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/185da286d26ea7f892097c48b79a28acd7e5f172", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEcPkYW+t8+2SKgl5T2MS9WuTZzE0FAmAnswMACgkQ2MS9WuTZ\nzE3ovAf5AU+9d/j1AivfoNTsQkSZBf5PUbYQ7FxbaJPltOa942lnvHUENG0/Du69\nuQbRA6xVOop4IGLcpwxtoTGkVMg/cXJpfYhml5i4T++nfjdeggpNhXW3tai/zgmi\nkxczFOub0jDhU31B6ULdrbYQhGamMMWRc+o+vnl0gLJZR+cQ9sD/+NzBfHu5uqU+\nGVvLy/mFjlHlPed0k0rFzu2AsdDcUT27SWySJpdfY/MBP68Pp8wsiX5+jO88gF3F\n6zveZ79XeX2sKPb3lr7bS2o9XN6Upg+9Gxm9zCWjqfsTdmYrRG3aX53IhXnFOtuJ\nuAWMTZIqgPl4mVq3ZesuUy94e6FBog==\n=EGwS\n-----END PGP SIGNATURE-----", "payload": "tree 925bdb4be5377544323989476b0d30e091287ea5\nparent 935830d05bcf5f0c648e636dcbc8848a201467c0\nauthor ivan770 <leshenko.ivan770@gmail.com> 1613214467 +0200\ncommitter ivan770 <leshenko.ivan770@gmail.com> 1613214467 +0200\n\nMoved CodeLens to ide crate\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/185da286d26ea7f892097c48b79a28acd7e5f172", "html_url": "https://github.com/rust-lang/rust/commit/185da286d26ea7f892097c48b79a28acd7e5f172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/185da286d26ea7f892097c48b79a28acd7e5f172/comments", "author": {"login": "ivan770", "id": 14003886, "node_id": "MDQ6VXNlcjE0MDAzODg2", "avatar_url": "https://avatars.githubusercontent.com/u/14003886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivan770", "html_url": "https://github.com/ivan770", "followers_url": "https://api.github.com/users/ivan770/followers", "following_url": "https://api.github.com/users/ivan770/following{/other_user}", "gists_url": "https://api.github.com/users/ivan770/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivan770/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivan770/subscriptions", "organizations_url": "https://api.github.com/users/ivan770/orgs", "repos_url": "https://api.github.com/users/ivan770/repos", "events_url": "https://api.github.com/users/ivan770/events{/privacy}", "received_events_url": "https://api.github.com/users/ivan770/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ivan770", "id": 14003886, "node_id": "MDQ6VXNlcjE0MDAzODg2", "avatar_url": "https://avatars.githubusercontent.com/u/14003886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivan770", "html_url": "https://github.com/ivan770", "followers_url": "https://api.github.com/users/ivan770/followers", "following_url": "https://api.github.com/users/ivan770/following{/other_user}", "gists_url": "https://api.github.com/users/ivan770/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivan770/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivan770/subscriptions", "organizations_url": "https://api.github.com/users/ivan770/orgs", "repos_url": "https://api.github.com/users/ivan770/repos", "events_url": "https://api.github.com/users/ivan770/events{/privacy}", "received_events_url": "https://api.github.com/users/ivan770/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "935830d05bcf5f0c648e636dcbc8848a201467c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/935830d05bcf5f0c648e636dcbc8848a201467c0", "html_url": "https://github.com/rust-lang/rust/commit/935830d05bcf5f0c648e636dcbc8848a201467c0"}], "stats": {"total": 590, "additions": 388, "deletions": 202}, "files": [{"sha": "6d54b6b572a5e9100a1f423c99670b883b153b32", "filename": "crates/ide/src/annotations.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=185da286d26ea7f892097c48b79a28acd7e5f172", "patch": "@@ -0,0 +1,142 @@\n+use hir::Semantics;\n+use ide_db::{\n+    base_db::{FileId, FilePosition, FileRange, SourceDatabase},\n+    RootDatabase, SymbolKind,\n+};\n+use syntax::TextRange;\n+\n+use crate::{\n+    file_structure::file_structure,\n+    fn_references::find_all_methods,\n+    goto_implementation::goto_implementation,\n+    references::find_all_refs,\n+    runnables::{runnables, Runnable},\n+    NavigationTarget, RunnableKind,\n+};\n+\n+// Feature: Annotations\n+//\n+// Provides user with annotations above items for looking up references or impl blocks\n+// and running/debugging binaries.\n+pub struct Annotation {\n+    pub range: TextRange,\n+    pub kind: AnnotationKind,\n+}\n+\n+pub enum AnnotationKind {\n+    Runnable { debug: bool, runnable: Runnable },\n+    HasImpls { position: FilePosition, data: Option<Vec<NavigationTarget>> },\n+    HasReferences { position: FilePosition, data: Option<Vec<FileRange>> },\n+}\n+\n+pub struct AnnotationConfig {\n+    pub binary_target: bool,\n+    pub annotate_runnables: bool,\n+    pub annotate_impls: bool,\n+    pub annotate_references: bool,\n+    pub annotate_method_references: bool,\n+    pub run: bool,\n+    pub debug: bool,\n+}\n+\n+pub(crate) fn annotations(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    config: AnnotationConfig,\n+) -> Vec<Annotation> {\n+    let mut annotations = Vec::default();\n+\n+    if config.annotate_runnables {\n+        for runnable in runnables(db, file_id) {\n+            if !matches!(runnable.kind, RunnableKind::Bin) || !config.binary_target {\n+                continue;\n+            }\n+\n+            let action = runnable.action();\n+            let range = runnable.nav.full_range;\n+\n+            if config.run {\n+                annotations.push(Annotation {\n+                    range,\n+                    // FIXME: This one allocates without reason if run is enabled, but debug is disabled\n+                    kind: AnnotationKind::Runnable { debug: false, runnable: runnable.clone() },\n+                });\n+            }\n+\n+            if action.debugee && config.debug {\n+                annotations.push(Annotation {\n+                    range,\n+                    kind: AnnotationKind::Runnable { debug: true, runnable },\n+                });\n+            }\n+        }\n+    }\n+\n+    file_structure(&db.parse(file_id).tree())\n+        .into_iter()\n+        .filter(|node| {\n+            matches!(\n+                node.kind,\n+                SymbolKind::Trait\n+                    | SymbolKind::Struct\n+                    | SymbolKind::Enum\n+                    | SymbolKind::Union\n+                    | SymbolKind::Const\n+            )\n+        })\n+        .for_each(|node| {\n+            if config.annotate_impls && node.kind != SymbolKind::Const {\n+                annotations.push(Annotation {\n+                    range: node.node_range,\n+                    kind: AnnotationKind::HasImpls {\n+                        position: FilePosition { file_id, offset: node.navigation_range.start() },\n+                        data: None,\n+                    },\n+                });\n+            }\n+\n+            if config.annotate_references {\n+                annotations.push(Annotation {\n+                    range: node.node_range,\n+                    kind: AnnotationKind::HasReferences {\n+                        position: FilePosition { file_id, offset: node.navigation_range.start() },\n+                        data: None,\n+                    },\n+                });\n+            }\n+        });\n+\n+    if config.annotate_method_references {\n+        annotations.extend(find_all_methods(db, file_id).into_iter().map(|method| Annotation {\n+            range: method.range,\n+            kind: AnnotationKind::HasReferences {\n+                position: FilePosition { file_id, offset: method.range.start() },\n+                data: None,\n+            },\n+        }));\n+    }\n+\n+    annotations\n+}\n+\n+pub(crate) fn resolve_annotation(db: &RootDatabase, mut annotation: Annotation) -> Annotation {\n+    match annotation.kind {\n+        AnnotationKind::HasImpls { position, ref mut data } => {\n+            *data = goto_implementation(db, position).map(|range| range.info);\n+        }\n+        AnnotationKind::HasReferences { position, ref mut data } => {\n+            *data = find_all_refs(&Semantics::new(db), position, None).map(|result| {\n+                result\n+                    .references\n+                    .into_iter()\n+                    .map(|(_, access)| access.into_iter())\n+                    .flatten()\n+                    .map(|(range, _)| FileRange { file_id: position.file_id, range })\n+                    .collect()\n+            });\n+        }\n+        _ => {}\n+    };\n+\n+    annotation\n+}"}, {"sha": "89e7bef7de8d796222612fbd133415e2943d067e", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=185da286d26ea7f892097c48b79a28acd7e5f172", "patch": "@@ -22,6 +22,7 @@ mod markup;\n mod prime_caches;\n mod display;\n \n+mod annotations;\n mod call_hierarchy;\n mod diagnostics;\n mod expand_macro;\n@@ -63,6 +64,7 @@ use syntax::SourceFile;\n use crate::display::ToNav;\n \n pub use crate::{\n+    annotations::{Annotation, AnnotationConfig, AnnotationKind},\n     call_hierarchy::CallItem,\n     diagnostics::{Diagnostic, DiagnosticsConfig, Fix, Severity},\n     display::navigation_target::NavigationTarget,\n@@ -555,6 +557,18 @@ impl Analysis {\n         })\n     }\n \n+    pub fn annotations(\n+        &self,\n+        file_id: FileId,\n+        config: AnnotationConfig,\n+    ) -> Cancelable<Vec<Annotation>> {\n+        self.with_db(|db| annotations::annotations(db, file_id, config))\n+    }\n+\n+    pub fn resolve_annotation(&self, annotation: Annotation) -> Cancelable<Annotation> {\n+        self.with_db(|db| annotations::resolve_annotation(db, annotation))\n+    }\n+\n     /// Performs an operation on that may be Canceled.\n     fn with_db<F, T>(&self, f: F) -> Cancelable<T>\n     where"}, {"sha": "6676eebf40106bcb4759d2ed2ca7201dc2aaa71a", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=185da286d26ea7f892097c48b79a28acd7e5f172", "patch": "@@ -1,12 +1,12 @@\n //! Conversion lsp_types types to rust-analyzer specific ones.\n use std::convert::TryFrom;\n \n-use ide::{AssistKind, LineCol, LineIndex};\n+use ide::{Annotation, AnnotationKind, AssistKind, LineCol, LineIndex};\n use ide_db::base_db::{FileId, FilePosition, FileRange};\n use syntax::{TextRange, TextSize};\n use vfs::AbsPathBuf;\n \n-use crate::{global_state::GlobalStateSnapshot, Result};\n+use crate::{from_json, global_state::GlobalStateSnapshot, lsp_ext, Result};\n \n pub(crate) fn abs_path(url: &lsp_types::Url) -> Result<AbsPathBuf> {\n     let path = url.to_file_path().map_err(|()| \"url is not a file\")?;\n@@ -66,3 +66,39 @@ pub(crate) fn assist_kind(kind: lsp_types::CodeActionKind) -> Option<AssistKind>\n \n     Some(assist_kind)\n }\n+\n+pub(crate) fn annotation(\n+    world: &GlobalStateSnapshot,\n+    code_lens: lsp_types::CodeLens,\n+) -> Result<Annotation> {\n+    let data = code_lens.data.unwrap();\n+    let resolve = from_json::<lsp_ext::CodeLensResolveData>(\"CodeLensResolveData\", data)?;\n+\n+    match resolve {\n+        lsp_ext::CodeLensResolveData::Impls(params) => {\n+            let file_id =\n+                world.url_to_file_id(&params.text_document_position_params.text_document.uri)?;\n+            let line_index = world.analysis.file_line_index(file_id)?;\n+\n+            Ok(Annotation {\n+                range: text_range(&line_index, code_lens.range),\n+                kind: AnnotationKind::HasImpls {\n+                    position: file_position(world, params.text_document_position_params)?,\n+                    data: None,\n+                },\n+            })\n+        }\n+        lsp_ext::CodeLensResolveData::References(params) => {\n+            let file_id = world.url_to_file_id(&params.text_document.uri)?;\n+            let line_index = world.analysis.file_line_index(file_id)?;\n+\n+            Ok(Annotation {\n+                range: text_range(&line_index, code_lens.range),\n+                kind: AnnotationKind::HasReferences {\n+                    position: file_position(world, params)?,\n+                    data: None,\n+                },\n+            })\n+        }\n+    }\n+}"}, {"sha": "b051c8f6c52acd541c68ad79306ccd6fd613882e", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 33, "deletions": 195, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=185da286d26ea7f892097c48b79a28acd7e5f172", "patch": "@@ -9,8 +9,9 @@ use std::{\n };\n \n use ide::{\n-    FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, LineIndex, NavigationTarget,\n-    Query, RangeInfo, Runnable, RunnableKind, SearchScope, SourceChange, TextEdit,\n+    AnnotationConfig, FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, LineIndex,\n+    NavigationTarget, Query, RangeInfo, Runnable, RunnableKind, SearchScope, SourceChange,\n+    TextEdit,\n };\n use ide_db::SymbolKind;\n use itertools::Itertools;\n@@ -35,7 +36,7 @@ use crate::{\n     cargo_target_spec::CargoTargetSpec,\n     config::RustfmtConfig,\n     diff::diff,\n-    from_json, from_proto,\n+    from_proto,\n     global_state::{GlobalState, GlobalStateSnapshot},\n     line_endings::LineEndings,\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n@@ -1078,177 +1079,51 @@ pub(crate) fn handle_code_lens(\n     params: lsp_types::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n     let _p = profile::span(\"handle_code_lens\");\n-    let mut lenses: Vec<CodeLens> = Default::default();\n \n     let lens_config = snap.config.lens();\n     if lens_config.none() {\n         // early return before any db query!\n-        return Ok(Some(lenses));\n+        return Ok(Some(Vec::default()));\n     }\n \n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n-    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n-\n-    if lens_config.runnable() {\n-        // Gather runnables\n-        for runnable in snap.analysis.runnables(file_id)? {\n-            if should_skip_target(&runnable, cargo_spec.as_ref()) {\n-                continue;\n-            }\n-\n-            let action = runnable.action();\n-            let range = to_proto::range(&line_index, runnable.nav.full_range);\n-            let r = to_proto::runnable(&snap, file_id, runnable)?;\n-            if lens_config.run {\n-                let lens = CodeLens {\n-                    range,\n-                    command: Some(run_single_command(&r, action.run_title)),\n-                    data: None,\n-                };\n-                lenses.push(lens);\n-            }\n+    let cargo_target_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n \n-            if action.debugee && lens_config.debug {\n-                let debug_lens =\n-                    CodeLens { range, command: Some(debug_single_command(&r)), data: None };\n-                lenses.push(debug_lens);\n-            }\n-        }\n-    }\n-\n-    if lens_config.implementations || lens_config.refs {\n-        snap.analysis\n-            .file_structure(file_id)?\n-            .into_iter()\n-            .filter(|it| {\n-                matches!(\n-                    it.kind,\n-                    SymbolKind::Trait | SymbolKind::Struct | SymbolKind::Enum | SymbolKind::Union\n-                )\n-            })\n-            .for_each(|it| {\n-                let range = to_proto::range(&line_index, it.node_range);\n-                let position = to_proto::position(&line_index, it.navigation_range.start());\n-                let doc_pos = lsp_types::TextDocumentPositionParams::new(\n-                    params.text_document.clone(),\n-                    position,\n-                );\n-                let goto_params = lsp_types::request::GotoImplementationParams {\n-                    text_document_position_params: doc_pos.clone(),\n-                    work_done_progress_params: Default::default(),\n-                    partial_result_params: Default::default(),\n-                };\n-\n-                if lens_config.implementations {\n-                    lenses.push(CodeLens {\n-                        range,\n-                        command: None,\n-                        data: Some(to_value(CodeLensResolveData::Impls(goto_params)).unwrap()),\n-                    })\n-                }\n-\n-                if lens_config.refs {\n-                    lenses.push(CodeLens {\n-                        range,\n-                        command: None,\n-                        data: Some(to_value(CodeLensResolveData::References(doc_pos)).unwrap()),\n+    let lenses = snap\n+        .analysis\n+        .annotations(\n+            file_id,\n+            AnnotationConfig {\n+                binary_target: cargo_target_spec\n+                    .map(|spec| {\n+                        matches!(\n+                            spec.target_kind,\n+                            TargetKind::Bin | TargetKind::Example | TargetKind::Test\n+                        )\n                     })\n-                }\n-            });\n-    }\n-\n-    if lens_config.method_refs {\n-        lenses.extend(snap.analysis.find_all_methods(file_id)?.into_iter().map(|it| {\n-            let range = to_proto::range(&line_index, it.range);\n-            let position = to_proto::position(&line_index, it.range.start());\n-            let lens_params =\n-                lsp_types::TextDocumentPositionParams::new(params.text_document.clone(), position);\n-\n-            CodeLens {\n-                range,\n-                command: None,\n-                data: Some(to_value(CodeLensResolveData::References(lens_params)).unwrap()),\n-            }\n-        }));\n-    }\n+                    .unwrap_or(false),\n+                annotate_runnables: lens_config.runnable(),\n+                annotate_impls: lens_config.implementations,\n+                annotate_references: lens_config.refs,\n+                annotate_method_references: lens_config.method_refs,\n+                run: lens_config.run,\n+                debug: lens_config.debug,\n+            },\n+        )?\n+        .into_iter()\n+        .map(|annotation| to_proto::code_lens(&snap, annotation).unwrap())\n+        .collect();\n \n     Ok(Some(lenses))\n }\n \n-#[derive(Debug, Serialize, Deserialize)]\n-#[serde(rename_all = \"camelCase\")]\n-enum CodeLensResolveData {\n-    Impls(lsp_types::request::GotoImplementationParams),\n-    References(lsp_types::TextDocumentPositionParams),\n-}\n-\n pub(crate) fn handle_code_lens_resolve(\n     snap: GlobalStateSnapshot,\n     code_lens: CodeLens,\n ) -> Result<CodeLens> {\n-    let _p = profile::span(\"handle_code_lens_resolve\");\n-    let data = code_lens.data.unwrap();\n-    let resolve = from_json::<Option<CodeLensResolveData>>(\"CodeLensResolveData\", data)?;\n-    match resolve {\n-        Some(CodeLensResolveData::Impls(lens_params)) => {\n-            let locations: Vec<Location> =\n-                match handle_goto_implementation(snap, lens_params.clone())? {\n-                    Some(lsp_types::GotoDefinitionResponse::Scalar(loc)) => vec![loc],\n-                    Some(lsp_types::GotoDefinitionResponse::Array(locs)) => locs,\n-                    Some(lsp_types::GotoDefinitionResponse::Link(links)) => links\n-                        .into_iter()\n-                        .map(|link| Location::new(link.target_uri, link.target_selection_range))\n-                        .collect(),\n-                    _ => vec![],\n-                };\n-\n-            let title = implementation_title(locations.len());\n-            let cmd = show_references_command(\n-                title,\n-                &lens_params.text_document_position_params.text_document.uri,\n-                code_lens.range.start,\n-                locations,\n-            );\n-            Ok(CodeLens { range: code_lens.range, command: Some(cmd), data: None })\n-        }\n-        Some(CodeLensResolveData::References(doc_position)) => {\n-            let position = from_proto::file_position(&snap, doc_position.clone())?;\n-            let locations = snap\n-                .analysis\n-                .find_all_refs(position, None)\n-                .unwrap_or(None)\n-                .map(|r| {\n-                    r.references\n-                        .into_iter()\n-                        .flat_map(|(file_id, ranges)| {\n-                            ranges.into_iter().map(move |(range, _)| FileRange { file_id, range })\n-                        })\n-                        .filter_map(|frange| to_proto::location(&snap, frange).ok())\n-                        .collect_vec()\n-                })\n-                .unwrap_or_default();\n-\n-            let title = reference_title(locations.len());\n-            let cmd = if locations.is_empty() {\n-                Command { title, command: \"\".into(), arguments: None }\n-            } else {\n-                show_references_command(\n-                    title,\n-                    &doc_position.text_document.uri,\n-                    code_lens.range.start,\n-                    locations,\n-                )\n-            };\n+    let annotation = from_proto::annotation(&snap, code_lens)?;\n \n-            Ok(CodeLens { range: code_lens.range, command: Some(cmd), data: None })\n-        }\n-        None => Ok(CodeLens {\n-            range: code_lens.range,\n-            command: Some(Command { title: \"Error\".into(), ..Default::default() }),\n-            data: None,\n-        }),\n-    }\n+    Ok(to_proto::code_lens(&snap, snap.analysis.resolve_annotation(annotation)?)?)\n }\n \n pub(crate) fn handle_document_highlight(\n@@ -1547,43 +1422,6 @@ pub(crate) fn handle_open_cargo_toml(\n     Ok(Some(res))\n }\n \n-fn implementation_title(count: usize) -> String {\n-    if count == 1 {\n-        \"1 implementation\".into()\n-    } else {\n-        format!(\"{} implementations\", count)\n-    }\n-}\n-\n-fn reference_title(count: usize) -> String {\n-    if count == 1 {\n-        \"1 reference\".into()\n-    } else {\n-        format!(\"{} references\", count)\n-    }\n-}\n-\n-fn show_references_command(\n-    title: String,\n-    uri: &lsp_types::Url,\n-    position: lsp_types::Position,\n-    locations: Vec<lsp_types::Location>,\n-) -> Command {\n-    // We cannot use the 'editor.action.showReferences' command directly\n-    // because that command requires vscode types which we convert in the handler\n-    // on the client side.\n-\n-    Command {\n-        title,\n-        command: \"rust-analyzer.showReferences\".into(),\n-        arguments: Some(vec![\n-            to_value(uri).unwrap(),\n-            to_value(position).unwrap(),\n-            to_value(locations).unwrap(),\n-        ]),\n-    }\n-}\n-\n fn run_single_command(runnable: &lsp_ext::Runnable, title: &str) -> Command {\n     Command {\n         title: title.to_string(),\n@@ -1635,8 +1473,8 @@ fn show_impl_command_link(\n                 .into_iter()\n                 .filter_map(|nav| to_proto::location_from_nav(snap, nav).ok())\n                 .collect();\n-            let title = implementation_title(locations.len());\n-            let command = show_references_command(title, &uri, position, locations);\n+            let title = to_proto::implementation_title(locations.len());\n+            let command = to_proto::show_references_command(title, &uri, position, locations);\n \n             return Some(lsp_ext::CommandLinkGroup {\n                 commands: vec![to_command_link(command, \"Go to implementations\".into())],"}, {"sha": "a1ad855c32f11a594aacb763e783443c9f7a4f15", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=185da286d26ea7f892097c48b79a28acd7e5f172", "patch": "@@ -377,3 +377,11 @@ impl Request for OpenCargoToml {\n pub struct OpenCargoTomlParams {\n     pub text_document: TextDocumentIdentifier,\n }\n+\n+/// Information about CodeLens, that is to be resolved.\n+#[derive(Debug, Serialize, Deserialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) enum CodeLensResolveData {\n+    Impls(lsp_types::request::GotoImplementationParams),\n+    References(lsp_types::TextDocumentPositionParams),\n+}"}, {"sha": "29fac96fb0e9e8465deb89126e399c8c4c015d27", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 141, "deletions": 4, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185da286d26ea7f892097c48b79a28acd7e5f172/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=185da286d26ea7f892097c48b79a28acd7e5f172", "patch": "@@ -5,13 +5,15 @@ use std::{\n };\n \n use ide::{\n-    Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind, Documentation, FileId,\n-    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HlMod, HlPunct, HlRange, HlTag, Indel,\n-    InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup, NavigationTarget, ReferenceAccess,\n-    RenameError, Runnable, Severity, SourceChange, TextEdit, TextRange, TextSize,\n+    Annotation, AnnotationKind, Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind,\n+    Documentation, FileId, FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HlMod, HlPunct,\n+    HlRange, HlTag, Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup,\n+    NavigationTarget, ReferenceAccess, RenameError, Runnable, Severity, SourceChange, TextEdit,\n+    TextRange, TextSize,\n };\n use ide_db::SymbolKind;\n use itertools::Itertools;\n+use serde_json::to_value;\n \n use crate::{\n     cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot,\n@@ -863,6 +865,141 @@ pub(crate) fn runnable(\n     })\n }\n \n+pub(crate) fn code_lens(\n+    snap: &GlobalStateSnapshot,\n+    annotation: Annotation,\n+) -> Result<lsp_types::CodeLens> {\n+    match annotation.kind {\n+        AnnotationKind::Runnable { debug, runnable: run } => {\n+            let line_index = snap.analysis.file_line_index(run.nav.file_id)?;\n+            let annotation_range = range(&line_index, annotation.range);\n+\n+            let action = run.action();\n+            let r = runnable(&snap, run.nav.file_id, run)?;\n+\n+            let command = if debug {\n+                lsp_types::Command {\n+                    title: action.run_title.to_string(),\n+                    command: \"rust-analyzer.runSingle\".into(),\n+                    arguments: Some(vec![to_value(r).unwrap()]),\n+                }\n+            } else {\n+                lsp_types::Command {\n+                    title: \"Debug\".into(),\n+                    command: \"rust-analyzer.debugSingle\".into(),\n+                    arguments: Some(vec![to_value(r).unwrap()]),\n+                }\n+            };\n+\n+            Ok(lsp_types::CodeLens { range: annotation_range, command: Some(command), data: None })\n+        }\n+        AnnotationKind::HasImpls { position: file_position, data } => {\n+            let line_index = snap.analysis.file_line_index(file_position.file_id)?;\n+            let annotation_range = range(&line_index, annotation.range);\n+            let url = url(snap, file_position.file_id);\n+\n+            let position = position(&line_index, file_position.offset);\n+\n+            let id = lsp_types::TextDocumentIdentifier { uri: url.clone() };\n+\n+            let doc_pos = lsp_types::TextDocumentPositionParams::new(id.clone(), position);\n+\n+            let goto_params = lsp_types::request::GotoImplementationParams {\n+                text_document_position_params: doc_pos.clone(),\n+                work_done_progress_params: Default::default(),\n+                partial_result_params: Default::default(),\n+            };\n+\n+            let command = data.map(|ranges| {\n+                let locations: Vec<lsp_types::Location> = ranges\n+                    .into_iter()\n+                    .filter_map(|target| {\n+                        location(\n+                            snap,\n+                            FileRange { file_id: target.file_id, range: target.full_range },\n+                        )\n+                        .ok()\n+                    })\n+                    .collect();\n+\n+                show_references_command(\n+                    implementation_title(locations.len()),\n+                    &url,\n+                    position,\n+                    locations,\n+                )\n+            });\n+\n+            Ok(lsp_types::CodeLens {\n+                range: annotation_range,\n+                command,\n+                data: Some(to_value(lsp_ext::CodeLensResolveData::Impls(goto_params)).unwrap()),\n+            })\n+        }\n+        AnnotationKind::HasReferences { position: file_position, data } => {\n+            let line_index = snap.analysis.file_line_index(file_position.file_id)?;\n+            let annotation_range = range(&line_index, annotation.range);\n+            let url = url(snap, file_position.file_id);\n+\n+            let position = position(&line_index, file_position.offset);\n+\n+            let id = lsp_types::TextDocumentIdentifier { uri: url.clone() };\n+\n+            let doc_pos = lsp_types::TextDocumentPositionParams::new(id, position);\n+\n+            let command = data.map(|ranges| {\n+                let locations: Vec<lsp_types::Location> =\n+                    ranges.into_iter().filter_map(|range| location(snap, range).ok()).collect();\n+\n+                show_references_command(reference_title(locations.len()), &url, position, locations)\n+            });\n+\n+            Ok(lsp_types::CodeLens {\n+                range: annotation_range,\n+                command,\n+                data: Some(to_value(lsp_ext::CodeLensResolveData::References(doc_pos)).unwrap()),\n+            })\n+        }\n+    }\n+}\n+\n+pub(crate) fn show_references_command(\n+    title: String,\n+    uri: &lsp_types::Url,\n+    position: lsp_types::Position,\n+    locations: Vec<lsp_types::Location>,\n+) -> lsp_types::Command {\n+    // We cannot use the 'editor.action.showReferences' command directly\n+    // because that command requires vscode types which we convert in the handler\n+    // on the client side.\n+\n+    lsp_types::Command {\n+        title,\n+        command: \"rust-analyzer.showReferences\".into(),\n+        arguments: Some(vec![\n+            to_value(uri).unwrap(),\n+            to_value(position).unwrap(),\n+            to_value(locations).unwrap(),\n+        ]),\n+    }\n+}\n+\n+pub(crate) fn implementation_title(count: usize) -> String {\n+    if count == 1 {\n+        \"1 implementation\".into()\n+    } else {\n+        format!(\"{} implementations\", count)\n+    }\n+}\n+\n+pub(crate) fn reference_title(count: usize) -> String {\n+    if count == 1 {\n+        \"1 reference\".into()\n+    } else {\n+        format!(\"{} references\", count)\n+    }\n+}\n+\n pub(crate) fn markup_content(markup: Markup) -> lsp_types::MarkupContent {\n     let value = crate::markdown::format_docs(markup.as_str());\n     lsp_types::MarkupContent { kind: lsp_types::MarkupKind::Markdown, value }"}, {"sha": "51aa795170edccd9385e7472ff6d87bf0c341fd6", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/185da286d26ea7f892097c48b79a28acd7e5f172/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/185da286d26ea7f892097c48b79a28acd7e5f172/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=185da286d26ea7f892097c48b79a28acd7e5f172", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: 8f1ae8530f69e3a3\n+lsp_ext.rs hash: 34aec6bfeaeb97a\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this  issue:\n@@ -573,3 +573,14 @@ This request is sent from client to server to open the current project's Cargo.t\n ```\n \n `experimental/openCargoToml` returns a single `Link` to the start of the `[package]` keyword.\n+\n+## CodeLens resolve request\n+\n+This request is sent from client to server to resolve previously provided CodeLens.\n+\n+As an alternative to `any` type in `data` field of `CodeLens`, you may use `CodeLensResolveData`:\n+```typescript\n+interface CodeLensResolveData {\n+    data: (DefinitionParams | TextDocumentPositionParams),\n+}\n+```"}]}