{"sha": "6e350bd9990c600ed68ebac13ff8a89cade98fb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMzUwYmQ5OTkwYzYwMGVkNjhlYmFjMTNmZjhhODljYWRlOThmYjI=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-11-03T09:55:50Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-11-03T09:55:50Z"}, "message": "librustc_lexer: Simplify \"raw_double_quoted_string\" method", "tree": {"sha": "ce7dc8cfebaa09ff4e0c6ce9e9cd252a00e87abe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce7dc8cfebaa09ff4e0c6ce9e9cd252a00e87abe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e350bd9990c600ed68ebac13ff8a89cade98fb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e350bd9990c600ed68ebac13ff8a89cade98fb2", "html_url": "https://github.com/rust-lang/rust/commit/6e350bd9990c600ed68ebac13ff8a89cade98fb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e350bd9990c600ed68ebac13ff8a89cade98fb2/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6f722d79cf01f8305288235d82e13a6863711f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6f722d79cf01f8305288235d82e13a6863711f5", "html_url": "https://github.com/rust-lang/rust/commit/d6f722d79cf01f8305288235d82e13a6863711f5"}], "stats": {"total": 59, "additions": 34, "deletions": 25}, "files": [{"sha": "f66e6641abc24e321a5c655e3842a7391b37b9e6", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6e350bd9990c600ed68ebac13ff8a89cade98fb2/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e350bd9990c600ed68ebac13ff8a89cade98fb2/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=6e350bd9990c600ed68ebac13ff8a89cade98fb2", "patch": "@@ -600,36 +600,45 @@ impl Cursor<'_> {\n     /// (amount of the '#' symbols, raw string started, raw string terminated)\n     fn raw_double_quoted_string(&mut self) -> (usize, bool, bool) {\n         debug_assert!(self.prev() == 'r');\n+        let mut started: bool = false;\n+        let mut finished: bool = false;\n+\n         // Count opening '#' symbols.\n-        let n_hashes = {\n-            let mut acc: usize = 0;\n-            loop {\n-                match self.bump() {\n-                    Some('#') => acc += 1,\n-                    Some('\"') => break acc,\n-                    None | Some(_) => return (acc, false, false),\n-                }\n+        let n_hashes = self.eat_while(|c| c == '#');\n+\n+        // Check that string is started.\n+        match self.bump() {\n+            Some('\"') => started = true,\n+            _ => return (n_hashes, started, finished),\n+        }\n+\n+        // Skip the string contents and on each '#' character met, check if this is\n+        // a raw string termination.\n+        while !finished {\n+            self.eat_while(|c| c != '\"');\n+\n+            if self.is_eof() {\n+                return (n_hashes, started, finished);\n             }\n-        };\n \n-        // Skip the string itself and check that amount of closing '#'\n-        // symbols is equal to the amount of opening ones.\n-        loop {\n-            match self.bump() {\n-                Some('\"') => {\n-                    let mut acc = n_hashes;\n-                    while self.nth_char(0) == '#' && acc > 0 {\n-                        self.bump();\n-                        acc -= 1;\n-                    }\n-                    if acc == 0 {\n-                        return (n_hashes, true, true);\n-                    }\n+            // Eat closing double quote.\n+            self.bump();\n+\n+            // Check that amount of closing '#' symbols\n+            // is equal to the amount of opening ones.\n+            let mut hashes_left = n_hashes;\n+            let is_closing_hash = |c| {\n+                if c == '#' && hashes_left != 0 {\n+                    hashes_left -= 1;\n+                    true\n+                } else {\n+                    false\n                 }\n-                Some(_) => (),\n-                None => return (n_hashes, true, false),\n-            }\n+            };\n+            finished = self.eat_while(is_closing_hash) == n_hashes;\n         }\n+\n+        (n_hashes, started, finished)\n     }\n \n     fn eat_decimal_digits(&mut self) -> bool {"}]}