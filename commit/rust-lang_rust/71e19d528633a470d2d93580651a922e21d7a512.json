{"sha": "71e19d528633a470d2d93580651a922e21d7a512", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZTE5ZDUyODYzM2E0NzBkMmQ5MzU4MDY1MWE5MjJlMjFkN2E1MTI=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-08-12T02:16:00Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-08-12T04:53:54Z"}, "message": "librustc: Don't use an alloca per return if the function doesn't have nested returns.", "tree": {"sha": "1928a6eda5bf332a907ad16e3c79cf9e4a07f446", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1928a6eda5bf332a907ad16e3c79cf9e4a07f446"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71e19d528633a470d2d93580651a922e21d7a512", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71e19d528633a470d2d93580651a922e21d7a512", "html_url": "https://github.com/rust-lang/rust/commit/71e19d528633a470d2d93580651a922e21d7a512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71e19d528633a470d2d93580651a922e21d7a512/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ad97c042a1ae41652a0157d0ac148e6e90db6c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad97c042a1ae41652a0157d0ac148e6e90db6c2", "html_url": "https://github.com/rust-lang/rust/commit/0ad97c042a1ae41652a0157d0ac148e6e90db6c2"}], "stats": {"total": 184, "additions": 150, "deletions": 34}, "files": [{"sha": "0860f84dbef47a4375ab844e162ab7f061141090", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 121, "deletions": 15, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=71e19d528633a470d2d93580651a922e21d7a512", "patch": "@@ -1214,19 +1214,117 @@ pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n pub fn make_return_slot_pointer(fcx: &FunctionContext, output_type: ty::t) -> ValueRef {\n     let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n \n-    // Let's create the stack slot\n-    let slot = AllocaFcx(fcx, lloutputtype.ptr_to(), \"llretslotptr\");\n+    // We create an alloca to hold a pointer of type `output_type`\n+    // which will hold the pointer to the right alloca which has the\n+    // final ret value\n+    if fcx.needs_ret_allocas {\n+        // Let's create the stack slot\n+        let slot = AllocaFcx(fcx, lloutputtype.ptr_to(), \"llretslotptr\");\n \n-    // and if we're using an out pointer, then store that in our newly made slot\n-    if type_of::return_uses_outptr(fcx.ccx, output_type) {\n-        let outptr = get_param(fcx.llfn, 0);\n+        // and if we're using an out pointer, then store that in our newly made slot\n+        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n+            let outptr = get_param(fcx.llfn, 0);\n \n-        let b = fcx.ccx.builder();\n-        b.position_before(fcx.alloca_insert_pt.get().unwrap());\n-        b.store(outptr, slot);\n+            let b = fcx.ccx.builder();\n+            b.position_before(fcx.alloca_insert_pt.get().unwrap());\n+            b.store(outptr, slot);\n+        }\n+\n+        slot\n+\n+    // But if there are no nested returns, we skip the indirection and have a single\n+    // retslot\n+    } else {\n+        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n+            get_param(fcx.llfn, 0)\n+        } else {\n+            AllocaFcx(fcx, lloutputtype, \"sret_slot\")\n+        }\n     }\n+}\n \n-    slot\n+struct CheckForNestedReturnsVisitor {\n+    found: bool\n+}\n+\n+impl Visitor<bool> for CheckForNestedReturnsVisitor {\n+    fn visit_expr(&mut self, e: &ast::Expr, in_return: bool) {\n+        match e.node {\n+            ast::ExprRet(..) if in_return => {\n+                self.found = true;\n+                return;\n+            }\n+            ast::ExprRet(..) => visit::walk_expr(self, e, true),\n+            _ => visit::walk_expr(self, e, in_return)\n+        }\n+    }\n+}\n+\n+fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n+    match tcx.map.find(id) {\n+        Some(ast_map::NodeItem(i)) => {\n+            match i.node {\n+                ast::ItemFn(_, _, _, _, blk) => {\n+                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n+                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n+                    visit::walk_item(&mut explicit, &*i, false);\n+                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                    explicit.found || implicit.found\n+                }\n+                _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n+            }\n+        }\n+        Some(ast_map::NodeTraitMethod(trait_method)) => {\n+            match *trait_method {\n+                ast::Provided(m) => {\n+                    match m.node {\n+                        ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                            let mut explicit = CheckForNestedReturnsVisitor { found: false };\n+                            let mut implicit = CheckForNestedReturnsVisitor { found: false };\n+                            visit::walk_method_helper(&mut explicit, &*m, false);\n+                            visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                            explicit.found || implicit.found\n+                        }\n+                        ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n+                    }\n+                }\n+                ast::Required(_) => tcx.sess.bug(\"unexpected variant: required trait method in \\\n+                                                  has_nested_returns\")\n+            }\n+        }\n+        Some(ast_map::NodeMethod(m)) => {\n+            match m.node {\n+                ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n+                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n+                    visit::walk_method_helper(&mut explicit, &*m, false);\n+                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                    explicit.found || implicit.found\n+                }\n+                ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n+            }\n+        }\n+        Some(ast_map::NodeExpr(e)) => {\n+            match e.node {\n+                ast::ExprFnBlock(_, blk) | ast::ExprProc(_, blk) | ast::ExprUnboxedFn(_, blk) => {\n+                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n+                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n+                    visit::walk_expr(&mut explicit, &*e, false);\n+                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                    explicit.found || implicit.found\n+                }\n+                _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n+            }\n+        }\n+\n+        Some(ast_map::NodeVariant(..)) | Some(ast_map::NodeStructCtor(..)) => false,\n+\n+        // glue, shims, etc\n+        None if id == ast::DUMMY_NODE_ID => false,\n+\n+        _ => tcx.sess.bug(format!(\"unexpected variant in has_nested_returns: {}\",\n+                                  tcx.map.path_to_string(id)).as_slice())\n+    }\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1261,13 +1359,15 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n     let substd_output_type = output_type.substp(ccx.tcx(), param_substs);\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n+    let nested_returns = has_nested_returns(ccx.tcx(), id);\n \n     let mut fcx = FunctionContext {\n           llfn: llfndecl,\n           llenv: None,\n           llretslotptr: Cell::new(None),\n           alloca_insert_pt: Cell::new(None),\n           llreturn: Cell::new(None),\n+          needs_ret_allocas: nested_returns,\n           personality: Cell::new(None),\n           caller_expects_out_pointer: uses_outptr,\n           llargs: RefCell::new(NodeMap::new()),\n@@ -1540,11 +1640,16 @@ pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n \n // Builds the return block for a function.\n pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n-    if fcx.llretslotptr.get().is_none() {\n+    if fcx.llretslotptr.get().is_none() ||\n+       (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n         return RetVoid(ret_cx);\n     }\n \n-    let retslot = Load(ret_cx, fcx.llretslotptr.get().unwrap());\n+    let retslot = if fcx.needs_ret_allocas {\n+        Load(ret_cx, fcx.llretslotptr.get().unwrap())\n+    } else {\n+        fcx.llretslotptr.get().unwrap()\n+    };\n     let retptr = Value(retslot);\n     match retptr.get_dominating_store(ret_cx) {\n         // If there's only a single store to the ret slot, we can directly return\n@@ -1678,7 +1783,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     debuginfo::start_emitting_source_locations(&fcx);\n \n     let dest = match fcx.llretslotptr.get() {\n-        Some(_) => expr::SaveIn(alloca(bcx, type_of::type_of(bcx.ccx(), block_ty), \"iret_slot\")),\n+        Some(_) => expr::SaveIn(fcx.get_ret_slot(bcx, block_ty, \"iret_slot\")),\n         None => {\n             assert!(type_is_zero_size(bcx.ccx(), block_ty));\n             expr::Ignore\n@@ -1692,7 +1797,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     bcx = controlflow::trans_block(bcx, body, dest);\n \n     match dest {\n-        expr::SaveIn(slot) => {\n+        expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n             Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n         }\n         _ => {}\n@@ -1862,12 +1967,14 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n                           param_substs, None, &arena, TranslateItems);\n     let bcx = init_function(&fcx, false, result_ty);\n \n+    assert!(!fcx.needs_ret_allocas);\n+\n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n     if !type_is_zero_size(fcx.ccx, result_ty) {\n-        let dest = alloca(bcx, type_of::type_of(bcx.ccx(), result_ty), \"eret_slot\");\n+        let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n         let repr = adt::represent_type(ccx, result_ty);\n         for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n@@ -1878,7 +1985,6 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n             arg_datum.store_to(bcx, lldestptr);\n         }\n         adt::trans_set_discr(bcx, &*repr, dest, disr);\n-        Store(bcx, dest, fcx.llretslotptr.get().unwrap());\n     }\n \n     finish_fn(&fcx, bcx, result_ty);"}, {"sha": "8e6ff0cdb3e115e61e0fa1742975a1d0f23a420e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=71e19d528633a470d2d93580651a922e21d7a512", "patch": "@@ -334,7 +334,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n     let return_type = ty::ty_fn_ret(boxed_function_type);\n     let fcx = new_fn_ctxt(ccx,\n                           llfn,\n-                          -1,\n+                          ast::DUMMY_NODE_ID,\n                           false,\n                           return_type,\n                           &empty_param_substs,\n@@ -389,8 +389,9 @@ pub fn trans_unboxing_shim(bcx: &Block,\n     for i in range(1, arg_types.len()) {\n         llshimmedargs.push(get_param(fcx.llfn, fcx.arg_pos(i) as u32));\n     }\n+    assert!(!fcx.needs_ret_allocas);\n     let dest = match fcx.llretslotptr.get() {\n-        Some(_) => Some(expr::SaveIn(alloca(bcx, type_of::type_of(ccx, return_type), \"ret_slot\"))),\n+        Some(_) => Some(expr::SaveIn(fcx.get_ret_slot(bcx, return_type, \"ret_slot\"))),\n         None => None\n     };\n     bcx = trans_call_inner(bcx,\n@@ -404,12 +405,6 @@ pub fn trans_unboxing_shim(bcx: &Block,\n                            },\n                            ArgVals(llshimmedargs.as_slice()),\n                            dest).bcx;\n-    match dest {\n-        Some(expr::SaveIn(slot)) => {\n-            Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n-        }\n-        _ => {}\n-    }\n \n     bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n     finish_fn(&fcx, bcx, return_type);"}, {"sha": "eeff0609a56dd2658f2071958762a982d40b5a36", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=71e19d528633a470d2d93580651a922e21d7a512", "patch": "@@ -574,7 +574,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = param_substs::empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, -1, true, f.sig.output,\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, true, f.sig.output,\n                           &empty_param_substs, None, &arena, TranslateItems);\n     let bcx = init_function(&fcx, true, f.sig.output);\n \n@@ -583,8 +583,9 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n                                             .as_slice());\n     let mut llargs = Vec::new();\n     match fcx.llretslotptr.get() {\n-        Some(llretslotptr) => {\n-            llargs.push(Load(bcx, llretslotptr));\n+        Some(llretptr) => {\n+            assert!(!fcx.needs_ret_allocas);\n+            llargs.push(llretptr);\n         }\n         None => {}\n     }"}, {"sha": "5e46550eccba561191200c6d9c35f2fe8876c6af", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=71e19d528633a470d2d93580651a922e21d7a512", "patch": "@@ -21,11 +21,13 @@ use middle::def;\n use middle::lang_items::LangItem;\n use middle::subst;\n use middle::subst::Subst;\n+use middle::trans::base;\n use middle::trans::build;\n use middle::trans::cleanup;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n+use middle::trans::type_of;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n@@ -254,6 +256,11 @@ pub struct FunctionContext<'a> {\n     pub alloca_insert_pt: Cell<Option<ValueRef>>,\n     pub llreturn: Cell<Option<BasicBlockRef>>,\n \n+    // If the function has any nested return's, including something like:\n+    // fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n+    // we use a separate alloca for each return\n+    pub needs_ret_allocas: bool,\n+\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     pub personality: Cell<Option<ValueRef>>,\n@@ -345,6 +352,14 @@ impl<'a> FunctionContext<'a> {\n         self.llreturn.get().unwrap()\n     }\n \n+    pub fn get_ret_slot(&self, bcx: &Block, ty: ty::t, name: &str) -> ValueRef {\n+        if self.needs_ret_allocas {\n+            base::alloca_no_lifetime(bcx, type_of::type_of(bcx.ccx(), ty), name)\n+        } else {\n+            self.llretslotptr.get().unwrap()\n+        }\n+    }\n+\n     pub fn new_block(&'a self,\n                      is_lpad: bool,\n                      name: &str,"}, {"sha": "02a5f715ecb230e2132c08e5f2605ba2c54901c3", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=71e19d528633a470d2d93580651a922e21d7a512", "patch": "@@ -26,7 +26,6 @@ use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::meth;\n use middle::trans::type_::Type;\n-use middle::trans::type_of;\n use middle::ty;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n@@ -466,15 +465,15 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n     let dest = match (fcx.llretslotptr.get(), e) {\n         (Some(_), Some(e)) => {\n             let ret_ty = expr_ty(bcx, &*e);\n-            expr::SaveIn(alloca(bcx, type_of::type_of(bcx.ccx(), ret_ty), \"ret_slot\"))\n+            expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\"))\n         }\n         _ => expr::Ignore,\n     };\n     match e {\n         Some(x) => {\n             bcx = expr::trans_into(bcx, &*x, dest);\n             match dest {\n-                expr::SaveIn(slot) => {\n+                expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n                     Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n                 }\n                 _ => {}"}, {"sha": "1d016f6db265933472562f77c9c386164226b0a1", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=71e19d528633a470d2d93580651a922e21d7a512", "patch": "@@ -467,7 +467,7 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = param_substs::empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, -1, false, ty::mk_nil(),\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false, ty::mk_nil(),\n                           &empty_param_substs, None, &arena, TranslateItems);\n \n     let bcx = init_function(&fcx, false, ty::mk_nil());"}, {"sha": "e49d483e8d93d29b5608ae9f9369e25ce45b07b0", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e19d528633a470d2d93580651a922e21d7a512/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=71e19d528633a470d2d93580651a922e21d7a512", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                                                     sym.as_slice());\n                 let arena = TypedArena::new();\n                 let empty_param_substs = param_substs::empty();\n-                let fcx = new_fn_ctxt(ccx, llfdecl, -1, false,\n+                let fcx = new_fn_ctxt(ccx, llfdecl, ast::DUMMY_NODE_ID, false,\n                                       ty::mk_u64(), &empty_param_substs,\n                                       None, &arena, TranslateItems);\n                 let bcx = init_function(&fcx, false, ty::mk_u64());\n@@ -321,9 +321,9 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                 let arg = get_param(llfdecl, fcx.arg_pos(0u) as c_uint);\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, &*repr, arg, Some(Type::i64(ccx)));\n-                let ret_alloca = alloca(bcx, Type::i64(ccx), \"ret_slot\");\n-                Store(bcx, ret, ret_alloca);\n-                Store(bcx, ret_alloca, fcx.llretslotptr.get().unwrap());\n+                assert!(!fcx.needs_ret_allocas);\n+                let ret_slot = fcx.get_ret_slot(bcx, ty::mk_u64(), \"ret_slot\");\n+                Store(bcx, ret, ret_slot);\n                 match fcx.llreturn.get() {\n                     Some(llreturn) => Br(bcx, llreturn),\n                     None => {}"}]}