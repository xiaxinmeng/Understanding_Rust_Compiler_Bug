{"sha": "e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YzlhNTNkMWExNDhmZTRjZDJjZjllMGUxMzI5Mjg5MTYzZDIyODQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-14T16:19:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-18T09:23:08Z"}, "message": "incr.comp.: Compute hashes of all query results.", "tree": {"sha": "e6267762ca6034e3921b1fb45c1dd6653bd1e23e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6267762ca6034e3921b1fb45c1dd6653bd1e23e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "html_url": "https://github.com/rust-lang/rust/commit/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cf28f3002470f61a471c69b869e4f55ae1766f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf28f3002470f61a471c69b869e4f55ae1766f7", "html_url": "https://github.com/rust-lang/rust/commit/3cf28f3002470f61a471c69b869e4f55ae1766f7"}], "stats": {"total": 912, "additions": 828, "deletions": 84}, "files": [{"sha": "767868ffda31884a8c6f65266d602592b9c4b6ea", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 75, "deletions": 7, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -13,9 +13,10 @@ use hir::def_id::DefId;\n use hir::map::DefPathHash;\n use ich::{self, CachingCodemapView};\n use session::config::DebugInfoLevel::NoDebugInfo;\n-use ty::TyCtxt;\n-use util::nodemap::{NodeMap, ItemLocalMap};\n+use ty::{self, TyCtxt, fast_reject};\n+use util::nodemap::{NodeMap, NodeSet, ItemLocalMap};\n \n+use std::cmp::Ord;\n use std::hash as std_hash;\n use std::collections::{HashMap, HashSet, BTreeMap};\n \n@@ -47,6 +48,7 @@ pub struct StableHashingContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub enum NodeIdHashingMode {\n     Ignore,\n+    CheckedIgnore,\n     HashDefPath,\n     HashTraitsInScope,\n }\n@@ -148,7 +150,7 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n             self.overflow_checks_enabled = true;\n         }\n         let prev_hash_node_ids = self.node_id_hashing_mode;\n-        self.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n+        self.node_id_hashing_mode = NodeIdHashingMode::CheckedIgnore;\n \n         f(self);\n \n@@ -202,6 +204,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::N\n         let hir_id = hcx.tcx.hir.node_to_hir_id(*self);\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n+                // Don't do anything.\n+            }\n+            NodeIdHashingMode::CheckedIgnore => {\n                 // Most NodeIds in the HIR can be ignored, but if there is a\n                 // corresponding entry in the `trait_map` we need to hash that.\n                 // Make sure we don't ignore too much by checking that there is\n@@ -321,7 +326,7 @@ pub fn hash_stable_hashmap<'a, 'gcx, 'tcx, K, V, R, SK, F, W>(\n     let mut keys: Vec<_> = map.keys()\n                               .map(|k| (extract_stable_key(hcx, k), k))\n                               .collect();\n-    keys.sort_unstable_by_key(|&(ref stable_key, _)| stable_key.clone());\n+    keys.sort_unstable_by(|&(ref sk1, _), &(ref sk2, _)| sk1.cmp(sk2));\n     keys.len().hash_stable(hcx, hasher);\n     for (stable_key, key) in keys {\n         stable_key.hash_stable(hcx, hasher);\n@@ -354,8 +359,25 @@ pub fn hash_stable_nodemap<'a, 'tcx, 'gcx, V, W>(\n     where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n           W: StableHasherResult,\n {\n-    hash_stable_hashmap(hcx, hasher, map, |hcx, node_id| {\n-        hcx.tcx.hir.definitions().node_to_hir_id(*node_id).local_id\n+    let definitions = hcx.tcx.hir.definitions();\n+    hash_stable_hashmap(hcx, hasher, map, |_, node_id| {\n+        let hir_id = definitions.node_to_hir_id(*node_id);\n+        let owner_def_path_hash = definitions.def_path_hash(hir_id.owner);\n+        (owner_def_path_hash, hir_id.local_id)\n+    });\n+}\n+\n+pub fn hash_stable_nodeset<'a, 'tcx, 'gcx, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &NodeSet)\n+    where W: StableHasherResult,\n+{\n+    let definitions = hcx.tcx.hir.definitions();\n+    hash_stable_hashset(hcx, hasher, map, |_, node_id| {\n+        let hir_id = definitions.node_to_hir_id(*node_id);\n+        let owner_def_path_hash = definitions.def_path_hash(hir_id.owner);\n+        (owner_def_path_hash, hir_id.local_id)\n     });\n }\n \n@@ -386,10 +408,56 @@ pub fn hash_stable_btreemap<'a, 'tcx, 'gcx, K, V, SK, F, W>(\n     let mut keys: Vec<_> = map.keys()\n                               .map(|k| (extract_stable_key(hcx, k), k))\n                               .collect();\n-    keys.sort_unstable_by_key(|&(ref stable_key, _)| stable_key.clone());\n+    keys.sort_unstable_by(|&(ref sk1, _), &(ref sk2, _)| sk1.cmp(sk2));\n     keys.len().hash_stable(hcx, hasher);\n     for (stable_key, key) in keys {\n         stable_key.hash_stable(hcx, hasher);\n         map[key].hash_stable(hcx, hasher);\n     }\n }\n+\n+pub fn hash_stable_trait_impls<'a, 'tcx, 'gcx, W, R>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    blanket_impls: &Vec<DefId>,\n+    non_blanket_impls: &HashMap<fast_reject::SimplifiedType, Vec<DefId>, R>)\n+    where W: StableHasherResult,\n+          R: std_hash::BuildHasher,\n+{\n+    {\n+        let mut blanket_impls: AccumulateVec<[_; 8]> = blanket_impls\n+            .iter()\n+            .map(|&def_id| hcx.def_path_hash(def_id))\n+            .collect();\n+\n+        if blanket_impls.len() > 1 {\n+            blanket_impls.sort_unstable();\n+        }\n+\n+        blanket_impls.hash_stable(hcx, hasher);\n+    }\n+\n+    {\n+        let tcx = hcx.tcx();\n+        let mut keys: AccumulateVec<[_; 8]> =\n+            non_blanket_impls.keys()\n+                             .map(|k| (k, k.map_def(|d| tcx.def_path_hash(d))))\n+                             .collect();\n+        keys.sort_unstable_by(|&(_, ref k1), &(_, ref k2)| k1.cmp(k2));\n+        keys.len().hash_stable(hcx, hasher);\n+        for (key, ref stable_key) in keys {\n+            stable_key.hash_stable(hcx, hasher);\n+            let mut impls : AccumulateVec<[_; 8]> = non_blanket_impls[key]\n+                .iter()\n+                .map(|&impl_id| hcx.def_path_hash(impl_id))\n+                .collect();\n+\n+            if impls.len() > 1 {\n+                impls.sort_unstable();\n+            }\n+\n+            impls.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+"}, {"sha": "dad5c35c1e814b084d7752b26a608cd71d113a6a", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -38,3 +38,10 @@ impl_stable_hash_for!(enum middle::cstore::LinkagePreference {\n     RequireDynamic,\n     RequireStatic\n });\n+\n+impl_stable_hash_for!(struct middle::cstore::ExternCrate {\n+    def_id,\n+    span,\n+    direct,\n+    path_len\n+});"}, {"sha": "a4cbcf04111992adead7ca5c1e2acbf5c007fcda", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -13,13 +13,12 @@\n \n use hir;\n use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n-use ich::{StableHashingContext, NodeIdHashingMode};\n-use std::mem;\n-\n-use syntax::ast;\n-\n+use ich::{self, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n+use std::mem;\n+use syntax::ast;\n+use util::nodemap::DefIdSet;\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n     #[inline]\n@@ -30,6 +29,16 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefIdSet\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        ich::hash_stable_hashset(hcx, hasher, self, |hcx, def_id| {\n+            hcx.def_path_hash(*def_id)\n+        });\n+    }\n+}\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::HirId {\n     #[inline]\n@@ -235,7 +244,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::T\n             hir::TyTypeof(..)      |\n             hir::TyErr             |\n             hir::TyInfer           => {\n-                NodeIdHashingMode::Ignore\n+                NodeIdHashingMode::CheckedIgnore\n             }\n             hir::TyPath(..) => {\n                 NodeIdHashingMode::HashTraitsInScope\n@@ -403,7 +412,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::P\n             hir::PatKind::Lit(..)     |\n             hir::PatKind::Range(..)   |\n             hir::PatKind::Slice(..)   => {\n-                NodeIdHashingMode::Ignore\n+                NodeIdHashingMode::CheckedIgnore\n             }\n             hir::PatKind::Path(..)        |\n             hir::PatKind::Struct(..)      |\n@@ -574,21 +583,21 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n                 hir::ExprRepeat(..)     |\n                 hir::ExprTup(..)        => {\n                     // For these we only hash the span when debuginfo is on.\n-                    (false, NodeIdHashingMode::Ignore)\n+                    (false, NodeIdHashingMode::CheckedIgnore)\n                 }\n                 // For the following, spans might be significant because of\n                 // panic messages indicating the source location.\n                 hir::ExprBinary(op, ..) => {\n-                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::CheckedIgnore)\n                 }\n                 hir::ExprUnary(op, _) => {\n-                    (hcx.unop_can_panic_at_runtime(op), NodeIdHashingMode::Ignore)\n+                    (hcx.unop_can_panic_at_runtime(op), NodeIdHashingMode::CheckedIgnore)\n                 }\n                 hir::ExprAssignOp(op, ..) => {\n-                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::CheckedIgnore)\n                 }\n                 hir::ExprIndex(..) => {\n-                    (true, NodeIdHashingMode::Ignore)\n+                    (true, NodeIdHashingMode::CheckedIgnore)\n                 }\n                 // For these we don't care about the span, but want to hash the\n                 // trait in scope\n@@ -899,7 +908,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n             hir::ItemStatic(..)      |\n             hir::ItemConst(..)       |\n             hir::ItemFn(..)          => {\n-                (NodeIdHashingMode::Ignore, hcx.hash_spans())\n+                (NodeIdHashingMode::CheckedIgnore, hcx.hash_spans())\n             }\n             hir::ItemUse(..) => {\n                 (NodeIdHashingMode::HashTraitsInScope, false)\n@@ -916,7 +925,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n             hir::ItemEnum(..)        |\n             hir::ItemStruct(..)      |\n             hir::ItemUnion(..)       => {\n-                (NodeIdHashingMode::Ignore, false)\n+                (NodeIdHashingMode::CheckedIgnore, false)\n             }\n         };\n \n@@ -1160,3 +1169,20 @@ for ::middle::lang_items::LangItem {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for hir::TraitCandidate {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            let hir::TraitCandidate {\n+                def_id,\n+                import_id,\n+            } = *self;\n+\n+            def_id.hash_stable(hcx, hasher);\n+            import_id.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "53a071fe4803015c84c8608af2551693254ca436", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 216, "deletions": 39, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -11,12 +11,13 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use ich::StableHashingContext;\n+use ich::{self, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n use std::mem;\n use middle::region;\n+use traits;\n use ty;\n \n impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n@@ -304,7 +305,9 @@ for ::middle::const_val::ConstVal<'gcx> {\n             }\n             Function(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                    substs.hash_stable(hcx, hasher);\n+                });\n             }\n             Aggregate(Struct(ref name_values)) => {\n                 let mut values = name_values.to_vec();\n@@ -338,6 +341,54 @@ impl_stable_hash_for!(struct ty::Const<'tcx> {\n     val\n });\n \n+impl_stable_hash_for!(struct ::middle::const_val::ConstEvalErr<'tcx> {\n+    span,\n+    kind\n+});\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::const_val::ErrKind<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::const_val::ErrKind::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            CannotCast |\n+            MissingStructField |\n+            NonConstPath |\n+            ExpectedConstTuple |\n+            ExpectedConstStruct |\n+            IndexedNonVec |\n+            IndexNotUsize |\n+            MiscBinaryOp |\n+            MiscCatchAll |\n+            IndexOpFeatureGated |\n+            TypeckError => {\n+                // nothing to do\n+            }\n+            UnimplementedConstVal(s) => {\n+                s.hash_stable(hcx, hasher);\n+            }\n+            IndexOutOfBounds { len, index } => {\n+                len.hash_stable(hcx, hasher);\n+                index.hash_stable(hcx, hasher);\n+            }\n+            Math(ref const_math_err) => {\n+                const_math_err.hash_stable(hcx, hasher);\n+            }\n+            LayoutError(ref layout_error) => {\n+                layout_error.hash_stable(hcx, hasher);\n+            }\n+            ErroneousReferencedConstant(ref const_val) => {\n+                const_val.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });\n@@ -414,7 +465,6 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n     pure_wrt_drop\n });\n \n-\n impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n for ::middle::resolve_lifetime::Set1<T>\n     where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n@@ -470,19 +520,21 @@ for region::Scope\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            region::Scope::Node(node_id) |\n-            region::Scope::Destruction(node_id) => {\n-                node_id.hash_stable(hcx, hasher);\n-            }\n-            region::Scope::CallSite(body_id) |\n-            region::Scope::Arguments(body_id) => {\n-                body_id.hash_stable(hcx, hasher);\n-            }\n-            region::Scope::Remainder(block_remainder) => {\n-                block_remainder.hash_stable(hcx, hasher);\n-            }\n-        }\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            match *self {\n+                region::Scope::Node(node_id) |\n+                region::Scope::Destruction(node_id) => {\n+                    node_id.hash_stable(hcx, hasher);\n+                }\n+                region::Scope::CallSite(body_id) |\n+                region::Scope::Arguments(body_id) => {\n+                    body_id.hash_stable(hcx, hasher);\n+                }\n+                region::Scope::Remainder(block_remainder) => {\n+                    block_remainder.hash_stable(hcx, hasher);\n+                }\n+            }\n+        })\n     }\n }\n \n@@ -520,6 +572,7 @@ for ty::TypeVariants<'gcx>\n             TyBool  |\n             TyChar  |\n             TyStr   |\n+            TyError |\n             TyNever => {\n                 // Nothing more to hash.\n             }\n@@ -585,10 +638,8 @@ for ty::TypeVariants<'gcx>\n             TyParam(param_ty) => {\n                 param_ty.hash_stable(hcx, hasher);\n             }\n-\n-            TyError     |\n             TyInfer(..) => {\n-                bug!(\"ty::TypeVariants::hash_stable() - Unexpected variant.\")\n+                bug!(\"ty::TypeVariants::hash_stable() - Unexpected variant {:?}.\", *self)\n             }\n         }\n     }\n@@ -636,26 +687,6 @@ impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n     ty\n });\n \n-impl_stable_hash_for!(enum ty::fast_reject::SimplifiedType {\n-    BoolSimplifiedType,\n-    CharSimplifiedType,\n-    IntSimplifiedType(int_ty),\n-    UintSimplifiedType(int_ty),\n-    FloatSimplifiedType(float_ty),\n-    AdtSimplifiedType(def_id),\n-    StrSimplifiedType,\n-    ArraySimplifiedType,\n-    PtrSimplifiedType,\n-    NeverSimplifiedType,\n-    TupleSimplifiedType(size),\n-    TraitSimplifiedType(def_id),\n-    ClosureSimplifiedType(def_id),\n-    GeneratorSimplifiedType(def_id),\n-    AnonSimplifiedType(def_id),\n-    FunctionSimplifiedType(params),\n-    ParameterSimplifiedType\n-});\n-\n impl_stable_hash_for!(struct ty::Instance<'tcx> {\n     def,\n     substs\n@@ -697,3 +728,149 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::In\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::TraitDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::TraitDef {\n+            // We already have the def_path_hash below, no need to hash it twice\n+            def_id: _,\n+            unsafety,\n+            paren_sugar,\n+            has_default_impl,\n+            def_path_hash,\n+        } = *self;\n+\n+        unsafety.hash_stable(hcx, hasher);\n+        paren_sugar.hash_stable(hcx, hasher);\n+        has_default_impl.hash_stable(hcx, hasher);\n+        def_path_hash.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::Destructor {\n+    did\n+});\n+\n+impl_stable_hash_for!(struct ty::DtorckConstraint<'tcx> {\n+    outlives,\n+    dtorck_types\n+});\n+\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::CrateVariancesMap {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::CrateVariancesMap {\n+            ref dependencies,\n+            ref variances,\n+            // This is just an irrelevant helper value.\n+            empty_variance: _,\n+        } = *self;\n+\n+        dependencies.hash_stable(hcx, hasher);\n+\n+        ich::hash_stable_hashmap(hcx, hasher, variances, |hcx, def_id| {\n+            hcx.def_path_hash(*def_id)\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::AssociatedItem {\n+    def_id,\n+    name,\n+    kind,\n+    vis,\n+    defaultness,\n+    container,\n+    method_has_self_argument\n+});\n+\n+impl_stable_hash_for!(enum ty::AssociatedKind {\n+    Const,\n+    Method,\n+    Type\n+});\n+\n+impl_stable_hash_for!(enum ty::AssociatedItemContainer {\n+    TraitContainer(def_id),\n+    ImplContainer(def_id)\n+});\n+\n+\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::steal::Steal<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.borrow().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n+    caller_bounds,\n+    reveal\n+});\n+\n+impl_stable_hash_for!(enum traits::Reveal {\n+    UserFacing,\n+    All\n+});\n+\n+impl_stable_hash_for!(enum ::middle::privacy::AccessLevel {\n+    Reachable,\n+    Exported,\n+    Public\n+});\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::privacy::AccessLevels {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            let ::middle::privacy::AccessLevels {\n+                ref map\n+            } = *self;\n+\n+            ich::hash_stable_nodemap(hcx, hasher, map);\n+        });\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::CrateInherentImpls {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::CrateInherentImpls {\n+            ref inherent_impls,\n+        } = *self;\n+\n+        ich::hash_stable_hashmap(hcx, hasher, inherent_impls, |hcx, def_id| {\n+            hcx.def_path_hash(*def_id)\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::session::CompileIncomplete {\n+    Stopped,\n+    Errored(error_reported)\n+});\n+\n+impl_stable_hash_for!(struct ::util::common::ErrorReported {});\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::reachable::ReachableSet {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ::middle::reachable::ReachableSet(ref reachable_set) = *self;\n+\n+        ich::hash_stable_nodeset(hcx, hasher, reachable_set);\n+    }\n+}\n+"}, {"sha": "c24064eb27c589bc4a4fbd1cff6aec1d9034df0f", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -13,8 +13,9 @@\n pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n-                    hash_stable_hashset, hash_stable_nodemap,\n-                    hash_stable_btreemap, hash_stable_itemlocalmap};\n+                    hash_stable_hashset, hash_stable_nodemap, hash_stable_nodeset,\n+                    hash_stable_btreemap, hash_stable_itemlocalmap,\n+                    hash_stable_trait_impls};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;"}, {"sha": "e953afd799dbfd469bd9c579effde5e59ff16322", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -12,9 +12,12 @@ use std::cmp;\n \n use errors::DiagnosticBuilder;\n use hir::HirId;\n+use ich::{self, StableHashingContext};\n use lint::builtin;\n use lint::context::CheckLintNameResult;\n use lint::{self, Lint, LintId, Level, LintSource};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n use session::Session;\n use syntax::ast;\n use syntax::attr;\n@@ -382,3 +385,61 @@ impl LintLevelMap {\n         })\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for LintLevelMap {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let LintLevelMap {\n+            ref sets,\n+            ref id_to_set,\n+        } = *self;\n+\n+        let definitions = hcx.tcx().hir.definitions();\n+        ich::hash_stable_hashmap(hcx, hasher, id_to_set, |_, hir_id| {\n+            (definitions.def_path_hash(hir_id.owner), hir_id.local_id)\n+        });\n+\n+        let LintLevelSets {\n+            ref list,\n+            lint_cap,\n+        } = *sets;\n+\n+        lint_cap.hash_stable(hcx, hasher);\n+\n+        hcx.while_hashing_spans(true, |hcx| {\n+            list.len().hash_stable(hcx, hasher);\n+\n+            // We are working under the assumption here that the list of\n+            // lint-sets is built in a deterministic order.\n+            for lint_set in list {\n+                ::std::mem::discriminant(lint_set).hash_stable(hcx, hasher);\n+\n+                match *lint_set {\n+                    LintSet::CommandLine { ref specs } => {\n+                        ich::hash_stable_hashmap(hcx, hasher, specs, |_, lint_id| {\n+                            lint_id.lint_name_raw()\n+                        });\n+                    }\n+                    LintSet::Node { ref specs, parent } => {\n+                        ich::hash_stable_hashmap(hcx, hasher, specs, |_, lint_id| {\n+                            lint_id.lint_name_raw()\n+                        });\n+                        parent.hash_stable(hcx, hasher);\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for LintId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.lint_name_raw().hash_stable(hcx, hasher);\n+    }\n+}\n+"}, {"sha": "42b5e2dd83de598151b4664026abda4a39f88abb", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -305,6 +305,10 @@ impl LintId {\n         }\n     }\n \n+    pub fn lint_name_raw(&self) -> &'static str {\n+        self.lint.name\n+    }\n+\n     /// Get the name of the lint.\n     pub fn to_string(&self) -> String {\n         self.lint.name_lower()\n@@ -317,6 +321,13 @@ pub enum Level {\n     Allow, Warn, Deny, Forbid\n }\n \n+impl_stable_hash_for!(enum self::Level {\n+    Allow,\n+    Warn,\n+    Deny,\n+    Forbid\n+});\n+\n impl Level {\n     /// Convert a level to a lower-case string.\n     pub fn as_str(self) -> &'static str {\n@@ -354,6 +365,12 @@ pub enum LintSource {\n     CommandLine(Symbol),\n }\n \n+impl_stable_hash_for!(enum self::LintSource {\n+    Default,\n+    Node(name, span),\n+    CommandLine(text)\n+});\n+\n pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;"}, {"sha": "fa29dda86ddd04dbdf0a0385ea5e917664ef142f", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -369,7 +369,13 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n     }\n }\n \n-fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> Rc<NodeSet> {\n+// We introduce a new-type here, so we can have a specialized HashStable\n+// implementation for it.\n+#[derive(Clone)]\n+pub struct ReachableSet(pub Rc<NodeSet>);\n+\n+\n+fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n@@ -414,7 +420,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     reachable_context.propagate();\n \n     // Return the set of reachable symbols.\n-    Rc::new(reachable_context.reachable_symbols)\n+    ReachableSet(Rc::new(reachable_context.reachable_symbols))\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "562536ced3ce9ddcfc8622af7bb0ff839f6e4d6b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -14,6 +14,7 @@\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n \n+use ich::{self, StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n@@ -31,6 +32,8 @@ use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use mir::transform::MirSource;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n \n /// Scope represents a statically-describable scope that can be\n /// used to bound the lifetime/region for values.\n@@ -1235,3 +1238,43 @@ pub fn provide(providers: &mut Providers) {\n         ..*providers\n     };\n }\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ScopeTree {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ScopeTree {\n+            root_body,\n+            root_parent,\n+            ref parent_map,\n+            ref var_map,\n+            ref destruction_scopes,\n+            ref rvalue_scopes,\n+            ref closure_tree,\n+            ref yield_in_scope,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            root_body.hash_stable(hcx, hasher);\n+            root_parent.hash_stable(hcx, hasher);\n+        });\n+\n+        ich::hash_stable_hashmap(hcx, hasher, parent_map, |hcx, scope| {\n+            let mut hasher = StableHasher::new();\n+            scope.hash_stable(hcx, &mut hasher);\n+            let stable: u64 = hasher.finish();\n+            stable\n+        });\n+\n+        ich::hash_stable_itemlocalmap(hcx, hasher, var_map);\n+        ich::hash_stable_itemlocalmap(hcx, hasher, destruction_scopes);\n+        ich::hash_stable_itemlocalmap(hcx, hasher, rvalue_scopes);\n+        ich::hash_stable_itemlocalmap(hcx, hasher, closure_tree);\n+        ich::hash_stable_hashmap(hcx, hasher, yield_in_scope, |hcx, scope| {\n+            let mut hasher = StableHasher::new();\n+            scope.hash_stable(hcx, &mut hasher);\n+            let stable: u64 = hasher.finish();\n+            stable\n+        });\n+    }\n+}"}, {"sha": "ecaf14659ae6bb38986791f340f6bbc8ded01b06", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -11,6 +11,9 @@\n use super::OverlapError;\n \n use hir::def_id::DefId;\n+use ich::{self, StableHashingContext};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n@@ -365,3 +368,34 @@ pub fn ancestors(tcx: TyCtxt,\n         current_source: Some(Node::Impl(start_from_impl)),\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Children {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Children {\n+            ref nonblanket_impls,\n+            ref blanket_impls,\n+        } = *self;\n+\n+        ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, nonblanket_impls);\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Graph {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Graph {\n+            ref parent,\n+            ref children,\n+        } = *self;\n+\n+        ich::hash_stable_hashmap(hcx, hasher, parent, |hcx, def_id| {\n+            hcx.def_path_hash(*def_id)\n+        });\n+        ich::hash_stable_hashmap(hcx, hasher, children, |hcx, def_id| {\n+            hcx.def_path_hash(*def_id)\n+        });\n+    }\n+}"}, {"sha": "86ae4bb92df0738a4d38ec325def6a3f5659ff1f", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 84, "deletions": 10, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -9,29 +9,44 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use ty::{self, Ty, TyCtxt};\n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::mem;\n use syntax::ast;\n+use ty::{self, Ty, TyCtxt};\n \n-use self::SimplifiedType::*;\n+use self::SimplifiedTypeGen::*;\n \n-/// See `simplify_type\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum SimplifiedType {\n+pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n+\n+/// See `simplify_type`\n+///\n+/// Note that we keep this type generic over the type of identifier it uses\n+/// because we sometimes need to use SimplifiedTypeGen values as stable sorting\n+/// keys (in which case we use a DefPathHash as id-type) but in the general case\n+/// the non-stable but fast to construct DefId-version is the better choice.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum SimplifiedTypeGen<D>\n+    where D: Copy + Debug + Ord + Eq + Hash\n+{\n     BoolSimplifiedType,\n     CharSimplifiedType,\n     IntSimplifiedType(ast::IntTy),\n     UintSimplifiedType(ast::UintTy),\n     FloatSimplifiedType(ast::FloatTy),\n-    AdtSimplifiedType(DefId),\n+    AdtSimplifiedType(D),\n     StrSimplifiedType,\n     ArraySimplifiedType,\n     PtrSimplifiedType,\n     NeverSimplifiedType,\n     TupleSimplifiedType(usize),\n-    TraitSimplifiedType(DefId),\n-    ClosureSimplifiedType(DefId),\n-    GeneratorSimplifiedType(DefId),\n-    AnonSimplifiedType(DefId),\n+    TraitSimplifiedType(D),\n+    ClosureSimplifiedType(D),\n+    GeneratorSimplifiedType(D),\n+    AnonSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n }\n@@ -101,3 +116,62 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyInfer(_) | ty::TyError => None,\n     }\n }\n+\n+impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n+    pub fn map_def<U, F>(self, map: F) -> SimplifiedTypeGen<U>\n+        where F: Fn(D) -> U,\n+              U: Copy + Debug + Ord + Eq + Hash,\n+    {\n+        match self {\n+            BoolSimplifiedType => BoolSimplifiedType,\n+            CharSimplifiedType => CharSimplifiedType,\n+            IntSimplifiedType(t) => IntSimplifiedType(t),\n+            UintSimplifiedType(t) => UintSimplifiedType(t),\n+            FloatSimplifiedType(t) => FloatSimplifiedType(t),\n+            AdtSimplifiedType(d) => AdtSimplifiedType(map(d)),\n+            StrSimplifiedType => StrSimplifiedType,\n+            ArraySimplifiedType => ArraySimplifiedType,\n+            PtrSimplifiedType => PtrSimplifiedType,\n+            NeverSimplifiedType => NeverSimplifiedType,\n+            TupleSimplifiedType(n) => TupleSimplifiedType(n),\n+            TraitSimplifiedType(d) => TraitSimplifiedType(map(d)),\n+            ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n+            GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n+            AnonSimplifiedType(d) => AnonSimplifiedType(map(d)),\n+            FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n+            ParameterSimplifiedType => ParameterSimplifiedType,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx, D> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for SimplifiedTypeGen<D>\n+    where D: Copy + Debug + Ord + Eq + Hash +\n+             HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            BoolSimplifiedType |\n+            CharSimplifiedType |\n+            StrSimplifiedType |\n+            ArraySimplifiedType |\n+            PtrSimplifiedType |\n+            NeverSimplifiedType |\n+            ParameterSimplifiedType => {\n+                // nothing to do\n+            }\n+            IntSimplifiedType(t) => t.hash_stable(hcx, hasher),\n+            UintSimplifiedType(t) => t.hash_stable(hcx, hasher),\n+            FloatSimplifiedType(t) => t.hash_stable(hcx, hasher),\n+            AdtSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            TupleSimplifiedType(n) => n.hash_stable(hcx, hasher),\n+            TraitSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            ClosureSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            GeneratorSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            AnonSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            FunctionSimplifiedType(n) => n.hash_stable(hcx, hasher),\n+        }\n+    }\n+}"}, {"sha": "1ae1e7007ac5e93c8a27ba955eb698c9eef8cf8e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -23,8 +23,13 @@ use std::cmp;\n use std::fmt;\n use std::i64;\n use std::iter;\n+use std::mem;\n use std::ops::Deref;\n \n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+\n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n /// for a target, which contains everything needed to compute layouts.\n pub struct TargetDataLayout {\n@@ -2300,3 +2305,128 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         cx.layout_of(cx.normalize_projections(self.field_type(cx, i)))\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Layout\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use ty::layout::Layout::*;\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Scalar { value, non_zero } => {\n+                value.hash_stable(hcx, hasher);\n+                non_zero.hash_stable(hcx, hasher);\n+            }\n+            Vector { element, count } => {\n+                element.hash_stable(hcx, hasher);\n+                count.hash_stable(hcx, hasher);\n+            }\n+            Array { sized, align, primitive_align, element_size, count } => {\n+                sized.hash_stable(hcx, hasher);\n+                align.hash_stable(hcx, hasher);\n+                primitive_align.hash_stable(hcx, hasher);\n+                element_size.hash_stable(hcx, hasher);\n+                count.hash_stable(hcx, hasher);\n+            }\n+            FatPointer { ref metadata, non_zero } => {\n+                metadata.hash_stable(hcx, hasher);\n+                non_zero.hash_stable(hcx, hasher);\n+            }\n+            CEnum { discr, signed, non_zero, min, max } => {\n+                discr.hash_stable(hcx, hasher);\n+                signed.hash_stable(hcx, hasher);\n+                non_zero.hash_stable(hcx, hasher);\n+                min.hash_stable(hcx, hasher);\n+                max.hash_stable(hcx, hasher);\n+            }\n+            Univariant { ref variant, non_zero } => {\n+                variant.hash_stable(hcx, hasher);\n+                non_zero.hash_stable(hcx, hasher);\n+            }\n+            UntaggedUnion { ref variants } => {\n+                variants.hash_stable(hcx, hasher);\n+            }\n+            General { discr, ref variants, size, align, primitive_align } => {\n+                discr.hash_stable(hcx, hasher);\n+                variants.hash_stable(hcx, hasher);\n+                size.hash_stable(hcx, hasher);\n+                align.hash_stable(hcx, hasher);\n+                primitive_align.hash_stable(hcx, hasher);\n+            }\n+            RawNullablePointer { nndiscr, ref value } => {\n+                nndiscr.hash_stable(hcx, hasher);\n+                value.hash_stable(hcx, hasher);\n+            }\n+            StructWrappedNullablePointer {\n+                nndiscr,\n+                ref nonnull,\n+                ref discrfield,\n+                ref discrfield_source\n+            } => {\n+                nndiscr.hash_stable(hcx, hasher);\n+                nonnull.hash_stable(hcx, hasher);\n+                discrfield.hash_stable(hcx, hasher);\n+                discrfield_source.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::ty::layout::Integer {\n+    I1,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128\n+});\n+\n+impl_stable_hash_for!(enum ::ty::layout::Primitive {\n+    Int(integer),\n+    F32,\n+    F64,\n+    Pointer\n+});\n+\n+impl_stable_hash_for!(struct ::ty::layout::Align {\n+    abi,\n+    pref\n+});\n+\n+impl_stable_hash_for!(struct ::ty::layout::Size {\n+    raw\n+});\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for LayoutError<'gcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use ty::layout::LayoutError::*;\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Unknown(t) |\n+            SizeOverflow(t) => t.hash_stable(hcx, hasher)\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ::ty::layout::Struct {\n+    align,\n+    primitive_align,\n+    packed,\n+    sized,\n+    offsets,\n+    memory_index,\n+    min_size\n+});\n+\n+impl_stable_hash_for!(struct ::ty::layout::Union {\n+    align,\n+    primitive_align,\n+    min_size,\n+    packed\n+});"}, {"sha": "48502dc2e8c84192e3bf77984d4ac075c930f8e9", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -14,11 +14,13 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId};\n use hir::svh::Svh;\n+use ich::{Fingerprint, StableHashingContext};\n use lint;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary};\n use middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n use middle::privacy::AccessLevels;\n+use middle::reachable::ReachableSet;\n use middle::region;\n use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n@@ -36,14 +38,15 @@ use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n-use util::nodemap::{DefIdSet, NodeSet, DefIdMap};\n+use util::nodemap::{DefIdSet, DefIdMap};\n use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::cell::{RefCell, RefMut, Cell};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::marker::PhantomData;\n@@ -925,9 +928,8 @@ macro_rules! define_maps {\n                     span = key.default_span(tcx)\n                 }\n \n+                let dep_node = Self::to_dep_node(tcx, &key);\n                 let res = tcx.cycle_check(span, Query::$name(key), || {\n-                    let dep_node = Self::to_dep_node(tcx, &key);\n-\n                     tcx.sess.diagnostic().track_diagnostics(|| {\n                         if dep_node.kind.is_anon() {\n                             tcx.dep_graph.with_anon_task(dep_node.kind, || {\n@@ -951,6 +953,20 @@ macro_rules! define_maps {\n \n                 tcx.dep_graph.read_index(dep_node_index);\n \n+                // In incremental mode, hash the result of the query. We don't\n+                // do anything with the hash yet, but we are computing it\n+                // anyway so that\n+                //  - we make sure that the infrastructure works and\n+                //  - we can get an idea of the runtime cost.\n+                if !dep_node.kind.is_anon() && tcx.sess.opts.incremental.is_some() {\n+                    let mut hcx = StableHashingContext::new(tcx);\n+                    let mut hasher = StableHasher::new();\n+\n+                    result.hash_stable(&mut hcx, &mut hasher);\n+\n+                    let _: Fingerprint = hasher.finish();\n+                }\n+\n                 let value = QueryValue {\n                     value: result,\n                     index: dep_node_index,\n@@ -1300,7 +1316,7 @@ define_maps! { <'tcx>\n     /// Performs the privacy check and computes \"access levels\".\n     [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    [] fn reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n+    [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n \n     /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n     /// in the case of closures, this will be redirected to the enclosing function."}, {"sha": "9ae6c3516a5cf088020f1df02702161903bffacf", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -11,13 +11,15 @@\n use hir;\n use hir::def_id::DefId;\n use hir::map::DefPathHash;\n+use ich::{self, StableHashingContext};\n use traits::specialization_graph;\n use ty::fast_reject;\n use ty::fold::TypeFoldable;\n use ty::{Ty, TyCtxt};\n \n use rustc_data_structures::fx::FxHashMap;\n-\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n use std::rc::Rc;\n \n /// A trait's definition with type information.\n@@ -183,3 +185,16 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         non_blanket_impls: non_blanket_impls,\n     })\n }\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TraitImpls {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let TraitImpls {\n+            ref blanket_impls,\n+            ref non_blanket_impls,\n+        } = *self;\n+\n+        ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, non_blanket_impls);\n+    }\n+}"}, {"sha": "0d0cf672489445c18f1afb71aa14918fc7ab94b0", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -365,8 +365,24 @@ impl<T, CTX> HashStable<CTX> for Option<T>\n     }\n }\n \n+impl<T1, T2, CTX> HashStable<CTX> for Result<T1, T2>\n+    where T1: HashStable<CTX>,\n+          T2: HashStable<CTX>,\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(ctx, hasher);\n+        match *self {\n+            Ok(ref x) => x.hash_stable(ctx, hasher),\n+            Err(ref x) => x.hash_stable(ctx, hasher),\n+        }\n+    }\n+}\n+\n impl<'a, T, CTX> HashStable<CTX> for &'a T\n-    where T: HashStable<CTX>\n+    where T: HashStable<CTX> + ?Sized\n {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -425,3 +441,13 @@ impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<\n         }\n     }\n }\n+\n+\n+impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSetBuf<I>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.words().hash_stable(ctx, hasher);\n+    }\n+}"}, {"sha": "6ed928ca09deb641ab1f8be151867aebb911267a", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -15,7 +15,8 @@\n //! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, ClosureSubsts};\n+use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n@@ -79,6 +80,45 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n         self.super_statement(block, statement, location);\n         self.in_validation_statement = false;\n     }\n+\n+    fn visit_const_val(&mut self,\n+                       const_val: &mut ConstVal<'tcx>,\n+                       _: Location) {\n+        erase_const_val(self.tcx, const_val);\n+        self.super_const_val(const_val);\n+\n+        fn erase_const_val<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     const_val: &mut ConstVal<'tcx>) {\n+            match *const_val {\n+                ConstVal::Float(_)    |\n+                ConstVal::Integral(_) |\n+                ConstVal::Str(_)      |\n+                ConstVal::ByteStr(_)  |\n+                ConstVal::Bool(_)     |\n+                ConstVal::Char(_)     |\n+                ConstVal::Variant(_)  => {\n+                    // nothing to do\n+                }\n+                ConstVal::Function(_, ref mut substs) => {\n+                    *substs = tcx.erase_regions(&{*substs});\n+                }\n+                ConstVal::Struct(ref mut field_map) => {\n+                    for (_, field_val) in field_map {\n+                        erase_const_val(tcx, field_val);\n+                    }\n+                }\n+                ConstVal::Tuple(ref mut fields) |\n+                ConstVal::Array(ref mut fields) => {\n+                    for field_val in fields {\n+                        erase_const_val(tcx, field_val);\n+                    }\n+                }\n+                ConstVal::Repeat(ref mut expr, _) => {\n+                    erase_const_val(tcx, &mut **expr);\n+                }\n+            }\n+        }\n+    }\n }\n \n pub struct EraseRegions;"}, {"sha": "496be8b3eb23e93b22b0f51c9ed9366dcf8a8242", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6c9a53d1a148fe4cd2cf9e0e1329289163d2284/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e6c9a53d1a148fe4cd2cf9e0e1329289163d2284", "patch": "@@ -1221,7 +1221,8 @@ pub enum ImplItemKind {\n     Macro(Mac),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n+         PartialOrd, Ord)]\n pub enum IntTy {\n     Is,\n     I8,\n@@ -1274,7 +1275,8 @@ impl IntTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n+         PartialOrd, Ord)]\n pub enum UintTy {\n     Us,\n     U8,\n@@ -1324,7 +1326,8 @@ impl fmt::Display for UintTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n+         PartialOrd, Ord)]\n pub enum FloatTy {\n     F32,\n     F64,"}]}