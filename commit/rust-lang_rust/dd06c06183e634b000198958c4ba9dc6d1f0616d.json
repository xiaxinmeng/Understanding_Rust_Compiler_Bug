{"sha": "dd06c06183e634b000198958c4ba9dc6d1f0616d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMDZjMDYxODNlNjM0YjAwMDE5ODk1OGM0YmE5ZGM2ZDFmMDYxNmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-21T05:53:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-21T05:53:46Z"}, "message": "Auto merge of #5028 - krishna-veerareddy:issue-5026-mem-ordering-fences, r=phansch\n\nDetect usage of invalid atomic ordering in memory fences\n\nDetect usage of `core::sync::atomic::{fence, compiler_fence}` with `Ordering::Relaxed` and suggest valid alternatives.\n\nchangelog: Extend `invalid_atomic_ordering` to lint memory fences\n\nFixes #5026", "tree": {"sha": "79a788982036886dab2bb5f2a19c9d3b9858bf1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79a788982036886dab2bb5f2a19c9d3b9858bf1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd06c06183e634b000198958c4ba9dc6d1f0616d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd06c06183e634b000198958c4ba9dc6d1f0616d", "html_url": "https://github.com/rust-lang/rust/commit/dd06c06183e634b000198958c4ba9dc6d1f0616d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd06c06183e634b000198958c4ba9dc6d1f0616d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eca0d8e5d0a26bee85da646fb61b3917a1ba79ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/eca0d8e5d0a26bee85da646fb61b3917a1ba79ae", "html_url": "https://github.com/rust-lang/rust/commit/eca0d8e5d0a26bee85da646fb61b3917a1ba79ae"}, {"sha": "5e058f38f43108d81d6efc98cf7406f28e891ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e058f38f43108d81d6efc98cf7406f28e891ded", "html_url": "https://github.com/rust-lang/rust/commit/5e058f38f43108d81d6efc98cf7406f28e891ded"}], "stats": {"total": 138, "additions": 104, "deletions": 34}, "files": [{"sha": "0dab0c9cc4f8c182b3ae508102b067bce3d8c9f7", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 64, "deletions": 33, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/dd06c06183e634b000198958c4ba9dc6d1f0616d/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd06c06183e634b000198958c4ba9dc6d1f0616d/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=dd06c06183e634b000198958c4ba9dc6d1f0616d", "patch": "@@ -8,7 +8,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of invalid atomic\n-    /// ordering in Atomic*::{load, store} calls.\n+    /// ordering in atomic loads/stores and memory fences.\n     ///\n     /// **Why is this bad?** Using an invalid atomic ordering\n     /// will cause a panic at run-time.\n@@ -17,7 +17,7 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust,no_run\n-    /// # use std::sync::atomic::{AtomicBool, Ordering};\n+    /// # use std::sync::atomic::{self, AtomicBool, Ordering};\n     ///\n     /// let x = AtomicBool::new(true);\n     ///\n@@ -26,10 +26,13 @@ declare_clippy_lint! {\n     ///\n     /// x.store(false, Ordering::Acquire);\n     /// x.store(false, Ordering::AcqRel);\n+    ///\n+    /// atomic::fence(Ordering::Relaxed);\n+    /// atomic::compiler_fence(Ordering::Relaxed);\n     /// ```\n     pub INVALID_ATOMIC_ORDERING,\n     correctness,\n-    \"usage of invalid atomic ordering in atomic load/store calls\"\n+    \"usage of invalid atomic ordering in atomic loads/stores and memory fences\"\n }\n \n declare_lint_pass!(AtomicOrdering => [INVALID_ATOMIC_ORDERING]);\n@@ -65,37 +68,65 @@ fn match_ordering_def_path(cx: &LateContext<'_, '_>, did: DefId, orderings: &[&s\n         .any(|ordering| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", \"Ordering\", ordering]))\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AtomicOrdering {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(ref method_path, _, args) = &expr.kind;\n-            let method = method_path.ident.name.as_str();\n-            if type_is_atomic(cx, &args[0]);\n-            if method == \"load\" || method == \"store\";\n-            let ordering_arg = if method == \"load\" { &args[1] } else { &args[2] };\n-            if let ExprKind::Path(ref ordering_qpath) = ordering_arg.kind;\n-            if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n-            then {\n-                if method == \"load\" &&\n-                    match_ordering_def_path(cx, ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n-                    span_help_and_lint(\n-                        cx,\n-                        INVALID_ATOMIC_ORDERING,\n-                        ordering_arg.span,\n-                        \"atomic loads cannot have `Release` and `AcqRel` ordering\",\n-                        \"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\"\n-                    );\n-                } else if method == \"store\" &&\n-                    match_ordering_def_path(cx, ordering_def_id, &[\"Acquire\", \"AcqRel\"]) {\n-                    span_help_and_lint(\n-                        cx,\n-                        INVALID_ATOMIC_ORDERING,\n-                        ordering_arg.span,\n-                        \"atomic stores cannot have `Acquire` and `AcqRel` ordering\",\n-                        \"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\"\n-                    );\n-                }\n+fn check_atomic_load_store(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method_path, _, args) = &expr.kind;\n+        let method = method_path.ident.name.as_str();\n+        if type_is_atomic(cx, &args[0]);\n+        if method == \"load\" || method == \"store\";\n+        let ordering_arg = if method == \"load\" { &args[1] } else { &args[2] };\n+        if let ExprKind::Path(ref ordering_qpath) = ordering_arg.kind;\n+        if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n+        then {\n+            if method == \"load\" &&\n+                match_ordering_def_path(cx, ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n+                span_help_and_lint(\n+                    cx,\n+                    INVALID_ATOMIC_ORDERING,\n+                    ordering_arg.span,\n+                    \"atomic loads cannot have `Release` and `AcqRel` ordering\",\n+                    \"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\"\n+                );\n+            } else if method == \"store\" &&\n+                match_ordering_def_path(cx, ordering_def_id, &[\"Acquire\", \"AcqRel\"]) {\n+                span_help_and_lint(\n+                    cx,\n+                    INVALID_ATOMIC_ORDERING,\n+                    ordering_arg.span,\n+                    \"atomic stores cannot have `Acquire` and `AcqRel` ordering\",\n+                    \"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\"\n+                );\n             }\n         }\n     }\n }\n+\n+fn check_memory_fence(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Call(ref func, ref args) = expr.kind;\n+        if let ExprKind::Path(ref func_qpath) = func.kind;\n+        if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if [\"fence\", \"compiler_fence\"]\n+            .iter()\n+            .any(|func| match_def_path(cx, def_id, &[\"core\", \"sync\", \"atomic\", func]));\n+        if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n+        if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n+        if match_ordering_def_path(cx, ordering_def_id, &[\"Relaxed\"]);\n+        then {\n+            span_help_and_lint(\n+                cx,\n+                INVALID_ATOMIC_ORDERING,\n+                args[0].span,\n+                \"memory fences cannot have `Relaxed` ordering\",\n+                \"consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\"\n+            );\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AtomicOrdering {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        check_atomic_load_store(cx, expr);\n+        check_memory_fence(cx, expr);\n+    }\n+}"}, {"sha": "6858c3e15c8a939f1dd7769e7f7ed031ac936257", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd06c06183e634b000198958c4ba9dc6d1f0616d/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd06c06183e634b000198958c4ba9dc6d1f0616d/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=dd06c06183e634b000198958c4ba9dc6d1f0616d", "patch": "@@ -843,7 +843,7 @@ pub const ALL_LINTS: [Lint; 348] = [\n     Lint {\n         name: \"invalid_atomic_ordering\",\n         group: \"correctness\",\n-        desc: \"usage of invalid atomic ordering in atomic load/store calls\",\n+        desc: \"usage of invalid atomic ordering in atomic loads/stores and memory fences\",\n         deprecation: None,\n         module: \"atomic_ordering\",\n     },"}, {"sha": "5ee5182ca051ade720278e764c4d9b5edb3d3d7a", "filename": "tests/ui/atomic_ordering_fence.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dd06c06183e634b000198958c4ba9dc6d1f0616d/tests%2Fui%2Fatomic_ordering_fence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd06c06183e634b000198958c4ba9dc6d1f0616d/tests%2Fui%2Fatomic_ordering_fence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_fence.rs?ref=dd06c06183e634b000198958c4ba9dc6d1f0616d", "patch": "@@ -0,0 +1,20 @@\n+#![warn(clippy::invalid_atomic_ordering)]\n+\n+use std::sync::atomic::{compiler_fence, fence, Ordering};\n+\n+fn main() {\n+    // Allowed fence ordering modes\n+    fence(Ordering::Acquire);\n+    fence(Ordering::Release);\n+    fence(Ordering::AcqRel);\n+    fence(Ordering::SeqCst);\n+\n+    // Disallowed fence ordering modes\n+    fence(Ordering::Relaxed);\n+\n+    compiler_fence(Ordering::Acquire);\n+    compiler_fence(Ordering::Release);\n+    compiler_fence(Ordering::AcqRel);\n+    compiler_fence(Ordering::SeqCst);\n+    compiler_fence(Ordering::Relaxed);\n+}"}, {"sha": "3ceff27d9ad5e7164e95f565a9e906140e2b5550", "filename": "tests/ui/atomic_ordering_fence.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dd06c06183e634b000198958c4ba9dc6d1f0616d/tests%2Fui%2Fatomic_ordering_fence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd06c06183e634b000198958c4ba9dc6d1f0616d/tests%2Fui%2Fatomic_ordering_fence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fatomic_ordering_fence.stderr?ref=dd06c06183e634b000198958c4ba9dc6d1f0616d", "patch": "@@ -0,0 +1,19 @@\n+error: memory fences cannot have `Relaxed` ordering\n+  --> $DIR/atomic_ordering_fence.rs:13:11\n+   |\n+LL |     fence(Ordering::Relaxed);\n+   |           ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::invalid-atomic-ordering` implied by `-D warnings`\n+   = help: consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n+\n+error: memory fences cannot have `Relaxed` ordering\n+  --> $DIR/atomic_ordering_fence.rs:19:20\n+   |\n+LL |     compiler_fence(Ordering::Relaxed);\n+   |                    ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n+\n+error: aborting due to 2 previous errors\n+"}]}