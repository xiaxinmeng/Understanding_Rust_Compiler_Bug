{"sha": "adbe7554d7fa3d0dffae9aa291607d66e6649c84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYmU3NTU0ZDdmYTNkMGRmZmFlOWFhMjkxNjA3ZDY2ZTY2NDljODQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-15T16:03:22Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-15T16:03:22Z"}, "message": "enable Miri to fix the bytes in an allocation (since ptr offsets have different meanings there)", "tree": {"sha": "2487b286517a456e582c35b3ab414b99d771f858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2487b286517a456e582c35b3ab414b99d771f858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adbe7554d7fa3d0dffae9aa291607d66e6649c84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adbe7554d7fa3d0dffae9aa291607d66e6649c84", "html_url": "https://github.com/rust-lang/rust/commit/adbe7554d7fa3d0dffae9aa291607d66e6649c84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adbe7554d7fa3d0dffae9aa291607d66e6649c84/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4b61ba509e71710df5c14ac282fbdd512344072", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b61ba509e71710df5c14ac282fbdd512344072", "html_url": "https://github.com/rust-lang/rust/commit/f4b61ba509e71710df5c14ac282fbdd512344072"}], "stats": {"total": 134, "additions": 65, "deletions": 69}, "files": [{"sha": "6b2d0fc1a0eb8ff0fbee9e63df5dda9b3b773f65", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/adbe7554d7fa3d0dffae9aa291607d66e6649c84/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbe7554d7fa3d0dffae9aa291607d66e6649c84/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=adbe7554d7fa3d0dffae9aa291607d66e6649c84", "patch": "@@ -3,7 +3,7 @@\n use std::borrow::Cow;\n use std::convert::TryFrom;\n use std::iter;\n-use std::ops::{Deref, DerefMut, Range};\n+use std::ops::{Deref, Range};\n use std::ptr;\n \n use rustc_ast::Mutability;\n@@ -156,16 +156,30 @@ impl<Tag> Allocation<Tag> {\n \n impl Allocation {\n     /// Convert Tag and add Extra fields\n-    pub fn with_prov_and_extra<Tag, Extra>(\n+    pub fn convert_tag_add_extra<Tag, Extra>(\n         self,\n-        mut tagger: impl FnMut(AllocId) -> Tag,\n+        cx: &impl HasDataLayout,\n         extra: Extra,\n+        mut tagger: impl FnMut(Pointer<AllocId>) -> Pointer<Tag>,\n     ) -> Allocation<Tag, Extra> {\n+        // Compute new pointer tags, which also adjusts the bytes.\n+        let mut bytes = self.bytes;\n+        let mut new_relocations = Vec::with_capacity(self.relocations.0.len());\n+        let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n+        let endian = cx.data_layout().endian;\n+        for &(offset, alloc_id) in self.relocations.iter() {\n+            let idx = offset.bytes_usize();\n+            let ptr_bytes = &mut bytes[idx..idx + ptr_size];\n+            let bits = read_target_uint(endian, ptr_bytes).unwrap();\n+            let (ptr_tag, ptr_offset) =\n+                tagger(Pointer::new(alloc_id, Size::from_bytes(bits))).into_parts();\n+            write_target_uint(endian, ptr_bytes, ptr_offset.bytes().into()).unwrap();\n+            new_relocations.push((offset, ptr_tag));\n+        }\n+        // Create allocation.\n         Allocation {\n-            bytes: self.bytes,\n-            relocations: Relocations::from_presorted(\n-                self.relocations.iter().map(|&(offset, tag)| (offset, tagger(tag))).collect(),\n-            ),\n+            bytes,\n+            relocations: Relocations::from_presorted(new_relocations),\n             init_mask: self.init_mask,\n             align: self.align,\n             mutability: self.mutability,\n@@ -377,7 +391,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n \n         // See if we have to also write a relocation.\n         if let Some(provenance) = provenance {\n-            self.relocations.insert(range.start, provenance);\n+            self.relocations.0.insert(range.start, provenance);\n         }\n \n         Ok(())\n@@ -437,7 +451,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         }\n \n         // Forget all the relocations.\n-        self.relocations.remove_range(first..last);\n+        self.relocations.0.remove_range(first..last);\n     }\n \n     /// Errors if there are relocations overlapping with the edges of the\n@@ -597,12 +611,6 @@ impl<Tag> Deref for Relocations<Tag> {\n     }\n }\n \n-impl<Tag> DerefMut for Relocations<Tag> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.0\n-    }\n-}\n-\n /// A partial, owned list of relocations to transfer into another allocation.\n pub struct AllocationRelocations<Tag> {\n     relative_relocations: Vec<(Size, Tag)>,\n@@ -643,7 +651,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n     /// to be clear of relocations.\n     pub fn mark_relocation_range(&mut self, relocations: AllocationRelocations<Tag>) {\n-        self.relocations.insert_presorted(relocations.relative_relocations);\n+        self.relocations.0.insert_presorted(relocations.relative_relocations);\n     }\n }\n "}, {"sha": "323e102b8723b904e8deadc005f055d421b139ec", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/adbe7554d7fa3d0dffae9aa291607d66e6649c84/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbe7554d7fa3d0dffae9aa291607d66e6649c84/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=adbe7554d7fa3d0dffae9aa291607d66e6649c84", "patch": "@@ -7,7 +7,7 @@ use std::fmt::Debug;\n use std::hash::Hash;\n \n use rustc_middle::mir;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::def_id::DefId;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n@@ -310,8 +310,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n     fn init_allocation_extra<'b>(\n-        memory_extra: &Self::MemoryExtra,\n-        tcx: TyCtxt<'tcx>,\n+        mem: &Memory<'mir, 'tcx, Self>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n@@ -441,8 +440,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n \n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n-        _memory_extra: &Self::MemoryExtra,\n-        _tcx: TyCtxt<$tcx>,\n+        _mem: &Memory<$mir, $tcx, Self>,\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<Self::MemoryKind>>,\n@@ -473,10 +471,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     #[inline(always)]\n-    fn ptr_get_alloc(\n-        _mem: &Memory<$mir, $tcx, Self>,\n-        ptr: Pointer<AllocId>,\n-    ) -> (AllocId, Size) {\n+    fn ptr_get_alloc(_mem: &Memory<$mir, $tcx, Self>, ptr: Pointer<AllocId>) -> (AllocId, Size) {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n         (alloc_id, offset)"}, {"sha": "c467665ec77b9886f0c9eb3e281e25e85f0eb2b2", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 37, "deletions": 44, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/adbe7554d7fa3d0dffae9aa291607d66e6649c84/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbe7554d7fa3d0dffae9aa291607d66e6649c84/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=adbe7554d7fa3d0dffae9aa291607d66e6649c84", "patch": "@@ -232,10 +232,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n             \"dynamically allocating global memory\"\n         );\n-        // This is a new allocation, not a new global one, so no `global_base_ptr`.\n-        let alloc = M::init_allocation_extra(&self.extra, self.tcx, id, Cow::Owned(alloc), Some(kind));\n+        let alloc =\n+            M::init_allocation_extra(self, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n-        M::tag_alloc_base_pointer(self, Pointer::new(id, Size::ZERO))\n+        M::tag_alloc_base_pointer(self, Pointer::from(id))\n     }\n \n     pub fn reallocate(\n@@ -334,7 +334,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // Let the machine take some extra action\n         let size = alloc.size();\n-        M::memory_deallocated(&mut self.extra, &mut alloc.extra, ptr.provenance, alloc_range(Size::ZERO, size))?;\n+        M::memory_deallocated(\n+            &mut self.extra,\n+            &mut alloc.extra,\n+            ptr.provenance,\n+            alloc_range(Size::ZERO, size),\n+        )?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(alloc_id, (size, alloc.align));\n@@ -492,21 +497,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// this machine use the same pointer tag, so it is indirected through\n     /// `M::tag_allocation`.\n     fn get_global_alloc(\n-        memory_extra: &M::MemoryExtra,\n-        tcx: TyCtxt<'tcx>,\n+        &self,\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n-        let (alloc, def_id) = match tcx.get_global_alloc(id) {\n+        let (alloc, def_id) = match self.tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n             }\n             Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n             None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n-                assert!(tcx.is_static(def_id));\n-                assert!(!tcx.is_thread_local_static(def_id));\n+                assert!(self.tcx.is_static(def_id));\n+                assert!(!self.tcx.is_thread_local_static(def_id));\n                 // Notice that every static has two `AllocId` that will resolve to the same\n                 // thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n                 // and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n@@ -517,19 +521,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n                 // contains a reference to memory that was created during its evaluation (i.e., not\n                 // to another static), those inner references only exist in \"resolved\" form.\n-                if tcx.is_foreign_item(def_id) {\n+                if self.tcx.is_foreign_item(def_id) {\n                     throw_unsup!(ReadExternStatic(def_id));\n                 }\n \n-                (tcx.eval_static_initializer(def_id)?, Some(def_id))\n+                (self.tcx.eval_static_initializer(def_id)?, Some(def_id))\n             }\n         };\n-        M::before_access_global(memory_extra, id, alloc, def_id, is_write)?;\n+        M::before_access_global(&self.extra, id, alloc, def_id, is_write)?;\n         let alloc = Cow::Borrowed(alloc);\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n         let alloc = M::init_allocation_extra(\n-            memory_extra,\n-            tcx,\n+            self,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n@@ -548,7 +551,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n-            let alloc = Self::get_global_alloc(&self.extra, self.tcx, id, /*is_write*/ false)\n+            let alloc = self.get_global_alloc(id, /*is_write*/ false)\n                 .map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n@@ -619,30 +622,26 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n     ) -> InterpResult<'tcx, (&mut Allocation<M::PointerTag, M::AllocExtra>, &mut M::MemoryExtra)>\n     {\n-        let tcx = self.tcx;\n-        let memory_extra = &mut self.extra;\n-        let a = self.alloc_map.get_mut_or(id, || {\n-            // Need to make a copy, even if `get_global_alloc` is able\n-            // to give us a cheap reference.\n-            let alloc = Self::get_global_alloc(memory_extra, tcx, id, /*is_write*/ true)?;\n+        // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n+        // efficiency even for the common case where the key is in the map.\n+        // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n+        // (Cannot use `get_mut_or` since `get_global_alloc` needs `&self`.)\n+        if self.alloc_map.get_mut(id).is_none() {\n+            // Slow path.\n+            // Allocation not found locally, go look global.\n+            let alloc = self.get_global_alloc(id, /*is_write*/ true)?;\n             let kind = M::GLOBAL_KIND.expect(\n                 \"I got a global allocation that I have to copy but the machine does \\\n                     not expect that to happen\",\n             );\n-            Ok((MemoryKind::Machine(kind), alloc.into_owned()))\n-        });\n-        // Unpack the error type manually because type inference doesn't\n-        // work otherwise (and we cannot help it because `impl Trait`)\n-        match a {\n-            Err(e) => Err(e),\n-            Ok(a) => {\n-                let a = &mut a.1;\n-                if a.mutability == Mutability::Not {\n-                    throw_ub!(WriteToReadOnly(id))\n-                }\n-                Ok((a, memory_extra))\n-            }\n+            self.alloc_map.insert(id, (MemoryKind::Machine(kind), alloc.into_owned()));\n+        }\n+\n+        let (_kind, alloc) = self.alloc_map.get_mut(id).unwrap();\n+        if alloc.mutability == Mutability::Not {\n+            throw_ub!(WriteToReadOnly(id))\n         }\n+        Ok((alloc, &mut self.extra))\n     }\n \n     /// \"Safe\" (bounds and align-checked) allocation access.\n@@ -737,7 +736,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n-        trace!(\"reading fn ptr: {}\", id);\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n@@ -752,6 +750,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n+        trace!(\"get_fn({:?})\", ptr);\n         let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(ptr.erase_for_fmt()))\n@@ -1046,12 +1045,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // since we don't want to keep any relocations at the target.\n         // (`get_bytes_with_uninit_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n-        let relocations = src_alloc.prepare_relocation_copy(\n-            self,\n-            src_range,\n-            dest_offset,\n-            num_copies,\n-        );\n+        let relocations =\n+            src_alloc.prepare_relocation_copy(self, src_range, dest_offset, num_copies);\n         // Prepare a copy of the initialization mask.\n         let compressed = src_alloc.compress_uninit_range(src_range);\n         // This checks relocation edges on the src.\n@@ -1064,9 +1059,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let (dest_alloc, extra) = self.get_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n         M::memory_written(extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n-        let dest_bytes = dest_alloc\n-            .get_bytes_mut_ptr(&tcx, dest_range)\n-            .as_mut_ptr();\n+        let dest_bytes = dest_alloc.get_bytes_mut_ptr(&tcx, dest_range).as_mut_ptr();\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range"}]}