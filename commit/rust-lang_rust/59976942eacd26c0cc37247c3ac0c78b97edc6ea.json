{"sha": "59976942eacd26c0cc37247c3ac0c78b97edc6ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OTc2OTQyZWFjZDI2YzBjYzM3MjQ3YzNhYzBjNzhiOTdlZGM2ZWE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-09-24T11:41:09Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-10-07T02:49:53Z"}, "message": "Use slice syntax instead of slice_to, etc.", "tree": {"sha": "81df79265eb8601f2965303b9626b80ee728208f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81df79265eb8601f2965303b9626b80ee728208f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59976942eacd26c0cc37247c3ac0c78b97edc6ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59976942eacd26c0cc37247c3ac0c78b97edc6ea", "html_url": "https://github.com/rust-lang/rust/commit/59976942eacd26c0cc37247c3ac0c78b97edc6ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59976942eacd26c0cc37247c3ac0c78b97edc6ea/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5ba2f5517b1f90d07969ca3facdf5132e42436c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ba2f5517b1f90d07969ca3facdf5132e42436c", "html_url": "https://github.com/rust-lang/rust/commit/b5ba2f5517b1f90d07969ca3facdf5132e42436c"}], "stats": {"total": 630, "additions": 313, "deletions": 317}, "files": [{"sha": "b39ad46bc86af9747948792b4322a2d2c9caa817", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -874,7 +874,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n+        props.error_patterns[next_err_idx..];\n     if missing_patterns.len() == 1u {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),"}, {"sha": "9f26c0980131f447ce66ef28cf467551c290e3d1", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -194,7 +194,7 @@ impl Bitv {\n         if start > self.storage.len() {\n             start = self.storage.len();\n         }\n-        let mut iter = self.storage.slice_from(start).iter();\n+        let mut iter = self.storage[start..].iter();\n         MaskWords {\n           next_word: iter.next(),\n           iter: iter,"}, {"sha": "c9c824ac9cebff78a3bd16e7c58920fd796375d5", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -271,7 +271,7 @@ impl<T> RingBuf<T> {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>().as_slice(), b);\n+    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n@@ -291,7 +291,7 @@ impl<T> RingBuf<T> {\n         } else {\n             // Items to iterate goes from start_index to end_index:\n             let (empty, elts) = self.elts.split_at_mut(0);\n-            let remaining1 = elts.slice_mut(start_index, end_index);\n+            let remaining1 = elts[mut start_index..end_index];\n             MutItems { remaining1: remaining1,\n                                  remaining2: empty,\n                                  nelts: self.nelts }"}, {"sha": "2ea1b2607ff55e63c5d679586b91b52236def5f7", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -44,14 +44,16 @@\n //!\n //! A number of traits add methods that allow you to accomplish tasks with slices.\n //! These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n-//! and `MutableSlice`, defined for `&mut [T]` types.\n+//! `MutableSlice`, defined for `&mut [T]` types, and `Slice` and `SliceMut`\n+//! which are defined for `[T]`.\n //!\n-//! An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n-//! a `Vec` or another slice from the index interval `[a, b)`:\n+//! An example is the `slice` method which enables slicing syntax `[a..b]` that\n+//! returns an immutable \"view\" into a `Vec` or another slice from the index\n+//! interval `[a, b)`:\n //!\n //! ```rust\n //! let numbers = [0i, 1i, 2i];\n-//! let last_numbers = numbers.slice(1, 3);\n+//! let last_numbers = numbers[1..3];\n //! // last_numbers is now &[1i, 2i]\n //! ```\n //!\n@@ -610,7 +612,7 @@ impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n \n     #[inline]\n     fn move_from(self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(src[mut start..end].iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n@@ -702,7 +704,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self.slice_from_mut(i).reverse();\n+        self[mut i..].reverse();\n \n         true\n     }\n@@ -723,7 +725,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self.slice_from_mut(i).reverse();\n+        self[mut i..].reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -990,24 +992,24 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1i, 2, 3, 4];\n-        let v_a = vec_fixed.slice(1u, vec_fixed.len()).to_vec();\n+        let v_a = vec_fixed[1u..vec_fixed.len()].to_vec();\n         assert_eq!(v_a.len(), 3u);\n         let v_a = v_a.as_slice();\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n-        let vec_stack = &[1i, 2, 3];\n-        let v_b = vec_stack.slice(1u, 3u).to_vec();\n+        let vec_stack: &[_] = &[1i, 2, 3];\n+        let v_b = vec_stack[1u..3u].to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique.slice(1u, 6u).to_vec();\n+        let v_d = vec_unique[1u..6u].to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n@@ -1020,21 +1022,21 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec.slice_from(0), vec);\n+        assert_eq!(vec[0..], vec);\n         let b: &[int] = &[3, 4];\n-        assert_eq!(vec.slice_from(2), b);\n+        assert_eq!(vec[2..], b);\n         let b: &[int] = &[];\n-        assert_eq!(vec.slice_from(4), b);\n+        assert_eq!(vec[4..], b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec.slice_to(4), vec);\n+        assert_eq!(vec[..4], vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(vec.slice_to(2), b);\n+        assert_eq!(vec[..2], b);\n         let b: &[int] = &[];\n-        assert_eq!(vec.slice_to(0), b);\n+        assert_eq!(vec[..0], b);\n     }\n \n \n@@ -1975,7 +1977,7 @@ mod tests {\n         assert!(a == [7i,2,3,4]);\n         let mut a = [1i,2,3,4,5];\n         let b = vec![5i,6,7,8,9,0];\n-        assert_eq!(a.slice_mut(2,4).move_from(b,1,6), 2);\n+        assert_eq!(a[mut 2..4].move_from(b,1,6), 2);\n         assert!(a == [1i,2,6,7,5]);\n     }\n \n@@ -1995,7 +1997,7 @@ mod tests {\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1i,2,3,4,5];\n-        values.slice_mut(1, 4).reverse();\n+        values[mut 1..4].reverse();\n         assert!(values == [1,4,3,2,5]);\n     }\n \n@@ -2042,9 +2044,9 @@ mod tests {\n     fn test_bytes_set_memory() {\n         use slice::bytes::MutableByteVector;\n         let mut values = [1u8,2,3,4,5];\n-        values.slice_mut(0,5).set_memory(0xAB);\n+        values[mut 0..5].set_memory(0xAB);\n         assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-        values.slice_mut(2,4).set_memory(0xFF);\n+        values[mut 2..4].set_memory(0xFF);\n         assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n     }\n \n@@ -2070,12 +2072,18 @@ mod tests {\n         let mut values = [1u8,2,3,4,5];\n         {\n             let (left, right) = values.split_at_mut(2);\n-            assert!(left.slice(0, left.len()) == [1, 2]);\n+            {\n+                let left: &[_] = left;\n+                assert!(left[0..left.len()] == [1, 2]);\n+            }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n-            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n+            {\n+                let right: &[_] = right;\n+                assert!(right[0..right.len()] == [3, 4, 5]);\n+            }\n             for p in right.iter_mut() {\n                 *p += 2;\n             }\n@@ -2099,7 +2107,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v.slice(1, 3).iter() {\n+        for f in v[1..3].iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "3976367a76ad5e5b5738514184332bb2647caf08", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -1678,7 +1678,7 @@ mod tests {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n+            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n             if Some(c) != s.chars().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n@@ -1690,7 +1690,7 @@ mod tests {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n+            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }"}, {"sha": "19edc1d2b007c19b100e17eb9e3b57a9afbd3f7b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -160,7 +160,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(v.slice_to(i))\n+                res.as_mut_vec().push_all(v[..i])\n             };\n         }\n \n@@ -177,7 +177,7 @@ impl String {\n             macro_rules! error(() => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.as_mut_vec().push_all(v.slice(subseqidx, i_));\n+                        res.as_mut_vec().push_all(v[subseqidx..i_]);\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n@@ -246,7 +246,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.as_mut_vec().push_all(v.slice(subseqidx, total))\n+                res.as_mut_vec().push_all(v[subseqidx..total])\n             };\n         }\n         Owned(res.into_string())"}, {"sha": "04175173febe6e8ba628351f87a35ca74f67e381", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -24,6 +24,7 @@ use core::fmt;\n use core::fmt::Show;\n use core::mem::zeroed;\n use core::mem;\n+use core::ops::{Slice,SliceMut};\n use core::uint;\n use core::iter;\n use std::hash::{Writer, Hash};\n@@ -378,7 +379,7 @@ macro_rules! bound {\n                         }\n                     };\n                     // push to the stack.\n-                    it.stack[it.length] = children.$slice_from(slice_idx).$iter();\n+                    it.stack[it.length] = children.$slice_from(&slice_idx).$iter();\n                     it.length += 1;\n                     if ret { return it }\n                 })\n@@ -392,7 +393,7 @@ impl<T> TrieMap<T> {\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n         bound!(Entries, self = self,\n                key = key, is_upper = upper,\n-               slice_from = slice_from, iter = iter,\n+               slice_from = slice_from_, iter = iter,\n                mutability = )\n     }\n \n@@ -434,7 +435,7 @@ impl<T> TrieMap<T> {\n     fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n         bound!(MutEntries, self = self,\n                key = key, is_upper = upper,\n-               slice_from = slice_from_mut, iter = iter_mut,\n+               slice_from = slice_from_mut_, iter = iter_mut,\n                mutability = mut)\n     }\n "}, {"sha": "7b4cf4900f2456feb05c641e53741bab921812ff", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -438,7 +438,7 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let slice = other.slice_from(self.len());\n+        let slice = other[self.len()..];\n         self.push_all(slice);\n     }\n }\n@@ -933,11 +933,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice(0, 2) == [1, 2]);\n+    /// assert!(vec[0..2] == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        self.as_slice().slice(start, end)\n+        self[start..end]\n     }\n \n     /// Returns a slice containing all but the first element of the vector.\n@@ -954,7 +954,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn tail<'a>(&'a self) -> &'a [T] {\n-        self.as_slice().tail()\n+        self[].tail()\n     }\n \n     /// Returns all but the first `n' elements of a vector.\n@@ -973,7 +973,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[deprecated = \"use slice_from\"]\n     pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n-        self.as_slice().slice_from(n)\n+        self[n..]\n     }\n \n     /// Returns a reference to the last element of a vector, or `None` if it is\n@@ -987,7 +987,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn last<'a>(&'a self) -> Option<&'a T> {\n-        self.as_slice().last()\n+        self[].last()\n     }\n \n     /// Deprecated: use `last_mut`.\n@@ -1181,10 +1181,10 @@ impl<T> Vec<T> {\n     }\n \n     /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_mut\"]\n+    #[deprecated = \"use slice_from\"]\n     pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self.slice_mut(start, end)\n+        self[mut start..end]\n     }\n \n     /// Returns a mutable slice of `self` between `start` and `end`.\n@@ -1198,18 +1198,18 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice_mut(0, 2) == [1, 2]);\n+    /// assert!(vec[mut 0..2] == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self.as_mut_slice().slice_mut(start, end)\n+        self[mut start..end]\n     }\n \n     /// Deprecated: use \"slice_from_mut\".\n     #[deprecated = \"use slice_from_mut\"]\n     pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self.slice_from_mut(start)\n+        self[mut start..]\n     }\n \n     /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n@@ -1222,17 +1222,17 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice_from_mut(2) == [3, 4]);\n+    /// assert!(vec[mut 2..] == [3, 4]);\n     /// ```\n     #[inline]\n     pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_mut(start)\n+        self[mut start..]\n     }\n \n     /// Deprecated: use `slice_to_mut`.\n     #[deprecated = \"use slice_to_mut\"]\n     pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self.slice_to_mut(end)\n+        self[mut ..end]\n     }\n \n     /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n@@ -1245,11 +1245,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice_to_mut(2) == [1, 2]);\n+    /// assert!(vec[mut ..2] == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_mut(end)\n+        self[mut ..end]\n     }\n \n     /// Deprecated: use `split_at_mut`.\n@@ -1294,7 +1294,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self.as_mut_slice().split_at_mut(mid)\n+        self[mut].split_at_mut(mid)\n     }\n \n     /// Reverses the order of elements in a vector, in place.\n@@ -1308,7 +1308,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn reverse(&mut self) {\n-        self.as_mut_slice().reverse()\n+        self[mut].reverse()\n     }\n \n     /// Returns a slice of `self` from `start` to the end of the vec.\n@@ -1321,11 +1321,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.slice_from(1) == [2, 3]);\n+    /// assert!(vec[1..] == [2, 3]);\n     /// ```\n     #[inline]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        self.as_slice().slice_from(start)\n+        self[start..]\n     }\n \n     /// Returns a slice of self from the start of the vec to `end`.\n@@ -1338,11 +1338,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice_to(2) == [1, 2]);\n+    /// assert!(vec[..2] == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        self.as_slice().slice_to(end)\n+        self[..end]\n     }\n \n     /// Returns a slice containing all but the last element of the vector.\n@@ -1359,7 +1359,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn init<'a>(&'a self) -> &'a [T] {\n-        self.slice(0, self.len() - 1)\n+        self[0..self.len() - 1]\n     }\n \n \n@@ -2244,12 +2244,18 @@ mod tests {\n         let mut values = Vec::from_slice([1u8,2,3,4,5]);\n         {\n             let (left, right) = values.split_at_mut(2);\n-            assert!(left.slice(0, left.len()) == [1, 2]);\n+            {\n+                let left: &[_] = left;\n+                assert!(left[0..left.len()] == [1, 2]);\n+            }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n-            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n+            {\n+                let right: &[_] = right;\n+                assert!(right[0..right.len()] == [3, 4, 5]);\n+            }\n             for p in right.iter_mut() {\n                 *p += 2;\n             }"}, {"sha": "343ab7cfd28b98e7ec9733dc11a10f7dd5aa3166", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,7 @@ use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n use num::{Zero, One, cast};\n use result::Ok;\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::MutableSlice;\n use slice;\n use str::StrSlice;\n \n@@ -173,7 +173,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         _ => ()\n     }\n \n-    buf.slice_to_mut(end).reverse();\n+    buf[mut ..end].reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n \n             impl<'a> fmt::FormatWriter for Filler<'a> {\n                 fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n+                    slice::bytes::copy_memory(self.buf[mut *self.end..],\n                                               bytes);\n                     *self.end += bytes.len();\n                     Ok(())\n@@ -328,5 +328,5 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         }\n     }\n \n-    f(buf.slice_to(end))\n+    f(buf[..end])\n }"}, {"sha": "28ee522346f2f41e6046e25ec1508f8b7b3956cb", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -423,7 +423,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0, ..4];\n                 let n = c.encode_utf8(b).unwrap_or(0);\n-                try!(f.buf.write(b.slice_to(n)));\n+                try!(f.buf.write(b[..n]));\n             }\n             if prefixed { f.buf.write(prefix.as_bytes()) }\n             else { Ok(()) }\n@@ -530,13 +530,13 @@ impl<'a> Formatter<'a> {\n         let len = self.fill.encode_utf8(fill).unwrap_or(0);\n \n         for _ in range(0, pre_pad) {\n-            try!(self.buf.write(fill.slice_to(len)));\n+            try!(self.buf.write(fill[..len]));\n         }\n \n         try!(f(self));\n \n         for _ in range(0, post_pad) {\n-            try!(self.buf.write(fill.slice_to(len)));\n+            try!(self.buf.write(fill[..len]));\n         }\n \n         Ok(())\n@@ -611,7 +611,7 @@ impl Char for char {\n \n         let mut utf8 = [0u8, ..4];\n         let amt = self.encode_utf8(utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n+        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n         secret_string(&s, f)\n     }\n }"}, {"sha": "e57c499948362576932b274fd6721d0f1c1374af", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -18,7 +18,7 @@ use collections::Collection;\n use fmt;\n use iter::DoubleEndedIterator;\n use num::{Int, cast, zero};\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::{MutableSlice};\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -60,7 +60,7 @@ trait GenericRadix {\n                 if x == zero() { break; }                 // No more digits left to accumulate.\n             }\n         }\n-        f.pad_integral(is_positive, self.prefix(), buf.slice_from(curr))\n+        f.pad_integral(is_positive, self.prefix(), buf[curr..])\n     }\n }\n "}, {"sha": "e1afd1a647a123e0bfa91d90403655dad0b31b56", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -67,23 +67,23 @@ pub trait ImmutableSlice<'a, T> {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n     fn slice(&self, start: uint, end: uint) -> &'a [T];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Fails when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n     fn slice_from(&self, start: uint) -> &'a [T];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Fails when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n     fn slice_to(&self, end: uint) -> &'a [T];\n \n     /// Divides one slice into two at an index.\n@@ -262,7 +262,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None }\n      *     let head = &self[0];\n-     *     *self = self.slice_from(1);\n+     *     *self = self[1..];\n      *     Some(head)\n      * ```\n      *\n@@ -281,7 +281,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &self[self.len() - 1];\n-     *     *self = self.slice_to(self.len() - 1);\n+     *     *self = self[..self.len() - 1];\n      *     Some(tail)\n      * ```\n      *\n@@ -299,9 +299,9 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n         assert!(end <= self.len());\n         unsafe {\n             transmute(RawSlice {\n-                    data: self.as_ptr().offset(start as int),\n-                    len: (end - start)\n-                })\n+                data: self.as_ptr().offset(start as int),\n+                len: (end - start)\n+            })\n         }\n     }\n \n@@ -317,7 +317,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n \n     #[inline]\n     fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]) {\n-        (self.slice(0, mid), self.slice(mid, self.len()))\n+        ((*self)[..mid], (*self)[mid..])\n     }\n \n     #[inline]\n@@ -386,21 +386,21 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n+    fn tail(&self) -> &'a [T] { (*self)[1..] }\n \n     #[inline]\n     #[deprecated = \"use slice_from\"]\n-    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n+    fn tailn(&self, n: uint) -> &'a [T] { (*self)[n..] }\n \n     #[inline]\n     fn init(&self) -> &'a [T] {\n-        self.slice(0, self.len() - 1)\n+        (*self)[..self.len() - 1]\n     }\n \n     #[inline]\n     #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T] {\n-        self.slice(0, self.len() - n)\n+        (*self)[..self.len() - n]\n     }\n \n     #[inline]\n@@ -556,7 +556,7 @@ pub trait MutableSlice<'a, T> {\n     fn as_mut_slice(self) -> &'a mut [T];\n \n     /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_mut\"]\n+    #[deprecated = \"slice_mut\"]\n     fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n         self.slice_mut(start, end)\n     }\n@@ -681,7 +681,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let head = &mut self[0];\n-     *     *self = self.slice_from_mut(1);\n+     *     *self = self[mut 1..];\n      *     Some(head)\n      * ```\n      *\n@@ -700,7 +700,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &mut self[self.len() - 1];\n-     *     *self = self.slice_to_mut(self.len() - 1);\n+     *     *self = self[mut ..self.len() - 1];\n      *     Some(tail)\n      * ```\n      *\n@@ -826,33 +826,24 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     fn as_mut_slice(self) -> &'a mut [T] { self }\n \n     fn slice_mut(self, start: uint, end: uint) -> &'a mut [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_mut_ptr().offset(start as int) as *const T,\n-                    len: (end - start)\n-                })\n-        }\n+        self[mut start..end]\n     }\n \n     #[inline]\n     fn slice_from_mut(self, start: uint) -> &'a mut [T] {\n-        let len = self.len();\n-        self.slice_mut(start, len)\n+        self[mut start..]\n     }\n \n     #[inline]\n     fn slice_to_mut(self, end: uint) -> &'a mut [T] {\n-        self.slice_mut(0, end)\n+        self[mut ..end]\n     }\n \n     #[inline]\n     fn split_at_mut(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n-            let len = self.len();\n             let self2: &'a mut [T] = mem::transmute_copy(&self);\n-            (self.slice_mut(0, mid), self2.slice_mut(mid, len))\n+            (self[mut ..mid], self2[mut mid..])\n         }\n     }\n \n@@ -889,13 +880,13 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn tail_mut(self) -> &'a mut [T] {\n         let len = self.len();\n-        self.slice_mut(1, len)\n+        self[mut 1..len]\n     }\n \n     #[inline]\n     fn init_mut(self) -> &'a mut [T] {\n         let len = self.len();\n-        self.slice_mut(0, len - 1)\n+        self[mut 0..len - 1]\n     }\n \n     #[inline]\n@@ -1042,13 +1033,13 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle == self.slice_to(n)\n+        self.len() >= n && needle == (*self)[..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == self.slice_from(m - n)\n+        m >= n && needle == (*self)[m-n..]\n     }\n }\n \n@@ -1339,8 +1330,8 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v.slice(0, idx));\n-                self.v = self.v.slice(idx + 1, self.v.len());\n+                let ret = Some(self.v[..idx]);\n+                self.v = self.v[idx + 1..];\n                 ret\n             }\n         }\n@@ -1365,8 +1356,8 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n-                self.v = self.v.slice(0, idx);\n+                let ret = Some(self.v[idx + 1..]);\n+                self.v = self.v[..idx];\n                 ret\n             }\n         }\n@@ -1416,7 +1407,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail.slice_from_mut(1);\n+                self.v = tail[mut 1..];\n                 Some(head)\n             }\n         }\n@@ -1450,7 +1441,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail.slice_from_mut(1))\n+                Some(tail[mut 1..])\n             }\n         }\n     }\n@@ -1498,8 +1489,8 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(1, self.v.len());\n+            let ret = Some(self.v[..self.size]);\n+            self.v = self.v[1..];\n             ret\n         }\n     }\n@@ -1583,7 +1574,7 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n             let mut hi = lo + self.size;\n             if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-            Some(self.v.slice(lo, hi))\n+            Some(self.v[lo..hi])\n         } else {\n             None\n         }"}, {"sha": "f3a10a0a3ae908edd663a5f8bdf513749cbf3abc", "filename": "src/libcore/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -30,7 +30,7 @@ use iter::range;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::ImmutableSlice;\n use slice;\n use uint;\n \n@@ -393,7 +393,7 @@ impl NaiveSearcher {\n \n     fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n-            if haystack.slice(self.position, self.position + needle.len()) == needle {\n+            if haystack[self.position .. self.position + needle.len()] == needle {\n                 let match_pos = self.position;\n                 self.position += needle.len(); // add 1 for all matches\n                 return Some((match_pos, match_pos + needle.len()));\n@@ -514,10 +514,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // v.slice_to(period). If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if needle.slice_to(crit_pos) == needle.slice(period, period + crit_pos) {\n+        if needle[..crit_pos] == needle[period.. period + crit_pos] {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -741,7 +741,7 @@ impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n \n         let mut buf = [0u16, ..2];\n         self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n+            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })\n@@ -1007,7 +1007,7 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n-        Some(i) => v.slice_to(i),\n+        Some(i) => v[..i],\n         None => v\n     }\n }\n@@ -1994,13 +1994,13 @@ impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes().slice_to(n)\n+        self.len() >= n && needle.as_bytes() == self.as_bytes()[..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n+        m >= n && needle.as_bytes() == self.as_bytes()[m-n..]\n     }\n \n     #[inline]"}, {"sha": "9628d7950b5cf0c35b83e3ec9400fa818ae1ccd6", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -174,7 +174,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8, ..4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf.slice_to(n), expect);\n+        assert_eq!(buf[..n], expect);\n     }\n \n     check('x', [0x78]);\n@@ -188,7 +188,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16, ..2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf.slice_to(n), expect);\n+        assert_eq!(buf[..n], expect);\n     }\n \n     check('x', [0x0078]);"}, {"sha": "e937d58ca2099234a305acd48757a7e5a6442cde", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -13,6 +13,7 @@ use core::iter::order::*;\n use core::uint;\n use core::cmp;\n use core::num;\n+use core::ops::Slice;\n \n use test::Bencher;\n \n@@ -228,7 +229,7 @@ fn test_inspect() {\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(xs.as_slice(), ys.as_slice());\n+    assert_eq!(xs[], ys[]);\n }\n \n #[test]\n@@ -268,7 +269,7 @@ fn test_cycle() {\n \n #[test]\n fn test_iterator_nth() {\n-    let v = &[0i, 1, 2, 3, 4];\n+    let v: &[_] = &[0i, 1, 2, 3, 4];\n     for i in range(0u, v.len()) {\n         assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n     }\n@@ -277,55 +278,55 @@ fn test_iterator_nth() {\n \n #[test]\n fn test_iterator_last() {\n-    let v = &[0i, 1, 2, 3, 4];\n+    let v: &[_] = &[0i, 1, 2, 3, 4];\n     assert_eq!(v.iter().last().unwrap(), &4);\n-    assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n+    assert_eq!(v[0..1].iter().last().unwrap(), &0);\n }\n \n #[test]\n fn test_iterator_len() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().count(), 4);\n-    assert_eq!(v.slice(0, 10).iter().count(), 10);\n-    assert_eq!(v.slice(0, 0).iter().count(), 0);\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().count(), 4);\n+    assert_eq!(v[0..10].iter().count(), 10);\n+    assert_eq!(v[0..0].iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n-    assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n-    assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().map(|&x| x).product(), 0);\n+    assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n+    assert_eq!(v[0..0].iter().map(|&x| x).product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().map(|&x| x).max(), Some(3));\n     assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-    assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n+    assert_eq!(v[0..0].iter().map(|&x| x).max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n+    assert_eq!(v[0..0].iter().map(|&x| x).min(), None);\n }\n \n #[test]\n fn test_iterator_size_hint() {\n     let c = count(0i, 1);\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let v2 = &[10i, 11, 12];\n     let vi = v.iter();\n \n@@ -372,7 +373,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v.slice(0, 0).iter().all(|_| fail!()));\n+    assert!(v.slice_(&0, &0).iter().all(|_| fail!()));\n }\n \n #[test]\n@@ -381,7 +382,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n+    assert!(!v.slice_(&0, &0).iter().any(|_| fail!()));\n }\n \n #[test]\n@@ -565,7 +566,7 @@ fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, le\n fn test_double_ended_flat_map() {\n     let u = [0u,1];\n     let v = [5u,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n+    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);"}, {"sha": "aa2b1a6f14e6bd39773bca8c4fa5119e714c16fa", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -1012,7 +1012,7 @@ pub fn write<T>(fd: sock_t,\n             // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n             // against unforeseen circumstances.\n             let _guard = lock();\n-            let ptr = buf.slice_from(written).as_ptr();\n+            let ptr = buf[written..].as_ptr();\n             let len = buf.len() - written;\n             match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if util::wouldblock() => {}"}, {"sha": "5475de6d7e1cc4158a7d4d8ed45070c7a240349c", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -448,7 +448,7 @@ impl rtio::RtioPipe for UnixStream {\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n-                                buf.slice_from(offset).as_ptr() as libc::LPVOID,\n+                                buf[offset..].as_ptr() as libc::LPVOID,\n                                 (buf.len() - offset) as libc::DWORD,\n                                 &mut bytes_written,\n                                 &mut overlapped)"}, {"sha": "af2ff747fe9682dc43aca68cdbb9c6f565248af5", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -738,7 +738,7 @@ impl BigUint {\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = cmp::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(buf.slice(start, end), radix) {\n+            match uint::parse_bytes(buf[start..end], radix) {\n                 Some(d) => {\n                     let d: Option<BigUint> = FromPrimitive::from_uint(d);\n                     match d {\n@@ -1409,7 +1409,7 @@ impl BigInt {\n             sign  = Minus;\n             start = 1;\n         }\n-        return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n+        return BigUint::parse_bytes(buf[start..], radix)\n             .map(|bu| BigInt::from_biguint(sign, bu));\n     }\n "}, {"sha": "6d3d0aad4200ba3597a8afea714f522cb554a5bb", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -230,7 +230,7 @@ pub trait Rng {\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = task_rng();\n     /// println!(\"{}\", rng.choose(choices));\n-    /// assert_eq!(rng.choose(choices.slice_to(0)), None);\n+    /// assert_eq!(rng.choose(choices[..0]), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "8917151609f810e3e1fa0f235a05405715c0f324", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -94,15 +94,15 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (buf.slice_to(cap), buf.slice_from(cap))\n+                (buf[..cap], buf[cap..])\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result\n             };\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n+                slice::bytes::copy_memory(self.buf[mut self.pos..], left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "fa327fb3b4c5d14f4fa232b672746b46dbc35190", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -54,7 +54,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n+        str::from_utf8(self.data[self.start..self.end]).unwrap()\n     }\n \n     pub fn as_str(&self) -> String {\n@@ -280,7 +280,7 @@ pub mod reader {\n     }\n \n     pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n-        f(d.data.slice(d.start, d.end))\n+        f(d.data[d.start..d.end])\n     }\n \n "}, {"sha": "a32dfcf5d2a2b89121332272a8ab45c81cb3a323", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -102,7 +102,7 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = String::with_capacity(5);\n-        for inst in c.insts.slice_from(1).iter() {\n+        for inst in c.insts[1..].iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break"}, {"sha": "bf576432631391e7a91714146994d1187032188e", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -511,7 +511,7 @@ impl<'a> Parser<'a> {\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n         let inner = String::from_chars(\n-            self.chars.as_slice().slice(start + 1, closer));\n+            self.chars[start+1..closer]);\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n@@ -944,7 +944,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        String::from_chars(self.chars.as_slice().slice(start, end))\n+        String::from_chars(self.chars[start..end])\n     }\n }\n "}, {"sha": "088425c08885533916fb2b0abb8f735b93cf2cce", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -130,7 +130,7 @@ macro_rules! mat(\n             // actual capture groups to match test set.\n             let (sexpect, mut sgot) = (expected.as_slice(), got.as_slice());\n             if sgot.len() > sexpect.len() {\n-                sgot = sgot.slice(0, sexpect.len())\n+                sgot = sgot[0..sexpect.len()]\n             }\n             if sexpect != sgot {\n                 fail!(\"For RE '{}' against '{}', expected '{}' but got '{}'\","}, {"sha": "0a4dca9125aa60144048662f713e711a252eb8bc", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -145,7 +145,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n                     let needle = self.prog.prefix.as_slice().as_bytes();\n-                    let haystack = self.input.as_bytes().slice_from(self.ic);\n+                    let haystack = self.input.as_bytes()[self.ic..];\n                     match find_prefix(needle, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "67018769fb371b530ecc4ecdd7aa81aacb536cac", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -550,7 +550,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         } else {\n             quote_expr!(self.cx,\n                 if clist.size == 0 {\n-                    let haystack = self.input.as_bytes().slice_from(self.ic);\n+                    let haystack = self.input.as_bytes()[self.ic..];\n                     match find_prefix(prefix_bytes, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "58db79f41ca4ce272c620f856fd2c45b76a3d676", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -89,9 +89,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     if version == 1 {\n                         // The only version existing so far\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = bc_encoded.slice(\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n+                        let compressed_data = bc_encoded[\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint];\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Some(inflated) => inflated,\n@@ -188,7 +188,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           bc.slice(0, magic_id_byte_count) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           bc[..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n@@ -200,8 +200,8 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = bytes.slice(position_in_bytes,\n-                                position_in_bytes + mem::size_of::<T>());\n+    let byte_data = bytes[position_in_bytes..\n+                          position_in_bytes + mem::size_of::<T>()];\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "58d0f132e06a2616276d61e309c512c31ece6cf1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -70,7 +70,7 @@ fn lookup_hash<'a>(d: rbml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n+        if eq_fn(elt.data[elt.start + 4 .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n@@ -84,7 +84,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes.slice(0u, 4u), 0u, 4u) as ast::NodeId\n+            bytes[0u..4u], 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,"}, {"sha": "a07518cf3f2d3ae7538540695d02591230eb09be", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -91,7 +91,7 @@ fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(st.data.slice(start_pos, end_pos));\n+    return op(st.data[start_pos..end_pos]);\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n@@ -598,8 +598,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         fail!();\n     }\n \n-    let crate_part = buf.slice(0u, colon_idx);\n-    let def_part = buf.slice(colon_idx + 1u, len);\n+    let crate_part = buf[0u..colon_idx];\n+    let def_part = buf[colon_idx + 1u..len];\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "92f04b108c19b8f428621635454195c303dbdf31", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -865,7 +865,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             None\n         }\n     };\n-    head.map(|head| head.append(r.slice_to(col)).append(r.slice_from(col + 1)))\n+    head.map(|head| head.append(r[..col]).append(r[col + 1..]))\n }\n \n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {"}, {"sha": "595739585a398cd7785cfbbce8a54f55c30d58b8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -4019,7 +4019,7 @@ impl<'a> Resolver<'a> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.find_copy(&name) {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs.slice_from(i + 1), def_like, span);\n+                    return self.upvarify(ribs[i + 1..], def_like, span);\n                 }\n                 None => {\n                     // Continue."}, {"sha": "debcfe3933c0388192b0368839b842f8bab87438", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -193,7 +193,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = sub_paths.slice(0, len-2);\n+        let sub_paths = sub_paths[..len-2];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,"}, {"sha": "38f09d19572525ace14f6938f4826fdc946a213a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -473,7 +473,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            Some(Vec::from_slice(pats.slice_to(col)).append(pats.slice_from(col + 1)))\n+            Some(Vec::from_slice(pats[..col]).append(pats[col + 1..]))\n         } else {\n             None\n         }\n@@ -948,7 +948,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = compile_guard(bcx,\n                                     &**guard_expr,\n                                     m[0].data,\n-                                    m.slice(1, m.len()),\n+                                    m[1..m.len()],\n                                     vals,\n                                     chk,\n                                     has_genuine_default);\n@@ -987,7 +987,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let vals_left = Vec::from_slice(vals.slice(0u, col)).append(vals.slice(col + 1u, vals.len()));\n+    let vals_left = Vec::from_slice(vals[0u..col]).append(vals[col + 1u..vals.len()]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but"}, {"sha": "11cf24027825b50e1c8f0b43643008fb649eea8e", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -550,7 +550,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n+            self.inbounds_gep(base, small_vec[..ixs.len()])\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");"}, {"sha": "7fbfe43c208ffd008c16c459cd6348600d6f6283", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -937,7 +937,7 @@ pub fn create_captured_var_metadata(bcx: Block,\n \n     let variable_access = IndirectVariable {\n         alloca: env_pointer,\n-        address_operations: address_operations.slice_to(address_op_count)\n+        address_operations: address_operations[..address_op_count]\n     };\n \n     declare_local(bcx,"}, {"sha": "4d21090dd2c2aa14baa1b7d145b9881d101ee388", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -330,7 +330,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n         }\n     }\n \n-    for param in ty_param_defs.slice_from(supplied_ty_param_count).iter() {\n+    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter."}, {"sha": "cdc375b258da7fef3bc2dcb27140b8cf396c88b5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -3033,7 +3033,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args.slice_from(1).iter().map(|x| x).collect();\n+        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,"}, {"sha": "6898eb17e917011ba767cb5cebd02894e79052ee", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -489,7 +489,7 @@ pub fn parameterized(cx: &ctxt,\n         0\n     };\n \n-    for t in tps.slice_to(tps.len() - num_defaults).iter() {\n+    for t in tps[..tps.len() - num_defaults].iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n "}, {"sha": "bf8d993964ff9b3ccd08f3533973347e8edbf2fa", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -136,14 +136,14 @@ impl FixedBuffer for FixedBuffer64 {\n             let buffer_remaining = size - self.buffer_idx;\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n-                        self.buffer.slice_mut(self.buffer_idx, size),\n-                        input.slice_to(buffer_remaining));\n+                        self.buffer[mut self.buffer_idx..size],\n+                        input[..buffer_remaining]);\n                 self.buffer_idx = 0;\n                 func(self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n-                    self.buffer.slice_mut(self.buffer_idx, self.buffer_idx + input.len()),\n+                    self.buffer[mut self.buffer_idx..self.buffer_idx + input.len()],\n                     input);\n                 self.buffer_idx += input.len();\n                 return;\n@@ -153,7 +153,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(input.slice(i, i + size));\n+            func(input[i..i + size]);\n             i += size;\n         }\n \n@@ -162,8 +162,8 @@ impl FixedBuffer for FixedBuffer64 {\n         // be empty.\n         let input_remaining = input.len() - i;\n         copy_memory(\n-            self.buffer.slice_mut(0, input_remaining),\n-            input.slice_from(i));\n+            self.buffer[mut ..input_remaining],\n+            input[i..]);\n         self.buffer_idx += input_remaining;\n     }\n \n@@ -173,19 +173,19 @@ impl FixedBuffer for FixedBuffer64 {\n \n     fn zero_until(&mut self, idx: uint) {\n         assert!(idx >= self.buffer_idx);\n-        self.buffer.slice_mut(self.buffer_idx, idx).set_memory(0);\n+        self.buffer[mut self.buffer_idx..idx].set_memory(0);\n         self.buffer_idx = idx;\n     }\n \n     fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n         self.buffer_idx += len;\n-        return self.buffer.slice_mut(self.buffer_idx - len, self.buffer_idx);\n+        return self.buffer[mut self.buffer_idx - len..self.buffer_idx];\n     }\n \n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return self.buffer.slice_to(64);\n+        return self.buffer[..64];\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }\n@@ -359,7 +359,7 @@ impl Engine256State {\n              )\n         )\n \n-        read_u32v_be(w.slice_mut(0, 16), data);\n+        read_u32v_be(w[mut 0..16], data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n@@ -495,14 +495,14 @@ impl Digest for Sha256 {\n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        write_u32_be(out.slice_mut(0, 4), self.engine.state.h0);\n-        write_u32_be(out.slice_mut(4, 8), self.engine.state.h1);\n-        write_u32_be(out.slice_mut(8, 12), self.engine.state.h2);\n-        write_u32_be(out.slice_mut(12, 16), self.engine.state.h3);\n-        write_u32_be(out.slice_mut(16, 20), self.engine.state.h4);\n-        write_u32_be(out.slice_mut(20, 24), self.engine.state.h5);\n-        write_u32_be(out.slice_mut(24, 28), self.engine.state.h6);\n-        write_u32_be(out.slice_mut(28, 32), self.engine.state.h7);\n+        write_u32_be(out[mut 0..4], self.engine.state.h0);\n+        write_u32_be(out[mut 4..8], self.engine.state.h1);\n+        write_u32_be(out[mut 8..12], self.engine.state.h2);\n+        write_u32_be(out[mut 12..16], self.engine.state.h3);\n+        write_u32_be(out[mut 16..20], self.engine.state.h4);\n+        write_u32_be(out[mut 20..24], self.engine.state.h5);\n+        write_u32_be(out[mut 24..28], self.engine.state.h6);\n+        write_u32_be(out[mut 28..32], self.engine.state.h7);\n     }\n \n     fn reset(&mut self) {"}, {"sha": "5c78bb976f1e33f0e54d7569cef3381d7ac028db", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -720,7 +720,7 @@ impl Clean<Item> for ast::Method {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n-            _ => all_inputs.slice_from(1)\n+            _ => all_inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -759,7 +759,7 @@ impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs.slice_from(1)\n+            _ => self.decl.inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -1031,7 +1031,7 @@ impl Clean<Item> for ty::Method {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n-                    inputs: self.fty.sig.inputs.slice_from(1).to_vec(),\n+                    inputs: self.fty.sig.inputs[1..].to_vec(),\n                     ..self.fty.sig.clone()\n                 };\n                 let s = match s {"}, {"sha": "ebccb1188cc7554a6ddde0f03f8a4b0963f0c182", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -252,7 +252,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments.slice_to(amt).iter() {\n+                for seg in path.segments[..amt].iter() {\n                     if \"super\" == seg.name.as_slice() ||\n                             \"self\" == seg.name.as_slice() {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -267,7 +267,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n                 }\n             }\n             None => {\n-                for seg in path.segments.slice_to(amt).iter() {\n+                for seg in path.segments[..amt].iter() {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }\n@@ -278,7 +278,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n-            let to_link = fqp.slice_to(fqp.len() - 1);\n+            let to_link = fqp[..fqp.len() - 1];\n             for component in to_link.iter() {\n                 url.push_str(component.as_slice());\n                 url.push_str(\"/\");"}, {"sha": "e9d65b0a40cf2135c55f1c169582c179bdc21006", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -394,7 +394,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     search_index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n-                        path: fqp.slice_to(fqp.len() - 1).connect(\"::\"),\n+                        path: fqp[..fqp.len() - 1].connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n                     });\n@@ -549,7 +549,7 @@ fn write_shared(cx: &Context,\n         };\n \n         let mut mydst = dst.clone();\n-        for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n+        for part in remote_path[..remote_path.len() - 1].iter() {\n             mydst.push(part.as_slice());\n             try!(mkdir(&mydst));\n         }\n@@ -829,7 +829,7 @@ impl DocFolder for Cache {\n                     clean::StructFieldItem(..) |\n                     clean::VariantItem(..) => {\n                         ((Some(*self.parent_stack.last().unwrap()),\n-                          Some(self.stack.slice_to(self.stack.len() - 1))),\n+                          Some(self.stack[..self.stack.len() - 1])),\n                           false)\n                     }\n                     clean::MethodItem(..) => {\n@@ -840,13 +840,13 @@ impl DocFolder for Cache {\n                             let did = *last;\n                             let path = match self.paths.find(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n-                                    Some(self.stack.slice_to(self.stack.len() - 1)),\n+                                    Some(self.stack[..self.stack.len() - 1]),\n                                 // The current stack not necessarily has correlation for\n                                 // where the type was defined. On the other hand,\n                                 // `paths` always has the right information if present.\n                                 Some(&(ref fqp, item_type::Struct)) |\n                                 Some(&(ref fqp, item_type::Enum)) =>\n-                                    Some(fqp.slice_to(fqp.len() - 1)),\n+                                    Some(fqp[..fqp.len() - 1]),\n                                 Some(..) => Some(self.stack.as_slice()),\n                                 None => None\n                             };\n@@ -1172,7 +1172,7 @@ impl Context {\n                 let mut url = \"../\".repeat(cx.current.len());\n                 match cache_key.get().unwrap().paths.find(&it.def_id) {\n                     Some(&(ref names, _)) => {\n-                        for name in names.slice_to(names.len() - 1).iter() {\n+                        for name in names[..names.len() - 1].iter() {\n                             url.push_str(name.as_slice());\n                             url.push_str(\"/\");\n                         }"}, {"sha": "f07e8ecc335d7c0fda54b1807a6ff27c4e5fbe02", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -562,7 +562,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n     let callbacks = unsafe {\n         let amt = CALLBACK_CNT.load(atomic::SeqCst);\n-        CALLBACKS.slice_to(cmp::min(amt, MAX_CALLBACKS))\n+        CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n     };\n     for cb in callbacks.iter() {\n         match cb.load(atomic::SeqCst) {"}, {"sha": "ab1ef2fc5aa689256ed7a1d8ace7cd185f8536ac", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -64,8 +64,8 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     }\n     impl<'a> FormatWriter for BufWriter<'a> {\n         fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-            let left = self.buf.slice_from_mut(self.pos);\n-            let to_write = bytes.slice_to(cmp::min(bytes.len(), left.len()));\n+            let left = self.buf[mut self.pos..];\n+            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())\n@@ -76,7 +76,7 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     let mut msg = [0u8, ..512];\n     let mut w = BufWriter { buf: msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(w.buf.slice_to(w.pos)).unwrap_or(\"aborted\");\n+    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n     let msg = if msg.is_empty() {\"aborted\"} else {msg};\n \n     // Give some context to the message"}, {"sha": "a9ac5ec3ab4f675001b439515001867efc02eba8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -334,7 +334,7 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n         };\n \n         if start < i {\n-            try!(wr.write(bytes.slice(start, i)));\n+            try!(wr.write(bytes[start..i]));\n         }\n \n         try!(wr.write_str(escaped));\n@@ -343,7 +343,7 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n     }\n \n     if start != bytes.len() {\n-        try!(wr.write(bytes.slice_from(start)));\n+        try!(wr.write(bytes[start..]));\n     }\n \n     wr.write_str(\"\\\"\")\n@@ -371,7 +371,7 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n     }\n \n     if n > 0 {\n-        wr.write(buf.slice_to(n))\n+        wr.write(buf[..n])\n     } else {\n         Ok(())\n     }\n@@ -1151,7 +1151,7 @@ impl Stack {\n             InternalIndex(i) => { Index(i) }\n             InternalKey(start, size) => {\n                 Key(str::from_utf8(\n-                    self.str_buffer.slice(start as uint, start as uint + size as uint)).unwrap())\n+                    self.str_buffer[start as uint .. start as uint + size as uint]).unwrap())\n             }\n         }\n     }\n@@ -1193,7 +1193,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(Key(str::from_utf8(\n-                    self.str_buffer.slice(start as uint, (start+size) as uint)\n+                    self.str_buffer[start as uint .. (start+size) as uint]\n                 ).unwrap()))\n             }\n         }"}, {"sha": "754b440b0de8a873bd29d8b2408fdc907eae8a36", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -90,10 +90,10 @@ impl<R: Reader> BufferedReader<R> {\n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n+            self.cap = try!(self.inner.read(self.buf[mut]));\n             self.pos = 0;\n         }\n-        Ok(self.buf.slice(self.pos, self.cap))\n+        Ok(self.buf[self.pos..self.cap])\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -107,7 +107,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, available.slice_to(nread));\n+            slice::bytes::copy_memory(buf, available[..nread]);\n             nread\n         };\n         self.pos += nread;\n@@ -162,7 +162,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(self.buf.slice_to(self.pos));\n+            let ret = self.inner.as_mut().unwrap().write(self.buf[..self.pos]);\n             self.pos = 0;\n             ret\n         } else {\n@@ -195,7 +195,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         if buf.len() > self.buf.len() {\n             self.inner.as_mut().unwrap().write(buf)\n         } else {\n-            let dst = self.buf.slice_from_mut(self.pos);\n+            let dst = self.buf[mut self.pos..];\n             slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())\n@@ -250,9 +250,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(buf.slice_to(i + 1)));\n+                try!(self.inner.write(buf[..i + 1]));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(buf.slice_from(i + 1)));\n+                try!(self.inner.write(buf[i + 1..]));\n                 Ok(())\n             }\n             None => self.inner.write(buf),"}, {"sha": "5bec131f22251d3e24666fb150947dfa47f15ed1", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -15,8 +15,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n-use slice::{bytes, MutableSlice, ImmutableSlice, CloneableVector};\n-use str::StrSlice;\n+use slice::{bytes, CloneableVector};\n use super::{Reader, Writer, IoResult};\n use vec::Vec;\n \n@@ -62,10 +61,10 @@ impl Reader for ChanReader {\n         loop {\n             match self.buf {\n                 Some(ref prev) => {\n-                    let dst = buf.slice_from_mut(num_read);\n-                    let src = prev.slice_from(self.pos);\n+                    let dst = buf[mut num_read..];\n+                    let src = prev[self.pos..];\n                     let count = cmp::min(dst.len(), src.len());\n-                    bytes::copy_memory(dst, src.slice_to(count));\n+                    bytes::copy_memory(dst, src[..count]);\n                     num_read += count;\n                     self.pos += count;\n                 },"}, {"sha": "82494d41aa3fffdae945b53066fb153558a127c6", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -485,7 +485,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => { break }\n             Err(e) => return update_err(Err(e), from, to)\n         };\n-        try!(writer.write(buf.slice_to(amt)));\n+        try!(writer.write(buf[..amt]));\n     }\n \n     chmod(to, try!(update_err(from.stat(), from, to)).perm)\n@@ -1014,7 +1014,7 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match check!(read_stream.read(read_buf)) {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.slice_to(n)).unwrap().to_string()\n+                n => str::from_utf8(read_buf[..n]).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n         }\n@@ -1061,11 +1061,11 @@ mod test {\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n-                let read_buf = read_mem.slice_mut(0, 4);\n+                let read_buf = read_mem[mut 0..4];\n                 check!(read_stream.read(read_buf));\n             }\n             {\n-                let read_buf = read_mem.slice_mut(4, 8);\n+                let read_buf = read_mem[mut 4..8];\n                 check!(read_stream.read(read_buf));\n             }\n         }"}, {"sha": "ca9692ee1588da2411c7ba887d657c86e9f24248", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -19,7 +19,7 @@ use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n-use slice::{Slice, ImmutableSlice, MutableSlice};\n+use slice::Slice;\n use vec::Vec;\n \n static BUF_CAPACITY: uint = 128;\n@@ -146,8 +146,8 @@ impl Reader for MemReader {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = buf.slice_mut(0, write_len);\n+            let input = self.buf[self.pos.. self.pos + write_len];\n+            let output = buf[mut ..write_len];\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -174,7 +174,7 @@ impl Buffer for MemReader {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf.slice_from(self.pos))\n+            Ok(self.buf[self.pos..])\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -232,7 +232,7 @@ impl<'a> Writer for BufWriter<'a> {\n             })\n         }\n \n-        slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), buf);\n+        slice::bytes::copy_memory(self.buf[mut self.pos..], buf);\n         self.pos += buf.len();\n         Ok(())\n     }\n@@ -292,8 +292,8 @@ impl<'a> Reader for BufReader<'a> {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = buf.slice_mut(0, write_len);\n+            let input = self.buf[self.pos.. self.pos + write_len];\n+            let output = buf[mut ..write_len];\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -320,7 +320,7 @@ impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf.slice_from(self.pos))\n+            Ok(self.buf[self.pos..])\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -427,7 +427,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.slice(0, 3), b);\n+        assert_eq!(buf[0..3], b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -454,7 +454,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.slice(0, 3), b);\n+        assert_eq!(buf[0..3], b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -548,7 +548,7 @@ mod test {\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n         assert_eq!(buf.as_slice(), b);\n-        assert!(r.read_at_least(0, buf.slice_to_mut(0)).is_ok());\n+        assert!(r.read_at_least(0, buf[mut ..0]).is_ok());\n         assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[4, 5, 6];"}, {"sha": "d279b88a1c51ca3d0b431c547efa1a7e4e43f46a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -235,7 +235,7 @@ use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n-use slice::{Slice, MutableSlice, ImmutableSlice};\n+use slice::{Slice, ImmutableSlice};\n use str::{Str, StrSlice};\n use str;\n use string::String;\n@@ -575,7 +575,7 @@ pub trait Reader {\n         while read < min {\n             let mut zeroes = 0;\n             loop {\n-                match self.read(buf.slice_from_mut(read)) {\n+                match self.read(buf[mut read..]) {\n                     Ok(0) => {\n                         zeroes += 1;\n                         if zeroes >= NO_PROGRESS_LIMIT {\n@@ -1111,8 +1111,8 @@ pub trait Writer {\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n-        let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        self.write(buf.slice_to(n))\n+        let n = c.encode_utf8(buf[mut]).unwrap_or(0);\n+        self.write(buf[..n])\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1496,7 +1496,7 @@ pub trait Buffer: Reader {\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(available.slice_to(i + 1));\n+                        res.push_all(available[..i + 1]);\n                         used = i + 1;\n                         break\n                     }\n@@ -1528,14 +1528,14 @@ pub trait Buffer: Reader {\n         {\n             let mut start = 1;\n             while start < width {\n-                match try!(self.read(buf.slice_mut(start, width))) {\n+                match try!(self.read(buf[mut start..width])) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),\n                 }\n             }\n         }\n-        match str::from_utf8(buf.slice_to(width)) {\n+        match str::from_utf8(buf[..width]) {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }"}, {"sha": "5140159e4ea3790f1cdfc139e2744972bff9a158", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -21,7 +21,7 @@ use from_str::FromStr;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str::StrSlice;\n-use slice::{MutableCloneableSlice, ImmutableSlice, MutableSlice};\n+use slice::{MutableCloneableSlice, MutableSlice};\n \n pub type Port = u16;\n \n@@ -241,7 +241,7 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16, ..8];\n             gs.clone_from_slice(head);\n-            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n+            gs[mut 8 - tail.len() .. 8].clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n \n@@ -303,7 +303,7 @@ impl<'a> Parser<'a> {\n \n         let mut tail = [0u16, ..8];\n         let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(head.slice(0, head_size), tail.slice(0, tail_size)))\n+        Some(ipv6_addr_from_head_tail(head[..head_size], tail[..tail_size]))\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {"}, {"sha": "4dd6f448ee504dd6f94030306c0874280c01210f", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -48,7 +48,7 @@ use rt::rtio;\n /// match socket.recv_from(buf) {\n ///     Ok((amt, src)) => {\n ///         // Send a reply to the socket we received data from\n-///         let buf = buf.slice_to_mut(amt);\n+///         let buf = buf[mut ..amt];\n ///         buf.reverse();\n ///         socket.send_to(buf, src);\n ///     }"}, {"sha": "820ae931f320484a3ef7fa8caf5b60c4618d67fd", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -47,7 +47,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(buf.slice_to_mut(len));\n+        let res = self.inner.read(buf[mut ..len]);\n         match res {\n             Ok(len) => self.limit -= len,\n             _ => {}\n@@ -59,7 +59,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n-        let buf = amt.slice_to(cmp::min(amt.len(), self.limit));\n+        let buf = amt[..cmp::min(amt.len(), self.limit)];\n         if buf.len() == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -216,7 +216,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(buf.slice_to(len)).map(|()| len)\n+            self.writer.write(buf[mut ..len]).map(|()| len)\n         })\n     }\n }\n@@ -230,7 +230,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(buf.slice_to(len)));\n+        try!(w.write(buf[..len]));\n     }\n }\n "}, {"sha": "9e4cc06f0a2005c9a5bcec46a7eb2fc85448621a", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "54259fcad55cb700ebaaa3976374a2538445c4ab", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "b5fe6825ca4b4c12fba61d75bf89885e6e32bf45", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "7aa9a41e340386330ea4ee1f9d88d7a107fe4b25", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "74ee61634c6950ed5b95072dc7a32e0fca6fbf4b", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};"}, {"sha": "62e609bb2e18b962878158dcfc1a2a86b30ef86e", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -78,7 +78,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n-    f(buf.slice(0, amt))\n+    f(buf[..amt])\n }\n \n #[deprecated = \"use fmt::radix\"]"}, {"sha": "f97bbe0dc8eab12955d5ffbbdb65e33ee5728e9f", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -730,7 +730,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n         // parse remaining bytes as decimal integer,\n         // skipping the exponent char\n         let exp: Option<int> = from_str_bytes_common(\n-            buf.slice(i+1, len), 10, true, false, false, ExpNone, false,\n+            buf[i+1..len], 10, true, false, false, ExpNone, false,\n             ignore_underscores);\n \n         match exp {"}, {"sha": "c141ecc9cba4ec3ae609e0d21fe4ade2a4cb61ce", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "8a8e2729a5325d4b0764614a882e8c7d8e3497fb", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "1b4f8bc433f15299d28790b89c2482250d1ea3d9", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "28f2242923560ee60869a093813bbfa24d504c95", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "da328074453925a64037b55735fc0d749b1e9355", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};"}, {"sha": "a033308af1616cc182837e78d407036b2804fd1c", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -79,7 +79,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n-    f(buf.slice(0, amt))\n+    f(buf[..amt])\n }\n \n #[deprecated = \"use fmt::radix\"]"}, {"sha": "c6948cccafec8b468808669b7c533653f849567a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -144,7 +144,7 @@ pub mod windows {\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::{MutableSlice, ImmutableSlice};\n+    use slice::MutableSlice;\n     use string::String;\n     use str::StrSlice;\n     use vec::Vec;"}, {"sha": "63c81695affd9c38c3313da4a68628ead7f049b8", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -357,7 +357,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n-                    Some(pos) => name.slice_to(pos)\n+                    Some(pos) => name[..pos]\n                 }\n             })\n         }\n@@ -404,7 +404,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(name.slice_from(pos+1))\n+                    Some(pos) => Some(name[pos+1..])\n                 }\n             }\n         }\n@@ -480,7 +480,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name.slice_to(idx).to_vec()),\n+                (Some(idx), 0) => Some(name[..idx].to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -489,7 +489,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n                     let mut v;\n                     v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(name.slice_to(idx));\n+                    v.push_all(name[..idx]);\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n                     Some(v)"}, {"sha": "2425b40fef4876599c9f3bb4f83a1a36f430948f", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -165,7 +165,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => {\n+            Some(idx) if self.repr[idx+1..] == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -175,7 +175,7 @@ impl GenericPathUnsafe for Path {\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(self.repr.slice_to(idx+1));\n+                v.push_all(self.repr[..idx+1]);\n                 v.push_all(filename);\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n@@ -216,9 +216,9 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\"..\" == self.repr.as_slice() => self.repr.as_slice(),\n             None => dot_static,\n-            Some(0) => self.repr.slice_to(1),\n-            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => self.repr.as_slice(),\n-            Some(idx) => self.repr.slice_to(idx)\n+            Some(0) => self.repr[..1],\n+            Some(idx) if self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n+            Some(idx) => self.repr[..idx]\n         }\n     }\n \n@@ -227,9 +227,9 @@ impl GenericPath for Path {\n             None if b\".\" == self.repr.as_slice() ||\n                 b\"..\" == self.repr.as_slice() => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => None,\n-            Some(0) if self.repr.slice_from(1).is_empty() => None,\n-            Some(idx) => Some(self.repr.slice_from(idx+1))\n+            Some(idx) if self.repr[idx+1..] == b\"..\" => None,\n+            Some(0) if self.repr[1..].is_empty() => None,\n+            Some(idx) => Some(self.repr[idx+1..])\n         }\n     }\n \n@@ -371,7 +371,7 @@ impl Path {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n-            let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n+            let v_ = if is_abs { v.as_slice()[1..] } else { v.as_slice() };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n@@ -410,7 +410,7 @@ impl Path {\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n         let v = if self.repr[0] == SEP_BYTE {\n-            self.repr.slice_from(1)\n+            self.repr[1..]\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);\n         if v.is_empty() {"}, {"sha": "e1925fc79d0dc1e8ed0c10c31f3e2ca70d33e548", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -999,7 +999,7 @@ mod imp {\n                 let bytes = cstr.as_bytes();\n                 match cstr.as_str() {\n                     Some(s) => try!(super::demangle(w, s)),\n-                    None => try!(w.write(bytes.slice_to(bytes.len() - 1))),\n+                    None => try!(w.write(bytes[..bytes.len()-1])),\n                 }\n             }\n             try!(w.write(['\\n' as u8]));"}, {"sha": "257bfc632d882f4b0a7fb760a29e7a1fd4e47136", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -496,7 +496,7 @@ impl<'ast> Map<'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n-            in_which: parts.slice_to(parts.len() - 1),\n+            in_which: parts[..parts.len() - 1],\n             idx: 0,\n         }\n     }"}, {"sha": "6d063aef5a99063e886aaeca006b592d98ce1058", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -414,7 +414,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n     if display_lines.len() > MAX_LINES {\n-        display_lines = display_lines.slice(0u, MAX_LINES);\n+        display_lines = display_lines[0u..MAX_LINES];\n         elided = true;\n     }\n     // Print the offending lines"}, {"sha": "6b921144144e26f133eea9fea79674a736959366", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -285,13 +285,13 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table.slice(offset as uint, string_table_bytes as uint)\n+            let nulpos = string_table[offset as uint .. string_table_bytes as uint]\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      string_table.slice(offset as uint,\n-                                          offset as uint + len).to_vec())\n+                                      string_table[offset as uint ..\n+                                          offset as uint + len].to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\"}, {"sha": "1260cc33725f592b27b9c3d789997d401db293af", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -50,7 +50,7 @@ fn rotate(x: &mut [i32]) {\n \n fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n     for i in range(1, perm.len()) {\n-        rotate(perm.slice_to_mut(i + 1));\n+        rotate(perm[mut ..i + 1]);\n         let count_i = &mut count[i];\n         if *count_i >= i as i32 {\n             *count_i = 0;\n@@ -99,7 +99,7 @@ impl Perm {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n-            for (place, val) in pp.iter_mut().zip(self.perm.p.slice_to(i + 1).iter()) {\n+            for (place, val) in pp.iter_mut().zip(self.perm.p[..i+1].iter()) {\n                 *place = (*val) as u8\n             }\n \n@@ -125,7 +125,7 @@ impl Perm {\n \n \n fn reverse(tperm: &mut [i32], mut k: uint) {\n-    tperm.slice_to_mut(k).reverse()\n+    tperm[mut ..k].reverse()\n }\n \n fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {"}, {"sha": "3f8c929aecf89440d30cd722e5e30b8e7f7cd745", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -124,8 +124,8 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n         copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n-        copy_memory(buf.slice_mut(alu_len, buf_len),\n-                    alu.slice_to(LINE_LEN));\n+        copy_memory(buf[mut alu_len..buf_len],\n+                    alu[..LINE_LEN]);\n \n         let mut pos = 0;\n         let mut bytes;\n@@ -201,7 +201,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         for i in range(0u, chars_left) {\n             buf[i] = self.nextc();\n         }\n-        self.out.write(buf.slice_to(chars_left))\n+        self.out.write(buf[..chars_left])\n     }\n }\n "}, {"sha": "ed8ddcaa0ed5fd1f1c7dfdb9d625f351372219fe", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -93,7 +93,7 @@ fn make_fasta<W: Writer, I: Iterator<u8>>(\n         }\n         n -= nb;\n         line[nb] = '\\n' as u8;\n-        wr.write(line.slice_to(nb + 1));\n+        wr.write(line[..nb+1]);\n     }\n }\n "}, {"sha": "80d623bbeb1247043337b3a1b318381d8d222ef3", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -97,11 +97,11 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n \n    let len = bb.len();\n    while ii < len - (nn - 1u) {\n-      it(bb.slice(ii, ii+nn));\n+      it(bb[ii..ii+nn]);\n       ii += 1u;\n    }\n \n-   return Vec::from_slice(bb.slice(len - (nn - 1u), len));\n+   return Vec::from_slice(bb[len - (nn - 1u)..len]);\n }\n \n fn make_sequence_processor(sz: uint,"}, {"sha": "70fd937d2a388eb8283f46e25161f4f944dc68db", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -240,14 +240,14 @@ fn generate_frequencies(mut input: &[u8], frame: uint) -> Table {\n     // Pull first frame.\n     for _ in range(0, frame) {\n         code = code.push_char(input[0]);\n-        input = input.slice_from(1);\n+        input = input[1..];\n     }\n     frequencies.lookup(code, BumpCallback);\n \n     while input.len() != 0 && input[0] != ('>' as u8) {\n         code = code.rotate(input[0], frame);\n         frequencies.lookup(code, BumpCallback);\n-        input = input.slice_from(1);\n+        input = input[1..];\n     }\n     frequencies\n }"}, {"sha": "e5f22a3d07c2cf12a90dcb1486906acee43ed14c", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -81,7 +81,7 @@ fn main() {\n             Some(c) => c\n         };\n         let len = seq.len();\n-        let seq = seq.slice_mut(begin + 1, len - 1);\n+        let seq = seq[mut begin+1..len-1];\n \n         // arrange line breaks\n         let len = seq.len();"}, {"sha": "fc8c4e36075fa6c8ba6274ac9d36ed8e5dcc29a8", "filename": "src/test/compile-fail/issue-15730.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -11,5 +11,5 @@\n fn main() {\n     let mut array = [1, 2, 3];\n //~^ ERROR cannot determine a type for this local variable: cannot determine the type of this integ\n-    let pie_slice = array.slice(1, 2);\n+    let pie_slice = array[1..2];\n }"}, {"sha": "392a025b1f0bc31bb0d405d59eb09fa4b3ebe537", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -94,7 +94,7 @@ fn main() {\n     let empty: &[i64] = &[];\n     let singleton: &[i64] = &[1];\n     let multiple: &[i64] = &[2, 3, 4, 5];\n-    let slice_of_slice = multiple.slice(1,3);\n+    let slice_of_slice = multiple[1..3];\n \n     let padded_tuple: &[(i32, i16)] = &[(6, 7), (8, 9)];\n "}, {"sha": "2062967361906e89c7e291d13299f7c679a8bb8b", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n-    v.slice(1, 5)\n+    v[1..5]\n }\n \n pub fn main() {}"}, {"sha": "0f3f9149536764beb2fcb9bf5225fabb1eeaa6af", "filename": "src/test/run-pass/issue-4464.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4464.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v.slice(i, j) }\n+fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v[i..j] }\n \n pub fn main() {}"}, {"sha": "5348476fad7f4c78510c4185086ec36ee84bf204", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59976942eacd26c0cc37247c3ac0c78b97edc6ea/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=59976942eacd26c0cc37247c3ac0c78b97edc6ea", "patch": "@@ -19,7 +19,7 @@ pub fn main() {\n     let abc = [1i, 2, 3];\n     let tf = [true, false];\n     let x  = [(), ()];\n-    let slice = x.slice(0, 1);\n+    let slice = x[0..1];\n \n     assert_repr_eq(abc, \"[1, 2, 3]\".to_string());\n     assert_repr_eq(tf, \"[true, false]\".to_string());"}]}