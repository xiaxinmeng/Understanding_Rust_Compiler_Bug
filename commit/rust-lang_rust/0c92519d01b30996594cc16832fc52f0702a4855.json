{"sha": "0c92519d01b30996594cc16832fc52f0702a4855", "node_id": "C_kwDOAAsO6NoAKDBjOTI1MTlkMDFiMzA5OTY1OTRjYzE2ODMyZmM1MmYwNzAyYTQ4NTU", "commit": {"author": {"name": "Chris Martin", "email": "marti4d@live.ca", "date": "2022-05-09T16:04:53Z"}, "committer": {"name": "Chris Martin", "email": "marti4d@live.ca", "date": "2022-05-10T15:30:46Z"}, "message": "Make HashMap fall back to RtlGenRandom if BCryptGenRandom fails\n\nIssue #84096 changed the hashmap RNG to use BCryptGenRandom instead of\nRtlGenRandom on Windows.\n\nMozilla Firefox started experiencing random failures in\nenv_logger::Builder::new() (Issue #94098) during initialization of their\nunsandboxed main process with an \"Access Denied\" error message from\nBCryptGenRandom(), which is used by the HashMap contained in\nenv_logger::Builder\n\nThe root cause appears to be a virus scanner or other software interfering\nwith BCrypt DLLs loading.\n\nThis change adds a fallback option if BCryptGenRandom is unusable for\nwhatever reason. It will fallback to RtlGenRandom in this case.\n\nFixes #94098", "tree": {"sha": "7e608683e1aa790f4fd601c14f03c1a1294ef6db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e608683e1aa790f4fd601c14f03c1a1294ef6db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c92519d01b30996594cc16832fc52f0702a4855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c92519d01b30996594cc16832fc52f0702a4855", "html_url": "https://github.com/rust-lang/rust/commit/0c92519d01b30996594cc16832fc52f0702a4855", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c92519d01b30996594cc16832fc52f0702a4855/comments", "author": {"login": "marti4d", "id": 22406337, "node_id": "MDQ6VXNlcjIyNDA2MzM3", "avatar_url": "https://avatars.githubusercontent.com/u/22406337?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marti4d", "html_url": "https://github.com/marti4d", "followers_url": "https://api.github.com/users/marti4d/followers", "following_url": "https://api.github.com/users/marti4d/following{/other_user}", "gists_url": "https://api.github.com/users/marti4d/gists{/gist_id}", "starred_url": "https://api.github.com/users/marti4d/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marti4d/subscriptions", "organizations_url": "https://api.github.com/users/marti4d/orgs", "repos_url": "https://api.github.com/users/marti4d/repos", "events_url": "https://api.github.com/users/marti4d/events{/privacy}", "received_events_url": "https://api.github.com/users/marti4d/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marti4d", "id": 22406337, "node_id": "MDQ6VXNlcjIyNDA2MzM3", "avatar_url": "https://avatars.githubusercontent.com/u/22406337?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marti4d", "html_url": "https://github.com/marti4d", "followers_url": "https://api.github.com/users/marti4d/followers", "following_url": "https://api.github.com/users/marti4d/following{/other_user}", "gists_url": "https://api.github.com/users/marti4d/gists{/gist_id}", "starred_url": "https://api.github.com/users/marti4d/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marti4d/subscriptions", "organizations_url": "https://api.github.com/users/marti4d/orgs", "repos_url": "https://api.github.com/users/marti4d/repos", "events_url": "https://api.github.com/users/marti4d/events{/privacy}", "received_events_url": "https://api.github.com/users/marti4d/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e209e85e39b4851c3ec122a45ddeabe318b2d522", "url": "https://api.github.com/repos/rust-lang/rust/commits/e209e85e39b4851c3ec122a45ddeabe318b2d522", "html_url": "https://github.com/rust-lang/rust/commit/e209e85e39b4851c3ec122a45ddeabe318b2d522"}], "stats": {"total": 87, "additions": 83, "deletions": 4}, "files": [{"sha": "0bb6fee60c92eba5c22cd55910c7a6783da1b215", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c92519d01b30996594cc16832fc52f0702a4855/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c92519d01b30996594cc16832fc52f0702a4855/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=0c92519d01b30996594cc16832fc52f0702a4855", "patch": "@@ -788,6 +788,10 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n \n     #[link(name = \"advapi32\")]\n     extern \"system\" {\n+        // Forbidden when targeting UWP\n+        #[link_name = \"SystemFunction036\"]\n+        pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n+\n         // Allowed but unused by UWP\n         pub fn OpenProcessToken(\n             ProcessHandle: HANDLE,"}, {"sha": "ec6c40d2f49789e4f3765ad133d521f5841a6645", "filename": "library/std/src/sys/windows/rand.rs", "status": "modified", "additions": 79, "deletions": 4, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0c92519d01b30996594cc16832fc52f0702a4855/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c92519d01b30996594cc16832fc52f0702a4855/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs?ref=0c92519d01b30996594cc16832fc52f0702a4855", "patch": "@@ -1,8 +1,69 @@\n use crate::io;\n use crate::mem;\n+use crate::sync;\n use crate::sys::c;\n \n+// The kinds of HashMap RNG that may be available\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+enum HashMapRng {\n+    Preferred,\n+    Fallback,\n+}\n+\n pub fn hashmap_random_keys() -> (u64, u64) {\n+    match get_hashmap_rng() {\n+        HashMapRng::Preferred => {\n+            preferred_rng().expect(\"couldn't generate random bytes with preferred RNG\")\n+        }\n+        HashMapRng::Fallback => {\n+            fallback_rng().unwrap().expect(\"couldn't generate random bytes with fallback RNG\")\n+        }\n+    }\n+}\n+\n+// Returns the HashMap RNG that should be used\n+//\n+// Panics if they are both broken\n+fn get_hashmap_rng() -> HashMapRng {\n+    // Assume that if the preferred RNG is broken the first time we use it, it likely means\n+    // that: the DLL has failed to load, there is no point to calling it over-and-over again,\n+    // and we should cache the result\n+    static INIT: sync::Once = sync::Once::new();\n+    static mut HASHMAP_RNG: HashMapRng = HashMapRng::Preferred;\n+\n+    unsafe {\n+        INIT.call_once(|| HASHMAP_RNG = choose_hashmap_rng());\n+        HASHMAP_RNG\n+    }\n+}\n+\n+// Test whether we should use the preferred or fallback RNG\n+//\n+// If the preferred RNG is successful, we choose it. Otherwise, if the fallback RNG is successful,\n+// we choose that\n+//\n+// Panics if both the preferred and the fallback RNG are both non-functional\n+fn choose_hashmap_rng() -> HashMapRng {\n+    let preferred_error = match preferred_rng() {\n+        Ok(_) => return HashMapRng::Preferred,\n+        Err(e) => e,\n+    };\n+\n+    // On UWP, there is no fallback\n+    let fallback_result = fallback_rng()\n+        .unwrap_or_else(|| panic!(\"preferred RNG broken: `{}`, no fallback\", preferred_error));\n+\n+    match fallback_result {\n+        Ok(_) => return HashMapRng::Fallback,\n+        Err(fallback_error) => panic!(\n+            \"preferred RNG broken: `{}`, fallback RNG broken: `{}`\",\n+            preferred_error, fallback_error\n+        ),\n+    }\n+}\n+\n+// Generate random numbers using the preferred RNG function (BCryptGenRandom)\n+fn preferred_rng() -> Result<(u64, u64), io::Error> {\n     use crate::ptr;\n \n     let mut v = (0, 0);\n@@ -14,8 +75,22 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n             c::BCRYPT_USE_SYSTEM_PREFERRED_RNG,\n         )\n     };\n-    if ret != 0 {\n-        panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n-    }\n-    return v;\n+\n+    if ret == 0 { Ok(v) } else { Err(io::Error::last_os_error()) }\n+}\n+\n+// Generate random numbers using the fallback RNG function (RtlGenRandom)\n+#[cfg(not(target_vendor = \"uwp\"))]\n+fn fallback_rng() -> Option<Result<(u64, u64), io::Error>> {\n+    let mut v = (0, 0);\n+    let ret =\n+        unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n+\n+    Some(if ret != 0 { Ok(v) } else { Err(io::Error::last_os_error()) })\n+}\n+\n+// We can't use RtlGenRandom with UWP, so there is no fallback\n+#[cfg(target_vendor = \"uwp\")]\n+fn fallback_rng() -> Option<Result<(u64, u64), io::Error>> {\n+    None\n }"}]}