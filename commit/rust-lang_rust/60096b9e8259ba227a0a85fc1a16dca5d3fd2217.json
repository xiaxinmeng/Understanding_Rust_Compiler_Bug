{"sha": "60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMDk2YjllODI1OWJhMjI3YTBhODVmYzFhMTZkY2E1ZDNmZDIyMTc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-21T19:43:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-30T08:11:59Z"}, "message": "when suspending, we need to specify for which lifetime to recover\n\nThis matters if the lvalues that is suspended involves Deref'ing a reference --\nthat reference's lifetime will then not be in the type any more", "tree": {"sha": "ad3b7a5d5cbf6ea86ce9b79334af8ef8da270171", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad3b7a5d5cbf6ea86ce9b79334af8ef8da270171"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "html_url": "https://github.com/rust-lang/rust/commit/60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a233afa794763846a8d970ecedf763350cc2c067", "url": "https://api.github.com/repos/rust-lang/rust/commits/a233afa794763846a8d970ecedf763350cc2c067", "html_url": "https://github.com/rust-lang/rust/commit/a233afa794763846a8d970ecedf763350cc2c067"}], "stats": {"total": 203, "additions": 147, "deletions": 56}, "files": [{"sha": "cc0d49c1a3630fe5b498234edb10ab3be4d1aeda", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "patch": "@@ -684,6 +684,16 @@ pub enum Mutability {\n     MutImmutable,\n }\n \n+impl Mutability {\n+    /// Return MutMutable only if both arguments are mutable.\n+    pub fn and(self, other: Self) -> Self {\n+        match self {\n+            MutMutable => other,\n+            MutImmutable => MutImmutable,\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOp_ {\n     /// The `+` operator (addition)"}, {"sha": "dc41f981ed57b3dbe2a5d1e41d20789087ee4872", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "patch": "@@ -243,6 +243,8 @@ for mir::StatementKind<'tcx> {\n     }\n }\n \n+impl_stable_hash_for!(struct mir::ValidationOperand<'tcx> { lval, ty, re, mutbl });\n+\n impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(extent) });\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'tcx> {"}, {"sha": "4655f8a9c15ec2edc479df4b50e36eecbc4743ea", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "patch": "@@ -25,7 +25,7 @@ use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use util::ppaux;\n use rustc_back::slice;\n-use hir::InlineAsm;\n+use hir::{self, InlineAsm};\n use std::ascii;\n use std::borrow::{Cow};\n use std::cell::Ref;\n@@ -826,7 +826,7 @@ pub enum StatementKind<'tcx> {\n     },\n \n     /// Assert the given lvalues to be valid inhabitants of their type.\n-    Validate(ValidationOp, Vec<(Ty<'tcx>, Lvalue<'tcx>)>),\n+    Validate(ValidationOp, Vec<ValidationOperand<'tcx>>),\n \n     /// Mark one terminating point of an extent (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n@@ -855,6 +855,28 @@ impl Debug for ValidationOp {\n     }\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub struct ValidationOperand<'tcx> {\n+    pub lval: Lvalue<'tcx>,\n+    pub ty: Ty<'tcx>,\n+    pub re: Option<CodeExtent>,\n+    pub mutbl: hir::Mutability,\n+}\n+\n+impl<'tcx> Debug for ValidationOperand<'tcx> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}@{:?}\", self.lval, self.ty)?;\n+        if let Some(ce) = self.re {\n+            // (reuse lifetime rendering policy from ppaux.)\n+            write!(fmt, \"/{}\", ty::ReScope(ce))?;\n+        }\n+        if let hir::MutImmutable = self.mutbl {\n+            write!(fmt, \" (imm)\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n@@ -1505,6 +1527,21 @@ impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ValidationOperand {\n+            lval: self.lval.fold_with(folder),\n+            ty: self.ty.fold_with(folder),\n+            re: self.re,\n+            mutbl: self.mutbl,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.lval.visit_with(visitor) || self.ty.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use mir::StatementKind::*;\n@@ -1531,7 +1568,7 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n \n             Validate(ref op, ref lvals) =>\n                 Validate(op.clone(),\n-                         lvals.iter().map(|ty_and_lval| ty_and_lval.fold_with(folder)).collect()),\n+                         lvals.iter().map(|operand| operand.fold_with(folder)).collect()),\n \n             Nop => Nop,\n         };"}, {"sha": "a05007503cefb48008b58cfa5fd10d2913e161c3", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "patch": "@@ -334,9 +334,10 @@ macro_rules! make_mir_visitor {\n                     }\n                     StatementKind::EndRegion(_) => {}\n                     StatementKind::Validate(_, ref $($mutability)* lvalues) => {\n-                        for & $($mutability)* (ref $($mutability)* ty, ref $($mutability)* lvalue) in lvalues {\n-                            self.visit_ty(ty, Lookup::Loc(location));\n-                            self.visit_lvalue(lvalue, LvalueContext::Validate, location);\n+                        for operand in lvalues {\n+                            self.visit_lvalue(& $($mutability)* operand.lval,\n+                                              LvalueContext::Validate, location);\n+                            self.visit_ty(& $($mutability)* operand.ty, Lookup::Loc(location));\n                         }\n                     }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {"}, {"sha": "1fe16fb98f22591cc2889898367a4628b8cad124", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 91, "deletions": 50, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60096b9e8259ba227a0a85fc1a16dca5d3fd2217/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=60096b9e8259ba227a0a85fc1a16dca5d3fd2217", "patch": "@@ -14,34 +14,67 @@\n //! of MIR building, and only after this pass we think of the program has having the\n //! normal MIR semantics.\n \n-use rustc::ty::{TyCtxt, RegionKind};\n+use rustc::ty::{self, TyCtxt, RegionKind};\n+use rustc::hir;\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource};\n+use rustc::middle::region::CodeExtent;\n \n pub struct AddValidation;\n \n-\n-fn is_lvalue_shared<'a, 'tcx, D>(lval: &Lvalue<'tcx>, local_decls: &D, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool\n+/// Determine the \"context\" of the lval: Mutability and region.\n+fn lval_context<'a, 'tcx, D>(\n+    lval: &Lvalue<'tcx>,\n+    local_decls: &D,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+) -> (Option<CodeExtent>, hir::Mutability)\n     where D: HasLocalDecls<'tcx>\n {\n     use rustc::mir::Lvalue::*;\n \n     match *lval {\n-        Local { .. } => false,\n-        Static(_) => true,\n+        Local { .. } => (None, hir::MutMutable),\n+        Static(_) => (None, hir::MutImmutable),\n         Projection(ref proj) => {\n-            // If the base is shared, things stay shared\n-            if is_lvalue_shared(&proj.base, local_decls, tcx) {\n-                return true;\n-            }\n-            // A Deref projection may make things shared\n             match proj.elem {\n                 ProjectionElem::Deref => {\n-                    // Computing the inside the recursion makes this quadratic.  We don't expect deep paths though.\n+                    // Computing the inside the recursion makes this quadratic.\n+                    // We don't expect deep paths though.\n                     let ty = proj.base.ty(local_decls, tcx).to_ty(tcx);\n-                    !ty.is_mutable_pointer()\n+                    // A Deref projection may restrict the context, this depends on the type\n+                    // being deref'd.\n+                    let context = match ty.sty {\n+                        ty::TyRef(re, tam) => {\n+                            let re = match re {\n+                                &RegionKind::ReScope(ce) => Some(ce),\n+                                &RegionKind::ReErased =>\n+                                    bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n+                                _ => None\n+                            };\n+                            (re, tam.mutbl)\n+                        }\n+                        ty::TyRawPtr(_) =>\n+                            // There is no guarantee behind even a mutable raw pointer,\n+                            // no write locks are acquired there, so we also don't want to\n+                            // release any.\n+                            (None, hir::MutImmutable),\n+                        ty::TyAdt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n+                        _ => bug!(\"Deref on a non-pointer type {:?}\", ty),\n+                    };\n+                    // \"Intersect\" this restriction with proj.base.\n+                    if let (Some(_), hir::MutImmutable) = context {\n+                        // This is already as restricted as it gets, no need to even recurse\n+                        context\n+                    } else {\n+                        let base_context = lval_context(&proj.base, local_decls, tcx);\n+                        // The region of the outermost Deref is always most restrictive.\n+                        let re = context.0.or(base_context.0);\n+                        let mutbl = context.1.and(base_context.1);\n+                        (re, mutbl)\n+                    }\n+\n                 }\n-                _ => false,\n+                _ => lval_context(&proj.base, local_decls, tcx),\n             }\n         }\n     }\n@@ -52,41 +85,49 @@ impl MirPass for AddValidation {\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource,\n                           mir: &mut Mir<'tcx>) {\n+        let local_decls = mir.local_decls.clone(); // TODO: Find a way to get rid of this clone.\n+\n+        /// Convert an lvalue to a validation operand.\n+        let lval_to_operand = |lval: Lvalue<'tcx>| -> ValidationOperand<'tcx> {\n+            let (re, mutbl) = lval_context(&lval, &local_decls, tcx);\n+            let ty = lval.ty(&local_decls, tcx).to_ty(tcx);\n+            ValidationOperand { lval, ty, re, mutbl }\n+        };\n+\n         // PART 1\n         // Add an AcquireValid at the beginning of the start block.\n         if mir.arg_count > 0 {\n             let acquire_stmt = Statement {\n                 source_info: SourceInfo {\n                     scope: ARGUMENT_VISIBILITY_SCOPE,\n-                    span: mir.span, // TODO: Consider using just the span covering the function argument declaration\n+                    span: mir.span, // TODO: Consider using just the span covering the function\n+                                    // argument declaration.\n                 },\n                 kind: StatementKind::Validate(ValidationOp::Acquire,\n                     // Skip return value, go over all the arguments\n                     mir.local_decls.iter_enumerated().skip(1).take(mir.arg_count)\n-                    .map(|(local, local_decl)| (local_decl.ty, Lvalue::Local(local))).collect()\n+                    .map(|(local, _)| lval_to_operand(Lvalue::Local(local))).collect()\n                 )\n             };\n             mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, acquire_stmt);\n         }\n \n         // PART 2\n-        // Add ReleaseValid/AcquireValid around function call terminators.  We don't use a visitor because\n-        // we need to access the block that a Call jumps to.\n-        let mut returns : Vec<(SourceInfo, Lvalue<'tcx>, BasicBlock)> = Vec::new(); // Here we collect the destinations.\n-        let local_decls = mir.local_decls.clone(); // TODO: Find a way to get rid of this clone.\n+        // Add ReleaseValid/AcquireValid around function call terminators.  We don't use a visitor\n+        // because we need to access the block that a Call jumps to.\n+        let mut returns : Vec<(SourceInfo, Lvalue<'tcx>, BasicBlock)> = Vec::new();\n         for block_data in mir.basic_blocks_mut() {\n             match block_data.terminator {\n-                Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. }, source_info }) => {\n+                Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. },\n+                                  source_info }) => {\n                     // Before the call: Release all arguments\n                     let release_stmt = Statement {\n                         source_info,\n                         kind: StatementKind::Validate(ValidationOp::Release,\n                             args.iter().filter_map(|op| {\n                                 match op {\n-                                    &Operand::Consume(ref lval) => {\n-                                        let ty = lval.ty(&local_decls, tcx).to_ty(tcx);\n-                                        Some((ty, lval.clone()))\n-                                    },\n+                                    &Operand::Consume(ref lval) =>\n+                                        Some(lval_to_operand(lval.clone())),\n                                     &Operand::Constant(..) => { None },\n                                 }\n                             }).collect())\n@@ -97,13 +138,15 @@ impl MirPass for AddValidation {\n                         returns.push((source_info, destination.0.clone(), destination.1));\n                     }\n                 }\n-                Some(Terminator { kind: TerminatorKind::Drop { location: ref lval, .. }, source_info }) |\n-                Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref lval, .. }, source_info }) => {\n+                Some(Terminator { kind: TerminatorKind::Drop { location: ref lval, .. },\n+                                  source_info }) |\n+                Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref lval, .. },\n+                                  source_info }) => {\n                     // Before the call: Release all arguments\n-                    let ty = lval.ty(&local_decls, tcx).to_ty(tcx);\n                     let release_stmt = Statement {\n                         source_info,\n-                        kind: StatementKind::Validate(ValidationOp::Release, vec![(ty, lval.clone())])\n+                        kind: StatementKind::Validate(ValidationOp::Release,\n+                                vec![lval_to_operand(lval.clone())]),\n                     };\n                     block_data.statements.push(release_stmt);\n                     // drop doesn't return anything, so we need no acquire.\n@@ -115,20 +158,20 @@ impl MirPass for AddValidation {\n         }\n         // Now we go over the returns we collected to acquire the return values.\n         for (source_info, dest_lval, dest_block) in returns {\n-            let ty = dest_lval.ty(&local_decls, tcx).to_ty(tcx);\n             let acquire_stmt = Statement {\n                 source_info,\n-                kind: StatementKind::Validate(ValidationOp::Acquire, vec![(ty, dest_lval)])\n+                kind: StatementKind::Validate(ValidationOp::Acquire,\n+                        vec![lval_to_operand(dest_lval)]),\n             };\n             mir.basic_blocks_mut()[dest_block].statements.insert(0, acquire_stmt);\n         }\n \n         // PART 3\n-        // Add ReleaseValid/AcquireValid around Ref.  Again an iterator does not seem very suited as\n-        // we need to add new statements before and after each Ref.\n+        // Add ReleaseValid/AcquireValid around Ref.  Again an iterator does not seem very suited\n+        // as we need to add new statements before and after each Ref.\n         for block_data in mir.basic_blocks_mut() {\n-            // We want to insert statements around Ref commands as we iterate.  To this end, we iterate backwards\n-            // using indices.\n+            // We want to insert statements around Ref commands as we iterate.  To this end, we\n+            // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (dest_lval, re, src_lval) = match block_data.statements[i].kind {\n                     StatementKind::Assign(ref dest_lval, Rvalue::Ref(re, _, ref src_lval)) => {\n@@ -137,27 +180,25 @@ impl MirPass for AddValidation {\n                     _ => continue,\n                 };\n                 // So this is a ref, and we got all the data we wanted.\n-                let dest_ty = dest_lval.ty(&local_decls, tcx).to_ty(tcx);\n                 let acquire_stmt = Statement {\n                     source_info: block_data.statements[i].source_info,\n-                    kind: StatementKind::Validate(ValidationOp::Acquire, vec![(dest_ty, dest_lval)]),\n+                    kind: StatementKind::Validate(ValidationOp::Acquire,\n+                            vec![lval_to_operand(dest_lval)]),\n                 };\n                 block_data.statements.insert(i+1, acquire_stmt);\n \n-                // The source is released until the region of the borrow ends -- but not if it is shared.\n-                if !is_lvalue_shared(&src_lval, &local_decls, tcx) {\n-                    let src_ty = src_lval.ty(&local_decls, tcx).to_ty(tcx);\n-                    let op = match re {\n-                        &RegionKind::ReScope(ce) => ValidationOp::Suspend(ce),\n-                        &RegionKind::ReErased => bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n-                        _ => ValidationOp::Release,\n-                    };\n-                    let release_stmt = Statement {\n-                        source_info: block_data.statements[i].source_info,\n-                        kind: StatementKind::Validate(op, vec![(src_ty, src_lval)]),\n-                    };\n-                    block_data.statements.insert(i, release_stmt);\n-                }\n+                // The source is released until the region of the borrow ends.\n+                let op = match re {\n+                    &RegionKind::ReScope(ce) => ValidationOp::Suspend(ce),\n+                    &RegionKind::ReErased =>\n+                        bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n+                    _ => ValidationOp::Release,\n+                };\n+                let release_stmt = Statement {\n+                    source_info: block_data.statements[i].source_info,\n+                    kind: StatementKind::Validate(op, vec![lval_to_operand(src_lval)]),\n+                };\n+                block_data.statements.insert(i, release_stmt);\n             }\n         }\n     }"}]}