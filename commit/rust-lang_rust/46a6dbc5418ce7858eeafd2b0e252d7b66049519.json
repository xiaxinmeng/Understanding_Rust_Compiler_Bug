{"sha": "46a6dbc5418ce7858eeafd2b0e252d7b66049519", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2YTZkYmM1NDE4Y2U3ODU4ZWVhZmQyYjBlMjUyZDdiNjYwNDk1MTk=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-30T18:00:17Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-30T18:06:26Z"}, "message": "std::str: Use reverse enumerate and .rposition\n\nSimplify code by using the reversibility of enumerate and use\n.rposition().", "tree": {"sha": "f4e9954d8393382c1b1829072a997d40d91ed8f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4e9954d8393382c1b1829072a997d40d91ed8f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46a6dbc5418ce7858eeafd2b0e252d7b66049519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46a6dbc5418ce7858eeafd2b0e252d7b66049519", "html_url": "https://github.com/rust-lang/rust/commit/46a6dbc5418ce7858eeafd2b0e252d7b66049519", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46a6dbc5418ce7858eeafd2b0e252d7b66049519/comments", "author": null, "committer": null, "parents": [{"sha": "db22f2627d625ba9481a16e44f1cc3195e8d6ef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/db22f2627d625ba9481a16e44f1cc3195e8d6ef7", "html_url": "https://github.com/rust-lang/rust/commit/db22f2627d625ba9481a16e44f1cc3195e8d6ef7"}], "stats": {"total": 21, "additions": 6, "deletions": 15}, "files": [{"sha": "0360d4ac72f6bb875a898a23bbd7b1c04b8ad67d", "filename": "src/libstd/str.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46a6dbc5418ce7858eeafd2b0e252d7b66049519/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a6dbc5418ce7858eeafd2b0e252d7b66049519/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=46a6dbc5418ce7858eeafd2b0e252d7b66049519", "patch": "@@ -24,7 +24,7 @@ use container::{Container, Mutable};\n use num::Times;\n use iterator::{Iterator, FromIterator, Extendable};\n use iterator::{Filter, AdditiveIterator, Map};\n-use iterator::{Invert, DoubleEndedIterator};\n+use iterator::{Invert, DoubleEndedIterator, ExactSizeDoubleEndedIterator};\n use libc;\n use num::{Saturating};\n use option::{None, Option, Some};\n@@ -484,9 +484,8 @@ for CharSplitIterator<'self, Sep> {\n         let mut next_split = None;\n \n         if self.only_ascii {\n-            for (j, byte) in self.string.byte_rev_iter().enumerate() {\n+            for (idx, byte) in self.string.byte_iter().enumerate().invert() {\n                 if self.sep.matches(byte as char) && byte < 128u8 {\n-                    let idx = len - j - 1;\n                     next_split = Some((idx, idx + 1));\n                     break;\n                 }\n@@ -2008,16 +2007,13 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// or `None` if there is no match\n     fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            for (i, b) in self.byte_iter().enumerate() {\n-                if search.matches(b as char) { return Some(i) }\n-            }\n+            self.byte_iter().position(|b| search.matches(b as char))\n         } else {\n             for (index, c) in self.char_offset_iter() {\n                 if search.matches(c) { return Some(index); }\n             }\n+            None\n         }\n-\n-        None\n     }\n \n     /// Returns the byte index of the last character of `self` that matches `search`\n@@ -2028,18 +2024,13 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// or `None` if there is no match\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            let mut index = self.len();\n-            for b in self.byte_rev_iter() {\n-                index -= 1;\n-                if search.matches(b as char) { return Some(index); }\n-            }\n+            self.byte_iter().rposition(|b| search.matches(b as char))\n         } else {\n             for (index, c) in self.char_offset_rev_iter() {\n                 if search.matches(c) { return Some(index); }\n             }\n+            None\n         }\n-\n-        None\n     }\n \n     /// Returns the byte index of the first matching substring"}]}