{"sha": "64cd645d14407d312c7ed3a10efd9b3a99271884", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0Y2Q2NDVkMTQ0MDdkMzEyYzdlZDNhMTBlZmQ5YjNhOTkyNzE4ODQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-11-29T02:58:58Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-11-29T06:14:57Z"}, "message": "Split up `pretty_print` and `print`.\n\n`pretty_print` takes a `Token` and `match`es on it. But the particular\n`Token` kind is known at each call site, so this commit splits it into\nfive functions: `pretty_print_eof`, `pretty_print_begin`, etc.\n\nThis commit also does likewise with `print`, though there is one\ncallsite for `print` where the `Token` kind isn't known, so a generic\n`print` has to stay (but it now just calls out to the various `print_*`\nfunctions).", "tree": {"sha": "7212ca102c08c5332d9ea59bd931525e442d32d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7212ca102c08c5332d9ea59bd931525e442d32d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64cd645d14407d312c7ed3a10efd9b3a99271884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64cd645d14407d312c7ed3a10efd9b3a99271884", "html_url": "https://github.com/rust-lang/rust/commit/64cd645d14407d312c7ed3a10efd9b3a99271884", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64cd645d14407d312c7ed3a10efd9b3a99271884/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "787959c20d062d396b97a5566e0a766d963af022", "url": "https://api.github.com/repos/rust-lang/rust/commits/787959c20d062d396b97a5566e0a766d963af022", "html_url": "https://github.com/rust-lang/rust/commit/787959c20d062d396b97a5566e0a766d963af022"}], "stats": {"total": 302, "additions": 152, "deletions": 150}, "files": [{"sha": "aaed56da29d5f5e5173a7b150084cc0d94d5d88b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 152, "deletions": 150, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/64cd645d14407d312c7ed3a10efd9b3a99271884/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cd645d14407d312c7ed3a10efd9b3a99271884/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=64cd645d14407d312c7ed3a10efd9b3a99271884", "patch": "@@ -140,9 +140,9 @@\n //! calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n //! it.\n //!\n-//! In this implementation (following the paper, again) the SCAN process is\n-//! the method called `Printer::pretty_print`, and the 'PRINT' process is the method\n-//! called `Printer::print`.\n+//! In this implementation (following the paper, again) the SCAN process is the\n+//! methods called `Printer::pretty_print_*`, and the 'PRINT' process is the\n+//! method called `Printer::print`.\n \n use std::collections::VecDeque;\n use std::fmt;\n@@ -319,78 +319,77 @@ impl<'a> Printer<'a> {\n         self.buf[self.right].token = t;\n     }\n \n-    pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n-        debug!(\"pp Vec<{},{}>\", self.left, self.right);\n-        match token {\n-            Token::Eof => {\n-                if !self.scan_stack.is_empty() {\n-                    self.check_stack(0);\n-                    self.advance_left()?;\n-                }\n-                self.indent(0);\n-                Ok(())\n-            }\n-            Token::Begin(b) => {\n-                if self.scan_stack.is_empty() {\n-                    self.left_total = 1;\n-                    self.right_total = 1;\n-                    self.left = 0;\n-                    self.right = 0;\n-                } else {\n-                    self.advance_right();\n-                }\n-                debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n-                       b.offset, self.left, self.right);\n-                self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n-                let right = self.right;\n-                self.scan_push(right);\n-                Ok(())\n-            }\n-            Token::End => {\n-                if self.scan_stack.is_empty() {\n-                    debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n-                    self.print(token, 0)\n-                } else {\n-                    debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n-                    self.advance_right();\n-                    self.buf[self.right] = BufEntry { token: token, size: -1 };\n-                    let right = self.right;\n-                    self.scan_push(right);\n-                    Ok(())\n-                }\n-            }\n-            Token::Break(b) => {\n-                if self.scan_stack.is_empty() {\n-                    self.left_total = 1;\n-                    self.right_total = 1;\n-                    self.left = 0;\n-                    self.right = 0;\n-                } else {\n-                    self.advance_right();\n-                }\n-                debug!(\"pp Break({})/buffer Vec<{},{}>\",\n-                       b.offset, self.left, self.right);\n-                self.check_stack(0);\n-                let right = self.right;\n-                self.scan_push(right);\n-                self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n-                self.right_total += b.blank_space;\n-                Ok(())\n-            }\n-            Token::String(s, len) => {\n-                if self.scan_stack.is_empty() {\n-                    debug!(\"pp String('{}')/print Vec<{},{}>\",\n-                           s, self.left, self.right);\n-                    self.print(Token::String(s, len), len)\n-                } else {\n-                    debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n-                           s, self.left, self.right);\n-                    self.advance_right();\n-                    self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n-                    self.right_total += len;\n-                    self.check_stream()\n-                }\n-            }\n+    fn pretty_print_eof(&mut self) -> io::Result<()> {\n+        if !self.scan_stack.is_empty() {\n+            self.check_stack(0);\n+            self.advance_left()?;\n+        }\n+        self.indent(0);\n+        Ok(())\n+    }\n+\n+    fn pretty_print_begin(&mut self, b: BeginToken) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            self.left_total = 1;\n+            self.right_total = 1;\n+            self.left = 0;\n+            self.right = 0;\n+        } else {\n+            self.advance_right();\n+        }\n+        debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n+               b.offset, self.left, self.right);\n+        self.buf[self.right] = BufEntry { token: Token::Begin(b), size: -self.right_total };\n+        let right = self.right;\n+        self.scan_push(right);\n+        Ok(())\n+    }\n+\n+    fn pretty_print_end(&mut self) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n+            self.print_end()\n+        } else {\n+            debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n+            self.advance_right();\n+            self.buf[self.right] = BufEntry { token: Token::End, size: -1 };\n+            let right = self.right;\n+            self.scan_push(right);\n+            Ok(())\n+        }\n+    }\n+\n+    fn pretty_print_break(&mut self, b: BreakToken) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            self.left_total = 1;\n+            self.right_total = 1;\n+            self.left = 0;\n+            self.right = 0;\n+        } else {\n+            self.advance_right();\n+        }\n+        debug!(\"pp Break({})/buffer Vec<{},{}>\",\n+               b.offset, self.left, self.right);\n+        self.check_stack(0);\n+        let right = self.right;\n+        self.scan_push(right);\n+        self.buf[self.right] = BufEntry { token: Token::Break(b), size: -self.right_total };\n+        self.right_total += b.blank_space;\n+        Ok(())\n+    }\n+\n+    fn pretty_print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            debug!(\"pp String('{}')/print Vec<{},{}>\",\n+                   s, self.left, self.right);\n+            self.print_string(s, len)\n+        } else {\n+            debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n+                   s, self.left, self.right);\n+            self.advance_right();\n+            self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n+            self.right_total += len;\n+            self.check_stream()\n         }\n     }\n \n@@ -526,7 +525,70 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    pub fn print_str(&mut self, s: &str) -> io::Result<()> {\n+    pub fn print_begin(&mut self, b: BeginToken, l: isize) -> io::Result<()> {\n+        if l > self.space {\n+            let col = self.margin - self.space + b.offset;\n+            debug!(\"print Begin -> push broken block at col {}\", col);\n+            self.print_stack.push(PrintStackElem {\n+                offset: col,\n+                pbreak: PrintStackBreak::Broken(b.breaks)\n+            });\n+        } else {\n+            debug!(\"print Begin -> push fitting block\");\n+            self.print_stack.push(PrintStackElem {\n+                offset: 0,\n+                pbreak: PrintStackBreak::Fits\n+            });\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn print_end(&mut self) -> io::Result<()> {\n+        debug!(\"print End -> pop End\");\n+        let print_stack = &mut self.print_stack;\n+        assert!(!print_stack.is_empty());\n+        print_stack.pop().unwrap();\n+        Ok(())\n+    }\n+\n+    pub fn print_break(&mut self, b: BreakToken, l: isize) -> io::Result<()> {\n+        let top = self.get_top();\n+        match top.pbreak {\n+            PrintStackBreak::Fits => {\n+                debug!(\"print Break({}) in fitting block\", b.blank_space);\n+                self.space -= b.blank_space;\n+                self.indent(b.blank_space);\n+                Ok(())\n+            }\n+            PrintStackBreak::Broken(Breaks::Consistent) => {\n+                debug!(\"print Break({}+{}) in consistent block\",\n+                       top.offset, b.offset);\n+                let ret = self.print_newline(top.offset + b.offset);\n+                self.space = self.margin - (top.offset + b.offset);\n+                ret\n+            }\n+            PrintStackBreak::Broken(Breaks::Inconsistent) => {\n+                if l > self.space {\n+                    debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n+                           top.offset, b.offset);\n+                    let ret = self.print_newline(top.offset + b.offset);\n+                    self.space = self.margin - (top.offset + b.offset);\n+                    ret\n+                } else {\n+                    debug!(\"print Break({}) w/o newline in inconsistent\",\n+                           b.blank_space);\n+                    self.indent(b.blank_space);\n+                    self.space -= b.blank_space;\n+                    Ok(())\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+        debug!(\"print String({})\", s);\n+        // assert!(len <= space);\n+        self.space -= len;\n         while self.pending_indentation > 0 {\n             write!(self.out, \" \")?;\n             self.pending_indentation -= 1;\n@@ -542,85 +604,25 @@ impl<'a> Printer<'a> {\n                              self.right,\n                              6));\n         match token {\n-            Token::Begin(b) => {\n-                if l > self.space {\n-                    let col = self.margin - self.space + b.offset;\n-                    debug!(\"print Begin -> push broken block at col {}\", col);\n-                    self.print_stack.push(PrintStackElem {\n-                        offset: col,\n-                        pbreak: PrintStackBreak::Broken(b.breaks)\n-                    });\n-                } else {\n-                    debug!(\"print Begin -> push fitting block\");\n-                    self.print_stack.push(PrintStackElem {\n-                        offset: 0,\n-                        pbreak: PrintStackBreak::Fits\n-                    });\n-                }\n-                Ok(())\n-            }\n-            Token::End => {\n-                debug!(\"print End -> pop End\");\n-                let print_stack = &mut self.print_stack;\n-                assert!(!print_stack.is_empty());\n-                print_stack.pop().unwrap();\n-                Ok(())\n-            }\n-            Token::Break(b) => {\n-                let top = self.get_top();\n-                match top.pbreak {\n-                    PrintStackBreak::Fits => {\n-                        debug!(\"print Break({}) in fitting block\", b.blank_space);\n-                        self.space -= b.blank_space;\n-                        self.indent(b.blank_space);\n-                        Ok(())\n-                    }\n-                    PrintStackBreak::Broken(Breaks::Consistent) => {\n-                        debug!(\"print Break({}+{}) in consistent block\",\n-                               top.offset, b.offset);\n-                        let ret = self.print_newline(top.offset + b.offset);\n-                        self.space = self.margin - (top.offset + b.offset);\n-                        ret\n-                    }\n-                    PrintStackBreak::Broken(Breaks::Inconsistent) => {\n-                        if l > self.space {\n-                            debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n-                                   top.offset, b.offset);\n-                            let ret = self.print_newline(top.offset + b.offset);\n-                            self.space = self.margin - (top.offset + b.offset);\n-                            ret\n-                        } else {\n-                            debug!(\"print Break({}) w/o newline in inconsistent\",\n-                                   b.blank_space);\n-                            self.indent(b.blank_space);\n-                            self.space -= b.blank_space;\n-                            Ok(())\n-                        }\n-                    }\n-                }\n-            }\n-            Token::String(ref s, len) => {\n-                debug!(\"print String({})\", s);\n-                assert_eq!(l, len);\n-                // assert!(l <= space);\n-                self.space -= len;\n-                self.print_str(s)\n-            }\n-            Token::Eof => {\n-                // Eof should never get here.\n-                panic!();\n+            Token::Begin(b) => self.print_begin(b, l),\n+            Token::End => self.print_end(),\n+            Token::Break(b) => self.print_break(b, l),\n+            Token::String(s, len) => {\n+                assert_eq!(len, l);\n+                self.print_string(s, len)\n             }\n+            Token::Eof => panic!(), // Eof should never get here.\n         }\n     }\n \n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n     pub fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n-        self.pretty_print(Token::Begin(BeginToken {\n+        self.pretty_print_begin(BeginToken {\n             offset: indent as isize,\n             breaks: b\n-        }))\n+        })\n     }\n \n     /// Inconsistent breaking box\n@@ -634,24 +636,24 @@ impl<'a> Printer<'a> {\n     }\n \n     pub fn break_offset(&mut self, n: usize, off: isize) -> io::Result<()> {\n-        self.pretty_print(Token::Break(BreakToken {\n+        self.pretty_print_break(BreakToken {\n             offset: off,\n             blank_space: n as isize\n-        }))\n+        })\n     }\n \n     pub fn end(&mut self) -> io::Result<()> {\n-        self.pretty_print(Token::End)\n+        self.pretty_print_end()\n     }\n \n     pub fn eof(&mut self) -> io::Result<()> {\n-        self.pretty_print(Token::Eof)\n+        self.pretty_print_eof()\n     }\n \n     pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) -> io::Result<()> {\n         let s = wrd.into();\n         let len = s.len() as isize;\n-        self.pretty_print(Token::String(s, len))\n+        self.pretty_print_string(s, len)\n     }\n \n     fn spaces(&mut self, n: usize) -> io::Result<()> {"}]}