{"sha": "721fc7320850596a20ad417397f5fc8820cd87da", "node_id": "C_kwDOAAsO6NoAKDcyMWZjNzMyMDg1MDU5NmEyMGFkNDE3Mzk3ZjVmYzg4MjBjZDg3ZGE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-02-14T11:48:27Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-06-02T08:19:15Z"}, "message": "remove the old `emit_inference_failure_err`", "tree": {"sha": "5e08b91e40683e2e89683729f2d5db1a792ab971", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e08b91e40683e2e89683729f2d5db1a792ab971"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/721fc7320850596a20ad417397f5fc8820cd87da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/721fc7320850596a20ad417397f5fc8820cd87da", "html_url": "https://github.com/rust-lang/rust/commit/721fc7320850596a20ad417397f5fc8820cd87da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/721fc7320850596a20ad417397f5fc8820cd87da/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb1976011e3df96b5d3eccd6b2f4e51ef7dc8f16", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb1976011e3df96b5d3eccd6b2f4e51ef7dc8f16", "html_url": "https://github.com/rust-lang/rust/commit/fb1976011e3df96b5d3eccd6b2f4e51ef7dc8f16"}], "stats": {"total": 956, "additions": 43, "deletions": 913}, "files": [{"sha": "19b2ea08e5f8a3fc081fd17731398aa524a1eefb", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 43, "deletions": 913, "changes": 956, "blob_url": "https://github.com/rust-lang/rust/blob/721fc7320850596a20ad417397f5fc8820cd87da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721fc7320850596a20ad417397f5fc8820cd87da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=721fc7320850596a20ad417397f5fc8820cd87da", "patch": "@@ -17,248 +17,6 @@ use rustc_span::symbol::kw;\n use rustc_span::{sym, Span};\n use std::borrow::Cow;\n \n-struct FindHirNodeVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    target: GenericArg<'tcx>,\n-    target_span: Span,\n-    found_node_ty: Option<Ty<'tcx>>,\n-    found_local_pattern: Option<&'tcx Pat<'tcx>>,\n-    found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n-    found_closure: Option<&'tcx Expr<'tcx>>,\n-    found_method_call: Option<&'tcx Expr<'tcx>>,\n-    found_exact_method_call: Option<&'tcx Expr<'tcx>>,\n-    found_for_loop_iter: Option<&'tcx Expr<'tcx>>,\n-    found_use_diagnostic: Option<UseDiagnostic<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>, target_span: Span) -> Self {\n-        Self {\n-            infcx,\n-            target,\n-            target_span,\n-            found_node_ty: None,\n-            found_local_pattern: None,\n-            found_arg_pattern: None,\n-            found_closure: None,\n-            found_method_call: None,\n-            found_exact_method_call: None,\n-            found_for_loop_iter: None,\n-            found_use_diagnostic: None,\n-        }\n-    }\n-\n-    fn node_type_opt(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n-        self.infcx.in_progress_typeck_results?.borrow().node_type_opt(hir_id)\n-    }\n-\n-    fn node_ty_contains_target(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n-        self.node_type_opt(hir_id).map(|ty| self.infcx.resolve_vars_if_possible(ty)).filter(|ty| {\n-            ty.walk().any(|inner| {\n-                inner == self.target\n-                    || match (inner.unpack(), self.target.unpack()) {\n-                        (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n-                            use ty::{Infer, TyVar};\n-                            match (inner_ty.kind(), target_ty.kind()) {\n-                                (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n-                                    .infcx\n-                                    .inner\n-                                    .borrow_mut()\n-                                    .type_variables()\n-                                    .sub_unified(a_vid, b_vid),\n-                                _ => false,\n-                            }\n-                        }\n-                        _ => false,\n-                    }\n-            })\n-        })\n-    }\n-\n-    /// Determine whether the expression, assumed to be the callee within a `Call`,\n-    /// corresponds to the `From::from` emitted in desugaring of the `?` operator.\n-    fn is_try_conversion(&self, callee: &Expr<'tcx>) -> bool {\n-        self.infcx\n-            .trait_def_from_hir_fn(callee.hir_id)\n-            .map_or(false, |def_id| self.infcx.is_try_conversion(callee.span, def_id))\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n-    type NestedFilter = nested_filter::OnlyBodies;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.infcx.tcx.hir()\n-    }\n-\n-    fn visit_local(&mut self, local: &'tcx Local<'tcx>) {\n-        if let (None, Some(ty)) =\n-            (self.found_local_pattern, self.node_ty_contains_target(local.hir_id))\n-        {\n-            self.found_local_pattern = Some(&*local.pat);\n-            self.found_node_ty = Some(ty);\n-        }\n-        intravisit::walk_local(self, local);\n-    }\n-\n-    fn visit_body(&mut self, body: &'tcx Body<'tcx>) {\n-        for param in body.params {\n-            if let (None, Some(ty)) =\n-                (self.found_arg_pattern, self.node_ty_contains_target(param.hir_id))\n-            {\n-                self.found_arg_pattern = Some(&*param.pat);\n-                self.found_node_ty = Some(ty);\n-            }\n-        }\n-        intravisit::walk_body(self, body);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::Match(scrutinee, [_, arm], MatchSource::ForLoopDesugar) = expr.kind\n-            && let Some(pat) = arm.pat.for_loop_some()\n-            && let Some(ty) = self.node_ty_contains_target(pat.hir_id)\n-        {\n-            self.found_for_loop_iter = Some(scrutinee);\n-            self.found_node_ty = Some(ty);\n-            return;\n-        }\n-        if let ExprKind::MethodCall(segment, exprs, _) = expr.kind\n-            && segment.ident.span == self.target_span\n-            && Some(self.target) == self.infcx.in_progress_typeck_results.and_then(|typeck_results| {\n-                typeck_results\n-                    .borrow()\n-                    .node_type_opt(exprs.first().unwrap().hir_id)\n-                    .map(Into::into)\n-            })\n-        {\n-            self.found_exact_method_call = Some(&expr);\n-            return;\n-        }\n-\n-        // FIXME(const_generics): Currently, any uninferred `const` generics arguments\n-        // are handled specially, but instead they should be handled in `annotate_method_call`,\n-        // which currently doesn't work because this evaluates to `false` for const arguments.\n-        // See https://github.com/rust-lang/rust/pull/77758 for more details.\n-        if let Some(ty) = self.node_ty_contains_target(expr.hir_id) {\n-            match expr.kind {\n-                ExprKind::Closure(..) => self.found_closure = Some(&expr),\n-                ExprKind::MethodCall(..) => self.found_method_call = Some(&expr),\n-\n-                // If the given expression falls within the target span and is a\n-                // `From::from(e)` call emitted during desugaring of the `?` operator,\n-                // extract the types inferred before and after the call\n-                ExprKind::Call(callee, [arg])\n-                    if self.target_span.contains(expr.span)\n-                        && self.found_use_diagnostic.is_none()\n-                        && self.is_try_conversion(callee) =>\n-                {\n-                    self.found_use_diagnostic = self.node_type_opt(arg.hir_id).map(|pre_ty| {\n-                        UseDiagnostic::TryConversion { pre_ty, post_ty: ty, span: callee.span }\n-                    });\n-                }\n-                _ => {}\n-            }\n-        }\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-/// An observation about the use site of a type to be emitted as an additional\n-/// note in an inference failure error.\n-enum UseDiagnostic<'tcx> {\n-    /// Records the types inferred before and after `From::from` is called on the\n-    /// error value within the desugaring of the `?` operator.\n-    TryConversion { pre_ty: Ty<'tcx>, post_ty: Ty<'tcx>, span: Span },\n-}\n-\n-impl UseDiagnostic<'_> {\n-    /// Return a descriptor of the value at the use site\n-    fn descr(&self) -> &'static str {\n-        match self {\n-            Self::TryConversion { .. } => \"error for `?` operator\",\n-        }\n-    }\n-\n-    /// Return a descriptor of the type at the use site\n-    fn type_descr(&self) -> &'static str {\n-        match self {\n-            Self::TryConversion { .. } => \"error type for `?` operator\",\n-        }\n-    }\n-\n-    fn applies_to(&self, span: Span) -> bool {\n-        match *self {\n-            // In some cases the span for an inference failure due to try\n-            // conversion contains the antecedent expression as well as the `?`\n-            Self::TryConversion { span: s, .. } => span.contains(s) && span.hi() == s.hi(),\n-        }\n-    }\n-\n-    fn attach_note(&self, err: &mut Diagnostic) {\n-        match *self {\n-            Self::TryConversion { pre_ty, post_ty, .. } => {\n-                let intro = \"`?` implicitly converts the error value\";\n-\n-                let msg = match (pre_ty.is_ty_infer(), post_ty.is_ty_infer()) {\n-                    (true, true) => format!(\"{} using the `From` trait\", intro),\n-                    (false, true) => {\n-                        format!(\"{} into a type implementing `From<{}>`\", intro, pre_ty)\n-                    }\n-                    (true, false) => {\n-                        format!(\"{} into `{}` using the `From` trait\", intro, post_ty)\n-                    }\n-                    (false, false) => {\n-                        format!(\n-                            \"{} into `{}` using its implementation of `From<{}>`\",\n-                            intro, post_ty, pre_ty\n-                        )\n-                    }\n-                };\n-\n-                err.note(&msg);\n-            }\n-        }\n-    }\n-}\n-\n-/// Suggest giving an appropriate return type to a closure expression.\n-fn closure_return_type_suggestion(\n-    err: &mut Diagnostic,\n-    output: &FnRetTy<'_>,\n-    body: &Body<'_>,\n-    ret: &str,\n-) {\n-    let (arrow, post) = match output {\n-        FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-        _ => (\"\", \"\"),\n-    };\n-    let suggestion = match body.value.kind {\n-        ExprKind::Block(..) => vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))],\n-        _ => vec![\n-            (output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n-            (body.value.span.shrink_to_hi(), \" }\".to_string()),\n-        ],\n-    };\n-    err.multipart_suggestion(\n-        \"give this closure an explicit return type without `_` placeholders\",\n-        suggestion,\n-        Applicability::HasPlaceholders,\n-    );\n-}\n-\n-/// Given a closure signature, return a `String` containing a list of all its argument types.\n-fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n-    fn_sig\n-        .inputs()\n-        .skip_binder()\n-        .iter()\n-        .next()\n-        .map(|args| {\n-            args.tuple_fields().iter().map(|arg| arg.to_string()).collect::<Vec<_>>().join(\", \")\n-        })\n-        .unwrap_or_default()\n-}\n-\n pub enum TypeAnnotationNeeded {\n     /// ```compile_fail,E0282\n     /// let x = \"hello\".chars().rev().collect();\n@@ -306,32 +64,18 @@ pub enum UnderspecifiedArgKind {\n     Const { is_parameter: bool },\n }\n \n-impl UnderspecifiedArgKind {\n-    fn descr(&self) -> &'static str {\n-        match self {\n-            Self::Type { .. } => \"type\",\n-            Self::Const { .. } => \"const\",\n-        }\n-    }\n-}\n-\n impl InferenceDiagnosticsData {\n     /// Generate a label for a generic argument which can't be inferred. When not\n     /// much is known about the argument, `use_diag` may be used to describe the\n     /// labeled value.\n-    fn cannot_infer_msg(&self, use_diag: Option<&UseDiagnostic<'_>>) -> String {\n+    fn cannot_infer_msg(&self) -> String {\n         if self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }) {\n-            if let Some(use_diag) = use_diag {\n-                return format!(\"cannot infer type of {}\", use_diag.descr());\n-            }\n-\n             return \"cannot infer type\".to_string();\n         }\n \n-        let suffix = match (&self.parent, use_diag) {\n-            (Some(parent), _) => format!(\" declared on the {} `{}`\", parent.prefix, parent.name),\n-            (None, Some(use_diag)) => format!(\" in {}\", use_diag.type_descr()),\n-            (None, None) => String::new(),\n+        let suffix = match &self.parent {\n+            Some(parent) => parent.suffix_string(),\n+            None => String::new(),\n         };\n \n         // For example: \"cannot infer type for type parameter `T`\"\n@@ -340,9 +84,10 @@ impl InferenceDiagnosticsData {\n }\n \n impl InferenceDiagnosticsParentData {\n-    fn for_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<InferenceDiagnosticsParentData> {\n-        let parent_def_id = tcx.parent(def_id);\n-\n+    fn for_parent_def_id(\n+        tcx: TyCtxt<'_>,\n+        parent_def_id: DefId,\n+    ) -> Option<InferenceDiagnosticsParentData> {\n         let parent_name =\n             tcx.def_key(parent_def_id).disambiguated_data.data.get_opt_name()?.to_string();\n \n@@ -352,6 +97,14 @@ impl InferenceDiagnosticsParentData {\n             def_id: parent_def_id,\n         })\n     }\n+\n+    fn for_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<InferenceDiagnosticsParentData> {\n+        Self::for_parent_def_id(tcx, tcx.parent(def_id))\n+    }\n+\n+    fn suffix_string(&self) -> String {\n+        format!(\" declared on the {} `{}`\", self.prefix, self.name)\n+    }\n }\n \n impl UnderspecifiedArgKind {\n@@ -409,71 +162,34 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             }\n             GenericArgKind::Const(ct) => {\n-                match ct.val() {\n-                    ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                        let origin = self\n-                            .inner\n-                            .borrow_mut()\n-                            .const_unification_table()\n-                            .probe_value(vid)\n-                            .origin;\n-                        if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n-                            origin.kind\n-                        {\n-                            return InferenceDiagnosticsData {\n-                                name: name.to_string(),\n-                                span: Some(origin.span),\n-                                kind: UnderspecifiedArgKind::Const { is_parameter: true },\n-                                parent: InferenceDiagnosticsParentData::for_def_id(\n-                                    self.tcx, def_id,\n-                                ),\n-                            };\n-                        }\n-\n-                        debug_assert!(!origin.span.is_dummy());\n-                        let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::ValueNS);\n-                        if let Some(highlight) = highlight {\n-                            printer.region_highlight_mode = highlight;\n-                        }\n-                        let name = ct.print(printer).unwrap().into_buffer();\n-                        InferenceDiagnosticsData {\n-                            name,\n+                if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val() {\n+                    let origin =\n+                        self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n+                    if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n+                        origin.kind\n+                    {\n+                        return InferenceDiagnosticsData {\n+                            name: name.to_string(),\n                             span: Some(origin.span),\n-                            kind: UnderspecifiedArgKind::Const { is_parameter: false },\n-                            parent: None,\n-                        }\n+                            kind: UnderspecifiedArgKind::Const { is_parameter: true },\n+                            parent: InferenceDiagnosticsParentData::for_def_id(self.tcx, def_id),\n+                        };\n                     }\n-                    ty::ConstKind::Unevaluated(ty::Unevaluated { substs, .. }) => {\n-                        assert!(substs.has_infer_types_or_consts());\n \n-                        // FIXME: We only use the first inference variable we encounter in\n-                        // `substs` here, this gives insufficiently informative diagnostics\n-                        // in case there are multiple inference variables\n-                        for s in substs.iter() {\n-                            match s.unpack() {\n-                                GenericArgKind::Type(t) => match t.kind() {\n-                                    ty::Infer(_) => {\n-                                        return self.extract_inference_diagnostics_data(s, None);\n-                                    }\n-                                    _ => {}\n-                                },\n-                                GenericArgKind::Const(c) => match c.val() {\n-                                    ty::ConstKind::Infer(InferConst::Var(_)) => {\n-                                        return self.extract_inference_diagnostics_data(s, None);\n-                                    }\n-                                    _ => {}\n-                                },\n-                                _ => {}\n-                            }\n-                        }\n-                        bug!(\n-                            \"expected an inference variable in substs of unevaluated const {:?}\",\n-                            ct\n-                        );\n+                    debug_assert!(!origin.span.is_dummy());\n+                    let mut printer =\n+                        ty::print::FmtPrinter::new(self.tcx, Namespace::ValueNS);\n+                    if let Some(highlight) = highlight {\n+                        printer.region_highlight_mode = highlight;\n                     }\n-                    _ => {\n-                        bug!(\"unexpect const: {:?}\", ct);\n+                    InferenceDiagnosticsData {\n+                        name: ct.print(printer).unwrap().into_buffer(),\n+                        span: Some(origin.span),\n+                        kind: UnderspecifiedArgKind::Const { is_parameter: false },\n+                        parent: None,\n                     }\n+                } else {\n+                    bug!(\"unexpect const: {:?}\", ct);\n                 }\n             }\n             GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n@@ -489,473 +205,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let arg = self.resolve_vars_if_possible(arg);\n-        let arg_data = self.extract_inference_diagnostics_data(arg, None);\n \n-        let mut local_visitor = FindHirNodeVisitor::new(&self, arg, span);\n-        let ty_to_string = |ty: Ty<'tcx>| -> String {\n-            let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS);\n-            let ty_getter = move |ty_vid| {\n-                if let TypeVariableOriginKind::TypeParameterDefinition(name, _) =\n-                    self.inner.borrow_mut().type_variables().var_origin(ty_vid).kind\n-                {\n-                    Some(name.to_string())\n-                } else {\n-                    None\n-                }\n-            };\n-            printer.ty_infer_name_resolver = Some(Box::new(ty_getter));\n-            let const_getter = move |ct_vid| {\n-                if let ConstVariableOriginKind::ConstParameterDefinition(name, _) = self\n-                    .inner\n-                    .borrow_mut()\n-                    .const_unification_table()\n-                    .probe_value(ct_vid)\n-                    .origin\n-                    .kind\n-                {\n-                    return Some(name.to_string());\n-                } else {\n-                    None\n-                }\n-            };\n-            printer.const_infer_name_resolver = Some(Box::new(const_getter));\n-\n-            if let ty::FnDef(..) = ty.kind() {\n-                // We don't want the regular output for `fn`s because it includes its path in\n-                // invalid pseudo-syntax, we want the `fn`-pointer output instead.\n-                ty.fn_sig(self.tcx).print(printer).unwrap().into_buffer()\n-            } else {\n-                ty.print(printer).unwrap().into_buffer()\n-            }\n-        };\n-\n-        if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n-            local_visitor.visit_expr(expr);\n-        }\n-        let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n-            pattern.span\n-        } else if let Some(span) = arg_data.span {\n-            // `span` here lets us point at `sum` instead of the entire right hand side expr:\n-            // error[E0282]: type annotations needed\n-            //  --> file2.rs:3:15\n-            //   |\n-            // 3 |     let _ = x.sum() as f64;\n-            //   |               ^^^ cannot infer type for `S`\n-            span\n-        } else if let Some(ExprKind::MethodCall(segment, ..)) =\n-            local_visitor.found_method_call.map(|e| &e.kind)\n-        {\n-            // Point at the call instead of the whole expression:\n-            // error[E0284]: type annotations needed\n-            //  --> file.rs:2:5\n-            //   |\n-            // 2 |     [Ok(2)].into_iter().collect()?;\n-            //   |                         ^^^^^^^ cannot infer type\n-            //   |\n-            //   = note: cannot resolve `<_ as std::ops::Try>::Ok == _`\n-            if span.contains(segment.ident.span) { segment.ident.span } else { span }\n-        } else {\n-            span\n-        };\n-\n-        let is_named_and_not_impl_trait =\n-            |ty: Ty<'_>| &ty.to_string() != \"_\" && !ty.is_impl_trait();\n-\n-        let ty_msg = match (local_visitor.found_node_ty, local_visitor.found_exact_method_call) {\n-            (_, Some(_)) => String::new(),\n-            (Some(ty), _) if ty.is_closure() => {\n-                let ty::Closure(_, substs) = *ty.kind() else { unreachable!() };\n-                let fn_sig = substs.as_closure().sig();\n-                let args = closure_args(&fn_sig);\n-                let ret = fn_sig.output().skip_binder().to_string();\n-                format!(\" for the closure `fn({}) -> {}`\", args, ret)\n-            }\n-            (Some(ty), _) if is_named_and_not_impl_trait(ty) => {\n-                let ty = ty_to_string(ty);\n-                format!(\" for `{}`\", ty)\n-            }\n-            _ => String::new(),\n-        };\n-\n-        // When `arg_data.name` corresponds to a type argument, show the path of the full type we're\n-        // trying to infer. In the following example, `ty_msg` contains\n-        // \" for `std::result::Result<i32, E>`\":\n-        // ```\n-        // error[E0282]: type annotations needed for `std::result::Result<i32, E>`\n-        //  --> file.rs:L:CC\n-        //   |\n-        // L |     let b = Ok(4);\n-        //   |         -   ^^ cannot infer type for `E` in `std::result::Result<i32, E>`\n-        //   |         |\n-        //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n-        //   |         the type parameter `E` is specified\n-        // ```\n         let error_code = error_code.into();\n-        let mut err = self.tcx.sess.struct_span_err_with_code(\n-            err_span,\n-            &format!(\"type annotations needed{}\", ty_msg),\n+        let err = self.tcx.sess.struct_span_err_with_code(\n+            span,\n+            &format!(\"type annotations needed\"),\n             error_code,\n         );\n-\n-        let use_diag = local_visitor.found_use_diagnostic.as_ref();\n-        if let Some(use_diag) = use_diag && use_diag.applies_to(err_span) {\n-            use_diag.attach_note(&mut err);\n-        }\n-\n-        let param_type = arg_data.kind.descr();\n-        let suffix = match local_visitor.found_node_ty {\n-            Some(ty) if ty.is_closure() => {\n-                let ty::Closure(_, substs) = *ty.kind() else { unreachable!() };\n-                let fn_sig = substs.as_closure().sig();\n-                let ret = fn_sig.output().skip_binder().to_string();\n-\n-                let closure_decl_and_body_id =\n-                    local_visitor.found_closure.and_then(|closure| match &closure.kind {\n-                        ExprKind::Closure(_, decl, body_id, ..) => Some((decl, *body_id)),\n-                        _ => None,\n-                    });\n-\n-                if let Some((decl, body_id)) = closure_decl_and_body_id {\n-                    closure_return_type_suggestion(\n-                        &mut err,\n-                        &decl.output,\n-                        self.tcx.hir().body(body_id),\n-                        &ret,\n-                    );\n-                    // We don't want to give the other suggestions when the problem is the\n-                    // closure return type.\n-                    err.span_label(\n-                        span,\n-                        arg_data.cannot_infer_msg(use_diag.filter(|d| d.applies_to(span))),\n-                    );\n-                    return err;\n-                }\n-\n-                // This shouldn't be reachable, but just in case we leave a reasonable fallback.\n-                let args = closure_args(&fn_sig);\n-                // This suggestion is incomplete, as the user will get further type inference\n-                // errors due to the `_` placeholders and the introduction of `Box`, but it does\n-                // nudge them in the right direction.\n-                format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n-            }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && arg_data.name == \"_\" => {\n-                let ty = ty_to_string(ty);\n-                format!(\"the explicit type `{}`, with the {} parameters specified\", ty, param_type)\n-            }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n-                let ty = ResolvedTypeParamEraser::new(self.tcx).fold_ty(ty);\n-                let ty = ErrTypeParamEraser(self.tcx).fold_ty(ty);\n-                let ty = ty_to_string(ty);\n-                format!(\n-                    \"the explicit type `{}`, where the {} parameter `{}` is specified\",\n-                    ty, param_type, arg_data.name,\n-                )\n-            }\n-            _ => \"a type\".to_string(),\n-        };\n-\n-        if let Some(e) = local_visitor.found_exact_method_call {\n-            if let ExprKind::MethodCall(segment, ..) = &e.kind {\n-                // Suggest specifying type params or point out the return type of the call:\n-                //\n-                // error[E0282]: type annotations needed\n-                //   --> $DIR/type-annotations-needed-expr.rs:2:39\n-                //    |\n-                // LL |     let _ = x.into_iter().sum() as f64;\n-                //    |                           ^^^\n-                //    |                           |\n-                //    |                           cannot infer type for `S`\n-                //    |                           help: consider specifying the type argument in\n-                //    |                           the method call: `sum::<S>`\n-                //    |\n-                //    = note: type must be known at this point\n-                //\n-                // or\n-                //\n-                // error[E0282]: type annotations needed\n-                //   --> $DIR/issue-65611.rs:59:20\n-                //    |\n-                // LL |     let x = buffer.last().unwrap().0.clone();\n-                //    |             -------^^^^--\n-                //    |             |      |\n-                //    |             |      cannot infer type for `T`\n-                //    |             this method call resolves to `std::option::Option<&T>`\n-                //    |\n-                //    = note: type must be known at this point\n-                self.annotate_method_call(segment, e, &mut err);\n-            }\n-        } else if let Some(pattern) = local_visitor.found_arg_pattern {\n-            // We don't want to show the default label for closures.\n-            //\n-            // So, before clearing, the output would look something like this:\n-            // ```\n-            // let x = |_| {  };\n-            //          -  ^^^^ cannot infer type for `[_; 0]`\n-            //          |\n-            //          consider giving this closure parameter a type\n-            // ```\n-            //\n-            // After clearing, it looks something like this:\n-            // ```\n-            // let x = |_| {  };\n-            //          ^ consider giving this closure parameter the type `[_; 0]`\n-            //            with the type parameter `_` specified\n-            // ```\n-            err.span_label(\n-                pattern.span,\n-                format!(\"consider giving this closure parameter {}\", suffix),\n-            );\n-        } else if let Some(pattern) = local_visitor.found_local_pattern {\n-            let msg = if let Some(simple_ident) = pattern.simple_ident() {\n-                match pattern.span.desugaring_kind() {\n-                    None => format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    Some(_) => format!(\"this needs {}\", suffix),\n-                }\n-            } else {\n-                format!(\"consider giving this pattern {}\", suffix)\n-            };\n-            err.span_label(pattern.span, msg);\n-        } else if let Some(e) = local_visitor.found_method_call {\n-            if let ExprKind::MethodCall(segment, exprs, _) = &e.kind {\n-                // Suggest impl candidates:\n-                //\n-                // error[E0283]: type annotations needed\n-                //   --> $DIR/E0283.rs:35:24\n-                //    |\n-                // LL |     let bar = foo_impl.into() * 1u32;\n-                //    |               ---------^^^^--\n-                //    |               |        |\n-                //    |               |        cannot infer type for type parameter `T` declared on the trait `Into`\n-                //    |               this method call resolves to `T`\n-                //    |               help: specify type like: `<Impl as Into<u32>>::into(foo_impl)`\n-                //    |\n-                //    = note: cannot satisfy `Impl: Into<_>`\n-                debug!(?segment);\n-                if !impl_candidates.is_empty() && e.span.contains(span)\n-                    && let Some(expr) = exprs.first()\n-                    && let ExprKind::Path(hir::QPath::Resolved(_, path)) = expr.kind\n-                    && let [_] = path.segments\n-                {\n-                    let mut eraser = TypeParamEraser(self.tcx);\n-                    let candidate_len = impl_candidates.len();\n-                    let mut suggestions: Vec<_> = impl_candidates.iter().filter_map(|candidate| {\n-                        let trait_item = self.tcx\n-                            .associated_items(candidate.def_id)\n-                            .find_by_name_and_kind(\n-                                self.tcx,\n-                                segment.ident,\n-                                ty::AssocKind::Fn,\n-                                candidate.def_id\n-                            );\n-                        if trait_item.is_none() {\n-                            return None;\n-                        }\n-                        let prefix = if let Some(trait_item) = trait_item\n-                            && let Some(trait_m) = trait_item.def_id.as_local()\n-                            && let hir::TraitItemKind::Fn(fn_, _) = &self.tcx.hir().trait_item(hir::TraitItemId { def_id: trait_m }).kind\n-                        {\n-                            match fn_.decl.implicit_self {\n-                                hir::ImplicitSelfKind::ImmRef => \"&\",\n-                                hir::ImplicitSelfKind::MutRef => \"&mut \",\n-                                _ => \"\",\n-                            }\n-                        } else {\n-                            \"\"\n-                        };\n-                        let candidate = candidate.super_fold_with(&mut eraser);\n-                        Some(vec![\n-                            (expr.span.shrink_to_lo(), format!(\"{}::{}({}\", candidate, segment.ident, prefix)),\n-                            if exprs.len() == 1 {\n-                                (expr.span.shrink_to_hi().with_hi(e.span.hi()), \")\".to_string())\n-                            } else {\n-                                (expr.span.shrink_to_hi().with_hi(exprs[1].span.lo()), \", \".to_string())\n-                            },\n-                        ])\n-                    }).collect();\n-                    suggestions.sort_by(|a, b| a[0].1.cmp(&b[0].1));\n-                    if !suggestions.is_empty() {\n-                        err.multipart_suggestions(\n-                            &format!(\n-                                \"use the fully qualified path for the potential candidate{}\",\n-                                pluralize!(candidate_len),\n-                            ),\n-                            suggestions.into_iter(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-                // Suggest specifying type params or point out the return type of the call:\n-                //\n-                // error[E0282]: type annotations needed\n-                //   --> $DIR/type-annotations-needed-expr.rs:2:39\n-                //    |\n-                // LL |     let _ = x.into_iter().sum() as f64;\n-                //    |                           ^^^\n-                //    |                           |\n-                //    |                           cannot infer type for `S`\n-                //    |                           help: consider specifying the type argument in\n-                //    |                           the method call: `sum::<S>`\n-                //    |\n-                //    = note: type must be known at this point\n-                //\n-                // or\n-                //\n-                // error[E0282]: type annotations needed\n-                //   --> $DIR/issue-65611.rs:59:20\n-                //    |\n-                // LL |     let x = buffer.last().unwrap().0.clone();\n-                //    |             -------^^^^--\n-                //    |             |      |\n-                //    |             |      cannot infer type for `T`\n-                //    |             this method call resolves to `std::option::Option<&T>`\n-                //    |\n-                //    = note: type must be known at this point\n-                self.annotate_method_call(segment, e, &mut err);\n-            }\n-        } else if let Some(scrutinee) = local_visitor.found_for_loop_iter {\n-            err.span_label(\n-                scrutinee.span,\n-                \"the element type for this iterator is not specified\".to_string(),\n-            );\n-        }\n-        // Instead of the following:\n-        // error[E0282]: type annotations needed\n-        //  --> file2.rs:3:15\n-        //   |\n-        // 3 |     let _ = x.sum() as f64;\n-        //   |             --^^^--------- cannot infer type for `S`\n-        //   |\n-        //   = note: type must be known at this point\n-        // We want:\n-        // error[E0282]: type annotations needed\n-        //  --> file2.rs:3:15\n-        //   |\n-        // 3 |     let _ = x.sum() as f64;\n-        //   |               ^^^ cannot infer type for `S`\n-        //   |\n-        //   = note: type must be known at this point\n-        let span = arg_data.span.unwrap_or(err_span);\n-\n-        // Avoid multiple labels pointing at `span`.\n-        if !err\n-            .span\n-            .span_labels()\n-            .iter()\n-            .any(|span_label| span_label.label.is_some() && span_label.span == span)\n-            && local_visitor.found_arg_pattern.is_none()\n-        {\n-            // FIXME(const_generics): we would like to handle const arguments\n-            // as part of the normal diagnostics flow below, but there appear to\n-            // be subtleties in doing so, so for now we special-case const args\n-            // here.\n-            if let (UnderspecifiedArgKind::Const { .. }, Some(parent_data)) =\n-                (&arg_data.kind, &arg_data.parent)\n-            {\n-                // (#83606): Do not emit a suggestion if the parent has an `impl Trait`\n-                // as an argument otherwise it will cause the E0282 error.\n-                if !self.tcx.generics_of(parent_data.def_id).has_impl_trait()\n-                    || self.tcx.features().explicit_generic_args_with_impl_trait\n-                {\n-                    err.span_suggestion_verbose(\n-                        span,\n-                        \"consider specifying the const argument\",\n-                        format!(\"{}::<{}>\", parent_data.name, arg_data.name),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n-\n-            self.report_ambiguous_type_parameter(&mut err, arg);\n-            err.span_label(\n-                span,\n-                arg_data.cannot_infer_msg(use_diag.filter(|d| d.applies_to(span))),\n-            );\n-        }\n-\n         err\n     }\n \n-    fn trait_def_from_hir_fn(&self, hir_id: hir::HirId) -> Option<DefId> {\n-        // The DefId will be the method's trait item ID unless this is an inherent impl\n-        if let Some((DefKind::AssocFn, def_id)) =\n-            self.in_progress_typeck_results?.borrow().type_dependent_def(hir_id)\n-        {\n-            let parent_def_id = self.tcx.parent(def_id);\n-            return self.tcx.is_trait(parent_def_id).then_some(parent_def_id);\n-        }\n-\n-        None\n-    }\n-\n-    /// If the `FnSig` for the method call can be found and type arguments are identified as\n-    /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n-    fn annotate_method_call(\n-        &self,\n-        segment: &hir::PathSegment<'_>,\n-        e: &Expr<'_>,\n-        err: &mut Diagnostic,\n-    ) {\n-        if let (Some(typeck_results), None) = (self.in_progress_typeck_results, &segment.args) {\n-            let borrow = typeck_results.borrow();\n-            if let Some((DefKind::AssocFn, did)) = borrow.type_dependent_def(e.hir_id) {\n-                let generics = self.tcx.generics_of(did);\n-                if !generics.params.is_empty() && !generics.has_impl_trait() {\n-                    err.span_suggestion_verbose(\n-                        segment.ident.span.shrink_to_hi(),\n-                        &format!(\n-                            \"consider specifying the type argument{} in the method call\",\n-                            pluralize!(generics.params.len()),\n-                        ),\n-                        format!(\n-                            \"::<{}>\",\n-                            generics\n-                                .params\n-                                .iter()\n-                                .map(|p| p.name.to_string())\n-                                .collect::<Vec<String>>()\n-                                .join(\", \")\n-                        ),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                } else {\n-                    let sig = self.tcx.fn_sig(did);\n-                    let bound_output = sig.output();\n-                    let output = bound_output.skip_binder();\n-                    err.span_label(e.span, &format!(\"this method call resolves to `{}`\", output));\n-                    let kind = output.kind();\n-                    if let ty::Projection(proj) = kind {\n-                        if let Some(span) = self.tcx.hir().span_if_local(proj.item_def_id) {\n-                            err.span_label(span, &format!(\"`{}` defined here\", output));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn report_ambiguous_type_parameter(&self, err: &mut Diagnostic, arg: GenericArg<'tcx>) {\n-        if let GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind()\n-        {\n-            let mut inner = self.inner.borrow_mut();\n-            let ty_vars = &inner.type_variables();\n-            let var_origin = ty_vars.var_origin(ty_vid);\n-            if let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n-                var_origin.kind\n-                && let Some(parent_def_id) = self.tcx.parent(def_id).as_local()\n-                && let Some(node) = self.tcx.hir().find_by_def_id(parent_def_id)\n-            {\n-                match node {\n-                    hir::Node::Item(item) if matches!(item.kind, hir::ItemKind::Impl(_) | hir::ItemKind::Fn(..)) => (),\n-                    hir::Node::ImplItem(impl_item) if matches!(impl_item.kind, hir::ImplItemKind::Fn(..)) => (),\n-                    _ => return,\n-                }\n-                err.span_help(self.tcx.def_span(def_id), \"type parameter declared here\");\n-            }\n-        }\n-    }\n-\n     pub fn need_type_info_err_in_generator(\n         &self,\n         kind: hir::GeneratorKind,\n@@ -972,136 +231,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"type inside {} must be known in this context\",\n             kind,\n         );\n-        err.span_label(span, data.cannot_infer_msg(None));\n+        err.span_label(span, data.cannot_infer_msg());\n         err\n     }\n }\n-\n-/// Turn *resolved* type params into `[type error]` to signal we don't want to display them. After\n-/// performing that replacement, we'll turn all remaining infer type params to use their name from\n-/// their definition, and replace all the `[type error]`s back to being infer so they display in\n-/// the output as `_`. If we didn't go through `[type error]`, we would either show all type params\n-/// by their name *or* `_`, neither of which is desirable: we want to show all types that we could\n-/// infer as `_` to reduce verbosity and avoid telling the user about unnecessary type annotations.\n-struct ResolvedTypeParamEraser<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    level: usize,\n-}\n-\n-impl<'tcx> ResolvedTypeParamEraser<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        ResolvedTypeParamEraser { tcx, level: 0 }\n-    }\n-\n-    /// Replace not yet inferred const params with their def name.\n-    fn replace_infers(&self, c: Const<'tcx>, index: u32, name: Symbol) -> Const<'tcx> {\n-        match c.val() {\n-            ty::ConstKind::Infer(..) => self.tcx().mk_const_param(index, name, c.ty()),\n-            _ => c,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        self.level += 1;\n-        let t = match t.kind() {\n-            // We'll hide this type only if all its type params are hidden as well.\n-            ty::Adt(def, substs) => {\n-                let generics = self.tcx().generics_of(def.did());\n-                // Account for params with default values, like `Vec`, where we\n-                // want to show `Vec<T>`, not `Vec<T, _>`. If we replaced that\n-                // subst, then we'd get the incorrect output, so we passthrough.\n-                let substs: Vec<_> = substs\n-                    .iter()\n-                    .zip(generics.params.iter())\n-                    .map(|(subst, param)| match &(subst.unpack(), &param.kind) {\n-                        (_, ty::GenericParamDefKind::Type { has_default: true, .. }) => subst,\n-                        (crate::infer::GenericArgKind::Const(c), _) => {\n-                            self.replace_infers(*c, param.index, param.name).into()\n-                        }\n-                        _ => subst.super_fold_with(self),\n-                    })\n-                    .collect();\n-                let should_keep = |subst: &GenericArg<'_>| match subst.unpack() {\n-                    ty::subst::GenericArgKind::Type(t) => match t.kind() {\n-                        ty::Error(_) => false,\n-                        _ => true,\n-                    },\n-                    // Account for `const` params here, otherwise `doesnt_infer.rs`\n-                    // shows `_` instead of `Foo<{ _: u32 }>`\n-                    ty::subst::GenericArgKind::Const(_) => true,\n-                    _ => false,\n-                };\n-                if self.level == 1 || substs.iter().any(should_keep) {\n-                    let substs = self.tcx().intern_substs(&substs[..]);\n-                    self.tcx().mk_ty(ty::Adt(*def, substs))\n-                } else {\n-                    self.tcx().ty_error()\n-                }\n-            }\n-            ty::Ref(_, ty, _) => {\n-                let ty = self.fold_ty(*ty);\n-                match ty.kind() {\n-                    // Avoid `&_`, these can be safely presented as `_`.\n-                    ty::Error(_) => self.tcx().ty_error(),\n-                    _ => t.super_fold_with(self),\n-                }\n-            }\n-            // We could account for `()` if we wanted to replace it, but it's assured to be short.\n-            ty::Tuple(_)\n-            | ty::Slice(_)\n-            | ty::RawPtr(_)\n-            | ty::FnDef(..)\n-            | ty::FnPtr(_)\n-            | ty::Opaque(..)\n-            | ty::Projection(_)\n-            | ty::Never => t.super_fold_with(self),\n-            ty::Array(ty, c) => {\n-                self.tcx().mk_ty(ty::Array(self.fold_ty(*ty), self.replace_infers(*c, 0, sym::N)))\n-            }\n-            // We don't want to hide type params that haven't been resolved yet.\n-            // This would be the type that will be written out with the type param\n-            // name in the output.\n-            ty::Infer(_) => t,\n-            // We don't want to hide the outermost type, only its type params.\n-            _ if self.level == 1 => t.super_fold_with(self),\n-            // Hide this type\n-            _ => self.tcx().ty_error(),\n-        };\n-        self.level -= 1;\n-        t\n-    }\n-}\n-\n-/// Replace `[type error]` with `ty::Infer(ty::Var)` to display `_`.\n-struct ErrTypeParamEraser<'tcx>(TyCtxt<'tcx>);\n-impl<'tcx> TypeFolder<'tcx> for ErrTypeParamEraser<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-        self.0\n-    }\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.kind() {\n-            ty::Error(_) => self.tcx().mk_ty_var(ty::TyVid::from_u32(0)),\n-            _ => t.super_fold_with(self),\n-        }\n-    }\n-}\n-\n-/// Replace type parameters with `ty::Infer(ty::Var)` to display `_`.\n-struct TypeParamEraser<'tcx>(TyCtxt<'tcx>);\n-\n-impl<'tcx> TypeFolder<'tcx> for TypeParamEraser<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-        self.0\n-    }\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.kind() {\n-            ty::Param(_) | ty::Error(_) => self.tcx().mk_ty_var(ty::TyVid::from_u32(0)),\n-            _ => t.super_fold_with(self),\n-        }\n-    }\n-}"}]}