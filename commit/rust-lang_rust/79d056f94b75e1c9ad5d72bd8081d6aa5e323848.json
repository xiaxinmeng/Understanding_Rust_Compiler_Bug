{"sha": "79d056f94b75e1c9ad5d72bd8081d6aa5e323848", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZDA1NmY5NGI3NWUxYzlhZDVkNzJiZDgwODFkNmFhNWUzMjM4NDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-09T19:02:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-09T19:02:06Z"}, "message": "auto merge of #17558 : kaseyc/rust/fix_bitvset_union, r=aturon\n\nUpdates the other_op function shared by the union/intersect/difference/symmetric_difference -with functions to fix an issue where certain elements would not be present in the result. To fix this, when other op is called, we resize self's nbits to account for any new elements that may be added to the set.\r\n\r\nExample:\r\n```rust\r\n\tlet mut a = BitvSet::new();\r\n\tlet mut b = BitvSet::new();\r\n\ta.insert(0);\r\n\tb.insert(5);\r\n\ta.union_with(&b);\r\n\tprintln!(\"{}\", a); //Prints \"{0}\" instead of \"{0, 5}\"\r\n```", "tree": {"sha": "6bcd6807b6086f7fd99925bee2e4f2009871a61e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bcd6807b6086f7fd99925bee2e4f2009871a61e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79d056f94b75e1c9ad5d72bd8081d6aa5e323848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79d056f94b75e1c9ad5d72bd8081d6aa5e323848", "html_url": "https://github.com/rust-lang/rust/commit/79d056f94b75e1c9ad5d72bd8081d6aa5e323848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79d056f94b75e1c9ad5d72bd8081d6aa5e323848/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb04229f7a8c12924b3b6357c42961c96f821423", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb04229f7a8c12924b3b6357c42961c96f821423", "html_url": "https://github.com/rust-lang/rust/commit/eb04229f7a8c12924b3b6357c42961c96f821423"}, {"sha": "dd4fa906fcc3f21eca8d8ce958b4728ed62581e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4fa906fcc3f21eca8d8ce958b4728ed62581e1", "html_url": "https://github.com/rust-lang/rust/commit/dd4fa906fcc3f21eca8d8ce958b4728ed62581e1"}], "stats": {"total": 188, "additions": 131, "deletions": 57}, "files": [{"sha": "8f9873d77d17e5b69fdf8fae78a3694996ba4717", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 131, "deletions": 57, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/79d056f94b75e1c9ad5d72bd8081d6aa5e323848/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d056f94b75e1c9ad5d72bd8081d6aa5e323848/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=79d056f94b75e1c9ad5d72bd8081d6aa5e323848", "patch": "@@ -235,11 +235,20 @@ impl Bitv {\n     /// }\n     /// ```\n     pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n-        Bitv {\n+        let mut bitv = Bitv {\n             storage: Vec::from_elem((nbits + uint::BITS - 1) / uint::BITS,\n                                     if init { !0u } else { 0u }),\n             nbits: nbits\n+        };\n+\n+        // Zero out any unused bits in the highest word if necessary\n+        let used_bits = bitv.nbits % uint::BITS;\n+        if init && used_bits != 0 {\n+            let largest_used_word = (bitv.nbits + uint::BITS - 1) / uint::BITS - 1;\n+            *bitv.storage.get_mut(largest_used_word) &= (1 << used_bits) - 1;\n         }\n+\n+        bitv\n     }\n \n     /// Retrieves the value at index `i`.\n@@ -629,9 +638,9 @@ impl Bitv {\n     /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let old_size = self.storage.len();\n-        let size = (size + uint::BITS - 1) / uint::BITS;\n-        if old_size < size {\n-            self.storage.grow(size - old_size, 0);\n+        let new_size = (size + uint::BITS - 1) / uint::BITS;\n+        if old_size < new_size {\n+            self.storage.grow(new_size - old_size, 0);\n         }\n     }\n \n@@ -686,8 +695,15 @@ impl Bitv {\n         }\n         // Allocate new words, if needed\n         if new_nwords > self.storage.len() {\n-          let to_add = new_nwords - self.storage.len();\n-          self.storage.grow(to_add, full_value);\n+            let to_add = new_nwords - self.storage.len();\n+            self.storage.grow(to_add, full_value);\n+\n+            // Zero out and unused bits in the new tail word\n+            if value {\n+                let tail_word = new_nwords - 1;\n+                let used_bits = new_nbits % uint::BITS;\n+                *self.storage.get_mut(tail_word) &= (1 << used_bits) - 1;\n+            }\n         }\n         // Adjust internal bit count\n         self.nbits = new_nbits;\n@@ -970,9 +986,8 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// }\n ///\n /// // Can convert back to a `Bitv`\n-/// let bv: Bitv = s.unwrap();\n-/// assert!(bv.eq_vec([true, true, false, true,\n-///                    false, false, false, false]));\n+/// let bv: Bitv = s.into_bitv();\n+/// assert!(bv.get(3));\n /// ```\n #[deriving(Clone)]\n pub struct BitvSet(Bitv);\n@@ -993,7 +1008,8 @@ impl FromIterator<bool> for BitvSet {\n impl Extendable<bool> for BitvSet {\n     #[inline]\n     fn extend<I: Iterator<bool>>(&mut self, iterator: I) {\n-        self.get_mut_ref().extend(iterator);\n+        let &BitvSet(ref mut self_bitv) = self;\n+        self_bitv.extend(iterator);\n     }\n }\n \n@@ -1049,7 +1065,8 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n-        BitvSet(Bitv::with_capacity(nbits, false))\n+        let bitv = Bitv::with_capacity(nbits, false);\n+        BitvSet::from_bitv(bitv)\n     }\n \n     /// Creates a new bit vector set from the given bit vector.\n@@ -1068,7 +1085,9 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n+    pub fn from_bitv(mut bitv: Bitv) -> BitvSet {\n+        // Mark every bit as valid\n+        bitv.nbits = bitv.capacity();\n         BitvSet(bitv)\n     }\n \n@@ -1102,7 +1121,10 @@ impl BitvSet {\n     /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let &BitvSet(ref mut bitv) = self;\n-        bitv.reserve(size)\n+        bitv.reserve(size);\n+        if bitv.nbits < size {\n+            bitv.nbits = bitv.capacity();\n+        }\n     }\n \n     /// Consumes this set to return the underlying bit vector.\n@@ -1116,11 +1138,12 @@ impl BitvSet {\n     /// s.insert(0);\n     /// s.insert(3);\n     ///\n-    /// let bv = s.unwrap();\n-    /// assert!(bv.eq_vec([true, false, false, true]));\n+    /// let bv = s.into_bitv();\n+    /// assert!(bv.get(0));\n+    /// assert!(bv.get(3));\n     /// ```\n     #[inline]\n-    pub fn unwrap(self) -> Bitv {\n+    pub fn into_bitv(self) -> Bitv {\n         let BitvSet(bitv) = self;\n         bitv\n     }\n@@ -1144,38 +1167,15 @@ impl BitvSet {\n         bitv\n     }\n \n-    /// Returns a mutable reference to the underlying bit vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BitvSet;\n-    ///\n-    /// let mut s = BitvSet::new();\n-    /// s.insert(0);\n-    /// assert_eq!(s.contains(&0), true);\n-    /// {\n-    ///     // Will free the set during bv's lifetime\n-    ///     let bv = s.get_mut_ref();\n-    ///     bv.set(0, false);\n-    /// }\n-    /// assert_eq!(s.contains(&0), false);\n-    /// ```\n-    #[inline]\n-    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut Bitv {\n-        let &BitvSet(ref mut bitv) = self;\n-        bitv\n-    }\n-\n     #[inline]\n     fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n+        // Expand the vector if necessary\n+        self.reserve(other.capacity());\n+\n         // Unwrap Bitvs\n         let &BitvSet(ref mut self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n \n-        // Expand the vector if necessary\n-        self_bitv.reserve(other_bitv.capacity());\n-\n         // virtually pad other with 0's for equal lengths\n         let mut other_words = {\n             let (_, result) = match_words(self_bitv, other_bitv);\n@@ -1376,9 +1376,10 @@ impl BitvSet {\n     ///\n     /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n     ///\n     /// a.union_with(&b);\n-    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n     pub fn union_with(&mut self, other: &BitvSet) {\n@@ -1399,9 +1400,10 @@ impl BitvSet {\n     ///\n     /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n     ///\n     /// a.intersect_with(&b);\n-    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n     pub fn intersect_with(&mut self, other: &BitvSet) {\n@@ -1424,15 +1426,17 @@ impl BitvSet {\n     ///\n     /// let mut bva = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let bvb = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let bva_b = BitvSet::from_bitv(bitv::from_bytes([a_b]));\n+    /// let bvb_a = BitvSet::from_bitv(bitv::from_bytes([b_a]));\n     ///\n     /// bva.difference_with(&bvb);\n-    /// assert_eq!(bva.unwrap(), bitv::from_bytes([a_b]));\n+    /// assert_eq!(bva, bva_b);\n     ///\n     /// let bva = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let mut bvb = BitvSet::from_bitv(bitv::from_bytes([b]));\n     ///\n     /// bvb.difference_with(&bva);\n-    /// assert_eq!(bvb.unwrap(), bitv::from_bytes([b_a]));\n+    /// assert_eq!(bvb, bvb_a);\n     /// ```\n     #[inline]\n     pub fn difference_with(&mut self, other: &BitvSet) {\n@@ -1454,9 +1458,10 @@ impl BitvSet {\n     ///\n     /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n     /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n     ///\n     /// a.symmetric_difference_with(&b);\n-    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n@@ -1538,20 +1543,14 @@ impl MutableSet<uint> for BitvSet {\n         if self.contains(&value) {\n             return false;\n         }\n+\n+        // Ensure we have enough space to hold the new element\n         if value >= self.capacity() {\n             let new_cap = cmp::max(value + 1, self.capacity() * 2);\n             self.reserve(new_cap);\n         }\n+\n         let &BitvSet(ref mut bitv) = self;\n-        if value >= bitv.nbits {\n-            // If we are increasing nbits, make sure we mask out any previously-unconsidered bits\n-            let old_rem = bitv.nbits % uint::BITS;\n-            if old_rem != 0 {\n-                let old_last_word = (bitv.nbits + uint::BITS - 1) / uint::BITS - 1;\n-                *bitv.storage.get_mut(old_last_word) &= (1 << old_rem) - 1;\n-            }\n-            bitv.nbits = value + 1;\n-        }\n         bitv.set(value, true);\n         return true;\n     }\n@@ -2225,14 +2224,15 @@ mod tests {\n         assert!(a.insert(160));\n         assert!(a.insert(19));\n         assert!(a.insert(24));\n+        assert!(a.insert(200));\n \n         assert!(b.insert(1));\n         assert!(b.insert(5));\n         assert!(b.insert(9));\n         assert!(b.insert(13));\n         assert!(b.insert(19));\n \n-        let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n+        let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n         let actual = a.union(&b).collect::<Vec<uint>>();\n         assert_eq!(actual.as_slice(), expected.as_slice());\n     }\n@@ -2281,6 +2281,27 @@ mod tests {\n         assert!(c.is_disjoint(&b))\n     }\n \n+    #[test]\n+    fn test_bitv_set_union_with() {\n+        //a should grow to include larger elements\n+        let mut a = BitvSet::new();\n+        a.insert(0);\n+        let mut b = BitvSet::new();\n+        b.insert(5);\n+        let expected = BitvSet::from_bitv(from_bytes([0b10000100]));\n+        a.union_with(&b);\n+        assert_eq!(a, expected);\n+\n+        // Standard\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes([0b01100010]));\n+        let c = a.clone();\n+        a.union_with(&b);\n+        b.union_with(&c);\n+        assert_eq!(a.len(), 4);\n+        assert_eq!(b.len(), 4);\n+    }\n+\n     #[test]\n     fn test_bitv_set_intersect_with() {\n         // Explicitly 0'ed bits\n@@ -2311,6 +2332,59 @@ mod tests {\n         assert_eq!(b.len(), 2);\n     }\n \n+    #[test]\n+    fn test_bitv_set_difference_with() {\n+        // Explicitly 0'ed bits\n+        let mut a = BitvSet::from_bitv(from_bytes([0b00000000]));\n+        let b = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        a.difference_with(&b);\n+        assert!(a.is_empty());\n+\n+        // Uninitialized bits should behave like 0's\n+        let mut a = BitvSet::new();\n+        let b = BitvSet::from_bitv(from_bytes([0b11111111]));\n+        a.difference_with(&b);\n+        assert!(a.is_empty());\n+\n+        // Standard\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes([0b01100010]));\n+        let c = a.clone();\n+        a.difference_with(&b);\n+        b.difference_with(&c);\n+        assert_eq!(a.len(), 1);\n+        assert_eq!(b.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_symmetric_difference_with() {\n+        //a should grow to include larger elements\n+        let mut a = BitvSet::new();\n+        a.insert(0);\n+        a.insert(1);\n+        let mut b = BitvSet::new();\n+        b.insert(1);\n+        b.insert(5);\n+        let expected = BitvSet::from_bitv(from_bytes([0b10000100]));\n+        a.symmetric_difference_with(&b);\n+        assert_eq!(a, expected);\n+\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let b = BitvSet::new();\n+        let c = a.clone();\n+        a.symmetric_difference_with(&b);\n+        assert_eq!(a, c);\n+\n+        // Standard\n+        let mut a = BitvSet::from_bitv(from_bytes([0b11100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes([0b01101010]));\n+        let c = a.clone();\n+        a.symmetric_difference_with(&b);\n+        b.symmetric_difference_with(&c);\n+        assert_eq!(a.len(), 2);\n+        assert_eq!(b.len(), 2);\n+    }\n+\n     #[test]\n     fn test_bitv_set_eq() {\n         let a = BitvSet::from_bitv(from_bytes([0b10100010]));"}]}