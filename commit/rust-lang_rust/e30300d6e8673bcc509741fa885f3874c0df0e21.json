{"sha": "e30300d6e8673bcc509741fa885f3874c0df0e21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMDMwMGQ2ZTg2NzNiY2M1MDk3NDFmYTg4NWYzODc0YzBkZjBlMjE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-25T02:57:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-25T02:57:36Z"}, "message": "Rollup merge of #61099 - spastorino:ignore-borrow-iterate, r=oli-obk\n\nMake ignore_borrow iterate instead of recurse\n\nr? @oli-obk", "tree": {"sha": "c65d5b8d8cd00426f9f42448b35690d47644d7d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c65d5b8d8cd00426f9f42448b35690d47644d7d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e30300d6e8673bcc509741fa885f3874c0df0e21", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc6K8gCRBK7hj4Ov3rIwAAdHIIAFXh1kvzoA9pip20n7kM0VGR\nSMSwZ18yg5Y6Ki2sIeLX3gX7RpE8NGFaToYI5imi9x3SXXwntlPdcqBAD16Ywgxq\ne4jNiTykL0aLCas0/zD77mBKzgtCzfnsu1F3Lb345o+fp0bgcLJrUM2kDJ/wC9q7\nBFwkkH3QnImnq1Cm/2h5pqjZ50blBroOWlfhSohQcx0GESqI9REcy6GyfEGHu+uD\nVyDMHlR7hqs0ItdE/Rix4r967ym22VuVxJURqkyErReSTLkrA2YTL0eVN+7YhTT7\nGuAYKMyWpf1xM3s7E3Fn1aH7EXE3tlQn3kkAbWdN9e6/tCkJRP1YXZ+DH/hyvnw=\n=dTiG\n-----END PGP SIGNATURE-----\n", "payload": "tree c65d5b8d8cd00426f9f42448b35690d47644d7d2\nparent af015527aa037ae858871ae30cf6897bdb8236e5\nparent 10fe26962c644d6b1a381ecea93d6fe516bd861f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558753056 +0200\ncommitter GitHub <noreply@github.com> 1558753056 +0200\n\nRollup merge of #61099 - spastorino:ignore-borrow-iterate, r=oli-obk\n\nMake ignore_borrow iterate instead of recurse\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e30300d6e8673bcc509741fa885f3874c0df0e21", "html_url": "https://github.com/rust-lang/rust/commit/e30300d6e8673bcc509741fa885f3874c0df0e21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e30300d6e8673bcc509741fa885f3874c0df0e21/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af015527aa037ae858871ae30cf6897bdb8236e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/af015527aa037ae858871ae30cf6897bdb8236e5", "html_url": "https://github.com/rust-lang/rust/commit/af015527aa037ae858871ae30cf6897bdb8236e5"}, {"sha": "10fe26962c644d6b1a381ecea93d6fe516bd861f", "url": "https://api.github.com/repos/rust-lang/rust/commits/10fe26962c644d6b1a381ecea93d6fe516bd861f", "html_url": "https://github.com/rust-lang/rust/commit/10fe26962c644d6b1a381ecea93d6fe516bd861f"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "9ad0e936e1b2d7b4283bd0b0c5f8f2134106eb8e", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e30300d6e8673bcc509741fa885f3874c0df0e21/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30300d6e8673bcc509741fa885f3874c0df0e21/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=e30300d6e8673bcc509741fa885f3874c0df0e21", "patch": "@@ -25,40 +25,36 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         mir: &Mir<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        match self {\n-            // If a local variable is immutable, then we only need to track borrows to guard\n-            // against two kinds of errors:\n-            // * The variable being dropped while still borrowed (e.g., because the fn returns\n-            //   a reference to a local variable)\n-            // * The variable being moved while still borrowed\n-            //\n-            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n-            // so we don't have to worry about mutation while borrowed.\n-            Place::Base(PlaceBase::Local(index)) => {\n-                match locals_state_at_exit {\n-                    LocalsStateAtExit::AllAreInvalidated => false,\n-                    LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                        let ignore = !has_storage_dead_or_moved.contains(*index) &&\n-                            mir.local_decls[*index].mutability == Mutability::Not;\n-                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                        ignore\n+        self.iterate(|place_base, place_projection| {\n+            let ignore = match place_base {\n+                // If a local variable is immutable, then we only need to track borrows to guard\n+                // against two kinds of errors:\n+                // * The variable being dropped while still borrowed (e.g., because the fn returns\n+                //   a reference to a local variable)\n+                // * The variable being moved while still borrowed\n+                //\n+                // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+                // so we don't have to worry about mutation while borrowed.\n+                PlaceBase::Local(index) => {\n+                    match locals_state_at_exit {\n+                        LocalsStateAtExit::AllAreInvalidated => false,\n+                        LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n+                            let ignore = !has_storage_dead_or_moved.contains(*index) &&\n+                                mir.local_decls[*index].mutability == Mutability::Not;\n+                            debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n+                            ignore\n+                        }\n                     }\n                 }\n-            }\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n-                false,\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n-                tcx.is_mutable_static(*def_id)\n-            }\n-            Place::Projection(proj) => match proj.elem {\n-                ProjectionElem::Field(..)\n-                | ProjectionElem::Downcast(..)\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Index(_) => proj.base.ignore_borrow(\n-                    tcx, mir, locals_state_at_exit),\n+                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. }) =>\n+                    false,\n+                PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. }) => {\n+                    tcx.is_mutable_static(*def_id)\n+                }\n+            };\n \n-                ProjectionElem::Deref => {\n+            for proj in place_projection {\n+                if proj.elem == ProjectionElem::Deref {\n                     let ty = proj.base.ty(mir, tcx).ty;\n                     match ty.sty {\n                         // For both derefs of raw pointers and `&T`\n@@ -71,11 +67,13 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                         // original path into a new variable and\n                         // borrowed *that* one, leaving the original\n                         // path unborrowed.\n-                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => true,\n-                        _ => proj.base.ignore_borrow(tcx, mir, locals_state_at_exit),\n+                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => return true,\n+                        _ => {}\n                     }\n                 }\n-            },\n-        }\n+            }\n+\n+            ignore\n+        })\n     }\n }"}]}