{"sha": "584252bfb053149b1405da0951cd855561694990", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NDI1MmJmYjA1MzE0OWIxNDA1ZGEwOTUxY2Q4NTU1NjE2OTQ5OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-16T07:14:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-16T07:14:52Z"}, "message": "Auto merge of #71665 - RalfJung:miri-intern-no-ice, r=oli-obk\n\nMiri interning: replace ICEs by proper errors\n\nFixes https://github.com/rust-lang/rust/issues/71316\n\nI also did some refactoring, as I kept being confused by all the parameters to `intern_shallow`, some of which have invalid combinations (such as a mutable const). So instead `InternMode` now contains all the information that is needed and invalid combinations are ruled out by the type system.\n\nAlso I removed interpreter errors from interning. We already ignored almost all errors, and the `ValidationFailure` errors that we handled separately actually cannot ever happen here. The only interpreter failure that was actually reachable was the UB on dangling pointers -- and arguably, a dangling raw pointer is not UB, so the error was not even correct. It's just that the rest of the compiler does not like \"dangling\" `AllocId`.\n\nIt should be possible to review the 3 commits separately.\n\nr? @oli-obk\nCc @rust-lang/wg-const-eval", "tree": {"sha": "e4fce6d805d9542f26af054f9ab40d6c6bea0814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4fce6d805d9542f26af054f9ab40d6c6bea0814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/584252bfb053149b1405da0951cd855561694990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/584252bfb053149b1405da0951cd855561694990", "html_url": "https://github.com/rust-lang/rust/commit/584252bfb053149b1405da0951cd855561694990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/584252bfb053149b1405da0951cd855561694990/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84539360498cab3c70a7c9114c0b8106c8e1b06b", "url": "https://api.github.com/repos/rust-lang/rust/commits/84539360498cab3c70a7c9114c0b8106c8e1b06b", "html_url": "https://github.com/rust-lang/rust/commit/84539360498cab3c70a7c9114c0b8106c8e1b06b"}, {"sha": "e73ee41241240f740afc10a6fc16521215759ed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e73ee41241240f740afc10a6fc16521215759ed7", "html_url": "https://github.com/rust-lang/rust/commit/e73ee41241240f740afc10a6fc16521215759ed7"}], "stats": {"total": 667, "additions": 331, "deletions": 336}, "files": [{"sha": "0637ebf959e5a6b1ef0bd340a83481b913f51da9", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -66,7 +66,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         intern_kind,\n         ret,\n         body.ignore_interior_mut_in_const_validation,\n-    )?;\n+    );\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)"}, {"sha": "7f557e340bbc8caa4ae4983f9a1ffcbf60c55928", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false).unwrap();\n+    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false);\n     ConstValue::Scalar(loc_place.ptr)\n }\n "}, {"sha": "eba4dd336ade2d1bb110f7a1db0044b9caf65239", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -871,6 +871,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Our result will later be validated anyway, and there seems no good reason\n         // to have to fail early here.  This is also more consistent with\n         // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n+        // FIXME: We can hit delay_span_bug if this is an invalid const, interning finds\n+        // that problem, but we never run validation to show an error. Can we ensure\n+        // this does not happen?\n         let val = self.tcx.const_eval_raw(param_env.and(gid))?;\n         self.raw_const_to_mplace(val)\n     }"}, {"sha": "02a7f24a1e351d20438d1b36dc74f6466f243b8e", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 177, "deletions": 153, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -5,10 +5,9 @@\n \n use super::validity::RefTracking;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_middle::mir::interpret::{ErrorHandled, InterpResult};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::mir::interpret::InterpResult;\n+use rustc_middle::ty::{self, query::TyCtxtAt, Ty};\n \n use rustc_ast::ast::Mutability;\n \n@@ -29,43 +28,45 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// The ectx from which we intern.\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n     /// Previously encountered safe references.\n-    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, InternMode)>,\n     /// A list of all encountered allocations. After type-based interning, we traverse this list to\n     /// also intern allocations that are only referenced by a raw pointer or inside a union.\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n-    /// The root node of the value that we're looking at. This field is never mutated and only used\n+    /// The root kind of the value that we're looking at. This field is never mutated and only used\n     /// for sanity assertions that will ICE when `const_qualif` screws up.\n     mode: InternMode,\n-    /// This field stores the mutability of the value *currently* being checked.\n-    /// When encountering a mutable reference, we determine the pointee mutability\n-    /// taking into account the mutability of the context: `& &mut i32` is entirely immutable,\n-    /// despite the nested mutable reference!\n-    /// The field gets updated when an `UnsafeCell` is encountered.\n-    mutability: Mutability,\n+    /// This field stores whether we are *currently* inside an `UnsafeCell`. This can affect\n+    /// the intern mode of references we encounter.\n+    inside_unsafe_cell: bool,\n \n     /// This flag is to avoid triggering UnsafeCells are not allowed behind references in constants\n     /// for promoteds.\n     /// It's a copy of `mir::Body`'s ignore_interior_mut_in_const_validation field\n-    ignore_interior_mut_in_const_validation: bool,\n+    ignore_interior_mut_in_const: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n enum InternMode {\n-    /// Mutable references must in fact be immutable due to their surrounding immutability in a\n-    /// `static`. In a `static mut` we start out as mutable and thus can also contain further `&mut`\n-    /// that will actually be treated as mutable.\n-    Static,\n-    /// UnsafeCell is OK in the value of a constant: `const FOO = Cell::new(0)` creates\n-    /// a new cell every time it is used.\n+    /// A static and its current mutability.  Below shared references inside a `static mut`,\n+    /// this is *immutable*, and below mutable references inside an `UnsafeCell`, this\n+    /// is *mutable*.\n+    Static(hir::Mutability),\n+    /// The \"base value\" of a const, which can have `UnsafeCell` (as in `const FOO: Cell<i32>`),\n+    /// but that interior mutability is simply ignored.\n     ConstBase,\n-    /// `UnsafeCell` ICEs.\n-    Const,\n+    /// The \"inner values\" of a const with references, where `UnsafeCell` is an error.\n+    ConstInner,\n }\n \n /// Signalling data structure to ensure we don't recurse\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n+fn mutable_memory_in_const(tcx: TyCtxtAt<'_>, kind: &str) {\n+    // FIXME: show this in validation instead so we can point at where in the value the error is?\n+    tcx.sess.span_err(tcx.span, &format!(\"mutable memory ({}) is not allowed in constant\", kind));\n+}\n+\n /// Intern an allocation without looking at its children.\n /// `mode` is the mode of the environment where we found this pointer.\n /// `mutablity` is the mutability of the place to be interned; even if that says\n@@ -75,12 +76,11 @@ struct IsStaticOrFn;\n fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n-    mode: InternMode,\n     alloc_id: AllocId,\n-    mutability: Mutability,\n+    mode: InternMode,\n     ty: Option<Ty<'tcx>>,\n-) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-    trace!(\"InternVisitor::intern {:?} with {:?}\", alloc_id, mutability,);\n+) -> Option<IsStaticOrFn> {\n+    trace!(\"intern_shallow {:?} with {:?}\", alloc_id, mode);\n     // remove allocation\n     let tcx = ecx.tcx;\n     let (kind, mut alloc) = match ecx.memory.alloc_map.remove(&alloc_id) {\n@@ -89,14 +89,15 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             // Pointer not found in local memory map. It is either a pointer to the global\n             // map, or dangling.\n             // If the pointer is dangling (neither in local nor global memory), we leave it\n-            // to validation to error. The `delay_span_bug` ensures that we don't forget such\n-            // a check in validation.\n+            // to validation to error -- it has the much better error messages, pointing out where\n+            // in the value the dangling reference lies.\n+            // The `delay_span_bug` ensures that we don't forget such a check in validation.\n             if tcx.get_global_alloc(alloc_id).is_none() {\n                 tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n             }\n             // treat dangling pointers like other statics\n             // just to stop trying to recurse into them\n-            return Ok(Some(IsStaticOrFn));\n+            return Some(IsStaticOrFn);\n         }\n     };\n     // This match is just a canary for future changes to `MemoryKind`, which most likely need\n@@ -107,45 +108,45 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     // Set allocation mutability as appropriate. This is used by LLVM to put things into\n     // read-only memory, and also by Miri when evaluating other globals that\n     // access this one.\n-    if mode == InternMode::Static {\n-        // When `ty` is `None`, we assume no interior mutability.\n+    if let InternMode::Static(mutability) = mode {\n+        // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n+        // no interior mutability.\n         let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx.tcx, ecx.param_env, ecx.tcx.span));\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n-        if mutability == Mutability::Not && frozen {\n+        let immutable = mutability == Mutability::Not && frozen;\n+        if immutable {\n             alloc.mutability = Mutability::Not;\n         } else {\n             // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n             assert_eq!(alloc.mutability, Mutability::Mut);\n         }\n     } else {\n-        // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n-        // But we still intern that as immutable as the memory cannot be changed once the\n-        // initial value was computed.\n-        // Constants are never mutable.\n-        assert_eq!(\n-            mutability,\n-            Mutability::Not,\n-            \"Something went very wrong: mutability requested for a constant\"\n-        );\n+        // No matter what, *constants are never mutable*. Mutating them is UB.\n+        // See const_eval::machine::MemoryExtra::can_access_statics for why\n+        // immutability is so important.\n+\n+        // There are no sensible checks we can do here; grep for `mutable_memory_in_const` to\n+        // find the checks we are doing elsewhere to avoid even getting here for memory\n+        // that \"wants\" to be mutable.\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n     leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n-    Ok(None)\n+    None\n }\n \n impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir, 'tcx, M> {\n     fn intern_shallow(\n         &mut self,\n         alloc_id: AllocId,\n-        mutability: Mutability,\n+        mode: InternMode,\n         ty: Option<Ty<'tcx>>,\n-    ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n-        intern_shallow(self.ecx, self.leftover_allocations, self.mode, alloc_id, mutability, ty)\n+    ) -> Option<IsStaticOrFn> {\n+        intern_shallow(self.ecx, self.leftover_allocations, alloc_id, mode, ty)\n     }\n }\n \n@@ -166,22 +167,22 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     ) -> InterpResult<'tcx> {\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n+                if self.mode == InternMode::ConstInner && !self.ignore_interior_mut_in_const {\n+                    // We do not actually make this memory mutable.  But in case the user\n+                    // *expected* it to be mutable, make sure we error.  This is just a\n+                    // sanity check to prevent users from accidentally exploiting the UB\n+                    // they caused.  It also helps us to find cases where const-checking\n+                    // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n+                    // shows that part is not airtight).\n+                    mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n+                }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n-                let old = std::mem::replace(&mut self.mutability, Mutability::Mut);\n-                if !self.ignore_interior_mut_in_const_validation {\n-                    assert_ne!(\n-                        self.mode,\n-                        InternMode::Const,\n-                        \"UnsafeCells are not allowed behind references in constants. This should \\\n-                        have been prevented statically by const qualification. If this were \\\n-                        allowed one would be able to change a constant at one use site and other \\\n-                        use sites could observe that mutation.\",\n-                    );\n-                }\n+                // Remember the `old` value to handle nested `UnsafeCell`.\n+                let old = std::mem::replace(&mut self.inside_unsafe_cell, true);\n                 let walked = self.walk_aggregate(mplace, fields);\n-                self.mutability = old;\n+                self.inside_unsafe_cell = old;\n                 return walked;\n             }\n         }\n@@ -191,78 +192,92 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n+        let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n-        if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n+        if let ty::Ref(_, referenced_ty, ref_mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n             let mplace = self.ecx.ref_to_mplace(value)?;\n+            assert_eq!(mplace.layout.ty, referenced_ty);\n             // Handle trait object vtables.\n             if let ty::Dynamic(..) =\n-                self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n+                tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n             {\n-                // Validation has already errored on an invalid vtable pointer so we can safely not\n-                // do anything if this is not a real pointer.\n+                // Validation will error (with a better message) on an invalid vtable pointer\n+                // so we can safely not do anything if this is not a real pointer.\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n-                    // Explicitly choose `Immutable` here, since vtables are immutable, even\n+                    // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n-                    self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n+                    self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n                 } else {\n-                    self.ecx().tcx.sess.delay_span_bug(\n-                        rustc_span::DUMMY_SP,\n-                        \"vtables pointers cannot be integer pointers\",\n-                    );\n+                    // Let validation show the error message, but make sure it *does* error.\n+                    tcx.sess\n+                        .delay_span_bug(tcx.span, \"vtables pointers cannot be integer pointers\");\n                 }\n             }\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n-                // We do not have any `frozen` logic here, because it's essentially equivalent to\n-                // the mutability except for the outermost item. Only `UnsafeCell` can \"unfreeze\",\n-                // and we check that in `visit_aggregate`.\n-                // This is not an inherent limitation, but one that we know to be true, because\n-                // const qualification enforces it. We can lift it in the future.\n-                match (self.mode, mutability) {\n-                    // immutable references are fine everywhere\n-                    (_, hir::Mutability::Not) => {}\n-                    // all is \"good and well\" in the unsoundness of `static mut`\n+                // Compute the mode with which we intern this.\n+                let ref_mode = match self.mode {\n+                    InternMode::Static(mutbl) => {\n+                        // In statics, merge outer mutability with reference mutability and\n+                        // take into account whether we are in an `UnsafeCell`.\n \n-                    // mutable references are ok in `static`. Either they are treated as immutable\n-                    // because they are behind an immutable one, or they are behind an `UnsafeCell`\n-                    // and thus ok.\n-                    (InternMode::Static, hir::Mutability::Mut) => {}\n-                    // we statically prevent `&mut T` via `const_qualif` and double check this here\n-                    (InternMode::ConstBase | InternMode::Const, hir::Mutability::Mut) => {\n-                        match referenced_ty.kind {\n-                            ty::Array(_, n)\n-                                if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n-                            ty::Slice(_)\n-                                if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)? == 0 => {}\n-                            _ => bug!(\"const qualif failed to prevent mutable references\"),\n+                        // The only way a mutable reference actually works as a mutable reference is\n+                        // by being in a `static mut` directly or behind another mutable reference.\n+                        // If there's an immutable reference or we are inside a `static`, then our\n+                        // mutable reference is equivalent to an immutable one. As an example:\n+                        // `&&mut Foo` is semantically equivalent to `&&Foo`\n+                        match ref_mutability {\n+                            _ if self.inside_unsafe_cell => {\n+                                // Inside an `UnsafeCell` is like inside a `static mut`, the \"outer\"\n+                                // mutability does not matter.\n+                                InternMode::Static(ref_mutability)\n+                            }\n+                            Mutability::Not => {\n+                                // A shared reference, things become immutable.\n+                                // We do *not* consier `freeze` here -- that is done more precisely\n+                                // when traversing the referenced data (by tracking `UnsafeCell`).\n+                                InternMode::Static(Mutability::Not)\n+                            }\n+                            Mutability::Mut => {\n+                                // Mutable reference.\n+                                InternMode::Static(mutbl)\n+                            }\n                         }\n                     }\n-                }\n-                // Compute the mutability with which we'll start visiting the allocation. This is\n-                // what gets changed when we encounter an `UnsafeCell`.\n-                //\n-                // The only way a mutable reference actually works as a mutable reference is\n-                // by being in a `static mut` directly or behind another mutable reference.\n-                // If there's an immutable reference or we are inside a static, then our\n-                // mutable reference is equivalent to an immutable one. As an example:\n-                // `&&mut Foo` is semantically equivalent to `&&Foo`\n-                let mutability = self.mutability.and(mutability);\n-                // Recursing behind references changes the intern mode for constants in order to\n-                // cause assertions to trigger if we encounter any `UnsafeCell`s.\n-                let mode = match self.mode {\n-                    InternMode::ConstBase => InternMode::Const,\n-                    other => other,\n+                    InternMode::ConstBase | InternMode::ConstInner => {\n+                        // Ignore `UnsafeCell`, everything is immutable.  Do some sanity checking\n+                        // for mutable references that we encounter -- they must all be ZST.\n+                        // This helps to prevent users from accidentally exploiting UB that they\n+                        // caused (by somehow getting a mutable reference in a `const`).\n+                        if ref_mutability == Mutability::Mut {\n+                            match referenced_ty.kind {\n+                                ty::Array(_, n)\n+                                    if n.eval_usize(tcx.tcx, self.ecx.param_env) == 0 => {}\n+                                ty::Slice(_)\n+                                    if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n+                                        == 0 => {}\n+                                _ => mutable_memory_in_const(tcx, \"`&mut`\"),\n+                            }\n+                        } else {\n+                            // A shared reference. We cannot check `freeze` here due to references\n+                            // like `&dyn Trait` that are actually immutable.  We do check for\n+                            // concrete `UnsafeCell` when traversing the pointee though (if it is\n+                            // a new allocation, not yet interned).\n+                        }\n+                        // Go on with the \"inner\" rules.\n+                        InternMode::ConstInner\n+                    }\n                 };\n-                match self.intern_shallow(ptr.alloc_id, mutability, Some(mplace.layout.ty))? {\n+                match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty)) {\n                     // No need to recurse, these are interned already and statics may have\n                     // cycles, so we don't want to recurse there\n                     Some(IsStaticOrFn) => {}\n                     // intern everything referenced by this value. The mutability is taken from the\n                     // reference. It is checked above that mutable references only happen in\n                     // `static mut`\n-                    None => self.ref_tracking.track((mplace, mutability, mode), || ()),\n+                    None => self.ref_tracking.track((mplace, ref_mode), || ()),\n                 }\n             }\n             Ok(())\n@@ -273,6 +288,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n pub enum InternKind {\n     /// The `mutability` of the static, ignoring the type which may have interior mutability.\n     Static(hir::Mutability),\n@@ -281,71 +297,78 @@ pub enum InternKind {\n     ConstProp,\n }\n \n+/// Intern `ret` and everything it references.\n+///\n+/// This *cannot raise an interpreter error*.  Doing so is left to validation, which\n+/// tracks where in the value we are and thus can show much better error messages.\n+/// Any errors here would anyway be turned into `const_err` lints, whereas validation failures\n+/// are hard errors.\n pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n-    ignore_interior_mut_in_const_validation: bool,\n-) -> InterpResult<'tcx>\n-where\n+    ignore_interior_mut_in_const: bool,\n+) where\n     'tcx: 'mir,\n {\n     let tcx = ecx.tcx;\n-    let (base_mutability, base_intern_mode) = match intern_kind {\n-        // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        InternKind::Static(mutbl) => (mutbl, InternMode::Static),\n+    let base_intern_mode = match intern_kind {\n+        InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // FIXME: what about array lengths, array initializers?\n-        InternKind::Constant | InternKind::ConstProp => (Mutability::Not, InternMode::ConstBase),\n-        InternKind::Promoted => (Mutability::Not, InternMode::ConstBase),\n+        InternKind::Constant | InternKind::ConstProp | InternKind::Promoted => {\n+            InternMode::ConstBase\n+        }\n     };\n \n     // Type based interning.\n-    // `ref_tracking` tracks typed references we have seen and still need to crawl for\n+    // `ref_tracking` tracks typed references we have already interned and still need to crawl for\n     // more typed information inside them.\n     // `leftover_allocations` collects *all* allocations we see, because some might not\n     // be available in a typed way. They get interned at the end.\n-    let mut ref_tracking = RefTracking::new((ret, base_mutability, base_intern_mode));\n+    let mut ref_tracking = RefTracking::empty();\n     let leftover_allocations = &mut FxHashSet::default();\n \n     // start with the outermost allocation\n     intern_shallow(\n         ecx,\n         leftover_allocations,\n-        base_intern_mode,\n         // The outermost allocation must exist, because we allocated it with\n         // `Memory::allocate`.\n         ret.ptr.assert_ptr().alloc_id,\n-        base_mutability,\n+        base_intern_mode,\n         Some(ret.layout.ty),\n-    )?;\n+    );\n \n-    while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n-        let interned = InternVisitor {\n+    ref_tracking.track((ret, base_intern_mode), || ());\n+\n+    while let Some(((mplace, mode), _)) = ref_tracking.todo.pop() {\n+        let res = InternVisitor {\n             ref_tracking: &mut ref_tracking,\n             ecx,\n             mode,\n             leftover_allocations,\n-            mutability,\n-            ignore_interior_mut_in_const_validation,\n+            ignore_interior_mut_in_const,\n+            inside_unsafe_cell: false,\n         }\n         .visit_value(mplace);\n-        if let Err(error) = interned {\n-            // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n-            // to read enum discriminants in order to find references in enum variant fields.\n-            if let err_ub!(ValidationFailure(_)) = error.kind {\n-                let err = crate::const_eval::error_to_const_error(&ecx, error);\n-                match err.struct_error(\n-                    ecx.tcx,\n-                    \"it is undefined behavior to use this value\",\n-                    |mut diag| {\n-                        diag.note(crate::const_eval::note_on_undefined_behavior_error());\n-                        diag.emit();\n-                    },\n-                ) {\n-                    ErrorHandled::TooGeneric\n-                    | ErrorHandled::Reported(ErrorReported)\n-                    | ErrorHandled::Linted => {}\n-                }\n+        // We deliberately *ignore* interpreter errors here.  When there is a problem, the remaining\n+        // references are \"leftover\"-interned, and later validation will show a proper error\n+        // and point at the right part of the value causing the problem.\n+        match res {\n+            Ok(()) => {}\n+            Err(error) => {\n+                ecx.tcx.sess.delay_span_bug(\n+                    ecx.tcx.span,\n+                    \"error during interning should later cause validation failure\",\n+                );\n+                // Some errors shouldn't come up because creating them causes\n+                // an allocation, which we should avoid. When that happens,\n+                // dedicated error variants should be introduced instead.\n+                assert!(\n+                    !error.kind.allocates(),\n+                    \"interning encountered allocating error: {}\",\n+                    error\n+                );\n             }\n         }\n     }\n@@ -366,26 +389,27 @@ where\n                 InternKind::Static(_) => {}\n                 // Raw pointers in promoteds may only point to immutable things so we mark\n                 // everything as immutable.\n-                // It is UB to mutate through a raw pointer obtained via an immutable reference.\n+                // It is UB to mutate through a raw pointer obtained via an immutable reference:\n                 // Since all references and pointers inside a promoted must by their very definition\n                 // be created from an immutable reference (and promotion also excludes interior\n                 // mutability), mutating through them would be UB.\n                 // There's no way we can check whether the user is using raw pointers correctly,\n                 // so all we can do is mark this as immutable here.\n                 InternKind::Promoted => {\n+                    // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                    // immutability is so important.\n                     alloc.mutability = Mutability::Not;\n                 }\n                 InternKind::Constant | InternKind::ConstProp => {\n-                    // If it's a constant, it *must* be immutable.\n-                    // We cannot have mutable memory inside a constant.\n-                    // We use `delay_span_bug` here, because this can be reached in the presence\n-                    // of fancy transmutes.\n-                    if alloc.mutability == Mutability::Mut {\n-                        // For better errors later, mark the allocation as immutable\n-                        // (on top of the delayed ICE).\n-                        alloc.mutability = Mutability::Not;\n-                        ecx.tcx.sess.delay_span_bug(ecx.tcx.span, \"mutable allocation in constant\");\n-                    }\n+                    // If it's a constant, we should not have any \"leftovers\" as everything\n+                    // is tracked by const-checking.\n+                    // FIXME: downgrade this to a warning? It rejects some legitimate consts,\n+                    // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n+                    ecx.tcx\n+                        .sess\n+                        .span_err(ecx.tcx.span, \"untyped pointers are not allowed in constant\");\n+                    // For better errors later, mark the allocation as immutable.\n+                    alloc.mutability = Mutability::Not;\n                 }\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n@@ -396,13 +420,13 @@ where\n                 }\n             }\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n-            // dangling pointer\n-            throw_ub_format!(\"encountered dangling pointer in final constant\")\n+            // Codegen does not like dangling pointers, and generally `tcx` assumes that\n+            // all allocations referenced anywhere actually exist. So, make sure we error here.\n+            ecx.tcx.sess.span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n         } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n-            // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n-            // as dangling by local memory.\n+            // We have hit an `AllocId` that is neither in local or global memory and isn't\n+            // marked as dangling by local memory.  That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }\n-    Ok(())\n }"}, {"sha": "c1e577c8ab237790fb2f05a9c6a177dc98bcde76", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -709,8 +709,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n                 let mplace = op.assert_mem_place(&self.ecx);\n-                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false)\n-                    .expect(\"failed to intern alloc\");\n+                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false);\n                 true\n             }\n             _ => false,"}, {"sha": "3b7f1de5b9bea728a515009a026958a2659bb6da", "filename": "src/test/ui/consts/dangling-alloc-id-ice.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -1,11 +1,13 @@\n // https://github.com/rust-lang/rust/issues/55223\n+#![allow(const_err)]\n \n union Foo<'a> {\n     y: &'a (),\n     long_live_the_unit: &'static (),\n }\n \n-const FOO: &() = { //~ ERROR any use of this value will cause an error\n+const FOO: &() = { //~ ERROR it is undefined behavior to use this value\n+//~^ ERROR encountered dangling pointer in final constant\n     let y = ();\n     unsafe { Foo { y: &y }.long_live_the_unit }\n };"}, {"sha": "14a49810b9de5fe07d99b50742abed192d0b7eac", "filename": "src/test/ui/consts/dangling-alloc-id-ice.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -1,13 +1,25 @@\n-error: any use of this value will cause an error\n-  --> $DIR/dangling-alloc-id-ice.rs:8:1\n+error: encountered dangling pointer in final constant\n+  --> $DIR/dangling-alloc-id-ice.rs:9:1\n    |\n LL | / const FOO: &() = {\n+LL | |\n LL | |     let y = ();\n LL | |     unsafe { Foo { y: &y }.long_live_the_unit }\n LL | | };\n-   | |__^ encountered dangling pointer in final constant\n+   | |__^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/dangling-alloc-id-ice.rs:9:1\n+   |\n+LL | / const FOO: &() = {\n+LL | |\n+LL | |     let y = ();\n+LL | |     unsafe { Foo { y: &y }.long_live_the_unit }\n+LL | | };\n+   | |__^ type validation failed: encountered a dangling reference (use-after-free)\n    |\n-   = note: `#[deny(const_err)]` on by default\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "ddd1fb1ba76e163124a485ff3643e78114aa6309", "filename": "src/test/ui/consts/dangling_raw_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -1,4 +1,4 @@\n-const FOO: *const u32 = { //~ ERROR any use of this value will cause an error\n+const FOO: *const u32 = { //~ ERROR encountered dangling pointer in final constant\n     let x = 42;\n     &x\n };"}, {"sha": "a79ac62d5cdbdcce13ea7947f244036b8ab13317", "filename": "src/test/ui/consts/dangling_raw_ptr.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -1,13 +1,11 @@\n-error: any use of this value will cause an error\n+error: encountered dangling pointer in final constant\n   --> $DIR/dangling_raw_ptr.rs:1:1\n    |\n LL | / const FOO: *const u32 = {\n LL | |     let x = 42;\n LL | |     &x\n LL | | };\n-   | |__^ encountered dangling pointer in final constant\n-   |\n-   = note: `#[deny(const_err)]` on by default\n+   | |__^\n \n error: aborting due to previous error\n "}, {"sha": "f8aa652827381c32d29b9394c1443394c641972b", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs?ref=84539360498cab3c70a7c9114c0b8106c8e1b06b", "patch": "@@ -1,25 +0,0 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n-// normalize-stderr-test \"alloc[0-9]+\" -> \"allocN\"\n-\n-#![deny(const_err)] // The `allow` variant is tested by `mutable_const2`.\n-//~^ NOTE lint level\n-// Here we check that even though `MUTABLE_BEHIND_RAW` is created from a mutable\n-// allocation, we intern that allocation as *immutable* and reject writes to it.\n-// We avoid the `delay_span_bug` ICE by having compilation fail via the `deny` above.\n-\n-use std::cell::UnsafeCell;\n-\n-// make sure we do not just intern this as mutable\n-const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-\n-const MUTATING_BEHIND_RAW: () = { //~ NOTE\n-    // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n-    unsafe {\n-        *MUTABLE_BEHIND_RAW = 99 //~ ERROR any use of this value will cause an error\n-        //~^ NOTE: which is read-only\n-        // FIXME would be good to match more of the error message here, but looks like we\n-        // normalize *after* checking the annoations here.\n-    }\n-};\n-\n-fn main() {}"}, {"sha": "4772baf9d9a019a7bb254dd4256816c165430f39", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=84539360498cab3c70a7c9114c0b8106c8e1b06b", "patch": "@@ -1,39 +0,0 @@\n-error: any use of this value will cause an error\n-  --> $DIR/mutable_const.rs:18:9\n-   |\n-LL | / const MUTATING_BEHIND_RAW: () = {\n-LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n-LL | |     unsafe {\n-LL | |         *MUTABLE_BEHIND_RAW = 99\n-   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to allocN which is read-only\n-...  |\n-LL | |     }\n-LL | | };\n-   | |__-\n-   |\n-note: the lint level is defined here\n-  --> $DIR/mutable_const.rs:4:9\n-   |\n-LL | #![deny(const_err)] // The `allow` variant is tested by `mutable_const2`.\n-   |         ^^^^^^^^^\n-\n-warning: skipping const checks\n-   |\n-help: skipping check that does not even have a feature gate\n-  --> $DIR/mutable_const.rs:13:38\n-   |\n-LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-   |                                      ^^^^^^^^^^^^^^^^^^^^\n-help: skipping check for `const_raw_ptr_deref` feature\n-  --> $DIR/mutable_const.rs:18:9\n-   |\n-LL |         *MUTABLE_BEHIND_RAW = 99\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n-  --> $DIR/mutable_const.rs:18:9\n-   |\n-LL |         *MUTABLE_BEHIND_RAW = 99\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error; 1 warning emitted\n-"}, {"sha": "867091af7ba762335a31e9f7a2ee2b9070b191a1", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs?ref=84539360498cab3c70a7c9114c0b8106c8e1b06b", "patch": "@@ -1,16 +0,0 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n-// failure-status: 101\n-// rustc-env:RUST_BACKTRACE=0\n-// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n-// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n-// normalize-stderr-test \"interpret/intern.rs:[0-9]+:[0-9]+\" -> \"interpret/intern.rs:LL:CC\"\n-\n-#![allow(const_err)]\n-\n-use std::cell::UnsafeCell;\n-\n-// make sure we do not just intern this as mutable\n-const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-//~^ ERROR: mutable allocation in constant\n-\n-fn main() {}"}, {"sha": "98a1c8bdd8967d881efd94a8800947cda3251b0d", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.stderr", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr?ref=84539360498cab3c70a7c9114c0b8106c8e1b06b", "patch": "@@ -1,29 +0,0 @@\n-warning: skipping const checks\n-   |\n-help: skipping check that does not even have a feature gate\n-  --> $DIR/mutable_const2.rs:13:38\n-   |\n-LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-   |                                      ^^^^^^^^^^^^^^^^^^^^\n-\n-warning: 1 warning emitted\n-\n-error: internal compiler error: mutable allocation in constant\n-  --> $DIR/mutable_const2.rs:13:1\n-   |\n-LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-thread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:366:17\n-note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-\n-error: internal compiler error: unexpected panic\n-\n-note: the compiler unexpectedly panicked. this is a bug.\n-\n-note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\n-\n-note: rustc VERSION running on TARGET\n-\n-note: compiler flags: FLAGS\n-"}, {"sha": "ca927ef4a518b0226ffff0ad9efe4db2ae3122bc", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -17,12 +17,11 @@ struct Foo<T>(T);\n // this is fine for the same reason as `BAR`.\n static BOO: &mut Foo<()> = &mut Foo(());\n \n+// interior mutability is fine\n struct Meh {\n     x: &'static UnsafeCell<i32>,\n }\n-\n unsafe impl Sync for Meh {}\n-\n static MEH: Meh = Meh {\n     x: &UnsafeCell::new(42),\n };"}, {"sha": "7109ffd8b61d783b1c770ad0ce172cb55e03ac79", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -1,5 +1,5 @@\n error[E0594]: cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n-  --> $DIR/mutable_references.rs:37:5\n+  --> $DIR/mutable_references.rs:36:5\n    |\n LL |     *OH_YES = 99;\n    |     ^^^^^^^^^^^^ cannot assign\n@@ -22,12 +22,12 @@ help: skipping check for `const_mut_refs` feature\n LL | static BOO: &mut Foo<()> = &mut Foo(());\n    |                            ^^^^^^^^^^^^\n help: skipping check that does not even have a feature gate\n-  --> $DIR/mutable_references.rs:27:8\n+  --> $DIR/mutable_references.rs:26:8\n    |\n LL |     x: &UnsafeCell::new(42),\n    |        ^^^^^^^^^^^^^^^^^^^^\n help: skipping check for `const_mut_refs` feature\n-  --> $DIR/mutable_references.rs:31:27\n+  --> $DIR/mutable_references.rs:30:27\n    |\n LL | static OH_YES: &mut i32 = &mut 42;\n    |                           ^^^^^^^"}, {"sha": "06fb27bcff86620b429cdd60a7c24216f8e87723", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -0,0 +1,37 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![allow(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// this test ensures that our mutability story is sound\n+\n+struct Meh {\n+    x: &'static UnsafeCell<i32>,\n+}\n+unsafe impl Sync for Meh {}\n+\n+// the following will never be ok! no interior mut behind consts, because\n+// all allocs interned here will be marked immutable.\n+const MUH: Meh = Meh { //~ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+    x: &UnsafeCell::new(42),\n+};\n+\n+struct Synced {\n+    x: UnsafeCell<i32>,\n+}\n+unsafe impl Sync for Synced {}\n+\n+// Make sure we also catch this behind a type-erased `dyn Trait` reference.\n+const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n+//~^ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+\n+// Make sure we also catch mutable references.\n+const BLUNT: &mut i32 = &mut 42;\n+//~^ ERROR: mutable memory (`&mut`) is not allowed in constant\n+\n+fn main() {\n+    unsafe {\n+        *MUH.x.get() = 99;\n+    }\n+}"}, {"sha": "45e7d5a2cc3b3e03bb93d0054c27d2e7a41c499d", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -0,0 +1,40 @@\n+error: mutable memory (`UnsafeCell`) is not allowed in constant\n+  --> $DIR/mutable_references_err.rs:16:1\n+   |\n+LL | / const MUH: Meh = Meh {\n+LL | |     x: &UnsafeCell::new(42),\n+LL | | };\n+   | |__^\n+\n+error: mutable memory (`UnsafeCell`) is not allowed in constant\n+  --> $DIR/mutable_references_err.rs:26:1\n+   |\n+LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable memory (`&mut`) is not allowed in constant\n+  --> $DIR/mutable_references_err.rs:30:1\n+   |\n+LL | const BLUNT: &mut i32 = &mut 42;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+   |\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/mutable_references_err.rs:17:8\n+   |\n+LL |     x: &UnsafeCell::new(42),\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/mutable_references_err.rs:26:27\n+   |\n+LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: skipping check for `const_mut_refs` feature\n+  --> $DIR/mutable_references_err.rs:30:25\n+   |\n+LL | const BLUNT: &mut i32 = &mut 42;\n+   |                         ^^^^^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+"}, {"sha": "7388aad2a9e53c05b90bb5910f40f3ff1a7aa732", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs?ref=84539360498cab3c70a7c9114c0b8106c8e1b06b", "patch": "@@ -1,29 +0,0 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n-// failure-status: 101\n-// rustc-env:RUST_BACKTRACE=0\n-// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n-// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n-// normalize-stderr-test \"interpret/intern.rs:[0-9]+:[0-9]+\" -> \"interpret/intern.rs:LL:CC\"\n-\n-#![allow(const_err)]\n-\n-use std::cell::UnsafeCell;\n-\n-// this test ICEs to ensure that our mutability story is sound\n-\n-struct Meh {\n-    x: &'static UnsafeCell<i32>,\n-}\n-\n-unsafe impl Sync for Meh {}\n-\n-// the following will never be ok!\n-const MUH: Meh = Meh {\n-    x: &UnsafeCell::new(42),\n-};\n-\n-fn main() {\n-    unsafe {\n-        *MUH.x.get() = 99;\n-    }\n-}"}, {"sha": "7ddf77af4d3af645a272acd7b0fff0cb82aa296a", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.stderr", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84539360498cab3c70a7c9114c0b8106c8e1b06b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr?ref=84539360498cab3c70a7c9114c0b8106c8e1b06b", "patch": "@@ -1,25 +0,0 @@\n-thread 'rustc' panicked at 'assertion failed: `(left != right)`\n-  left: `Const`,\n- right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites could observe that mutation.', src/librustc_mir/interpret/intern.rs:LL:CC\n-note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-\n-error: internal compiler error: unexpected panic\n-\n-note: the compiler unexpectedly panicked. this is a bug.\n-\n-note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\n-\n-note: rustc VERSION running on TARGET\n-\n-note: compiler flags: FLAGS\n-\n-warning: skipping const checks\n-   |\n-help: skipping check that does not even have a feature gate\n-  --> $DIR/mutable_references_ice.rs:22:8\n-   |\n-LL |     x: &UnsafeCell::new(42),\n-   |        ^^^^^^^^^^^^^^^^^^^^\n-\n-warning: 1 warning emitted\n-"}, {"sha": "cabd754e01ac30165070cf962f2994c8e8cb173e", "filename": "src/test/ui/consts/miri_unleashed/raw_mutable_const.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![allow(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+//~^ ERROR: untyped pointers are not allowed in constant\n+\n+fn main() {}"}, {"sha": "b5b5a965295a720fe7b4d2dc826cc469146d4240", "filename": "src/test/ui/consts/miri_unleashed/raw_mutable_const.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -0,0 +1,16 @@\n+error: untyped pointers are not allowed in constant\n+  --> $DIR/raw_mutable_const.rs:7:1\n+   |\n+LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+   |\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/raw_mutable_const.rs:7:38\n+   |\n+LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "00fad046b557d337f6d6540d93f627feb3c2ce57", "filename": "src/test/ui/consts/raw-ptr-const.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.rs?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -0,0 +1,10 @@\n+#![allow(const_err)] // make sure we hit the `delay_span_bug`\n+\n+// This is a regression test for a `delay_span_bug` during interning when a constant\n+// evaluates to a (non-dangling) raw pointer.  For now this errors; potentially it\n+// could also be allowed.\n+\n+const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;\n+//~^ ERROR untyped pointers are not allowed in constant\n+\n+fn main() {}"}, {"sha": "974b1c3ff45b55c891d2af81e1d7007f39051846", "filename": "src/test/ui/consts/raw-ptr-const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/584252bfb053149b1405da0951cd855561694990/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fraw-ptr-const.stderr?ref=584252bfb053149b1405da0951cd855561694990", "patch": "@@ -0,0 +1,8 @@\n+error: untyped pointers are not allowed in constant\n+  --> $DIR/raw-ptr-const.rs:7:1\n+   |\n+LL | const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}