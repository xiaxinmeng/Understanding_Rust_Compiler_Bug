{"sha": "96787c45acb623c7e39e041f44a5d98d814217e2", "node_id": "C_kwDOAAsO6NoAKDk2Nzg3YzQ1YWNiNjIzYzdlMzllMDQxZjQ0YTVkOThkODE0MjE3ZTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-03T00:20:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-03T00:20:08Z"}, "message": "Auto merge of #103903 - matthiaskrgr:rollup-r5xcvrp, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #99801 (fix(generic_const_exprs): Fix predicate inheritance for children of opaque types)\n - #103610 (Allow use of `-Clto=thin` with `-Ccodegen-units=1` in general)\n - #103870 (Fix `inferred_kind` ICE)\n - #103875 (Simplify astconv item def id handling)\n - #103886 (rustdoc: Fix merge of attributes for reexports of local items)\n - #103890 (rustdoc: remove unused mobile CSS `.rustdoc { padding-top: 0 }`)\n\nFailed merges:\n\n - #103884 (Add visit_fn_ret_ty to hir intravisit)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "979712ec26210152f4deb92852134f88b26fcc37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/979712ec26210152f4deb92852134f88b26fcc37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96787c45acb623c7e39e041f44a5d98d814217e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96787c45acb623c7e39e041f44a5d98d814217e2", "html_url": "https://github.com/rust-lang/rust/commit/96787c45acb623c7e39e041f44a5d98d814217e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96787c45acb623c7e39e041f44a5d98d814217e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b1304a03bbefe618cf16d6f4b3c41f4bd8e390a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1304a03bbefe618cf16d6f4b3c41f4bd8e390a", "html_url": "https://github.com/rust-lang/rust/commit/5b1304a03bbefe618cf16d6f4b3c41f4bd8e390a"}, {"sha": "36d813498c50b9014463f5b7162066113fdb57f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/36d813498c50b9014463f5b7162066113fdb57f1", "html_url": "https://github.com/rust-lang/rust/commit/36d813498c50b9014463f5b7162066113fdb57f1"}], "stats": {"total": 263, "additions": 213, "deletions": 50}, "files": [{"sha": "e6465d641f1e64552af60f0775a5bbf4564b0666", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -177,11 +177,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .all_traits()\n             .filter(|trait_def_id| {\n                 let viz = self.tcx().visibility(*trait_def_id);\n-                if let Some(def_id) = self.item_def_id() {\n-                    viz.is_accessible_from(def_id, self.tcx())\n-                } else {\n-                    viz.is_visible_locally()\n-                }\n+                let def_id = self.item_def_id();\n+                viz.is_accessible_from(def_id, self.tcx())\n             })\n             .collect();\n "}, {"sha": "9dd9bf05540fbfe6d8c4c716a4fd0bb2def7141c", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -54,7 +54,7 @@ pub struct PathSeg(pub DefId, pub usize);\n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn item_def_id(&self) -> Option<DefId>;\n+    fn item_def_id(&self) -> DefId;\n \n     /// Returns predicates in scope of the form `X: Foo<T>`, where `X`\n     /// is a type parameter `X` with the given id `def_id` and T\n@@ -500,6 +500,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                     GenericParamDefKind::Const { has_default } => {\n                         let ty = tcx.at(self.span).type_of(param.def_id);\n+                        if ty.references_error() {\n+                            return tcx.const_error(ty).into();\n+                        }\n                         if !infer_args && has_default {\n                             tcx.bound_const_param_default(param.def_id)\n                                 .subst(tcx, substs.unwrap())\n@@ -2079,17 +2082,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             debug!(\"qpath_to_ty: self.item_def_id()={:?}\", def_id);\n \n-            let parent_def_id = def_id\n-                .and_then(|def_id| {\n-                    def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n-                })\n+            let parent_def_id = def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n                 .map(|hir_id| tcx.hir().get_parent_item(hir_id).to_def_id());\n \n             debug!(\"qpath_to_ty: parent_def_id={:?}\", parent_def_id);\n \n             // If the trait in segment is the same as the trait defining the item,\n             // use the `<Self as ..>` syntax in the error.\n-            let is_part_of_self_trait_constraints = def_id == Some(trait_def_id);\n+            let is_part_of_self_trait_constraints = def_id == trait_def_id;\n             let is_part_of_fn_in_self_trait = parent_def_id == Some(trait_def_id);\n \n             let type_name = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {"}, {"sha": "25faacadf3d0c18a8ca572277481c4106561dd40", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -379,8 +379,8 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         self.tcx\n     }\n \n-    fn item_def_id(&self) -> Option<DefId> {\n-        Some(self.item_def_id)\n+    fn item_def_id(&self) -> DefId {\n+        self.item_def_id\n     }\n \n     fn get_type_parameter_bounds("}, {"sha": "5d1ca1cbd2389046881a349839011366507c796d", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -427,6 +427,8 @@ pub(super) fn explicit_predicates_of<'tcx>(\n     } else {\n         if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+            let parent_def_id = tcx.hir().get_parent_item(hir_id);\n+\n             if tcx.hir().opt_const_param_default_param_hir_id(hir_id).is_some() {\n                 // In `generics_of` we set the generics' parent to be our parent's parent which means that\n                 // we lose out on the predicates of our actual parent if we dont return those predicates here.\n@@ -439,8 +441,33 @@ pub(super) fn explicit_predicates_of<'tcx>(\n                 //        parent of generics returned by `generics_of`\n                 //\n                 // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n-                let item_def_id = tcx.hir().get_parent_item(hir_id);\n-                // In the above code example we would be calling `explicit_predicates_of(Foo)` here\n+                // and we would be calling `explicit_predicates_of(Foo)` here\n+                return tcx.explicit_predicates_of(parent_def_id);\n+            }\n+\n+            let parent_def_kind = tcx.def_kind(parent_def_id);\n+            if matches!(parent_def_kind, DefKind::OpaqueTy) {\n+                // In `instantiate_identity` we inherit the predicates of our parent.\n+                // However, opaque types do not have a parent (see `gather_explicit_predicates_of`), which means\n+                // that we lose out on the predicates of our actual parent if we dont return those predicates here.\n+                //\n+                //\n+                // fn foo<T: Trait>() -> impl Iterator<Output = Another<{ <T as Trait>::ASSOC }> > { todo!() }\n+                //                                                        ^^^^^^^^^^^^^^^^^^^ the def id we are calling\n+                //                                                                            explicit_predicates_of on\n+                //\n+                // In the above code we want the anon const to have predicates in its param env for `T: Trait`.\n+                // However, the anon const cannot inherit predicates from its parent since it's opaque.\n+                //\n+                // To fix this, we call `explicit_predicates_of` directly on `foo`, the parent's parent.\n+\n+                // In the above example this is `foo::{opaque#0}` or `impl Iterator`\n+                let parent_hir_id = tcx.hir().local_def_id_to_hir_id(parent_def_id.def_id);\n+\n+                // In the above example this is the function `foo`\n+                let item_def_id = tcx.hir().get_parent_item(parent_hir_id);\n+\n+                // In the above code example we would be calling `explicit_predicates_of(foo)` here\n                 return tcx.explicit_predicates_of(item_def_id);\n             }\n         }"}, {"sha": "c36c01e1b46d07b5905cd8ebe2124729431406c3", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -194,8 +194,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn item_def_id(&self) -> Option<DefId> {\n-        None\n+    fn item_def_id(&self) -> DefId {\n+        self.body_id.owner.to_def_id()\n     }\n \n     fn get_type_parameter_bounds("}, {"sha": "b8ad18c64dcf649de2618da657952fd8ccaee491", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -738,7 +738,7 @@ impl Default for Options {\n             actually_rustdoc: false,\n             trimmed_def_paths: TrimmedDefPaths::default(),\n             cli_forced_codegen_units: None,\n-            cli_forced_thinlto_off: false,\n+            cli_forced_local_thinlto_off: false,\n             remap_path_prefix: Vec::new(),\n             real_rust_source_base_dir: None,\n             edition: DEFAULT_EDITION,\n@@ -1721,7 +1721,7 @@ fn should_override_cgus_and_disable_thinlto(\n     error_format: ErrorOutputType,\n     mut codegen_units: Option<usize>,\n ) -> (bool, Option<usize>) {\n-    let mut disable_thinlto = false;\n+    let mut disable_local_thinlto = false;\n     // Issue #30063: if user requests LLVM-related output to one\n     // particular path, disable codegen-units.\n     let incompatible: Vec<_> = output_types\n@@ -1746,12 +1746,12 @@ fn should_override_cgus_and_disable_thinlto(\n                     }\n                     early_warn(error_format, \"resetting to default -C codegen-units=1\");\n                     codegen_units = Some(1);\n-                    disable_thinlto = true;\n+                    disable_local_thinlto = true;\n                 }\n             }\n             _ => {\n                 codegen_units = Some(1);\n-                disable_thinlto = true;\n+                disable_local_thinlto = true;\n             }\n         }\n     }\n@@ -1760,7 +1760,7 @@ fn should_override_cgus_and_disable_thinlto(\n         early_error(error_format, \"value for codegen units must be a positive non-zero integer\");\n     }\n \n-    (disable_thinlto, codegen_units)\n+    (disable_local_thinlto, codegen_units)\n }\n \n fn check_thread_count(unstable_opts: &UnstableOptions, error_format: ErrorOutputType) {\n@@ -2265,7 +2265,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let output_types = parse_output_types(&unstable_opts, matches, error_format);\n \n     let mut cg = CodegenOptions::build(matches, error_format);\n-    let (disable_thinlto, mut codegen_units) = should_override_cgus_and_disable_thinlto(\n+    let (disable_local_thinlto, mut codegen_units) = should_override_cgus_and_disable_thinlto(\n         &output_types,\n         matches,\n         error_format,\n@@ -2508,7 +2508,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         actually_rustdoc: false,\n         trimmed_def_paths: TrimmedDefPaths::default(),\n         cli_forced_codegen_units: codegen_units,\n-        cli_forced_thinlto_off: disable_thinlto,\n+        cli_forced_local_thinlto_off: disable_local_thinlto,\n         remap_path_prefix,\n         real_rust_source_base_dir,\n         edition,"}, {"sha": "f9ee202466f67964ced1c4cafab319f51ab44733", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -181,7 +181,7 @@ top_level_options!(\n         #[rustc_lint_opt_deny_field_access(\"use `Session::codegen_units` instead of this field\")]\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n         #[rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\")]\n-        cli_forced_thinlto_off: bool [UNTRACKED],\n+        cli_forced_local_thinlto_off: bool [UNTRACKED],\n \n         /// Remap source path prefixes in all output (messages, object files, debug, etc.).\n         remap_path_prefix: Vec<(PathBuf, PathBuf)> [TRACKED_NO_CRATE_HASH],"}, {"sha": "ec0a5b9d0d84ffa6e4865cdcf12957c384d18fbc", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -1018,11 +1018,8 @@ impl Session {\n                 return config::Lto::Fat;\n             }\n             config::LtoCli::Thin => {\n-                return if self.opts.cli_forced_thinlto_off {\n-                    config::Lto::Fat\n-                } else {\n-                    config::Lto::Thin\n-                };\n+                // The user explicitly asked for ThinLTO\n+                return config::Lto::Thin;\n             }\n         }\n \n@@ -1034,7 +1031,7 @@ impl Session {\n \n         // If processing command line options determined that we're incompatible\n         // with ThinLTO (e.g., `-C lto --emit llvm-ir`) then return that option.\n-        if self.opts.cli_forced_thinlto_off {\n+        if self.opts.cli_forced_local_thinlto_off {\n             return config::Lto::No;\n         }\n "}, {"sha": "ad4ad4104e104e9d48562e13d4fe6b9bae150843", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -74,20 +74,20 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n     // This covers the case where somebody does an import which should pull in an item,\n     // but there's already an item with the same namespace and same name. Rust gives\n     // priority to the not-imported one, so we should, too.\n-    items.extend(doc.items.iter().flat_map(|(item, renamed)| {\n+    items.extend(doc.items.iter().flat_map(|(item, renamed, import_id)| {\n         // First, lower everything other than imports.\n         if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n             return Vec::new();\n         }\n-        let v = clean_maybe_renamed_item(cx, item, *renamed);\n+        let v = clean_maybe_renamed_item(cx, item, *renamed, *import_id);\n         for item in &v {\n             if let Some(name) = item.name && !item.attrs.lists(sym::doc).has_word(sym::hidden) {\n                 inserted.insert((item.type_(), name));\n             }\n         }\n         v\n     }));\n-    items.extend(doc.items.iter().flat_map(|(item, renamed)| {\n+    items.extend(doc.items.iter().flat_map(|(item, renamed, _)| {\n         // Now we actually lower the imports, skipping everything else.\n         if let hir::ItemKind::Use(path, hir::UseKind::Glob) = item.kind {\n             let name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n@@ -1911,6 +1911,7 @@ fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n     renamed: Option<Symbol>,\n+    import_id: Option<hir::HirId>,\n ) -> Vec<Item> {\n     use hir::ItemKind;\n \n@@ -1987,8 +1988,23 @@ fn clean_maybe_renamed_item<'tcx>(\n             }\n             _ => unreachable!(\"not yet converted\"),\n         };\n-\n-        vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+        if let Some(import_id) = import_id {\n+            let (attrs, cfg) = inline::merge_attrs(\n+                cx,\n+                Some(cx.tcx.parent_module(import_id).to_def_id()),\n+                inline::load_attrs(cx, def_id),\n+                Some(inline::load_attrs(cx, cx.tcx.hir().local_def_id(import_id).to_def_id())),\n+            );\n+            vec![Item::from_def_id_and_attrs_and_parts(\n+                def_id,\n+                Some(name),\n+                kind,\n+                Box::new(attrs),\n+                cfg,\n+            )]\n+        } else {\n+            vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+        }\n     })\n }\n "}, {"sha": "d6f2b02afd8f8f0ac2129bef9d699c2810bf82d2", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -1677,7 +1677,6 @@ in storage.js\n \t}\n \n \t.rustdoc {\n-\t\tpadding-top: 0px;\n \t\t/* Sidebar should overlay main content, rather than pushing main content to the right.\n \t\t   Turn off `display: flex` on the body element. */\n \t\tdisplay: block;"}, {"sha": "c788b9f4093fea7721b838118443e16a71708ee1", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -25,8 +25,8 @@ pub(crate) struct Module<'hir> {\n     pub(crate) where_inner: Span,\n     pub(crate) mods: Vec<Module<'hir>>,\n     pub(crate) id: hir::HirId,\n-    // (item, renamed)\n-    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>)>,\n+    // (item, renamed, import_id)\n+    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>, Option<hir::HirId>)>,\n     pub(crate) foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n }\n \n@@ -93,6 +93,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::CRATE_HIR_ID,\n             self.cx.tcx.hir().root_module(),\n             self.cx.tcx.crate_name(LOCAL_CRATE),\n+            None,\n         );\n \n         // `#[macro_export] macro_rules!` items are reexported at the top level of the\n@@ -113,7 +114,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n                         if inserted.insert(def_id) {\n                             let item = self.cx.tcx.hir().expect_item(local_def_id);\n-                            top_level_module.items.push((item, None));\n+                            top_level_module.items.push((item, None, None));\n                         }\n                     }\n                 }\n@@ -155,6 +156,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         id: hir::HirId,\n         m: &'tcx hir::Mod<'tcx>,\n         name: Symbol,\n+        parent_id: Option<hir::HirId>,\n     ) -> Module<'tcx> {\n         let mut om = Module::new(name, id, m.spans.inner_span);\n         let def_id = self.cx.tcx.hir().local_def_id(id).to_def_id();\n@@ -166,15 +168,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n                 continue;\n             }\n-            self.visit_item(item, None, &mut om);\n+            self.visit_item(item, None, &mut om, parent_id);\n         }\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n             // To match the way import precedence works, visit glob imports last.\n             // Later passes in rustdoc will de-duplicate by name and kind, so if glob-\n             // imported items appear last, then they'll be the ones that get discarded.\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                self.visit_item(item, None, &mut om);\n+                self.visit_item(item, None, &mut om, parent_id);\n             }\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -247,14 +249,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n                     let i = self.cx.tcx.hir().item(i);\n-                    self.visit_item(i, None, om);\n+                    self.visit_item(i, None, om, Some(id));\n                 }\n                 self.inlining = prev;\n                 true\n             }\n             Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_item(it, renamed, om);\n+                self.visit_item(it, renamed, om, Some(id));\n                 self.inlining = prev;\n                 true\n             }\n@@ -275,6 +277,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         item: &'tcx hir::Item<'_>,\n         renamed: Option<Symbol>,\n         om: &mut Module<'tcx>,\n+        parent_id: Option<hir::HirId>,\n     ) {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n@@ -330,7 +333,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n                 }\n \n-                om.items.push((item, renamed))\n+                om.items.push((item, renamed, parent_id))\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 // `#[macro_export] macro_rules!` items are handled separately in `visit()`,\n@@ -349,11 +352,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n \n                 if is_macro_2_0 || nonexported || self.inlining {\n-                    om.items.push((item, renamed));\n+                    om.items.push((item, renamed, None));\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(item.hir_id(), m, name));\n+                om.mods.push(self.visit_mod_contents(item.hir_id(), m, name, parent_id));\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -364,19 +367,19 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed)),\n+            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed, parent_id)),\n             hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if name != kw::Underscore {\n-                    om.items.push((item, renamed));\n+                    om.items.push((item, renamed, parent_id));\n                 }\n             }\n             hir::ItemKind::Impl(impl_) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && impl_.of_trait.is_none() {\n-                    om.items.push((item, None));\n+                    om.items.push((item, None, None));\n                 }\n             }\n         }"}, {"sha": "1c8468008dd0afd0eb64d80e32174a1c16c1a93c", "filename": "src/test/rustdoc/local-reexport-doc.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Ftest%2Frustdoc%2Flocal-reexport-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Ftest%2Frustdoc%2Flocal-reexport-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Flocal-reexport-doc.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -0,0 +1,16 @@\n+// This test ensures that the reexports of local items also get the doc from\n+// the reexport.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/fn.g.html'\n+// @has - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]' \\\n+// 'outer module inner module'\n+\n+mod inner_mod {\n+    /// inner module\n+    pub fn g() {}\n+}\n+\n+/// outer module\n+pub use inner_mod::g;"}, {"sha": "75b57b621bb574160965e9d76f935458f8bd8d6e", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-99705.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-99705.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-99705.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-99705.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+#![crate_type = \"lib\"]\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+pub trait MyIterator {\n+    type Output;\n+}\n+\n+pub trait Foo {\n+    const ABC: usize;\n+}\n+\n+pub struct IteratorStruct<const N: usize>{\n+\n+}\n+\n+pub struct Bar<const N: usize> {\n+    pub data: [usize; N]\n+}\n+\n+impl<const N: usize> MyIterator for IteratorStruct<N> {\n+    type Output = Bar<N>;\n+}\n+\n+pub fn test1<T: Foo>() -> impl MyIterator<Output = Bar<{T::ABC}>> where [(); T::ABC]: Sized {\n+    IteratorStruct::<{T::ABC}>{}\n+}\n+\n+pub trait Baz<const N: usize>{}\n+impl<const N: usize> Baz<N> for Bar<N> {}\n+pub fn test2<T: Foo>() -> impl MyIterator<Output = impl Baz<{ T::ABC }>> where [(); T::ABC]: Sized {\n+    IteratorStruct::<{T::ABC}>{}\n+}"}, {"sha": "ea3cac605b156a403543b8d76657f226fe072df9", "filename": "src/test/ui/consts/issue-103790.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Ftest%2Fui%2Fconsts%2Fissue-103790.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Ftest%2Fui%2Fconsts%2Fissue-103790.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-103790.rs?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -0,0 +1,10 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+struct S<const S: (), const S: S = { S }>;\n+//~^ ERROR the name `S` is already used for a generic parameter in this item's generic parameters\n+//~| ERROR missing generics for struct `S`\n+//~| ERROR cycle detected when computing type of `S::S`\n+//~| ERROR cycle detected when computing type of `S`\n+\n+fn main() {}"}, {"sha": "41b0816dc32af8dd4b7fc8a6d52d443b0ed0a200", "filename": "src/test/ui/consts/issue-103790.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Ftest%2Fui%2Fconsts%2Fissue-103790.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96787c45acb623c7e39e041f44a5d98d814217e2/src%2Ftest%2Fui%2Fconsts%2Fissue-103790.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-103790.stderr?ref=96787c45acb623c7e39e041f44a5d98d814217e2", "patch": "@@ -0,0 +1,65 @@\n+error[E0403]: the name `S` is already used for a generic parameter in this item's generic parameters\n+  --> $DIR/issue-103790.rs:4:29\n+   |\n+LL | struct S<const S: (), const S: S = { S }>;\n+   |                -            ^ already used\n+   |                |\n+   |                first use of `S`\n+\n+error[E0107]: missing generics for struct `S`\n+  --> $DIR/issue-103790.rs:4:32\n+   |\n+LL | struct S<const S: (), const S: S = { S }>;\n+   |                                ^ expected at least 1 generic argument\n+   |\n+note: struct defined here, with at least 1 generic parameter: `S`\n+  --> $DIR/issue-103790.rs:4:8\n+   |\n+LL | struct S<const S: (), const S: S = { S }>;\n+   |        ^ -----------\n+help: add missing generic argument\n+   |\n+LL | struct S<const S: (), const S: S<S> = { S }>;\n+   |                                ~~~~\n+\n+error[E0391]: cycle detected when computing type of `S::S`\n+  --> $DIR/issue-103790.rs:4:32\n+   |\n+LL | struct S<const S: (), const S: S = { S }>;\n+   |                                ^\n+   |\n+   = note: ...which immediately requires computing type of `S::S` again\n+note: cycle used when computing type of `S`\n+  --> $DIR/issue-103790.rs:4:1\n+   |\n+LL | struct S<const S: (), const S: S = { S }>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0391]: cycle detected when computing type of `S`\n+  --> $DIR/issue-103790.rs:4:1\n+   |\n+LL | struct S<const S: (), const S: S = { S }>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing type of `S::S`...\n+  --> $DIR/issue-103790.rs:4:32\n+   |\n+LL | struct S<const S: (), const S: S = { S }>;\n+   |                                ^\n+   = note: ...which again requires computing type of `S`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/issue-103790.rs:1:1\n+   |\n+LL | / #![feature(generic_const_exprs)]\n+LL | | #![allow(incomplete_features)]\n+LL | |\n+LL | | struct S<const S: (), const S: S = { S }>;\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0107, E0391, E0403.\n+For more information about an error, try `rustc --explain E0107`."}]}