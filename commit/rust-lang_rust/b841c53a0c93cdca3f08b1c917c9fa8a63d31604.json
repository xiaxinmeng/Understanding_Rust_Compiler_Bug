{"sha": "b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NDFjNTNhMGM5M2NkY2EzZjA4YjFjOTE3YzlmYThhNjNkMzE2MDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-22T14:43:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-22T14:43:32Z"}, "message": "Merge #2356\n\n2356: Move FunctionData to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "2b1d06598328b9d1922e83c791f181b5789eb789", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b1d06598328b9d1922e83c791f181b5789eb789"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd1/QUCRBK7hj4Ov3rIwAAdHIIAF4ej90vFFdlGsvQZeX9goP+\nDXTaoWgXg2I5y23WXjH23gsu6HU3Bmcd8TJR39Kux040uHw9EwaSyj9sJ22a+NYl\ncOwZRERgt/sNCAnbYOVvw24fVH/5/dTMudkxea5xTkWV2Dfyw21yam23gBljOWpN\nSUI6619qvferC73gzdcybcB8FbV4mevXCNNR6HBWOqucUWhZxzeyCCHgnBH0tZ7p\n5UjuuldJFc6yj3epeg8fc99SsQwuCcSU0x4TnZalPBcOcXYwreM5vlJQEt0MUbaR\nCIy1IPrCx1eR7uh7wyfwBDkgWweAh37o2stIx63M1cwPAy09sUHUwCqGyT5bgzM=\n=ipDc\n-----END PGP SIGNATURE-----\n", "payload": "tree 2b1d06598328b9d1922e83c791f181b5789eb789\nparent a132cc715ed05cab83fd058156eb152f0be96982\nparent 64df759418a83fd05fab850b8351fcddbdd3ef63\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574433812 +0000\ncommitter GitHub <noreply@github.com> 1574433812 +0000\n\nMerge #2356\n\n2356: Move FunctionData to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "html_url": "https://github.com/rust-lang/rust/commit/b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a132cc715ed05cab83fd058156eb152f0be96982", "url": "https://api.github.com/repos/rust-lang/rust/commits/a132cc715ed05cab83fd058156eb152f0be96982", "html_url": "https://github.com/rust-lang/rust/commit/a132cc715ed05cab83fd058156eb152f0be96982"}, {"sha": "64df759418a83fd05fab850b8351fcddbdd3ef63", "url": "https://api.github.com/repos/rust-lang/rust/commits/64df759418a83fd05fab850b8351fcddbdd3ef63", "html_url": "https://github.com/rust-lang/rust/commit/64df759418a83fd05fab850b8351fcddbdd3ef63"}], "stats": {"total": 561, "additions": 252, "deletions": 309}, "files": [{"sha": "3daf7488ed413011b7f187c9da55631a873305f5", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 11, "deletions": 78, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -10,10 +10,10 @@ use hir_def::{\n     adt::VariantData,\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n+    data::TraitData,\n     nameres::per_ns::PerNs,\n     resolver::{HasResolver, TypeNs},\n-    traits::TraitData,\n-    type_ref::{Mutability, TypeRef},\n+    type_ref::TypeRef,\n     ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId, LocalStructFieldId, Lookup,\n     ModuleId, UnionId,\n };\n@@ -561,77 +561,6 @@ pub struct Function {\n     pub(crate) id: FunctionId,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct FnData {\n-    pub(crate) name: Name,\n-    pub(crate) params: Vec<TypeRef>,\n-    pub(crate) ret_type: TypeRef,\n-    /// True if the first param is `self`. This is relevant to decide whether this\n-    /// can be called as a method.\n-    pub(crate) has_self_param: bool,\n-}\n-\n-impl FnData {\n-    pub(crate) fn fn_data_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        func: Function,\n-    ) -> Arc<FnData> {\n-        let src = func.source(db);\n-        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n-        let mut params = Vec::new();\n-        let mut has_self_param = false;\n-        if let Some(param_list) = src.value.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(type_ref)\n-                } else {\n-                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n-                    match self_param.kind() {\n-                        ast::SelfParamKind::Owned => self_type,\n-                        ast::SelfParamKind::Ref => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n-                        }\n-                        ast::SelfParamKind::MutRef => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n-                        }\n-                    }\n-                };\n-                params.push(self_type);\n-                has_self_param = true;\n-            }\n-            for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n-                params.push(type_ref);\n-            }\n-        }\n-        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n-            TypeRef::from_ast(type_ref)\n-        } else {\n-            TypeRef::unit()\n-        };\n-\n-        let sig = FnData { name, params, ret_type, has_self_param };\n-        Arc::new(sig)\n-    }\n-    pub fn name(&self) -> &Name {\n-        &self.name\n-    }\n-\n-    pub fn params(&self) -> &[TypeRef] {\n-        &self.params\n-    }\n-\n-    pub fn ret_type(&self) -> &TypeRef {\n-        &self.ret_type\n-    }\n-\n-    /// True if the first arg is `self`. This is relevant to decide whether this\n-    /// can be called as a method.\n-    pub fn has_self_param(&self) -> bool {\n-        self.has_self_param\n-    }\n-}\n-\n impl Function {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.lookup(db).module(db).into()\n@@ -642,7 +571,15 @@ impl Function {\n     }\n \n     pub fn name(self, db: &impl HirDatabase) -> Name {\n-        self.data(db).name.clone()\n+        db.function_data(self.id).name.clone()\n+    }\n+\n+    pub fn has_self_param(self, db: &impl HirDatabase) -> bool {\n+        db.function_data(self.id).has_self_param\n+    }\n+\n+    pub fn params(self, db: &impl HirDatabase) -> Vec<TypeRef> {\n+        db.function_data(self.id).params.clone()\n     }\n \n     pub(crate) fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n@@ -657,10 +594,6 @@ impl Function {\n         db.type_for_def(self.into(), Namespace::Values)\n     }\n \n-    pub fn data(self, db: &impl HirDatabase) -> Arc<FnData> {\n-        db.fn_data(self)\n-    }\n-\n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.into())\n     }"}, {"sha": "8b9af0565232d353bdcbc54b0427c0bbe07629e6", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -16,15 +16,15 @@ use crate::{\n         CallableDef, FnSig, GenericPredicate, InferenceResult, Namespace, Substs, Ty, TypableDef,\n         TypeCtor,\n     },\n-    Const, ConstData, Crate, DefWithBody, FnData, Function, GenericDef, ImplBlock, Module, Static,\n-    StructField, Trait,\n+    Const, ConstData, Crate, DefWithBody, GenericDef, ImplBlock, Module, Static, StructField,\n+    Trait,\n };\n \n pub use hir_def::db::{\n     BodyQuery, BodyWithSourceMapQuery, CrateDefMapQuery, DefDatabase2, DefDatabase2Storage,\n-    EnumDataQuery, ExprScopesQuery, GenericParamsQuery, ImplDataQuery, InternDatabase,\n-    InternDatabaseStorage, RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n-    TraitDataQuery, TypeAliasDataQuery,\n+    EnumDataQuery, ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery,\n+    InternDatabase, InternDatabaseStorage, RawItemsQuery, RawItemsWithSourceMapQuery,\n+    StructDataQuery, TraitDataQuery, TypeAliasDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -35,9 +35,6 @@ pub use hir_expand::db::{\n #[salsa::query_group(DefDatabaseStorage)]\n #[salsa::requires(AstDatabase)]\n pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n-    #[salsa::invoke(FnData::fn_data_query)]\n-    fn fn_data(&self, func: Function) -> Arc<FnData>;\n-\n     #[salsa::invoke(ConstData::const_data_query)]\n     fn const_data(&self, konst: Const) -> Arc<ConstData>;\n "}, {"sha": "334eeebacd9a9f2428bbb4e670e2d8ae1f3473de", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -18,11 +18,11 @@ impl HasSource for ImplBlock {\n \n impl ImplBlock {\n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n-        db.impl_data(self.id).target_trait().cloned()\n+        db.impl_data(self.id).target_trait.clone()\n     }\n \n     pub fn target_type(&self, db: &impl DefDatabase) -> TypeRef {\n-        db.impl_data(self.id).target_type().clone()\n+        db.impl_data(self.id).target_type.clone()\n     }\n \n     pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n@@ -35,11 +35,11 @@ impl ImplBlock {\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        db.impl_data(self.id).items().iter().map(|it| (*it).into()).collect()\n+        db.impl_data(self.id).items.iter().map(|it| (*it).into()).collect()\n     }\n \n     pub fn is_negative(&self, db: &impl DefDatabase) -> bool {\n-        db.impl_data(self.id).is_negative()\n+        db.impl_data(self.id).is_negative\n     }\n \n     pub fn module(&self, db: &impl DefDatabase) -> Module {"}, {"sha": "d29cc92580656f18c98ae8eea80c34dfd9209968", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -55,9 +55,9 @@ pub use crate::{\n         docs::{DocDef, Docs, Documentation},\n         src::{HasBodySource, HasSource},\n         Adt, AssocItem, Const, ConstData, Container, Crate, CrateDependency, DefWithBody, Enum,\n-        EnumVariant, FieldSource, FnData, Function, GenericDef, GenericParam, HasBody, ImplBlock,\n-        Local, MacroDef, Module, ModuleDef, ModuleSource, ScopeDef, Static, Struct, StructField,\n-        Trait, TypeAlias, Union, VariantDef,\n+        EnumVariant, FieldSource, Function, GenericDef, GenericParam, HasBody, ImplBlock, Local,\n+        MacroDef, Module, ModuleDef, ModuleSource, ScopeDef, Static, Struct, StructField, Trait,\n+        TypeAlias, Union, VariantDef,\n     },\n     expr::ExprScopes,\n     from_source::FromSource,"}, {"sha": "6e07ab86e89c868eb60e92b2782762890bf27a4c", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -22,6 +22,7 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n use hir_def::{\n+    data::FunctionData,\n     path::known,\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n@@ -43,8 +44,8 @@ use crate::{\n     db::HirDatabase,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, ConstData, DefWithBody, FloatTy, FnData, Function, HasBody, IntTy, Path,\n-    StructField, Trait, VariantDef,\n+    Adt, AssocItem, ConstData, DefWithBody, FloatTy, Function, HasBody, IntTy, Path, StructField,\n+    Trait, VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -70,7 +71,7 @@ pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResu\n \n     match def {\n         DefWithBody::Const(ref c) => ctx.collect_const(&c.data(db)),\n-        DefWithBody::Function(ref f) => ctx.collect_fn(&f.data(db)),\n+        DefWithBody::Function(ref f) => ctx.collect_fn(&db.function_data(f.id)),\n         DefWithBody::Static(ref s) => ctx.collect_const(&s.data(db)),\n     }\n \n@@ -562,14 +563,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.return_ty = self.make_ty(data.type_ref());\n     }\n \n-    fn collect_fn(&mut self, data: &FnData) {\n+    fn collect_fn(&mut self, data: &FunctionData) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        for (type_ref, pat) in data.params().iter().zip(body.params()) {\n+        for (type_ref, pat) in data.params.iter().zip(body.params()) {\n             let ty = self.make_ty(type_ref);\n \n             self.infer_pat(*pat, &ty, BindingMode::default());\n         }\n-        self.return_ty = self.make_ty(data.ret_type());\n+        self.return_ty = self.make_ty(&data.ret_type);\n     }\n \n     fn infer_body(&mut self) {"}, {"sha": "42daa9cb93989955df7e684511a4bbd308f6f4b9", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -622,10 +622,10 @@ pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) ->\n }\n \n fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n-    let data = def.data(db);\n+    let data = db.function_data(def.id);\n     let resolver = def.id.resolver(db);\n-    let params = data.params().iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n-    let ret = Ty::from_hir(db, &resolver, data.ret_type());\n+    let params = data.params.iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n+    let ret = Ty::from_hir(db, &resolver, &data.ret_type);\n     FnSig::from_params_and_return(params, ret)\n }\n "}, {"sha": "f84aae26eee755f488ea0eae7f52c102a09cee22", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -291,9 +291,9 @@ fn is_valid_candidate(\n ) -> bool {\n     match item {\n         AssocItem::Function(m) => {\n-            let data = m.data(db);\n-            name.map_or(true, |name| data.name() == name)\n-                && (data.has_self_param() || mode == LookupMode::Path)\n+            let data = db.function_data(m.id);\n+            name.map_or(true, |name| data.name == *name)\n+                && (data.has_self_param || mode == LookupMode::Path)\n         }\n         AssocItem::Const(c) => {\n             name.map_or(true, |name| Some(name) == c.name(db).as_ref())"}, {"sha": "ba47629db33bd2151144c7995be6578e9ccc36a9", "filename": "crates/ra_hir_def/src/data.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -0,0 +1,192 @@\n+//! Contains basic data about various HIR declarations.\n+\n+use std::sync::Arc;\n+\n+use hir_expand::{\n+    name::{self, AsName, Name},\n+    AstId,\n+};\n+use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n+\n+use crate::{\n+    db::DefDatabase2,\n+    type_ref::{Mutability, TypeRef},\n+    AssocItemId, AstItemDef, ConstLoc, ContainerId, FunctionId, FunctionLoc, HasSource, ImplId,\n+    Intern, Lookup, TraitId, TypeAliasId, TypeAliasLoc,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct FunctionData {\n+    pub name: Name,\n+    pub params: Vec<TypeRef>,\n+    pub ret_type: TypeRef,\n+    /// True if the first param is `self`. This is relevant to decide whether this\n+    /// can be called as a method.\n+    pub has_self_param: bool,\n+}\n+\n+impl FunctionData {\n+    pub(crate) fn fn_data_query(db: &impl DefDatabase2, func: FunctionId) -> Arc<FunctionData> {\n+        let src = func.lookup(db).source(db);\n+        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n+        let mut params = Vec::new();\n+        let mut has_self_param = false;\n+        if let Some(param_list) = src.value.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n+                    TypeRef::from_ast(type_ref)\n+                } else {\n+                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n+                    match self_param.kind() {\n+                        ast::SelfParamKind::Owned => self_type,\n+                        ast::SelfParamKind::Ref => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n+                        }\n+                        ast::SelfParamKind::MutRef => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n+                        }\n+                    }\n+                };\n+                params.push(self_type);\n+                has_self_param = true;\n+            }\n+            for param in param_list.params() {\n+                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+                params.push(type_ref);\n+            }\n+        }\n+        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n+            TypeRef::from_ast(type_ref)\n+        } else {\n+            TypeRef::unit()\n+        };\n+\n+        let sig = FunctionData { name, params, ret_type, has_self_param };\n+        Arc::new(sig)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TypeAliasData {\n+    pub name: Name,\n+    pub type_ref: Option<TypeRef>,\n+}\n+\n+impl TypeAliasData {\n+    pub(crate) fn type_alias_data_query(\n+        db: &impl DefDatabase2,\n+        typ: TypeAliasId,\n+    ) -> Arc<TypeAliasData> {\n+        let node = typ.lookup(db).source(db).value;\n+        let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n+        let type_ref = node.type_ref().map(TypeRef::from_ast);\n+        Arc::new(TypeAliasData { name, type_ref })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    pub name: Option<Name>,\n+    pub items: Vec<AssocItemId>,\n+    pub auto: bool,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &impl DefDatabase2, tr: TraitId) -> Arc<TraitData> {\n+        let src = tr.source(db);\n+        let name = src.value.name().map(|n| n.as_name());\n+        let auto = src.value.is_auto();\n+        let ast_id_map = db.ast_id_map(src.file_id);\n+        let items = if let Some(item_list) = src.value.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => FunctionLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                    ast::ImplItem::ConstDef(it) => ConstLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TraitData { name, items, auto })\n+    }\n+\n+    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n+        self.items.iter().filter_map(|item| match item {\n+            AssocItemId::TypeAliasId(t) => Some(*t),\n+            _ => None,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImplData {\n+    pub target_trait: Option<TypeRef>,\n+    pub target_type: TypeRef,\n+    pub items: Vec<AssocItemId>,\n+    pub is_negative: bool,\n+}\n+\n+impl ImplData {\n+    pub(crate) fn impl_data_query(db: &impl DefDatabase2, id: ImplId) -> Arc<ImplData> {\n+        let src = id.source(db);\n+        let items = db.ast_id_map(src.file_id);\n+\n+        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n+        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n+        let is_negative = src.value.is_negative();\n+\n+        let items = if let Some(item_list) = src.value.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => {\n+                        let def = FunctionLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                    ast::ImplItem::ConstDef(it) => {\n+                        let def = ConstLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                    ast::ImplItem::TypeAliasDef(it) => {\n+                        let def = TypeAliasLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+\n+        let res = ImplData { target_trait, target_type, items, is_negative };\n+        Arc::new(res)\n+    }\n+}"}, {"sha": "8c1784ec9d5e085a346d6ba097fad25ebe54b1af", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -8,15 +8,14 @@ use ra_syntax::ast;\n use crate::{\n     adt::{EnumData, StructData},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n+    data::{FunctionData, ImplData, TraitData, TypeAliasData},\n     generics::GenericParams,\n-    impls::ImplData,\n     nameres::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    traits::TraitData,\n-    type_alias::TypeAliasData,\n-    DefWithBodyId, EnumId, GenericDefId, ImplId, ItemLoc, StructOrUnionId, TraitId, TypeAliasId,\n+    DefWithBodyId, EnumId, FunctionId, GenericDefId, ImplId, ItemLoc, StructOrUnionId, TraitId,\n+    TypeAliasId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -68,6 +67,9 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n     fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;\n \n+    #[salsa::invoke(FunctionData::fn_data_query)]\n+    fn function_data(&self, func: FunctionId) -> Arc<FunctionData>;\n+\n     #[salsa::invoke(Body::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n "}, {"sha": "750a869f256fa9cc02e5669ec5094d91bb7a716e", "filename": "crates/ra_hir_def/src/impls.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a132cc715ed05cab83fd058156eb152f0be96982/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a132cc715ed05cab83fd058156eb152f0be96982/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs?ref=a132cc715ed05cab83fd058156eb152f0be96982", "patch": "@@ -1,86 +0,0 @@\n-//! Defines hir-level representation of impls.\n-//!\n-//! The handling is similar, but is not quite the same as for other items,\n-//! because `impl`s don't have names.\n-\n-use std::sync::Arc;\n-\n-use hir_expand::AstId;\n-use ra_syntax::ast;\n-\n-use crate::{\n-    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstLoc, ContainerId,\n-    FunctionLoc, ImplId, Intern, TypeAliasLoc,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ImplData {\n-    target_trait: Option<TypeRef>,\n-    target_type: TypeRef,\n-    items: Vec<AssocItemId>,\n-    negative: bool,\n-}\n-\n-impl ImplData {\n-    pub(crate) fn impl_data_query(db: &impl DefDatabase2, id: ImplId) -> Arc<ImplData> {\n-        let src = id.source(db);\n-        let items = db.ast_id_map(src.file_id);\n-\n-        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n-        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n-        let negative = src.value.is_negative();\n-\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => {\n-                        let def = FunctionLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::ConstDef(it) => {\n-                        let def = ConstLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                    ast::ImplItem::TypeAliasDef(it) => {\n-                        let def = TypeAliasLoc {\n-                            container: ContainerId::ImplId(id),\n-                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n-                        }\n-                        .intern(db);\n-                        def.into()\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-\n-        let res = ImplData { target_trait, target_type, items, negative };\n-        Arc::new(res)\n-    }\n-\n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n-        self.target_trait.as_ref()\n-    }\n-\n-    pub fn target_type(&self) -> &TypeRef {\n-        &self.target_type\n-    }\n-\n-    pub fn items(&self) -> &[AssocItemId] {\n-        &self.items\n-    }\n-\n-    pub fn is_negative(&self) -> bool {\n-        self.negative\n-    }\n-}"}, {"sha": "3a0420da0c7757488c03dc2693fe461c169caf2c", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -13,14 +13,12 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n-pub mod impls;\n pub mod diagnostics;\n pub mod expr;\n pub mod body;\n pub mod generics;\n-pub mod traits;\n pub mod resolver;\n-pub mod type_alias;\n+pub mod data;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "6c2d5b2a9f7be9bbdb1aa293ad054dc99bf55977", "filename": "crates/ra_hir_def/src/traits.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a132cc715ed05cab83fd058156eb152f0be96982/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a132cc715ed05cab83fd058156eb152f0be96982/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs?ref=a132cc715ed05cab83fd058156eb152f0be96982", "patch": "@@ -1,66 +0,0 @@\n-//! HIR for trait definitions.\n-\n-use std::sync::Arc;\n-\n-use hir_expand::{\n-    name::{AsName, Name},\n-    AstId,\n-};\n-\n-use ra_syntax::ast::{self, NameOwner};\n-\n-use crate::{\n-    db::DefDatabase2, AssocItemId, AstItemDef, ConstLoc, ContainerId, FunctionLoc, Intern, TraitId,\n-    TypeAliasId, TypeAliasLoc,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TraitData {\n-    pub name: Option<Name>,\n-    pub items: Vec<AssocItemId>,\n-    pub auto: bool,\n-}\n-\n-impl TraitData {\n-    pub(crate) fn trait_data_query(db: &impl DefDatabase2, tr: TraitId) -> Arc<TraitData> {\n-        let src = tr.source(db);\n-        let name = src.value.name().map(|n| n.as_name());\n-        let auto = src.value.is_auto();\n-        let ast_id_map = db.ast_id_map(src.file_id);\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => FunctionLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::ConstDef(it) => ConstLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                    }\n-                    .intern(db)\n-                    .into(),\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-        Arc::new(TraitData { name, items, auto })\n-    }\n-\n-    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n-        self.items.iter().filter_map(|item| match item {\n-            AssocItemId::TypeAliasId(t) => Some(*t),\n-            _ => None,\n-        })\n-    }\n-}"}, {"sha": "c0b49aa7cc7e69ade47e86ae334ff53db87ade35", "filename": "crates/ra_hir_def/src/type_alias.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a132cc715ed05cab83fd058156eb152f0be96982/crates%2Fra_hir_def%2Fsrc%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a132cc715ed05cab83fd058156eb152f0be96982/crates%2Fra_hir_def%2Fsrc%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_alias.rs?ref=a132cc715ed05cab83fd058156eb152f0be96982", "patch": "@@ -1,27 +0,0 @@\n-//! HIR for type aliases (i.e. the `type` keyword).\n-\n-use std::sync::Arc;\n-\n-use hir_expand::name::{AsName, Name};\n-\n-use ra_syntax::ast::NameOwner;\n-\n-use crate::{db::DefDatabase2, type_ref::TypeRef, HasSource, Lookup, TypeAliasId};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TypeAliasData {\n-    pub name: Name,\n-    pub type_ref: Option<TypeRef>,\n-}\n-\n-impl TypeAliasData {\n-    pub(crate) fn type_alias_data_query(\n-        db: &impl DefDatabase2,\n-        typ: TypeAliasId,\n-    ) -> Arc<TypeAliasData> {\n-        let node = typ.lookup(db).source(db).value;\n-        let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n-        let type_ref = node.type_ref().map(TypeRef::from_ast);\n-        Arc::new(TypeAliasData { name, type_ref })\n-    }\n-}"}, {"sha": "7c367230e7192c753e574b8dfa6995ad96c75fc2", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -30,15 +30,15 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n             let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::Function(it) => {\n-                    (CallInfo::with_fn(db, it), it.data(db).has_self_param())\n+                    (CallInfo::with_fn(db, it), it.has_self_param(db))\n                 }\n                 hir::CallableDef::Struct(it) => (CallInfo::with_struct(db, it)?, false),\n                 hir::CallableDef::EnumVariant(it) => (CallInfo::with_enum_variant(db, it)?, false),\n             }\n         }\n         FnCallNode::MethodCallExpr(expr) => {\n             let function = analyzer.resolve_method_call(&expr)?;\n-            (CallInfo::with_fn(db, function), function.data(db).has_self_param())\n+            (CallInfo::with_fn(db, function), function.has_self_param(db))\n         }\n         FnCallNode::MacroCallExpr(expr) => {\n             let macro_def = analyzer.resolve_macro_call(db, &expr)?;"}, {"sha": "8a05b287f7107e15a18710f6b728629c45220ece", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -313,7 +313,7 @@ impl RootDatabase {\n             hir::db::RawItemsQuery\n             hir::db::CrateDefMapQuery\n             hir::db::GenericParamsQuery\n-            hir::db::FnDataQuery\n+            hir::db::FunctionDataQuery\n             hir::db::TypeAliasDataQuery\n             hir::db::ConstDataQuery\n             hir::db::StaticDataQuery"}, {"sha": "5a3f9b5f64a329a2cfb654fe69dd7391a75f1945", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -59,8 +59,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     let mut seen_methods = FxHashSet::default();\n     ctx.analyzer.iterate_method_candidates(ctx.db, receiver, None, |_ty, func| {\n-        let data = func.data(ctx.db);\n-        if data.has_self_param() && seen_methods.insert(data.name().clone()) {\n+        if func.has_self_param(ctx.db) && seen_methods.insert(func.name(ctx.db)) {\n             acc.add_function(ctx, func);\n         }\n         None::<()>"}, {"sha": "802c7701a34870d42efe67de72769a79e0de09cc", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -53,8 +53,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             ctx.analyzer.iterate_path_candidates(ctx.db, ty.clone(), None, |_ty, item| {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n-                        let data = func.data(ctx.db);\n-                        if !data.has_self_param() {\n+                        if !func.has_self_param(ctx.db) {\n                             acc.add_function(ctx, func);\n                         }\n                     }\n@@ -80,8 +79,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             for item in t.items(ctx.db) {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n-                        let data = func.data(ctx.db);\n-                        if !data.has_self_param() {\n+                        if !func.has_self_param(ctx.db) {\n                             acc.add_function(ctx, func);\n                         }\n                     }"}, {"sha": "896ad15173db17d620cd2b9524ffe1497774b549", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841c53a0c93cdca3f08b1c917c9fa8a63d31604/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=b841c53a0c93cdca3f08b1c917c9fa8a63d31604", "patch": "@@ -199,14 +199,17 @@ impl Completions {\n         name: Option<String>,\n         func: hir::Function,\n     ) {\n-        let data = func.data(ctx.db);\n-        let name = name.unwrap_or_else(|| data.name().to_string());\n+        let func_name = func.name(ctx.db);\n+        let has_self_param = func.has_self_param(ctx.db);\n+        let params = func.params(ctx.db);\n+\n+        let name = name.unwrap_or_else(|| func_name.to_string());\n         let ast_node = func.source(ctx.db).value;\n         let detail = function_label(&ast_node);\n \n         let mut builder =\n             CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n-                .kind(if data.has_self_param() {\n+                .kind(if has_self_param {\n                     CompletionItemKind::Method\n                 } else {\n                     CompletionItemKind::Function\n@@ -221,12 +224,11 @@ impl Completions {\n             && ctx.db.feature_flags.get(\"completion.insertion.add-call-parenthesis\")\n         {\n             tested_by!(inserts_parens_for_function_calls);\n-            let (snippet, label) =\n-                if data.params().is_empty() || data.has_self_param() && data.params().len() == 1 {\n-                    (format!(\"{}()$0\", data.name()), format!(\"{}()\", name))\n-                } else {\n-                    (format!(\"{}($0)\", data.name()), format!(\"{}(\u2026)\", name))\n-                };\n+            let (snippet, label) = if params.is_empty() || has_self_param && params.len() == 1 {\n+                (format!(\"{}()$0\", func_name), format!(\"{}()\", name))\n+            } else {\n+                (format!(\"{}($0)\", func_name), format!(\"{}(\u2026)\", name))\n+            };\n             builder = builder.lookup_by(name).label(label).insert_snippet(snippet);\n         }\n "}]}