{"sha": "748d516e0d468534c9dfccf00b99da55634ae2d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0OGQ1MTZlMGQ0Njg1MzRjOWRmY2NmMDBiOTlkYTU1NjM0YWUyZDI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-07-11T19:19:10Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-07-15T14:28:21Z"}, "message": "Use builtin ranlib instead of running external ranlib\n\nThis makes it possible to create rlibs for any target without installing\na toolchain for the target\n\nFixes #763", "tree": {"sha": "26cfc8f9e1602a79cf6052b4ea87e5b00aa394e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26cfc8f9e1602a79cf6052b4ea87e5b00aa394e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/748d516e0d468534c9dfccf00b99da55634ae2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/748d516e0d468534c9dfccf00b99da55634ae2d2", "html_url": "https://github.com/rust-lang/rust/commit/748d516e0d468534c9dfccf00b99da55634ae2d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/748d516e0d468534c9dfccf00b99da55634ae2d2/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e67eb1b44c2570024211701925bf287d4c7bdc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e67eb1b44c2570024211701925bf287d4c7bdc5", "html_url": "https://github.com/rust-lang/rust/commit/3e67eb1b44c2570024211701925bf287d4c7bdc5"}], "stats": {"total": 144, "additions": 79, "deletions": 65}, "files": [{"sha": "3fc3623d8b68f0a8cdcf56b004ea21f853e99a5b", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/748d516e0d468534c9dfccf00b99da55634ae2d2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/748d516e0d468534c9dfccf00b99da55634ae2d2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=748d516e0d468534c9dfccf00b99da55634ae2d2", "patch": "@@ -9,8 +9,7 @@ checksum = \"85bb70cc08ec97ca5450e6eba421deeea5f172c0fc61f78b5357b2a8e8be195f\"\n [[package]]\n name = \"ar\"\n version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"450575f58f7bee32816abbff470cbc47797397c2a81e0eaced4b98436daf52e1\"\n+source = \"git+https://github.com/bjorn3/rust-ar.git?branch=do_not_remove_cg_clif_ranlib#de9ab0e56bf3a208381d342aa5b60f9ff2891648\"\n \n [[package]]\n name = \"autocfg\""}, {"sha": "f16d45cd46a2574e70f81f755fe2050544014d6f", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/748d516e0d468534c9dfccf00b99da55634ae2d2/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/748d516e0d468534c9dfccf00b99da55634ae2d2/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=748d516e0d468534c9dfccf00b99da55634ae2d2", "patch": "@@ -18,7 +18,7 @@ target-lexicon = \"0.10.0\"\n gimli = { version = \"0.21.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.20.0\", default-features = false, features = [\"read\", \"std\", \"write\"] }\n \n-ar = \"0.8.0\"\n+ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n byteorder = \"1.2.7\"\n indexmap = \"1.0.2\"\n cfg-if = \"0.1.10\""}, {"sha": "0e5820936bc5966060368badc0ed4ce4f9b05e6b", "filename": "src/archive.rs", "status": "modified", "additions": 77, "deletions": 62, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/748d516e0d468534c9dfccf00b99da55634ae2d2/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748d516e0d468534c9dfccf00b99da55634ae2d2/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=748d516e0d468534c9dfccf00b99da55634ae2d2", "patch": "@@ -1,16 +1,19 @@\n+use std::collections::BTreeMap;\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n use rustc_session::Session;\n use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n use rustc_codegen_ssa::METADATA_FILENAME;\n \n+use object::{Object, SymbolKind};\n+\n struct ArchiveConfig<'a> {\n     sess: &'a Session,\n     dst: PathBuf,\n     lib_search_paths: Vec<PathBuf>,\n-    use_native_ar: bool,\n     use_gnu_style_archive: bool,\n+    no_builtin_ranlib: bool,\n }\n \n #[derive(Debug)]\n@@ -38,9 +41,9 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             sess,\n             dst: output.to_path_buf(),\n             lib_search_paths: archive_search_paths(sess),\n-            use_native_ar: false,\n-            // FIXME test for linux and System V derivatives instead\n             use_gnu_style_archive: sess.target.target.options.archive_format == \"gnu\",\n+            // FIXME fix builtin ranlib on macOS\n+            no_builtin_ranlib: sess.target.target.options.is_like_osx,\n         };\n \n         let (src_archives, entries) = if let Some(input) = input {\n@@ -141,85 +144,97 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     }\n \n     fn build(mut self) {\n-        use std::process::Command;\n-\n-        fn add_file_using_ar(archive: &Path, file: &Path) {\n-            Command::new(\"ar\")\n-                .arg(\"r\") // add or replace file\n-                .arg(\"-c\") // silence created file message\n-                .arg(archive)\n-                .arg(&file)\n-                .status()\n-                .unwrap();\n-        }\n-\n-        enum BuilderKind<'a> {\n+        enum BuilderKind {\n             Bsd(ar::Builder<File>),\n             Gnu(ar::GnuBuilder<File>),\n-            NativeAr(&'a Path),\n         }\n \n-        let mut builder = if self.config.use_native_ar {\n-            BuilderKind::NativeAr(&self.config.dst)\n-        } else if self.config.use_gnu_style_archive {\n-            BuilderKind::Gnu(ar::GnuBuilder::new(\n-                File::create(&self.config.dst).unwrap(),\n-                self.entries\n-                    .iter()\n-                    .map(|(name, _)| name.as_bytes().to_vec())\n-                    .collect(),\n-            ))\n-        } else {\n-            BuilderKind::Bsd(ar::Builder::new(File::create(&self.config.dst).unwrap()))\n-        };\n+        let mut symbol_table = BTreeMap::new();\n \n-        // Add all files\n-        for (entry_name, entry) in self.entries.into_iter() {\n-            match entry {\n+        let mut entries = Vec::new();\n+\n+        for (entry_name, entry) in self.entries {\n+            // FIXME only read the symbol table of the object files to avoid having to keep all\n+            // object files in memory at once, or read them twice.\n+            let data = match entry {\n                 ArchiveEntry::FromArchive {\n                     archive_index,\n                     entry_index,\n                 } => {\n-                    let (ref src_archive_path, ref mut src_archive) =\n+                    // FIXME read symbols from symtab\n+                    use std::io::Read;\n+                    let (ref _src_archive_path, ref mut src_archive) =\n                         self.src_archives[archive_index];\n-                    let entry = src_archive.jump_to_entry(entry_index).unwrap();\n-                    let header = entry.header().clone();\n+                    let mut entry = src_archive.jump_to_entry(entry_index).unwrap();\n+                    let mut data = Vec::new();\n+                    entry.read_to_end(&mut data).unwrap();\n+                    data\n \n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::NativeAr(archive_file) => {\n-                            Command::new(\"ar\")\n-                                .arg(\"x\")\n-                                .arg(src_archive_path)\n-                                .arg(&entry_name)\n-                                .status()\n-                                .unwrap();\n-                            add_file_using_ar(archive_file, Path::new(&entry_name));\n-                            std::fs::remove_file(entry_name).unwrap();\n+                }\n+                ArchiveEntry::File(file) => {\n+                    std::fs::read(file).unwrap()\n+                }\n+            };\n+\n+            if !self.config.no_builtin_ranlib {\n+                match object::File::parse(&data) {\n+                    Ok(object) => {\n+                        symbol_table.insert(entry_name.as_bytes().to_vec(), object.symbols().filter_map(|(_index, symbol)| {\n+                            if symbol.is_undefined() || symbol.is_local() || symbol.kind() != SymbolKind::Data && symbol.kind() != SymbolKind::Text && symbol.kind() != SymbolKind::Tls {\n+                                None\n+                            } else {\n+                                symbol.name().map(|name| name.as_bytes().to_vec())\n+                            }\n+                        }).collect::<Vec<_>>());\n+                    }\n+                    Err(err) => {\n+                        let err = err.to_string();\n+                        if err == \"Unknown file magic\" {\n+                            // Not an object file; skip it.\n+                        } else {\n+                            self.config.sess.fatal(&format!(\"Error parsing `{}` during archive creation: {}\", entry_name, err));\n                         }\n                     }\n                 }\n-                ArchiveEntry::File(file) => match builder {\n-                    BuilderKind::Bsd(ref mut builder) => builder\n-                        .append_file(entry_name.as_bytes(), &mut File::open(file).unwrap())\n-                        .unwrap(),\n-                    BuilderKind::Gnu(ref mut builder) => builder\n-                        .append_file(entry_name.as_bytes(), &mut File::open(file).unwrap())\n-                        .unwrap(),\n-                    BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n-                },\n+            }\n+\n+            entries.push((entry_name, data));\n+        }\n+\n+        let mut builder = if self.config.use_gnu_style_archive {\n+            BuilderKind::Gnu(ar::GnuBuilder::new(\n+                File::create(&self.config.dst).unwrap(),\n+                entries\n+                    .iter()\n+                    .map(|(name, _)| name.as_bytes().to_vec())\n+                    .collect(),\n+                ar::GnuSymbolTableFormat::Size32,\n+                symbol_table,\n+            ).unwrap())\n+        } else {\n+            BuilderKind::Bsd(ar::Builder::new(\n+                File::create(&self.config.dst).unwrap(),\n+                symbol_table,\n+            ).unwrap())\n+        };\n+\n+        // Add all files\n+        for (entry_name, data) in entries.into_iter() {\n+            let header = ar::Header::new(entry_name.into_bytes(), data.len() as u64);\n+            match builder {\n+                BuilderKind::Bsd(ref mut builder) => builder\n+                    .append(&header, &mut &*data)\n+                    .unwrap(),\n+                BuilderKind::Gnu(ref mut builder) => builder\n+                    .append(&header, &mut &*data)\n+                    .unwrap(),\n             }\n         }\n \n         // Finalize archive\n         std::mem::drop(builder);\n \n-        if self.update_symbols {\n+        if self.config.no_builtin_ranlib {\n             let ranlib = crate::toolchain::get_toolchain_binary(self.config.sess, \"ranlib\");\n \n             // Run ranlib to be able to link the archive"}]}