{"sha": "f8cbf41064869f0e99137d64cc236831c565247c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4Y2JmNDEwNjQ4NjlmMGU5OTEzN2Q2NGNjMjM2ODMxYzU2NTI0N2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-11T08:46:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-11T08:46:07Z"}, "message": "auto merge of #9093 : pnkfelix/rust/fsk-remove-oldvisit, r=alexcrichton", "tree": {"sha": "d23e79a9d082a9b179b060f2cd1d0bb24566c4f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d23e79a9d082a9b179b060f2cd1d0bb24566c4f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8cbf41064869f0e99137d64cc236831c565247c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8cbf41064869f0e99137d64cc236831c565247c", "html_url": "https://github.com/rust-lang/rust/commit/f8cbf41064869f0e99137d64cc236831c565247c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8cbf41064869f0e99137d64cc236831c565247c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef6a97ddbed10ac3483c639fb27e7771fd155ebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef6a97ddbed10ac3483c639fb27e7771fd155ebc", "html_url": "https://github.com/rust-lang/rust/commit/ef6a97ddbed10ac3483c639fb27e7771fd155ebc"}, {"sha": "8b00004871af8b573c88b22cb80c4a1f0316451b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b00004871af8b573c88b22cb80c4a1f0316451b", "html_url": "https://github.com/rust-lang/rust/commit/8b00004871af8b573c88b22cb80c4a1f0316451b"}], "stats": {"total": 780, "additions": 0, "deletions": 780}, "files": [{"sha": "80e037bce812da2d5a862dcaaa98d0c7895ab24b", "filename": "src/libsyntax/oldvisit.rs", "status": "removed", "additions": 0, "deletions": 779, "changes": 779, "blob_url": "https://github.com/rust-lang/rust/blob/ef6a97ddbed10ac3483c639fb27e7771fd155ebc/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6a97ddbed10ac3483c639fb27e7771fd155ebc/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=ef6a97ddbed10ac3483c639fb27e7771fd155ebc", "patch": "@@ -1,779 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use abi::AbiSet;\n-use ast::*;\n-use ast;\n-use codemap::Span;\n-use parse;\n-use opt_vec;\n-use opt_vec::OptVec;\n-\n-// Context-passing AST walker. Each overridden visit method has full control\n-// over what happens with its node, it can do its own traversal of the node's\n-// children (potentially passing in different contexts to each), call\n-// visit::visit_* to apply the default traversal algorithm (again, it can\n-// override the context), or prevent deeper traversal by doing nothing.\n-//\n-// Note: it is an important invariant that the default visitor walks the body\n-// of a function in \"execution order\" (more concretely, reverse post-order\n-// with respect to the CFG implied by the AST), meaning that if AST node A may\n-// execute before AST node B, then A is visited first.  The borrow checker in\n-// particular relies on this property.\n-\n-// Our typesystem doesn't do circular types, so the visitor record can not\n-// hold functions that take visitors. A vt enum is used to break the cycle.\n-pub enum vt<E> { mk_vt(visitor<E>), }\n-\n-pub enum fn_kind<'self> {\n-    // fn foo() or extern \"Abi\" fn foo()\n-    fk_item_fn(Ident, &'self Generics, purity, AbiSet),\n-\n-    // fn foo(&self)\n-    fk_method(Ident, &'self Generics, &'self method),\n-\n-    // @fn(x, y) { ... }\n-    fk_anon(ast::Sigil),\n-\n-    // |x, y| ...\n-    fk_fn_block,\n-}\n-\n-pub fn name_of_fn(fk: &fn_kind) -> Ident {\n-    match *fk {\n-      fk_item_fn(name, _, _, _) | fk_method(name, _, _) => {\n-          name\n-      }\n-      fk_anon(*) | fk_fn_block(*) => parse::token::special_idents::anon,\n-    }\n-}\n-\n-pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n-    match *fk {\n-        fk_item_fn(_, generics, _, _) |\n-        fk_method(_, generics, _) => {\n-            (*generics).clone()\n-        }\n-        fk_anon(*) | fk_fn_block(*) => {\n-            Generics {\n-                lifetimes: opt_vec::Empty,\n-                ty_params: opt_vec::Empty,\n-            }\n-        }\n-    }\n-}\n-\n-pub struct Visitor<E> {\n-    visit_mod: @fn(&_mod, Span, NodeId, (E, vt<E>)),\n-    visit_view_item: @fn(&view_item, (E, vt<E>)),\n-    visit_foreign_item: @fn(@foreign_item, (E, vt<E>)),\n-    visit_item: @fn(@item, (E, vt<E>)),\n-    visit_local: @fn(@Local, (E, vt<E>)),\n-    visit_block: @fn(&Block, (E, vt<E>)),\n-    visit_stmt: @fn(@Stmt, (E, vt<E>)),\n-    visit_arm: @fn(&Arm, (E, vt<E>)),\n-    visit_pat: @fn(@Pat, (E, vt<E>)),\n-    visit_decl: @fn(@Decl, (E, vt<E>)),\n-    visit_expr: @fn(@Expr, (E, vt<E>)),\n-    visit_expr_post: @fn(@Expr, (E, vt<E>)),\n-    visit_ty: @fn(&Ty, (E, vt<E>)),\n-    visit_generics: @fn(&Generics, (E, vt<E>)),\n-    visit_fn: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId, (E, vt<E>)),\n-    visit_ty_method: @fn(&TypeMethod, (E, vt<E>)),\n-    visit_trait_method: @fn(&trait_method, (E, vt<E>)),\n-    visit_struct_def: @fn(@struct_def, Ident, &Generics, NodeId, (E, vt<E>)),\n-    visit_struct_field: @fn(@struct_field, (E, vt<E>)),\n-}\n-\n-pub type visitor<E> = @Visitor<E>;\n-\n-pub fn default_visitor<E:Clone>() -> visitor<E> {\n-    return @Visitor {\n-        visit_mod: |a,b,c,d|visit_mod::<E>(a, b, c, d),\n-        visit_view_item: |a,b|visit_view_item::<E>(a, b),\n-        visit_foreign_item: |a,b|visit_foreign_item::<E>(a, b),\n-        visit_item: |a,b|visit_item::<E>(a, b),\n-        visit_local: |a,b|visit_local::<E>(a, b),\n-        visit_block: |a,b|visit_block::<E>(a, b),\n-        visit_stmt: |a,b|visit_stmt::<E>(a, b),\n-        visit_arm: |a,b|visit_arm::<E>(a, b),\n-        visit_pat: |a,b|visit_pat::<E>(a, b),\n-        visit_decl: |a,b|visit_decl::<E>(a, b),\n-        visit_expr: |a,b|visit_expr::<E>(a, b),\n-        visit_expr_post: |_a,_b| (),\n-        visit_ty: |a,b|skip_ty::<E>(a, b),\n-        visit_generics: |a,b|visit_generics::<E>(a, b),\n-        visit_fn: |a,b,c,d,e,f|visit_fn::<E>(a, b, c, d, e, f),\n-        visit_ty_method: |a,b|visit_ty_method::<E>(a, b),\n-        visit_trait_method: |a,b|visit_trait_method::<E>(a, b),\n-        visit_struct_def: |a,b,c,d,e|visit_struct_def::<E>(a, b, c, d, e),\n-        visit_struct_field: |a,b|visit_struct_field::<E>(a, b),\n-    };\n-}\n-\n-pub fn visit_crate<E:Clone>(c: &Crate, (e, v): (E, vt<E>)) {\n-    (v.visit_mod)(&c.module, c.span, CRATE_NODE_ID, (e, v));\n-}\n-\n-pub fn visit_mod<E:Clone>(m: &_mod,\n-                          _sp: Span,\n-                          _id: NodeId,\n-                          (e, v): (E, vt<E>)) {\n-    for vi in m.view_items.iter() {\n-        (v.visit_view_item)(vi, (e.clone(), v));\n-    }\n-    for i in m.items.iter() {\n-        (v.visit_item)(*i, (e.clone(), v));\n-    }\n-}\n-\n-pub fn visit_view_item<E>(_vi: &view_item, (_e, _v): (E, vt<E>)) { }\n-\n-pub fn visit_local<E:Clone>(loc: &Local, (e, v): (E, vt<E>)) {\n-    (v.visit_pat)(loc.pat, (e.clone(), v));\n-    (v.visit_ty)(&loc.ty, (e.clone(), v));\n-    match loc.init {\n-      None => (),\n-      Some(ex) => (v.visit_expr)(ex, (e, v))\n-    }\n-}\n-\n-fn visit_trait_ref<E:Clone>(tref: &ast::trait_ref, (e, v): (E, vt<E>)) {\n-    visit_path(&tref.path, (e, v));\n-}\n-\n-pub fn visit_item<E:Clone>(i: &item, (e, v): (E, vt<E>)) {\n-    match i.node {\n-        item_static(ref t, _, ex) => {\n-            (v.visit_ty)(t, (e.clone(), v));\n-            (v.visit_expr)(ex, (e.clone(), v));\n-        }\n-        item_fn(ref decl, purity, abi, ref generics, ref body) => {\n-            (v.visit_fn)(\n-                &fk_item_fn(\n-                    i.ident,\n-                    generics,\n-                    purity,\n-                    abi\n-                ),\n-                decl,\n-                body,\n-                i.span,\n-                i.id,\n-                (e,\n-                 v)\n-            );\n-        }\n-        item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n-        item_foreign_mod(ref nm) => {\n-            for vi in nm.view_items.iter() {\n-                (v.visit_view_item)(vi, (e.clone(), v));\n-            }\n-            for ni in nm.items.iter() {\n-                (v.visit_foreign_item)(*ni, (e.clone(), v));\n-            }\n-        }\n-        item_ty(ref t, ref tps) => {\n-            (v.visit_ty)(t, (e.clone(), v));\n-            (v.visit_generics)(tps, (e, v));\n-        }\n-        item_enum(ref enum_definition, ref tps) => {\n-            (v.visit_generics)(tps, (e.clone(), v));\n-            visit_enum_def(\n-                enum_definition,\n-                tps,\n-                (e, v)\n-            );\n-        }\n-        item_impl(ref tps, ref traits, ref ty, ref methods) => {\n-            (v.visit_generics)(tps, (e.clone(), v));\n-            for p in traits.iter() {\n-                visit_trait_ref(p, (e.clone(), v));\n-            }\n-            (v.visit_ty)(ty, (e.clone(), v));\n-            for m in methods.iter() {\n-                visit_method_helper(*m, (e.clone(), v))\n-            }\n-        }\n-        item_struct(struct_def, ref generics) => {\n-            (v.visit_generics)(generics, (e.clone(), v));\n-            (v.visit_struct_def)(struct_def, i.ident, generics, i.id, (e, v));\n-        }\n-        item_trait(ref generics, ref traits, ref methods) => {\n-            (v.visit_generics)(generics, (e.clone(), v));\n-            for p in traits.iter() {\n-                visit_path(&p.path, (e.clone(), v));\n-            }\n-            for m in methods.iter() {\n-                (v.visit_trait_method)(m, (e.clone(), v));\n-            }\n-        }\n-        item_mac(ref m) => visit_mac(m, (e, v))\n-    }\n-}\n-\n-pub fn visit_enum_def<E:Clone>(enum_definition: &ast::enum_def,\n-                               tps: &Generics,\n-                               (e, v): (E, vt<E>)) {\n-    for vr in enum_definition.variants.iter() {\n-        match vr.node.kind {\n-            tuple_variant_kind(ref variant_args) => {\n-                for va in variant_args.iter() {\n-                    (v.visit_ty)(&va.ty, (e.clone(), v));\n-                }\n-            }\n-            struct_variant_kind(struct_def) => {\n-                (v.visit_struct_def)(struct_def, vr.node.name, tps,\n-                                     vr.node.id, (e.clone(), v));\n-            }\n-        }\n-        // Visit the disr expr if it exists\n-        for ex in vr.node.disr_expr.iter() {\n-            (v.visit_expr)(*ex, (e.clone(), v))\n-        }\n-    }\n-}\n-\n-pub fn skip_ty<E>(_t: &Ty, (_e,_v): (E, vt<E>)) {}\n-\n-pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n-    match t.node {\n-        ty_box(ref mt) | ty_uniq(ref mt) |\n-        ty_vec(ref mt) | ty_ptr(ref mt) | ty_rptr(_, ref mt) => {\n-            (v.visit_ty)(mt.ty, (e, v));\n-        },\n-        ty_tup(ref ts) => {\n-            for tt in ts.iter() {\n-                (v.visit_ty)(tt, (e.clone(), v));\n-            }\n-        },\n-        ty_closure(ref f) => {\n-            for a in f.decl.inputs.iter() {\n-                (v.visit_ty)(&a.ty, (e.clone(), v));\n-            }\n-            (v.visit_ty)(&f.decl.output, (e.clone(), v));\n-            do f.bounds.map |bounds| {\n-                visit_ty_param_bounds(bounds, (e.clone(), v));\n-            };\n-        },\n-        ty_bare_fn(ref f) => {\n-            for a in f.decl.inputs.iter() {\n-                (v.visit_ty)(&a.ty, (e.clone(), v));\n-            }\n-            (v.visit_ty)(&f.decl.output, (e, v));\n-        },\n-        ty_path(ref p, ref bounds, _) => {\n-            visit_path(p, (e.clone(), v));\n-            do bounds.map |bounds| {\n-                visit_ty_param_bounds(bounds, (e.clone(), v));\n-            };\n-        },\n-        ty_fixed_length_vec(ref mt, ex) => {\n-            (v.visit_ty)(mt.ty, (e.clone(), v));\n-            (v.visit_expr)(ex, (e.clone(), v));\n-        },\n-        ty_typeof(ex) => {\n-            (v.visit_expr)(ex, (e.clone(), v));\n-        }\n-        ty_nil | ty_bot | ty_mac(_) | ty_infer => ()\n-    }\n-}\n-\n-pub fn visit_path<E:Clone>(p: &Path, (e, v): (E, vt<E>)) {\n-    for segment in p.segments.iter() {\n-        for typ in segment.types.iter() {\n-            (v.visit_ty)(typ, (e.clone(), v))\n-        }\n-    }\n-}\n-\n-pub fn visit_pat<E:Clone>(p: &Pat, (e, v): (E, vt<E>)) {\n-    match p.node {\n-        PatEnum(ref path, ref children) => {\n-            visit_path(path, (e.clone(), v));\n-            for children in children.iter() {\n-                for child in children.iter() {\n-                    (v.visit_pat)(*child, (e.clone(), v));\n-                }\n-            }\n-        }\n-        PatStruct(ref path, ref fields, _) => {\n-            visit_path(path, (e.clone(), v));\n-            for f in fields.iter() {\n-                (v.visit_pat)(f.pat, (e.clone(), v));\n-            }\n-        }\n-        PatTup(ref elts) => {\n-            for elt in elts.iter() {\n-                (v.visit_pat)(*elt, (e.clone(), v))\n-            }\n-        },\n-        PatBox(inner) | PatUniq(inner) | PatRegion(inner) => {\n-            (v.visit_pat)(inner, (e, v))\n-        },\n-        PatIdent(_, ref path, ref inner) => {\n-            visit_path(path, (e.clone(), v));\n-            for subpat in inner.iter() {\n-                (v.visit_pat)(*subpat, (e.clone(), v))\n-            }\n-        }\n-        PatLit(ex) => (v.visit_expr)(ex, (e, v)),\n-        PatRange(e1, e2) => {\n-            (v.visit_expr)(e1, (e.clone(), v));\n-            (v.visit_expr)(e2, (e, v));\n-        }\n-        PatWild => (),\n-        PatVec(ref before, ref slice, ref after) => {\n-            for elt in before.iter() {\n-                (v.visit_pat)(*elt, (e.clone(), v));\n-            }\n-            for elt in slice.iter() {\n-                (v.visit_pat)(*elt, (e.clone(), v));\n-            }\n-            for tail in after.iter() {\n-                (v.visit_pat)(*tail, (e.clone(), v));\n-            }\n-        }\n-    }\n-}\n-\n-pub fn visit_foreign_item<E:Clone>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n-    match ni.node {\n-        foreign_item_fn(ref fd, ref generics) => {\n-            visit_fn_decl(fd, (e.clone(), v));\n-            (v.visit_generics)(generics, (e, v));\n-        }\n-        foreign_item_static(ref t, _) => {\n-            (v.visit_ty)(t, (e, v));\n-        }\n-    }\n-}\n-\n-pub fn visit_ty_param_bounds<E:Clone>(bounds: &OptVec<TyParamBound>,\n-                                      (e, v): (E, vt<E>)) {\n-    for bound in bounds.iter() {\n-        match *bound {\n-            TraitTyParamBound(ref ty) => visit_trait_ref(ty, (e.clone(), v)),\n-            RegionTyParamBound => {}\n-        }\n-    }\n-}\n-\n-pub fn visit_generics<E:Clone>(generics: &Generics, (e, v): (E, vt<E>)) {\n-    for tp in generics.ty_params.iter() {\n-        visit_ty_param_bounds(&tp.bounds, (e.clone(), v));\n-    }\n-}\n-\n-pub fn visit_fn_decl<E:Clone>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n-    for a in fd.inputs.iter() {\n-        (v.visit_pat)(a.pat, (e.clone(), v));\n-        (v.visit_ty)(&a.ty, (e.clone(), v));\n-    }\n-    (v.visit_ty)(&fd.output, (e, v));\n-}\n-\n-// Note: there is no visit_method() method in the visitor, instead override\n-// visit_fn() and check for fk_method().  I named this visit_method_helper()\n-// because it is not a default impl of any method, though I doubt that really\n-// clarifies anything. - Niko\n-pub fn visit_method_helper<E:Clone>(m: &method, (e, v): (E, vt<E>)) {\n-    (v.visit_fn)(&fk_method(m.ident, &m.generics, m),\n-                 &m.decl,\n-                 &m.body,\n-                 m.span,\n-                 m.id,\n-                 (e, v));\n-}\n-\n-pub fn visit_fn<E:Clone>(fk: &fn_kind,\n-                         decl: &fn_decl,\n-                         body: &Block,\n-                         _sp: Span,\n-                         _id: NodeId,\n-                         (e, v): (E, vt<E>)) {\n-    visit_fn_decl(decl, (e.clone(), v));\n-    let generics = generics_of_fn(fk);\n-    (v.visit_generics)(&generics, (e.clone(), v));\n-    (v.visit_block)(body, (e, v));\n-}\n-\n-pub fn visit_ty_method<E:Clone>(m: &TypeMethod, (e, v): (E, vt<E>)) {\n-    for a in m.decl.inputs.iter() {\n-        (v.visit_ty)(&a.ty, (e.clone(), v));\n-    }\n-    (v.visit_generics)(&m.generics, (e.clone(), v));\n-    (v.visit_ty)(&m.decl.output, (e, v));\n-}\n-\n-pub fn visit_trait_method<E:Clone>(m: &trait_method, (e, v): (E, vt<E>)) {\n-    match *m {\n-      required(ref ty_m) => (v.visit_ty_method)(ty_m, (e, v)),\n-      provided(m) => visit_method_helper(m, (e, v))\n-    }\n-}\n-\n-pub fn visit_struct_def<E:Clone>(\n-    sd: @struct_def,\n-    _nm: ast::Ident,\n-    _generics: &Generics,\n-    _id: NodeId,\n-    (e, v): (E, vt<E>)\n-) {\n-    for f in sd.fields.iter() {\n-        (v.visit_struct_field)(*f, (e.clone(), v));\n-    }\n-}\n-\n-pub fn visit_struct_field<E:Clone>(sf: &struct_field, (e, v): (E, vt<E>)) {\n-    (v.visit_ty)(&sf.node.ty, (e, v));\n-}\n-\n-pub fn visit_block<E:Clone>(b: &Block, (e, v): (E, vt<E>)) {\n-    for vi in b.view_items.iter() {\n-        (v.visit_view_item)(vi, (e.clone(), v));\n-    }\n-    for s in b.stmts.iter() {\n-        (v.visit_stmt)(*s, (e.clone(), v));\n-    }\n-    visit_expr_opt(b.expr, (e, v));\n-}\n-\n-pub fn visit_stmt<E>(s: &Stmt, (e, v): (E, vt<E>)) {\n-    match s.node {\n-      StmtDecl(d, _) => (v.visit_decl)(d, (e, v)),\n-      StmtExpr(ex, _) => (v.visit_expr)(ex, (e, v)),\n-      StmtSemi(ex, _) => (v.visit_expr)(ex, (e, v)),\n-      StmtMac(ref mac, _) => visit_mac(mac, (e, v))\n-    }\n-}\n-\n-pub fn visit_decl<E:Clone>(d: &Decl, (e, v): (E, vt<E>)) {\n-    match d.node {\n-        DeclLocal(ref loc) => (v.visit_local)(*loc, (e, v)),\n-        DeclItem(it) => (v.visit_item)(it, (e, v))\n-    }\n-}\n-\n-pub fn visit_expr_opt<E>(eo: Option<@Expr>, (e, v): (E, vt<E>)) {\n-    match eo { None => (), Some(ex) => (v.visit_expr)(ex, (e, v)) }\n-}\n-\n-pub fn visit_exprs<E:Clone>(exprs: &[@Expr], (e, v): (E, vt<E>)) {\n-    for ex in exprs.iter() { (v.visit_expr)(*ex, (e.clone(), v)); }\n-}\n-\n-pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n-    /* no user-serviceable parts inside */\n-}\n-\n-pub fn visit_expr<E:Clone>(ex: @Expr, (e, v): (E, vt<E>)) {\n-    match ex.node {\n-        ExprVstore(x, _) => (v.visit_expr)(x, (e.clone(), v)),\n-        ExprVec(ref es, _) => visit_exprs(*es, (e.clone(), v)),\n-        ExprRepeat(element, count, _) => {\n-            (v.visit_expr)(element, (e.clone(), v));\n-            (v.visit_expr)(count, (e.clone(), v));\n-        }\n-        ExprStruct(ref p, ref flds, base) => {\n-            visit_path(p, (e.clone(), v));\n-            for f in flds.iter() {\n-                (v.visit_expr)(f.expr, (e.clone(), v));\n-            }\n-            visit_expr_opt(base, (e.clone(), v));\n-        }\n-        ExprTup(ref elts) => {\n-            for el in elts.iter() { (v.visit_expr)(*el, (e.clone(), v)) }\n-        }\n-        ExprCall(callee, ref args, _) => {\n-            visit_exprs(*args, (e.clone(), v));\n-            (v.visit_expr)(callee, (e.clone(), v));\n-        }\n-        ExprMethodCall(_, callee, _, ref tys, ref args, _) => {\n-            visit_exprs(*args, (e.clone(), v));\n-            for tp in tys.iter() {\n-                (v.visit_ty)(tp, (e.clone(), v));\n-            }\n-            (v.visit_expr)(callee, (e.clone(), v));\n-        }\n-        ExprBinary(_, _, a, b) => {\n-            (v.visit_expr)(a, (e.clone(), v));\n-            (v.visit_expr)(b, (e.clone(), v));\n-        }\n-        ExprAddrOf(_, x) | ExprUnary(_, _, x) |\n-        ExprDoBody(x) => (v.visit_expr)(x, (e.clone(), v)),\n-        ExprLit(_) => (),\n-        ExprCast(x, ref t) => {\n-            (v.visit_expr)(x, (e.clone(), v));\n-            (v.visit_ty)(t, (e.clone(), v));\n-        }\n-        ExprIf(x, ref b, eo) => {\n-            (v.visit_expr)(x, (e.clone(), v));\n-            (v.visit_block)(b, (e.clone(), v));\n-            visit_expr_opt(eo, (e.clone(), v));\n-        }\n-        ExprWhile(x, ref b) => {\n-            (v.visit_expr)(x, (e.clone(), v));\n-            (v.visit_block)(b, (e.clone(), v));\n-        }\n-        ExprForLoop(pattern, subexpression, ref block, _) => {\n-            (v.visit_pat)(pattern, (e.clone(), v));\n-            (v.visit_expr)(subexpression, (e.clone(), v));\n-            (v.visit_block)(block, (e.clone(), v))\n-        }\n-        ExprLoop(ref b, _) => (v.visit_block)(b, (e.clone(), v)),\n-        ExprMatch(x, ref arms) => {\n-            (v.visit_expr)(x, (e.clone(), v));\n-            for a in arms.iter() { (v.visit_arm)(a, (e.clone(), v)); }\n-        }\n-        ExprFnBlock(ref decl, ref body) => {\n-            (v.visit_fn)(\n-                &fk_fn_block,\n-                decl,\n-                body,\n-                ex.span,\n-                ex.id,\n-                (e.clone(), v)\n-            );\n-        }\n-        ExprBlock(ref b) => (v.visit_block)(b, (e.clone(), v)),\n-        ExprAssign(a, b) => {\n-            (v.visit_expr)(b, (e.clone(), v));\n-            (v.visit_expr)(a, (e.clone(), v));\n-        }\n-        ExprAssignOp(_, _, a, b) => {\n-            (v.visit_expr)(b, (e.clone(), v));\n-            (v.visit_expr)(a, (e.clone(), v));\n-        }\n-        ExprField(x, _, ref tys) => {\n-            (v.visit_expr)(x, (e.clone(), v));\n-            for tp in tys.iter() {\n-                (v.visit_ty)(tp, (e.clone(), v));\n-            }\n-        }\n-        ExprIndex(_, a, b) => {\n-            (v.visit_expr)(a, (e.clone(), v));\n-            (v.visit_expr)(b, (e.clone(), v));\n-        }\n-        ExprPath(ref p) => visit_path(p, (e.clone(), v)),\n-        ExprSelf => (),\n-        ExprBreak(_) => (),\n-        ExprAgain(_) => (),\n-        ExprRet(eo) => visit_expr_opt(eo, (e.clone(), v)),\n-        ExprLogLevel => (),\n-        ExprMac(ref mac) => visit_mac(mac, (e.clone(), v)),\n-        ExprParen(x) => (v.visit_expr)(x, (e.clone(), v)),\n-        ExprInlineAsm(ref a) => {\n-            for &(_, input) in a.inputs.iter() {\n-                (v.visit_expr)(input, (e.clone(), v));\n-            }\n-            for &(_, out) in a.outputs.iter() {\n-                (v.visit_expr)(out, (e.clone(), v));\n-            }\n-        }\n-    }\n-    (v.visit_expr_post)(ex, (e, v));\n-}\n-\n-pub fn visit_arm<E:Clone>(a: &Arm, (e, v): (E, vt<E>)) {\n-    for p in a.pats.iter() { (v.visit_pat)(*p, (e.clone(), v)); }\n-    visit_expr_opt(a.guard, (e.clone(), v));\n-    (v.visit_block)(&a.body, (e.clone(), v));\n-}\n-\n-// Simpler, non-context passing interface. Always walks the whole tree, simply\n-// calls the given functions on the nodes.\n-\n-pub struct SimpleVisitor {\n-    visit_mod: @fn(&_mod, Span, NodeId),\n-    visit_view_item: @fn(&view_item),\n-    visit_foreign_item: @fn(@foreign_item),\n-    visit_item: @fn(@item),\n-    visit_local: @fn(@Local),\n-    visit_block: @fn(&Block),\n-    visit_stmt: @fn(@Stmt),\n-    visit_arm: @fn(&Arm),\n-    visit_pat: @fn(@Pat),\n-    visit_decl: @fn(@Decl),\n-    visit_expr: @fn(@Expr),\n-    visit_expr_post: @fn(@Expr),\n-    visit_ty: @fn(&Ty),\n-    visit_generics: @fn(&Generics),\n-    visit_fn: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId),\n-    visit_ty_method: @fn(&TypeMethod),\n-    visit_trait_method: @fn(&trait_method),\n-    visit_struct_def: @fn(@struct_def, Ident, &Generics, NodeId),\n-    visit_struct_field: @fn(@struct_field),\n-    visit_struct_method: @fn(@method)\n-}\n-\n-pub type simple_visitor = @SimpleVisitor;\n-\n-pub fn simple_ignore_ty(_t: &Ty) {}\n-\n-pub fn default_simple_visitor() -> @SimpleVisitor {\n-    @SimpleVisitor {\n-        visit_mod: |_m, _sp, _id| { },\n-        visit_view_item: |_vi| { },\n-        visit_foreign_item: |_ni| { },\n-        visit_item: |_i| { },\n-        visit_local: |_l| { },\n-        visit_block: |_b| { },\n-        visit_stmt: |_s| { },\n-        visit_arm: |_a| { },\n-        visit_pat: |_p| { },\n-        visit_decl: |_d| { },\n-        visit_expr: |_e| { },\n-        visit_expr_post: |_e| { },\n-        visit_ty: simple_ignore_ty,\n-        visit_generics: |_| {},\n-        visit_fn: |_, _, _, _, _| {},\n-        visit_ty_method: |_| {},\n-        visit_trait_method: |_| {},\n-        visit_struct_def: |_, _, _, _| {},\n-        visit_struct_field: |_| {},\n-        visit_struct_method: |_| {},\n-    }\n-}\n-\n-pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n-    fn v_mod(\n-        f: @fn(&_mod, Span, NodeId),\n-        m: &_mod,\n-        sp: Span,\n-        id: NodeId,\n-        (e, v): ((), vt<()>)\n-    ) {\n-        f(m, sp, id);\n-        visit_mod(m, sp, id, (e, v));\n-    }\n-    fn v_view_item(f: @fn(&view_item), vi: &view_item, (e, v): ((), vt<()>)) {\n-        f(vi);\n-        visit_view_item(vi, (e, v));\n-    }\n-    fn v_foreign_item(f: @fn(@foreign_item), ni: @foreign_item, (e, v): ((), vt<()>)) {\n-        f(ni);\n-        visit_foreign_item(ni, (e, v));\n-    }\n-    fn v_item(f: @fn(@item), i: @item, (e, v): ((), vt<()>)) {\n-        f(i);\n-        visit_item(i, (e, v));\n-    }\n-    fn v_local(f: @fn(@Local), l: @Local, (e, v): ((), vt<()>)) {\n-        f(l);\n-        visit_local(l, (e, v));\n-    }\n-    fn v_block(f: @fn(&ast::Block), bl: &ast::Block, (e, v): ((), vt<()>)) {\n-        f(bl);\n-        visit_block(bl, (e, v));\n-    }\n-    fn v_stmt(f: @fn(@Stmt), st: @Stmt, (e, v): ((), vt<()>)) {\n-        f(st);\n-        visit_stmt(st, (e, v));\n-    }\n-    fn v_arm(f: @fn(&Arm), a: &Arm, (e, v): ((), vt<()>)) {\n-        f(a);\n-        visit_arm(a, (e, v));\n-    }\n-    fn v_pat(f: @fn(@Pat), p: @Pat, (e, v): ((), vt<()>)) {\n-        f(p);\n-        visit_pat(p, (e, v));\n-    }\n-    fn v_decl(f: @fn(@Decl), d: @Decl, (e, v): ((), vt<()>)) {\n-        f(d);\n-        visit_decl(d, (e, v));\n-    }\n-    fn v_expr(f: @fn(@Expr), ex: @Expr, (e, v): ((), vt<()>)) {\n-        f(ex);\n-        visit_expr(ex, (e, v));\n-    }\n-    fn v_expr_post(f: @fn(@Expr), ex: @Expr, (_e, _v): ((), vt<()>)) {\n-        f(ex);\n-    }\n-    fn v_ty(f: @fn(&Ty), ty: &Ty, (e, v): ((), vt<()>)) {\n-        f(ty);\n-        visit_ty(ty, (e, v));\n-    }\n-    fn v_ty_method(f: @fn(&TypeMethod), ty: &TypeMethod, (e, v): ((), vt<()>)) {\n-        f(ty);\n-        visit_ty_method(ty, (e, v));\n-    }\n-    fn v_trait_method(f: @fn(&trait_method),\n-                      m: &trait_method,\n-                      (e, v): ((), vt<()>)) {\n-        f(m);\n-        visit_trait_method(m, (e, v));\n-    }\n-    fn v_struct_def(\n-        f: @fn(@struct_def, Ident, &Generics, NodeId),\n-        sd: @struct_def,\n-        nm: Ident,\n-        generics: &Generics,\n-        id: NodeId,\n-        (e, v): ((), vt<()>)\n-    ) {\n-        f(sd, nm, generics, id);\n-        visit_struct_def(sd, nm, generics, id, (e, v));\n-    }\n-    fn v_generics(\n-        f: @fn(&Generics),\n-        ps: &Generics,\n-        (e, v): ((), vt<()>)\n-    ) {\n-        f(ps);\n-        visit_generics(ps, (e, v));\n-    }\n-    fn v_fn(\n-        f: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId),\n-        fk: &fn_kind,\n-        decl: &fn_decl,\n-        body: &Block,\n-        sp: Span,\n-        id: NodeId,\n-        (e, v): ((), vt<()>)\n-    ) {\n-        f(fk, decl, body, sp, id);\n-        visit_fn(fk, decl, body, sp, id, (e, v));\n-    }\n-    let visit_ty: @fn(&Ty, ((), vt<()>)) =\n-        |a,b| v_ty(v.visit_ty, a, b);\n-    fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, (e, v): ((), vt<()>)) {\n-        f(sf);\n-        visit_struct_field(sf, (e, v));\n-    }\n-    return mk_vt(@Visitor {\n-        visit_mod: |a,b,c,d|v_mod(v.visit_mod, a, b, c, d),\n-        visit_view_item: |a,b| v_view_item(v.visit_view_item, a, b),\n-        visit_foreign_item:\n-            |a,b|v_foreign_item(v.visit_foreign_item, a, b),\n-        visit_item: |a,b|v_item(v.visit_item, a, b),\n-        visit_local: |a,b|v_local(v.visit_local, a, b),\n-        visit_block: |a,b|v_block(v.visit_block, a, b),\n-        visit_stmt: |a,b|v_stmt(v.visit_stmt, a, b),\n-        visit_arm: |a,b|v_arm(v.visit_arm, a, b),\n-        visit_pat: |a,b|v_pat(v.visit_pat, a, b),\n-        visit_decl: |a,b|v_decl(v.visit_decl, a, b),\n-        visit_expr: |a,b|v_expr(v.visit_expr, a, b),\n-        visit_expr_post: |a,b| v_expr_post(v.visit_expr_post, a, b),\n-        visit_ty: visit_ty,\n-        visit_generics: |a,b|\n-            v_generics(v.visit_generics, a, b),\n-        visit_fn: |a,b,c,d,e,f|\n-            v_fn(v.visit_fn, a, b, c, d, e, f),\n-        visit_ty_method: |a,b|\n-            v_ty_method(v.visit_ty_method, a, b),\n-        visit_trait_method: |a,b|\n-            v_trait_method(v.visit_trait_method, a, b),\n-        visit_struct_def: |a,b,c,d,e|\n-            v_struct_def(v.visit_struct_def, a, b, c, d, e),\n-        visit_struct_field: |a,b|\n-            v_struct_field(v.visit_struct_field, a, b),\n-    });\n-}"}, {"sha": "fec3b88aab411a6056a8d358c8207f3d602a6c0f", "filename": "src/libsyntax/syntax.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8cbf41064869f0e99137d64cc236831c565247c/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cbf41064869f0e99137d64cc236831c565247c/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=f8cbf41064869f0e99137d64cc236831c565247c", "patch": "@@ -43,7 +43,6 @@ pub mod ast_util;\n pub mod ast_map;\n pub mod visit;\n pub mod fold;\n-pub mod oldvisit;\n \n \n pub mod parse;"}]}