{"sha": "a9587b8fcd3e436cf2e4a25997e6eecc4608235b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NTg3YjhmY2QzZTQzNmNmMmU0YTI1OTk3ZTZlZWNjNDYwODIzNWI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-30T00:55:46Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-02-01T03:35:57Z"}, "message": "core: Remove transitional code", "tree": {"sha": "601bff732cd4168b64d80e6e83df3cba622d0019", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/601bff732cd4168b64d80e6e83df3cba622d0019"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9587b8fcd3e436cf2e4a25997e6eecc4608235b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9587b8fcd3e436cf2e4a25997e6eecc4608235b", "html_url": "https://github.com/rust-lang/rust/commit/a9587b8fcd3e436cf2e4a25997e6eecc4608235b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a71d0043934371309ba2b7b23b67552c48a41b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/a71d0043934371309ba2b7b23b67552c48a41b25", "html_url": "https://github.com/rust-lang/rust/commit/a71d0043934371309ba2b7b23b67552c48a41b25"}], "stats": {"total": 1052, "additions": 0, "deletions": 1052}, "files": [{"sha": "0910975e481a62b144ba032ae6a722f5e08483a4", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=a9587b8fcd3e436cf2e4a25997e6eecc4608235b", "patch": "@@ -499,12 +499,6 @@ pub mod rt {\n \n     pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n \n-    #[cfg(stage0)]\n-    pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     pub struct Conv {\n         flags: u32,\n         width: Count,"}, {"sha": "2dde9a9508b2940523e012c73a54dfad3c5e452f", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=a9587b8fcd3e436cf2e4a25997e6eecc4608235b", "patch": "@@ -142,10 +142,6 @@ pub fn BufferHeader() -> BufferHeader {\n \n // This is for protocols to associate extra data to thread around.\n #[doc(hidden)]\n-#[cfg(stage0)]\n-#[cfg(stage1)]\n-type Buffer<T> = { header: BufferHeader, data: T };\n-#[cfg(stage2)]\n pub struct Buffer<T> {\n     header: BufferHeader,\n     data: T,\n@@ -207,14 +203,6 @@ impl PacketHeader {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub struct Packet<T: Owned> {\n-    header: PacketHeader,\n-    mut payload: Option<T>,\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct Packet<T> {\n     header: PacketHeader,\n     mut payload: Option<T>,\n@@ -223,16 +211,12 @@ pub struct Packet<T> {\n #[doc(hidden)]\n pub trait HasBuffer {\n     fn set_buffer(b: *libc::c_void);\n-    // FIXME #4421 remove after snapshot\n-    fn set_buffer_(b: *libc::c_void);\n }\n \n impl<T: Owned> Packet<T>: HasBuffer {\n     fn set_buffer(b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n-    // FIXME #4421 remove after snapshot\n-    fn set_buffer_(b: *libc::c_void) { self.set_buffer(b) }\n }\n \n #[doc(hidden)]\n@@ -243,38 +227,6 @@ pub fn mk_packet<T: Owned>() -> Packet<T> {\n     }\n }\n #[doc(hidden)]\n-#[cfg(stage0)]\n-fn unibuffer<T: Owned>() -> ~Buffer<Packet<T>> {\n-    let b = ~{\n-        header: BufferHeader(),\n-        data: Packet {\n-            header: PacketHeader(),\n-            payload: None,\n-        }\n-    };\n-\n-    unsafe {\n-        b.data.header.buffer = reinterpret_cast(&b);\n-    }\n-    move b\n-}\n-#[cfg(stage1)]\n-fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n-    let b = ~{\n-        header: BufferHeader(),\n-        data: Packet {\n-            header: PacketHeader(),\n-            payload: None,\n-        }\n-    };\n-\n-    unsafe {\n-        b.data.header.buffer = reinterpret_cast(&b);\n-    }\n-    move b\n-}\n-#[doc(hidden)]\n-#[cfg(stage2)]\n fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     let b = ~Buffer {\n         header: BufferHeader(),\n@@ -291,17 +243,6 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn packet<T: Owned>() -> *Packet<T> {\n-    let b = unibuffer();\n-    let p = ptr::addr_of(&(b.data));\n-    // We'll take over memory management from here.\n-    unsafe { forget(move b) }\n-    p\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn packet<T>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(&(b.data));\n@@ -412,42 +353,11 @@ fn swap_state_rel(dst: &mut State, src: State) -> State {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub unsafe fn get_buffer<T: Owned>(p: *PacketHeader) -> ~Buffer<T> {\n-    transmute((*p).buf_header())\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub unsafe fn get_buffer<T>(p: *PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n // This could probably be done with SharedMutableState to avoid move_it!().\n-#[cfg(stage0)]\n-struct BufferResource<T: Owned> {\n-    buffer: ~Buffer<T>,\n-\n-    drop {\n-        unsafe {\n-            let b = move_it!(self.buffer);\n-            //let p = ptr::addr_of(*b);\n-            //error!(\"drop %?\", p);\n-            let old_count = atomic_sub_rel(&mut b.header.ref_count, 1);\n-            //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n-            if old_count == 1 {\n-                // The new count is 0.\n-\n-                // go go gadget drop glue\n-            }\n-            else {\n-                forget(move b)\n-            }\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n struct BufferResource<T> {\n     buffer: ~Buffer<T>,\n \n@@ -470,19 +380,6 @@ struct BufferResource<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-fn BufferResource<T: Owned>(b: ~Buffer<T>) -> BufferResource<T> {\n-    //let p = ptr::addr_of(*b);\n-    //error!(\"take %?\", p);\n-    atomic_add_acq(&mut b.header.ref_count, 1);\n-\n-    BufferResource {\n-        // tjc: ????\n-        buffer: move b\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::addr_of(*b);\n     //error!(\"take %?\", p);\n@@ -495,51 +392,6 @@ fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn send<T: Owned, Tbuffer: Owned>(p: SendPacketBuffered<T, Tbuffer>,\n-                                    payload: T) -> bool {\n-    let header = p.header();\n-    let p_ = p.unwrap();\n-    let p = unsafe { &*p_ };\n-    assert ptr::addr_of(&(p.header)) == header;\n-    assert p.payload.is_none();\n-    p.payload = move Some(move payload);\n-    let old_state = swap_state_rel(&mut p.header.state, Full);\n-    match old_state {\n-        Empty => {\n-            // Yay, fastpath.\n-\n-            // The receiver will eventually clean this up.\n-            //unsafe { forget(p); }\n-            return true;\n-        }\n-        Full => fail ~\"duplicate send\",\n-        Blocked => {\n-            debug!(\"waking up task for %?\", p_);\n-            let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n-            if !old_task.is_null() {\n-                unsafe {\n-                    rustrt::task_signal_event(\n-                        old_task,\n-                        ptr::addr_of(&(p.header)) as *libc::c_void);\n-                    rustrt::rust_task_deref(old_task);\n-                }\n-            }\n-\n-            // The receiver will eventually clean this up.\n-            //unsafe { forget(p); }\n-            return true;\n-        }\n-        Terminated => {\n-            // The receiver will never receive this. Rely on drop_glue\n-            // to clean everything up.\n-            return false;\n-        }\n-    }\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n@@ -925,44 +777,13 @@ pub fn select<T: Owned, Tb: Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n message.\n \n */\n-#[cfg(stage0)]\n-pub type SendPacket<T: Owned> = SendPacketBuffered<T, Packet<T>>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type SendPacket<T> = SendPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn SendPacket<T: Owned>(p: *Packet<T>) -> SendPacket<T> {\n-    SendPacketBuffered(p)\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn SendPacket<T>(p: *Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n-#[cfg(stage0)]\n-pub struct SendPacketBuffered<T: Owned, Tbuffer: Owned> {\n-    mut p: Option<*Packet<T>>,\n-    mut buffer: Option<BufferResource<Tbuffer>>,\n-    drop {\n-        //if self.p != none {\n-        //    debug!(\"drop send %?\", option::get(self.p));\n-        //}\n-        if self.p != None {\n-            let mut p = None;\n-            p <-> self.p;\n-            sender_terminate(option::unwrap(move p))\n-        }\n-        //unsafe { error!(\"send_drop: %?\",\n-        //                if self.buffer == none {\n-        //                    \"none\"\n-        //                } else { \"some\" }); }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct SendPacketBuffered<T, Tbuffer> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n@@ -985,20 +806,6 @@ impl<T:Owned,Tbuffer:Owned> SendPacketBuffered<T,Tbuffer> : ::ops::Drop {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn SendPacketBuffered<T: Owned, Tbuffer: Owned>(p: *Packet<T>)\n-    -> SendPacketBuffered<T, Tbuffer> {\n-        //debug!(\"take send %?\", p);\n-    SendPacketBuffered {\n-        p: Some(p),\n-        buffer: unsafe {\n-            Some(BufferResource(\n-                get_buffer(ptr::addr_of(&((*p).header)))))\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n     -> SendPacketBuffered<T, Tbuffer> {\n         //debug!(\"take send %?\", p);\n@@ -1011,35 +818,6 @@ pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T:Owned,Tbuffer:Owned> SendPacketBuffered<T,Tbuffer> {\n-    fn unwrap() -> *Packet<T> {\n-        let mut p = None;\n-        p <-> self.p;\n-        option::unwrap(move p)\n-    }\n-\n-    pure fn header() -> *PacketHeader {\n-        match self.p {\n-          Some(packet) => unsafe {\n-            let packet = &*packet;\n-            let header = ptr::addr_of(&(packet.header));\n-            //forget(packet);\n-            header\n-          },\n-          None => fail ~\"packet already consumed\"\n-        }\n-    }\n-\n-    fn reuse_buffer() -> BufferResource<Tbuffer> {\n-        //error!(\"send reuse_buffer\");\n-        let mut tmp = None;\n-        tmp <-> self.buffer;\n-        option::unwrap(move tmp)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n@@ -1069,45 +847,12 @@ impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n \n /// Represents the receive end of a pipe. It can receive exactly one\n /// message.\n-#[cfg(stage0)]\n-pub type RecvPacket<T: Owned> = RecvPacketBuffered<T, Packet<T>>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type RecvPacket<T> = RecvPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn RecvPacket<T: Owned>(p: *Packet<T>) -> RecvPacket<T> {\n-    RecvPacketBuffered(p)\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn RecvPacket<T>(p: *Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n-\n-#[cfg(stage0)]\n-pub struct RecvPacketBuffered<T: Owned, Tbuffer: Owned> {\n-    mut p: Option<*Packet<T>>,\n-    mut buffer: Option<BufferResource<Tbuffer>>,\n-    drop {\n-        //if self.p != none {\n-        //    debug!(\"drop recv %?\", option::get(self.p));\n-        //}\n-        if self.p != None {\n-            let mut p = None;\n-            p <-> self.p;\n-            receiver_terminate(option::unwrap(move p))\n-        }\n-        //unsafe { error!(\"recv_drop: %?\",\n-        //                if self.buffer == none {\n-        //                    \"none\"\n-        //                } else { \"some\" }); }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct RecvPacketBuffered<T, Tbuffer> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n@@ -1159,20 +904,6 @@ impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> : Selectable {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn RecvPacketBuffered<T: Owned, Tbuffer: Owned>(p: *Packet<T>)\n-    -> RecvPacketBuffered<T, Tbuffer> {\n-    //debug!(\"take recv %?\", p);\n-    RecvPacketBuffered {\n-        p: Some(p),\n-        buffer: unsafe {\n-            Some(BufferResource(\n-                get_buffer(ptr::addr_of(&((*p).header)))))\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n     -> RecvPacketBuffered<T,Tbuffer> {\n     //debug!(\"take recv %?\", p);\n@@ -1186,14 +917,6 @@ pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn entangle<T: Owned>() -> (SendPacket<T>, RecvPacket<T>) {\n-    let p = packet();\n-    (SendPacket(p), RecvPacket(p))\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn entangle<T>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();\n     (SendPacket(p), RecvPacket(p))\n@@ -1289,47 +1012,21 @@ pub trait Peekable<T> {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-struct Chan_<T:Owned> {\n-    mut endp: Option<streamp::client::Open<T>>\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n struct Chan_<T> {\n     mut endp: Option<streamp::client::Open<T>>\n }\n \n /// An endpoint that can send many messages.\n-#[cfg(stage0)]\n-pub enum Chan<T:Owned> {\n-    Chan_(Chan_<T>)\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub enum Chan<T> {\n     Chan_(Chan_<T>)\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-struct Port_<T:Owned> {\n-    mut endp: Option<streamp::server::Open<T>>,\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n struct Port_<T> {\n     mut endp: Option<streamp::server::Open<T>>,\n }\n \n /// An endpoint that can receive many messages.\n-#[cfg(stage0)]\n-pub enum Port<T:Owned> {\n-    Port_(Port_<T>)\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub enum Port<T> {\n     Port_(Port_<T>)\n }\n@@ -1418,12 +1115,6 @@ impl<T: Owned> Port<T>: Selectable {\n }\n \n /// Treat many ports as one.\n-#[cfg(stage0)]\n-pub struct PortSet<T: Owned> {\n-    mut ports: ~[pipes::Port<T>],\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct PortSet<T> {\n     mut ports: ~[pipes::Port<T>],\n }\n@@ -1489,10 +1180,6 @@ impl<T: Owned> PortSet<T> : Peekable<T> {\n }\n \n /// A channel that can be shared between many senders.\n-#[cfg(stage0)]\n-pub type SharedChan<T: Owned> = private::Exclusive<Chan<T>>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type SharedChan<T> = private::Exclusive<Chan<T>>;\n \n impl<T: Owned> SharedChan<T>: GenericChan<T> {\n@@ -1561,16 +1248,8 @@ proto! oneshot (\n )\n \n /// The send end of a oneshot pipe.\n-#[cfg(stage0)]\n-pub type ChanOne<T: Owned> = oneshot::client::Oneshot<T>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type ChanOne<T> = oneshot::client::Oneshot<T>;\n /// The receive end of a oneshot pipe.\n-#[cfg(stage0)]\n-pub type PortOne<T: Owned> = oneshot::server::Oneshot<T>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type PortOne<T> = oneshot::server::Oneshot<T>;\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair."}, {"sha": "dcbb7067670443061057c6d886d6199bf36607e1", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 0, "deletions": 428, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=a9587b8fcd3e436cf2e4a25997e6eecc4608235b", "patch": "@@ -75,434 +75,6 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V> {\n }\n \n /// Abstract type-directed pointer-movement using the MovePtr trait\n-#[cfg(stage0)]\n-impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n-    fn visit_bot() -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_bot() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_nil() -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_nil() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_bool() -> bool {\n-        self.align_to::<bool>();\n-        if ! self.inner.visit_bool() { return false; }\n-        self.bump_past::<bool>();\n-        true\n-    }\n-\n-    fn visit_int() -> bool {\n-        self.align_to::<int>();\n-        if ! self.inner.visit_int() { return false; }\n-        self.bump_past::<int>();\n-        true\n-    }\n-\n-    fn visit_i8() -> bool {\n-        self.align_to::<i8>();\n-        if ! self.inner.visit_i8() { return false; }\n-        self.bump_past::<i8>();\n-        true\n-    }\n-\n-    fn visit_i16() -> bool {\n-        self.align_to::<i16>();\n-        if ! self.inner.visit_i16() { return false; }\n-        self.bump_past::<i16>();\n-        true\n-    }\n-\n-    fn visit_i32() -> bool {\n-        self.align_to::<i32>();\n-        if ! self.inner.visit_i32() { return false; }\n-        self.bump_past::<i32>();\n-        true\n-    }\n-\n-    fn visit_i64() -> bool {\n-        self.align_to::<i64>();\n-        if ! self.inner.visit_i64() { return false; }\n-        self.bump_past::<i64>();\n-        true\n-    }\n-\n-    fn visit_uint() -> bool {\n-        self.align_to::<uint>();\n-        if ! self.inner.visit_uint() { return false; }\n-        self.bump_past::<uint>();\n-        true\n-    }\n-\n-    fn visit_u8() -> bool {\n-        self.align_to::<u8>();\n-        if ! self.inner.visit_u8() { return false; }\n-        self.bump_past::<u8>();\n-        true\n-    }\n-\n-    fn visit_u16() -> bool {\n-        self.align_to::<u16>();\n-        if ! self.inner.visit_u16() { return false; }\n-        self.bump_past::<u16>();\n-        true\n-    }\n-\n-    fn visit_u32() -> bool {\n-        self.align_to::<u32>();\n-        if ! self.inner.visit_u32() { return false; }\n-        self.bump_past::<u32>();\n-        true\n-    }\n-\n-    fn visit_u64() -> bool {\n-        self.align_to::<u64>();\n-        if ! self.inner.visit_u64() { return false; }\n-        self.bump_past::<u64>();\n-        true\n-    }\n-\n-    fn visit_float() -> bool {\n-        self.align_to::<float>();\n-        if ! self.inner.visit_float() { return false; }\n-        self.bump_past::<float>();\n-        true\n-    }\n-\n-    fn visit_f32() -> bool {\n-        self.align_to::<f32>();\n-        if ! self.inner.visit_f32() { return false; }\n-        self.bump_past::<f32>();\n-        true\n-    }\n-\n-    fn visit_f64() -> bool {\n-        self.align_to::<f64>();\n-        if ! self.inner.visit_f64() { return false; }\n-        self.bump_past::<f64>();\n-        true\n-    }\n-\n-    fn visit_char() -> bool {\n-        self.align_to::<char>();\n-        if ! self.inner.visit_char() { return false; }\n-        self.bump_past::<char>();\n-        true\n-    }\n-\n-    fn visit_str() -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_str() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_box() -> bool {\n-        self.align_to::<@str>();\n-        if ! self.inner.visit_estr_box() { return false; }\n-        self.bump_past::<@str>();\n-        true\n-    }\n-\n-    fn visit_estr_uniq() -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_estr_uniq() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_slice() -> bool {\n-        self.align_to::<&static/str>();\n-        if ! self.inner.visit_estr_slice() { return false; }\n-        self.bump_past::<&static/str>();\n-        true\n-    }\n-\n-    fn visit_estr_fixed(n: uint,\n-                        sz: uint,\n-                        align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_box(mtbl, inner) { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n-    fn visit_ptr(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n-        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n-        true\n-    }\n-\n-    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&static/u8>();\n-        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&static/u8>();\n-        true\n-    }\n-\n-    fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<vec::UnboxedVecRepr>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_vec(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@[u8]>();\n-        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n-        self.bump_past::<@[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&static/[u8]>();\n-        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&static/[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_fixed(n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_enter_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_rec_field(i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_class(n_fields: uint, sz: uint, align: uint)\n-                      -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_class(n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(i: uint, name: &str,\n-                         mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_class(n_fields: uint, sz: uint, align: uint)\n-                      -> bool {\n-        if ! self.inner.visit_leave_class(n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_tup_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn(purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            return false\n-        }\n-        true\n-    }\n-\n-    fn visit_fn_input(i: uint, mode: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_fn_output(retstyle: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn(purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum(n_variants: uint, sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        self.inner.push_ptr();\n-        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_enum_variant_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        self.inner.pop_ptr();\n-        true\n-    }\n-\n-    fn visit_leave_enum(n_variants: uint, sz: uint, align: uint)\n-                     -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, sz, align) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_trait() -> bool {\n-        self.align_to::<TyVisitor>();\n-        if ! self.inner.visit_trait() { return false; }\n-        self.bump_past::<TyVisitor>();\n-        true\n-    }\n-\n-    fn visit_var() -> bool {\n-        if ! self.inner.visit_var() { return false; }\n-        true\n-    }\n-\n-    fn visit_var_integral() -> bool {\n-        if ! self.inner.visit_var_integral() { return false; }\n-        true\n-    }\n-\n-    fn visit_param(i: uint) -> bool {\n-        if ! self.inner.visit_param(i) { return false; }\n-        true\n-    }\n-\n-    fn visit_self() -> bool {\n-        self.align_to::<&static/u8>();\n-        if ! self.inner.visit_self() { return false; }\n-        self.align_to::<&static/u8>();\n-        true\n-    }\n-\n-    fn visit_type() -> bool {\n-        if ! self.inner.visit_type() { return false; }\n-        true\n-    }\n-\n-    fn visit_opaque_box() -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_opaque_box() { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_constr(inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_constr(inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_closure_ptr(ck: uint) -> bool {\n-        self.align_to::<fn@()>();\n-        if ! self.inner.visit_closure_ptr(ck) { return false; }\n-        self.bump_past::<fn@()>();\n-        true\n-    }\n-}\n-\n-/// Abstract type-directed pointer-movement using the MovePtr trait\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n     fn visit_bot(&self) -> bool {\n         self.align_to::<()>();"}, {"sha": "cce5cac8683e0bdd0cee49305b4aa39b78d683c7", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9587b8fcd3e436cf2e4a25997e6eecc4608235b/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=a9587b8fcd3e436cf2e4a25997e6eecc4608235b", "patch": "@@ -265,303 +265,6 @@ impl ReprVisitor {\n \n }\n \n-#[cfg(stage0)]\n-impl ReprVisitor : TyVisitor {\n-    fn visit_bot() -> bool {\n-        self.writer.write_str(\"!\");\n-        true\n-    }\n-    fn visit_nil() -> bool { self.write::<()>() }\n-    fn visit_bool() -> bool { self.write::<bool>() }\n-    fn visit_int() -> bool { self.write::<int>() }\n-    fn visit_i8() -> bool { self.write::<i8>() }\n-    fn visit_i16() -> bool { self.write::<i16>() }\n-    fn visit_i32() -> bool { self.write::<i32>()  }\n-    fn visit_i64() -> bool { self.write::<i64>() }\n-\n-    fn visit_uint() -> bool { self.write::<uint>() }\n-    fn visit_u8() -> bool { self.write::<u8>() }\n-    fn visit_u16() -> bool { self.write::<u16>() }\n-    fn visit_u32() -> bool { self.write::<u32>() }\n-    fn visit_u64() -> bool { self.write::<u64>() }\n-\n-    fn visit_float() -> bool { self.write::<float>() }\n-    fn visit_f32() -> bool { self.write::<f32>() }\n-    fn visit_f64() -> bool { self.write::<f64>() }\n-\n-    fn visit_char() -> bool {\n-        do self.get::<char> |&ch| {\n-            self.writer.write_char('\\'');\n-            self.writer.write_escaped_char(ch);\n-            self.writer.write_char('\\'');\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_str() -> bool { fail; }\n-\n-    fn visit_estr_box() -> bool {\n-        do self.get::<@str> |s| {\n-            self.writer.write_char('@');\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-    fn visit_estr_uniq() -> bool {\n-        do self.get::<~str> |s| {\n-            self.writer.write_char('~');\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-    fn visit_estr_slice() -> bool {\n-        do self.get::<&str> |s| {\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_estr_fixed(_n: uint, _sz: uint,\n-                        _align: uint) -> bool { fail; }\n-\n-    fn visit_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('@');\n-        self.write_mut_qualifier(mtbl);\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, inner);\n-        }\n-    }\n-\n-    fn visit_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('~');\n-        self.write_mut_qualifier(mtbl);\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, inner);\n-        }\n-    }\n-\n-    fn visit_ptr(_mtbl: uint, _inner: *TyDesc) -> bool {\n-        do self.get::<*c_void> |p| {\n-            self.writer.write_str(fmt!(\"(0x%x as *())\",\n-                                       *p as uint));\n-        }\n-    }\n-\n-    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('&');\n-        self.write_mut_qualifier(mtbl);\n-        do self.get::<*c_void> |p| {\n-            self.visit_ptr_inner(*p, inner);\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_vec(_mtbl: uint, _inner: *TyDesc) -> bool { fail; }\n-\n-\n-    fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<vec::UnboxedVecRepr> |b| {\n-            self.write_unboxed_vec_repr(mtbl, b, inner);\n-        }\n-    }\n-\n-    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&VecRepr> |b| {\n-            self.writer.write_char('@');\n-            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n-        }\n-    }\n-\n-    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&VecRepr> |b| {\n-            self.writer.write_char('~');\n-            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n-        }\n-    }\n-\n-    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<SliceRepr> |s| {\n-            self.writer.write_char('&');\n-            self.write_vec_range(mtbl, s.data, s.len, inner);\n-        }\n-    }\n-\n-    fn visit_evec_fixed(_n: uint, sz: uint, _align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<u8> |b| {\n-            self.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n-        }\n-    }\n-\n-    fn visit_enter_rec(_n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('{');\n-        true\n-    }\n-\n-    fn visit_rec_field(i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        self.writer.write_str(name);\n-        self.writer.write_str(\": \");\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_rec(_n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('}');\n-        true\n-    }\n-\n-    fn visit_enter_class(_n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('{');\n-        true\n-    }\n-    fn visit_class_field(i: uint, name: &str,\n-                         mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        self.writer.write_str(name);\n-        self.writer.write_str(\": \");\n-        self.visit_inner(inner);\n-        true\n-    }\n-    fn visit_leave_class(_n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('}');\n-        true\n-    }\n-\n-    fn visit_enter_tup(_n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('(');\n-        true\n-    }\n-    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-    fn visit_leave_tup(_n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char(')');\n-        true\n-    }\n-\n-    fn visit_enter_enum(n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool {\n-        if n_variants == 1 {\n-            self.var_stk.push(Degenerate)\n-        } else {\n-            self.var_stk.push(TagMatch)\n-        }\n-        true\n-    }\n-    fn visit_enter_enum_variant(_variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        let mut write = false;\n-        match self.var_stk.pop() {\n-            Degenerate => {\n-                write = true;\n-                self.var_stk.push(Degenerate);\n-            }\n-            TagMatch | TagMismatch => {\n-                do self.get::<int>() |t| {\n-                    if disr_val == *t {\n-                        write = true;\n-                        self.var_stk.push(TagMatch);\n-                    } else {\n-                        self.var_stk.push(TagMismatch);\n-                    }\n-                };\n-                self.bump_past::<int>();\n-            }\n-        }\n-\n-        if write {\n-            self.writer.write_str(name);\n-            if n_fields > 0 {\n-                self.writer.write_char('(');\n-            }\n-        }\n-        true\n-    }\n-    fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool {\n-        match self.var_stk.last() {\n-            Degenerate | TagMatch => {\n-                if i != 0 {\n-                    self.writer.write_str(\", \");\n-                }\n-                if ! self.visit_inner(inner) {\n-                    return false;\n-                }\n-            }\n-            TagMismatch => ()\n-        }\n-        true\n-    }\n-    fn visit_leave_enum_variant(_variant: uint,\n-                                _disr_val: int,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        match self.var_stk.last() {\n-            Degenerate | TagMatch => {\n-                if n_fields > 0 {\n-                    self.writer.write_char(')');\n-                }\n-            }\n-            TagMismatch => ()\n-        }\n-        true\n-    }\n-    fn visit_leave_enum(_n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool {\n-        self.var_stk.pop();\n-        true\n-    }\n-\n-    fn visit_enter_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(_i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_fn_output(_retstyle: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait() -> bool { true }\n-    fn visit_var() -> bool { true }\n-    fn visit_var_integral() -> bool { true }\n-    fn visit_param(_i: uint) -> bool { true }\n-    fn visit_self() -> bool { true }\n-    fn visit_type() -> bool { true }\n-\n-    fn visit_opaque_box() -> bool {\n-        self.writer.write_char('@');\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, b.header.type_desc);\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_constr(_inner: *TyDesc) -> bool { fail; }\n-\n-    fn visit_closure_ptr(_ck: uint) -> bool { true }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ReprVisitor : TyVisitor {\n     fn visit_bot(&self) -> bool {\n         self.writer.write_str(\"!\");"}]}