{"sha": "a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "node_id": "C_kwDOAAsO6NoAKGE5ODI1NDE3OWIzMTJmM2QwM2M3ZWY1N2M1M2NkYzU5MGZjNWMwYjI", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-11-27T10:32:48Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-11-30T03:19:33Z"}, "message": "Support arbitrary `let` statements in custom mir", "tree": {"sha": "ba920b74605195dadc0700120b297c9207ab5f61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba920b74605195dadc0700120b297c9207ab5f61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "html_url": "https://github.com/rust-lang/rust/commit/a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a98254179b312f3d03c7ef57c53cdc590fc5c0b2/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bddad597feb997a4e5d2cd174a76c3b07a84e4d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bddad597feb997a4e5d2cd174a76c3b07a84e4d6", "html_url": "https://github.com/rust-lang/rust/commit/bddad597feb997a4e5d2cd174a76c3b07a84e4d6"}], "stats": {"total": 193, "additions": 189, "deletions": 4}, "files": [{"sha": "6e3cf974119bf9af7618ad8fb91ecf5133b03392", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 139, "deletions": 4, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/a98254179b312f3d03c7ef57c53cdc590fc5c0b2/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a98254179b312f3d03c7ef57c53cdc590fc5c0b2/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "patch": "@@ -90,10 +90,14 @@ pub macro mir {\n     (\n         $(let $local_decl:ident $(: $local_decl_ty:ty)? ;)*\n \n-        $entry_block:block\n+        {\n+            $($entry:tt)*\n+        }\n \n         $(\n-            $block_name:ident = $block:block\n+            $block_name:ident = {\n+                $($block:tt)*\n+            }\n         )*\n     ) => {{\n         // First, we declare all basic blocks.\n@@ -109,15 +113,146 @@ pub macro mir {\n                 let $local_decl $(: $local_decl_ty)? ;\n             )*\n \n+            ::core::intrinsics::mir::__internal_extract_let!($($entry)*);\n+            $(\n+                ::core::intrinsics::mir::__internal_extract_let!($($block)*);\n+            )*\n+\n             {\n                 // Finally, the contents of the basic blocks\n-                $entry_block;\n+                ::core::intrinsics::mir::__internal_remove_let!({\n+                    {}\n+                    { $($entry)* }\n+                });\n                 $(\n-                    $block;\n+                    ::core::intrinsics::mir::__internal_remove_let!({\n+                        {}\n+                        { $($block)* }\n+                    });\n                 )*\n \n                 RET\n             }\n         }\n     }}\n }\n+\n+/// Helper macro that extracts the `let` declarations out of a bunch of statements.\n+///\n+/// This macro is written using the \"statement muncher\" strategy. Each invocation parses the first\n+/// statement out of the input, does the appropriate thing with it, and then recursively calls the\n+/// same macro on the remainder of the input.\n+#[doc(hidden)]\n+pub macro __internal_extract_let {\n+    // If it's a `let` like statement, keep the `let`\n+    (\n+        let $var:ident $(: $ty:ty)? = $expr:expr; $($rest:tt)*\n+    ) => {\n+        let $var $(: $ty)?;\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n+    // Otherwise, output nothing\n+    (\n+        $stmt:stmt; $($rest:tt)*\n+    ) => {\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n+    (\n+        $expr:expr\n+    ) => {}\n+}\n+\n+/// Helper macro that removes the `let` declarations from a bunch of statements.\n+///\n+/// Because expression position macros cannot expand to statements + expressions, we need to be\n+/// slightly creative here. The general strategy is also statement munching as above, but the output\n+/// of the macro is \"stored\" in the subsequent macro invocation. Easiest understood via example:\n+/// ```text\n+/// invoke!(\n+///     {\n+///         {\n+///             x = 5;\n+///         }\n+///         {\n+///             let d = e;\n+///             Call()\n+///         }\n+///     }\n+/// )\n+/// ```\n+/// becomes\n+/// ```text\n+/// invoke!(\n+///     {\n+///         {\n+///             x = 5;\n+///             d = e;\n+///         }\n+///         {\n+///             Call()\n+///         }\n+///     }\n+/// )\n+/// ```\n+#[doc(hidden)]\n+pub macro __internal_remove_let {\n+    // If it's a `let` like statement, remove the `let`\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                let $var:ident $(: $ty:ty)? = $expr:expr;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $var = $expr;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n+    // Otherwise, keep going\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                $stmt:stmt;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $stmt;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                $expr:expr\n+            }\n+        }\n+    ) => {\n+        {\n+            $($already_parsed)*\n+            $expr\n+        }\n+    },\n+}"}, {"sha": "d8cef6244f4086ed70791f6db8bb16998509f2d2", "filename": "src/test/mir-opt/building/custom/arbitrary_let.arbitrary_let.built.after.mir", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a98254179b312f3d03c7ef57c53cdc590fc5c0b2/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.arbitrary_let.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a98254179b312f3d03c7ef57c53cdc590fc5c0b2/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.arbitrary_let.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.arbitrary_let.built.after.mir?ref=a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "patch": "@@ -0,0 +1,22 @@\n+// MIR for `arbitrary_let` after built\n+\n+fn arbitrary_let(_1: i32) -> i32 {\n+    let mut _0: i32;                     // return place in scope 0 at $DIR/arbitrary_let.rs:+0:29: +0:32\n+    let mut _2: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _3: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _2 = _1;                         // scope 0 at $DIR/arbitrary_let.rs:+0:1: +0:32\n+        goto -> bb2;                     // scope 0 at $DIR/arbitrary_let.rs:+0:1: +0:32\n+    }\n+\n+    bb1: {\n+        _0 = _3;                         // scope 0 at $DIR/arbitrary_let.rs:+0:1: +0:32\n+        return;                          // scope 0 at $DIR/arbitrary_let.rs:+0:1: +0:32\n+    }\n+\n+    bb2: {\n+        _3 = _2;                         // scope 0 at $DIR/arbitrary_let.rs:+0:1: +0:32\n+        goto -> bb1;                     // scope 0 at $DIR/arbitrary_let.rs:+0:1: +0:32\n+    }\n+}"}, {"sha": "776df3151ffd7817186f8b8cefc0a1dd6747495f", "filename": "src/test/mir-opt/building/custom/arbitrary_let.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a98254179b312f3d03c7ef57c53cdc590fc5c0b2/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a98254179b312f3d03c7ef57c53cdc590fc5c0b2/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.rs?ref=a98254179b312f3d03c7ef57c53cdc590fc5c0b2", "patch": "@@ -0,0 +1,28 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+use core::ptr::{addr_of, addr_of_mut};\n+\n+// EMIT_MIR arbitrary_let.arbitrary_let.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn arbitrary_let(x: i32) -> i32 {\n+    mir!(\n+        {\n+            let y = x;\n+            Goto(second)\n+        }\n+        third = {\n+            RET = z;\n+            Return()\n+        }\n+        second = {\n+            let z = y;\n+            Goto(third)\n+        }\n+    )\n+}\n+\n+fn main() {\n+    assert_eq!(arbitrary_let(5), 5);\n+}"}]}