{"sha": "45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZGUwZjkwZDZlODZjYjFmNWExYWE4YzNlNzg1YzA3N2FhMjU5YWI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-03-11T19:57:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-11T19:57:39Z"}, "message": "Rollup merge of #40146 - bjorn3:few-infer-changes, r=pnkfelix\n\nBetter docs of rusty parts of typeck", "tree": {"sha": "3ced2b0fedeb4ee6f038da7017e640dd3c7bb2f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ced2b0fedeb4ee6f038da7017e640dd3c7bb2f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab", "html_url": "https://github.com/rust-lang/rust/commit/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "html_url": "https://github.com/rust-lang/rust/commit/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60"}, {"sha": "90e94d97f2635af1f976a1c6ad2f1296df05c784", "url": "https://api.github.com/repos/rust-lang/rust/commits/90e94d97f2635af1f976a1c6ad2f1296df05c784", "html_url": "https://github.com/rust-lang/rust/commit/90e94d97f2635af1f976a1c6ad2f1296df05c784"}], "stats": {"total": 114, "additions": 63, "deletions": 51}, "files": [{"sha": "68e64b8b7bfc827a03bfffd75abd246f7e2d4569", "filename": "src/librustc/infer/README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab/src%2Flibrustc%2Finfer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab/src%2Flibrustc%2Finfer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2FREADME.md?ref=45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab", "patch": "@@ -152,7 +152,7 @@ course, it depends on the program.\n \n The main case which fails today that I would like to support is:\n \n-```text\n+```rust\n fn foo<T>(x: T, y: T) { ... }\n \n fn bar() {\n@@ -168,6 +168,8 @@ because the type variable `T` is merged with the type variable for\n `X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n flexibility for `T` to later adjust to accommodate `@int`.\n \n+Note: `@` and `@mut` are replaced with `Rc<T>` and `Rc<RefCell<T>>` in current Rust.\n+\n ### What to do when not all bounds are present\n \n In the prior discussion we assumed that A.ub was not top and B.lb was"}, {"sha": "b564faf3d0c24c9500c3a56950e3b9f89ca9f8c5", "filename": "src/librustc/infer/region_inference/README.md", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab/src%2Flibrustc%2Finfer%2Fregion_inference%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab/src%2Flibrustc%2Finfer%2Fregion_inference%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2FREADME.md?ref=45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab", "patch": "@@ -121,17 +121,19 @@ every expression, block, and pattern (patterns are considered to\n \"execute\" by testing the value they are applied to and creating any\n relevant bindings).  So, for example:\n \n-    fn foo(x: isize, y: isize) { // -+\n-    //  +------------+       //  |\n-    //  |      +-----+       //  |\n-    //  |  +-+ +-+ +-+       //  |\n-    //  |  | | | | | |       //  |\n-    //  v  v v v v v v       //  |\n-        let z = x + y;       //  |\n-        ...                  //  |\n-    }                        // -+\n-\n-    fn bar() { ... }\n+```rust\n+fn foo(x: isize, y: isize) { // -+\n+//  +------------+           //  |\n+//  |      +-----+           //  |\n+//  |  +-+ +-+ +-+           //  |\n+//  |  | | | | | |           //  |\n+//  v  v v v v v v           //  |\n+    let z = x + y;           //  |\n+    ...                      //  |\n+}                            // -+\n+\n+fn bar() { ... }\n+```\n \n In this example, there is a region for the fn body block as a whole,\n and then a subregion for the declaration of the local variable.\n@@ -160,28 +162,32 @@ this, we get a lot of spurious errors around nested calls, in\n particular when combined with `&mut` functions. For example, a call\n like this one\n \n-    self.foo(self.bar())\n+```rust\n+self.foo(self.bar())\n+```\n \n where both `foo` and `bar` are `&mut self` functions will always yield\n an error.\n \n Here is a more involved example (which is safe) so we can see what's\n going on:\n \n-    struct Foo { f: usize, g: usize }\n-    ...\n-    fn add(p: &mut usize, v: usize) {\n-        *p += v;\n-    }\n-    ...\n-    fn inc(p: &mut usize) -> usize {\n-        *p += 1; *p\n-    }\n-    fn weird() {\n-        let mut x: Box<Foo> = box Foo { ... };\n-        'a: add(&mut (*x).f,\n-                'b: inc(&mut (*x).f)) // (..)\n-    }\n+```rust\n+struct Foo { f: usize, g: usize }\n+// ...\n+fn add(p: &mut usize, v: usize) {\n+    *p += v;\n+}\n+// ...\n+fn inc(p: &mut usize) -> usize {\n+    *p += 1; *p\n+}\n+fn weird() {\n+    let mut x: Box<Foo> = box Foo { /* ... */ };\n+    'a: add(&mut (*x).f,\n+            'b: inc(&mut (*x).f)) // (..)\n+}\n+```\n \n The important part is the line marked `(..)` which contains a call to\n `add()`. The first argument is a mutable borrow of the field `f`.  The\n@@ -197,16 +203,18 @@ can see that this error is unnecessary. Let's examine the lifetimes\n involved with `'a` in detail. We'll break apart all the steps involved\n in a call expression:\n \n-    'a: {\n-        'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a mut usize = &'a mut (*x).f;\n-        'a_arg3: let a_temp3: usize = {\n-            let b_temp1: ... = inc;\n-            let b_temp2: &'b = &'b mut (*x).f;\n-            'b_call: b_temp1(b_temp2)\n-        };\n-        'a_call: a_temp1(a_temp2, a_temp3) // (**)\n-    }\n+```rust\n+'a: {\n+    'a_arg1: let a_temp1: ... = add;\n+    'a_arg2: let a_temp2: &'a mut usize = &'a mut (*x).f;\n+    'a_arg3: let a_temp3: usize = {\n+        let b_temp1: ... = inc;\n+        let b_temp2: &'b = &'b mut (*x).f;\n+        'b_call: b_temp1(b_temp2)\n+    };\n+    'a_call: a_temp1(a_temp2, a_temp3) // (**)\n+}\n+```\n \n Here we see that the lifetime `'a` includes a number of substatements.\n In particular, there is this lifetime I've called `'a_call` that\n@@ -225,19 +233,21 @@ it will not be *dereferenced* during the evaluation of the second\n argument, it can still be *invalidated* by that evaluation. Consider\n this similar but unsound example:\n \n-    struct Foo { f: usize, g: usize }\n-    ...\n-    fn add(p: &mut usize, v: usize) {\n-        *p += v;\n-    }\n-    ...\n-    fn consume(x: Box<Foo>) -> usize {\n-        x.f + x.g\n-    }\n-    fn weird() {\n-        let mut x: Box<Foo> = box Foo { ... };\n-        'a: add(&mut (*x).f, consume(x)) // (..)\n-    }\n+```rust\n+struct Foo { f: usize, g: usize }\n+// ...\n+fn add(p: &mut usize, v: usize) {\n+    *p += v;\n+}\n+// ...\n+fn consume(x: Box<Foo>) -> usize {\n+    x.f + x.g\n+}\n+fn weird() {\n+    let mut x: Box<Foo> = box Foo { ... };\n+    'a: add(&mut (*x).f, consume(x)) // (..)\n+}\n+```\n \n In this case, the second argument to `add` actually consumes `x`, thus\n invalidating the first argument."}, {"sha": "a67049f72852bd99b81ee062c1fed836c875e842", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=45de0f90d6e86cb1f5a1aa8c3e785c077aa259ab", "patch": "@@ -91,7 +91,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         };\n \n         if output_template.is_empty() {\n-            bug!(\"empty string provided as RUST_REGION_GRAPH\");\n+            panic!(\"empty string provided as RUST_REGION_GRAPH\");\n         }\n \n         if output_template.contains('%') {"}]}