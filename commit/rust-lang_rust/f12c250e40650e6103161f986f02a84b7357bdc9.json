{"sha": "f12c250e40650e6103161f986f02a84b7357bdc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMmMyNTBlNDA2NTBlNjEwMzE2MWY5ODZmMDJhODRiNzM1N2JkYzk=", "commit": {"author": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-10-04T03:40:21Z"}, "committer": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-11-01T22:16:59Z"}, "message": "Replace CoerceSized trait with DispatchFromDyn\n\nRename `CoerceSized` to `DispatchFromDyn`, and reverse the direction so that, for example, you write\n\n```\nimpl<T: Unsize<U>, U> DispatchFromDyn<*const U> for *const T {}\n```\n\ninstead of\n\n```\nimpl<T: Unsize<U>, U> DispatchFromDyn<*const T> for *const U {}\n```\n\nthis way the trait is really just a subset of `CoerceUnsized`.\n\nThe checks in object_safety.rs are updated for the new trait, and some documentation and method names in there are updated for the new trait name \u2014 e.g. `receiver_is_coercible` is now called `receiver_is_dispatchable`. Since the trait now works in the opposite direction, some code had to updated here for that too.\n\nI did not update the error messages for invalid `CoerceSized` (now `DispatchFromDyn`) implementations, except to find/replace `CoerceSized` with `DispatchFromDyn`. Will ask for suggestions in the PR thread.", "tree": {"sha": "c79c2edee2f4e22e63cd3baef0b0bebd982c103d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c79c2edee2f4e22e63cd3baef0b0bebd982c103d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f12c250e40650e6103161f986f02a84b7357bdc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f12c250e40650e6103161f986f02a84b7357bdc9", "html_url": "https://github.com/rust-lang/rust/commit/f12c250e40650e6103161f986f02a84b7357bdc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f12c250e40650e6103161f986f02a84b7357bdc9/comments", "author": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c29641e067d44c754fbc6a40e463a7e4d45ab31e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c29641e067d44c754fbc6a40e463a7e4d45ab31e", "html_url": "https://github.com/rust-lang/rust/commit/c29641e067d44c754fbc6a40e463a7e4d45ab31e"}], "stats": {"total": 354, "additions": 164, "deletions": 190}, "files": [{"sha": "74354f605e5370d1824dc58d03d0b4266e4ce23a", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -77,7 +77,7 @@ use core::iter::FusedIterator;\n use core::marker::{Unpin, Unsize};\n use core::mem;\n use core::pin::Pin;\n-use core::ops::{CoerceUnsized, CoerceSized, Deref, DerefMut, Generator, GeneratorState};\n+use core::ops::{CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n use core::task::{LocalWaker, Poll};\n \n@@ -696,8 +696,8 @@ impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + Send + 'a> {\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n \n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceSized<Box<T>> for Box<U> {}\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n \n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl<T: Clone> Clone for Box<[T]> {"}, {"sha": "ad6e594c884af9674c7311ffcd0200bac1fd79da", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -86,7 +86,7 @@\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n-#![feature(coerce_sized)]\n+#![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]"}, {"sha": "be452ebb45a3cae2b2ad54c04b2d5c38aa0dd65b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -255,7 +255,7 @@ use core::marker;\n use core::marker::{Unpin, Unsize, PhantomData};\n use core::mem::{self, align_of_val, forget, size_of_val};\n use core::ops::Deref;\n-use core::ops::{CoerceUnsized, CoerceSized};\n+use core::ops::{CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n@@ -297,8 +297,8 @@ impl<T: ?Sized> !marker::Sync for Rc<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n \n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceSized<Rc<T>> for Rc<U> {}\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T> {}\n \n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n@@ -1179,8 +1179,8 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceSized<Weak<T>> for Weak<U> {}\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating any memory."}, {"sha": "d388f76d8e84c1686ff2dd5a5482a5bffdcdce9a", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -25,7 +25,7 @@ use core::cmp::Ordering;\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val};\n use core::ops::Deref;\n-use core::ops::{CoerceUnsized, CoerceSized};\n+use core::ops::{CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::marker::{Unpin, Unsize, PhantomData};\n@@ -214,8 +214,8 @@ unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n \n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceSized<Arc<T>> for Arc<U> {}\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Arc<U>> for Arc<T> {}\n \n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n /// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n@@ -257,8 +257,8 @@ unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> {}\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceSized<Weak<T>> for Weak<U> {}\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Weak<U>> for Weak<T> {}\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {"}, {"sha": "436cd1fc0572837e408407e9d0bb7b310eea92b2", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -10,7 +10,7 @@\n \n //! Exposes the NonZero lang item which provides optimization hints.\n \n-use ops::{CoerceUnsized, CoerceSized};\n+use ops::{CoerceUnsized, DispatchFromDyn};\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n@@ -21,4 +21,4 @@ pub(crate) struct NonZero<T>(pub(crate) T);\n \n impl<T: CoerceUnsized<U>, U> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n \n-impl<T: CoerceUnsized<U>, U: CoerceSized<T>> CoerceSized<NonZero<T>> for NonZero<U> {}\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<NonZero<U>> for NonZero<T> {}"}, {"sha": "edfa6df11aceb6e958273084271ccf87762d20e9", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -202,5 +202,5 @@ pub use self::generator::{Generator, GeneratorState};\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n pub use self::unsize::CoerceUnsized;\n \n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-pub use self::unsize::CoerceSized;\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+pub use self::unsize::DispatchFromDyn;"}, {"sha": "822c80fadde794001c3ffb1ead96f3dd785a506f", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -79,32 +79,32 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n \n \n-/// Pointers to unsized types that can be coerced to a pointer to a sized type,\n-/// as long as pointee is actually a value of that sized type. This is used for\n-/// object safety, to check that a method's receiver type can be coerced from the version\n-///  where `Self = dyn Trait` to the version where `Self = T`, the erased, sized type\n-/// of the underlying object.\n+/// This is used for object safety, to check that a method's receiver type can be dispatched on.\n ///\n-/// `CoerceSized` is implemented for:\n-/// - `&[T]` is `CoerceSized<&[T; N]>` for any `N`\n-/// - `&Trait` is `CoerceSized<&T>` for any `T: Trait`\n-/// - and similarly for `&mut T`, `*const T`, `*mut T`, `Box<T>`, `Rc<T>`, `Arc<T>`\n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-#[cfg_attr(not(stage0), lang = \"coerce_sized\")]\n-pub trait CoerceSized<T> where T: CoerceUnsized<Self> {\n+/// example impl:\n+///\n+/// ```\n+/// impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T>\n+/// where\n+///     T: Unsize<U>,\n+/// {}\n+/// ```\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+#[cfg_attr(not(stage0), lang = \"dispatch_from_dyn\")]\n+pub trait DispatchFromDyn<T> {\n     // Empty.\n }\n \n-// &U -> &T\n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceSized<&'a T> for &'a U {}\n-// &mut U -> &mut T\n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceSized<&'a mut T> for &'a mut U {}\n-// *const U -> *const T\n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceSized<*const T> for *const U {}\n-// *mut U -> *mut T\n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceSized<*mut T> for *mut U {}\n+// &T -> &U\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+// &mut T -> &mut U\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n+// *const T -> *const U\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n+// *mut T -> *mut U\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n "}, {"sha": "68de82d294529e5cefa0d3eae3159a00674849f3", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -91,7 +91,7 @@\n \n use fmt;\n use marker::Sized;\n-use ops::{Deref, DerefMut, CoerceUnsized, CoerceSized};\n+use ops::{Deref, DerefMut, CoerceUnsized, DispatchFromDyn};\n \n #[doc(inline)]\n pub use marker::Unpin;\n@@ -325,10 +325,9 @@ where\n {}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, P, U> CoerceSized<Pin<P>> for Pin<U>\n+impl<'a, P, U> DispatchFromDyn<Pin<U>> for Pin<P>\n where\n-    P: CoerceUnsized<U>,\n-    U: CoerceSized<P>,\n+    P: DispatchFromDyn<U>,\n {}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]"}, {"sha": "62ccf6c865cd96735a92bf30969e5be5de08f815", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -75,7 +75,7 @@\n \n use convert::From;\n use intrinsics;\n-use ops::{CoerceUnsized, CoerceSized};\n+use ops::{CoerceUnsized, DispatchFromDyn};\n use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n@@ -2796,7 +2796,7 @@ impl<T: ?Sized> Copy for Unique<T> { }\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> CoerceSized<Unique<T>> for Unique<U> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> fmt::Pointer for Unique<T> {\n@@ -2954,8 +2954,8 @@ impl<T: ?Sized> Copy for NonNull<T> { }\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n \n-#[unstable(feature = \"coerce_sized\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> CoerceSized<NonNull<T>> for NonNull<U> where T: Unsize<U> { }\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> fmt::Debug for NonNull<T> {"}, {"sha": "cce8081daf28e5b397cd3edb7350e0f1b2309c6b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -271,7 +271,7 @@ language_item_table! {\n     DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n \n     CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n-    CoerceSizedTraitLangItem,    \"coerce_sized\",       coerce_sized_trait,      Target::Trait;\n+    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n \n     AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n     SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;"}, {"sha": "5e7a3043ae73e5be9bb2ecf80024210de6dd0115", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -319,41 +319,42 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             &sig.map_bound(|sig| sig.inputs()[0]),\n         );\n \n-        // until `unsized_locals` is fully implemented, `self: Self` can't be coerced from\n-        // `Self=dyn Trait` to `Self=T`. However, this is already considered object-safe. We allow\n-        // it as a special case here.\n-        // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_coercible` allows\n+        // until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n+        // However, this is already considered object-safe. We allow it as a special case here.\n+        // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n         // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n         if receiver_ty != self.mk_self_type() {\n-            if !self.receiver_is_coercible(method, receiver_ty) {\n+            if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UncoercibleReceiver);\n             }\n         }\n \n         None\n     }\n \n-    /// checks the method's receiver (the `self` argument) can be coerced from\n-    /// a fat pointer, including the trait object vtable, to a thin pointer.\n-    /// e.g. from `Rc<dyn Trait>` to `Rc<T>`, where `T` is the erased type of the underlying object.\n-    /// More formally:\n+    /// checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n+    /// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n+    /// in the following way:\n     /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`\n     /// - require the following bound:\n     ///       forall(T: Trait) {\n-    ///           Receiver[Self => dyn Trait]: CoerceSized<Receiver[Self => T]>\n+    ///           Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n     ///       }\n     ///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n     ///   (substitution notation).\n     ///\n     /// some examples of receiver types and their required obligation\n-    /// - `&'a mut self` requires `&'a mut dyn Trait: CoerceSized<&'a mut T>`\n-    /// - `self: Rc<Self>` requires `Rc<dyn Trait>: CoerceSized<Rc<T>>`\n+    /// - `&'a mut self` requires `&'a mut T: DispatchFromDyn<&'a mut dyn Trait>`\n+    /// - `self: Rc<Self>` requires `Rc<T>: DispatchFromDyn<Rc<dyn Trait>>`\n+    /// - `self: Pin<Box<Self>>` requires `Pin<Box<T>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`\n     ///\n-    /// The only case where the receiver is not coercible, but is still a valid receiver\n+    /// The only case where the receiver is not dispatchable, but is still a valid receiver\n     /// type (just not object-safe), is when there is more than one level of pointer indirection.\n     /// e.g. `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n-    /// is no way, or at least no inexpensive way, to coerce the receiver, because the object that\n-    /// needs to be coerced is behind a pointer.\n+    /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n+    /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n+    /// contained by the trait object, because the object that needs to be coerced is behind\n+    /// a pointer.\n     ///\n     /// In practice, there are issues with the above bound: `where` clauses that apply to `Self`\n     /// would have to apply to `T`, trait object types have a lot of parameters that need to\n@@ -364,37 +365,38 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     ///\n     ///     forall (U: ?Sized) {\n     ///         if (Self: Unsize<U>) {\n-    ///             Receiver[Self => U]: CoerceSized<Receiver>\n+    ///             Receiver: DispatchFromDyn<Receiver[Self => U]>\n     ///         }\n     ///     }\n     ///\n-    /// for `self: &'a mut Self`, this means `&'a mut U: CoerceSized<&'a mut Self>`\n-    /// for `self: Rc<Self>`, this means `Rc<U>: CoerceSized<Rc<Self>>`\n+    /// for `self: &'a mut Self`, this means `&'a mut Self: DispatchFromDyn<&'a mut U>`\n+    /// for `self: Rc<Self>`, this means `Rc<Self>: DispatchFromDyn<Rc<U>>`\n+    /// for `self: Pin<Box<Self>>, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`\n     //\n     // FIXME(mikeyhew) when unsized receivers are implemented as part of unsized rvalues, add this\n     // fallback query: `Receiver: Unsize<Receiver[Self => U]>` to support receivers like\n     // `self: Wrapper<Self>`.\n     #[allow(dead_code)]\n-    fn receiver_is_coercible(\n+    fn receiver_is_dispatchable(\n         self,\n         method: &ty::AssociatedItem,\n         receiver_ty: Ty<'tcx>,\n     ) -> bool {\n-        debug!(\"receiver_is_coercible: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);\n+        debug!(\"receiver_is_dispatchable: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);\n \n         let traits = (self.lang_items().unsize_trait(),\n-                      self.lang_items().coerce_sized_trait());\n-        let (unsize_did, coerce_sized_did) = if let (Some(u), Some(cu)) = traits {\n+                      self.lang_items().dispatch_from_dyn_trait());\n+        let (unsize_did, dispatch_from_dyn_did) = if let (Some(u), Some(cu)) = traits {\n             (u, cu)\n         } else {\n-            debug!(\"receiver_is_coercible: Missing Unsize or CoerceSized traits\");\n+            debug!(\"receiver_is_dispatchable: Missing Unsize or DispatchFromDyn traits\");\n             return false;\n         };\n \n         // use a bogus type parameter to mimick a forall(U) query using u32::MAX for now.\n         // FIXME(mikeyhew) this is a total hack, and we should replace it when real forall queries\n         // are implemented\n-        let target_self_ty: Ty<'tcx> = self.mk_ty_param(\n+        let unsized_self_ty: Ty<'tcx> = self.mk_ty_param(\n             ::std::u32::MAX,\n             Name::intern(\"RustaceansAreAwesome\").as_interned_str(),\n         );\n@@ -405,7 +407,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n             let predicate = ty::TraitRef {\n                 def_id: unsize_did,\n-                substs: self.mk_substs_trait(self.mk_self_type(), &[target_self_ty.into()]),\n+                substs: self.mk_substs_trait(self.mk_self_type(), &[unsized_self_ty.into()]),\n             }.to_predicate();\n \n             let caller_bounds: Vec<Predicate<'tcx>> = param_env.caller_bounds.iter().cloned()\n@@ -419,19 +421,19 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n         let receiver_substs = Substs::for_item(self, method.def_id, |param, _| {\n             if param.index == 0 {\n-                target_self_ty.into()\n+                unsized_self_ty.into()\n             } else {\n                 self.mk_param_from_def(param)\n             }\n         });\n         // the type `Receiver[Self => U]` in the query\n         let unsized_receiver_ty = receiver_ty.subst(self, receiver_substs);\n \n-        // Receiver[Self => U]: CoerceSized<Receiver>\n+        // Receiver: DispatchFromDyn<Receiver[Self => U]>\n         let obligation = {\n             let predicate = ty::TraitRef {\n-                def_id: coerce_sized_did,\n-                substs: self.mk_substs_trait(unsized_receiver_ty, &[receiver_ty.into()]),\n+                def_id: dispatch_from_dyn_did,\n+                substs: self.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n             }.to_predicate();\n \n             Obligation::new(\n@@ -442,7 +444,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         };\n \n         self.infer_ctxt().enter(|ref infcx| {\n-            // the receiver is coercible iff the obligation holds\n+            // the receiver is dispatchable iff the obligation holds\n             infcx.predicate_must_hold(&obligation)\n         })\n     }"}, {"sha": "a01718bc12870e032baca80c6e9b058e604f2db0", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -32,7 +32,8 @@ pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n         .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n         .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n         .check(tcx.lang_items().coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n-        .check(tcx.lang_items().coerce_sized_trait(), visit_implementation_of_coerce_sized);\n+        .check(tcx.lang_items().dispatch_from_dyn_trait(),\n+            visit_implementation_of_dispatch_from_dyn);\n }\n \n struct Checker<'a, 'tcx: 'a> {\n@@ -162,11 +163,14 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn visit_implementation_of_coerce_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n-    debug!(\"visit_implementation_of_coerce_sized: impl_did={:?}\",\n+fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impl_did: DefId,\n+) {\n+    debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\",\n            impl_did);\n     if impl_did.is_local() {\n-        let coerce_sized_trait = tcx.lang_items().coerce_sized_trait().unwrap();\n+        let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n         let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap();\n         let span = tcx.hir.span(impl_node_id);\n@@ -175,12 +179,12 @@ fn visit_implementation_of_coerce_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, i\n         assert!(!source.has_escaping_regions());\n         let target = {\n             let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n-            assert_eq!(trait_ref.def_id, coerce_sized_trait);\n+            assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n \n             trait_ref.substs.type_at(1)\n         };\n \n-        debug!(\"visit_implementation_of_coerce_sized: {:?} -> {:?}\",\n+        debug!(\"visit_implementation_of_dispatch_from_dyn: {:?} -> {:?}\",\n             source,\n             target);\n \n@@ -209,7 +213,7 @@ fn visit_implementation_of_coerce_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, i\n \n                         create_err(\n                             &format!(\n-                                \"the trait `CoerceSized` may only be implemented \\\n+                                \"the trait `DispatchFromDyn` may only be implemented \\\n                                 for a coercion between structures with the same \\\n                                 definition; expected {}, found {}\",\n                                 source_path, target_path,\n@@ -232,9 +236,9 @@ fn visit_implementation_of_coerce_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, i\n                         if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n                             if ok.obligations.is_empty() {\n                                 create_err(\n-                                    \"the trait `CoerceSized` may only be implemented for structs \\\n-                                     containing the field being coerced, `PhantomData` fields, \\\n-                                     and nothing else\"\n+                                    \"the trait `DispatchFromDyn` may only be implemented \\\n+                                     for structs containing the field being coerced, \\\n+                                     `PhantomData` fields, and nothing else\"\n                                 ).note(\n                                     &format!(\n                                         \"extra field `{}` of type `{}` is not allowed\",\n@@ -251,15 +255,15 @@ fn visit_implementation_of_coerce_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, i\n \n                     if coerced_fields.is_empty() {\n                         create_err(\n-                            \"the trait `CoerceSized` may only be implemented \\\n+                            \"the trait `DispatchFromDyn` may only be implemented \\\n                             for a coercion between structures with a single field \\\n                             being coerced, none found\"\n                         ).emit();\n                     } else if coerced_fields.len() > 1 {\n                         create_err(\n-                            \"implementing the `CoerceSized` trait requires multiple coercions\",\n+                            \"implementing the `DispatchFromDyn` trait requires multiple coercions\",\n                         ).note(\n-                            \"the trait `CoerceSized` may only be implemented \\\n+                            \"the trait `DispatchFromDyn` may only be implemented \\\n                                 for a coercion between structures with a single field \\\n                                 being coerced\"\n                         ).note(\n@@ -284,7 +288,7 @@ fn visit_implementation_of_coerce_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, i\n                             let predicate = tcx.predicate_for_trait_def(\n                                 param_env,\n                                 cause.clone(),\n-                                coerce_sized_trait,\n+                                dispatch_from_dyn_trait,\n                                 0,\n                                 field.ty(tcx, substs_a),\n                                 &[field.ty(tcx, substs_b).into()]\n@@ -311,7 +315,7 @@ fn visit_implementation_of_coerce_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, i\n                 }\n                 _ => {\n                     create_err(\n-                        \"the trait `CoerceSsized` may only be implemented \\\n+                        \"the trait `DispatchFromDyn` may only be implemented \\\n                         for a coercion between structures\"\n                     ).emit();\n                 }"}, {"sha": "e53536fc55a2c824dc8d37a294c00a2fb3f85cf7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -3085,75 +3085,58 @@ struct.\n \"##,\n \n E0378: r##\"\n-The `CoerceSized` trait currently can only be implemented for builtin pointer\n-types and structs that are newtype wrappers around them \u2014 that is, the struct\n-must have only one field (except for`PhantomData`), and that field must itself\n-implement `CoerceSized`.\n+The `DispatchFromDyn` trait currently can only be implemented for\n+builtin pointer types and structs that are newtype wrappers around them\n+\u2014 that is, the struct must have only one field (except for`PhantomData`),\n+and that field must itself implement `DispatchFromDyn`.\n \n Examples:\n \n ```\n-#![feature(coerce_sized, unsize)]\n+#![feature(dispatch_from_dyn, unsize)]\n use std::{\n     marker::Unsize,\n-    ops::CoerceSized,\n+    ops::DispatchFromDyn,\n };\n \n struct Ptr<T: ?Sized>(*const T);\n \n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T>\n-where\n-    T: Unsize<U>,\n-{}\n-\n-impl<T: ?Sized, U: ?Sized> CoerceSized<Ptr<T>> for Ptr<U>\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T>\n where\n     T: Unsize<U>,\n {}\n ```\n \n ```\n-#![feature(coerce_unsized, coerce_sized)]\n-use std::ops::{CoerceUnsized, CoerceSized};\n+#![feature(dispatch_from_dyn)]\n+use std::ops::DispatchFromDyn;\n \n struct Wrapper<T> {\n     ptr: T,\n     _phantom: PhantomData<()>,\n }\n \n-impl<T, U> CoerceUnsized<Wrapper<U>> for Wrapper<T>\n-where\n-    T: CoerceUnsized<U>,\n-{}\n-\n-impl<T, U> CoerceSized<Wrapper<T>> for Wrapper<U>\n+impl<T, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T>\n where\n-    T: CoerceUnsized<U>,\n-    U: CoerceSized<T>,\n+    T: DispatchFromDyn<U>,\n {}\n ```\n \n-Example of illegal CoerceSized implementation\n+Example of illegal `DispatchFromDyn` implementation\n (illegal because of extra field)\n \n ```compile-fail,E0378\n-#![feature(coerce_unsized, coerce_sized)]\n-use std::ops::{CoerceUnsized, CoerceSized};\n+#![feature(dispatch_from_dyn)]\n+use std::ops::DispatchFromDyn;\n \n-struct WrapperWithExtraField<T> {\n+struct WrapperExtraField<T> {\n     ptr: T,\n     extra_stuff: i32,\n }\n \n-impl<T, U> CoerceUnsized<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\n-where\n-    T: CoerceUnsized<U>,\n-{}\n-\n-impl<T, U> CoerceSized<WrapperWithExtraField<T>> for WrapperWithExtraField<U>\n+impl<T, U> DispatchFromDyn<WrapperExtraField<U>> for WrapperExtraField<T>\n where\n-    T: CoerceUnsized<U>,\n-    U: CoerceSized<T>,\n+    T: DispatchFromDyn<U>,\n {}\n ```\n \"##,"}, {"sha": "e1663563cec0aef60341cf0fce21a021916b57ff", "filename": "src/test/run-pass/arbitrary_self_types_pointers_and_wrappers.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Ftest%2Frun-pass%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -7,13 +7,12 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(arbitrary_self_types, unsize, coerce_unsized, coerce_sized)]\n+#![feature(arbitrary_self_types, unsize, coerce_unsized, dispatch_from_dyn)]\n #![feature(rustc_attrs)]\n \n use std::{\n-    ops::{Deref, CoerceUnsized, CoerceSized},\n+    ops::{Deref, CoerceUnsized, DispatchFromDyn},\n     marker::Unsize,\n-    fmt::Debug,\n };\n \n struct Ptr<T: ?Sized>(Box<T>);\n@@ -27,7 +26,7 @@ impl<T: ?Sized> Deref for Ptr<T> {\n }\n \n impl<T: Unsize<U> + ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T> {}\n-impl<T: Unsize<U> + ?Sized, U: ?Sized> CoerceSized<Ptr<T>> for Ptr<U> {}\n+impl<T: Unsize<U> + ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T> {}\n \n struct Wrapper<T: ?Sized>(T);\n \n@@ -40,22 +39,20 @@ impl<T: ?Sized> Deref for Wrapper<T> {\n }\n \n impl<T: CoerceUnsized<U>, U> CoerceUnsized<Wrapper<U>> for Wrapper<T> {}\n-impl<T: CoerceUnsized<U>, U: CoerceSized<T>> CoerceSized<Wrapper<T>> for Wrapper<U> {}\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T> {}\n \n \n trait Trait {\n-    // This method can't be called on trait objects, since the receiver would be unsized,\n-    // but should not cause an object safety error\n+    // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n+    // without unsized_locals), but wrappers arond `Self` currently are not.\n+    // FIXME (mikeyhew) uncomment this when unsized rvalues object-safety is implemented\n     // fn wrapper(self: Wrapper<Self>) -> i32;\n     fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32;\n     fn wrapper_ptr(self: Wrapper<Ptr<Self>>) -> i32;\n     fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32;\n }\n \n impl Trait for i32 {\n-    // fn wrapper(self: Wrapper<Self>) -> i32 {\n-    //     *self\n-    // }\n     fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32 {\n         **self\n     }"}, {"sha": "70fb464d426ed35034cb84574b5d1bf68c62fef5", "filename": "src/test/ui/invalid_coerce_sized_impls.stderr", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c29641e067d44c754fbc6a40e463a7e4d45ab31e/src%2Ftest%2Fui%2Finvalid_coerce_sized_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c29641e067d44c754fbc6a40e463a7e4d45ab31e/src%2Ftest%2Fui%2Finvalid_coerce_sized_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid_coerce_sized_impls.stderr?ref=c29641e067d44c754fbc6a40e463a7e4d45ab31e", "patch": "@@ -1,33 +0,0 @@\n-error[E0378]: the trait `CoerceSized` may only be implemented for structs containing the field being coerced, `PhantomData` fields, and nothing else\n-  --> $DIR/invalid_coerce_sized_impls.rs:25:1\n-   |\n-LL | / impl<T, U> CoerceSized<WrapperWithExtraField<T>> for WrapperWithExtraField<U>\n-LL | | where\n-LL | |     T: CoerceUnsized<U>,\n-LL | |     U: CoerceSized<T>,\n-LL | | {} //~^^^^ ERROR [E0378]\n-   | |__^\n-   |\n-   = note: extra field `1` of type `i32` is not allowed\n-\n-error[E0378]: implementing the `CoerceSized` trait requires multiple coercions\n-  --> $DIR/invalid_coerce_sized_impls.rs:39:1\n-   |\n-LL | / impl<T: ?Sized, U: ?Sized> CoerceSized<MultiplePointers<T>> for MultiplePointers<U>\n-LL | | where\n-LL | |     T: Unsize<U>,\n-LL | | {} //~^^^ ERROR [E0378]\n-   | |__^\n-   |\n-   = note: the trait `CoerceSized` may only be implemented for a coercion between structures with a single field being coerced\n-   = note: currently, 2 fields need coercions: ptr1 (*const U to *const T), ptr2 (*const U to *const T)\n-\n-error[E0378]: the trait `CoerceSized` may only be implemented for a coercion between structures with a single field being coerced, none found\n-  --> $DIR/invalid_coerce_sized_impls.rs:51:1\n-   |\n-LL | impl<T: ?Sized, U: ?Sized> CoerceSized<NothingToCoerce<U>> for NothingToCoerce<T> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0378`."}, {"sha": "101e1eb6e3071cbc40da5f7a88fcaea5d531bff2", "filename": "src/test/ui/invalid_dispatch_from_dyn_impls.rs", "status": "renamed", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -8,35 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unsize, coerce_sized, coerce_unsized)]\n+#![feature(unsize, dispatch_from_dyn)]\n \n use std::{\n-    ops::{CoerceSized, CoerceUnsized},\n+    ops::DispatchFromDyn,\n     marker::{Unsize, PhantomData},\n };\n \n struct WrapperWithExtraField<T>(T, i32);\n \n-impl<T, U> CoerceUnsized<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\n+impl<T, U> DispatchFromDyn<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\n where\n-    T: CoerceUnsized<U>,\n-{}\n-\n-impl<T, U> CoerceSized<WrapperWithExtraField<T>> for WrapperWithExtraField<U>\n-where\n-    T: CoerceUnsized<U>,\n-    U: CoerceSized<T>,\n-{} //~^^^^ ERROR [E0378]\n+    T: DispatchFromDyn<U>,\n+{} //~^^^ ERROR [E0378]\n \n \n struct MultiplePointers<T: ?Sized>{\n     ptr1: *const T,\n     ptr2: *const T,\n }\n \n-// No CoerceUnsized impl\n-\n-impl<T: ?Sized, U: ?Sized> CoerceSized<MultiplePointers<T>> for MultiplePointers<U>\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<MultiplePointers<U>> for MultiplePointers<T>\n where\n     T: Unsize<U>,\n {} //~^^^ ERROR [E0378]\n@@ -46,9 +38,7 @@ struct NothingToCoerce<T: ?Sized> {\n     data: PhantomData<T>,\n }\n \n-// No CoerceUnsized impl\n-\n-impl<T: ?Sized, U: ?Sized> CoerceSized<NothingToCoerce<U>> for NothingToCoerce<T> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NothingToCoerce<T>> for NothingToCoerce<U> {}\n //~^ ERROR [E0378]\n \n fn main() {}", "previous_filename": "src/test/ui/invalid_coerce_sized_impls.rs"}, {"sha": "5e394f2fb915288c27af994110ea6c48c95b8628", "filename": "src/test/ui/invalid_dispatch_from_dyn_impls.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f12c250e40650e6103161f986f02a84b7357bdc9/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr?ref=f12c250e40650e6103161f986f02a84b7357bdc9", "patch": "@@ -0,0 +1,32 @@\n+error[E0378]: the trait `DispatchFromDyn` may only be implemented for structs containing the field being coerced, `PhantomData` fields, and nothing else\n+  --> $DIR/invalid_dispatch_from_dyn_impls.rs:20:1\n+   |\n+LL | / impl<T, U> DispatchFromDyn<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\n+LL | | where\n+LL | |     T: DispatchFromDyn<U>,\n+LL | | {} //~^^^ ERROR [E0378]\n+   | |__^\n+   |\n+   = note: extra field `1` of type `i32` is not allowed\n+\n+error[E0378]: implementing the `DispatchFromDyn` trait requires multiple coercions\n+  --> $DIR/invalid_dispatch_from_dyn_impls.rs:31:1\n+   |\n+LL | / impl<T: ?Sized, U: ?Sized> DispatchFromDyn<MultiplePointers<U>> for MultiplePointers<T>\n+LL | | where\n+LL | |     T: Unsize<U>,\n+LL | | {} //~^^^ ERROR [E0378]\n+   | |__^\n+   |\n+   = note: the trait `DispatchFromDyn` may only be implemented for a coercion between structures with a single field being coerced\n+   = note: currently, 2 fields need coercions: ptr1 (*const T to *const U), ptr2 (*const T to *const U)\n+\n+error[E0378]: the trait `DispatchFromDyn` may only be implemented for a coercion between structures with a single field being coerced, none found\n+  --> $DIR/invalid_dispatch_from_dyn_impls.rs:41:1\n+   |\n+LL | impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NothingToCoerce<T>> for NothingToCoerce<U> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0378`."}]}