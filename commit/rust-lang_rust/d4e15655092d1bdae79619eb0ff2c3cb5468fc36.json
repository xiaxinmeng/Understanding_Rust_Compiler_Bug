{"sha": "d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZTE1NjU1MDkyZDFiZGFlNzk2MTllYjBmZjJjM2NiNTQ2OGZjMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-10T08:59:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-10T08:59:15Z"}, "message": "Auto merge of #62441 - RalfJung:place-ptr-normalization, r=oli-obk\n\nMiri: Provide pointer forcing methods for MemPlace and Op\n\nThese are useful when one wants to to a lot of work with some place or operand and not to int-to-ptr casts all the time. In particular, this is needed to fix some test failures in Miri: we need to normalize before starting a visitor that walks a run-time value, so that we can later be sure (during the visitor walk) that we have a proper `Pointer`.\n\nAlso see the Miri side at https://github.com/rust-lang/miri/pull/830.\n\nCc @eddyb @oli-obk", "tree": {"sha": "e21c6d5d7e1f55fc089c569f02d5d4077c9b3d10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e21c6d5d7e1f55fc089c569f02d5d4077c9b3d10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "html_url": "https://github.com/rust-lang/rust/commit/d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0324a2b309cd66cb7bd4a156bd0b84cb136e254f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0324a2b309cd66cb7bd4a156bd0b84cb136e254f", "html_url": "https://github.com/rust-lang/rust/commit/0324a2b309cd66cb7bd4a156bd0b84cb136e254f"}, {"sha": "ac4f6ab2a0ef61af3cd6a1c6966609a0b5f97b34", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4f6ab2a0ef61af3cd6a1c6966609a0b5f97b34", "html_url": "https://github.com/rust-lang/rust/commit/ac4f6ab2a0ef61af3cd6a1c6966609a0b5f97b34"}], "stats": {"total": 237, "additions": 132, "deletions": 105}, "files": [{"sha": "4a59d845b3b42eebf76cf722e7e642d200126f68", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -262,19 +262,6 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n-    /// Returns this pointer's offset from the allocation base, or from NULL (for\n-    /// integer pointers).\n-    #[inline]\n-    pub fn get_ptr_offset(self, cx: &impl HasDataLayout) -> Size {\n-        match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, cx.pointer_size().bytes());\n-                Size::from_bytes(data as u64)\n-            }\n-            Scalar::Ptr(ptr) => ptr.offset,\n-        }\n-    }\n-\n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n         Scalar::Raw { data: b as u128, size: 1 }\n@@ -339,6 +326,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Raw { data: f.to_bits(), size: 8 }\n     }\n \n+    /// This is very rarely the method you want!  You should dispatch on the type\n+    /// and use `force_bits`/`assert_bits`/`force_ptr`/`assert_ptr`.\n+    /// This method only exists for the benefit of low-level memory operations\n+    /// as well as the implementation of the `force_*` methods.\n     #[inline]\n     pub fn to_bits_or_ptr(\n         self,\n@@ -359,6 +350,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    /// Do not call this method!  Use either `assert_bits` or `force_bits`.\n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         match self {\n@@ -372,6 +364,12 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn assert_bits(self, target_size: Size) -> u128 {\n+        self.to_bits(target_size).expect(\"Expected Raw bits but got a Pointer\")\n+    }\n+\n+    /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n     #[inline]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n@@ -381,6 +379,12 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn assert_ptr(self) -> Pointer<Tag> {\n+        self.to_ptr().expect(\"Expected a Pointer but got Raw bits\")\n+    }\n+\n+    /// Do not call this method!  Dispatch based on the type instead.\n     #[inline]\n     pub fn is_bits(self) -> bool {\n         match self {\n@@ -389,6 +393,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    /// Do not call this method!  Dispatch based on the type instead.\n     #[inline]\n     pub fn is_ptr(self) -> bool {\n         match self {\n@@ -536,11 +541,13 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n         }\n     }\n \n+    /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n     #[inline(always)]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         self.not_undef()?.to_ptr()\n     }\n \n+    /// Do not call this method!  Use either `assert_bits` or `force_bits`.\n     #[inline(always)]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         self.not_undef()?.to_bits(target_size)"}, {"sha": "8f3364b1fba19b7420cc50e920bb504e2fb4213c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -109,7 +109,7 @@ fn op_to_const<'tcx>(\n                 // `Immediate` is when we are called from `const_field`, and that `Immediate`\n                 // comes from a constant so it can happen have `Undef`, because the indirect\n                 // memory that was read had undefined bytes.\n-                let mplace = op.to_mem_place();\n+                let mplace = op.assert_mem_place();\n                 let ptr = mplace.ptr.to_ptr().unwrap();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                 ConstValue::ByRef { offset: ptr.offset, align: mplace.align, alloc }\n@@ -661,7 +661,7 @@ pub fn const_eval_raw_provider<'tcx>(\n         |body| eval_body_using_ecx(&mut ecx, cid, body, key.param_env)\n     ).and_then(|place| {\n         Ok(RawConst {\n-            alloc_id: place.to_ptr().expect(\"we allocated this ptr!\").alloc_id,\n+            alloc_id: place.ptr.assert_ptr().alloc_id,\n             ty: place.layout.ty\n         })\n     }).map_err(|error| {"}, {"sha": "3f2a76a77be36b8f6f847482de41871418849830", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -214,10 +214,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             None => Size::from_bytes(self.get(ptr.alloc_id)?.bytes.len() as u64),\n         };\n         self.copy(\n-            ptr.into(),\n-            Align::from_bytes(1).unwrap(), // old_align anyway gets checked below by `deallocate`\n-            new_ptr.into(),\n-            new_align,\n+            ptr,\n+            new_ptr,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n@@ -310,6 +308,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// `Pointer` they need. And even if you already have a `Pointer`, call this method\n     /// to make sure it is sufficiently aligned and not dangling.  Not doing that may\n     /// cause ICEs.\n+    ///\n+    /// Most of the time you should use `check_mplace_access`, but when you just have a pointer,\n+    /// this method is still appropriate.\n     pub fn check_ptr_access(\n         &self,\n         sptr: Scalar<M::PointerTag>,\n@@ -751,39 +752,26 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.get(ptr.alloc_id)?.read_c_str(self, ptr)\n     }\n \n-    /// Performs appropriate bounds checks.\n+    /// Expects the caller to have checked bounds and alignment.\n     pub fn copy(\n         &mut self,\n-        src: Scalar<M::PointerTag>,\n-        src_align: Align,\n-        dest: Scalar<M::PointerTag>,\n-        dest_align: Align,\n+        src: Pointer<M::PointerTag>,\n+        dest: Pointer<M::PointerTag>,\n         size: Size,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n+        self.copy_repeatedly(src, dest, size, 1, nonoverlapping)\n     }\n \n-    /// Performs appropriate bounds checks.\n+    /// Expects the caller to have checked bounds and alignment.\n     pub fn copy_repeatedly(\n         &mut self,\n-        src: Scalar<M::PointerTag>,\n-        src_align: Align,\n-        dest: Scalar<M::PointerTag>,\n-        dest_align: Align,\n+        src: Pointer<M::PointerTag>,\n+        dest: Pointer<M::PointerTag>,\n         size: Size,\n         length: u64,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        // We need to check *both* before early-aborting due to the size being 0.\n-        let (src, dest) = match (self.check_ptr_access(src, size, src_align)?,\n-                self.check_ptr_access(dest, size * length, dest_align)?)\n-        {\n-            (Some(src), Some(dest)) => (src, dest),\n-            // One of the two sizes is 0.\n-            _ => return Ok(()),\n-        };\n-\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target."}, {"sha": "3d97132e53969472ea39c580fe253867067c3bc0", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -123,23 +123,23 @@ pub enum Operand<Tag=(), Id=AllocId> {\n \n impl<Tag> Operand<Tag> {\n     #[inline]\n-    pub fn to_mem_place(self) -> MemPlace<Tag>\n+    pub fn assert_mem_place(self) -> MemPlace<Tag>\n         where Tag: ::std::fmt::Debug\n     {\n         match self {\n             Operand::Indirect(mplace) => mplace,\n-            _ => bug!(\"to_mem_place: expected Operand::Indirect, got {:?}\", self),\n+            _ => bug!(\"assert_mem_place: expected Operand::Indirect, got {:?}\", self),\n \n         }\n     }\n \n     #[inline]\n-    pub fn to_immediate(self) -> Immediate<Tag>\n+    pub fn assert_immediate(self) -> Immediate<Tag>\n         where Tag: ::std::fmt::Debug\n     {\n         match self {\n             Operand::Immediate(imm) => imm,\n-            _ => bug!(\"to_immediate: expected Operand::Immediate, got {:?}\", self),\n+            _ => bug!(\"assert_immediate: expected Operand::Immediate, got {:?}\", self),\n \n         }\n     }\n@@ -214,6 +214,19 @@ pub(super) fn from_known_layout<'tcx>(\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    /// Normalice `place.ptr` to a `Pointer` if this is a place and not a ZST.\n+    /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n+    #[inline]\n+    pub fn force_op_ptr(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        match op.try_as_mplace() {\n+            Ok(mplace) => Ok(self.force_mplace_ptr(mplace)?.into()),\n+            Err(imm) => Ok(imm.into()), // Nothing to cast/force\n+        }\n+    }\n+\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace(\n@@ -224,9 +237,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Don't touch unsized\n             return Ok(None);\n         }\n-        let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n \n-        let ptr = match self.memory.check_ptr_access(ptr, mplace.layout.size, ptr_align)? {\n+        let ptr = match self.check_mplace_access(mplace, None)? {\n             Some(ptr) => ptr,\n             None => return Ok(Some(ImmTy { // zero-sized type\n                 imm: Immediate::Scalar(Scalar::zst().into()),\n@@ -396,7 +408,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             } else {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n-                let mplace = base.to_mem_place();\n+                let mplace = base.assert_mem_place();\n                 self.mplace_projection(mplace, proj_elem)?.into()\n             }\n         })"}, {"sha": "68382071b4a6720a391b12f7677df35adff812a6", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -122,21 +122,6 @@ impl<Tag> MemPlace<Tag> {\n         Self::from_scalar_ptr(ptr.into(), align)\n     }\n \n-    #[inline(always)]\n-    pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, Align) {\n-        assert!(self.meta.is_none());\n-        (self.ptr, self.align)\n-    }\n-\n-    /// metact the ptr part of the mplace\n-    #[inline(always)]\n-    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n-        // At this point, we forget about the alignment information --\n-        // the place has been turned into a reference, and no matter where it came from,\n-        // it now must be aligned.\n-        self.to_scalar_ptr_align().0.to_ptr()\n-    }\n-\n     /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n     #[inline(always)]\n@@ -230,6 +215,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n }\n \n+// These are defined here because they produce a place.\n impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n@@ -240,12 +226,12 @@ impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn to_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n+    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         self.try_as_mplace().unwrap()\n     }\n }\n \n-impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n+impl<Tag: ::std::fmt::Debug> Place<Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n     pub fn null(cx: &impl HasDataLayout) -> Self {\n@@ -263,29 +249,19 @@ impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_mem_place(self) -> MemPlace<Tag> {\n+    pub fn assert_mem_place(self) -> MemPlace<Tag> {\n         match self {\n             Place::Ptr(mplace) => mplace,\n-            _ => bug!(\"to_mem_place: expected Place::Ptr, got {:?}\", self),\n+            _ => bug!(\"assert_mem_place: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n-\n-    #[inline]\n-    pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, Align) {\n-        self.to_mem_place().to_scalar_ptr_align()\n-    }\n-\n-    #[inline]\n-    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n-        self.to_mem_place().to_ptr()\n-    }\n }\n \n impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n     #[inline]\n-    pub fn to_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n-        MPlaceTy { mplace: self.place.to_mem_place(), layout: self.layout }\n+    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n+        MPlaceTy { mplace: self.place.assert_mem_place(), layout: self.layout }\n     }\n }\n \n@@ -301,8 +277,6 @@ where\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n-    /// This does NOT call the \"deref\" machine hook, so it does NOT count as a\n-    /// deref as far as Stacked Borrows is concerned.  Use `deref_operand` for that!\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n@@ -322,8 +296,8 @@ where\n         Ok(MPlaceTy { mplace, layout })\n     }\n \n-    // Take an operand, representing a pointer, and dereference it to a place -- that\n-    // will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n+    /// Take an operand, representing a pointer, and dereference it to a place -- that\n+    /// will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n     pub fn deref_operand(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n@@ -333,6 +307,36 @@ where\n         self.ref_to_mplace(val)\n     }\n \n+    /// Check if the given place is good for memory access with the given\n+    /// size, falling back to the layout's size if `None` (in the latter case,\n+    /// this must be a statically sized type).\n+    ///\n+    /// On success, returns `None` for zero-sized accesses (where nothing else is\n+    /// left to do) and a `Pointer` to use for the actual access otherwise.\n+    #[inline]\n+    pub fn check_mplace_access(\n+        &self,\n+        place: MPlaceTy<'tcx, M::PointerTag>,\n+        size: Option<Size>,\n+    ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n+        let size = size.unwrap_or_else(|| {\n+            assert!(!place.layout.is_unsized());\n+            assert!(place.meta.is_none());\n+            place.layout.size\n+        });\n+        self.memory.check_ptr_access(place.ptr, size, place.align)\n+    }\n+\n+    /// Force `place.ptr` to a `Pointer`.\n+    /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n+    pub fn force_mplace_ptr(\n+        &self,\n+        mut place: MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        place.mplace.ptr = self.force_ptr(place.mplace.ptr)?.into();\n+        Ok(place)\n+    }\n+\n     /// Offset a pointer to project to a field. Unlike `place_field`, this is always\n     /// possible without allocating, so it can take `&self`. Also return the field's layout.\n     /// This supports both struct and array fields.\n@@ -741,14 +745,12 @@ where\n         value: Immediate<M::PointerTag>,\n         dest: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n         // Note that it is really important that the type here is the right one, and matches the\n         // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n-        assert!(!dest.layout.is_unsized());\n \n-        let ptr = match self.memory.check_ptr_access(ptr, dest.layout.size, ptr_align)? {\n+        let ptr = match self.check_mplace_access(dest, None)? {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n         };\n@@ -850,14 +852,21 @@ where\n             dest.layout.size\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n+\n+        let src = self.check_mplace_access(src, Some(size))?;\n+        let dest = self.check_mplace_access(dest, Some(size))?;\n+        let (src_ptr, dest_ptr) = match (src, dest) {\n+            (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n+            (None, None) => return Ok(()), // zero-sized copy\n+            _ => bug!(\"The pointers should both be Some or both None\"),\n+        };\n+\n         self.memory.copy(\n-            src.ptr, src.align,\n-            dest.ptr, dest.align,\n+            src_ptr,\n+            dest_ptr,\n             size,\n             /*nonoverlapping*/ true,\n-        )?;\n-\n-        Ok(())\n+        )\n     }\n \n     /// Copies the data from an operand to a place. The layouts may disagree, but they must"}, {"sha": "246c90ba48e3aa3661ca61a81dbaf4ea932a0a0a", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -209,17 +209,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let dest = self.force_allocation(dest)?;\n                 let length = dest.len(self)?;\n \n-                if length > 0 {\n-                    // write the first\n+                if let Some(first_ptr) = self.check_mplace_access(dest, None)? {\n+                    // Write the first.\n                     let first = self.mplace_field(dest, 0)?;\n                     self.copy_op(op, first.into())?;\n \n                     if length > 1 {\n-                        // copy the rest\n-                        let (dest, dest_align) = first.to_scalar_ptr_align();\n-                        let rest = dest.ptr_offset(first.layout.size, self)?;\n+                        let elem_size = first.layout.size;\n+                        // Copy the rest. This is performance-sensitive code\n+                        // for big static/const arrays!\n+                        let rest_ptr = first_ptr.offset(elem_size, self)?;\n                         self.memory.copy_repeatedly(\n-                            dest, dest_align, rest, dest_align, first.layout.size, length - 1, true\n+                            first_ptr, rest_ptr, elem_size, length - 1, /*nonoverlapping:*/true\n                         )?;\n                     }\n                 }"}, {"sha": "c11e5e119237f48dba3930ba73e9ce57fb0da7bc", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -426,7 +426,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     None => {\n                         // Unsized self.\n-                        args[0].to_mem_place()\n+                        args[0].assert_mem_place()\n                     }\n                 };\n                 // Find and consult vtable"}, {"sha": "00107a536ba26522d1e317b215342d9d069799d3", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -440,9 +440,16 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                             }\n                         }\n                     }\n-                    // Check if we have encountered this pointer+layout combination\n-                    // before.  Proceed recursively even for ZST, no\n-                    // reason to skip them! E.g., `!` is a ZST and we want to validate it.\n+                    // Proceed recursively even for ZST, no reason to skip them!\n+                    // `!` is a ZST and we want to validate it.\n+                    // Normalize before handing `place` to tracking because that will\n+                    // check for duplicates.\n+                    let place = if size.bytes() > 0 {\n+                        self.ecx.force_mplace_ptr(place)\n+                            .expect(\"we already bounds-checked\")\n+                    } else {\n+                        place\n+                    };\n                     let path = &self.path;\n                     ref_tracking.track(place, || {\n                         // We need to clone the path anyway, make sure it gets created\n@@ -548,7 +555,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.sty {\n             ty::Str => {\n-                let mplace = op.to_mem_place(); // strings are never immediate\n+                let mplace = op.assert_mem_place(); // strings are never immediate\n                 try_validation!(self.ecx.read_str(mplace),\n                     \"uninitialized or non-UTF-8 data in str\", self.path);\n             }\n@@ -565,7 +572,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     return Ok(());\n                 }\n                 // non-ZST array cannot be immediate, slices are never immediate\n-                let mplace = op.to_mem_place();\n+                let mplace = op.assert_mem_place();\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n                 // zero length slices have nothing to be checked\n@@ -576,7 +583,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let ty_size = self.ecx.layout_of(tys)?.size;\n                 // This is the size in bytes of the whole array.\n                 let size = ty_size * len;\n-\n+                // Size is not 0, get a pointer.\n                 let ptr = self.ecx.force_ptr(mplace.ptr)?;\n \n                 // NOTE: Keep this in sync with the handling of integer and float\n@@ -633,7 +640,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// `ref_tracking_for_consts` can be `None` to avoid recursive checking below references.\n     /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n     /// validation (e.g., pointer values are fine in integers at runtime) and various other const\n-    /// specific validation checks\n+    /// specific validation checks.\n     pub fn validate_operand(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n@@ -652,6 +659,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ecx: self,\n         };\n \n+        // Try to cast to ptr *once* instead of all the time.\n+        let op = self.force_op_ptr(op).unwrap_or(op);\n+\n         // Run it\n         visitor.visit_value(op)\n     }"}, {"sha": "91fbd307db12123e04108f0066eb37877ea20e28", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e15655092d1bdae79619eb0ff2c3cb5468fc36/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "patch": "@@ -242,7 +242,7 @@ macro_rules! make_value_visitor {\n                 match v.layout().ty.sty {\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n-                        let dest = v.to_op(self.ecx())?.to_mem_place();\n+                        let dest = v.to_op(self.ecx())?.assert_mem_place();\n                         let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n@@ -316,7 +316,7 @@ macro_rules! make_value_visitor {\n                             MPlaceTy::dangling(v.layout(), self.ecx())\n                         } else {\n                             // non-ZST array/slice/str cannot be immediate\n-                            v.to_op(self.ecx())?.to_mem_place()\n+                            v.to_op(self.ecx())?.assert_mem_place()\n                         };\n                         // Now we can go over all the fields.\n                         let iter = self.ecx().mplace_array_fields(mplace)?"}]}