{"sha": "59e52b1b969545e6b7b8595913dc2e1a741d495d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZTUyYjFiOTY5NTQ1ZTZiN2I4NTk1OTEzZGMyZTFhNzQxZDQ5NWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-28T06:44:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-28T06:44:12Z"}, "message": "Auto merge of #53616 - varkor:hir-map-rename, r=nikomatsakis\n\nRestructure hir::map::Node and hir::map::Entry\n\n- Moves `hir::map::Node` to `hir::Node` and removes the `Node*` prefix from its variants.\n- Changes `hir::map::Entry` to a struct `hir::map::Entry`.\n- Removes the `Node*` prefix from each of `AnnNode`s variants.\n\nr? @eddyb", "tree": {"sha": "d5f5dc5b38fdaa7b44bd1e4822610ff4e02632ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5f5dc5b38fdaa7b44bd1e4822610ff4e02632ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59e52b1b969545e6b7b8595913dc2e1a741d495d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59e52b1b969545e6b7b8595913dc2e1a741d495d", "html_url": "https://github.com/rust-lang/rust/commit/59e52b1b969545e6b7b8595913dc2e1a741d495d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59e52b1b969545e6b7b8595913dc2e1a741d495d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca63a4e4383f502cf541e0b0bc1c13541918103d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca63a4e4383f502cf541e0b0bc1c13541918103d", "html_url": "https://github.com/rust-lang/rust/commit/ca63a4e4383f502cf541e0b0bc1c13541918103d"}, {"sha": "a9d075e756382248707f48ef23a7088322a79925", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d075e756382248707f48ef23a7088322a79925", "html_url": "https://github.com/rust-lang/rust/commit/a9d075e756382248707f48ef23a7088322a79925"}], "stats": {"total": 1377, "additions": 628, "deletions": 749}, "files": [{"sha": "eeb41682601f5798125be49567f819665b2f1ab2", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -22,8 +22,8 @@\n //! for the `Code` associated with a particular NodeId.\n \n use hir as ast;\n-use hir::map::{self, Node};\n-use hir::{Expr, FnDecl};\n+use hir::map;\n+use hir::{Expr, FnDecl, Node};\n use hir::intravisit::FnKind;\n use syntax::ast::{Attribute, Ident, Name, NodeId};\n use syntax_pos::Span;\n@@ -39,7 +39,7 @@ use syntax_pos::Span;\n ///\n /// To construct one, use the `Code::from_node` function.\n #[derive(Copy, Clone, Debug)]\n-pub struct FnLikeNode<'a> { node: map::Node<'a> }\n+pub struct FnLikeNode<'a> { node: Node<'a> }\n \n /// MaybeFnLike wraps a method that indicates if an object\n /// corresponds to some FnLikeNode.\n@@ -95,11 +95,11 @@ impl<'a> Code<'a> {\n     /// Attempts to construct a Code from presumed FnLike or Expr node input.\n     pub fn from_node(map: &map::Map<'a>, id: NodeId) -> Option<Code<'a>> {\n         match map.get(id) {\n-            map::NodeBlock(_) => {\n+            map::Node::Block(_) => {\n                 //  Use the parent, hopefully an expression node.\n                 Code::from_node(map, map.get_parent_node(id))\n             }\n-            map::NodeExpr(expr) => Some(Code::Expr(expr)),\n+            map::Node::Expr(expr) => Some(Code::Expr(expr)),\n             node => FnLikeNode::from_node(node).map(Code::FnLike)\n         }\n     }\n@@ -145,10 +145,10 @@ impl<'a> FnLikeNode<'a> {\n     /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n     pub fn from_node(node: Node) -> Option<FnLikeNode> {\n         let fn_like = match node {\n-            map::NodeItem(item) => item.is_fn_like(),\n-            map::NodeTraitItem(tm) => tm.is_fn_like(),\n-            map::NodeImplItem(it) => it.is_fn_like(),\n-            map::NodeExpr(e) => e.is_fn_like(),\n+            map::Node::Item(item) => item.is_fn_like(),\n+            map::Node::TraitItem(tm) => tm.is_fn_like(),\n+            map::Node::ImplItem(it) => it.is_fn_like(),\n+            map::Node::Expr(e) => e.is_fn_like(),\n             _ => false\n         };\n         if fn_like {\n@@ -234,7 +234,7 @@ impl<'a> FnLikeNode<'a> {\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n-            map::NodeItem(i) => match i.node {\n+            map::Node::Item(i) => match i.node {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n@@ -249,13 +249,13 @@ impl<'a> FnLikeNode<'a> {\n                     }),\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            map::NodeTraitItem(ti) => match ti.node {\n+            map::Node::TraitItem(ti) => match ti.node {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n                     method(ti.id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n-            map::NodeImplItem(ii) => {\n+            map::Node::ImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n                         method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n@@ -265,7 +265,7 @@ impl<'a> FnLikeNode<'a> {\n                     }\n                 }\n             },\n-            map::NodeExpr(e) => match e.node {\n+            map::Node::Expr(e) => match e.node {\n                 ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n                     closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),"}, {"sha": "30441c331e4cfea71cf9eabb835ff7b6ecb9d5fc", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 39, "deletions": 56, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -29,7 +29,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n     krate: &'hir Crate,\n     /// The node map\n-    map: Vec<MapEntry<'hir>>,\n+    map: Vec<Option<Entry<'hir>>>,\n     /// The parent of this node\n     parent_node: NodeId,\n \n@@ -114,7 +114,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             hcx,\n             hir_body_nodes,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_sig_dep_index));\n+        collector.insert_entry(CRATE_NODE_ID, Entry {\n+            parent: CRATE_NODE_ID,\n+            dep_node: root_mod_sig_dep_index,\n+            node: Node::Crate,\n+        });\n \n         collector\n     }\n@@ -124,9 +128,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   cstore: &dyn CrateStore,\n                                                   source_map: &SourceMap,\n                                                   commandline_args_hash: u64)\n-                                                  -> (Vec<MapEntry<'hir>>, Svh) {\n-        self\n-            .hir_body_nodes\n+                                                  -> (Vec<Option<Entry<'hir>>>, Svh) {\n+        self.hir_body_nodes\n             .sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n \n         let node_hashes = self\n@@ -178,44 +181,24 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         (self.map, svh)\n     }\n \n-    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'hir>) {\n+    fn insert_entry(&mut self, id: NodeId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n         if id.as_usize() >= len {\n-            self.map.extend(repeat(NotPresent).take(id.as_usize() - len + 1));\n+            self.map.extend(repeat(None).take(id.as_usize() - len + 1));\n         }\n-        self.map[id.as_usize()] = entry;\n+        self.map[id.as_usize()] = Some(entry);\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n-        let parent = self.parent_node;\n-        let dep_node_index = if self.currently_in_body {\n-            self.current_full_dep_index\n-        } else {\n-            self.current_signature_dep_index\n-        };\n-\n-        let entry = match node {\n-            NodeItem(n) => EntryItem(parent, dep_node_index, n),\n-            NodeForeignItem(n) => EntryForeignItem(parent, dep_node_index, n),\n-            NodeTraitItem(n) => EntryTraitItem(parent, dep_node_index, n),\n-            NodeImplItem(n) => EntryImplItem(parent, dep_node_index, n),\n-            NodeVariant(n) => EntryVariant(parent, dep_node_index, n),\n-            NodeField(n) => EntryField(parent, dep_node_index, n),\n-            NodeAnonConst(n) => EntryAnonConst(parent, dep_node_index, n),\n-            NodeExpr(n) => EntryExpr(parent, dep_node_index, n),\n-            NodeStmt(n) => EntryStmt(parent, dep_node_index, n),\n-            NodeTy(n) => EntryTy(parent, dep_node_index, n),\n-            NodeTraitRef(n) => EntryTraitRef(parent, dep_node_index, n),\n-            NodeBinding(n) => EntryBinding(parent, dep_node_index, n),\n-            NodePat(n) => EntryPat(parent, dep_node_index, n),\n-            NodeBlock(n) => EntryBlock(parent, dep_node_index, n),\n-            NodeStructCtor(n) => EntryStructCtor(parent, dep_node_index, n),\n-            NodeLifetime(n) => EntryLifetime(parent, dep_node_index, n),\n-            NodeGenericParam(n) => EntryGenericParam(parent, dep_node_index, n),\n-            NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n-            NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n-            NodeMacroDef(n) => EntryMacroDef(dep_node_index, n),\n+        let entry = Entry {\n+            parent: self.parent_node,\n+            dep_node: if self.currently_in_body {\n+                self.current_full_dep_index\n+            } else {\n+                self.current_signature_dep_index\n+            },\n+            node,\n         };\n \n         // Make sure that the DepNode of some node coincides with the HirId\n@@ -326,13 +309,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n-            this.insert(i.id, NodeItem(i));\n+            this.insert(i.id, Node::Item(i));\n             this.with_parent(i.id, |this| {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) => {\n                         // If this is a tuple-like struct, register the constructor.\n                         if !struct_def.is_struct() {\n-                            this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                            this.insert(struct_def.id(), Node::StructCtor(struct_def));\n                         }\n                     }\n                     _ => {}\n@@ -343,23 +326,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n-        self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n+        self.insert(foreign_item.id, Node::ForeignItem(foreign_item));\n \n         self.with_parent(foreign_item.id, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        self.insert(param.id, NodeGenericParam(param));\n+        self.insert(param.id, Node::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n-            this.insert(ti.id, NodeTraitItem(ti));\n+            this.insert(ti.id, Node::TraitItem(ti));\n \n             this.with_parent(ti.id, |this| {\n                 intravisit::walk_trait_item(this, ti);\n@@ -371,7 +354,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n-            this.insert(ii.id, NodeImplItem(ii));\n+            this.insert(ii.id, Node::ImplItem(ii));\n \n             this.with_parent(ii.id, |this| {\n                 intravisit::walk_impl_item(this, ii);\n@@ -381,9 +364,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_pat(&mut self, pat: &'hir Pat) {\n         let node = if let PatKind::Binding(..) = pat.node {\n-            NodeBinding(pat)\n+            Node::Binding(pat)\n         } else {\n-            NodePat(pat)\n+            Node::Pat(pat)\n         };\n         self.insert(pat.id, node);\n \n@@ -393,15 +376,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n-        self.insert(constant.id, NodeAnonConst(constant));\n+        self.insert(constant.id, Node::AnonConst(constant));\n \n         self.with_parent(constant.id, |this| {\n             intravisit::walk_anon_const(this, constant);\n         });\n     }\n \n     fn visit_expr(&mut self, expr: &'hir Expr) {\n-        self.insert(expr.id, NodeExpr(expr));\n+        self.insert(expr.id, Node::Expr(expr));\n \n         self.with_parent(expr.id, |this| {\n             intravisit::walk_expr(this, expr);\n@@ -410,23 +393,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n         let id = stmt.node.id();\n-        self.insert(id, NodeStmt(stmt));\n+        self.insert(id, Node::Stmt(stmt));\n \n         self.with_parent(id, |this| {\n             intravisit::walk_stmt(this, stmt);\n         });\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty) {\n-        self.insert(ty.id, NodeTy(ty));\n+        self.insert(ty.id, Node::Ty(ty));\n \n         self.with_parent(ty.id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n-        self.insert(tr.ref_id, NodeTraitRef(tr));\n+        self.insert(tr.ref_id, Node::TraitRef(tr));\n \n         self.with_parent(tr.ref_id, |this| {\n             intravisit::walk_trait_ref(this, tr);\n@@ -440,21 +423,21 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_block(&mut self, block: &'hir Block) {\n-        self.insert(block.id, NodeBlock(block));\n+        self.insert(block.id, Node::Block(block));\n         self.with_parent(block.id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n     fn visit_local(&mut self, l: &'hir Local) {\n-        self.insert(l.id, NodeLocal(l));\n+        self.insert(l.id, Node::Local(l));\n         self.with_parent(l.id, |this| {\n             intravisit::walk_local(this, l)\n         })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.id, NodeLifetime(lifetime));\n+        self.insert(lifetime.id, Node::Lifetime(lifetime));\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n@@ -463,7 +446,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             VisibilityKind::Crate(_) |\n             VisibilityKind::Inherited => {}\n             VisibilityKind::Restricted { id, .. } => {\n-                self.insert(id, NodeVisibility(visibility));\n+                self.insert(id, Node::Visibility(visibility));\n                 self.with_parent(id, |this| {\n                     intravisit::walk_vis(this, visibility);\n                 });\n@@ -475,20 +458,20 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n-            this.insert(macro_def.id, NodeMacroDef(macro_def));\n+            this.insert(macro_def.id, Node::MacroDef(macro_def));\n         });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n         let id = v.node.data.id();\n-        self.insert(id, NodeVariant(v));\n+        self.insert(id, Node::Variant(v));\n         self.with_parent(id, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, field: &'hir StructField) {\n-        self.insert(field.id, NodeField(field));\n+        self.insert(field.id, Node::Field(field));\n         self.with_parent(field.id, |this| {\n             intravisit::walk_struct_field(this, field);\n         });"}, {"sha": "6fffde7cab50cdc578839693e0cde37c8b8028c6", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 215, "deletions": 361, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::Node::*;\n-use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n@@ -42,172 +40,62 @@ mod def_collector;\n pub mod definitions;\n mod hir_id_validator;\n \n-\n pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n+/// Represents an entry and its parent NodeId.\n #[derive(Copy, Clone, Debug)]\n-pub enum Node<'hir> {\n-    NodeItem(&'hir Item),\n-    NodeForeignItem(&'hir ForeignItem),\n-    NodeTraitItem(&'hir TraitItem),\n-    NodeImplItem(&'hir ImplItem),\n-    NodeVariant(&'hir Variant),\n-    NodeField(&'hir StructField),\n-    NodeAnonConst(&'hir AnonConst),\n-    NodeExpr(&'hir Expr),\n-    NodeStmt(&'hir Stmt),\n-    NodeTy(&'hir Ty),\n-    NodeTraitRef(&'hir TraitRef),\n-    NodeBinding(&'hir Pat),\n-    NodePat(&'hir Pat),\n-    NodeBlock(&'hir Block),\n-    NodeLocal(&'hir Local),\n-    NodeMacroDef(&'hir MacroDef),\n-\n-    /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(&'hir VariantData),\n-\n-    NodeLifetime(&'hir Lifetime),\n-    NodeGenericParam(&'hir GenericParam),\n-    NodeVisibility(&'hir Visibility),\n-}\n-\n-/// Represents an entry and its parent NodeID.\n-/// The odd layout is to bring down the total size.\n-#[derive(Copy, Debug)]\n-enum MapEntry<'hir> {\n-    /// Placeholder for holes in the map.\n-    NotPresent,\n-\n-    /// All the node types, with a parent ID.\n-    EntryItem(NodeId, DepNodeIndex, &'hir Item),\n-    EntryForeignItem(NodeId, DepNodeIndex, &'hir ForeignItem),\n-    EntryTraitItem(NodeId, DepNodeIndex, &'hir TraitItem),\n-    EntryImplItem(NodeId, DepNodeIndex, &'hir ImplItem),\n-    EntryVariant(NodeId, DepNodeIndex, &'hir Variant),\n-    EntryField(NodeId, DepNodeIndex, &'hir StructField),\n-    EntryAnonConst(NodeId, DepNodeIndex, &'hir AnonConst),\n-    EntryExpr(NodeId, DepNodeIndex, &'hir Expr),\n-    EntryStmt(NodeId, DepNodeIndex, &'hir Stmt),\n-    EntryTy(NodeId, DepNodeIndex, &'hir Ty),\n-    EntryTraitRef(NodeId, DepNodeIndex, &'hir TraitRef),\n-    EntryBinding(NodeId, DepNodeIndex, &'hir Pat),\n-    EntryPat(NodeId, DepNodeIndex, &'hir Pat),\n-    EntryBlock(NodeId, DepNodeIndex, &'hir Block),\n-    EntryStructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n-    EntryLifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n-    EntryGenericParam(NodeId, DepNodeIndex, &'hir GenericParam),\n-    EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n-    EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n-\n-    EntryMacroDef(DepNodeIndex, &'hir MacroDef),\n-\n-    /// Roots for node trees. The DepNodeIndex is the dependency node of the\n-    /// crate's root module.\n-    RootCrate(DepNodeIndex),\n-}\n-\n-impl<'hir> Clone for MapEntry<'hir> {\n-    fn clone(&self) -> MapEntry<'hir> {\n-        *self\n-    }\n+pub struct Entry<'hir> {\n+    parent: NodeId,\n+    dep_node: DepNodeIndex,\n+    node: Node<'hir>,\n }\n \n-impl<'hir> MapEntry<'hir> {\n+impl<'hir> Entry<'hir> {\n     fn parent_node(self) -> Option<NodeId> {\n-        Some(match self {\n-            EntryItem(id, _, _) => id,\n-            EntryForeignItem(id, _, _) => id,\n-            EntryTraitItem(id, _, _) => id,\n-            EntryImplItem(id, _, _) => id,\n-            EntryVariant(id, _, _) => id,\n-            EntryField(id, _, _) => id,\n-            EntryAnonConst(id, _, _) => id,\n-            EntryExpr(id, _, _) => id,\n-            EntryStmt(id, _, _) => id,\n-            EntryTy(id, _, _) => id,\n-            EntryTraitRef(id, _, _) => id,\n-            EntryBinding(id, _, _) => id,\n-            EntryPat(id, _, _) => id,\n-            EntryBlock(id, _, _) => id,\n-            EntryStructCtor(id, _, _) => id,\n-            EntryLifetime(id, _, _) => id,\n-            EntryGenericParam(id, _, _) => id,\n-            EntryVisibility(id, _, _) => id,\n-            EntryLocal(id, _, _) => id,\n-\n-            NotPresent |\n-            EntryMacroDef(..) |\n-            RootCrate(_) => return None,\n-        })\n-    }\n-\n-    fn to_node(self) -> Option<Node<'hir>> {\n-        Some(match self {\n-            EntryItem(_, _, n) => NodeItem(n),\n-            EntryForeignItem(_, _, n) => NodeForeignItem(n),\n-            EntryTraitItem(_, _, n) => NodeTraitItem(n),\n-            EntryImplItem(_, _, n) => NodeImplItem(n),\n-            EntryVariant(_, _, n) => NodeVariant(n),\n-            EntryField(_, _, n) => NodeField(n),\n-            EntryAnonConst(_, _, n) => NodeAnonConst(n),\n-            EntryExpr(_, _, n) => NodeExpr(n),\n-            EntryStmt(_, _, n) => NodeStmt(n),\n-            EntryTy(_, _, n) => NodeTy(n),\n-            EntryTraitRef(_, _, n) => NodeTraitRef(n),\n-            EntryBinding(_, _, n) => NodeBinding(n),\n-            EntryPat(_, _, n) => NodePat(n),\n-            EntryBlock(_, _, n) => NodeBlock(n),\n-            EntryStructCtor(_, _, n) => NodeStructCtor(n),\n-            EntryLifetime(_, _, n) => NodeLifetime(n),\n-            EntryGenericParam(_, _, n) => NodeGenericParam(n),\n-            EntryVisibility(_, _, n) => NodeVisibility(n),\n-            EntryLocal(_, _, n) => NodeLocal(n),\n-            EntryMacroDef(_, n) => NodeMacroDef(n),\n-\n-            NotPresent |\n-            RootCrate(_) => return None\n-        })\n+        match self.node {\n+            Node::Crate | Node::MacroDef(_) => None,\n+            _ => Some(self.parent),\n+        }\n     }\n \n     fn fn_decl(&self) -> Option<&FnDecl> {\n-        match self {\n-            EntryItem(_, _, ref item) => {\n+        match self.node {\n+            Node::Item(ref item) => {\n                 match item.node {\n                     ItemKind::Fn(ref fn_decl, _, _, _) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n \n-            EntryTraitItem(_, _, ref item) => {\n+            Node::TraitItem(ref item) => {\n                 match item.node {\n                     TraitItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None\n                 }\n             }\n \n-            EntryImplItem(_, _, ref item) => {\n+            Node::ImplItem(ref item) => {\n                 match item.node {\n                     ImplItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None,\n                 }\n             }\n \n-            EntryExpr(_, _, ref expr) => {\n+            Node::Expr(ref expr) => {\n                 match expr.node {\n                     ExprKind::Closure(_, ref fn_decl, ..) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n \n-            _ => None\n+            _ => None,\n         }\n     }\n \n     fn associated_body(self) -> Option<BodyId> {\n-        match self {\n-            EntryItem(_, _, item) => {\n+        match self.node {\n+            Node::Item(item) => {\n                 match item.node {\n                     ItemKind::Const(_, body) |\n                     ItemKind::Static(.., body) |\n@@ -216,25 +104,25 @@ impl<'hir> MapEntry<'hir> {\n                 }\n             }\n \n-            EntryTraitItem(_, _, item) => {\n+            Node::TraitItem(item) => {\n                 match item.node {\n                     TraitItemKind::Const(_, Some(body)) |\n                     TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n                     _ => None\n                 }\n             }\n \n-            EntryImplItem(_, _, item) => {\n+            Node::ImplItem(item) => {\n                 match item.node {\n                     ImplItemKind::Const(_, body) |\n                     ImplItemKind::Method(_, body) => Some(body),\n                     _ => None,\n                 }\n             }\n \n-            EntryAnonConst(_, _, constant) => Some(constant.body),\n+            Node::AnonConst(constant) => Some(constant.body),\n \n-            EntryExpr(_, _, expr) => {\n+            Node::Expr(expr) => {\n                 match expr.node {\n                     ExprKind::Closure(.., body, _, _) => Some(body),\n                     _ => None,\n@@ -287,16 +175,16 @@ pub struct Map<'hir> {\n     /// The SVH of the local crate.\n     pub crate_hash: Svh,\n \n-    /// NodeIds are sequential integers from 0, so we can be\n+    /// `NodeId`s are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n-    /// a NodeId is in the map, but empirically the occupancy is about\n+    /// a `NodeId` is in the map, but empirically the occupancy is about\n     /// 75-80%, so there's not too much overhead (certainly less than\n     /// a hashmap, since they (at the time of writing) have a maximum\n     /// of 75% occupancy).\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: Vec<MapEntry<'hir>>,\n+    map: Vec<Option<Entry<'hir>>>,\n \n     definitions: &'hir Definitions,\n \n@@ -313,34 +201,10 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, id: NodeId) {\n-        let entry = self.map[id.as_usize()];\n-        match entry {\n-            EntryItem(_, dep_node_index, _) |\n-            EntryTraitItem(_, dep_node_index, _) |\n-            EntryImplItem(_, dep_node_index, _) |\n-            EntryVariant(_, dep_node_index, _) |\n-            EntryForeignItem(_, dep_node_index, _) |\n-            EntryField(_, dep_node_index, _) |\n-            EntryStmt(_, dep_node_index, _) |\n-            EntryTy(_, dep_node_index, _) |\n-            EntryTraitRef(_, dep_node_index, _) |\n-            EntryBinding(_, dep_node_index, _) |\n-            EntryPat(_, dep_node_index, _) |\n-            EntryBlock(_, dep_node_index, _) |\n-            EntryStructCtor(_, dep_node_index, _) |\n-            EntryLifetime(_, dep_node_index, _) |\n-            EntryGenericParam(_, dep_node_index, _) |\n-            EntryVisibility(_, dep_node_index, _) |\n-            EntryAnonConst(_, dep_node_index, _) |\n-            EntryExpr(_, dep_node_index, _) |\n-            EntryLocal(_, dep_node_index, _) |\n-            EntryMacroDef(dep_node_index, _) |\n-            RootCrate(dep_node_index) => {\n-                self.dep_graph.read_index(dep_node_index);\n-            }\n-            NotPresent => {\n-                bug!(\"called HirMap::read() with invalid NodeId\")\n-            }\n+        if let Some(entry) = self.map[id.as_usize()] {\n+            self.dep_graph.read_index(entry.dep_node);\n+        } else {\n+            bug!(\"called `HirMap::read()` with invalid `NodeId`\")\n         }\n     }\n \n@@ -421,7 +285,7 @@ impl<'hir> Map<'hir> {\n         };\n \n         match node {\n-            NodeItem(item) => {\n+            Node::Item(item) => {\n                 let def_id = || {\n                     self.local_def_id(item.id)\n                 };\n@@ -448,23 +312,23 @@ impl<'hir> Map<'hir> {\n                     ItemKind::Impl(..) => None,\n                 }\n             }\n-            NodeForeignItem(item) => {\n+            Node::ForeignItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n                     ForeignItemKind::Static(_, m) => Some(Def::Static(def_id, m)),\n                     ForeignItemKind::Type => Some(Def::ForeignTy(def_id)),\n                 }\n             }\n-            NodeTraitItem(item) => {\n+            Node::TraitItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n                     TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n                     TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n                 }\n             }\n-            NodeImplItem(item) => {\n+            Node::ImplItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n@@ -473,30 +337,31 @@ impl<'hir> Map<'hir> {\n                     ImplItemKind::Existential(..) => Some(Def::AssociatedExistential(def_id)),\n                 }\n             }\n-            NodeVariant(variant) => {\n+            Node::Variant(variant) => {\n                 let def_id = self.local_def_id(variant.node.data.id());\n                 Some(Def::Variant(def_id))\n             }\n-            NodeField(_) |\n-            NodeAnonConst(_) |\n-            NodeExpr(_) |\n-            NodeStmt(_) |\n-            NodeTy(_) |\n-            NodeTraitRef(_) |\n-            NodePat(_) |\n-            NodeBinding(_) |\n-            NodeStructCtor(_) |\n-            NodeLifetime(_) |\n-            NodeVisibility(_) |\n-            NodeBlock(_) => None,\n-            NodeLocal(local) => {\n+            Node::Field(_) |\n+            Node::AnonConst(_) |\n+            Node::Expr(_) |\n+            Node::Stmt(_) |\n+            Node::Ty(_) |\n+            Node::TraitRef(_) |\n+            Node::Pat(_) |\n+            Node::Binding(_) |\n+            Node::StructCtor(_) |\n+            Node::Lifetime(_) |\n+            Node::Visibility(_) |\n+            Node::Block(_) |\n+            Node::Crate => None,\n+            Node::Local(local) => {\n                 Some(Def::Local(local.id))\n             }\n-            NodeMacroDef(macro_def) => {\n+            Node::MacroDef(macro_def) => {\n                 Some(Def::Macro(self.local_def_id(macro_def.id),\n                                 MacroKind::Bang))\n             }\n-            NodeGenericParam(param) => {\n+            Node::GenericParam(param) => {\n                 Some(match param.kind {\n                     GenericParamKind::Lifetime { .. } => Def::Local(param.id),\n                     GenericParamKind::Type { .. } => Def::TyParam(self.local_def_id(param.id)),\n@@ -509,8 +374,8 @@ impl<'hir> Map<'hir> {\n         self.map.len()\n     }\n \n-    fn find_entry(&self, id: NodeId) -> Option<MapEntry<'hir>> {\n-        self.map.get(id.as_usize()).cloned()\n+    fn find_entry(&self, id: NodeId) -> Option<Entry<'hir>> {\n+        self.map.get(id.as_usize()).cloned().unwrap_or(None)\n     }\n \n     pub fn krate(&self) -> &'hir Crate {\n@@ -554,7 +419,7 @@ impl<'hir> Map<'hir> {\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node(node_id);\n-        assert!(self.map[parent.as_usize()].is_body_owner(node_id));\n+        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(node_id)));\n         parent\n     }\n \n@@ -588,13 +453,13 @@ impl<'hir> Map<'hir> {\n \n     pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemKind::Const(..), .. }) |\n-            NodeTraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n-            NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n-            NodeAnonConst(_) => {\n+            Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n+            Node::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n+            Node::ImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n+            Node::AnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n-            NodeItem(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n+            Node::Item(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n                 BodyOwnerKind::Static(m)\n             }\n             // Default to function if it's not a constant or static.\n@@ -604,8 +469,8 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemKind::Trait(..), .. }) => id,\n-            NodeGenericParam(_) => self.get_parent_node(id),\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n+            Node::GenericParam(_) => self.get_parent_node(id),\n             _ => {\n                 bug!(\"ty_param_owner: {} not a type parameter\",\n                     self.node_to_string(id))\n@@ -615,10 +480,10 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemKind::Trait(..), .. }) => {\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n-            NodeGenericParam(param) => param.name.ident().name,\n+            Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n@@ -669,9 +534,9 @@ impl<'hir> Map<'hir> {\n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics> {\n         self.get_if_local(id).and_then(|node| {\n             match node {\n-                NodeImplItem(ref impl_item) => Some(&impl_item.generics),\n-                NodeTraitItem(ref trait_item) => Some(&trait_item.generics),\n-                NodeItem(ref item) => {\n+                Node::ImplItem(ref impl_item) => Some(&impl_item.generics),\n+                Node::TraitItem(ref trait_item) => Some(&trait_item.generics),\n+                Node::Item(ref item) => {\n                     match item.node {\n                         ItemKind::Fn(_, _, ref generics, _) |\n                         ItemKind::Ty(_, ref generics) |\n@@ -696,7 +561,13 @@ impl<'hir> Map<'hir> {\n     /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n-        let result = self.find_entry(id).and_then(|x| x.to_node());\n+        let result = self.find_entry(id).and_then(|entry| {\n+            if let Node::Crate = entry.node {\n+                None\n+            } else {\n+                Some(entry.node)\n+            }\n+        });\n         if result.is_some() {\n             self.read(id);\n         }\n@@ -727,14 +598,14 @@ impl<'hir> Map<'hir> {\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: NodeId) -> bool {\n         match self.find(id) {\n-            Some(NodeBinding(_)) => (),\n+            Some(Node::Binding(_)) => (),\n             _ => return false,\n         }\n         match self.find(self.get_parent_node(id)) {\n-            Some(NodeItem(_)) |\n-            Some(NodeTraitItem(_)) |\n-            Some(NodeImplItem(_)) => true,\n-            Some(NodeExpr(e)) => {\n+            Some(Node::Item(_)) |\n+            Some(Node::TraitItem(_)) |\n+            Some(Node::ImplItem(_)) => true,\n+            Some(Node::Expr(e)) => {\n                 match e.node {\n                     ExprKind::Closure(..) => true,\n                     _ => false,\n@@ -766,24 +637,19 @@ impl<'hir> Map<'hir> {\n                 return Err(id);\n             }\n \n-            let node = self.find_entry(parent_node);\n-            if node.is_none() {\n-                return Err(id);\n-            }\n-            let node = node.unwrap().to_node();\n-            match node {\n-                Some(ref node) => {\n-                    if found(node) {\n-                        return Ok(parent_node);\n-                    } else if bail_early(node) {\n-                        return Err(parent_node);\n-                    }\n+            if let Some(entry) = self.find_entry(parent_node) {\n+                if let Node::Crate = entry.node {\n+                    return Err(id);\n                 }\n-                None => {\n+                if found(&entry.node) {\n+                    return Ok(parent_node);\n+                } else if bail_early(&entry.node) {\n                     return Err(parent_node);\n                 }\n+                id = parent_node;\n+            } else {\n+                return Err(id);\n             }\n-            id = parent_node;\n         }\n     }\n \n@@ -812,16 +678,16 @@ impl<'hir> Map<'hir> {\n     pub fn get_return_block(&self, id: NodeId) -> Option<NodeId> {\n         let match_fn = |node: &Node| {\n             match *node {\n-                NodeItem(_) |\n-                NodeForeignItem(_) |\n-                NodeTraitItem(_) |\n-                NodeImplItem(_) => true,\n+                Node::Item(_) |\n+                Node::ForeignItem(_) |\n+                Node::TraitItem(_) |\n+                Node::ImplItem(_) => true,\n                 _ => false,\n             }\n         };\n         let match_non_returning_block = |node: &Node| {\n             match *node {\n-                NodeExpr(ref expr) => {\n+                Node::Expr(ref expr) => {\n                     match expr.node {\n                         ExprKind::While(..) | ExprKind::Loop(..) => true,\n                         _ => false,\n@@ -843,10 +709,10 @@ impl<'hir> Map<'hir> {\n     /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n-            NodeItem(_) |\n-            NodeForeignItem(_) |\n-            NodeTraitItem(_) |\n-            NodeImplItem(_) => true,\n+            Node::Item(_) |\n+            Node::ForeignItem(_) |\n+            Node::TraitItem(_) |\n+            Node::ImplItem(_) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -858,7 +724,7 @@ impl<'hir> Map<'hir> {\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n         let id = match self.walk_parent_nodes(id, |node| match *node {\n-            NodeItem(&Item { node: ItemKind::Mod(_), .. }) => true,\n+            Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -873,11 +739,11 @@ impl<'hir> Map<'hir> {\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n         match self.walk_parent_nodes(id, |node| match *node {\n-            NodeItem(_) |\n-            NodeForeignItem(_) |\n-            NodeTraitItem(_) |\n-            NodeImplItem(_) |\n-            NodeBlock(_) => true,\n+            Node::Item(_) |\n+            Node::ForeignItem(_) |\n+            Node::TraitItem(_) |\n+            Node::ImplItem(_) |\n+            Node::Block(_) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => Some(id),\n@@ -891,49 +757,43 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n-        let abi = match self.find_entry(parent) {\n-            Some(EntryItem(_, _, i)) => {\n-                match i.node {\n-                    ItemKind::ForeignMod(ref nm) => Some(nm.abi),\n-                    _ => None\n+        if let Some(entry) = self.find_entry(parent) {\n+            match entry {\n+                Entry { node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. }\n+                    => {\n+                    self.read(id); // reveals some of the content of a node\n+                    return nm.abi;\n                 }\n+                _ => {}\n             }\n-            _ => None\n-        };\n-        match abi {\n-            Some(abi) => {\n-                self.read(id); // reveals some of the content of a node\n-                abi\n-            }\n-            None => bug!(\"expected foreign mod or inlined parent, found {}\",\n-                          self.node_to_string(parent))\n         }\n+        bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n     pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n         match self.find(id) { // read recorded by `find`\n-            Some(NodeItem(item)) => item,\n+            Some(Node::Item(item)) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: NodeId) -> &'hir ImplItem {\n         match self.find(id) {\n-            Some(NodeImplItem(item)) => item,\n+            Some(Node::ImplItem(item)) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: NodeId) -> &'hir TraitItem {\n         match self.find(id) {\n-            Some(NodeTraitItem(item)) => item,\n+            Some(Node::TraitItem(item)) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_variant_data(&self, id: NodeId) -> &'hir VariantData {\n         match self.find(id) {\n-            Some(NodeItem(i)) => {\n+            Some(Node::Item(i)) => {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n@@ -943,8 +803,8 @@ impl<'hir> Map<'hir> {\n                     }\n                 }\n             }\n-            Some(NodeStructCtor(data)) => data,\n-            Some(NodeVariant(variant)) => &variant.node.data,\n+            Some(Node::StructCtor(data)) => data,\n+            Some(Node::Variant(variant)) => &variant.node.data,\n             _ => {\n                 bug!(\"expected struct or variant, found {}\",\n                      self.node_to_string(id));\n@@ -954,38 +814,38 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_variant(&self, id: NodeId) -> &'hir Variant {\n         match self.find(id) {\n-            Some(NodeVariant(variant)) => variant,\n+            Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: NodeId) -> &'hir ForeignItem {\n         match self.find(id) {\n-            Some(NodeForeignItem(item)) => item,\n+            Some(Node::ForeignItem(item)) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_expr(&self, id: NodeId) -> &'hir Expr {\n         match self.find(id) { // read recorded by find\n-            Some(NodeExpr(expr)) => expr,\n+            Some(Node::Expr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            NodeItem(i) => i.name,\n-            NodeForeignItem(i) => i.name,\n-            NodeImplItem(ii) => ii.ident.name,\n-            NodeTraitItem(ti) => ti.ident.name,\n-            NodeVariant(v) => v.node.name,\n-            NodeField(f) => f.ident.name,\n-            NodeLifetime(lt) => lt.name.ident().name,\n-            NodeGenericParam(param) => param.name.ident().name,\n-            NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.name,\n-            NodeStructCtor(_) => self.name(self.get_parent(id)),\n+            Node::Item(i) => i.name,\n+            Node::ForeignItem(i) => i.name,\n+            Node::ImplItem(ii) => ii.ident.name,\n+            Node::TraitItem(ti) => ti.ident.name,\n+            Node::Variant(v) => v.node.name,\n+            Node::Field(f) => f.ident.name,\n+            Node::Lifetime(lt) => lt.name.ident().name,\n+            Node::GenericParam(param) => param.name.ident().name,\n+            Node::Binding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.name,\n+            Node::StructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n@@ -995,18 +855,18 @@ impl<'hir> Map<'hir> {\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find(id) {\n-            Some(NodeItem(i)) => Some(&i.attrs[..]),\n-            Some(NodeForeignItem(fi)) => Some(&fi.attrs[..]),\n-            Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n-            Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n-            Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n-            Some(NodeField(ref f)) => Some(&f.attrs[..]),\n-            Some(NodeExpr(ref e)) => Some(&*e.attrs),\n-            Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n-            Some(NodeGenericParam(param)) => Some(&param.attrs[..]),\n+            Some(Node::Item(i)) => Some(&i.attrs[..]),\n+            Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n+            Some(Node::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n+            Some(Node::ImplItem(ref ii)) => Some(&ii.attrs[..]),\n+            Some(Node::Variant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n+            Some(Node::Expr(ref e)) => Some(&*e.attrs),\n+            Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n+            Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n-            Some(NodeStructCtor(_)) => {\n+            Some(Node::StructCtor(_)) => {\n                 return self.attrs(self.get_parent(id));\n             }\n             _ => None\n@@ -1033,35 +893,33 @@ impl<'hir> Map<'hir> {\n \n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n-        match self.find_entry(id) {\n-            Some(EntryItem(_, _, item)) => item.span,\n-            Some(EntryForeignItem(_, _, foreign_item)) => foreign_item.span,\n-            Some(EntryTraitItem(_, _, trait_method)) => trait_method.span,\n-            Some(EntryImplItem(_, _, impl_item)) => impl_item.span,\n-            Some(EntryVariant(_, _, variant)) => variant.span,\n-            Some(EntryField(_, _, field)) => field.span,\n-            Some(EntryAnonConst(_, _, constant)) => self.body(constant.body).value.span,\n-            Some(EntryExpr(_, _, expr)) => expr.span,\n-            Some(EntryStmt(_, _, stmt)) => stmt.span,\n-            Some(EntryTy(_, _, ty)) => ty.span,\n-            Some(EntryTraitRef(_, _, tr)) => tr.path.span,\n-            Some(EntryBinding(_, _, pat)) => pat.span,\n-            Some(EntryPat(_, _, pat)) => pat.span,\n-            Some(EntryBlock(_, _, block)) => block.span,\n-            Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n-            Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n-            Some(EntryGenericParam(_, _, param)) => param.span,\n-            Some(EntryVisibility(_, _, &Spanned {\n+        match self.find_entry(id).map(|entry| entry.node) {\n+            Some(Node::Item(item)) => item.span,\n+            Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n+            Some(Node::TraitItem(trait_method)) => trait_method.span,\n+            Some(Node::ImplItem(impl_item)) => impl_item.span,\n+            Some(Node::Variant(variant)) => variant.span,\n+            Some(Node::Field(field)) => field.span,\n+            Some(Node::AnonConst(constant)) => self.body(constant.body).value.span,\n+            Some(Node::Expr(expr)) => expr.span,\n+            Some(Node::Stmt(stmt)) => stmt.span,\n+            Some(Node::Ty(ty)) => ty.span,\n+            Some(Node::TraitRef(tr)) => tr.path.span,\n+            Some(Node::Binding(pat)) => pat.span,\n+            Some(Node::Pat(pat)) => pat.span,\n+            Some(Node::Block(block)) => block.span,\n+            Some(Node::StructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n+            Some(Node::Lifetime(lifetime)) => lifetime.span,\n+            Some(Node::GenericParam(param)) => param.span,\n+            Some(Node::Visibility(&Spanned {\n                 node: VisibilityKind::Restricted { ref path, .. }, ..\n             })) => path.span,\n-            Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n-            Some(EntryLocal(_, _, local)) => local.span,\n-            Some(EntryMacroDef(_, macro_def)) => macro_def.span,\n+            Some(Node::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n+            Some(Node::Local(local)) => local.span,\n+            Some(Node::MacroDef(macro_def)) => macro_def.span,\n \n-            Some(RootCrate(_)) => self.forest.krate.span,\n-            Some(NotPresent) | None => {\n-                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n-            }\n+            Some(Node::Crate) => self.forest.krate.span,\n+            None => bug!(\"hir::map::Map::span: id not in map: {:?}\", id),\n         }\n     }\n \n@@ -1119,7 +977,7 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n         fn find_first_mod_parent<'a>(map: &'a Map, mut id: NodeId) -> Option<(NodeId, Name)> {\n             loop {\n                 match map.find(id)? {\n-                    NodeItem(item) if item_is_mod(&item) =>\n+                    Node::Item(item) if item_is_mod(&item) =>\n                         return Some((id, item.name)),\n                     _ => {}\n                 }\n@@ -1154,13 +1012,13 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n                 return None;\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n-            let name = match self.map.find_entry(idx) {\n-                Some(EntryItem(_, _, n))       => n.name(),\n-                Some(EntryForeignItem(_, _, n))=> n.name(),\n-                Some(EntryTraitItem(_, _, n))  => n.name(),\n-                Some(EntryImplItem(_, _, n))   => n.name(),\n-                Some(EntryVariant(_, _, n))    => n.name(),\n-                Some(EntryField(_, _, n))      => n.name(),\n+            let name = match self.map.find_entry(idx).map(|entry| entry.node) {\n+                Some(Node::Item(n)) => n.name(),\n+                Some(Node::ForeignItem(n)) => n.name(),\n+                Some(Node::TraitItem(n)) => n.name(),\n+                Some(Node::ImplItem(n)) => n.name(),\n+                Some(Node::Variant(n)) => n.name(),\n+                Some(Node::Field(n)) => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -1209,12 +1067,8 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n     if log_enabled!(::log::Level::Debug) {\n         // This only makes sense for ordered stores; note the\n         // enumerate to count the number of entries.\n-        let (entries_less_1, _) = map.iter().filter(|&x| {\n-            match *x {\n-                NotPresent => false,\n-                _ => true\n-            }\n-        }).enumerate().last().expect(\"AST map was empty after folding?\");\n+        let (entries_less_1, _) = map.iter().filter_map(|x| *x).enumerate().last()\n+            .expect(\"AST map was empty after folding?\");\n \n         let entries = entries_less_1 + 1;\n         let vector_length = map.len();\n@@ -1257,19 +1111,19 @@ impl<'hir> print::PpAnn for Map<'hir> {\n impl<'a> print::State<'a> {\n     pub fn print_node(&mut self, node: Node) -> io::Result<()> {\n         match node {\n-            NodeItem(a)         => self.print_item(&a),\n-            NodeForeignItem(a)  => self.print_foreign_item(&a),\n-            NodeTraitItem(a)    => self.print_trait_item(a),\n-            NodeImplItem(a)     => self.print_impl_item(a),\n-            NodeVariant(a)      => self.print_variant(&a),\n-            NodeAnonConst(a)    => self.print_anon_const(&a),\n-            NodeExpr(a)         => self.print_expr(&a),\n-            NodeStmt(a)         => self.print_stmt(&a),\n-            NodeTy(a)           => self.print_type(&a),\n-            NodeTraitRef(a)     => self.print_trait_ref(&a),\n-            NodeBinding(a)       |\n-            NodePat(a)          => self.print_pat(&a),\n-            NodeBlock(a)        => {\n+            Node::Item(a)         => self.print_item(&a),\n+            Node::ForeignItem(a)  => self.print_foreign_item(&a),\n+            Node::TraitItem(a)    => self.print_trait_item(a),\n+            Node::ImplItem(a)     => self.print_impl_item(a),\n+            Node::Variant(a)      => self.print_variant(&a),\n+            Node::AnonConst(a)    => self.print_anon_const(&a),\n+            Node::Expr(a)         => self.print_expr(&a),\n+            Node::Stmt(a)         => self.print_stmt(&a),\n+            Node::Ty(a)           => self.print_type(&a),\n+            Node::TraitRef(a)     => self.print_trait_ref(&a),\n+            Node::Binding(a)      |\n+            Node::Pat(a)          => self.print_pat(&a),\n+            Node::Block(a)        => {\n                 use syntax::print::pprust::PrintState;\n \n                 // containing cbox, will be closed by print-block at }\n@@ -1278,16 +1132,17 @@ impl<'a> print::State<'a> {\n                 self.ibox(0)?;\n                 self.print_block(&a)\n             }\n-            NodeLifetime(a)     => self.print_lifetime(&a),\n-            NodeVisibility(a)   => self.print_visibility(&a),\n-            NodeGenericParam(_) => bug!(\"cannot print NodeGenericParam\"),\n-            NodeField(_)        => bug!(\"cannot print StructField\"),\n+            Node::Lifetime(a)     => self.print_lifetime(&a),\n+            Node::Visibility(a)   => self.print_visibility(&a),\n+            Node::GenericParam(_) => bug!(\"cannot print Node::GenericParam\"),\n+            Node::Field(_)        => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // hir_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeStructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n-            NodeLocal(a)        => self.print_local_decl(&a),\n-            NodeMacroDef(_)     => bug!(\"cannot print MacroDef\"),\n+            Node::StructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n+            Node::Local(a)        => self.print_local_decl(&a),\n+            Node::MacroDef(_)     => bug!(\"cannot print MacroDef\"),\n+            Node::Crate     => bug!(\"cannot print Crate\"),\n         }\n     }\n }\n@@ -1313,7 +1168,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     };\n \n     match map.find(id) {\n-        Some(NodeItem(item)) => {\n+        Some(Node::Item(item)) => {\n             let item_str = match item.node {\n                 ItemKind::ExternCrate(..) => \"extern crate\",\n                 ItemKind::Use(..) => \"use\",\n@@ -1334,10 +1189,10 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             };\n             format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }\n-        Some(NodeForeignItem(_)) => {\n+        Some(Node::ForeignItem(_)) => {\n             format!(\"foreign item {}{}\", path_str(), id_str)\n         }\n-        Some(NodeImplItem(ii)) => {\n+        Some(Node::ImplItem(ii)) => {\n             match ii.node {\n                 ImplItemKind::Const(..) => {\n                     format!(\"assoc const {} in {}{}\", ii.ident, path_str(), id_str)\n@@ -1353,7 +1208,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 }\n             }\n         }\n-        Some(NodeTraitItem(ti)) => {\n+        Some(Node::TraitItem(ti)) => {\n             let kind = match ti.node {\n                 TraitItemKind::Const(..) => \"assoc constant\",\n                 TraitItemKind::Method(..) => \"trait method\",\n@@ -1362,61 +1217,60 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n \n             format!(\"{} {} in {}{}\", kind, ti.ident, path_str(), id_str)\n         }\n-        Some(NodeVariant(ref variant)) => {\n+        Some(Node::Variant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n                     variant.node.name,\n                     path_str(), id_str)\n         }\n-        Some(NodeField(ref field)) => {\n+        Some(Node::Field(ref field)) => {\n             format!(\"field {} in {}{}\",\n                     field.ident,\n                     path_str(), id_str)\n         }\n-        Some(NodeAnonConst(_)) => {\n+        Some(Node::AnonConst(_)) => {\n             format!(\"const {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeExpr(_)) => {\n+        Some(Node::Expr(_)) => {\n             format!(\"expr {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeStmt(_)) => {\n+        Some(Node::Stmt(_)) => {\n             format!(\"stmt {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTy(_)) => {\n+        Some(Node::Ty(_)) => {\n             format!(\"type {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTraitRef(_)) => {\n+        Some(Node::TraitRef(_)) => {\n             format!(\"trait_ref {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeBinding(_)) => {\n+        Some(Node::Binding(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodePat(_)) => {\n+        Some(Node::Pat(_)) => {\n             format!(\"pat {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeBlock(_)) => {\n+        Some(Node::Block(_)) => {\n             format!(\"block {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeLocal(_)) => {\n+        Some(Node::Local(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeStructCtor(_)) => {\n+        Some(Node::StructCtor(_)) => {\n             format!(\"struct_ctor {}{}\", path_str(), id_str)\n         }\n-        Some(NodeLifetime(_)) => {\n+        Some(Node::Lifetime(_)) => {\n             format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeGenericParam(ref param)) => {\n+        Some(Node::GenericParam(ref param)) => {\n             format!(\"generic_param {:?}{}\", param, id_str)\n         }\n-        Some(NodeVisibility(ref vis)) => {\n+        Some(Node::Visibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n-        Some(NodeMacroDef(_)) => {\n+        Some(Node::MacroDef(_)) => {\n             format!(\"macro {}{}\",  path_str(), id_str)\n         }\n-        None => {\n-            format!(\"unknown node{}\", id_str)\n-        }\n+        Some(Node::Crate) => format!(\"root_crate\"),\n+        None => format!(\"unknown node{}\", id_str),\n     }\n }\n "}, {"sha": "7ac334d84a9bfdd2401f6f5734a044f4d4f7aad0", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -2370,3 +2370,32 @@ impl CodegenFnAttrs {\n         self.flags.contains(CodegenFnAttrFlags::NO_MANGLE) || self.export_name.is_some()\n     }\n }\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Node<'hir> {\n+    Item(&'hir Item),\n+    ForeignItem(&'hir ForeignItem),\n+    TraitItem(&'hir TraitItem),\n+    ImplItem(&'hir ImplItem),\n+    Variant(&'hir Variant),\n+    Field(&'hir StructField),\n+    AnonConst(&'hir AnonConst),\n+    Expr(&'hir Expr),\n+    Stmt(&'hir Stmt),\n+    Ty(&'hir Ty),\n+    TraitRef(&'hir TraitRef),\n+    Binding(&'hir Pat),\n+    Pat(&'hir Pat),\n+    Block(&'hir Block),\n+    Local(&'hir Local),\n+    MacroDef(&'hir MacroDef),\n+\n+    /// StructCtor represents a tuple struct.\n+    StructCtor(&'hir VariantData),\n+\n+    Lifetime(&'hir Lifetime),\n+    GenericParam(&'hir GenericParam),\n+    Visibility(&'hir Visibility),\n+\n+    Crate,\n+}"}, {"sha": "8b221f3463ed334d27a2cc39fa7e1b714dc10b18", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::AnnNode::*;\n-\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::source_map::{SourceMap, Spanned};\n@@ -33,12 +31,12 @@ use std::iter::Peekable;\n use std::vec;\n \n pub enum AnnNode<'a> {\n-    NodeName(&'a ast::Name),\n-    NodeBlock(&'a hir::Block),\n-    NodeItem(&'a hir::Item),\n-    NodeSubItem(ast::NodeId),\n-    NodeExpr(&'a hir::Expr),\n-    NodePat(&'a hir::Pat),\n+    Name(&'a ast::Name),\n+    Block(&'a hir::Block),\n+    Item(&'a hir::Item),\n+    SubItem(ast::NodeId),\n+    Expr(&'a hir::Expr),\n+    Pat(&'a hir::Pat),\n }\n \n pub enum Nested {\n@@ -529,7 +527,7 @@ impl<'a> State<'a> {\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(item.span.lo())?;\n         self.print_outer_attributes(&item.attrs)?;\n-        self.ann.pre(self, NodeItem(item))?;\n+        self.ann.pre(self, AnnNode::Item(item))?;\n         match item.node {\n             hir::ItemKind::ExternCrate(orig_name) => {\n                 self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n@@ -768,7 +766,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n             }\n         }\n-        self.ann.post(self, NodeItem(item))\n+        self.ann.post(self, AnnNode::Item(item))\n     }\n \n     pub fn print_trait_ref(&mut self, t: &hir::TraitRef) -> io::Result<()> {\n@@ -933,7 +931,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem) -> io::Result<()> {\n-        self.ann.pre(self, NodeSubItem(ti.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ti.id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ti.span.lo())?;\n         self.print_outer_attributes(&ti.attrs)?;\n@@ -965,11 +963,11 @@ impl<'a> State<'a> {\n                                            default.as_ref().map(|ty| &**ty))?;\n             }\n         }\n-        self.ann.post(self, NodeSubItem(ti.id))\n+        self.ann.post(self, AnnNode::SubItem(ti.id))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n-        self.ann.pre(self, NodeSubItem(ii.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ii.span.lo())?;\n         self.print_outer_attributes(&ii.attrs)?;\n@@ -995,7 +993,7 @@ impl<'a> State<'a> {\n                 self.print_associated_type(ii.ident, Some(bounds), None)?;\n             }\n         }\n-        self.ann.post(self, NodeSubItem(ii.id))\n+        self.ann.post(self, AnnNode::SubItem(ii.id))\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {\n@@ -1055,7 +1053,7 @@ impl<'a> State<'a> {\n             hir::DefaultBlock => (),\n         }\n         self.maybe_print_comment(blk.span.lo())?;\n-        self.ann.pre(self, NodeBlock(blk))?;\n+        self.ann.pre(self, AnnNode::Block(blk))?;\n         self.bopen()?;\n \n         self.print_inner_attributes(attrs)?;\n@@ -1072,7 +1070,7 @@ impl<'a> State<'a> {\n             _ => (),\n         }\n         self.bclose_maybe_open(blk.span, indented, close_box)?;\n-        self.ann.post(self, NodeBlock(blk))\n+        self.ann.post(self, AnnNode::Block(blk))\n     }\n \n     fn print_else(&mut self, els: Option<&hir::Expr>) -> io::Result<()> {\n@@ -1321,7 +1319,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(expr.span.lo())?;\n         self.print_outer_attributes(&expr.attrs)?;\n         self.ibox(indent_unit)?;\n-        self.ann.pre(self, NodeExpr(expr))?;\n+        self.ann.pre(self, AnnNode::Expr(expr))?;\n         match expr.node {\n             hir::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\")?;\n@@ -1559,7 +1557,7 @@ impl<'a> State<'a> {\n                 self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }\n         }\n-        self.ann.post(self, NodeExpr(expr))?;\n+        self.ann.post(self, AnnNode::Expr(expr))?;\n         self.end()\n     }\n \n@@ -1606,7 +1604,7 @@ impl<'a> State<'a> {\n         } else {\n             self.s.word(&ident.as_str())?;\n         }\n-        self.ann.post(self, NodeName(&ident.name))\n+        self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n@@ -1774,7 +1772,7 @@ impl<'a> State<'a> {\n \n     pub fn print_pat(&mut self, pat: &hir::Pat) -> io::Result<()> {\n         self.maybe_print_comment(pat.span.lo())?;\n-        self.ann.pre(self, NodePat(pat))?;\n+        self.ann.pre(self, AnnNode::Pat(pat))?;\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n         match pat.node {\n@@ -1928,7 +1926,7 @@ impl<'a> State<'a> {\n                 self.s.word(\"]\")?;\n             }\n         }\n-        self.ann.post(self, NodePat(pat))\n+        self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n     fn print_arm(&mut self, arm: &hir::Arm) -> io::Result<()> {"}, {"sha": "8eab07ece05ef24219901d3e0ddab8eca7931b1e", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use hir;\n+use hir::Node;\n use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n@@ -697,7 +698,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             parent_def_id == tcx.hir.local_def_id(anon_parent_node_id)\n                         };\n                         let in_definition_scope = match tcx.hir.find(anon_node_id) {\n-                            Some(hir::map::NodeItem(item)) => match item.node {\n+                            Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: Some(parent),\n@@ -714,7 +715,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n-                            Some(hir::map::NodeImplItem(item)) => match item.node {\n+                            Some(Node::ImplItem(item)) => match item.node {\n                                 hir::ImplItemKind::Existential(_) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,"}, {"sha": "cf0d0ceadca910b68e2c029698f1ed86af7b819c", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -62,7 +62,7 @@ use super::lexical_region_resolve::RegionResolutionError;\n \n use std::{cmp, fmt};\n use hir;\n-use hir::map as hir_map;\n+use hir::Node;\n use hir::def_id::DefId;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n@@ -100,8 +100,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n-                    Some(hir_map::NodeBlock(_)) => \"block\",\n-                    Some(hir_map::NodeExpr(expr)) => match expr.node {\n+                    Some(Node::Block(_)) => \"block\",\n+                    Some(Node::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n                         hir::ExprKind::MethodCall(..) => \"method call\",\n                         hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n@@ -110,10 +110,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         hir::ExprKind::Match(..) => \"match\",\n                         _ => \"expression\",\n                     },\n-                    Some(hir_map::NodeStmt(_)) => \"statement\",\n-                    Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n-                    Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n-                    Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n+                    Some(Node::Stmt(_)) => \"statement\",\n+                    Some(Node::Item(it)) => Self::item_scope_tag(&it),\n+                    Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n+                    Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -194,10 +194,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n         let tag = match self.hir.find(node) {\n-            Some(hir_map::NodeBlock(_)) | Some(hir_map::NodeExpr(_)) => \"body\",\n-            Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n-            Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n-            Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n+            Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n+            Some(Node::Item(it)) => Self::item_scope_tag(&it),\n+            Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n+            Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n             _ => unreachable!()\n         };\n         let (prefix, span) = match *region {\n@@ -1127,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let hir_map::NodeGenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(ref param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "e3faf755672a10c55916cd51f101faddd15de726", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -10,7 +10,7 @@\n \n use hir;\n use ty::{self, Region, TyCtxt};\n-use hir::map as hir_map;\n+use hir::Node;\n use middle::resolve_lifetime as rl;\n use hir::intravisit::{self, NestedVisitorMap, Visitor};\n use infer::error_reporting::nice_region_error::NiceRegionError;\n@@ -40,15 +40,15 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let fndecl = match self.tcx.hir.get(node_id) {\n-                    hir_map::NodeItem(&hir::Item {\n+                    Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n                     }) => &fndecl,\n-                    hir_map::NodeTraitItem(&hir::TraitItem {\n+                    Node::TraitItem(&hir::TraitItem {\n                         node: hir::TraitItemKind::Method(ref m, ..),\n                         ..\n                     })\n-                    | hir_map::NodeImplItem(&hir::ImplItem {\n+                    | Node::ImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(ref m, ..),\n                         ..\n                     }) => &m.decl,"}, {"sha": "5c27cdb6fb55392198cb30678f1895d81b4ff040", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -15,7 +15,7 @@ use infer::error_reporting::nice_region_error::NiceRegionError;\n use infer::SubregionOrigin;\n use ty::RegionKind;\n use hir::{Expr, ExprKind::Closure};\n-use hir::map::NodeExpr;\n+use hir::Node;\n use util::common::ErrorReported;\n use infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n \n@@ -59,7 +59,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 let hir = &self.tcx.hir;\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     match hir.get(node_id) {\n-                        NodeExpr(Expr {\n+                        Node::Expr(Expr {\n                             node: Closure(_, _, _, closure_span, None),\n                             ..\n                         }) => {"}, {"sha": "30406f1fec55cd208ce6c56779f64c84deaa17b4", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -10,11 +10,12 @@\n \n //! Helper functions corresponding to lifetime errors due to\n //! anonymous regions.\n+\n use hir;\n use infer::error_reporting::nice_region_error::NiceRegionError;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n-use hir::map as hir_map;\n+use hir::Node;\n use syntax_pos::Span;\n \n // The struct contains the information about the anonymous region\n@@ -137,8 +138,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             .as_local_node_id(suitable_region_binding_scope)\n             .unwrap();\n         let is_impl_item = match self.tcx.hir.find(node_id) {\n-            Some(hir_map::NodeItem(..)) | Some(hir_map::NodeTraitItem(..)) => false,\n-            Some(hir_map::NodeImplItem(..)) => {\n+            Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n+            Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n             }\n             _ => return None,"}, {"sha": "d320173f9f47d01d95361323f5e58db16819f902", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -12,7 +12,7 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n-use hir::map as hir_map;\n+use hir::Node;\n use hir::{self, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -29,16 +29,16 @@ use syntax::attr;\n use syntax_pos;\n \n // Any local node that may call something in its body block should be\n-// explored. For example, if it's a live NodeItem that is a\n+// explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             node_id: ast::NodeId) -> bool {\n     match tcx.hir.find(node_id) {\n-        Some(hir_map::NodeItem(..)) |\n-        Some(hir_map::NodeImplItem(..)) |\n-        Some(hir_map::NodeForeignItem(..)) |\n-        Some(hir_map::NodeTraitItem(..)) =>\n+        Some(Node::Item(..)) |\n+        Some(Node::ImplItem(..)) |\n+        Some(Node::ForeignItem(..)) |\n+        Some(Node::TraitItem(..)) =>\n             true,\n         _ =>\n             false\n@@ -145,13 +145,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &hir_map::Node<'tcx>) {\n+    fn visit_node(&mut self, node: &Node<'tcx>) {\n         let had_repr_c = self.repr_has_repr_c;\n         self.repr_has_repr_c = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n         self.inherited_pub_visibility = false;\n         match *node {\n-            hir_map::NodeItem(item) => {\n+            Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -173,13 +173,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     _ => ()\n                 }\n             }\n-            hir_map::NodeTraitItem(trait_item) => {\n+            Node::TraitItem(trait_item) => {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n-            hir_map::NodeImplItem(impl_item) => {\n+            Node::ImplItem(impl_item) => {\n                 intravisit::walk_impl_item(self, impl_item);\n             }\n-            hir_map::NodeForeignItem(foreign_item) => {\n+            Node::ForeignItem(foreign_item) => {\n                 intravisit::walk_foreign_item(self, &foreign_item);\n             }\n             _ => ()"}, {"sha": "2697d62cf467aa0d4cf857cc018db30fb5e0c6db", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -102,11 +102,13 @@\n //!   only dead if the end of the function's block can never be reached.\n //!   It is the responsibility of typeck to ensure that there are no\n //!   `return` expressions in a function declared as diverging.\n+\n use self::LoopKind::*;\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n use hir::def::*;\n+use hir::Node;\n use ty::{self, TyCtxt};\n use lint;\n use errors::Applicability;\n@@ -362,7 +364,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir.get_parent(id);\n-        if let Some(hir::map::Node::NodeItem(i)) = ir.tcx.hir.find(parent) {\n+        if let Some(Node::Item(i)) = ir.tcx.hir.find(parent) {\n             if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n                 return;\n             }"}, {"sha": "b63cde0f205f78031363d851a4e6d718291f8620", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -70,7 +70,7 @@ use self::Aliasability::*;\n \n use middle::region;\n use hir::def_id::{DefId, LocalDefId};\n-use hir::map as hir_map;\n+use hir::Node;\n use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n use ty::adjustment;\n@@ -343,7 +343,7 @@ impl MutabilityCategory {\n \n     fn from_local(tcx: TyCtxt, tables: &ty::TypeckTables, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n-            hir_map::NodeBinding(p) => match p.node {\n+            Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)"}, {"sha": "55ee8987e8ad54ccbe49313878ef403d7888e3b8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -16,7 +16,7 @@\n // reachable as well.\n \n use hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n-use hir::map as hir_map;\n+use hir::Node;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n@@ -64,7 +64,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n-            Some(hir_map::NodeItem(item)) =>\n+            Some(Node::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n@@ -156,22 +156,22 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         };\n \n         match self.tcx.hir.find(node_id) {\n-            Some(hir_map::NodeItem(item)) => {\n+            Some(Node::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n                         item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n-            Some(hir_map::NodeTraitItem(trait_method)) => {\n+            Some(Node::TraitItem(trait_method)) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n                     hir::TraitItemKind::Type(..) => false,\n                 }\n             }\n-            Some(hir_map::NodeImplItem(impl_item)) => {\n+            Some(Node::ImplItem(impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n@@ -219,12 +219,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &hir_map::Node<'tcx>,\n+    fn propagate_node(&mut self, node: &Node<'tcx>,\n                       search_item: ast::NodeId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n-            if let hir_map::NodeItem(item) = *node {\n+            if let Node::Item(item) = *node {\n                 let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.node {\n                     header.abi != Abi::Rust\n                 } else {\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n \n         match *node {\n-            hir_map::NodeItem(item) => {\n+            Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ItemKind::GlobalAsm(..) => {}\n                 }\n             }\n-            hir_map::NodeTraitItem(trait_method) => {\n+            Node::TraitItem(trait_method) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, None) |\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::TraitItemKind::Type(..) => {}\n                 }\n             }\n-            hir_map::NodeImplItem(impl_item) => {\n+            Node::ImplItem(impl_item) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(_, body) => {\n                         self.visit_nested_body(body);\n@@ -313,16 +313,16 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }\n-            hir_map::NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n+            Node::Expr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these\n-            hir_map::NodeForeignItem(_) |\n-            hir_map::NodeVariant(_) |\n-            hir_map::NodeStructCtor(_) |\n-            hir_map::NodeField(_) |\n-            hir_map::NodeTy(_) |\n-            hir_map::NodeMacroDef(_) => {}\n+            Node::ForeignItem(_) |\n+            Node::Variant(_) |\n+            Node::StructCtor(_) |\n+            Node::Field(_) |\n+            Node::Ty(_) |\n+            Node::MacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.hir.node_to_string(search_item))"}, {"sha": "20ee5f0b04635fbc8dae8d5ca02c75da6f584da6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -30,6 +30,7 @@ use ty::TyCtxt;\n use ty::query::Providers;\n \n use hir;\n+use hir::Node;\n use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n@@ -257,7 +258,7 @@ impl Scope {\n         }\n         let span = tcx.hir.span(node_id);\n         if let ScopeData::Remainder(r) = self.data() {\n-            if let hir::map::NodeBlock(ref blk) = tcx.hir.get(node_id) {\n+            if let Node::Block(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -1420,8 +1421,8 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n         match tcx.hir.get(id) {\n-            hir::map::NodeImplItem(_) |\n-            hir::map::NodeTraitItem(_) => {\n+            Node::ImplItem(_) |\n+            Node::TraitItem(_) => {\n                 visitor.scope_tree.root_parent = Some(tcx.hir.get_parent(id));\n             }\n             _ => {}"}, {"sha": "d0f801e661b438d56bbff0798e8768a27b450e86", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -18,7 +18,7 @@\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use hir::map::Map;\n-use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName};\n+use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName, Node};\n use ty::{self, TyCtxt, GenericParamDefKind};\n \n use errors::DiagnosticBuilder;\n@@ -1440,10 +1440,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        hir::map::NodeLifetime(hir_lifetime) => {\n+                        Node::Lifetime(hir_lifetime) => {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n-                        hir::map::NodeGenericParam(param) => {\n+                        Node::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n@@ -1466,10 +1466,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 None => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        hir::map::NodeLifetime(hir_lifetime) => {\n+                        Node::Lifetime(hir_lifetime) => {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n-                        hir::map::NodeGenericParam(param) => {\n+                        Node::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n@@ -1643,15 +1643,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir.body_owner(body_id);\n                 match self.tcx.hir.get(fn_id) {\n-                    hir::map::NodeItem(&hir::Item {\n+                    Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n                     })\n-                    | hir::map::NodeTraitItem(&hir::TraitItem {\n+                    | Node::TraitItem(&hir::TraitItem {\n                         node: hir::TraitItemKind::Method(..),\n                         ..\n                     })\n-                    | hir::map::NodeImplItem(&hir::ImplItem {\n+                    | Node::ImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n@@ -1868,12 +1868,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let parent = self.tcx.hir.get_parent_node(output.id);\n         let body = match self.tcx.hir.get(parent) {\n             // `fn` definitions and methods.\n-            hir::map::NodeItem(&hir::Item {\n+            Node::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),\n                 ..\n             }) => Some(body),\n \n-            hir::map::NodeTraitItem(&hir::TraitItem {\n+            Node::TraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(_, ref m),\n                 ..\n             }) => {\n@@ -1896,7 +1896,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            hir::map::NodeImplItem(&hir::ImplItem {\n+            Node::ImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(_, body),\n                 ..\n             }) => {\n@@ -1918,7 +1918,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            hir::map::NodeForeignItem(_) | hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n+            Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => None,\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {"}, {"sha": "b34378151ccb32c9ea25a2acfcb7d55cc28eec78", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -29,6 +29,7 @@ use super::{\n \n use errors::{Applicability, DiagnosticBuilder};\n use hir;\n+use hir::Node;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n@@ -864,7 +865,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        err: &mut DiagnosticBuilder<'tcx>) {\n         if let &ObligationCauseCode::VariableType(node_id) = code {\n             let parent_node = self.tcx.hir.get_parent_node(node_id);\n-            if let Some(hir::map::NodeLocal(ref local)) = self.tcx.hir.find(parent_node) {\n+            if let Some(Node::Local(ref local)) = self.tcx.hir.find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n@@ -932,9 +933,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    pub fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n+    pub fn get_fn_like_arguments(&self, node: Node) -> (Span, Vec<ArgKind>) {\n         match node {\n-            hir::map::NodeExpr(&hir::Expr {\n+            Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n@@ -961,17 +962,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     })\n                     .collect::<Vec<ArgKind>>())\n             }\n-            hir::map::NodeItem(&hir::Item {\n+            Node::Item(&hir::Item {\n                 span,\n                 node: hir::ItemKind::Fn(ref decl, ..),\n                 ..\n             }) |\n-            hir::map::NodeImplItem(&hir::ImplItem {\n+            Node::ImplItem(&hir::ImplItem {\n                 span,\n                 node: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n             }) |\n-            hir::map::NodeTraitItem(&hir::TraitItem {\n+            Node::TraitItem(&hir::TraitItem {\n                 span,\n                 node: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n@@ -987,7 +988,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n                 }).collect::<Vec<ArgKind>>())\n             }\n-            hir::map::NodeVariant(&hir::Variant {\n+            Node::Variant(&hir::Variant {\n                 span,\n                 node: hir::VariantKind {\n                     data: hir::VariantData::Tuple(ref fields, _),\n@@ -1000,7 +1001,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                      ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n                  }).collect::<Vec<_>>())\n             }\n-            hir::map::NodeStructCtor(ref variant_data) => {\n+            Node::StructCtor(ref variant_data) => {\n                 (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n                  variant_data.fields()\n                     .iter().map(|_| ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned()))"}, {"sha": "63308ac46d10f4b7b28eb3a9e77756f6f587a5a0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -15,6 +15,7 @@ pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n use hir::{map as hir_map, FreevarMap, TraitMap};\n+use hir::Node;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use hir::map::DefPathData;\n@@ -2478,7 +2479,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n         match self.hir.find(id) {\n-            Some(hir_map::NodeExpr(e)) => {\n+            Some(Node::Expr(e)) => {\n                 e.span\n             }\n             Some(f) => {\n@@ -2505,7 +2506,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n         let is_associated_item = if let Some(node_id) = self.hir.as_local_node_id(def_id) {\n             match self.hir.get(node_id) {\n-                hir_map::NodeTraitItem(_) | hir_map::NodeImplItem(_) => true,\n+                Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n         } else {\n@@ -2895,7 +2896,7 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition\n pub fn is_impl_trait_defn(tcx: TyCtxt, def_id: DefId) -> Option<DefId> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let hir::map::NodeItem(item) = tcx.hir.get(node_id) {\n+        if let Node::Item(item) = tcx.hir.get(node_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }"}, {"sha": "f7679dc8ce0f02470a71112fbecc92572b38038e", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -12,8 +12,8 @@\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use hir::map::{DefPathData, Node};\n-use hir;\n+use hir::map::DefPathData;\n+use hir::{self, Node};\n use ich::NodeIdHashingMode;\n use traits::{self, ObligationCause};\n use ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n@@ -604,10 +604,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n         if let Some(node) = self.hir.get_if_local(def_id) {\n             match node {\n-                Node::NodeItem(&hir::Item {\n+                Node::Item(&hir::Item {\n                     node: hir::ItemKind::Static(_, mutbl, _), ..\n                 }) => Some(mutbl),\n-                Node::NodeForeignItem(&hir::ForeignItem {\n+                Node::ForeignItem(&hir::ForeignItem {\n                     node: hir::ForeignItemKind::Static(_, is_mutbl), ..\n                 }) =>\n                     Some(if is_mutbl {"}, {"sha": "1af117c97f569abbe829c82945a849bb40e262ed", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -16,6 +16,7 @@\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n+\n use self::UseError::*;\n \n use borrowck::*;\n@@ -29,6 +30,7 @@ use rustc::ty::{self, TyCtxt, RegionKind};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc::hir::Node;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::rc::Rc;\n@@ -201,7 +203,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n     let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let movable_generator = !match bccx.tcx.hir.get(node_id) {\n-        hir::map::Node::NodeExpr(&hir::Expr {\n+        Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => true,"}, {"sha": "ffc4fbfb4c9cb12839824eef37f04373f1dda358", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -24,7 +24,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::*;\n-use rustc::hir::map::Node::*;\n+use rustc::hir::Node;\n \n struct GatherMoveInfo<'c, 'tcx: 'c> {\n     id: hir::ItemLocalId,\n@@ -60,15 +60,15 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n     let parent = tcx.hir.get_parent_node(pat.id);\n \n     match tcx.hir.get(parent) {\n-        NodeExpr(ref e) => {\n+        Node::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n                         ExprKind::Match(..) => true,\n                         _ => return PatternSource::Other,\n                     });\n             PatternSource::MatchExpr(e)\n         }\n-        NodeLocal(local) => PatternSource::LetDecl(local),\n+        Node::Local(local) => PatternSource::LetDecl(local),\n         _ => return PatternSource::Other,\n \n     }"}, {"sha": "ad45c5429a512b3214a1a6544673f471f2150a88", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -21,7 +21,7 @@ pub use self::MovedValueUseKind::*;\n use self::InteriorKind::*;\n \n use rustc::hir::HirId;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::Node;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::cfg;\n use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n@@ -95,8 +95,8 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n \n     match tcx.hir.get(owner_id) {\n-        hir_map::NodeStructCtor(_) |\n-        hir_map::NodeVariant(_) => {\n+        Node::StructCtor(_) |\n+        Node::Variant(_) => {\n             // We get invoked with anything that has MIR, but some of\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body\n@@ -419,7 +419,7 @@ fn closure_to_block(closure_id: LocalDefId,\n                     tcx: TyCtxt) -> ast::NodeId {\n     let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n-        hir_map::NodeExpr(expr) => match expr.node {\n+        Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.node_id\n             }\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     let node =  self.tcx.hir.get(node_id);\n \n                     // This pattern probably always matches.\n-                    if let hir_map::NodeExpr(\n+                    if let Node::Expr(\n                         hir::Expr { node: hir::ExprKind::Index(lhs, _), ..}\n                     ) = node {\n                         let ty = self.tables.expr_ty(lhs);\n@@ -1032,7 +1032,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let ty::ReScope(scope) = *super_scope {\n                     let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n                     match self.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeStmt(_)) => {\n+                        Some(Node::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n                             }\n@@ -1183,7 +1183,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n         let pat = match self.tcx.hir.get(node_id) {\n-            hir_map::Node::NodeBinding(pat) => pat,\n+            Node::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n \n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => return\n                 };\n \n-                if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(node_id) {\n+                if let Node::Field(ref field) = self.tcx.hir.get(node_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }"}, {"sha": "832b69cb2acc4d53860505a9d9e11028ba1bdb40", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -117,12 +117,12 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeName(_) => return Ok(()),\n-            pprust::NodeExpr(expr) => expr.hir_id.local_id,\n-            pprust::NodeBlock(blk) => blk.hir_id.local_id,\n-            pprust::NodeItem(_) |\n-            pprust::NodeSubItem(_) => return Ok(()),\n-            pprust::NodePat(pat) => pat.hir_id.local_id\n+            pprust::AnnNode::Name(_) => return Ok(()),\n+            pprust::AnnNode::Expr(expr) => expr.hir_id.local_id,\n+            pprust::AnnNode::Block(blk) => blk.hir_id.local_id,\n+            pprust::AnnNode::Item(_) |\n+            pprust::AnnNode::SubItem(_) => return Ok(()),\n+            pprust::AnnNode::Pat(pat) => pat.hir_id.local_id\n         };\n \n         if !self.has_bitset_for_local_id(id) {"}, {"sha": "6b1b0b94fd9d7f747eb5d701add7e67064f28aba", "filename": "src/librustc_codegen_llvm/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -13,6 +13,7 @@ use std::sync::Arc;\n \n use monomorphize::Instance;\n use rustc::hir;\n+use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -94,7 +95,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n             match tcx.hir.get(node_id) {\n-                hir::map::NodeForeignItem(..) => {\n+                Node::ForeignItem(..) => {\n                     let def_id = tcx.hir.local_def_id(node_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {\n                         Some(def_id)\n@@ -104,14 +105,14 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n \n                 // Only consider nodes that actually have exported symbols.\n-                hir::map::NodeItem(&hir::Item {\n+                Node::Item(&hir::Item {\n                     node: hir::ItemKind::Static(..),\n                     ..\n                 }) |\n-                hir::map::NodeItem(&hir::Item {\n+                Node::Item(&hir::Item {\n                     node: hir::ItemKind::Fn(..), ..\n                 }) |\n-                hir::map::NodeImplItem(&hir::ImplItem {\n+                Node::ImplItem(&hir::ImplItem {\n                     node: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {"}, {"sha": "522de2f15e0a95806b15fc2f3023b54a9ae3ed4b", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -11,7 +11,7 @@\n use libc::c_uint;\n use llvm::{self, SetUnnamedAddr, True};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::Node;\n use debuginfo;\n use base;\n use monomorphize::MonoItem;\n@@ -135,7 +135,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n \n         let llty = cx.layout_of(ty).llvm_type(cx);\n         let (g, attrs) = match cx.tcx.hir.get(id) {\n-            hir_map::NodeItem(&hir::Item {\n+            Node::Item(&hir::Item {\n                 ref attrs, span, node: hir::ItemKind::Static(..), ..\n             }) => {\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n@@ -153,7 +153,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n                 (g, attrs)\n             }\n \n-            hir_map::NodeForeignItem(&hir::ForeignItem {\n+            Node::ForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n             }) => {\n                 let fn_attrs = cx.tcx.codegen_fn_attrs(def_id);"}, {"sha": "39b88b225edc75c22da63a492b74d51fcf157f55", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -98,7 +98,7 @@\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::hir::map as hir_map;\n+use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n@@ -261,7 +261,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n     let is_foreign = if let Some(id) = node_id {\n         match tcx.hir.get(id) {\n-            hir_map::NodeForeignItem(_) => true,\n+            Node::ForeignItem(_) => true,\n             _ => false,\n         }\n     } else {"}, {"sha": "c49631515eab9eb6cd63346d53e8e58a7361359f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -355,33 +355,33 @@ impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n     fn pre(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeExpr(_) => s.popen(),\n+            pprust::AnnNode::Expr(_) => s.popen(),\n             _ => Ok(()),\n         }\n     }\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(_) |\n-            pprust::NodeName(_) => Ok(()),\n+            pprust::AnnNode::Ident(_) |\n+            pprust::AnnNode::Name(_) => Ok(()),\n \n-            pprust::NodeItem(item) => {\n+            pprust::AnnNode::Item(item) => {\n                 s.s.space()?;\n                 s.synth_comment(item.id.to_string())\n             }\n-            pprust::NodeSubItem(id) => {\n+            pprust::AnnNode::SubItem(id) => {\n                 s.s.space()?;\n                 s.synth_comment(id.to_string())\n             }\n-            pprust::NodeBlock(blk) => {\n+            pprust::AnnNode::Block(blk) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n-            pprust::NodeExpr(expr) => {\n+            pprust::AnnNode::Expr(expr) => {\n                 s.s.space()?;\n                 s.synth_comment(expr.id.to_string())?;\n                 s.pclose()\n             }\n-            pprust::NodePat(pat) => {\n+            pprust::AnnNode::Pat(pat) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"pat {}\", pat.id))\n             }\n@@ -414,34 +414,34 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n     }\n     fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust_hir::NodeExpr(_) => s.popen(),\n+            pprust_hir::AnnNode::Expr(_) => s.popen(),\n             _ => Ok(()),\n         }\n     }\n     fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust_hir::NodeName(_) => Ok(()),\n-            pprust_hir::NodeItem(item) => {\n+            pprust_hir::AnnNode::Name(_) => Ok(()),\n+            pprust_hir::AnnNode::Item(item) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n                                         item.id, item.hir_id.local_id.0))\n             }\n-            pprust_hir::NodeSubItem(id) => {\n+            pprust_hir::AnnNode::SubItem(id) => {\n                 s.s.space()?;\n                 s.synth_comment(id.to_string())\n             }\n-            pprust_hir::NodeBlock(blk) => {\n+            pprust_hir::AnnNode::Block(blk) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"block node_id: {} hir local_id: {}\",\n                                         blk.id, blk.hir_id.local_id.0))\n             }\n-            pprust_hir::NodeExpr(expr) => {\n+            pprust_hir::AnnNode::Expr(expr) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n                                         expr.id, expr.hir_id.local_id.0))?;\n                 s.pclose()\n             }\n-            pprust_hir::NodePat(pat) => {\n+            pprust_hir::AnnNode::Pat(pat) => {\n                 s.s.space()?;\n                 s.synth_comment(format!(\"pat node_id: {} hir local_id: {}\",\n                                         pat.id, pat.hir_id.local_id.0))\n@@ -467,13 +467,13 @@ impl<'a> PrinterSupport for HygieneAnnotation<'a> {\n impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(&ast::Ident { name, span }) => {\n+            pprust::AnnNode::Ident(&ast::Ident { name, span }) => {\n                 s.s.space()?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n                 s.synth_comment(format!(\"{}{:?}\", name.as_u32(), span.ctxt()))\n             }\n-            pprust::NodeName(&name) => {\n+            pprust::AnnNode::Name(&name) => {\n                 s.s.space()?;\n                 s.synth_comment(name.as_u32().to_string())\n             }\n@@ -519,13 +519,13 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     }\n     fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust_hir::NodeExpr(_) => s.popen(),\n+            pprust_hir::AnnNode::Expr(_) => s.popen(),\n             _ => Ok(()),\n         }\n     }\n     fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust_hir::NodeExpr(expr) => {\n+            pprust_hir::AnnNode::Expr(expr) => {\n                 s.s.space()?;\n                 s.s.word(\"as\")?;\n                 s.s.space()?;"}, {"sha": "f715057541ffaa7476ef5ff2f49424344b8f7cd6", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -30,7 +30,7 @@ use std::vec::Vec;\n use rustc::dep_graph::{DepNode, label_strs};\n use rustc::hir;\n use rustc::hir::{ItemKind as HirItem, ImplItemKind, TraitItemKind};\n-use rustc::hir::map::Node as HirNode;\n+use rustc::hir::Node as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn auto_labels(&mut self, item_id: ast::NodeId, attr: &Attribute) -> (&'static str, Labels) {\n         let node = self.tcx.hir.get(item_id);\n         let (name, labels) = match node {\n-            HirNode::NodeItem(item) => {\n+            HirNode::Item(item) => {\n                 match item.node {\n                     // note: these are in the same order as hir::Item_;\n                     // FIXME(michaelwoerister): do commented out ones\n@@ -399,22 +399,23 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     _ => self.tcx.sess.span_fatal(\n                         attr.span,\n                         &format!(\n-                            \"clean/dirty auto-assertions not yet defined for NodeItem.node={:?}\",\n+                            \"clean/dirty auto-assertions not yet defined \\\n+                             for Node::Item.node={:?}\",\n                             item.node\n                         )\n                     ),\n                 }\n             },\n-            HirNode::NodeTraitItem(item) => {\n+            HirNode::TraitItem(item) => {\n                 match item.node {\n-                    TraitItemKind::Method(..) => (\"NodeTraitItem\", LABELS_FN_IN_TRAIT),\n+                    TraitItemKind::Method(..) => (\"Node::TraitItem\", LABELS_FN_IN_TRAIT),\n                     TraitItemKind::Const(..) => (\"NodeTraitConst\", LABELS_CONST_IN_TRAIT),\n                     TraitItemKind::Type(..) => (\"NodeTraitType\", LABELS_CONST_IN_TRAIT),\n                 }\n             },\n-            HirNode::NodeImplItem(item) => {\n+            HirNode::ImplItem(item) => {\n                 match item.node {\n-                    ImplItemKind::Method(..) => (\"NodeImplItem\", LABELS_FN_IN_IMPL),\n+                    ImplItemKind::Method(..) => (\"Node::ImplItem\", LABELS_FN_IN_IMPL),\n                     ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                     ImplItemKind::Type(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n                     ImplItemKind::Existential(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),"}, {"sha": "d84972b32c108fbd2b768f8321fc45122ec97685", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -34,7 +34,7 @@ use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use rustc::traits;\n-use rustc::hir::map as hir_map;\n+use hir::Node;\n use util::nodemap::NodeSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass, EarlyLintPass, EarlyContext};\n@@ -426,7 +426,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 let real_trait = trait_ref.path.def.def_id();\n                 if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n                     match cx.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeItem(item)) => {\n+                        Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n                                     self.private_traits.insert(impl_item_ref.id.node_id);\n@@ -979,7 +979,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n         fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match cx.tcx.hir.get(id) {\n-                hir_map::NodeExpr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n+                Node::Expr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n                     let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             use rustc::ty::adjustment::*;\n \n             // Ignore non-expressions.\n-            let expr = if let hir_map::NodeExpr(e) = cx.tcx.hir.get(id) {\n+            let expr = if let Node::Expr(e) = cx.tcx.hir.get(id) {\n                 e\n             } else {\n                 return false;\n@@ -1862,7 +1862,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestFunctions {\n                     if attr.name() == \"test\" {\n                         let parent = cx.tcx.hir.get_parent(it.id);\n                         match cx.tcx.hir.find(parent) {\n-                            Some(hir_map::NodeItem(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n+                            Some(Node::Item(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n                             None => {}\n                             _ => {\n                                 cx.struct_span_lint("}, {"sha": "2c410e8efb10a65fb0e852b92a83eed75954a6b7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_snake_case)]\n \n-use rustc::hir::map as hir_map;\n+use rustc::hir::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf};\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         };\n                         if lit_val < min || lit_val > max {\n                             let parent_id = cx.tcx.hir.get_parent_node(e.id);\n-                            if let hir_map::NodeExpr(parent_expr) = cx.tcx.hir.get(parent_id) {\n+                            if let Node::Expr(parent_expr) = cx.tcx.hir.get(parent_id) {\n                                 if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint("}, {"sha": "16d34082642bd57aa137b486e50bf114529ab59a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -12,6 +12,7 @@\n \n use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n+use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n@@ -232,7 +233,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     ));\n \n     let movable_generator = match tcx.hir.get(id) {\n-        hir::map::Node::NodeExpr(&hir::Expr {\n+        Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => false,"}, {"sha": "f96ef909c0df8ace584c08ca153c59455446e851", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n+use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Mir};\n use rustc::mir::{Mutability, Place, Projection, ProjectionElem, Static};\n use rustc::ty::{self, TyCtxt};\n@@ -246,7 +247,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     .var_hir_id\n                     .assert_crate_local();\n                 let upvar_node_id = self.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                if let Some(hir::map::NodeBinding(pat)) = self.tcx.hir.find(upvar_node_id) {\n+                if let Some(Node::Binding(pat)) = self.tcx.hir.find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,"}, {"sha": "f178ea8bdbab12c63d5ca8eaeb7450993b200f4b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -14,6 +14,7 @@ use build::scope::{CachedBlock, DropKind};\n use hair::cx::Cx;\n use hair::{LintLevel, BindingMode, PatternKind};\n use rustc::hir;\n+use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -40,9 +41,9 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n     // Figure out what primary body this item has.\n     let body_id = match tcx.hir.get(id) {\n-        hir::map::NodeVariant(variant) =>\n+        Node::Variant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n-        hir::map::NodeStructCtor(ctor) =>\n+        Node::StructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n \n         _ => match tcx.hir.maybe_body_owned_by(id) {\n@@ -520,7 +521,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref,\n                 mutability: Mutability::Not,\n             };\n-            if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n+            if let Some(Node::Binding(pat)) = tcx.hir.find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n "}, {"sha": "c9fd1d04e547b7f0a8a8b1d4a1e9562cc00c3dbc", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -19,6 +19,7 @@ use hair::*;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::hir::Node;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n@@ -202,7 +203,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let p = match tcx.hir.get(p.id) {\n-            hir::map::NodePat(p) | hir::map::NodeBinding(p) => p,\n+            Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n         Pattern::from_hir(tcx,"}, {"sha": "f19c4532b47d88c0a6767ec8ead7f34a441440db", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -191,7 +191,7 @@\n use rustc::hir::{self, CodegenFnAttrFlags};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n-use rustc::hir::map as hir_map;\n+use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{AllocId, ConstValue, ScalarMaybeUndef};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -740,7 +740,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n     };\n \n     return match tcx.hir.get_if_local(def_id) {\n-        Some(hir_map::NodeForeignItem(..)) => {\n+        Some(Node::ForeignItem(..)) => {\n             false // foreign items are linked against, not codegened.\n         }\n         Some(_) => true,"}, {"sha": "6efefdaa004008e66e52d9e3daad3b5b3efcbf4a", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -85,7 +85,7 @@ fn place_context<'a, 'tcx, D>(\n fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n     use rustc::hir::intravisit::{self, Visitor, FnKind};\n     use rustc::hir::map::blocks::FnLikeNode;\n-    use rustc::hir::map::Node;\n+    use rustc::hir::Node;\n \n     /// Decide if this is an unsafe block\n     fn block_is_unsafe(block: &hir::Block) -> bool {\n@@ -142,13 +142,13 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n             }\n             // Check if this is an unsafe block, or an item\n             match node {\n-                Node::NodeExpr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n+                Node::Expr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n                     if block_is_unsafe(&*block) {\n                         // Found an unsafe block, we can bail out here.\n                         return true;\n                     }\n                 }\n-                Node::NodeItem(..) => {\n+                Node::Item(..) => {\n                     // No walking up beyond items.  This makes sure the loop always terminates.\n                     break;\n                 }"}, {"sha": "f6006ae045ee787e238d520d2c2836378fafab30", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir;\n+use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSAFE};\n use rustc::mir::*;\n@@ -407,7 +408,7 @@ fn is_enclosed(tcx: TyCtxt,\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n-        } else if let Some(hir::map::NodeItem(&hir::Item {\n+        } else if let Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n         })) = tcx.hir.find(parent_id) {"}, {"sha": "44030c284fd812227b8d550e7e8a4aafd60ae62b", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -13,7 +13,7 @@ use rustc::session::Session;\n \n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Destination};\n+use rustc::hir::{self, Node, Destination};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -115,7 +115,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 if loop_id != ast::DUMMY_NODE_ID {\n                     match self.hir_map.find(loop_id).unwrap() {\n-                        hir::map::NodeBlock(_) => return,\n+                        Node::Block(_) => return,\n                         _=> (),\n                     }\n                 }\n@@ -158,7 +158,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 match label.target_id {\n                     Ok(loop_id) => {\n-                        if let hir::map::NodeBlock(block) = self.hir_map.find(loop_id).unwrap() {\n+                        if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n                             struct_span_err!(self.sess, e.span, E0696,\n                                             \"`continue` pointing to a labeled block\")\n                                 .span_label(e.span,"}, {"sha": "5166f69ba03304c49572d760cb514139184e2436", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -25,6 +25,7 @@ extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n use rustc::hir::{self, PatKind};\n+use hir::Node;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -659,17 +660,17 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         match self.tcx.hir.as_local_node_id(did) {\n             Some(node_id) => {\n                 let vis = match self.tcx.hir.get(node_id) {\n-                    hir::map::NodeItem(item) => &item.vis,\n-                    hir::map::NodeForeignItem(foreign_item) => &foreign_item.vis,\n-                    hir::map::NodeImplItem(impl_item) => &impl_item.vis,\n-                    hir::map::NodeTraitItem(..) |\n-                    hir::map::NodeVariant(..) => {\n+                    Node::Item(item) => &item.vis,\n+                    Node::ForeignItem(foreign_item) => &foreign_item.vis,\n+                    Node::ImplItem(impl_item) => &impl_item.vis,\n+                    Node::TraitItem(..) |\n+                    Node::Variant(..) => {\n                         return self.def_id_visibility(self.tcx.hir.get_parent_did(node_id));\n                     }\n-                    hir::map::NodeStructCtor(vdata) => {\n+                    Node::StructCtor(vdata) => {\n                         let struct_node_id = self.tcx.hir.get_parent(node_id);\n                         let struct_vis = match self.tcx.hir.get(struct_node_id) {\n-                            hir::map::NodeItem(item) => &item.vis,\n+                            Node::Item(item) => &item.vis,\n                             node => bug!(\"unexpected node kind: {:?}\", node),\n                         };\n                         let mut ctor_vis\n@@ -1037,7 +1038,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n             match self.tcx.hir.find(node_id) {\n-                Some(hir::map::NodeItem(ref item)) => !item.vis.node.is_pub(),\n+                Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -1469,8 +1470,8 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             // Non-local means public (private items can't leave their crate, modulo bugs)\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let hir_vis = match self.tcx.hir.find(node_id) {\n-                    Some(hir::map::NodeItem(item)) => &item.vis,\n-                    Some(hir::map::NodeForeignItem(item)) => &item.vis,\n+                    Some(Node::Item(item)) => &item.vis,\n+                    Some(Node::ForeignItem(item)) => &item.vis,\n                     _ => bug!(\"expected item of foreign item\"),\n                 };\n "}, {"sha": "fd29dac5af8cc87a72e62767698067eaee508f15", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -43,7 +43,7 @@ mod sig;\n \n use rustc::hir;\n use rustc::hir::def::Def as HirDef;\n-use rustc::hir::map::{Node, NodeTraitItem, NodeImplItem};\n+use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::CrateType;\n@@ -420,7 +420,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n             match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n                 Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n-                    Some(Node::NodeItem(item)) => match item.node {\n+                    Some(Node::Item(item)) => match item.node {\n                         hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n                             qualname.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n@@ -429,7 +429,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             let mut decl_id = None;\n                             let mut docs = String::new();\n                             let mut attrs = vec![];\n-                            if let Some(NodeImplItem(item)) = self.tcx.hir.find(id) {\n+                            if let Some(Node::ImplItem(item)) = self.tcx.hir.find(id) {\n                                 docs = self.docs_for_attrs(&item.attrs);\n                                 attrs = item.attrs.to_vec();\n                             }\n@@ -471,7 +471,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n \n-                        if let Some(NodeTraitItem(item)) = self.tcx.hir.find(id) {\n+                        if let Some(Node::TraitItem(item)) = self.tcx.hir.find(id) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }\n@@ -541,7 +541,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         match expr.node {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n                 let hir_node = match self.tcx.hir.find(sub_ex.id) {\n-                    Some(Node::NodeExpr(expr)) => expr,\n+                    Some(Node::Expr(expr)) => expr,\n                     _ => {\n                         debug!(\n                             \"Missing or weird node for sub-expression {} in {:?}\",\n@@ -628,45 +628,45 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_path_def(&self, id: NodeId) -> HirDef {\n         match self.tcx.hir.get(id) {\n-            Node::NodeTraitRef(tr) => tr.path.def,\n+            Node::TraitRef(tr) => tr.path.def,\n \n-            Node::NodeItem(&hir::Item {\n+            Node::Item(&hir::Item {\n                 node: hir::ItemKind::Use(ref path, _),\n                 ..\n             }) |\n-            Node::NodeVisibility(&Spanned {\n+            Node::Visibility(&Spanned {\n                 node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.def,\n \n-            Node::NodeExpr(&hir::Expr {\n+            Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n-            Node::NodeExpr(&hir::Expr {\n+            Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Path(ref qpath),\n                 ..\n             }) |\n-            Node::NodePat(&hir::Pat {\n+            Node::Pat(&hir::Pat {\n                 node: hir::PatKind::Path(ref qpath),\n                 ..\n             }) |\n-            Node::NodePat(&hir::Pat {\n+            Node::Pat(&hir::Pat {\n                 node: hir::PatKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n-            Node::NodePat(&hir::Pat {\n+            Node::Pat(&hir::Pat {\n                 node: hir::PatKind::TupleStruct(ref qpath, ..),\n                 ..\n             }) => {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 self.tables.qpath_def(qpath, hir_id)\n             }\n \n-            Node::NodeBinding(&hir::Pat {\n+            Node::Binding(&hir::Pat {\n                 node: hir::PatKind::Binding(_, canonical_id, ..),\n                 ..\n             }) => HirDef::Local(canonical_id),\n \n-            Node::NodeTy(ty) => if let hir::Ty {\n+            Node::Ty(ty) => if let hir::Ty {\n                 node: hir::TyKind::Path(ref qpath),\n                 ..\n             } = *ty"}, {"sha": "85646b9ab675af19da19ce9ce470e30aa9a47326", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -17,7 +17,7 @@ use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::map::{NodeItem, NodeExpr};\n+use rustc::hir::Node;\n use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n@@ -199,13 +199,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n             if let hir::def::Def::Local(id) = path.def {\n                 let parent = self.tcx.hir.get_parent_node(id);\n-                if let Some(NodeExpr(hir::Expr {\n+                if let Some(Node::Expr(hir::Expr {\n                     id,\n                     node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n                 })) = self.tcx.hir.find(parent) {\n                     let parent = self.tcx.hir.get_parent_node(*id);\n-                    if let (Some(NodeExpr(hir::Expr {\n+                    if let (Some(Node::Expr(hir::Expr {\n                         node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n                     })), 1) = (self.tcx.hir.find(parent), decl.inputs.len()) {\n@@ -377,7 +377,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.tcx.hir.find(parent_id) {\n             Some(parent) => {\n                 // Shouldn't suggest `.into()` on `const`s.\n-                if let NodeItem(Item { node: ItemKind::Const(_, _), .. }) = parent {\n+                if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n                     // FIXME(estebank): modify once we decide to suggest `as` casts\n                     return false;\n                 }"}, {"sha": "abc32ed2ea0433d2576dac7fd5e86d0f2f0f029e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -13,6 +13,7 @@\n \n use check::FnCtxt;\n use rustc::hir::map as hir_map;\n+use hir::Node;\n use rustc_data_structures::sync::Lrc;\n use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use hir::def::Def;\n@@ -275,7 +276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         );\n \n                                         match (filename, parent_node) {\n-                                            (FileName::Real(_), hir_map::NodeLocal(hir::Local {\n+                                            (FileName::Real(_), Node::Local(hir::Local {\n                                                 source: hir::LocalSource::Normal,\n                                                 ty,\n                                                 .."}, {"sha": "bbb45c04e4e9823d2ba8aed0c79c994c2b2c8fbe", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -132,7 +132,7 @@ use syntax_pos::{self, BytePos, Span, MultiSpan};\n \n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::map::Node;\n+use rustc::hir::Node;\n use rustc::hir::{self, PatKind, ItemKind};\n use rustc::middle::lang_items;\n \n@@ -761,7 +761,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n {\n     match tcx.hir.get(id) {\n-        hir::map::NodeItem(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 hir::ItemKind::Const(_, body) |\n                 hir::ItemKind::Static(_, _, body) =>\n@@ -772,7 +772,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeTraitItem(item) => {\n+        Node::TraitItem(item) => {\n             match item.node {\n                 hir::TraitItemKind::Const(_, Some(body)) =>\n                     Some((body, None)),\n@@ -782,7 +782,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeImplItem(item) => {\n+        Node::ImplItem(item) => {\n             match item.node {\n                 hir::ImplItemKind::Const(_, body) =>\n                     Some((body, None)),\n@@ -792,7 +792,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeAnonConst(constant) => Some((constant.body, None)),\n+        Node::AnonConst(constant) => Some((constant.body, None)),\n         _ => None,\n     }\n }\n@@ -1167,7 +1167,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir.get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -1214,7 +1214,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir.get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -4646,7 +4646,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(fn_id) = self.tcx.hir.get_return_block(blk_id) {\n             let parent = self.tcx.hir.get(fn_id);\n \n-            if let Node::NodeItem(&hir::Item {\n+            if let Node::Item(&hir::Item {\n                 name, node: hir::ItemKind::Fn(ref decl, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n@@ -4655,15 +4655,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // but it will still present it as the reason for the expected type.\n                     Some((decl, name != Symbol::intern(\"main\")))\n                 })\n-            } else if let Node::NodeTraitItem(&hir::TraitItem {\n+            } else if let Node::TraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n                     Some((decl, true))\n                 })\n-            } else if let Node::NodeImplItem(&hir::ImplItem {\n+            } else if let Node::ImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n@@ -5174,7 +5174,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n         match self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n-            Node::NodeExpr(expr) => {\n+            Node::Expr(expr) => {\n                 match expr.node {\n                     hir::ExprKind::Call(ref callee, ..) => {\n                         if callee.id == node_id {"}, {"sha": "efc35fad820c820c8c52924be8729e890ad1ba81", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::util::CopyImplementationError;\n use rustc::infer;\n \n use rustc::hir::def_id::DefId;\n-use rustc::hir::map as hir_map;\n+use hir::Node;\n use rustc::hir::{self, ItemKind};\n \n pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n@@ -60,7 +60,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n             // Destructors only work on nominal types.\n             if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n                 match tcx.hir.find(impl_node_id) {\n-                    Some(hir_map::NodeItem(item)) => {\n+                    Some(Node::Item(item)) => {\n                         let span = match item.node {\n                             ItemKind::Impl(.., ref ty, _) => ty.span,\n                             _ => item.span,"}, {"sha": "a42667ab45fc8726993b72d44000b4054f6ff702", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -50,10 +50,11 @@ use syntax::symbol::{keywords, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Def};\n+use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::GenericParamKind;\n-use rustc::hir::{self, map as hir_map, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n+use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n@@ -238,7 +239,6 @@ fn type_param_predicates<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (item_def_id, def_id): (DefId, DefId),\n ) -> ty::GenericPredicates<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     // In the AST, bounds can derive from two places. Either\n@@ -272,11 +272,11 @@ fn type_param_predicates<'a, 'tcx>(\n \n     let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n     let ast_generics = match tcx.hir.get(item_node_id) {\n-        NodeTraitItem(item) => &item.generics,\n+        Node::TraitItem(item) => &item.generics,\n \n-        NodeImplItem(item) => &item.generics,\n+        Node::ImplItem(item) => &item.generics,\n \n-        NodeItem(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(_, _, _, ref generics, ..)\n@@ -302,7 +302,7 @@ fn type_param_predicates<'a, 'tcx>(\n             }\n         }\n \n-        NodeForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             _ => return result,\n         },\n@@ -595,12 +595,11 @@ fn convert_struct_variant<'a, 'tcx>(\n }\n \n fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = match tcx.hir.get(node_id) {\n-        NodeItem(item) => item,\n+        Node::Item(item) => item,\n         _ => bug!(),\n     };\n \n@@ -671,7 +670,7 @@ fn super_predicates_of<'a, 'tcx>(\n     let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n \n     let item = match tcx.hir.get(trait_node_id) {\n-        hir_map::NodeItem(item) => item,\n+        Node::Item(item) => item,\n         _ => bug!(\"trait_node_id {} is not an item\", trait_node_id),\n     };\n \n@@ -740,7 +739,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n \n fn has_late_bound_regions<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    node: hir_map::Node<'tcx>,\n+    node: Node<'tcx>,\n ) -> Option<Span> {\n     struct LateBoundRegionsDetector<'a, 'tcx: 'a> {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -826,25 +825,25 @@ fn has_late_bound_regions<'a, 'tcx>(\n     }\n \n     match node {\n-        hir_map::NodeTraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.node {\n             hir::TraitItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.node {\n             hir::ImplItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeItem(item) => match item.node {\n+        Node::Item(item) => match item.node {\n             hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n@@ -855,22 +854,22 @@ fn has_late_bound_regions<'a, 'tcx>(\n }\n \n fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n     let node = tcx.hir.get(node_id);\n     let parent_def_id = match node {\n-        NodeImplItem(_) | NodeTraitItem(_) | NodeVariant(_) | NodeStructCtor(_) | NodeField(_) => {\n+        Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_)\n+        | Node::StructCtor(_) | Node::Field(_) => {\n             let parent_id = tcx.hir.get_parent(node_id);\n             Some(tcx.hir.local_def_id(parent_id))\n         }\n-        NodeExpr(&hir::Expr {\n+        Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n         }) => Some(tcx.closure_base_def_id(def_id)),\n-        NodeItem(item) => match item.node {\n+        Node::Item(item) => match item.node {\n             ItemKind::Existential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n             _ => None,\n         },\n@@ -882,11 +881,11 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n     let no_generics = hir::Generics::empty();\n     let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+        Node::TraitItem(item) => &item.generics,\n \n-        NodeImplItem(item) => &item.generics,\n+        Node::ImplItem(item) => &item.generics,\n \n-        NodeItem(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 ItemKind::Fn(.., ref generics, _) | ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     generics\n@@ -929,7 +928,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n             }\n         }\n \n-        NodeForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             ForeignItemKind::Static(..) => &no_generics,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             ForeignItemKind::Type => &no_generics,\n@@ -1024,7 +1023,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n-    if let NodeExpr(&hir::Expr {\n+    if let Node::Expr(&hir::Expr {\n         node: hir::ExprKind::Closure(.., gen),\n         ..\n     }) = node\n@@ -1094,15 +1093,14 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n }\n \n fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeTraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1113,7 +1111,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.node {\n             ImplItemKind::Method(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1141,7 +1139,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeItem(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 ItemKind::Static(ref t, ..)\n                 | ItemKind::Const(ref t, _)\n@@ -1199,7 +1197,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         }\n \n-        NodeForeignItem(foreign_item) => match foreign_item.node {\n+        Node::ForeignItem(foreign_item) => match foreign_item.node {\n             ForeignItemKind::Fn(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1208,8 +1206,8 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ForeignItemKind::Type => tcx.mk_foreign(def_id),\n         },\n \n-        NodeStructCtor(&ref def)\n-        | NodeVariant(&Spanned {\n+        Node::StructCtor(&ref def)\n+        | Node::Variant(&Spanned {\n             node: hir::VariantKind { data: ref def, .. },\n             ..\n         }) => match *def {\n@@ -1222,9 +1220,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeField(field) => icx.to_ty(&field.ty),\n+        Node::Field(field) => icx.to_ty(&field.ty),\n \n-        NodeExpr(&hir::Expr {\n+        Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., gen),\n             ..\n         }) => {\n@@ -1240,24 +1238,24 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             tcx.mk_closure(def_id, substs)\n         }\n \n-        NodeAnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n-            NodeTy(&hir::Ty {\n+        Node::AnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n+            Node::Ty(&hir::Ty {\n                 node: hir::TyKind::Array(_, ref constant),\n                 ..\n             })\n-            | NodeTy(&hir::Ty {\n+            | Node::Ty(&hir::Ty {\n                 node: hir::TyKind::Typeof(ref constant),\n                 ..\n             })\n-            | NodeExpr(&hir::Expr {\n+            | Node::Expr(&hir::Expr {\n                 node: ExprKind::Repeat(_, ref constant),\n                 ..\n             }) if constant.id == node_id =>\n             {\n                 tcx.types.usize\n             }\n \n-            NodeVariant(&Spanned {\n+            Node::Variant(&Spanned {\n                 node:\n                     VariantKind {\n                         disr_expr: Some(ref e),\n@@ -1277,7 +1275,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeGenericParam(param) => match param.kind {\n+        Node::GenericParam(param) => match param.kind {\n             hir::GenericParamKind::Type {\n                 default: Some(ref ty),\n                 ..\n@@ -1295,7 +1293,6 @@ fn find_existential_constraints<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> ty::Ty<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     struct ConstraintLocator<'a, 'tcx: 'a> {\n@@ -1375,9 +1372,9 @@ fn find_existential_constraints<'a, 'tcx>(\n     } else {\n         trace!(\"parent: {:?}\", tcx.hir.get(parent));\n         match tcx.hir.get(parent) {\n-            NodeItem(ref it) => intravisit::walk_item(&mut locator, it),\n-            NodeImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n-            NodeTraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n+            Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n+            Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n+            Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\n                 \"{:?} is not a valid parent of an existential type item\",\n                 other\n@@ -1395,38 +1392,38 @@ fn find_existential_constraints<'a, 'tcx>(\n }\n \n fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n+    use rustc::hir::Node::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeTraitItem(hir::TraitItem {\n+        TraitItem(hir::TraitItem {\n             node: TraitItemKind::Method(sig, _),\n             ..\n         })\n-        | NodeImplItem(hir::ImplItem {\n+        | ImplItem(hir::ImplItem {\n             node: ImplItemKind::Method(sig, _),\n             ..\n         }) => AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl),\n \n-        NodeItem(hir::Item {\n+        Item(hir::Item {\n             node: ItemKind::Fn(decl, header, _, _),\n             ..\n         }) => AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl),\n \n-        NodeForeignItem(&hir::ForeignItem {\n+        ForeignItem(&hir::ForeignItem {\n             node: ForeignItemKind::Fn(ref fn_decl, _, _),\n             ..\n         }) => {\n             let abi = tcx.hir.get_foreign_abi(node_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        NodeStructCtor(&VariantData::Tuple(ref fields, _))\n-        | NodeVariant(&Spanned {\n+        StructCtor(&VariantData::Tuple(ref fields, _))\n+        | Variant(&Spanned {\n             node:\n                 hir::VariantKind {\n                     data: VariantData::Tuple(ref fields, _),\n@@ -1447,7 +1444,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n             ))\n         }\n \n-        NodeExpr(&hir::Expr {\n+        Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n         }) => {\n@@ -1625,7 +1622,6 @@ fn explicit_predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> ty::GenericPredicates<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     debug!(\"explicit_predicates_of(def_id={:?})\", def_id);\n@@ -1642,9 +1638,9 @@ fn explicit_predicates_of<'a, 'tcx>(\n     let mut predicates = vec![];\n \n     let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+        Node::TraitItem(item) => &item.generics,\n \n-        NodeImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.node {\n             ImplItemKind::Existential(ref bounds) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 let anon_ty = tcx.mk_anon(def_id, substs);\n@@ -1664,7 +1660,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n             _ => &item.generics,\n         },\n \n-        NodeItem(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n                     if defaultness.is_default() {\n@@ -1716,7 +1712,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n             }\n         }\n \n-        NodeForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             ForeignItemKind::Static(..) => &no_generics,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             ForeignItemKind::Type => &no_generics,\n@@ -1876,7 +1872,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let NodeItem(&Item {\n+    if let Node::Item(&Item {\n         node: ItemKind::Impl(..),\n         ..\n     }) = node\n@@ -2026,7 +2022,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n \n fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     match tcx.hir.get_if_local(def_id) {\n-        Some(hir_map::NodeForeignItem(..)) => true,\n+        Some(Node::ForeignItem(..)) => true,\n         Some(_) => false,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n     }"}, {"sha": "e31ae8eb8c7aecde6624fc02756c9e4cc32eef66", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -103,7 +103,7 @@ use rustc::middle;\n use rustc::session;\n use rustc::util;\n \n-use hir::map as hir_map;\n+use hir::Node;\n use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -187,7 +187,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match main_t.sty {\n         ty::FnDef(..) => {\n             match tcx.hir.find(main_id) {\n-                Some(hir_map::NodeItem(it)) => {\n+                Some(Node::Item(it)) => {\n                     match it.node {\n                         hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;\n@@ -259,7 +259,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match start_t.sty {\n         ty::FnDef(..) => {\n             match tcx.hir.find(start_id) {\n-                Some(hir_map::NodeItem(it)) => {\n+                Some(Node::Item(it)) => {\n                     match it.node {\n                         hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;"}, {"sha": "092e4d62e2e9fa5724d4618bea8f6bf957897cb8", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n+use hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n@@ -70,7 +71,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n             .as_local_node_id(item_did)\n             .expect(\"expected local def-id\");\n         let item = match self.tcx.hir.get(node_id) {\n-            hir::map::NodeItem(item) => item,\n+            Node::Item(item) => item,\n             _ => bug!(),\n         };\n "}, {"sha": "63a424936eb4c75d9ac08fec999dbbc882c51b04", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::map as hir_map;\n+use hir::Node;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::query::Providers;\n@@ -40,7 +40,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n         .expect(\"expected local def-id\");\n \n     match tcx.hir.get(id) {\n-        hir_map::NodeItem(item) => match item.node {\n+        Node::Item(item) => match item.node {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n "}, {"sha": "aaa0fd8e099efa47c492f1987ccdfc57853bd0dd", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -15,6 +15,7 @@\n \n use arena;\n use rustc::hir;\n+use hir::Node;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n use rustc::ty::query::Providers;\n@@ -61,7 +62,7 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n         span_bug!(tcx.hir.span(id), \"asked to compute variance for wrong kind of item\")\n     };\n     match tcx.hir.get(id) {\n-        hir::map::NodeItem(item) => match item.node {\n+        Node::Item(item) => match item.node {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) |\n@@ -70,25 +71,25 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n             _ => unsupported()\n         },\n \n-        hir::map::NodeTraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.node {\n             hir::TraitItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.node {\n             hir::ImplItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             hir::ForeignItemKind::Fn(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeVariant(_) | hir::map::NodeStructCtor(_) => {}\n+        Node::Variant(_) | Node::StructCtor(_) => {}\n \n         _ => unsupported()\n     }"}, {"sha": "451e24d6c0dc938ecf90a79c4bdb6462a388ba23", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -18,7 +18,7 @@ use syntax::attr;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n-use rustc::hir::map as hir_map;\n+use rustc::hir::Node;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevel;\n@@ -295,7 +295,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         if !self.view_item_stack.insert(def_node_id) { return false }\n \n         let ret = match tcx.hir.get(def_node_id) {\n-            hir_map::NodeItem(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n+            Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n                     let i = self.cx.tcx.hir.expect_item(i.id);\n@@ -304,13 +304,13 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 self.inlining = prev;\n                 true\n             }\n-            hir_map::NodeItem(it) if !glob => {\n+            Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 self.visit_item(it, renamed, om);\n                 self.inlining = prev;\n                 true\n             }\n-            hir_map::NodeForeignItem(it) if !glob => {\n+            Node::ForeignItem(it) if !glob => {\n                 // generate a fresh `extern {}` block if we want to inline a foreign item.\n                 om.foreigns.push(hir::ForeignMod {\n                     abi: tcx.hir.get_foreign_abi(it.id),"}, {"sha": "e78e1afe3a4025543dff3f2e856abd82d3edcfae", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::AnnNode::*;\n-\n use rustc_target::spec::abi::{self, Abi};\n use ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use ast::{SelfKind, GenericBound, TraitBoundModifier};\n@@ -36,13 +34,13 @@ use std::iter::Peekable;\n use std::vec;\n \n pub enum AnnNode<'a> {\n-    NodeIdent(&'a ast::Ident),\n-    NodeName(&'a ast::Name),\n-    NodeBlock(&'a ast::Block),\n-    NodeItem(&'a ast::Item),\n-    NodeSubItem(ast::NodeId),\n-    NodeExpr(&'a ast::Expr),\n-    NodePat(&'a ast::Pat),\n+    Ident(&'a ast::Ident),\n+    Name(&'a ast::Name),\n+    Block(&'a ast::Block),\n+    Item(&'a ast::Item),\n+    SubItem(ast::NodeId),\n+    Expr(&'a ast::Expr),\n+    Pat(&'a ast::Pat),\n }\n \n pub trait PpAnn {\n@@ -1196,7 +1194,7 @@ impl<'a> State<'a> {\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(item.span.lo())?;\n         self.print_outer_attributes(&item.attrs)?;\n-        self.ann.pre(self, NodeItem(item))?;\n+        self.ann.pre(self, AnnNode::Item(item))?;\n         match item.node {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n@@ -1439,7 +1437,7 @@ impl<'a> State<'a> {\n                 self.end()?;\n             }\n         }\n-        self.ann.post(self, NodeItem(item))\n+        self.ann.post(self, AnnNode::Item(item))\n     }\n \n     fn print_trait_ref(&mut self, t: &ast::TraitRef) -> io::Result<()> {\n@@ -1596,7 +1594,7 @@ impl<'a> State<'a> {\n \n     pub fn print_trait_item(&mut self, ti: &ast::TraitItem)\n                             -> io::Result<()> {\n-        self.ann.pre(self, NodeSubItem(ti.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ti.id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ti.span.lo())?;\n         self.print_outer_attributes(&ti.attrs)?;\n@@ -1638,11 +1636,11 @@ impl<'a> State<'a> {\n                 }\n             }\n         }\n-        self.ann.post(self, NodeSubItem(ti.id))\n+        self.ann.post(self, AnnNode::SubItem(ti.id))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n-        self.ann.pre(self, NodeSubItem(ii.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ii.span.lo())?;\n         self.print_outer_attributes(&ii.attrs)?;\n@@ -1672,7 +1670,7 @@ impl<'a> State<'a> {\n                 }\n             }\n         }\n-        self.ann.post(self, NodeSubItem(ii.id))\n+        self.ann.post(self, AnnNode::SubItem(ii.id))\n     }\n \n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n@@ -1756,7 +1754,7 @@ impl<'a> State<'a> {\n             BlockCheckMode::Default => ()\n         }\n         self.maybe_print_comment(blk.span.lo())?;\n-        self.ann.pre(self, NodeBlock(blk))?;\n+        self.ann.pre(self, AnnNode::Block(blk))?;\n         self.bopen()?;\n \n         self.print_inner_attributes(attrs)?;\n@@ -1774,7 +1772,7 @@ impl<'a> State<'a> {\n         }\n \n         self.bclose_maybe_open(blk.span, indented, close_box)?;\n-        self.ann.post(self, NodeBlock(blk))\n+        self.ann.post(self, AnnNode::Block(blk))\n     }\n \n     fn print_else(&mut self, els: Option<&ast::Expr>) -> io::Result<()> {\n@@ -2065,7 +2063,7 @@ impl<'a> State<'a> {\n         }\n \n         self.ibox(INDENT_UNIT)?;\n-        self.ann.pre(self, NodeExpr(expr))?;\n+        self.ann.pre(self, AnnNode::Expr(expr))?;\n         match expr.node {\n             ast::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\")?;\n@@ -2385,7 +2383,7 @@ impl<'a> State<'a> {\n                 self.print_block_with_attrs(blk, attrs)?\n             }\n         }\n-        self.ann.post(self, NodeExpr(expr))?;\n+        self.ann.post(self, AnnNode::Expr(expr))?;\n         self.end()\n     }\n \n@@ -2404,7 +2402,7 @@ impl<'a> State<'a> {\n         } else {\n             self.s.word(&ident.as_str())?;\n         }\n-        self.ann.post(self, NodeIdent(&ident))\n+        self.ann.post(self, AnnNode::Ident(&ident))\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n@@ -2413,7 +2411,7 @@ impl<'a> State<'a> {\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n         self.s.word(&name.as_str())?;\n-        self.ann.post(self, NodeName(&name))\n+        self.ann.post(self, AnnNode::Name(&name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &ast::Local,\n@@ -2537,7 +2535,7 @@ impl<'a> State<'a> {\n \n     pub fn print_pat(&mut self, pat: &ast::Pat) -> io::Result<()> {\n         self.maybe_print_comment(pat.span.lo())?;\n-        self.ann.pre(self, NodePat(pat))?;\n+        self.ann.pre(self, AnnNode::Pat(pat))?;\n         /* Pat isn't normalized, but the beauty of it\n          is that it doesn't matter */\n         match pat.node {\n@@ -2675,7 +2673,7 @@ impl<'a> State<'a> {\n             }\n             PatKind::Mac(ref m) => self.print_mac(m)?,\n         }\n-        self.ann.post(self, NodePat(pat))\n+        self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n     fn print_pats(&mut self, pats: &[P<ast::Pat>]) -> io::Result<()> {"}, {"sha": "f525e0f082a44b723facd5f3f5aae20274762a8a", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e52b1b969545e6b7b8595913dc2e1a741d495d/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs?ref=59e52b1b969545e6b7b8595913dc2e1a741d495d", "patch": "@@ -27,6 +27,7 @@ use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::hir::map as hir_map;\n+use hir::Node;\n use rustc::lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n use rustc::ty;\n use syntax::{ast, source_map};\n@@ -58,7 +59,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n                 id: ast::NodeId) {\n \n         let item = match cx.tcx.hir.get(id) {\n-            hir_map::Node::NodeItem(item) => item,\n+            Node::Item(item) => item,\n             _ => cx.tcx.hir.expect_item(cx.tcx.hir.get_parent(id)),\n         };\n "}]}