{"sha": "4b1d13d9841c815915433ca2a3088a8e3e97ad96", "node_id": "C_kwDOAAsO6NoAKDRiMWQxM2Q5ODQxYzgxNTkxNTQzM2NhMmEzMDg4YThlM2U5N2FkOTY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-06-08T12:30:01Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-06-09T08:36:21Z"}, "message": "List matching impls on type aliases", "tree": {"sha": "bb98be510fe4c6f8fd35488c081df3a91494d239", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb98be510fe4c6f8fd35488c081df3a91494d239"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b1d13d9841c815915433ca2a3088a8e3e97ad96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1d13d9841c815915433ca2a3088a8e3e97ad96", "html_url": "https://github.com/rust-lang/rust/commit/4b1d13d9841c815915433ca2a3088a8e3e97ad96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b1d13d9841c815915433ca2a3088a8e3e97ad96/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a77659a1e1807ba567f513afe59115af2604dc30", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77659a1e1807ba567f513afe59115af2604dc30", "html_url": "https://github.com/rust-lang/rust/commit/a77659a1e1807ba567f513afe59115af2604dc30"}], "stats": {"total": 138, "additions": 110, "deletions": 28}, "files": [{"sha": "baffee0964da9c7e1ea6ff135ef608ede39dfeea", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4b1d13d9841c815915433ca2a3088a8e3e97ad96/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1d13d9841c815915433ca2a3088a8e3e97ad96/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4b1d13d9841c815915433ca2a3088a8e3e97ad96", "patch": "@@ -53,12 +53,15 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_hir::Mutability;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_span::{\n     symbol::{sym, Symbol},\n     BytePos, FileName, RealFileName,\n };\n+use rustc_trait_selection::traits::ObligationCtxt;\n use serde::ser::{SerializeMap, SerializeSeq};\n use serde::{Serialize, Serializer};\n \n@@ -1112,28 +1115,76 @@ fn render_assoc_items<'a, 'cx: 'a>(\n     containing_item: &'a clean::Item,\n     it: DefId,\n     what: AssocItemRender<'a>,\n+    aliased_type: Option<DefId>,\n ) -> impl fmt::Display + 'a + Captures<'cx> {\n     let mut derefs = DefIdSet::default();\n     derefs.insert(it);\n     display_fn(move |f| {\n-        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs);\n+        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs, aliased_type);\n         Ok(())\n     })\n }\n \n+/// Check whether `impl_def_id` may apply to *some instantiation* of `item_def_id`.\n+fn is_valid_impl_for(tcx: TyCtxt<'_>, item_def_id: DefId, impl_def_id: DefId) -> bool {\n+    let infcx = tcx.infer_ctxt().intercrate(true).build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let param_env = ParamEnv::empty();\n+\n+    let alias_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, item_def_id);\n+    let alias_ty = tcx.type_of(item_def_id).subst(tcx, alias_substs);\n+    let alias_bounds = tcx.predicates_of(item_def_id).instantiate(tcx, alias_substs);\n+\n+    let impl_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, impl_def_id);\n+    let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n+    let impl_bounds = tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs);\n+\n+    if ocx.eq(&ObligationCause::dummy(), param_env, impl_self_ty, alias_ty).is_err() {\n+        return false;\n+    }\n+    ocx.register_obligations(\n+        alias_bounds\n+            .iter()\n+            .chain(impl_bounds)\n+            .map(|(p, _)| Obligation::new(tcx, ObligationCause::dummy(), param_env, p)),\n+    );\n+\n+    let errors = ocx.select_where_possible();\n+    errors.is_empty()\n+}\n+\n+// If `aliased_type` is `Some`, it means `it` is a type alias and `aliased_type` is the \"actual\"\n+// type aliased behind `it`. It is used to check whether or not the implementation of the aliased\n+// type can be displayed on the alias doc page.\n fn render_assoc_items_inner(\n     mut w: &mut dyn fmt::Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n     derefs: &mut DefIdSet,\n+    aliased_type: Option<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n     let shared = Rc::clone(&cx.shared);\n     let cache = &shared.cache;\n-    let Some(v) = cache.impls.get(&it) else { return };\n-    let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n+    let empty = Vec::new();\n+    let v = match cache.impls.get(&it) {\n+        Some(v) => v,\n+        None => &empty,\n+    };\n+    let v2 = match aliased_type {\n+        Some(aliased_type) => cache.impls.get(&aliased_type).unwrap_or(&empty),\n+        None => &empty,\n+    };\n+    if v.is_empty() && v2.is_empty() {\n+        return;\n+    }\n+    let mut saw_impls = FxHashSet::default();\n+    let (non_trait, traits): (Vec<_>, _) =\n+        v.iter().chain(v2).partition(|i| i.inner_impl().trait_.is_none());\n+    let tcx = cx.tcx();\n+    let is_alias = aliased_type.is_some();\n     if !non_trait.is_empty() {\n         let mut tmp_buf = Buffer::html();\n         let (render_mode, id, class_html) = match what {\n@@ -1165,6 +1216,12 @@ fn render_assoc_items_inner(\n         };\n         let mut impls_buf = Buffer::html();\n         for i in &non_trait {\n+            if !saw_impls.insert(i.def_id()) {\n+                continue;\n+            }\n+            if is_alias && !is_valid_impl_for(tcx, it, i.def_id()) {\n+                continue;\n+            }\n             render_impl(\n                 &mut impls_buf,\n                 cx,\n@@ -1193,9 +1250,14 @@ fn render_assoc_items_inner(\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n-        if let Some(impl_) = deref_impl {\n+        if let Some(impl_) = deref_impl &&\n+            (!is_alias || is_valid_impl_for(tcx, it, impl_.def_id()))\n+        {\n             let has_deref_mut =\n-                traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n+                traits.iter().any(|t| {\n+                    t.trait_did() == cx.tcx().lang_items().deref_mut_trait() &&\n+                    (!is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n+                });\n             render_deref_methods(&mut w, cx, impl_, containing_item, has_deref_mut, derefs);\n         }\n \n@@ -1205,10 +1267,14 @@ fn render_assoc_items_inner(\n             return;\n         }\n \n-        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n-            traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n-        let (blanket_impl, concrete): (Vec<&Impl>, _) =\n-            concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n+        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) = traits\n+            .into_iter()\n+            .filter(|t| saw_impls.insert(t.def_id()))\n+            .partition(|t| t.inner_impl().kind.is_auto());\n+        let (blanket_impl, concrete): (Vec<&Impl>, _) = concrete\n+            .into_iter()\n+            .filter(|t| !is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n+            .partition(|t| t.inner_impl().kind.is_blanket());\n \n         render_all_impls(w, cx, containing_item, &concrete, &synthetic, &blanket_impl);\n     }\n@@ -1247,10 +1313,10 @@ fn render_deref_methods(\n                 return;\n             }\n         }\n-        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n+        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n     } else if let Some(prim) = target.primitive_type() {\n         if let Some(&did) = cache.primitive_locations.get(&prim) {\n-            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n+            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n         }\n     }\n }"}, {"sha": "01089ed348bfdd3190dc796ebdee37a4d6d4d974", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4b1d13d9841c815915433ca2a3088a8e3e97ad96/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1d13d9841c815915433ca2a3088a8e3e97ad96/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=4b1d13d9841c815915433ca2a3088a8e3e97ad96", "patch": "@@ -260,7 +260,7 @@ fn item_template_render_assoc_items<'a: 'b, 'b, 'cx: 'a>(\n     display_fn(move |f| {\n         let (item, mut cx) = templ.item_and_mut_cx();\n         let def_id = item.item_id.expect_def_id();\n-        let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All);\n+        let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All, None);\n         write!(f, \"{v}\")\n     })\n }\n@@ -893,7 +893,11 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All));\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    );\n \n     let cloned_shared = Rc::clone(&cx.shared);\n     let cache = &cloned_shared.cache;\n@@ -1125,8 +1129,12 @@ fn item_trait_alias(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_opaque_ty(\n@@ -1154,8 +1162,12 @@ fn item_opaque_ty(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -1179,11 +1191,11 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let def_id = it.item_id.expect_def_id();\n-    // Render any items associated directly to this alias, as otherwise they\n-    // won't be visible anywhere in the docs. It would be nice to also show\n-    // associated items from the aliased type (see discussion in #32077), but\n-    // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, def_id, AssocItemRender::All, t.type_.def_id(&cx.cache()))\n+    );\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1423,7 +1435,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n         write!(w, \"</div>\");\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1466,7 +1478,7 @@ fn item_primitive(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::Ite\n     let def_id = it.item_id.expect_def_id();\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n     if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All)).unwrap();\n+        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None)).unwrap();\n     } else {\n         // We handle the \"reference\" primitive type on its own because we only want to list\n         // implementations on generic types.\n@@ -1571,7 +1583,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n         }\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1606,8 +1618,12 @@ fn item_foreign_type(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::\n     });\n \n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {"}]}