{"sha": "e42687478870e9a764feabc7277300f2afe7a2ac", "node_id": "C_kwDOAAsO6NoAKGU0MjY4NzQ3ODg3MGU5YTc2NGZlYWJjNzI3NzMwMGYyYWZlN2EyYWM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-23T09:50:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-23T09:50:17Z"}, "message": "Rollup merge of #103192 - petrochenkov:noalltraits, r=jyn514\n\nrustdoc: Eliminate uses of `EarlyDocLinkResolver::all_traits`\n\nAnother step to https://github.com/rust-lang/rust/pull/94857.", "tree": {"sha": "072f72e8d6993bf942ba030c44ac20ffa535d28d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/072f72e8d6993bf942ba030c44ac20ffa535d28d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e42687478870e9a764feabc7277300f2afe7a2ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjVQ5ZCRBK7hj4Ov3rIwAAXlwIAJMtufZ7bThqjAnmMZ5zJgBX\ndZzb+xBtrziSe5RrEZeTw/AaK6dCHWkHMqXXRrTIOUt2puRFo8FkhO4IDJcmE1sx\n2cy0WGhStkP7eI/0fzRpca37yejJ8RjEvcB4YWi9k+EgLFAR833U1RdSRS2PxDXW\nfw+hsq7CPa6X41p+YiQF1a0sFrh0W2YSEzAPFHw/gQruYE38uDzBo+OV6y+8TrxO\n+yAgAco0FeRyD78wK4lQZGxIdDG8YW9oHxAlNpWf9c7YNrLjrD++ekuh5KEeu+Sz\nr8nRQ2+3JAIVzxoAC7IB+5EngI032VopQhKiwfuKsiM7aVltEac6fQg9b2www38=\n=ucMp\n-----END PGP SIGNATURE-----\n", "payload": "tree 072f72e8d6993bf942ba030c44ac20ffa535d28d\nparent 518d5ebc81f027d57ed61dc6443fdef528843815\nparent 175474549ca2add0dec0bea1cca2ce0e32c24dc6\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1666518617 +0530\ncommitter GitHub <noreply@github.com> 1666518617 +0530\n\nRollup merge of #103192 - petrochenkov:noalltraits, r=jyn514\n\nrustdoc: Eliminate uses of `EarlyDocLinkResolver::all_traits`\n\nAnother step to https://github.com/rust-lang/rust/pull/94857.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e42687478870e9a764feabc7277300f2afe7a2ac", "html_url": "https://github.com/rust-lang/rust/commit/e42687478870e9a764feabc7277300f2afe7a2ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e42687478870e9a764feabc7277300f2afe7a2ac/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "518d5ebc81f027d57ed61dc6443fdef528843815", "url": "https://api.github.com/repos/rust-lang/rust/commits/518d5ebc81f027d57ed61dc6443fdef528843815", "html_url": "https://github.com/rust-lang/rust/commit/518d5ebc81f027d57ed61dc6443fdef528843815"}, {"sha": "175474549ca2add0dec0bea1cca2ce0e32c24dc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/175474549ca2add0dec0bea1cca2ce0e32c24dc6", "html_url": "https://github.com/rust-lang/rust/commit/175474549ca2add0dec0bea1cca2ce0e32c24dc6"}], "stats": {"total": 250, "additions": 117, "deletions": 133}, "files": [{"sha": "a0a0855251b8dc241837ce3e1488a9b8445b1184", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e42687478870e9a764feabc7277300f2afe7a2ac/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42687478870e9a764feabc7277300f2afe7a2ac/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=e42687478870e9a764feabc7277300f2afe7a2ac", "patch": "@@ -587,11 +587,6 @@ impl CStore {\n         self.get_crate_data(cnum).get_proc_macro_quoted_span(id, sess)\n     }\n \n-    /// Decodes all traits in the crate (for rustdoc).\n-    pub fn traits_in_crate_untracked(&self, cnum: CrateNum) -> impl Iterator<Item = DefId> + '_ {\n-        self.get_crate_data(cnum).get_traits()\n-    }\n-\n     /// Decodes all trait impls in the crate (for rustdoc).\n     pub fn trait_impls_in_crate_untracked(\n         &self,"}, {"sha": "7c59e785752dcc9cfccc65169b425455f2f1dcf1", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 102, "deletions": 94, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/e42687478870e9a764feabc7277300f2afe7a2ac/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42687478870e9a764feabc7277300f2afe7a2ac/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=e42687478870e9a764feabc7277300f2afe7a2ac", "patch": "@@ -13,116 +13,124 @@ pub(crate) struct BlanketImplFinder<'a, 'tcx> {\n \n impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n     pub(crate) fn get_blanket_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n-        let param_env = self.cx.tcx.param_env(item_def_id);\n-        let ty = self.cx.tcx.bound_type_of(item_def_id);\n+        let cx = &mut self.cx;\n+        let param_env = cx.tcx.param_env(item_def_id);\n+        let ty = cx.tcx.bound_type_of(item_def_id);\n \n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n-        self.cx.with_all_traits(|cx, all_traits| {\n-            for &trait_def_id in all_traits {\n-                if !cx.cache.access_levels.is_public(trait_def_id)\n-                    || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n-                {\n+        for trait_def_id in cx.tcx.all_traits() {\n+            if !cx.cache.access_levels.is_public(trait_def_id)\n+                || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n+            {\n+                continue;\n+            }\n+            // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n+            let trait_impls = cx.tcx.trait_impls_of(trait_def_id);\n+            'blanket_impls: for &impl_def_id in trait_impls.blanket_impls() {\n+                trace!(\n+                    \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n+                    trait_def_id,\n+                    impl_def_id\n+                );\n+                let trait_ref = cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+                if !matches!(trait_ref.0.self_ty().kind(), ty::Param(_)) {\n                     continue;\n                 }\n-                // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n-                let trait_impls = cx.tcx.trait_impls_of(trait_def_id);\n-                'blanket_impls: for &impl_def_id in trait_impls.blanket_impls() {\n-                    trace!(\n-                        \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n-                        trait_def_id,\n-                        impl_def_id\n-                    );\n-                    let trait_ref = cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n-                    if !matches!(trait_ref.0.self_ty().kind(), ty::Param(_)) {\n-                        continue;\n-                    }\n-                    let infcx = cx.tcx.infer_ctxt().build();\n-                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n-                    let impl_ty = ty.subst(infcx.tcx, substs);\n-                    let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n+                let infcx = cx.tcx.infer_ctxt().build();\n+                let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n+                let impl_ty = ty.subst(infcx.tcx, substs);\n+                let param_env = EarlyBinder(param_env).subst(infcx.tcx, substs);\n \n-                    let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                    let impl_trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+                let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                let impl_trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n \n-                    // Require the type the impl is implemented on to match\n-                    // our type, and ignore the impl if there was a mismatch.\n-                    let cause = traits::ObligationCause::dummy();\n-                    let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n+                // Require the type the impl is implemented on to match\n+                // our type, and ignore the impl if there was a mismatch.\n+                let cause = traits::ObligationCause::dummy();\n+                let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n                         continue\n                     };\n-                    let InferOk { value: (), obligations } = eq_result;\n-                    // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                    drop(obligations);\n+                let InferOk { value: (), obligations } = eq_result;\n+                // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                drop(obligations);\n \n-                    trace!(\n-                        \"invoking predicate_may_hold: param_env={:?}, impl_trait_ref={:?}, impl_ty={:?}\",\n+                trace!(\n+                    \"invoking predicate_may_hold: param_env={:?}, impl_trait_ref={:?}, impl_ty={:?}\",\n+                    param_env,\n+                    impl_trait_ref,\n+                    impl_ty\n+                );\n+                let predicates = cx\n+                    .tcx\n+                    .predicates_of(impl_def_id)\n+                    .instantiate(cx.tcx, impl_substs)\n+                    .predicates\n+                    .into_iter()\n+                    .chain(Some(\n+                        ty::Binder::dummy(impl_trait_ref)\n+                            .to_poly_trait_predicate()\n+                            .map_bound(ty::PredicateKind::Trait)\n+                            .to_predicate(infcx.tcx),\n+                    ));\n+                for predicate in predicates {\n+                    debug!(\"testing predicate {:?}\", predicate);\n+                    let obligation = traits::Obligation::new(\n+                        traits::ObligationCause::dummy(),\n                         param_env,\n-                        impl_trait_ref,\n-                        impl_ty\n+                        predicate,\n                     );\n-                    let predicates = cx\n-                        .tcx\n-                        .predicates_of(impl_def_id)\n-                        .instantiate(cx.tcx, impl_substs)\n-                        .predicates\n-                        .into_iter()\n-                        .chain(Some(\n-                            ty::Binder::dummy(impl_trait_ref)\n-                                .to_poly_trait_predicate()\n-                                .map_bound(ty::PredicateKind::Trait)\n-                                .to_predicate(infcx.tcx),\n-                        ));\n-                    for predicate in predicates {\n-                        debug!(\"testing predicate {:?}\", predicate);\n-                        let obligation = traits::Obligation::new(\n-                            traits::ObligationCause::dummy(),\n-                            param_env,\n-                            predicate,\n-                        );\n-                        match infcx.evaluate_obligation(&obligation) {\n-                            Ok(eval_result) if eval_result.may_apply() => {}\n-                            Err(traits::OverflowError::Canonical) => {}\n-                            Err(traits::OverflowError::ErrorReporting) => {}\n-                            _ => continue 'blanket_impls,\n-                        }\n+                    match infcx.evaluate_obligation(&obligation) {\n+                        Ok(eval_result) if eval_result.may_apply() => {}\n+                        Err(traits::OverflowError::Canonical) => {}\n+                        Err(traits::OverflowError::ErrorReporting) => {}\n+                        _ => continue 'blanket_impls,\n                     }\n-                    debug!(\n-                        \"get_blanket_impls: found applicable impl for trait_ref={:?}, ty={:?}\",\n-                        trait_ref, ty\n-                    );\n+                }\n+                debug!(\n+                    \"get_blanket_impls: found applicable impl for trait_ref={:?}, ty={:?}\",\n+                    trait_ref, ty\n+                );\n \n-                    cx.generated_synthetics.insert((ty.0, trait_def_id));\n+                cx.generated_synthetics.insert((ty.0, trait_def_id));\n \n-                    impls.push(Item {\n-                        name: None,\n-                        attrs: Default::default(),\n-                        visibility: Inherited,\n-                        item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n-                        kind: Box::new(ImplItem(Box::new(Impl {\n-                            unsafety: hir::Unsafety::Normal,\n-                            generics: clean_ty_generics(\n-                                cx,\n-                                cx.tcx.generics_of(impl_def_id),\n-                                cx.tcx.explicit_predicates_of(impl_def_id),\n-                            ),\n-                            // FIXME(eddyb) compute both `trait_` and `for_` from\n-                            // the post-inference `trait_ref`, as it's more accurate.\n-                            trait_: Some(clean_trait_ref_with_bindings(cx, trait_ref.0, ThinVec::new())),\n-                            for_: clean_middle_ty(ty.0, cx, None),\n-                            items: cx.tcx\n-                                .associated_items(impl_def_id)\n-                                .in_definition_order()\n-                                .map(|x| clean_middle_assoc_item(x, cx))\n-                                .collect::<Vec<_>>(),\n-                            polarity: ty::ImplPolarity::Positive,\n-                            kind: ImplKind::Blanket(Box::new(clean_middle_ty(trait_ref.0.self_ty(), cx, None))),\n-                        }))),\n-                        cfg: None,\n-                    });\n-                }\n+                impls.push(Item {\n+                    name: None,\n+                    attrs: Default::default(),\n+                    visibility: Inherited,\n+                    item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n+                    kind: Box::new(ImplItem(Box::new(Impl {\n+                        unsafety: hir::Unsafety::Normal,\n+                        generics: clean_ty_generics(\n+                            cx,\n+                            cx.tcx.generics_of(impl_def_id),\n+                            cx.tcx.explicit_predicates_of(impl_def_id),\n+                        ),\n+                        // FIXME(eddyb) compute both `trait_` and `for_` from\n+                        // the post-inference `trait_ref`, as it's more accurate.\n+                        trait_: Some(clean_trait_ref_with_bindings(\n+                            cx,\n+                            trait_ref.0,\n+                            ThinVec::new(),\n+                        )),\n+                        for_: clean_middle_ty(ty.0, cx, None),\n+                        items: cx\n+                            .tcx\n+                            .associated_items(impl_def_id)\n+                            .in_definition_order()\n+                            .map(|x| clean_middle_assoc_item(x, cx))\n+                            .collect::<Vec<_>>(),\n+                        polarity: ty::ImplPolarity::Positive,\n+                        kind: ImplKind::Blanket(Box::new(clean_middle_ty(\n+                            trait_ref.0.self_ty(),\n+                            cx,\n+                            None,\n+                        ))),\n+                    }))),\n+                    cfg: None,\n+                });\n             }\n-        });\n+        }\n \n         impls\n     }"}, {"sha": "8232353f915b948419eaedeb56a9591ca3575856", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e42687478870e9a764feabc7277300f2afe7a2ac/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42687478870e9a764feabc7277300f2afe7a2ac/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e42687478870e9a764feabc7277300f2afe7a2ac", "patch": "@@ -38,7 +38,6 @@ pub(crate) struct ResolverCaches {\n     /// Traits in scope for a given module.\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     pub(crate) traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n-    pub(crate) all_traits: Option<Vec<DefId>>,\n     pub(crate) all_trait_impls: Option<Vec<DefId>>,\n     pub(crate) all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n }\n@@ -134,12 +133,6 @@ impl<'tcx> DocContext<'tcx> {\n         }\n     }\n \n-    pub(crate) fn with_all_traits(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n-        let all_traits = self.resolver_caches.all_traits.take();\n-        f(self, all_traits.as_ref().expect(\"`all_traits` are already borrowed\"));\n-        self.resolver_caches.all_traits = all_traits;\n-    }\n-\n     pub(crate) fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n         let all_trait_impls = self.resolver_caches.all_trait_impls.take();\n         f(self, all_trait_impls.as_ref().expect(\"`all_trait_impls` are already borrowed\"));\n@@ -353,14 +346,8 @@ pub(crate) fn run_global_ctxt(\n     });\n     rustc_passes::stability::check_unused_or_stable_features(tcx);\n \n-    let auto_traits = resolver_caches\n-        .all_traits\n-        .as_ref()\n-        .expect(\"`all_traits` are already borrowed\")\n-        .iter()\n-        .copied()\n-        .filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id))\n-        .collect();\n+    let auto_traits =\n+        tcx.all_traits().filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id)).collect();\n     let access_levels = tcx.privacy_access_levels(()).map_id(Into::into);\n \n     let mut ctxt = DocContext {"}, {"sha": "d121a3e2aa4a9f750d60f78a3db0329b6782df0a", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e42687478870e9a764feabc7277300f2afe7a2ac/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42687478870e9a764feabc7277300f2afe7a2ac/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=e42687478870e9a764feabc7277300f2afe7a2ac", "patch": "@@ -37,7 +37,6 @@ pub(crate) fn early_resolve_intra_doc_links(\n         markdown_links: Default::default(),\n         doc_link_resolutions: Default::default(),\n         traits_in_scope: Default::default(),\n-        all_traits: Default::default(),\n         all_trait_impls: Default::default(),\n         all_macro_rules: Default::default(),\n         document_private_items,\n@@ -63,7 +62,6 @@ pub(crate) fn early_resolve_intra_doc_links(\n         markdown_links: Some(link_resolver.markdown_links),\n         doc_link_resolutions: link_resolver.doc_link_resolutions,\n         traits_in_scope: link_resolver.traits_in_scope,\n-        all_traits: Some(link_resolver.all_traits),\n         all_trait_impls: Some(link_resolver.all_trait_impls),\n         all_macro_rules: link_resolver.all_macro_rules,\n     }\n@@ -81,7 +79,6 @@ struct EarlyDocLinkResolver<'r, 'ra> {\n     markdown_links: FxHashMap<String, Vec<PreprocessedMarkdownLink>>,\n     doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<ast::NodeId>>>,\n     traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n-    all_traits: Vec<DefId>,\n     all_trait_impls: Vec<DefId>,\n     all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n     document_private_items: bool,\n@@ -122,8 +119,6 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         loop {\n             let crates = Vec::from_iter(self.resolver.cstore().crates_untracked());\n             for &cnum in &crates[start_cnum..] {\n-                let all_traits =\n-                    Vec::from_iter(self.resolver.cstore().traits_in_crate_untracked(cnum));\n                 let all_trait_impls =\n                     Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n                 let all_inherent_impls =\n@@ -132,20 +127,18 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                     self.resolver.cstore().incoherent_impls_in_crate_untracked(cnum),\n                 );\n \n-                // Querying traits in scope is expensive so we try to prune the impl and traits lists\n-                // using privacy, private traits and impls from other crates are never documented in\n+                // Querying traits in scope is expensive so we try to prune the impl lists using\n+                // privacy, private traits and impls from other crates are never documented in\n                 // the current crate, and links in their doc comments are not resolved.\n-                for &def_id in &all_traits {\n-                    if self.resolver.cstore().visibility_untracked(def_id).is_public() {\n-                        self.resolve_doc_links_extern_impl(def_id, false);\n-                    }\n-                }\n                 for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n                     if self.resolver.cstore().visibility_untracked(trait_def_id).is_public()\n                         && simplified_self_ty.and_then(|ty| ty.def()).map_or(true, |ty_def_id| {\n                             self.resolver.cstore().visibility_untracked(ty_def_id).is_public()\n                         })\n                     {\n+                        if self.visited_mods.insert(trait_def_id) {\n+                            self.resolve_doc_links_extern_impl(trait_def_id, false);\n+                        }\n                         self.resolve_doc_links_extern_impl(impl_def_id, false);\n                     }\n                 }\n@@ -158,7 +151,6 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                     self.resolve_doc_links_extern_impl(impl_def_id, true);\n                 }\n \n-                self.all_traits.extend(all_traits);\n                 self.all_trait_impls\n                     .extend(all_trait_impls.into_iter().map(|(_, def_id, _)| def_id));\n             }\n@@ -307,15 +299,20 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n             {\n                 if let Some(def_id) = child.res.opt_def_id() && !def_id.is_local() {\n                     let scope_id = match child.res {\n-                        Res::Def(DefKind::Variant, ..) => self.resolver.parent(def_id),\n+                        Res::Def(\n+                            DefKind::Variant\n+                            | DefKind::AssocTy\n+                            | DefKind::AssocFn\n+                            | DefKind::AssocConst,\n+                            ..,\n+                        ) => self.resolver.parent(def_id),\n                         _ => def_id,\n                     };\n                     self.resolve_doc_links_extern_outer(def_id, scope_id); // Outer attribute scope\n                     if let Res::Def(DefKind::Mod, ..) = child.res {\n                         self.resolve_doc_links_extern_inner(def_id); // Inner attribute scope\n                     }\n-                    // `DefKind::Trait`s are processed in `process_extern_impls`.\n-                    if let Res::Def(DefKind::Mod | DefKind::Enum, ..) = child.res {\n+                    if let Res::Def(DefKind::Mod | DefKind::Enum | DefKind::Trait, ..) = child.res {\n                         self.process_module_children_or_reexports(def_id);\n                     }\n                     if let Res::Def(DefKind::Struct | DefKind::Union | DefKind::Variant, _) =\n@@ -357,9 +354,6 @@ impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n             self.parent_scope.module = old_module;\n         } else {\n             match &item.kind {\n-                ItemKind::Trait(..) => {\n-                    self.all_traits.push(self.resolver.local_def_id(item.id).to_def_id());\n-                }\n                 ItemKind::Impl(box ast::Impl { of_trait: Some(..), .. }) => {\n                     self.all_trait_impls.push(self.resolver.local_def_id(item.id).to_def_id());\n                 }"}]}