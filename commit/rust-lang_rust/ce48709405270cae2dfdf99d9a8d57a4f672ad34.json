{"sha": "ce48709405270cae2dfdf99d9a8d57a4f672ad34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNDg3MDk0MDUyNzBjYWUyZGZkZjk5ZDlhOGQ1N2E0ZjY3MmFkMzQ=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-01-14T18:00:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-14T18:00:11Z"}, "message": "Rollup merge of #80895 - sfackler:read-to-end-ub, r=m-ou-se\n\nFix handling of malicious Readers in read_to_end\n\nA malicious `Read` impl could return overly large values from `read`, which would result in the guard's drop impl setting the buffer's length to greater than its capacity! ~~To fix this, the drop impl now uses the safe `truncate` function instead of `set_len` which ensures that this will not happen. The result of calling the function will be nonsensical, but that's fine given the contract violation of the `Read` impl.~~\n\n~~The `Guard` type is also used by `append_to_string` which does not pass untrusted values into the length field, so I've copied the guard type into each function and only modified the one used by `read_to_end`. We could just keep a single one and modify it, but it seems a bit cleaner to keep the guard code close to the functions and related specifically to them.~~\n\nTo fix this, we now assert that the returned length is not larger than the buffer passed to the method.\n\nFor reference, this bug has been present for ~2.5 years since 1.20: https://github.com/rust-lang/rust/commit/ecbb896b9eb2acadefde57be493e4298c1aa04a3.\n\nCloses #80894.", "tree": {"sha": "f6beea366bf91ad77fb7157323b52591dfe95a3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6beea366bf91ad77fb7157323b52591dfe95a3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce48709405270cae2dfdf99d9a8d57a4f672ad34", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgAIarCRBK7hj4Ov3rIwAAdHIIAGcj5AAdsrkTdC/GKQc4CXgm\n+pqhdb/mQMRC2mvFxHMP8AgZLy3whOI4XsYaMsaEL27i6yuFaQpILAQO7u4bXiM+\nxZLmmSntfLzxss1grpDYryRogatmdKeVuNsgsl2tUifQ4ISRbJYHDTNrcfiXNd1v\nCLJaWBeKbh7JqYAXUJtivFsDNORsoJTGFdXzvQqMCa5qA36jVg9XzxvM2vIgW5uT\nG9AbXHPDp+n1geREumTU+Pl3qMLRor/d/3ZjDUModxYK4UmQF5HaNUVKr6I7k82q\nwnGJumYcCMzxjYIxaksEVlfLUtlv3leOdz1m9Ph7CbjLaEExN0XgaMLWL95Refg=\n=1d7K\n-----END PGP SIGNATURE-----\n", "payload": "tree f6beea366bf91ad77fb7157323b52591dfe95a3a\nparent 9e9aba87af74362f9fcf5e077c7a53412dd41f28\nparent e6c07b0628938b0003ecbae0f60b588eebf474aa\nauthor Mara Bos <m-ou.se@m-ou.se> 1610647211 +0000\ncommitter GitHub <noreply@github.com> 1610647211 +0000\n\nRollup merge of #80895 - sfackler:read-to-end-ub, r=m-ou-se\n\nFix handling of malicious Readers in read_to_end\n\nA malicious `Read` impl could return overly large values from `read`, which would result in the guard's drop impl setting the buffer's length to greater than its capacity! ~~To fix this, the drop impl now uses the safe `truncate` function instead of `set_len` which ensures that this will not happen. The result of calling the function will be nonsensical, but that's fine given the contract violation of the `Read` impl.~~\n\n~~The `Guard` type is also used by `append_to_string` which does not pass untrusted values into the length field, so I've copied the guard type into each function and only modified the one used by `read_to_end`. We could just keep a single one and modify it, but it seems a bit cleaner to keep the guard code close to the functions and related specifically to them.~~\n\nTo fix this, we now assert that the returned length is not larger than the buffer passed to the method.\n\nFor reference, this bug has been present for ~2.5 years since 1.20: https://github.com/rust-lang/rust/commit/ecbb896b9eb2acadefde57be493e4298c1aa04a3.\n\nCloses #80894.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce48709405270cae2dfdf99d9a8d57a4f672ad34", "html_url": "https://github.com/rust-lang/rust/commit/ce48709405270cae2dfdf99d9a8d57a4f672ad34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce48709405270cae2dfdf99d9a8d57a4f672ad34/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e9aba87af74362f9fcf5e077c7a53412dd41f28", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e9aba87af74362f9fcf5e077c7a53412dd41f28", "html_url": "https://github.com/rust-lang/rust/commit/9e9aba87af74362f9fcf5e077c7a53412dd41f28"}, {"sha": "e6c07b0628938b0003ecbae0f60b588eebf474aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c07b0628938b0003ecbae0f60b588eebf474aa", "html_url": "https://github.com/rust-lang/rust/commit/e6c07b0628938b0003ecbae0f60b588eebf474aa"}], "stats": {"total": 22, "additions": 10, "deletions": 12}, "files": [{"sha": "3f5b7c0b29be692a611f7c51d53a642247ef2a55", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce48709405270cae2dfdf99d9a8d57a4f672ad34/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce48709405270cae2dfdf99d9a8d57a4f672ad34/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=ce48709405270cae2dfdf99d9a8d57a4f672ad34", "patch": "@@ -366,7 +366,6 @@ where\n {\n     let start_len = buf.len();\n     let mut g = Guard { len: buf.len(), buf };\n-    let ret;\n     loop {\n         if g.len == g.buf.len() {\n             unsafe {\n@@ -385,21 +384,20 @@ where\n             }\n         }\n \n-        match r.read(&mut g.buf[g.len..]) {\n-            Ok(0) => {\n-                ret = Ok(g.len - start_len);\n-                break;\n+        let buf = &mut g.buf[g.len..];\n+        match r.read(buf) {\n+            Ok(0) => return Ok(g.len - start_len),\n+            Ok(n) => {\n+                // We can't allow bogus values from read. If it is too large, the returned vec could have its length\n+                // set past its capacity, or if it overflows the vec could be shortened which could create an invalid\n+                // string if this is called via read_to_string.\n+                assert!(n <= buf.len());\n+                g.len += n;\n             }\n-            Ok(n) => g.len += n,\n             Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-            Err(e) => {\n-                ret = Err(e);\n-                break;\n-            }\n+            Err(e) => return Err(e),\n         }\n     }\n-\n-    ret\n }\n \n pub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>"}]}