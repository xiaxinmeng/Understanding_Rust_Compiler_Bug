{"sha": "075fd364d06d89f5cd79308938e3ed4a5893ec84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NWZkMzY0ZDA2ZDg5ZjVjZDc5MzA4OTM4ZTNlZDRhNTg5M2VjODQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-07-10T18:04:15Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-07-28T13:46:23Z"}, "message": "Ensure upvars are dropped when generators have never been resumed", "tree": {"sha": "11775289ffb18bd2216bc57d18efbd3ddd254028", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11775289ffb18bd2216bc57d18efbd3ddd254028"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/075fd364d06d89f5cd79308938e3ed4a5893ec84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/075fd364d06d89f5cd79308938e3ed4a5893ec84", "html_url": "https://github.com/rust-lang/rust/commit/075fd364d06d89f5cd79308938e3ed4a5893ec84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/075fd364d06d89f5cd79308938e3ed4a5893ec84/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "facabcb85ef4e49ecc83ca942c38ade3dd70a5cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/facabcb85ef4e49ecc83ca942c38ade3dd70a5cf", "html_url": "https://github.com/rust-lang/rust/commit/facabcb85ef4e49ecc83ca942c38ade3dd70a5cf"}], "stats": {"total": 166, "additions": 118, "deletions": 48}, "files": [{"sha": "a2c1cf415974d3e71e2f8dfcfdd6b2302ceee331", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 115, "deletions": 43, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/075fd364d06d89f5cd79308938e3ed4a5893ec84/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075fd364d06d89f5cd79308938e3ed4a5893ec84/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=075fd364d06d89f5cd79308938e3ed4a5893ec84", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n                     lvalue: &mut Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n-        if *lvalue == Lvalue::Local(Local::new(2)) {\n+        if *lvalue == Lvalue::Local(Local::new(1)) {\n             *lvalue = Lvalue::Projection(Box::new(Projection {\n                 base: lvalue.clone(),\n                 elem: ProjectionElem::Deref,\n@@ -114,10 +114,6 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n \n     fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n         let base = Lvalue::Local(Local::new(1));\n-        let base = Lvalue::Projection(Box::new(Projection {\n-            base: base,\n-            elem: ProjectionElem::Deref,\n-        }));\n         let field = Projection {\n             base: base,\n             elem: ProjectionElem::Field(Field::new(idx), ty),\n@@ -258,6 +254,23 @@ fn ensure_generator_state_argument<'a, 'tcx>(\n \n     let gen_ty = mir.local_decls.raw[2].ty;\n \n+    // Swap generator and implicit argument\n+    SwapLocalVisitor {\n+        a: Local::new(1),\n+        b: Local::new(2),\n+    }.visit_mir(mir);\n+\n+    mir.local_decls.raw[..].swap(1, 2);\n+\n+    (gen_ty, interior)\n+}\n+\n+fn make_generator_state_argument_indirect<'a, 'tcx>(\n+                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                def_id: DefId,\n+                mir: &mut Mir<'tcx>) {\n+    let gen_ty = mir.local_decls.raw[1].ty;\n+\n     let region = ty::ReFree(ty::FreeRegion {\n         scope: def_id,\n         bound_region: ty::BoundRegion::BrEnv,\n@@ -271,20 +284,10 @@ fn ensure_generator_state_argument<'a, 'tcx>(\n     });\n \n     // Replace the by value generator argument\n-    mir.local_decls.raw[2].ty = ref_gen_ty;\n+    mir.local_decls.raw[1].ty = ref_gen_ty;\n \n-    // Add a deref to accesses of the generator state for upvars\n+    // Add a deref to accesses of the generator state\n     DerefArgVisitor.visit_mir(mir);\n-\n-    // Swap generator and implicit argument\n-    SwapLocalVisitor {\n-        a: Local::new(1),\n-        b: Local::new(2),\n-    }.visit_mir(mir);\n-\n-    mir.local_decls.raw[..].swap(1, 2);\n-\n-    (gen_ty, interior)\n }\n \n fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n@@ -412,7 +415,7 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     use shim::DropShimElaborator;\n \n     let param_env = tcx.param_env(def_id);\n-    let gen = Local::new(2);\n+    let gen = Local::new(1);\n \n     for block in mir.basic_blocks().indices() {\n         let (target, unwind, source_info) = match mir.basic_blocks()[block].terminator() {\n@@ -460,12 +463,14 @@ fn generate_drop<'a, 'tcx>(\n                 def_id: DefId,\n                 source: MirSource,\n                 gen_ty: Ty<'tcx>,\n-                mir: &mut Mir<'tcx>) {\n+                mir: &mut Mir<'tcx>,\n+                drop_clean: BasicBlock) {\n     let source_info = SourceInfo {\n         span: mir.span,\n         scope: ARGUMENT_VISIBILITY_SCOPE,\n     };\n \n+    let return_block = BasicBlock::new(mir.basic_blocks().len());\n     mir.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n@@ -475,10 +480,12 @@ fn generate_drop<'a, 'tcx>(\n         is_cleanup: false,\n     });\n \n-    let cases: Vec<_> = transform.bb_targets.iter().filter_map(|(&(r, u), &s)| {\n+    let mut cases: Vec<_> = transform.bb_targets.iter().filter_map(|(&(r, u), &s)| {\n         u.map(|d| (s, d))\n     }).collect();\n \n+    cases.insert(0, (0, drop_clean));\n+\n     // The poisoned state 1 falls through to the default case which is just to return\n \n     let switch = TerminatorKind::SwitchInt {\n@@ -487,7 +494,7 @@ fn generate_drop<'a, 'tcx>(\n         values: Cow::from(cases.iter().map(|&(i, _)| {\n                 ConstInt::U32(i)\n             }).collect::<Vec<_>>()),\n-        targets: cases.iter().map(|&(_, d)| d).chain(once(transform.return_block)).collect(),\n+        targets: cases.iter().map(|&(_, d)| d).chain(once(return_block)).collect(),\n     };\n \n     insert_entry_point(mir, BasicBlockData {\n@@ -525,6 +532,8 @@ fn generate_drop<'a, 'tcx>(\n         is_user_variable: false,\n     };\n \n+    make_generator_state_argument_indirect(tcx, def_id, mir);\n+\n     // Change the generator argument from &mut to *mut\n     mir.local_decls[Local::new(1)] = LocalDecl {\n         mutability: Mutability::Mut,\n@@ -544,21 +553,9 @@ fn generate_drop<'a, 'tcx>(\n     dump_mir(tcx, None, \"generator_drop\", &0, source, mir);\n }\n \n-fn generate_resume<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                mut transform: TransformVisitor<'a, 'tcx>,\n-                node_id: NodeId,\n-                def_id: DefId,\n-                source: MirSource,\n-                mir: &mut Mir<'tcx>) {\n-    // Poison the generator when it unwinds\n-    for block in mir.basic_blocks_mut() {\n-        let source_info = block.terminator().source_info;\n-        if let &TerminatorKind::Resume = &block.terminator().kind {\n-            block.statements.push(transform.set_state(1, source_info));\n-        }\n-    }\n-\n+fn insert_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        def_id: DefId,\n+                                        mir: &mut Mir<'tcx>) -> Option<BasicBlock> {\n     let drop_arg = mir.local_decls.raw[2].ty.needs_drop(tcx, tcx.param_env(def_id));\n \n     let cleanup = if drop_arg {\n@@ -567,6 +564,7 @@ fn generate_resume<'a, 'tcx>(\n         None\n     };\n \n+    let assert_block = BasicBlock::new(mir.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n             span: mir.span,\n@@ -577,7 +575,7 @@ fn generate_resume<'a, 'tcx>(\n         }),\n         expected: true,\n         msg: AssertMessage::GeneratorResumedAfterReturn,\n-        target: transform.return_block,\n+        target: assert_block,\n         cleanup: cleanup,\n     };\n \n@@ -623,6 +621,30 @@ fn generate_resume<'a, 'tcx>(\n         });\n     }\n \n+    cleanup\n+}\n+\n+fn generate_resume<'a, 'tcx>(\n+                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                mut transform: TransformVisitor<'a, 'tcx>,\n+                node_id: NodeId,\n+                def_id: DefId,\n+                source: MirSource,\n+                cleanup: Option<BasicBlock>,\n+                mir: &mut Mir<'tcx>) {\n+    // Poison the generator when it unwinds\n+    for block in mir.basic_blocks_mut() {\n+        let source_info = block.terminator().source_info;\n+        if let &TerminatorKind::Resume = &block.terminator().kind {\n+            block.statements.push(transform.set_state(1, source_info));\n+        }\n+    }\n+\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n     let poisoned_block = BasicBlock::new(mir.basic_blocks().len());\n \n     let term = TerminatorKind::Assert {\n@@ -671,13 +693,50 @@ fn generate_resume<'a, 'tcx>(\n         is_cleanup: false,\n     });\n \n+    make_generator_state_argument_indirect(tcx, def_id, mir);\n+\n     // Make sure we remove dead blocks to remove\n     // unrelated code from the drop part of the function\n     simplify::remove_dead_blocks(mir);\n \n     dump_mir(tcx, None, \"generator_resume\", &0, source, mir);\n }\n \n+fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> (BasicBlock, BasicBlock) {\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    let return_block = BasicBlock::new(mir.basic_blocks().len());\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: TerminatorKind::Return,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    // Create a block to destroy an unresumed generators. This can only destroy upvars.\n+    let drop_clean = BasicBlock::new(mir.basic_blocks().len());\n+    let term = TerminatorKind::Drop {\n+        location: Lvalue::Local(Local::new(1)),\n+        target: return_block,\n+        unwind: None,\n+    };\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: term,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    (return_block, drop_clean)\n+}\n+\n impl MirPass for StateTransform {\n     fn run_pass<'a, 'tcx>(&self,\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -695,8 +754,6 @@ impl MirPass for StateTransform {\n         let node_id = source.item_id();\n         let def_id = tcx.hir.local_def_id(source.item_id());\n \n-        elaborate_generator_drops(tcx, def_id, mir);\n-\n         let (gen_ty, interior) = ensure_generator_state_argument(tcx, node_id, def_id, mir);\n \n         let state_did = tcx.lang_items.gen_state().unwrap();\n@@ -709,7 +766,7 @@ impl MirPass for StateTransform {\n \n         let (remap, layout) = compute_layout(tcx, def_id, source, interior, mir);\n \n-        let return_block = BasicBlock::new(mir.basic_blocks().len());\n+        let tail_block = BasicBlock::new(mir.basic_blocks().len());\n \n         let state_field = mir.upvar_decls.len();\n \n@@ -724,7 +781,7 @@ impl MirPass for StateTransform {\n             bb_target_count: 2,\n             bb_targets,\n             new_ret_local,\n-            return_block,\n+            return_block: tail_block,\n             state_field,\n         };\n         transform.visit_mir(mir);\n@@ -735,14 +792,29 @@ impl MirPass for StateTransform {\n         mir.spread_arg = None;\n         mir.generator_layout = Some(layout);\n \n+        let arg_cleanup = insert_resume_after_return(tcx, def_id, mir);\n+\n+        let (_return_block, drop_clean) = insert_clean_drop(mir);\n+\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir);\n+\n+        elaborate_generator_drops(tcx, def_id, mir);\n+\n         dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir);\n \n         let mut drop_impl = mir.clone();\n \n-        generate_drop(tcx, &transform, node_id, def_id, source, gen_ty, &mut drop_impl);\n+        generate_drop(tcx,\n+                      &transform,\n+                      node_id,\n+                      def_id,\n+                      source,\n+                      gen_ty,\n+                      &mut drop_impl,\n+                      drop_clean);\n \n         mir.generator_drop = Some(box drop_impl);\n \n-        generate_resume(tcx, transform, node_id, def_id, source, mir);\n+        generate_resume(tcx, transform, node_id, def_id, source, arg_cleanup, mir);\n     }\n }"}, {"sha": "0f8d29e5cabb79b85166e0999bdab66d0c8851dc", "filename": "src/test/compile-fail/generator/no-arguments-on-generators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/075fd364d06d89f5cd79308938e3ed4a5893ec84/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fno-arguments-on-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075fd364d06d89f5cd79308938e3ed4a5893ec84/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fno-arguments-on-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fno-arguments-on-generators.rs?ref=075fd364d06d89f5cd79308938e3ed4a5893ec84", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     let gen = |start| { //~ ERROR generators cannot have explicit arguments\n         yield;\n-    }; \n+    };\n }\n\\ No newline at end of file"}, {"sha": "1b0df6f87236ebe7121ed249af1d1a1c6d28c6da", "filename": "src/test/run-pass/generator/drop-env.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/075fd364d06d89f5cd79308938e3ed4a5893ec84/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075fd364d06d89f5cd79308938e3ed4a5893ec84/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs?ref=075fd364d06d89f5cd79308938e3ed4a5893ec84", "patch": "@@ -58,7 +58,7 @@ fn t2() {\n \n fn t3() {\n     let b = B;\n-    let mut foo = || {\n+    let foo = || {\n         let _: () = gen arg; // TODO: this line should not be necessary\n         yield;\n         drop(b);\n@@ -67,7 +67,5 @@ fn t3() {\n     let n = A.load(Ordering::SeqCst);\n     assert_eq!(A.load(Ordering::SeqCst), n);\n     drop(foo);\n-    // TODO: we should assert n+1 here, not n\n-    // assert_eq!(A.load(Ordering::SeqCst), n + 1);\n-    assert_eq!(A.load(Ordering::SeqCst), n);\n+    assert_eq!(A.load(Ordering::SeqCst), n + 1);\n }"}]}