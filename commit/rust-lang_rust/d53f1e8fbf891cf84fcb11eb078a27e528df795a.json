{"sha": "d53f1e8fbf891cf84fcb11eb078a27e528df795a", "node_id": "C_kwDOAAsO6NoAKGQ1M2YxZThmYmY4OTFjZjg0ZmNiMTFlYjA3OGEyN2U1MjhkZjc5NWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-10T08:12:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-10T08:12:50Z"}, "message": "Auto merge of #96891 - Dylan-DPC:rollup-echa4wg, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #93661 (Add missing rustc arg docs)\n - #96674 (docs: add link explaining variance to NonNull docs)\n - #96812 (Do not lint on explicit outlives requirements from external macros.)\n - #96823 (Properly fix #96638)\n - #96872 (make sure ScalarPair enums have ScalarPair variants; add some layout sanity checks)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "61c1d67b743326a6e62a8dfacff273877dad1000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61c1d67b743326a6e62a8dfacff273877dad1000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d53f1e8fbf891cf84fcb11eb078a27e528df795a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d53f1e8fbf891cf84fcb11eb078a27e528df795a", "html_url": "https://github.com/rust-lang/rust/commit/d53f1e8fbf891cf84fcb11eb078a27e528df795a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d53f1e8fbf891cf84fcb11eb078a27e528df795a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2226f19f701fa53172fa48406c0f4ccb96b88ee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2226f19f701fa53172fa48406c0f4ccb96b88ee6", "html_url": "https://github.com/rust-lang/rust/commit/2226f19f701fa53172fa48406c0f4ccb96b88ee6"}, {"sha": "ec53c379ccb79257f4802a883b42789daec00c50", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec53c379ccb79257f4802a883b42789daec00c50", "html_url": "https://github.com/rust-lang/rust/commit/ec53c379ccb79257f4802a883b42789daec00c50"}], "stats": {"total": 541, "additions": 422, "deletions": 119}, "files": [{"sha": "5a985be08a133229810211dffeb81e4cd59bb187", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -38,7 +38,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n use rustc_hir::{ForeignItemKind, GenericParamKind, HirId, PatKind, PredicateOrigin};\n use rustc_index::vec::Idx;\n-use rustc_middle::lint::LintDiagnosticBuilder;\n+use rustc_middle::lint::{in_external_macro, LintDiagnosticBuilder};\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n@@ -2115,6 +2115,7 @@ impl ExplicitOutlivesRequirements {\n                     None\n                 }\n             })\n+            .filter(|(_, span)| !in_external_macro(tcx.sess, *span))\n             .collect()\n     }\n "}, {"sha": "c8055100d30968a5c1c9f0df09fa9d5400b72f38", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 127, "deletions": 9, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -221,6 +221,111 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n+/// Enforce some basic invariants on layouts.\n+fn sanity_check_layout<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    layout: &TyAndLayout<'tcx>,\n+) {\n+    // Type-level uninhabitedness should always imply ABI uninhabitedness.\n+    if tcx.conservative_is_privately_uninhabited(param_env.and(layout.ty)) {\n+        assert!(layout.abi.is_uninhabited());\n+    }\n+\n+    if cfg!(debug_assertions) {\n+        fn check_layout_abi<'tcx>(tcx: TyCtxt<'tcx>, layout: Layout<'tcx>) {\n+            match layout.abi() {\n+                Abi::Scalar(_scalar) => {\n+                    // No padding in scalars.\n+                    /* FIXME(#96185):\n+                    assert_eq!(\n+                        layout.align().abi,\n+                        scalar.align(&tcx).abi,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    assert_eq!(\n+                        layout.size(),\n+                        scalar.size(&tcx),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );*/\n+                }\n+                Abi::Vector { count, element } => {\n+                    // No padding in vectors. Alignment can be strengthened, though.\n+                    assert!(\n+                        layout.align().abi >= element.align(&tcx).abi,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    let size = element.size(&tcx) * count;\n+                    assert_eq!(\n+                        layout.size(),\n+                        size.align_to(tcx.data_layout().vector_align(size).abi),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                }\n+                Abi::ScalarPair(scalar1, scalar2) => {\n+                    // Sanity-check scalar pairs. These are a bit more flexible and support\n+                    // padding, but we can at least ensure both fields actually fit into the layout\n+                    // and the alignment requirement has not been weakened.\n+                    let align1 = scalar1.align(&tcx).abi;\n+                    let align2 = scalar2.align(&tcx).abi;\n+                    assert!(\n+                        layout.align().abi >= cmp::max(align1, align2),\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n+                    );\n+                    let field2_offset = scalar1.size(&tcx).align_to(align2);\n+                    assert!(\n+                        layout.size() >= field2_offset + scalar2.size(&tcx),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                }\n+                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n+            }\n+        }\n+\n+        check_layout_abi(tcx, layout.layout);\n+\n+        if let Variants::Multiple { variants, .. } = &layout.variants {\n+            for variant in variants {\n+                check_layout_abi(tcx, *variant);\n+                // No nested \"multiple\".\n+                assert!(matches!(variant.variants(), Variants::Single { .. }));\n+                // Skip empty variants.\n+                if variant.size() == Size::ZERO\n+                    || variant.fields().count() == 0\n+                    || variant.abi().is_uninhabited()\n+                {\n+                    // These are never actually accessed anyway, so we can skip them. (Note that\n+                    // sometimes, variants with fields have size 0, and sometimes, variants without\n+                    // fields have non-0 size.)\n+                    continue;\n+                }\n+                // Variants should have the same or a smaller size as the full thing.\n+                if variant.size() > layout.size {\n+                    bug!(\n+                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n+                        layout.size.bytes(),\n+                        variant.size().bytes(),\n+                    )\n+                }\n+                // The top-level ABI and the ABI of the variants should be coherent.\n+                let abi_coherent = match (layout.abi, variant.abi()) {\n+                    (Abi::Scalar(..), Abi::Scalar(..)) => true,\n+                    (Abi::ScalarPair(..), Abi::ScalarPair(..)) => true,\n+                    (Abi::Uninhabited, _) => true,\n+                    (Abi::Aggregate { .. }, _) => true,\n+                    _ => false,\n+                };\n+                if !abi_coherent {\n+                    bug!(\n+                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n+                        variant\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[instrument(skip(tcx, query), level = \"debug\")]\n fn layout_of<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -264,10 +369,7 @@ fn layout_of<'tcx>(\n \n             cx.record_layout_for_printing(layout);\n \n-            // Type-level uninhabitedness should always imply ABI uninhabitedness.\n-            if tcx.conservative_is_privately_uninhabited(param_env.and(ty)) {\n-                assert!(layout.abi.is_uninhabited());\n-            }\n+            sanity_check_layout(tcx, param_env, &layout);\n \n             Ok(layout)\n         })\n@@ -1314,9 +1416,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 };\n                 let mut abi = Abi::Aggregate { sized: true };\n \n-                // Without latter check aligned enums with custom discriminant values\n-                // Would result in ICE see the issue #92464 for more info\n-                if tag.size(dl) == size || variants.iter().all(|layout| layout.is_empty()) {\n+                if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n+                    abi = Abi::Uninhabited;\n+                } else if tag.size(dl) == size || variants.iter().all(|layout| layout.is_empty()) {\n+                    // Without latter check aligned enums with custom discriminant values\n+                    // Would result in ICE see the issue #92464 for more info\n                     abi = Abi::Scalar(tag);\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n@@ -1390,8 +1494,22 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     }\n                 }\n \n-                if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n-                    abi = Abi::Uninhabited;\n+                // If we pick a \"clever\" (by-value) ABI, we might have to adjust the ABI of the\n+                // variants to ensure they are consistent. This is because a downcast is\n+                // semantically a NOP, and thus should not affect layout.\n+                if matches!(abi, Abi::Scalar(..) | Abi::ScalarPair(..)) {\n+                    for variant in &mut layout_variants {\n+                        // We only do this for variants with fields; the others are not accessed anyway.\n+                        // Also do not overwrite any already existing \"clever\" ABIs.\n+                        if variant.fields.count() > 0\n+                            && matches!(variant.abi, Abi::Aggregate { .. })\n+                        {\n+                            variant.abi = abi;\n+                            // Also need to bump up the size and alignment, so that the entire value fits in here.\n+                            variant.size = cmp::max(variant.size, size);\n+                            variant.align.abi = cmp::max(variant.align.abi, align.abi);\n+                        }\n+                    }\n                 }\n \n                 let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);"}, {"sha": "b7ba9d978784627a3752e6c374b067dc05d26538", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/arg_matrix.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -3,6 +3,7 @@ use std::cmp;\n use rustc_middle::ty::error::TypeError;\n \n // An issue that might be found in the compatibility matrix\n+#[derive(Debug)]\n enum Issue {\n     /// The given argument is the invalid type for the input\n     Invalid(usize),\n@@ -23,9 +24,10 @@ pub(crate) enum Compatibility<'tcx> {\n }\n \n /// Similar to `Issue`, but contains some extra information\n+#[derive(Debug)]\n pub(crate) enum Error<'tcx> {\n-    /// The given argument is the invalid type for the input\n-    Invalid(usize, Compatibility<'tcx>),\n+    /// The provided argument is the invalid type for the expected input\n+    Invalid(usize, usize, Compatibility<'tcx>), // provided, expected\n     /// There is a missing input\n     Missing(usize),\n     /// There's a superfluous argument\n@@ -37,8 +39,15 @@ pub(crate) enum Error<'tcx> {\n }\n \n pub(crate) struct ArgMatrix<'tcx> {\n+    /// Maps the indices in the `compatibility_matrix` rows to the indices of\n+    /// the *user provided* inputs\n     input_indexes: Vec<usize>,\n+    /// Maps the indices in the `compatibility_matrix` columns to the indices\n+    /// of the *expected* args\n     arg_indexes: Vec<usize>,\n+    /// The first dimension (rows) are the remaining user provided inputs to\n+    /// match and the second dimension (cols) are the remaining expected args\n+    /// to match\n     compatibility_matrix: Vec<Vec<Compatibility<'tcx>>>,\n }\n \n@@ -52,24 +61,24 @@ impl<'tcx> ArgMatrix<'tcx> {\n             .map(|i| (0..minimum_input_count).map(|j| is_compatible(i, j)).collect())\n             .collect();\n         ArgMatrix {\n-            input_indexes: (0..minimum_input_count).collect(),\n-            arg_indexes: (0..provided_arg_count).collect(),\n+            input_indexes: (0..provided_arg_count).collect(),\n+            arg_indexes: (0..minimum_input_count).collect(),\n             compatibility_matrix,\n         }\n     }\n \n     /// Remove a given input from consideration\n     fn eliminate_input(&mut self, idx: usize) {\n         self.input_indexes.remove(idx);\n-        for row in &mut self.compatibility_matrix {\n-            row.remove(idx);\n-        }\n+        self.compatibility_matrix.remove(idx);\n     }\n \n     /// Remove a given argument from consideration\n     fn eliminate_arg(&mut self, idx: usize) {\n         self.arg_indexes.remove(idx);\n-        self.compatibility_matrix.remove(idx);\n+        for row in &mut self.compatibility_matrix {\n+            row.remove(idx);\n+        }\n     }\n \n     /// \"satisfy\" an input with a given arg, removing both from consideration\n@@ -78,21 +87,23 @@ impl<'tcx> ArgMatrix<'tcx> {\n         self.eliminate_arg(arg_idx);\n     }\n \n+    // Returns a `Vec` of (user input, expected arg) of matched arguments. These\n+    // are inputs on the remaining diagonal that match.\n     fn eliminate_satisfied(&mut self) -> Vec<(usize, usize)> {\n         let mut i = cmp::min(self.input_indexes.len(), self.arg_indexes.len());\n         let mut eliminated = vec![];\n         while i > 0 {\n             let idx = i - 1;\n             if matches!(self.compatibility_matrix[idx][idx], Compatibility::Compatible) {\n-                eliminated.push((self.arg_indexes[idx], self.input_indexes[idx]));\n+                eliminated.push((self.input_indexes[idx], self.arg_indexes[idx]));\n                 self.satisfy_input(idx, idx);\n             }\n             i -= 1;\n         }\n         return eliminated;\n     }\n \n-    // Check for the above mismatch cases\n+    // Find some issue in the compatibility matrix\n     fn find_issue(&self) -> Option<Issue> {\n         let mat = &self.compatibility_matrix;\n         let ai = &self.arg_indexes;\n@@ -121,26 +132,26 @@ impl<'tcx> ArgMatrix<'tcx> {\n             if is_arg {\n                 for j in 0..ii.len() {\n                     // If we find at least one input this argument could satisfy\n-                    // this argument isn't completely useless\n-                    if matches!(mat[i][j], Compatibility::Compatible) {\n-                        useless = false;\n+                    // this argument isn't unsatisfiable\n+                    if matches!(mat[j][i], Compatibility::Compatible) {\n+                        unsatisfiable = false;\n                         break;\n                     }\n                 }\n             }\n             if is_input {\n                 for j in 0..ai.len() {\n                     // If we find at least one argument that could satisfy this input\n-                    // this argument isn't unsatisfiable\n-                    if matches!(mat[j][i], Compatibility::Compatible) {\n-                        unsatisfiable = false;\n+                    // this argument isn't useless\n+                    if matches!(mat[i][j], Compatibility::Compatible) {\n+                        useless = false;\n                         break;\n                     }\n                 }\n             }\n \n-            match (is_arg, is_input, useless, unsatisfiable) {\n-                // If an input is unsatisfied, and the argument in its position is useless\n+            match (is_input, is_arg, useless, unsatisfiable) {\n+                // If an argument is unsatisfied, and the input in its position is useless\n                 // then the most likely explanation is that we just got the types wrong\n                 (true, true, true, true) => return Some(Issue::Invalid(i)),\n                 // Otherwise, if an input is useless, then indicate that this is an extra argument\n@@ -167,7 +178,7 @@ impl<'tcx> ArgMatrix<'tcx> {\n                 _ => {\n                     continue;\n                 }\n-            };\n+            }\n         }\n \n         // We didn't find any of the individual issues above, but\n@@ -254,11 +265,11 @@ impl<'tcx> ArgMatrix<'tcx> {\n     // We'll want to know which arguments and inputs these rows and columns correspond to\n     // even after we delete them.\n     pub(crate) fn find_errors(mut self) -> (Vec<Error<'tcx>>, Vec<Option<usize>>) {\n-        let provided_arg_count = self.arg_indexes.len();\n+        let provided_arg_count = self.input_indexes.len();\n \n         let mut errors: Vec<Error<'tcx>> = vec![];\n         // For each expected argument, the matched *actual* input\n-        let mut matched_inputs: Vec<Option<usize>> = vec![None; self.input_indexes.len()];\n+        let mut matched_inputs: Vec<Option<usize>> = vec![None; self.arg_indexes.len()];\n \n         // Before we start looking for issues, eliminate any arguments that are already satisfied,\n         // so that an argument which is already spoken for by the input it's in doesn't\n@@ -269,28 +280,28 @@ impl<'tcx> ArgMatrix<'tcx> {\n         // Without this elimination, the first argument causes the second argument\n         // to show up as both a missing input and extra argument, rather than\n         // just an invalid type.\n-        for (arg, inp) in self.eliminate_satisfied() {\n-            matched_inputs[inp] = Some(arg);\n+        for (inp, arg) in self.eliminate_satisfied() {\n+            matched_inputs[arg] = Some(inp);\n         }\n \n         while self.input_indexes.len() > 0 || self.arg_indexes.len() > 0 {\n-            // Check for the first relevant issue\n             match self.find_issue() {\n                 Some(Issue::Invalid(idx)) => {\n                     let compatibility = self.compatibility_matrix[idx][idx].clone();\n                     let input_idx = self.input_indexes[idx];\n+                    let arg_idx = self.arg_indexes[idx];\n                     self.satisfy_input(idx, idx);\n-                    errors.push(Error::Invalid(input_idx, compatibility));\n+                    errors.push(Error::Invalid(input_idx, arg_idx, compatibility));\n                 }\n                 Some(Issue::Extra(idx)) => {\n-                    let arg_idx = self.arg_indexes[idx];\n-                    self.eliminate_arg(idx);\n-                    errors.push(Error::Extra(arg_idx));\n-                }\n-                Some(Issue::Missing(idx)) => {\n                     let input_idx = self.input_indexes[idx];\n                     self.eliminate_input(idx);\n-                    errors.push(Error::Missing(input_idx));\n+                    errors.push(Error::Extra(input_idx));\n+                }\n+                Some(Issue::Missing(idx)) => {\n+                    let arg_idx = self.arg_indexes[idx];\n+                    self.eliminate_arg(idx);\n+                    errors.push(Error::Missing(arg_idx));\n                 }\n                 Some(Issue::Swap(idx, other)) => {\n                     let input_idx = self.input_indexes[idx];\n@@ -302,24 +313,21 @@ impl<'tcx> ArgMatrix<'tcx> {\n                     // Subtract 1 because we already removed the \"min\" row\n                     self.satisfy_input(max - 1, min);\n                     errors.push(Error::Swap(input_idx, other_input_idx, arg_idx, other_arg_idx));\n-                    matched_inputs[input_idx] = Some(other_arg_idx);\n-                    matched_inputs[other_input_idx] = Some(arg_idx);\n+                    matched_inputs[other_arg_idx] = Some(input_idx);\n+                    matched_inputs[arg_idx] = Some(other_input_idx);\n                 }\n                 Some(Issue::Permutation(args)) => {\n-                    // FIXME: If satisfy_input ever did anything non-trivial (emit obligations to help type checking, for example)\n-                    // we'd want to call this function with the correct arg/input pairs, but for now, we just throw them in a bucket.\n-                    // This works because they force a cycle, so each row is guaranteed to also be a column\n                     let mut idxs: Vec<usize> = args.iter().filter_map(|&a| a).collect();\n \n                     let mut real_idxs = vec![None; provided_arg_count];\n                     for (src, dst) in\n                         args.iter().enumerate().filter_map(|(src, dst)| dst.map(|dst| (src, dst)))\n                     {\n-                        let src_arg = self.arg_indexes[src];\n-                        let dst_arg = self.arg_indexes[dst];\n-                        let dest_input = self.input_indexes[dst];\n-                        real_idxs[src_arg] = Some((dst_arg, dest_input));\n-                        matched_inputs[dest_input] = Some(src_arg);\n+                        let src_input_idx = self.input_indexes[src];\n+                        let dst_input_idx = self.input_indexes[dst];\n+                        let dest_arg_idx = self.arg_indexes[dst];\n+                        real_idxs[src_input_idx] = Some((dest_arg_idx, dst_input_idx));\n+                        matched_inputs[dest_arg_idx] = Some(src_input_idx);\n                     }\n                     idxs.sort();\n                     idxs.reverse();\n@@ -331,8 +339,8 @@ impl<'tcx> ArgMatrix<'tcx> {\n                 None => {\n                     // We didn't find any issues, so we need to push the algorithm forward\n                     // First, eliminate any arguments that currently satisfy their inputs\n-                    for (arg, inp) in self.eliminate_satisfied() {\n-                        matched_inputs[inp] = Some(arg);\n+                    for (inp, arg) in self.eliminate_satisfied() {\n+                        matched_inputs[arg] = Some(inp);\n                     }\n                 }\n             };"}, {"sha": "847c2c32dba293f6487091932015837559d34954", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -274,9 +274,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // A \"softer\" version of the helper above, which checks types without persisting them,\n         // and treats error types differently\n         // This will allow us to \"probe\" for other argument orders that would likely have been correct\n-        let check_compatible = |arg_idx, input_idx| {\n-            let formal_input_ty: Ty<'tcx> = formal_input_tys[input_idx];\n-            let expected_input_ty: Ty<'tcx> = expected_input_tys[input_idx];\n+        let check_compatible = |input_idx, arg_idx| {\n+            let formal_input_ty: Ty<'tcx> = formal_input_tys[arg_idx];\n+            let expected_input_ty: Ty<'tcx> = expected_input_tys[arg_idx];\n \n             // If either is an error type, we defy the usual convention and consider them to *not* be\n             // coercible.  This prevents our error message heuristic from trying to pass errors into\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Compatibility::Incompatible(None);\n             }\n \n-            let provided_arg: &hir::Expr<'tcx> = &provided_args[arg_idx];\n+            let provided_arg: &hir::Expr<'tcx> = &provided_args[input_idx];\n             let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n             // FIXME: check that this is safe; I don't believe this commits any of the obligations, but I can't be sure.\n             //\n@@ -429,11 +429,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let found_errors = !errors.is_empty();\n \n             errors.drain_filter(|error| {\n-                let Error::Invalid(input_idx, Compatibility::Incompatible(error)) = error else { return false };\n-                let expected_ty = expected_input_tys[*input_idx];\n-                let Some(Some((provided_ty, _))) = final_arg_types.get(*input_idx) else { return false };\n+                let Error::Invalid(input_idx, arg_idx, Compatibility::Incompatible(error)) = error else { return false };\n+                let expected_ty = expected_input_tys[*arg_idx];\n+                let provided_ty = final_arg_types[*input_idx].map(|ty| ty.0).unwrap();\n                 let cause = &self.misc(provided_args[*input_idx].span);\n-                let trace = TypeTrace::types(cause, true, expected_ty, *provided_ty);\n+                let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n                 if let Some(e) = error {\n                     if !matches!(trace.cause.as_failure_code(e), FailureCode::Error0308(_)) {\n                         self.report_and_explain_type_error(trace, e).emit();\n@@ -562,11 +562,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Next special case: if there is only one \"Incompatible\" error, just emit that\n             if errors.len() == 1 {\n-                if let Some(Error::Invalid(input_idx, Compatibility::Incompatible(Some(error)))) =\n-                    errors.iter().next()\n+                if let Some(Error::Invalid(\n+                    input_idx,\n+                    arg_idx,\n+                    Compatibility::Incompatible(Some(error)),\n+                )) = errors.iter().next()\n                 {\n-                    let expected_ty = expected_input_tys[*input_idx];\n-                    let provided_ty = final_arg_types[*input_idx].map(|ty| ty.0).unwrap();\n+                    let expected_ty = expected_input_tys[*arg_idx];\n+                    let provided_ty = final_arg_types[*arg_idx].map(|ty| ty.0).unwrap();\n                     let expected_ty = self.resolve_vars_if_possible(expected_ty);\n                     let provided_ty = self.resolve_vars_if_possible(provided_ty);\n                     let cause = &self.misc(provided_args[*input_idx].span);\n@@ -631,19 +634,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut errors = errors.into_iter().peekable();\n             while let Some(error) = errors.next() {\n                 match error {\n-                    Error::Invalid(input_idx, compatibility) => {\n-                        let expected_ty = expected_input_tys[input_idx];\n-                        let provided_ty = final_arg_types\n-                            .get(input_idx)\n-                            .and_then(|x| x.as_ref())\n-                            .map(|ty| ty.0)\n-                            .unwrap_or(tcx.ty_error());\n+                    Error::Invalid(input_idx, arg_idx, compatibility) => {\n+                        let expected_ty = expected_input_tys[arg_idx];\n+                        let provided_ty = final_arg_types[input_idx].map(|ty| ty.0).unwrap();\n                         let expected_ty = self.resolve_vars_if_possible(expected_ty);\n                         let provided_ty = self.resolve_vars_if_possible(provided_ty);\n                         if let Compatibility::Incompatible(error) = &compatibility {\n-                            let cause = &self.misc(\n-                                provided_args.get(input_idx).map(|i| i.span).unwrap_or(call_span),\n-                            );\n+                            let cause = &self.misc(provided_args[input_idx].span);\n                             let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n                             if let Some(e) = error {\n                                 self.note_type_err(\n@@ -658,16 +655,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n \n-                        if let Some(expr) = provided_args.get(input_idx) {\n-                            self.emit_coerce_suggestions(\n-                                &mut err,\n-                                &expr,\n-                                final_arg_types[input_idx].map(|ty| ty.0).unwrap(),\n-                                final_arg_types[input_idx].map(|ty| ty.1).unwrap(),\n-                                None,\n-                                None,\n-                            );\n-                        }\n+                        self.emit_coerce_suggestions(\n+                            &mut err,\n+                            &provided_args[input_idx],\n+                            final_arg_types[input_idx].map(|ty| ty.0).unwrap(),\n+                            final_arg_types[input_idx].map(|ty| ty.1).unwrap(),\n+                            None,\n+                            None,\n+                        );\n                     }\n                     Error::Extra(arg_idx) => {\n                         let arg_type = if let Some((_, ty)) = final_arg_types[arg_idx] {\n@@ -843,12 +838,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     Error::Swap(input_idx, other_input_idx, arg_idx, other_arg_idx) => {\n-                        let first_span = provided_args[arg_idx].span;\n-                        let second_span = provided_args[other_arg_idx].span;\n+                        let first_span = provided_args[input_idx].span;\n+                        let second_span = provided_args[other_input_idx].span;\n \n                         let first_expected_ty =\n-                            self.resolve_vars_if_possible(expected_input_tys[input_idx]);\n-                        let first_provided_ty = if let Some((ty, _)) = final_arg_types[arg_idx] {\n+                            self.resolve_vars_if_possible(expected_input_tys[arg_idx]);\n+                        let first_provided_ty = if let Some((ty, _)) = final_arg_types[input_idx] {\n                             format!(\",found `{}`\", ty)\n                         } else {\n                             \"\".into()\n@@ -858,9 +853,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             format!(\"expected `{}`{}\", first_expected_ty, first_provided_ty),\n                         ));\n                         let other_expected_ty =\n-                            self.resolve_vars_if_possible(expected_input_tys[other_input_idx]);\n+                            self.resolve_vars_if_possible(expected_input_tys[other_arg_idx]);\n                         let other_provided_ty =\n-                            if let Some((ty, _)) = final_arg_types[other_arg_idx] {\n+                            if let Some((ty, _)) = final_arg_types[other_input_idx] {\n                                 format!(\",found `{}`\", ty)\n                             } else {\n                                 \"\".into()\n@@ -926,14 +921,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     \"{}(\",\n                     source_map.span_to_snippet(full_call_span).unwrap_or_else(|_| String::new())\n                 );\n-                for (idx, arg) in matched_inputs.iter().enumerate() {\n-                    let suggestion_text = if let Some(arg) = arg {\n-                        let arg_span = provided_args[*arg].span.source_callsite();\n+                for (arg_index, input_idx) in matched_inputs.iter().enumerate() {\n+                    let suggestion_text = if let Some(input_idx) = input_idx {\n+                        let arg_span = provided_args[*input_idx].span.source_callsite();\n                         let arg_text = source_map.span_to_snippet(arg_span).unwrap();\n                         arg_text\n                     } else {\n                         // Propose a placeholder of the correct type\n-                        let expected_ty = expected_input_tys[idx];\n+                        let expected_ty = expected_input_tys[arg_index];\n                         let input_ty = self.resolve_vars_if_possible(expected_ty);\n                         if input_ty.is_unit() {\n                             \"()\".to_string()\n@@ -942,7 +937,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     suggestion += &suggestion_text;\n-                    if idx < minimum_input_count - 1 {\n+                    if arg_index < minimum_input_count - 1 {\n                         suggestion += \", \";\n                     }\n                 }"}, {"sha": "9946db67db918d66ca2a90d0f7af229b5865ac70", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -9,7 +9,7 @@ use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n use crate::slice::{self, SliceIndex};\n \n-/// `*mut T` but non-zero and covariant.\n+/// `*mut T` but non-zero and [covariant].\n ///\n /// This is often the correct thing to use when building data structures using\n /// raw pointers, but is ultimately more dangerous to use because of its additional\n@@ -42,6 +42,7 @@ use crate::slice::{self, SliceIndex};\n /// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n /// is never used for mutation.\n ///\n+/// [covariant]: https://doc.rust-lang.org/reference/subtyping.html\n /// [`PhantomData`]: crate::marker::PhantomData\n /// [`UnsafeCell<T>`]: crate::cell::UnsafeCell\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]"}, {"sha": "02011325d687881c02174adbd61ac1148d95fe80", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -550,6 +550,21 @@ Supported values for this option are:\n - `symbols` - same as `debuginfo`, but the rest of the symbol table section is\n   stripped as well if the linker supports it.\n \n+## symbol-mangling-version\n+\n+This option controls the [name mangling] format for encoding Rust item names\n+for the purpose of generating object code and linking.\n+\n+Supported values for this option are:\n+\n+* `v0` \u2014 The \"v0\" mangling scheme. The specific format is not specified at\n+  this time.\n+\n+The default if not specified will use a compiler-chosen default which may\n+change in the future.\n+\n+[name mangling]: https://en.wikipedia.org/wiki/Name_mangling\n+\n ## target-cpu\n \n This instructs `rustc` to generate code specifically for a particular processor."}, {"sha": "0d02fa7bd6b3e996422d3b6fa9ac652f302365af", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -408,6 +408,9 @@ to customize the output:\n   argument](#option-emit), and as soon as the artifact is available on the\n   filesystem a notification will be emitted.\n \n+- `future-incompat` - includes a JSON message that contains a report if the\n+  crate contains any code that may fail to compile in the future.\n+\n Note that it is invalid to combine the `--json` argument with the\n [`--color`](#option-color) argument, and it is required to combine `--json`\n with `--error-format=json`."}, {"sha": "efbf861eaa68c1ede60a0c71d27e7e87454cc020", "filename": "src/doc/rustc/src/json.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -229,6 +229,32 @@ flag][option-emit] documentation.\n }\n ```\n \n+## Future-incompatible reports\n+\n+If the [`--json=future-incompat`][option-json] flag is used, then a separate\n+JSON structure will be emitted if the crate may stop compiling in the future.\n+This contains diagnostic information about the particular warnings that may be\n+turned into a hard error in the future. This will include the diagnostic\n+information, even if the diagnostics have been suppressed (such as with an\n+`#[allow]` attribute or the `--cap-lints` option).\n+\n+```javascript\n+{\n+    /* An array of objects describing a warning that will become a hard error\n+       in the future.\n+    */\n+    \"future_incompat_report\":\n+    [\n+        {\n+            /* A diagnostic structure as defined in\n+               https://doc.rust-lang.org/rustc/json.html#diagnostics\n+            */\n+            \"diagnostic\": {...},\n+        }\n+    ]\n+}\n+```\n+\n [option-emit]: command-line-arguments.md#option-emit\n [option-error-format]: command-line-arguments.md#option-error-format\n [option-json]: command-line-arguments.md#option-json"}, {"sha": "f129f073e98ded94b27ff273a5c1b15721f6a1a7", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -19,7 +19,7 @@ pub enum Enum4 {\n     A(i32),\n     B(i32),\n }\n-// CHECK: %\"Enum4::A\" = type { [1 x i32], i32 }\n+// No Aggregate type, and hence nothing in LLVM IR.\n \n pub enum Enum64 {\n     A(Align64),"}, {"sha": "7dbcc151855016fa5ab0545924ccb3693ee6385d", "filename": "src/test/ui/layout/debug.stderr", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -184,9 +184,22 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I32,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I32,\n+                                   true,\n+                               ),\n+                               valid_range: 0..=4294967295,\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(4 bytes),\n@@ -206,9 +219,22 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I32,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I32,\n+                                   true,\n+                               ),\n+                               valid_range: 0..=4294967295,\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(4 bytes),"}, {"sha": "33dfa307c1d271a9ac819e53ebf5cd2967f60a4c", "filename": "src/test/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.stderr", "status": "modified", "additions": 77, "deletions": 15, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -30,9 +30,21 @@ error: layout_of(MissingPayloadField) = Layout {\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Union {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n@@ -131,9 +143,22 @@ error: layout_of(CommonPayloadField) = Layout {\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=255,\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n@@ -153,9 +178,22 @@ error: layout_of(CommonPayloadField) = Layout {\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=255,\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n@@ -237,9 +275,21 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Union {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n@@ -259,9 +309,21 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Union {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),"}, {"sha": "d45fa10f022aa56542563c15e47535c56f4cc28b", "filename": "src/test/ui/rust-2018/auxiliary/edition-lint-infer-outlives-macro.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Fedition-lint-infer-outlives-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Fedition-lint-infer-outlives-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Fedition-lint-infer-outlives-macro.rs?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -0,0 +1,6 @@\n+pub fn foo() {}\n+\n+#[macro_export]\n+macro_rules! gimme_a {\n+    ($($mac:tt)*) => { $($mac)* { 'a } }\n+}"}, {"sha": "d7a832831c1d91cc916021ab172decb757d38420", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -0,0 +1,28 @@\n+// edition:2018\n+// aux-build:edition-lint-infer-outlives-macro.rs\n+\n+// Test that the lint does not fire if the where predicate\n+// is from the local crate, but all the bounds are from an\n+// external macro.\n+\n+#![deny(explicit_outlives_requirements)]\n+\n+#[macro_use]\n+extern crate edition_lint_infer_outlives_macro;\n+\n+macro_rules! make_foo {\n+    ($a:tt) => {\n+        struct Foo<$a, 'b> where 'b: $a {\n+            foo: &$a &'b (),\n+        }\n+    }\n+}\n+\n+gimme_a! {make_foo!}\n+\n+struct Bar<'a, 'b: 'a> {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+fn main() {}"}, {"sha": "553b1cd976ad6a114a10ce5dcc15770650ee10b3", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d53f1e8fbf891cf84fcb11eb078a27e528df795a/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr?ref=d53f1e8fbf891cf84fcb11eb078a27e528df795a", "patch": "@@ -0,0 +1,14 @@\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:23:18\n+   |\n+LL | struct Bar<'a, 'b: 'a> {\n+   |                  ^^^^ help: remove this bound\n+   |\n+note: the lint level is defined here\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:8:9\n+   |\n+LL | #![deny(explicit_outlives_requirements)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}