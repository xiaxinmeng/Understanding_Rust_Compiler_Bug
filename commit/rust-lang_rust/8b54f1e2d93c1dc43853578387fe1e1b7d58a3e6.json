{"sha": "8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNTRmMWUyZDkzYzFkYzQzODUzNTc4Mzg3ZmUxZTFiN2Q1OGEzZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-08T21:34:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-08T21:34:55Z"}, "message": "Auto merge of #6016 - giraffate:restrict_same_item_push, r=ebroto\n\nRestrict `same_item_push` to suppress false positives\n\nIt only emits a lint when the pushed item is a literal, a constant and an immutable binding that are initialized with those, as discussed in https://github.com/rust-lang/rust-clippy/pull/5997#pullrequestreview-483005186.\n\nFix https://github.com/rust-lang/rust-clippy/issues/5985\n\nchangelog: Restrict `same_item_push` to literals, constants and immutable bindings that are initialized with those.\n\nr? `@ebroto`", "tree": {"sha": "3edc476a26a5c3c4240893d4643dd82f329a2dbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3edc476a26a5c3c4240893d4643dd82f329a2dbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6", "html_url": "https://github.com/rust-lang/rust/commit/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d6cf3a824852e59b98e2038bc574fce01108cf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6cf3a824852e59b98e2038bc574fce01108cf4", "html_url": "https://github.com/rust-lang/rust/commit/8d6cf3a824852e59b98e2038bc574fce01108cf4"}, {"sha": "1d8ae3aa12567b8461436ac10ba9fc4da55adb29", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d8ae3aa12567b8461436ac10ba9fc4da55adb29", "html_url": "https://github.com/rust-lang/rust/commit/1d8ae3aa12567b8461436ac10ba9fc4da55adb29"}], "stats": {"total": 236, "additions": 150, "deletions": 86}, "files": [{"sha": "6c54c07869ad1a6a2b7f1814fef1ed6ee20718d6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6", "patch": "@@ -1131,6 +1131,27 @@ fn detect_same_item_push<'tcx>(\n     body: &'tcx Expr<'_>,\n     _: &'tcx Expr<'_>,\n ) {\n+    fn emit_lint(cx: &LateContext<'_>, vec: &Expr<'_>, pushed_item: &Expr<'_>) {\n+        let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n+        let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n+\n+        span_lint_and_help(\n+            cx,\n+            SAME_ITEM_PUSH,\n+            vec.span,\n+            \"it looks like the same item is being pushed into this Vec\",\n+            None,\n+            &format!(\n+                \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                item_str, vec_str, item_str\n+            ),\n+        )\n+    }\n+\n+    if !matches!(pat.kind, PatKind::Wild) {\n+        return;\n+    }\n+\n     // Determine whether it is safe to lint the body\n     let mut same_item_push_visitor = SameItemPushVisitor {\n         should_lint: true,\n@@ -1149,43 +1170,41 @@ fn detect_same_item_push<'tcx>(\n                 .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n             {\n                 // Make sure that the push does not involve possibly mutating values\n-                if let PatKind::Wild = pat.kind {\n-                    let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n-                    let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n-                    if let ExprKind::Path(ref qpath) = pushed_item.kind {\n-                        if_chain! {\n-                            if let Res::Local(hir_id) = qpath_res(cx, qpath, pushed_item.hir_id);\n-                            let node = cx.tcx.hir().get(hir_id);\n-                            if let Node::Binding(pat) = node;\n-                            if let PatKind::Binding(bind_ann, ..) = pat.kind;\n-                            if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n-                            then {\n-                                span_lint_and_help(\n-                                    cx,\n-                                    SAME_ITEM_PUSH,\n-                                    vec.span,\n-                                    \"it looks like the same item is being pushed into this Vec\",\n-                                    None,\n-                                    &format!(\n-                                        \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n-                                        item_str, vec_str, item_str\n-                                    ),\n-                                )\n-                            }\n+                match pushed_item.kind {\n+                    ExprKind::Path(ref qpath) => {\n+                        match qpath_res(cx, qpath, pushed_item.hir_id) {\n+                            // immutable bindings that are initialized with literal or constant\n+                            Res::Local(hir_id) => {\n+                                if_chain! {\n+                                    let node = cx.tcx.hir().get(hir_id);\n+                                    if let Node::Binding(pat) = node;\n+                                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                                    if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                    let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n+                                    if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n+                                    if let Some(init) = parent_let_expr.init;\n+                                    then {\n+                                        match init.kind {\n+                                            // immutable bindings that are initialized with literal\n+                                            ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                                            // immutable bindings that are initialized with constant\n+                                            ExprKind::Path(ref path) => {\n+                                                if let Res::Def(DefKind::Const, ..) = qpath_res(cx, path, init.hir_id) {\n+                                                    emit_lint(cx, vec, pushed_item);\n+                                                }\n+                                            }\n+                                            _ => {},\n+                                        }\n+                                    }\n+                                }\n+                            },\n+                            // constant\n+                            Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n+                            _ => {},\n                         }\n-                    } else if mutated_variables(pushed_item, cx).map_or(false, |mutvars| mutvars.is_empty()) {\n-                        span_lint_and_help(\n-                            cx,\n-                            SAME_ITEM_PUSH,\n-                            vec.span,\n-                            \"it looks like the same item is being pushed into this Vec\",\n-                            None,\n-                            &format!(\n-                                \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n-                                item_str, vec_str, item_str\n-                            ),\n-                        )\n-                    }\n+                    },\n+                    ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                    _ => {},\n                 }\n             }\n         }"}, {"sha": "a37c8782ec3300c58f887df041a048abf143159f", "filename": "tests/ui/same_item_push.rs", "status": "modified", "additions": 70, "deletions": 33, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6/tests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6/tests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.rs?ref=8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6", "patch": "@@ -1,5 +1,7 @@\n #![warn(clippy::same_item_push)]\n \n+const VALUE: u8 = 7;\n+\n fn mutate_increment(x: &mut u8) -> u8 {\n     *x += 1;\n     *x\n@@ -9,65 +11,81 @@ fn increment(x: u8) -> u8 {\n     x + 1\n }\n \n-fn main() {\n-    // Test for basic case\n-    let mut spaces = Vec::with_capacity(10);\n-    for _ in 0..10 {\n-        spaces.push(vec![b' ']);\n-    }\n+fn fun() -> usize {\n+    42\n+}\n \n-    let mut vec2: Vec<u8> = Vec::new();\n+fn main() {\n+    // ** linted cases **\n+    let mut vec: Vec<u8> = Vec::new();\n     let item = 2;\n     for _ in 5..=20 {\n-        vec2.push(item);\n+        vec.push(item);\n     }\n \n-    let mut vec3: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     for _ in 0..15 {\n         let item = 2;\n-        vec3.push(item);\n+        vec.push(item);\n     }\n \n-    let mut vec4: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     for _ in 0..15 {\n-        vec4.push(13);\n+        vec.push(13);\n+    }\n+\n+    let mut vec = Vec::new();\n+    for _ in 0..20 {\n+        vec.push(VALUE);\n+    }\n+\n+    let mut vec = Vec::new();\n+    let item = VALUE;\n+    for _ in 0..20 {\n+        vec.push(item);\n+    }\n+\n+    // ** non-linted cases **\n+    let mut spaces = Vec::with_capacity(10);\n+    for _ in 0..10 {\n+        spaces.push(vec![b' ']);\n     }\n \n     // Suggestion should not be given as pushed variable can mutate\n-    let mut vec5: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     let mut item: u8 = 2;\n     for _ in 0..30 {\n-        vec5.push(mutate_increment(&mut item));\n+        vec.push(mutate_increment(&mut item));\n     }\n \n-    let mut vec6: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     let mut item: u8 = 2;\n     let mut item2 = &mut mutate_increment(&mut item);\n     for _ in 0..30 {\n-        vec6.push(mutate_increment(item2));\n+        vec.push(mutate_increment(item2));\n     }\n \n-    let mut vec7: Vec<usize> = Vec::new();\n+    let mut vec: Vec<usize> = Vec::new();\n     for (a, b) in [0, 1, 4, 9, 16].iter().enumerate() {\n-        vec7.push(a);\n+        vec.push(a);\n     }\n \n-    let mut vec8: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     for i in 0..30 {\n-        vec8.push(increment(i));\n+        vec.push(increment(i));\n     }\n \n-    let mut vec9: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     for i in 0..30 {\n-        vec9.push(i + i * i);\n+        vec.push(i + i * i);\n     }\n \n     // Suggestion should not be given as there are multiple pushes that are not the same\n-    let mut vec10: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     let item: u8 = 2;\n     for _ in 0..30 {\n-        vec10.push(item);\n-        vec10.push(item * 2);\n+        vec.push(item);\n+        vec.push(item * 2);\n     }\n \n     // Suggestion should not be given as Vec is not involved\n@@ -82,23 +100,23 @@ fn main() {\n     for i in 0..30 {\n         vec_a.push(A { kind: i });\n     }\n-    let mut vec12: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     for a in vec_a {\n-        vec12.push(2u8.pow(a.kind));\n+        vec.push(2u8.pow(a.kind));\n     }\n \n     // Fix #5902\n-    let mut vec13: Vec<u8> = Vec::new();\n+    let mut vec: Vec<u8> = Vec::new();\n     let mut item = 0;\n     for _ in 0..10 {\n-        vec13.push(item);\n+        vec.push(item);\n         item += 10;\n     }\n \n     // Fix #5979\n-    let mut vec14: Vec<std::fs::File> = Vec::new();\n+    let mut vec: Vec<std::fs::File> = Vec::new();\n     for _ in 0..10 {\n-        vec14.push(std::fs::File::open(\"foobar\").unwrap());\n+        vec.push(std::fs::File::open(\"foobar\").unwrap());\n     }\n     // Fix #5979\n     #[derive(Clone)]\n@@ -107,8 +125,27 @@ fn main() {\n     trait T {}\n     impl T for S {}\n \n-    let mut vec15: Vec<Box<dyn T>> = Vec::new();\n+    let mut vec: Vec<Box<dyn T>> = Vec::new();\n     for _ in 0..10 {\n-        vec15.push(Box::new(S {}));\n+        vec.push(Box::new(S {}));\n+    }\n+\n+    // Fix #5985\n+    let mut vec = Vec::new();\n+    let item = 42;\n+    let item = fun();\n+    for _ in 0..20 {\n+        vec.push(item);\n+    }\n+\n+    // Fix #5985\n+    let mut vec = Vec::new();\n+    let key = 1;\n+    for _ in 0..20 {\n+        let item = match key {\n+            1 => 10,\n+            _ => 0,\n+        };\n+        vec.push(item);\n     }\n }"}, {"sha": "d9ffa15780ad004b17609a48ef8e241af1992c7e", "filename": "tests/ui/same_item_push.stderr", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6/tests%2Fui%2Fsame_item_push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6/tests%2Fui%2Fsame_item_push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.stderr?ref=8b54f1e2d93c1dc43853578387fe1e1b7d58a3e6", "patch": "@@ -1,35 +1,43 @@\n error: it looks like the same item is being pushed into this Vec\n-  --> $DIR/same_item_push.rs:16:9\n+  --> $DIR/same_item_push.rs:23:9\n    |\n-LL |         spaces.push(vec![b' ']);\n-   |         ^^^^^^\n+LL |         vec.push(item);\n+   |         ^^^\n    |\n    = note: `-D clippy::same-item-push` implied by `-D warnings`\n-   = help: try using vec![vec![b' '];SIZE] or spaces.resize(NEW_SIZE, vec![b' '])\n+   = help: try using vec![item;SIZE] or vec.resize(NEW_SIZE, item)\n \n error: it looks like the same item is being pushed into this Vec\n-  --> $DIR/same_item_push.rs:22:9\n+  --> $DIR/same_item_push.rs:29:9\n    |\n-LL |         vec2.push(item);\n-   |         ^^^^\n+LL |         vec.push(item);\n+   |         ^^^\n    |\n-   = help: try using vec![item;SIZE] or vec2.resize(NEW_SIZE, item)\n+   = help: try using vec![item;SIZE] or vec.resize(NEW_SIZE, item)\n \n error: it looks like the same item is being pushed into this Vec\n-  --> $DIR/same_item_push.rs:28:9\n+  --> $DIR/same_item_push.rs:34:9\n    |\n-LL |         vec3.push(item);\n-   |         ^^^^\n+LL |         vec.push(13);\n+   |         ^^^\n    |\n-   = help: try using vec![item;SIZE] or vec3.resize(NEW_SIZE, item)\n+   = help: try using vec![13;SIZE] or vec.resize(NEW_SIZE, 13)\n \n error: it looks like the same item is being pushed into this Vec\n-  --> $DIR/same_item_push.rs:33:9\n+  --> $DIR/same_item_push.rs:39:9\n    |\n-LL |         vec4.push(13);\n-   |         ^^^^\n+LL |         vec.push(VALUE);\n+   |         ^^^\n    |\n-   = help: try using vec![13;SIZE] or vec4.resize(NEW_SIZE, 13)\n+   = help: try using vec![VALUE;SIZE] or vec.resize(NEW_SIZE, VALUE)\n \n-error: aborting due to 4 previous errors\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:45:9\n+   |\n+LL |         vec.push(item);\n+   |         ^^^\n+   |\n+   = help: try using vec![item;SIZE] or vec.resize(NEW_SIZE, item)\n+\n+error: aborting due to 5 previous errors\n "}]}