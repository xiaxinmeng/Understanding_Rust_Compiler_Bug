{"sha": "ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYTg3ZmFlNWYyZmUxYjJiYzZlOTVhZDdhNmE3MzA5MjFjMjIxNjE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-12-11T01:38:13Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-12-11T01:38:13Z"}, "message": "Rename (Ns)ImportResolution", "tree": {"sha": "8019fe1e0a2f4e546c91c17896a6b44e13f88f07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8019fe1e0a2f4e546c91c17896a6b44e13f88f07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "html_url": "https://github.com/rust-lang/rust/commit/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "url": "https://api.github.com/repos/rust-lang/rust/commits/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "html_url": "https://github.com/rust-lang/rust/commit/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380"}], "stats": {"total": 85, "additions": 42, "deletions": 43}, "files": [{"sha": "0deef91a0f6b08e9692190ef3f0023c115d05d64", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "patch": "@@ -16,7 +16,7 @@\n use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n-use resolve_imports::{ImportResolution, NsImportResolution};\n+use resolve_imports::{ImportResolution, ImportResolutionPerNamespace};\n use Module;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n@@ -822,23 +822,23 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 let mut import_resolutions = module_.import_resolutions.borrow_mut();\n                 match import_resolutions.get_mut(&target) {\n-                    Some(resolution) => {\n+                    Some(resolution_per_ns) => {\n                         debug!(\"(building import directive) bumping reference\");\n-                        resolution.outstanding_references += 1;\n+                        resolution_per_ns.outstanding_references += 1;\n \n                         // the source of this name is different now\n-                        let ns_resolution =\n-                            NsImportResolution { id: id, is_public: is_public, target: None };\n-                        resolution[TypeNS] = ns_resolution.clone();\n-                        resolution[ValueNS] = ns_resolution;\n+                        let resolution =\n+                            ImportResolution { id: id, is_public: is_public, target: None };\n+                        resolution_per_ns[TypeNS] = resolution.clone();\n+                        resolution_per_ns[ValueNS] = resolution;\n                         return;\n                     }\n                     None => {}\n                 }\n                 debug!(\"(building import directive) creating new\");\n-                let mut resolution = ImportResolution::new(id, is_public);\n-                resolution.outstanding_references = 1;\n-                import_resolutions.insert(target, resolution);\n+                let mut import_resolution_per_ns = ImportResolutionPerNamespace::new(id, is_public);\n+                import_resolution_per_ns.outstanding_references = 1;\n+                import_resolutions.insert(target, import_resolution_per_ns);\n             }\n             GlobImport => {\n                 // Set the glob flag. This tells us that we don't know the"}, {"sha": "c32acb7bb269f36f51c3c0aec8c4fec6dd0df251", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "patch": "@@ -96,7 +96,7 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::usize;\n \n-use resolve_imports::{Target, ImportDirective, ImportResolution};\n+use resolve_imports::{Target, ImportDirective, ImportResolutionPerNamespace};\n use resolve_imports::Shadowable;\n \n // NB: This module needs to be declared first so diagnostics are\n@@ -793,7 +793,7 @@ pub struct Module {\n     anonymous_children: RefCell<NodeMap<Rc<Module>>>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: RefCell<HashMap<Name, ImportResolution>>,\n+    import_resolutions: RefCell<HashMap<Name, ImportResolutionPerNamespace>>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n@@ -912,7 +912,7 @@ bitflags! {\n // Records a possibly-private value, type, or module definition.\n #[derive(Debug)]\n struct NsDef {\n-    modifiers: DefModifiers, // see note in ImportResolution about how to use this\n+    modifiers: DefModifiers, // see note in ImportResolutionPerNamespace about how to use this\n     def_or_module: DefOrModule,\n     span: Option<Span>,\n }"}, {"sha": "fd471893acd53c5517328ae67e73597b8457d293", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "patch": "@@ -58,7 +58,7 @@ pub struct ImportDirective {\n     pub subclass: ImportDirectiveSubclass,\n     pub span: Span,\n     pub id: NodeId,\n-    pub is_public: bool, // see note in ImportResolution about how to use this\n+    pub is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n     pub shadowable: Shadowable,\n }\n \n@@ -103,25 +103,25 @@ impl Target {\n }\n \n #[derive(Debug)]\n-/// An ImportResolution records what we know about an imported name.\n+/// An ImportResolutionPerNamespace records what we know about an imported name.\n /// More specifically, it records the number of unresolved `use` directives that import the name,\n /// and for each namespace, it records the `use` directive importing the name in the namespace\n /// and the `Target` to which the name in the namespace resolves (if applicable).\n /// Different `use` directives may import the same name in different namespaces.\n-pub struct ImportResolution {\n+pub struct ImportResolutionPerNamespace {\n     // When outstanding_references reaches zero, outside modules can count on the targets being\n     // correct. Before then, all bets are off; future `use` directives could override the name.\n     // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n     // is if the name is imported by exactly two `use` directives, one of which resolves to a\n     // value and the other of which resolves to a type.\n     pub outstanding_references: usize,\n-    pub type_ns: NsImportResolution,\n-    pub value_ns: NsImportResolution,\n+    pub type_ns: ImportResolution,\n+    pub value_ns: ImportResolution,\n }\n \n-/// Records what we know about an imported name in a namespace (see `ImportResolution`).\n+/// Records what we know about an imported name in a namespace (see `ImportResolutionPerNamespace`).\n #[derive(Clone,Debug)]\n-pub struct NsImportResolution {\n+pub struct ImportResolution {\n     /// Whether the name in the namespace was imported with a `use` or a `pub use`.\n     pub is_public: bool,\n \n@@ -132,23 +132,23 @@ pub struct NsImportResolution {\n     pub id: NodeId,\n }\n \n-impl ::std::ops::Index<Namespace> for ImportResolution {\n-    type Output = NsImportResolution;\n-    fn index(&self, ns: Namespace) -> &NsImportResolution {\n+impl ::std::ops::Index<Namespace> for ImportResolutionPerNamespace {\n+    type Output = ImportResolution;\n+    fn index(&self, ns: Namespace) -> &ImportResolution {\n         match ns { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n     }\n }\n \n-impl ::std::ops::IndexMut<Namespace> for ImportResolution {\n-    fn index_mut(&mut self, ns: Namespace) -> &mut NsImportResolution {\n+impl ::std::ops::IndexMut<Namespace> for ImportResolutionPerNamespace {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut ImportResolution {\n         match ns { TypeNS => &mut self.type_ns, ValueNS => &mut self.value_ns }\n     }\n }\n \n-impl ImportResolution {\n-    pub fn new(id: NodeId, is_public: bool) -> ImportResolution {\n-        let resolution = NsImportResolution { id: id, is_public: is_public, target: None };\n-        ImportResolution {\n+impl ImportResolutionPerNamespace {\n+    pub fn new(id: NodeId, is_public: bool) -> Self {\n+        let resolution = ImportResolution { id: id, is_public: is_public, target: None };\n+        ImportResolutionPerNamespace {\n             outstanding_references: 0, type_ns: resolution.clone(), value_ns: resolution,\n         }\n     }\n@@ -504,7 +504,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     Some(import_resolution) if import_resolution.outstanding_references == 0 => {\n \n                         fn get_binding(this: &mut Resolver,\n-                                       import_resolution: &ImportResolution,\n+                                       import_resolution: &ImportResolutionPerNamespace,\n                                        namespace: Namespace,\n                                        source: Name)\n                                        -> NamespaceResult {\n@@ -644,7 +644,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                              directive.span,\n                                                              target);\n \n-                        import_resolution[namespace] = NsImportResolution {\n+                        import_resolution[namespace] = ImportResolution {\n                             target: Some(Target::new(target_module.clone(),\n                                                      name_binding.clone(),\n                                                      directive.shadowable)),\n@@ -777,7 +777,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             // Here we merge two import resolutions.\n             let mut import_resolutions = module_.import_resolutions.borrow_mut();\n             let mut dest_import_resolution = import_resolutions.entry(*name).or_insert_with(|| {\n-                ImportResolution::new(id, is_public)\n+                ImportResolutionPerNamespace::new(id, is_public)\n             });\n \n             for &ns in [TypeNS, ValueNS].iter() {\n@@ -787,7 +787,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                           import_directive.span,\n                                                           *name,\n                                                           ns);\n-                        dest_import_resolution[ns] = NsImportResolution {\n+                        dest_import_resolution[ns] = ImportResolution {\n                             id: id, is_public: is_public, target: Some(target.clone())\n                         };\n                     }\n@@ -832,10 +832,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry(name)\n-                                                       .or_insert_with(|| {\n-                                                           ImportResolution::new(id, is_public)\n-                                                       });\n+        let dest_import_resolution = import_resolutions.entry(name).or_insert_with(|| {\n+            ImportResolutionPerNamespace::new(id, is_public)\n+        });\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` to `{}`\",\n                name,\n@@ -864,7 +863,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                   \"{}\",\n                                   msg);\n                     } else {\n-                        dest_import_resolution[namespace] = NsImportResolution {\n+                        dest_import_resolution[namespace] = ImportResolution {\n                             target: Some(Target::new(containing_module.clone(),\n                                                      name_bindings[namespace].clone(),\n                                                      import_directive.shadowable)),\n@@ -886,7 +885,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicting_import(&mut self,\n-                                    import_resolution: &ImportResolution,\n+                                    import_resolution: &ImportResolutionPerNamespace,\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n@@ -939,14 +938,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicts_between_imports_and_items(&mut self,\n                                                      module: &Module,\n-                                                     import_resolution: &ImportResolution,\n+                                                     import: &ImportResolutionPerNamespace,\n                                                      import_span: Span,\n                                                      name: Name) {\n         // First, check for conflicts between imports and `extern crate`s.\n         if module.external_module_children\n                  .borrow()\n                  .contains_key(&name) {\n-            match import_resolution.type_ns.target {\n+            match import.type_ns.target {\n                 Some(ref target) if target.shadowable != Shadowable::Always => {\n                     let msg = format!(\"import `{0}` conflicts with imported crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n@@ -967,7 +966,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref name_bindings) => (*name_bindings).clone(),\n         };\n \n-        match import_resolution.value_ns.target {\n+        match import.value_ns.target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref value) = *name_bindings.value_ns.borrow() {\n                     span_err!(self.resolver.session,\n@@ -983,7 +982,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(_) | None => {}\n         }\n \n-        match import_resolution.type_ns.target {\n+        match import.type_ns.target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_ns.borrow() {\n                     let (what, note) = match ty.module() {"}]}