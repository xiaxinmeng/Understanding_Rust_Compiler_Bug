{"sha": "c131063988ff8ac86bbf53a3bf998145c6b99d6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMzEwNjM5ODhmZjhhYzg2YmJmNTNhM2JmOTk4MTQ1YzZiOTlkNmY=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-13T00:08:42Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-13T00:22:25Z"}, "message": "Added a unit test for BcbCounters\n\nRestructured the code a little, to allow getting both the mir::Body and\ncoverage graph.", "tree": {"sha": "e11598307b152eb1e646e1750ec62bb8f990ce28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e11598307b152eb1e646e1750ec62bb8f990ce28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c131063988ff8ac86bbf53a3bf998145c6b99d6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c131063988ff8ac86bbf53a3bf998145c6b99d6f", "html_url": "https://github.com/rust-lang/rust/commit/c131063988ff8ac86bbf53a3bf998145c6b99d6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c131063988ff8ac86bbf53a3bf998145c6b99d6f/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb9f2bb3b0a3f7e712efa28743acf6134d49de5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb9f2bb3b0a3f7e712efa28743acf6134d49de5c", "html_url": "https://github.com/rust-lang/rust/commit/eb9f2bb3b0a3f7e712efa28743acf6134d49de5c"}], "stats": {"total": 290, "additions": 188, "deletions": 102}, "files": [{"sha": "20f6a16e0f75712190548ed9aa573a4310f4f673", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c131063988ff8ac86bbf53a3bf998145c6b99d6f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131063988ff8ac86bbf53a3bf998145c6b99d6f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=c131063988ff8ac86bbf53a3bf998145c6b99d6f", "patch": "@@ -120,7 +120,6 @@ struct BcbCounters<'a> {\n     basic_coverage_blocks: &'a mut CoverageGraph,\n }\n \n-// FIXME(richkadel): Add unit tests for `BcbCounters` functions/algorithms.\n impl<'a> BcbCounters<'a> {\n     fn new(\n         coverage_counters: &'a mut CoverageCounters,"}, {"sha": "95c49922262f628fb82f726cac1b4cf0b8b58201", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c131063988ff8ac86bbf53a3bf998145c6b99d6f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131063988ff8ac86bbf53a3bf998145c6b99d6f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=c131063988ff8ac86bbf53a3bf998145c6b99d6f", "patch": "@@ -645,7 +645,10 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n }\n \n-fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> Option<Span> {\n+pub(super) fn filtered_statement_span(\n+    statement: &'a Statement<'tcx>,\n+    body_span: Span,\n+) -> Option<Span> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -686,7 +689,10 @@ fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> O\n     }\n }\n \n-fn filtered_terminator_span(terminator: &'a Terminator<'tcx>, body_span: Span) -> Option<Span> {\n+pub(super) fn filtered_terminator_span(\n+    terminator: &'a Terminator<'tcx>,\n+    body_span: Span,\n+) -> Option<Span> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from"}, {"sha": "7de965be53bde0711e974daf02a06ea9aae983b8", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 180, "deletions": 99, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/c131063988ff8ac86bbf53a3bf998145c6b99d6f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131063988ff8ac86bbf53a3bf998145c6b99d6f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=c131063988ff8ac86bbf53a3bf998145c6b99d6f", "patch": "@@ -1,14 +1,39 @@\n+//! This crate hosts a selection of \"unit tests\" for components of the `InstrumentCoverage` MIR\n+//! pass.\n+//!\n+//! The tests construct a few \"mock\" objects, as needed, to support the `InstrumentCoverage`\n+//! functions and algorithms. Mocked objects include instances of `mir::Body`; including\n+//! `Terminator`s of various `kind`s, and `Span` objects. Some functions used by or used on\n+//! real, runtime versions of these mocked-up objects have constraints (such as cross-thread\n+//! limitations) and deep dependencies on other elements of the full Rust compiler (which is\n+//! *not* constructed or mocked for these tests).\n+//!\n+//! Of particular note, attempting to simply print elements of the `mir::Body` with default\n+//! `Debug` formatting can fail because some `Debug` format implementations require the\n+//! `TyCtxt`, obtained via a static global variable that is *not* set for these tests.\n+//! Initializing the global type context is prohibitively complex for the scope and scale of these\n+//! tests (essentially requiring initializing the entire compiler).\n+//!\n+//! Also note, some basic features of `Span` also rely on the `Span`s own \"session globals\", which\n+//! are unrelated to the `TyCtxt` global. Without initializing the `Span` session globals, some\n+//! basic, coverage-specific features would be impossible to test, but thankfully initializing these\n+//! globals is comparitively simpler. The easiest way is to wrap the test in a closure argument\n+//! to: `rustc_span::with_default_session_globals(|| { test_here(); })`.\n+\n+use super::counters;\n use super::debug;\n use super::graph;\n+use super::spans;\n \n use coverage_test_macros::let_bcb;\n \n use rustc_data_structures::graph::WithNumNodes;\n use rustc_data_structures::graph::WithSuccessors;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::mir::coverage::CoverageKind;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, DebruijnIndex, TyS, TypeFlags};\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{self, BytePos, Pos, Span, DUMMY_SP};\n \n fn dummy_ty() -> &'static TyS<'static> {\n     thread_local! {\n@@ -24,7 +49,6 @@ fn dummy_ty() -> &'static TyS<'static> {\n \n struct MockBlocks<'tcx> {\n     blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-    source_info: SourceInfo,\n     dummy_place: Place<'tcx>,\n     next_local: usize,\n }\n@@ -33,7 +57,6 @@ impl<'tcx> MockBlocks<'tcx> {\n     fn new() -> Self {\n         Self {\n             blocks: IndexVec::new(),\n-            source_info: SourceInfo::outermost(DUMMY_SP),\n             dummy_place: Place { local: RETURN_PLACE, projection: ty::List::empty() },\n             next_local: 0,\n         }\n@@ -45,12 +68,19 @@ impl<'tcx> MockBlocks<'tcx> {\n         Local::new(index)\n     }\n \n-    fn push(&mut self, num_nops: usize, kind: TerminatorKind<'tcx>) -> BasicBlock {\n-        let nop = Statement { source_info: self.source_info, kind: StatementKind::Nop };\n-\n+    fn push(&mut self, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+        let next_lo = if let Some(last) = self.blocks.last() {\n+            self.blocks[last].terminator().source_info.span.hi()\n+        } else {\n+            BytePos(1)\n+        };\n+        let next_hi = next_lo + BytePos(1);\n         self.blocks.push(BasicBlockData {\n-            statements: std::iter::repeat(&nop).cloned().take(num_nops).collect(),\n-            terminator: Some(Terminator { source_info: self.source_info, kind }),\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                source_info: SourceInfo::outermost(Span::with_root_ctxt(next_lo, next_hi)),\n+                kind,\n+            }),\n             is_cleanup: false,\n         })\n     }\n@@ -75,7 +105,7 @@ impl<'tcx> MockBlocks<'tcx> {\n         some_from_block: Option<BasicBlock>,\n         to_kind: TerminatorKind<'tcx>,\n     ) -> BasicBlock {\n-        let new_block = self.push(1, to_kind);\n+        let new_block = self.push(to_kind);\n         if let Some(from_block) = some_from_block {\n             self.link(from_block, new_block);\n         }\n@@ -152,7 +182,10 @@ fn debug_basic_blocks(mir_body: &Body<'tcx>) -> String {\n             .basic_blocks()\n             .iter_enumerated()\n             .map(|(bb, data)| {\n-                let kind = &data.terminator().kind;\n+                let term = &data.terminator();\n+                let kind = &term.kind;\n+                let span = term.source_info.span;\n+                let sp = format!(\"(span:{},{})\", span.lo().to_u32(), span.hi().to_u32());\n                 match kind {\n                     TerminatorKind::Assert { target, .. }\n                     | TerminatorKind::Call { destination: Some((_, target)), .. }\n@@ -163,12 +196,12 @@ fn debug_basic_blocks(mir_body: &Body<'tcx>) -> String {\n                     | TerminatorKind::Goto { target }\n                     | TerminatorKind::InlineAsm { destination: Some(target), .. }\n                     | TerminatorKind::Yield { resume: target, .. } => {\n-                        format!(\"{:?}:{} -> {:?}\", bb, debug::term_type(kind), target)\n+                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, debug::term_type(kind), target)\n                     }\n                     TerminatorKind::SwitchInt { targets, .. } => {\n-                        format!(\"{:?}:{} -> {:?}\", bb, debug::term_type(kind), targets)\n+                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, debug::term_type(kind), targets)\n                     }\n-                    _ => format!(\"{:?}:{}\", bb, debug::term_type(kind)),\n+                    _ => format!(\"{}{:?}:{}\", sp, bb, debug::term_type(kind)),\n                 }\n             })\n             .collect::<Vec<_>>()\n@@ -235,7 +268,7 @@ fn print_coverage_graphviz(\n }\n \n /// Create a mock `Body` with a simple flow.\n-fn mir_goto_switchint() -> Body<'a> {\n+fn goto_switchint() -> Body<'a> {\n     let mut blocks = MockBlocks::new();\n     let start = blocks.call(None);\n     let goto = blocks.goto(Some(start));\n@@ -281,13 +314,22 @@ fn mir_goto_switchint() -> Body<'a> {\n     mir_body\n }\n \n-fn covgraph_goto_switchint() -> graph::CoverageGraph {\n-    let mir_body = mir_goto_switchint();\n+macro_rules! assert_successors {\n+    ($basic_coverage_blocks:ident, $i:ident, [$($successor:ident),*]) => {\n+        let mut successors = $basic_coverage_blocks.successors[$i].clone();\n+        successors.sort_unstable();\n+        assert_eq!(successors, vec![$($successor),*]);\n+    }\n+}\n+\n+#[test]\n+fn test_covgraph_goto_switchint() {\n+    let mir_body = goto_switchint();\n     if false {\n         println!(\"basic_blocks = {}\", debug_basic_blocks(&mir_body));\n     }\n-    let covgraph = graph::CoverageGraph::from_mir(&mir_body);\n-    print_coverage_graphviz(\"covgraph_goto_switchint \", &mir_body, &covgraph);\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\"covgraph_goto_switchint \", &mir_body, &basic_coverage_blocks);\n     /*\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 bcb2: Return \u2502 \u25c0\u2500\u2500 \u2502 bcb0: SwitchInt \u2502\n@@ -299,11 +341,24 @@ fn covgraph_goto_switchint() -> graph::CoverageGraph {\n                          \u2502  bcb1: Return   \u2502\n                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     */\n-    covgraph\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        3,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1, bcb2]);\n+    assert_successors!(basic_coverage_blocks, bcb1, []);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n }\n \n /// Create a mock `Body` with a loop.\n-fn mir_switchint_then_loop_else_return() -> Body<'a> {\n+fn switchint_then_loop_else_return() -> Body<'a> {\n     let mut blocks = MockBlocks::new();\n     let start = blocks.call(None);\n     let switchint = blocks.switchint(Some(start));\n@@ -342,10 +397,15 @@ fn mir_switchint_then_loop_else_return() -> Body<'a> {\n     mir_body\n }\n \n-fn covgraph_switchint_then_loop_else_return() -> graph::CoverageGraph {\n-    let mir_body = mir_switchint_then_loop_else_return();\n-    let covgraph = graph::CoverageGraph::from_mir(&mir_body);\n-    print_coverage_graphviz(\"covgraph_switchint_then_loop_else_return\", &mir_body, &covgraph);\n+#[test]\n+fn test_covgraph_switchint_then_loop_else_return() {\n+    let mir_body = switchint_then_loop_else_return();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\n+        \"covgraph_switchint_then_loop_else_return\",\n+        &mir_body,\n+        &basic_coverage_blocks,\n+    );\n     /*\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502   bcb0: Call    \u2502\n@@ -365,11 +425,26 @@ fn covgraph_switchint_then_loop_else_return() -> graph::CoverageGraph {\n       \u2502                                     \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     */\n-    covgraph\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        4,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+    let_bcb!(3);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+    assert_successors!(basic_coverage_blocks, bcb3, [bcb1]);\n }\n \n /// Create a mock `Body` with nested loops.\n-fn mir_switchint_loop_then_inner_loop_else_break() -> Body<'a> {\n+fn switchint_loop_then_inner_loop_else_break() -> Body<'a> {\n     let mut blocks = MockBlocks::new();\n     let start = blocks.call(None);\n     let switchint = blocks.switchint(Some(start));\n@@ -438,13 +513,14 @@ fn mir_switchint_loop_then_inner_loop_else_break() -> Body<'a> {\n     mir_body\n }\n \n-fn covgraph_switchint_loop_then_inner_loop_else_break() -> graph::CoverageGraph {\n-    let mir_body = mir_switchint_loop_then_inner_loop_else_break();\n-    let covgraph = graph::CoverageGraph::from_mir(&mir_body);\n+#[test]\n+fn test_covgraph_switchint_loop_then_inner_loop_else_break() {\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n     print_coverage_graphviz(\n         \"covgraph_switchint_loop_then_inner_loop_else_break\",\n         &mir_body,\n-        &covgraph,\n+        &basic_coverage_blocks,\n     );\n     /*\n                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n@@ -477,39 +553,34 @@ fn covgraph_switchint_loop_then_inner_loop_else_break() -> graph::CoverageGraph\n       \u2502                                            \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     */\n-    covgraph\n-}\n-\n-macro_rules! assert_successors {\n-    ($basic_coverage_blocks:ident, $i:ident, [$($successor:ident),*]) => {\n-        let mut successors = $basic_coverage_blocks.successors[$i].clone();\n-        successors.sort_unstable();\n-        assert_eq!(successors, vec![$($successor),*]);\n-    }\n-}\n-\n-#[test]\n-fn test_covgraph_goto_switchint() {\n-    let basic_coverage_blocks = covgraph_goto_switchint();\n     assert_eq!(\n         basic_coverage_blocks.num_nodes(),\n-        3,\n+        7,\n         \"basic_coverage_blocks: {:?}\",\n         basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n     );\n \n     let_bcb!(0);\n     let_bcb!(1);\n     let_bcb!(2);\n+    let_bcb!(3);\n+    let_bcb!(4);\n+    let_bcb!(5);\n+    let_bcb!(6);\n \n-    assert_successors!(basic_coverage_blocks, bcb0, [bcb1, bcb2]);\n-    assert_successors!(basic_coverage_blocks, bcb1, []);\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n     assert_successors!(basic_coverage_blocks, bcb2, []);\n+    assert_successors!(basic_coverage_blocks, bcb3, [bcb4]);\n+    assert_successors!(basic_coverage_blocks, bcb4, [bcb5, bcb6]);\n+    assert_successors!(basic_coverage_blocks, bcb5, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb6, [bcb4]);\n }\n \n #[test]\n fn test_find_loop_backedges_none() {\n-    let basic_coverage_blocks = covgraph_goto_switchint();\n+    let mir_body = goto_switchint();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n     if false {\n         println!(\n             \"basic_coverage_blocks = {:?}\",\n@@ -526,30 +597,10 @@ fn test_find_loop_backedges_none() {\n     );\n }\n \n-#[test]\n-fn test_covgraph_switchint_then_loop_else_return() {\n-    let basic_coverage_blocks = covgraph_switchint_then_loop_else_return();\n-    assert_eq!(\n-        basic_coverage_blocks.num_nodes(),\n-        4,\n-        \"basic_coverage_blocks: {:?}\",\n-        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n-    );\n-\n-    let_bcb!(0);\n-    let_bcb!(1);\n-    let_bcb!(2);\n-    let_bcb!(3);\n-\n-    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n-    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n-    assert_successors!(basic_coverage_blocks, bcb2, []);\n-    assert_successors!(basic_coverage_blocks, bcb3, [bcb1]);\n-}\n-\n #[test]\n fn test_find_loop_backedges_one() {\n-    let basic_coverage_blocks = covgraph_switchint_then_loop_else_return();\n+    let mir_body = switchint_then_loop_else_return();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n     let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n     assert_eq!(\n         backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n@@ -564,36 +615,10 @@ fn test_find_loop_backedges_one() {\n     assert_eq!(backedges[bcb1], vec![bcb3]);\n }\n \n-#[test]\n-fn test_covgraph_switchint_loop_then_inner_loop_else_break() {\n-    let basic_coverage_blocks = covgraph_switchint_loop_then_inner_loop_else_break();\n-    assert_eq!(\n-        basic_coverage_blocks.num_nodes(),\n-        7,\n-        \"basic_coverage_blocks: {:?}\",\n-        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n-    );\n-\n-    let_bcb!(0);\n-    let_bcb!(1);\n-    let_bcb!(2);\n-    let_bcb!(3);\n-    let_bcb!(4);\n-    let_bcb!(5);\n-    let_bcb!(6);\n-\n-    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n-    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n-    assert_successors!(basic_coverage_blocks, bcb2, []);\n-    assert_successors!(basic_coverage_blocks, bcb3, [bcb4]);\n-    assert_successors!(basic_coverage_blocks, bcb4, [bcb5, bcb6]);\n-    assert_successors!(basic_coverage_blocks, bcb5, [bcb1]);\n-    assert_successors!(basic_coverage_blocks, bcb6, [bcb4]);\n-}\n-\n #[test]\n fn test_find_loop_backedges_two() {\n-    let basic_coverage_blocks = covgraph_switchint_loop_then_inner_loop_else_break();\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n     let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n     assert_eq!(\n         backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n@@ -613,7 +638,8 @@ fn test_find_loop_backedges_two() {\n \n #[test]\n fn test_traverse_coverage_with_loops() {\n-    let basic_coverage_blocks = covgraph_switchint_loop_then_inner_loop_else_break();\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n     let mut traversed_in_order = Vec::new();\n     let mut traversal = graph::TraverseCoverageGraphWithLoops::new(&basic_coverage_blocks);\n     while let Some(bcb) = traversal.next(&basic_coverage_blocks) {\n@@ -630,3 +656,58 @@ fn test_traverse_coverage_with_loops() {\n         \"bcb6 should not be visited until all nodes inside the first loop have been visited\"\n     );\n }\n+\n+fn synthesize_body_span_from_terminators(mir_body: &Body<'_>) -> Span {\n+    let mut some_span: Option<Span> = None;\n+    for (_, data) in mir_body.basic_blocks().iter_enumerated() {\n+        let term_span = data.terminator().source_info.span;\n+        if let Some(span) = some_span.as_mut() {\n+            *span = span.to(term_span);\n+        } else {\n+            some_span = Some(term_span)\n+        }\n+    }\n+    some_span.expect(\"body must have at least one BasicBlock\")\n+}\n+\n+#[test]\n+fn test_make_bcb_counters() {\n+    rustc_span::with_default_session_globals(|| {\n+        let mir_body = goto_switchint();\n+        let body_span = synthesize_body_span_from_terminators(&mir_body);\n+        let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+        let mut coverage_spans = Vec::new();\n+        for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n+            if let Some(span) =\n+                spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n+            {\n+                coverage_spans.push(spans::CoverageSpan::for_terminator(span, bcb, data.last_bb()));\n+            }\n+        }\n+        let mut coverage_counters = counters::CoverageCounters::new(0);\n+        let intermediate_expressions = coverage_counters\n+            .make_bcb_counters(&mut basic_coverage_blocks, &coverage_spans)\n+            .expect(\"should be Ok\");\n+        assert_eq!(intermediate_expressions.len(), 0);\n+\n+        let_bcb!(1);\n+        assert_eq!(\n+            1, // coincidentally, bcb1 has a `Counter` with id = 1\n+            match basic_coverage_blocks[bcb1].counter().expect(\"should have a counter\") {\n+                CoverageKind::Counter { id, .. } => id,\n+                _ => panic!(\"expected a Counter\"),\n+            }\n+            .as_u32()\n+        );\n+\n+        let_bcb!(2);\n+        assert_eq!(\n+            2, // coincidentally, bcb2 has a `Counter` with id = 2\n+            match basic_coverage_blocks[bcb2].counter().expect(\"should have a counter\") {\n+                CoverageKind::Counter { id, .. } => id,\n+                _ => panic!(\"expected a Counter\"),\n+            }\n+            .as_u32()\n+        );\n+    });\n+}"}]}