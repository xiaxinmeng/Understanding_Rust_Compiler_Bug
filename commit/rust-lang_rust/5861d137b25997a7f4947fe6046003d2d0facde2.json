{"sha": "5861d137b25997a7f4947fe6046003d2d0facde2", "node_id": "C_kwDOAAsO6NoAKDU4NjFkMTM3YjI1OTk3YTdmNDk0N2ZlNjA0NjAwM2QyZDBmYWNkZTI", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-04-16T03:04:07Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-04-30T14:25:52Z"}, "message": "Set the current span (somewhat) lazily", "tree": {"sha": "50b1145def204154c475072bf43c19aef0e6ac25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50b1145def204154c475072bf43c19aef0e6ac25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5861d137b25997a7f4947fe6046003d2d0facde2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5861d137b25997a7f4947fe6046003d2d0facde2", "html_url": "https://github.com/rust-lang/rust/commit/5861d137b25997a7f4947fe6046003d2d0facde2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5861d137b25997a7f4947fe6046003d2d0facde2/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f7e083dc92aba7a4c1818e56464fcb79f22f19", "html_url": "https://github.com/rust-lang/rust/commit/f3f7e083dc92aba7a4c1818e56464fcb79f22f19"}], "stats": {"total": 91, "additions": 58, "deletions": 33}, "files": [{"sha": "bba1989e2d58e0a5e4a091f68c0a7a143c671704", "filename": "src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=5861d137b25997a7f4947fe6046003d2d0facde2", "patch": "@@ -165,10 +165,10 @@ pub fn report_error<'tcx, 'mir>(\n                     ];\n                     match history {\n                         Some(TagHistory::Tagged {tag, created: (created_range, created_span), invalidated, protected }) => {\n-                            let msg = format!(\"{:?} was created due to a retag at offsets {}\", tag, HexRange(*created_range));\n+                            let msg = format!(\"{:?} was created by a retag at offsets {}\", tag, HexRange(*created_range));\n                             helps.push((Some(created_span.clone()), msg));\n                             if let Some((invalidated_range, invalidated_span)) = invalidated {\n-                                let msg = format!(\"{:?} was later invalidated due to a retag at offsets {}\", tag, HexRange(*invalidated_range));\n+                                let msg = format!(\"{:?} was later invalidated at offsets {}\", tag, HexRange(*invalidated_range));\n                                 helps.push((Some(invalidated_span.clone()), msg));\n                             }\n                             if let Some((protecting_tag, protecting_tag_span, protection_span)) = protected {"}, {"sha": "80738d33e0b9e89b81450b7b92dbd604e8018f7c", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=5861d137b25997a7f4947fe6046003d2d0facde2", "patch": "@@ -16,6 +16,7 @@ use rustc_target::spec::abi::Abi;\n use rustc_session::config::EntryFnType;\n \n use std::collections::HashSet;\n+use rustc_span::DUMMY_SP;\n \n use crate::*;\n \n@@ -283,24 +284,6 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     Ok((ecx, ret_place))\n }\n \n-// This is potentially a performance hazard.\n-// Factoring it into its own function lets us keep an eye on how much it shows up in a profile.\n-fn set_current_span<'mir, 'tcx: 'mir>(ecx: &mut MiriEvalContext<'mir, 'tcx>) {\n-    let current_span = Machine::stack(&ecx)\n-        .into_iter()\n-        .rev()\n-        .find(|frame| {\n-            let info =\n-                FrameInfo { instance: frame.instance, span: frame.current_span(), lint_root: None };\n-            ecx.machine.is_local(&info)\n-        })\n-        .map(|frame| frame.current_span())\n-        .unwrap_or(rustc_span::DUMMY_SP);\n-    if let Some(sb) = ecx.machine.stacked_borrows.as_mut() {\n-        sb.get_mut().current_span = current_span;\n-    }\n-}\n-\n /// Evaluates the entry function specified by `entry_id`.\n /// Returns `Some(return_code)` if program executed completed.\n /// Returns `None` if an evaluation error occured.\n@@ -328,8 +311,8 @@ pub fn eval_entry<'tcx>(\n             let info = ecx.preprocess_diagnostics();\n             match ecx.schedule()? {\n                 SchedulingAction::ExecuteStep => {\n-                    if ecx.machine.stacked_borrows.is_some() {\n-                        set_current_span(&mut ecx);\n+                    if let Some(sb) = ecx.machine.stacked_borrows.as_mut() {\n+                        sb.get_mut().current_span = DUMMY_SP;\n                     }\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n                 }"}, {"sha": "de9aaa2859d8e0292997940be85409994749d012", "filename": "src/machine.rs", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=5861d137b25997a7f4947fe6046003d2d0facde2", "patch": "@@ -25,6 +25,7 @@ use rustc_middle::{\n };\n use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n@@ -561,6 +562,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>> {\n+        set_current_span(&ecx.machine);\n         if ecx.machine.tracked_alloc_ids.contains(&id) {\n             register_diagnostic(NonHaltingDiagnostic::CreatedAlloc(id));\n         }\n@@ -589,6 +591,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         ptr: Pointer<AllocId>,\n     ) -> Pointer<Tag> {\n+        set_current_span(&ecx.machine);\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n         let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n             stacked_borrows.borrow_mut().base_tag(ptr.provenance)\n@@ -624,6 +627,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         (alloc_id, tag): (AllocId, Self::TagExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n+        set_current_span(&machine);\n         if let Some(data_race) = &alloc_extra.data_race {\n             data_race.read(alloc_id, range, machine.data_race.as_ref().unwrap())?;\n         }\n@@ -632,7 +636,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 alloc_id,\n                 tag,\n                 range,\n-                 machine.stacked_borrows.as_ref().unwrap(),\n+                machine.stacked_borrows.as_ref().unwrap(),\n             )\n         } else {\n             Ok(())\n@@ -647,6 +651,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         (alloc_id, tag): (AllocId, Self::TagExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n+        set_current_span(&machine);\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.write(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n         }\n@@ -670,6 +675,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         (alloc_id, tag): (AllocId, Self::TagExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n+        set_current_span(&machine);\n         if machine.tracked_alloc_ids.contains(&alloc_id) {\n             register_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n@@ -694,7 +700,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.machine.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n+        if ecx.machine.stacked_borrows.is_some() {\n+            set_current_span(&ecx.machine);\n+            ecx.retag(kind, place)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n@@ -740,7 +751,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n+        if ecx.machine.stacked_borrows.is_some() {\n+            set_current_span(&ecx.machine);\n+            ecx.retag_return_place()\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n@@ -757,3 +773,29 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         res\n     }\n }\n+\n+// This is potentially a performance hazard.\n+// Factoring it into its own function lets us keep an eye on how much it shows up in a profile.\n+fn set_current_span<'mir, 'tcx: 'mir>(machine: &Evaluator<'mir, 'tcx>) {\n+    if let Some(sb) = machine.stacked_borrows.as_ref() {\n+        if sb.borrow().current_span != DUMMY_SP {\n+            return;\n+        }\n+        let current_span = machine\n+            .threads\n+            .active_thread_stack()\n+            .into_iter()\n+            .rev()\n+            .find(|frame| {\n+                let info = FrameInfo {\n+                    instance: frame.instance,\n+                    span: frame.current_span(),\n+                    lint_root: None,\n+                };\n+                machine.is_local(&info)\n+            })\n+            .map(|frame| frame.current_span())\n+            .unwrap_or(rustc_span::DUMMY_SP);\n+        sb.borrow_mut().current_span = current_span;\n+    }\n+}"}, {"sha": "fcb702ea6ba802b8ce6c07047517a94075a13dda", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=5861d137b25997a7f4947fe6046003d2d0facde2", "patch": "@@ -125,9 +125,9 @@ struct AllocHistory {\n     // The time tags can be compressed down to one bit per event, by just storing a Vec<u8>\n     // where each bit is set to indicate if the event was a creation or a retag\n     current_time: usize,\n-    creations: Vec<Event>,\n-    invalidations: Vec<Event>,\n-    protectors: Vec<Protection>,\n+    creations: smallvec::SmallVec<[Event; 2]>,\n+    invalidations: smallvec::SmallVec<[Event; 1]>,\n+    protectors: smallvec::SmallVec<[Protection; 1]>,\n }\n \n #[derive(Debug)]\n@@ -552,9 +552,9 @@ impl<'tcx> Stack {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n-            self.access_error(access, tag, alloc_id, alloc_range, offset, global)\n-        })?;\n+        let granting_idx = self\n+            .find_granting(access, tag)\n+            .ok_or_else(|| self.access_error(access, tag, alloc_id, alloc_range, offset, global))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -852,7 +852,7 @@ impl Stacks {\n             let mut state = state.borrow_mut();\n             stack.access(AccessKind::Read, tag, (alloc_id, range, offset), &mut state)\n         })\n-   }\n+    }\n \n     #[inline(always)]\n     pub fn memory_written<'tcx>("}, {"sha": "5673af048fc5309dda251315e75fb07eaa31c472", "filename": "src/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5861d137b25997a7f4947fe6046003d2d0facde2/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=5861d137b25997a7f4947fe6046003d2d0facde2", "patch": "@@ -263,7 +263,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Borrow the stack of the active thread.\n-    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n+    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n         &self.threads[self.active_thread].stack\n     }\n "}]}