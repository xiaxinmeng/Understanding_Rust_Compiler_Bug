{"sha": "7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMjVhYTc5YzVhYTdlYThkZDJlYmUzYzk5ZDQ4M2RmMDhiZDAxZWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-19T14:37:29Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-19T14:38:49Z"}, "message": "Use `Size` instead of `u64` in mir interpretation", "tree": {"sha": "d5b9d6c54e44427b6e10bf8f9977d707a2604939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5b9d6c54e44427b6e10bf8f9977d707a2604939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "html_url": "https://github.com/rust-lang/rust/commit/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e933f4d8caf1cd37f69ea1283eff9c566db7cc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3", "html_url": "https://github.com/rust-lang/rust/commit/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3"}], "stats": {"total": 401, "additions": 204, "deletions": 197}, "files": [{"sha": "6885bf89cc8b6806a4965f10159ee7357d9c2f14", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -2,6 +2,7 @@ use std::{fmt, env};\n \n use mir;\n use ty::{FnSig, Ty, layout};\n+use ty::layout::{Size, Align};\n \n use super::{\n     MemoryPointer, Lock, AccessKind\n@@ -47,7 +48,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     PointerOutOfBounds {\n         ptr: MemoryPointer,\n         access: bool,\n-        allocation_size: u64,\n+        allocation_size: Size,\n     },\n     InvalidNullPointerUsage,\n     ReadPointerAsBytes,\n@@ -71,8 +72,8 @@ pub enum EvalErrorKind<'tcx, O> {\n     TlsOutOfBounds,\n     AbiViolation(String),\n     AlignmentCheckFailed {\n-        required: u64,\n-        has: u64,\n+        required: Align,\n+        has: Align,\n     },\n     MemoryLockViolation {\n         ptr: MemoryPointer,\n@@ -108,7 +109,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     DeallocatedWrongMemoryKind(String, String),\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n-    IncorrectAllocationInformation(u64, usize, u64, u64),\n+    IncorrectAllocationInformation(Size, Size, Align, Align),\n     Layout(layout::LayoutError<'tcx>),\n     HeapAllocZeroBytes,\n     HeapAllocNonPowerOfTwoAlignment(u64),\n@@ -269,7 +270,7 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n             PointerOutOfBounds { ptr, access, allocation_size } => {\n                 write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n                        if access { \"memory access\" } else { \"pointer computed\" },\n-                       ptr.offset, ptr.alloc_id, allocation_size)\n+                       ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n             MemoryLockViolation { ptr, len, frame, access, ref lock } => {\n                 write!(f, \"{:?} access by frame {} at {:?}, size {}, is in conflict with lock {:?}\",\n@@ -305,7 +306,7 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n             AlignmentCheckFailed { required, has } =>\n                write!(f, \"tried to access memory with alignment {}, but alignment {} is required\",\n-                      has, required),\n+                      has.abi(), required.abi()),\n             TypeNotPrimitive(ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n             Layout(ref err) =>\n@@ -315,7 +316,7 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n             MachineError(ref inner) =>\n                 write!(f, \"{}\", inner),\n             IncorrectAllocationInformation(size, size2, align, align2) =>\n-                write!(f, \"incorrect alloc info: expected size {} and align {}, got size {} and align {}\", size, align, size2, align2),\n+                write!(f, \"incorrect alloc info: expected size {} and align {}, got size {} and align {}\", size.bytes(), align.abi(), size2.bytes(), align2.abi()),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "d4f18acf8ad5404d961f9591ff2b4ffe0791a915", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -17,7 +17,7 @@ use std::fmt;\n use mir;\n use hir::def_id::DefId;\n use ty::{self, TyCtxt};\n-use ty::layout::{self, Align, HasDataLayout};\n+use ty::layout::{self, Align, HasDataLayout, Size};\n use middle::region;\n use std::iter;\n use std::io;\n@@ -109,42 +109,42 @@ impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub struct MemoryPointer {\n     pub alloc_id: AllocId,\n-    pub offset: u64,\n+    pub offset: Size,\n }\n \n impl<'tcx> MemoryPointer {\n-    pub fn new(alloc_id: AllocId, offset: u64) -> Self {\n+    pub fn new(alloc_id: AllocId, offset: Size) -> Self {\n         MemoryPointer { alloc_id, offset }\n     }\n \n     pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n         MemoryPointer::new(\n             self.alloc_id,\n-            cx.data_layout().wrapping_signed_offset(self.offset, i),\n+            Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n         )\n     }\n \n     pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset, i);\n-        (MemoryPointer::new(self.alloc_id, res), over)\n+        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n+        (MemoryPointer::new(self.alloc_id, Size::from_bytes(res)), over)\n     }\n \n     pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         Ok(MemoryPointer::new(\n             self.alloc_id,\n-            cx.data_layout().signed_offset(self.offset, i)?,\n+            Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n         ))\n     }\n \n-    pub fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_offset(self.offset, i);\n-        (MemoryPointer::new(self.alloc_id, res), over)\n+    pub fn overflowing_offset<C: HasDataLayout>(self, i: Size, cx: C) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n+        (MemoryPointer::new(self.alloc_id, Size::from_bytes(res)), over)\n     }\n \n-    pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n         Ok(MemoryPointer::new(\n             self.alloc_id,\n-            cx.data_layout().offset(self.offset, i)?,\n+            Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n         ))\n     }\n }\n@@ -244,7 +244,7 @@ pub struct Allocation {\n     pub bytes: Vec<u8>,\n     /// Maps from byte addresses to allocations.\n     /// Only the first byte of a pointer is inserted into the map.\n-    pub relocations: BTreeMap<u64, AllocId>,\n+    pub relocations: BTreeMap<Size, AllocId>,\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n@@ -257,8 +257,8 @@ pub struct Allocation {\n \n impl Allocation {\n     pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n-        let mut undef_mask = UndefMask::new(0);\n-        undef_mask.grow(slice.len() as u64, true);\n+        let mut undef_mask = UndefMask::new(Size::from_bytes(0));\n+        undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n         Self {\n             bytes: slice.to_owned(),\n             relocations: BTreeMap::new(),\n@@ -272,10 +272,10 @@ impl Allocation {\n         Allocation::from_bytes(slice, Align::from_bytes(1, 1).unwrap())\n     }\n \n-    pub fn undef(size: u64, align: Align) -> Self {\n-        assert_eq!(size as usize as u64, size);\n+    pub fn undef(size: Size, align: Align) -> Self {\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n-            bytes: vec![0; size as usize],\n+            bytes: vec![0; size.bytes() as usize],\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n@@ -331,54 +331,54 @@ const BLOCK_SIZE: u64 = 64;\n #[derive(Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UndefMask {\n     blocks: Vec<Block>,\n-    len: u64,\n+    len: Size,\n }\n \n impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n \n impl UndefMask {\n-    pub fn new(size: u64) -> Self {\n+    pub fn new(size: Size) -> Self {\n         let mut m = UndefMask {\n             blocks: vec![],\n-            len: 0,\n+            len: Size::from_bytes(0),\n         };\n         m.grow(size, false);\n         m\n     }\n \n     /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n-    pub fn is_range_defined(&self, start: u64, end: u64) -> bool {\n+    pub fn is_range_defined(&self, start: Size, end: Size) -> bool {\n         if end > self.len {\n             return false;\n         }\n-        for i in start..end {\n-            if !self.get(i) {\n+        for i in start.bytes()..end.bytes() {\n+            if !self.get(Size::from_bytes(i)) {\n                 return false;\n             }\n         }\n         true\n     }\n \n-    pub fn set_range(&mut self, start: u64, end: u64, new_state: bool) {\n+    pub fn set_range(&mut self, start: Size, end: Size, new_state: bool) {\n         let len = self.len;\n         if end > len {\n             self.grow(end - len, new_state);\n         }\n         self.set_range_inbounds(start, end, new_state);\n     }\n \n-    pub fn set_range_inbounds(&mut self, start: u64, end: u64, new_state: bool) {\n-        for i in start..end {\n-            self.set(i, new_state);\n+    pub fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n+        for i in start.bytes()..end.bytes() {\n+            self.set(Size::from_bytes(i), new_state);\n         }\n     }\n \n-    pub fn get(&self, i: u64) -> bool {\n+    pub fn get(&self, i: Size) -> bool {\n         let (block, bit) = bit_index(i);\n         (self.blocks[block] & 1 << bit) != 0\n     }\n \n-    pub fn set(&mut self, i: u64, new_state: bool) {\n+    pub fn set(&mut self, i: Size, new_state: bool) {\n         let (block, bit) = bit_index(i);\n         if new_state {\n             self.blocks[block] |= 1 << bit;\n@@ -387,10 +387,10 @@ impl UndefMask {\n         }\n     }\n \n-    pub fn grow(&mut self, amount: u64, new_state: bool) {\n-        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len;\n-        if amount > unused_trailing_bits {\n-            let additional_blocks = amount / BLOCK_SIZE + 1;\n+    pub fn grow(&mut self, amount: Size, new_state: bool) {\n+        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len.bytes();\n+        if amount.bytes() > unused_trailing_bits {\n+            let additional_blocks = amount.bytes() / BLOCK_SIZE + 1;\n             assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n                 iter::repeat(0).take(additional_blocks as usize),\n@@ -402,7 +402,8 @@ impl UndefMask {\n     }\n }\n \n-fn bit_index(bits: u64) -> (usize, usize) {\n+fn bit_index(bits: Size) -> (usize, usize) {\n+    let bits = bits.bytes();\n     let a = bits / BLOCK_SIZE;\n     let b = bits % BLOCK_SIZE;\n     assert_eq!(a as usize as u64, a);"}, {"sha": "5ac2f7f356ead2947b8951e664281e399a4efe63", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -1,6 +1,6 @@\n #![allow(unknown_lints)]\n \n-use ty::layout::{Align, HasDataLayout};\n+use ty::layout::{Align, HasDataLayout, Size};\n use ty;\n \n use super::{EvalResult, MemoryPointer, PointerArithmetic, Allocation};\n@@ -14,7 +14,7 @@ pub enum ConstValue<'tcx> {\n     /// Used only for types with layout::abi::ScalarPair\n     ByValPair(PrimVal, PrimVal),\n     /// Used only for the remaining cases. An allocation + offset into the allocation\n-    ByRef(&'tcx Allocation, u64),\n+    ByRef(&'tcx Allocation, Size),\n }\n \n impl<'tcx> ConstValue<'tcx> {\n@@ -129,13 +129,13 @@ impl<'tcx> Pointer {\n         }\n     }\n \n-    pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n                 Ok(Pointer::from(\n-                    PrimVal::Bytes(layout.offset(b as u64, i)? as u128),\n+                    PrimVal::Bytes(layout.offset(b as u64, i.bytes())? as u128),\n                 ))\n             }\n             PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n@@ -336,25 +336,25 @@ impl PrimValKind {\n         }\n     }\n \n-    pub fn from_uint_size(size: u64) -> Self {\n-        match size {\n+    pub fn from_uint_size(size: Size) -> Self {\n+        match size.bytes() {\n             1 => PrimValKind::U8,\n             2 => PrimValKind::U16,\n             4 => PrimValKind::U32,\n             8 => PrimValKind::U64,\n             16 => PrimValKind::U128,\n-            _ => bug!(\"can't make uint with size {}\", size),\n+            _ => bug!(\"can't make uint with size {}\", size.bytes()),\n         }\n     }\n \n-    pub fn from_int_size(size: u64) -> Self {\n-        match size {\n+    pub fn from_int_size(size: Size) -> Self {\n+        match size.bytes() {\n             1 => PrimValKind::I8,\n             2 => PrimValKind::I16,\n             4 => PrimValKind::I32,\n             8 => PrimValKind::I64,\n             16 => PrimValKind::I128,\n-            _ => bug!(\"can't make int with size {}\", size),\n+            _ => bug!(\"can't make int with size {}\", size.bytes()),\n         }\n     }\n "}, {"sha": "f42f876510de72be12eb4b013fd0de5482b69142", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -1913,7 +1913,7 @@ pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Resul\n                     .get_alloc(ptr.alloc_id);\n                 if let Some(alloc) = alloc {\n                     assert_eq!(len as usize as u128, len);\n-                    let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];\n+                    let slice = &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n                     let s = ::std::str::from_utf8(slice)\n                         .expect(\"non utf8 str from miri\");\n                     write!(f, \"{:?}\", s)"}, {"sha": "36c1d335ec4d73ba17ab89698dfc1dc690bfa688", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -16,7 +16,7 @@ use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::mir::interpret::{GlobalId, MemoryPointer, PrimVal, Allocation, ConstValue};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar};\n+use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar, Size};\n use builder::Builder;\n use common::{CodegenCx};\n use common::{C_bytes, C_struct, C_uint_big, C_undef, C_usize};\n@@ -68,7 +68,7 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n \n                 let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n                     consts::bitcast(base_addr, Type::i8p(cx)),\n-                    &C_usize(cx, ptr.offset),\n+                    &C_usize(cx, ptr.offset.bytes()),\n                     1,\n                 ) };\n                 if scalar.value != layout::Pointer {\n@@ -88,6 +88,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n \n     let mut next_offset = 0;\n     for (&offset, &alloc_id) in &alloc.relocations {\n+        let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n@@ -99,7 +100,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(primval_to_llvm(\n             cx,\n-            PrimVal::Ptr(MemoryPointer { alloc_id, offset: ptr_offset }),\n+            PrimVal::Ptr(MemoryPointer { alloc_id, offset: Size::from_bytes(ptr_offset) }),\n             &Scalar {\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0\n@@ -129,7 +130,7 @@ pub fn codegen_static_initializer<'a, 'tcx>(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstVal::Value(ConstValue::ByRef(alloc, 0)) => alloc,\n+        ConstVal::Value(ConstValue::ByRef(alloc, n)) if n.bytes() == 0 => alloc,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok(const_alloc_to_llvm(cx, alloc))"}, {"sha": "91e393733341990b2a1ecbe35aecea1942d18570", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n                 let llval = unsafe { LLVMConstInBoundsGEP(\n                     consts::bitcast(base_addr, Type::i8p(bx.cx)),\n-                    &C_usize(bx.cx, offset),\n+                    &C_usize(bx.cx, offset.bytes()),\n                     1,\n                 )};\n                 let llval = consts::bitcast(llval, layout.llvm_type(bx.cx).ptr_to());"}, {"sha": "4739c0e92ed2b79edacff0fe4c845a5bab6eda3a", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n-use rustc::ty::layout::IntegerExt;\n+use rustc::ty::layout::{IntegerExt, Size};\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt, layout};\n use rustc::ty::subst::Substs;\n@@ -182,15 +182,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_cached(s.as_bytes());\n-                let ptr = MemoryPointer::new(id, 0);\n+                let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n                 ConstValue::ByValPair(\n                     PrimVal::Ptr(ptr),\n                     PrimVal::from_u128(s.len() as u128),\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_cached(data);\n-                let ptr = MemoryPointer::new(id, 0);\n+                let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n                 ConstValue::ByVal(PrimVal::Ptr(ptr))\n             },\n             LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),"}, {"sha": "0c2645b4c5cdc4430eb6527a400b23e102a341f2", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -191,7 +191,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                             .interpret_interner\n                             .get_alloc(ptr.alloc_id)\n                             .unwrap();\n-                        assert_eq!(ptr.offset, 0);\n+                        assert_eq!(ptr.offset.bytes(), 0);\n                         // FIXME: check length\n                         alloc.bytes.iter().map(|b| {\n                             &*pattern_arena.alloc(Pattern {"}, {"sha": "0368e6595c18dfecbca16b83d29ff1061d3a3ea3", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::ty::layout::Size;\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -1083,15 +1084,15 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n             let id = tcx.allocate_cached(s.as_bytes());\n-            let ptr = MemoryPointer::new(id, 0);\n+            let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n             ConstValue::ByValPair(\n                 PrimVal::Ptr(ptr),\n                 PrimVal::from_u128(s.len() as u128),\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_cached(data);\n-            let ptr = MemoryPointer::new(id, 0);\n+            let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n             ConstValue::ByVal(PrimVal::Ptr(ptr))\n         },\n         LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),"}, {"sha": "b5568b833397f210d4d7234565f8e811a2db5381", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -73,15 +73,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_ty.sty {\n             // float -> uint\n             TyUint(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size() as usize * 8);\n+                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bytes() as usize * 8);\n                 match fty {\n                     FloatTy::F32 => Ok(PrimVal::Bytes(Single::from_bits(bits).to_u128(width).value)),\n                     FloatTy::F64 => Ok(PrimVal::Bytes(Double::from_bits(bits).to_u128(width).value)),\n                 }\n             },\n             // float -> int\n             TyInt(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size() as usize * 8);\n+                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bytes() as usize * 8);\n                 match fty {\n                     FloatTy::F32 => Ok(PrimVal::from_i128(Single::from_bits(bits).to_i128(width).value)),\n                     FloatTy::F64 => Ok(PrimVal::from_i128(Double::from_bits(bits).to_i128(width).value)),"}, {"sha": "c51438170300027e7ec5fbb01ac2216118b2374b", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -114,7 +114,7 @@ pub fn value_to_const_value<'tcx>(\n                 let ptr = ptr.primval.to_ptr().unwrap();\n                 let alloc = ecx.memory.get(ptr.alloc_id)?;\n                 assert!(alloc.align.abi() >= align.abi());\n-                assert!(alloc.bytes.len() as u64 - ptr.offset >= layout.size.bytes());\n+                assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n                 let mut alloc = alloc.clone();\n                 alloc.align = align;\n                 let alloc = ecx.tcx.intern_const_alloc(alloc);\n@@ -165,7 +165,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ptr = ecx.memory.allocate(\n-        layout.size.bytes(),\n+        layout.size,\n         layout.align,\n         None,\n     )?;\n@@ -470,7 +470,7 @@ pub fn const_variant_index<'a, 'tcx>(\n     let (ptr, align) = match value {\n         Value::ByValPair(..) | Value::ByVal(_) => {\n             let layout = ecx.layout_of(ty)?;\n-            let ptr = ecx.memory.allocate(layout.size.bytes(), layout.align, Some(MemoryKind::Stack))?;\n+            let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?;\n             let ptr: Pointer = ptr.into();\n             ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n             (ptr, layout.align)\n@@ -487,7 +487,7 @@ pub fn const_value_to_allocation_provider<'a, 'tcx>(\n ) -> &'tcx Allocation {\n     match val {\n         ConstValue::ByRef(alloc, offset) => {\n-            assert_eq!(offset, 0);\n+            assert_eq!(offset.bytes(), 0);\n             return alloc;\n         },\n         _ => ()\n@@ -500,7 +500,7 @@ pub fn const_value_to_allocation_provider<'a, 'tcx>(\n             ());\n         let value = ecx.const_value_to_value(val, ty)?;\n         let layout = ecx.layout_of(ty)?;\n-        let ptr = ecx.memory.allocate(layout.size.bytes(), layout.align, Some(MemoryKind::Stack))?;\n+        let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?;\n         ecx.write_value_to_ptr(value, ptr.into(), layout.align, ty)?;\n         let alloc = ecx.memory.get(ptr.alloc_id)?;\n         Ok(tcx.intern_const_alloc(alloc.clone()))"}, {"sha": "1b4cdccee76bdc99ec99337c572e0ce7404fedd4", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -207,8 +207,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n-        let size = layout.size.bytes();\n-        self.memory.allocate(size, layout.align, Some(MemoryKind::Stack))\n+        self.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n@@ -598,14 +597,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         )\n                     }\n                 };\n-                let elem_size = self.layout_of(elem_ty)?.size.bytes();\n+                let elem_size = self.layout_of(elem_ty)?.size;\n                 let value = self.eval_operand(operand)?.value;\n \n                 let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n \n                 // FIXME: speed up repeat filling\n                 for i in 0..length {\n-                    let elem_dest = dest.offset(i * elem_size, &self)?;\n+                    let elem_dest = dest.offset(elem_size * i as u64, &self)?;\n                     self.write_value_to_ptr(value, elem_dest, dest_align, elem_ty)?;\n                 }\n             }\n@@ -1027,7 +1026,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 .interpret_interner\n                 .cache_static(gid.instance.def_id());\n             let layout = self.layout_of(ty)?;\n-            let ptr = MemoryPointer::new(alloc_id, 0);\n+            let ptr = MemoryPointer::new(alloc_id, Size::from_bytes(0));\n             return Ok(Value::ByRef(ptr.into(), layout.align))\n         }\n         let cv = self.const_eval(gid)?;\n@@ -1195,7 +1194,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             } else {\n                 let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n                 let layout = self.layout_of(dest_ty)?;\n-                self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size.bytes(), false)?;\n+                self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size, false)?;\n                 write_dest(self, Value::ByRef(dest_ptr, layout.align))?;\n             }\n         } else {\n@@ -1217,7 +1216,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         trace!(\"write_value_to_ptr: {:#?}, {}, {:#?}\", value, dest_ty, layout);\n         match value {\n             Value::ByRef(ptr, align) => {\n-                self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size.bytes(), false)\n+                self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n             }\n             Value::ByVal(primval) => {\n                 let signed = match layout.abi {\n@@ -1228,7 +1227,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     _ if primval.is_undef() => false,\n                     _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout)\n                 };\n-                self.memory.write_primval(dest, dest_align, primval, layout.size.bytes(), signed)\n+                self.memory.write_primval(dest, dest_align, primval, layout.size, signed)\n             }\n             Value::ByValPair(a_val, b_val) => {\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n@@ -1239,10 +1238,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n                 let a_ptr = dest;\n                 let b_offset = a_size.abi_align(b.align(&self));\n-                let b_ptr = dest.offset(b_offset.bytes(), &self)?.into();\n+                let b_ptr = dest.offset(b_offset, &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory.write_primval(a_ptr, dest_align, a_val, a_size.bytes(), false)?;\n-                self.memory.write_primval(b_ptr, dest_align, b_val, b_size.bytes(), false)\n+                self.memory.write_primval(a_ptr, dest_align, a_val, a_size, false)?;\n+                self.memory.write_primval(b_ptr, dest_align, b_val, b_size, false)\n             }\n         }\n     }\n@@ -1257,11 +1256,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             ty::TyInt(int_ty) => {\n                 use syntax::ast::IntTy::*;\n                 let size = match int_ty {\n-                    I8 => 1,\n-                    I16 => 2,\n-                    I32 => 4,\n-                    I64 => 8,\n-                    I128 => 16,\n+                    I8 => Size::from_bytes(1),\n+                    I16 => Size::from_bytes(2),\n+                    I32 => Size::from_bytes(4),\n+                    I64 => Size::from_bytes(8),\n+                    I128 => Size::from_bytes(16),\n                     Isize => self.memory.pointer_size(),\n                 };\n                 PrimValKind::from_int_size(size)\n@@ -1270,11 +1269,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             ty::TyUint(uint_ty) => {\n                 use syntax::ast::UintTy::*;\n                 let size = match uint_ty {\n-                    U8 => 1,\n-                    U16 => 2,\n-                    U32 => 4,\n-                    U64 => 8,\n-                    U128 => 16,\n+                    U8 => Size::from_bytes(1),\n+                    U16 => Size::from_bytes(2),\n+                    U32 => Size::from_bytes(4),\n+                    U64 => Size::from_bytes(8),\n+                    U128 => Size::from_bytes(16),\n                     Usize => self.memory.pointer_size(),\n                 };\n                 PrimValKind::from_uint_size(size)\n@@ -1297,8 +1296,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     layout::Abi::Scalar(ref scalar) => {\n                         use rustc::ty::layout::Primitive::*;\n                         match scalar.value {\n-                            Int(i, false) => PrimValKind::from_uint_size(i.size().bytes()),\n-                            Int(i, true) => PrimValKind::from_int_size(i.size().bytes()),\n+                            Int(i, false) => PrimValKind::from_uint_size(i.size()),\n+                            Int(i, true) => PrimValKind::from_int_size(i.size()),\n                             F32 => PrimValKind::F32,\n                             F64 => PrimValKind::F64,\n                             Pointer => PrimValKind::Ptr,\n@@ -1372,15 +1371,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         match ty.sty {\n             ty::TyBool => {\n-                let val = self.memory.read_primval(ptr, ptr_align, 1)?;\n+                let val = self.memory.read_primval(ptr, ptr_align, Size::from_bytes(1))?;\n                 match val {\n                     PrimVal::Bytes(0) | PrimVal::Bytes(1) => (),\n                     // TODO: This seems a little overeager, should reading at bool type already be insta-UB?\n                     _ => return err!(InvalidBool),\n                 }\n             }\n             ty::TyChar => {\n-                let c = self.memory.read_primval(ptr, ptr_align, 4)?.to_bytes()? as u32;\n+                let c = self.memory.read_primval(ptr, ptr_align, Size::from_bytes(4))?.to_bytes()? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(..) => (),\n                     None => return err!(InvalidChar(c as u128)),\n@@ -1402,7 +1401,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 }\n \n                 if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n-                    let size = scalar.value.size(self).bytes();\n+                    let size = scalar.value.size(self);\n                     self.memory.read_primval(ptr, ptr_align, size)?;\n                 }\n             }\n@@ -1437,17 +1436,17 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n         match layout.abi {\n             layout::Abi::Scalar(..) => {\n-                let primval = self.memory.read_primval(ptr, ptr_align, layout.size.bytes())?;\n+                let primval = self.memory.read_primval(ptr, ptr_align, layout.size)?;\n                 Ok(Some(Value::ByVal(primval)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let (a, b) = (&a.value, &b.value);\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let a_ptr = ptr;\n                 let b_offset = a_size.abi_align(b.align(self));\n-                let b_ptr = ptr.offset(b_offset.bytes(), self)?.into();\n-                let a_val = self.memory.read_primval(a_ptr, ptr_align, a_size.bytes())?;\n-                let b_val = self.memory.read_primval(b_ptr, ptr_align, b_size.bytes())?;\n+                let b_ptr = ptr.offset(b_offset, self)?.into();\n+                let a_val = self.memory.read_primval(a_ptr, ptr_align, a_size)?;\n+                let b_val = self.memory.read_primval(b_ptr, ptr_align, b_size)?;\n                 Ok(Some(Value::ByValPair(a_val, b_val)))\n             }\n             _ => Ok(None),"}, {"sha": "a5c94e4fcecfc2316bd6296e18c707679e9f6380", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -7,6 +7,7 @@ use super::{EvalContext, Place, ValTy, Memory};\n \n use rustc::mir;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::Size;\n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n \n@@ -92,7 +93,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn check_locks<'a>(\n         _mem: &Memory<'a, 'mir, 'tcx, Self>,\n         _ptr: MemoryPointer,\n-        _size: u64,\n+        _size: Size,\n         _access: AccessKind,\n     ) -> EvalResult<'tcx> {\n         Ok(())"}, {"sha": "755eaa443b6cddd8324c366b78022b0cb76c0256", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 86, "deletions": 83, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::Instance;\n use rustc::ty::ParamEnv;\n use rustc::ty::maps::TyCtxtAt;\n-use rustc::ty::layout::{self, Align, TargetDataLayout};\n+use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n use syntax::ast::Mutability;\n use rustc::middle::const_val::{ConstVal, ErrKind};\n \n@@ -73,12 +73,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n         let id = self.tcx.interpret_interner.create_fn_alloc(instance);\n-        MemoryPointer::new(id, 0)\n+        MemoryPointer::new(id, Size::from_bytes(0))\n     }\n \n     pub fn allocate_cached(&mut self, bytes: &[u8]) -> MemoryPointer {\n         let id = self.tcx.allocate_cached(bytes);\n-        MemoryPointer::new(id, 0)\n+        MemoryPointer::new(id, Size::from_bytes(0))\n     }\n \n     /// kind is `None` for statics\n@@ -105,24 +105,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// kind is `None` for statics\n     pub fn allocate(\n         &mut self,\n-        size: u64,\n+        size: Size,\n         align: Align,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         let id = self.allocate_value(Allocation::undef(size, align), kind)?;\n-        Ok(MemoryPointer::new(id, 0))\n+        Ok(MemoryPointer::new(id, Size::from_bytes(0)))\n     }\n \n     pub fn reallocate(\n         &mut self,\n         ptr: MemoryPointer,\n-        old_size: u64,\n+        old_size: Size,\n         old_align: Align,\n-        new_size: u64,\n+        new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n-        if ptr.offset != 0 {\n+        if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n         if self.alloc_map.contains_key(&ptr.alloc_id) {\n@@ -163,10 +163,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn deallocate(\n         &mut self,\n         ptr: MemoryPointer,\n-        size_and_align: Option<(u64, Align)>,\n+        size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n-        if ptr.offset != 0 {\n+        if ptr.offset.bytes() != 0 {\n             return err!(DeallocateNonBasePtr);\n         }\n \n@@ -208,8 +208,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             ));\n         }\n         if let Some((size, align)) = size_and_align {\n-            if size != alloc.bytes.len() as u64 || align != alloc.align {\n-                return err!(IncorrectAllocationInformation(size, alloc.bytes.len(), align.abi(), alloc.align.abi()));\n+            if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n+                return err!(IncorrectAllocationInformation(size, Size::from_bytes(alloc.bytes.len() as u64), align, alloc.align));\n             }\n         }\n \n@@ -218,8 +218,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn pointer_size(&self) -> u64 {\n-        self.tcx.data_layout.pointer_size.bytes()\n+    pub fn pointer_size(&self) -> Size {\n+        self.tcx.data_layout.pointer_size\n     }\n \n     pub fn endianness(&self) -> layout::Endian {\n@@ -232,10 +232,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         let (offset, alloc_align) = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n-                (ptr.offset, alloc.align)\n+                (ptr.offset.bytes(), alloc.align)\n             }\n             PrimVal::Bytes(bytes) => {\n-                let v = ((bytes as u128) % (1 << self.pointer_size())) as u64;\n+                let v = ((bytes as u128) % (1 << self.pointer_size().bytes())) as u64;\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n@@ -247,28 +247,29 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // Check alignment\n         if alloc_align.abi() < required_align.abi() {\n             return err!(AlignmentCheckFailed {\n-                has: alloc_align.abi(),\n-                required: required_align.abi(),\n+                has: alloc_align,\n+                required: required_align,\n             });\n         }\n         if offset % required_align.abi() == 0 {\n             Ok(())\n         } else {\n+            let has = offset % required_align.abi();\n             err!(AlignmentCheckFailed {\n-                has: offset % required_align.abi(),\n-                required: required_align.abi(),\n+                has: Align::from_bytes(has, has).unwrap(),\n+                required: required_align,\n             })\n         }\n     }\n \n     pub fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n-        if ptr.offset > allocation_size {\n+        if ptr.offset.bytes() > allocation_size {\n             return err!(PointerOutOfBounds {\n                 ptr,\n                 access,\n-                allocation_size,\n+                allocation_size: Size::from_bytes(allocation_size),\n             });\n         }\n         Ok(())\n@@ -354,7 +355,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Instance<'tcx>> {\n-        if ptr.offset != 0 {\n+        if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n         debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n@@ -419,15 +420,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 };\n \n             for i in 0..(alloc.bytes.len() as u64) {\n+                let i = Size::from_bytes(i);\n                 if let Some(&target_id) = alloc.relocations.get(&i) {\n                     if allocs_seen.insert(target_id) {\n                         allocs_to_print.push_back(target_id);\n                     }\n                     relocations.push((i, target_id));\n                 }\n-                if alloc.undef_mask.is_range_defined(i, i + 1) {\n+                if alloc.undef_mask.is_range_defined(i, i + Size::from_bytes(1)) {\n                     // this `as usize` is fine, since `i` came from a `usize`\n-                    write!(msg, \"{:02x} \", alloc.bytes[i as usize]).unwrap();\n+                    write!(msg, \"{:02x} \", alloc.bytes[i.bytes() as usize]).unwrap();\n                 } else {\n                     msg.push_str(\"__ \");\n                 }\n@@ -444,11 +446,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             if !relocations.is_empty() {\n                 msg.clear();\n                 write!(msg, \"{:1$}\", \"\", prefix_len).unwrap(); // Print spaces.\n-                let mut pos = 0;\n-                let relocation_width = (self.pointer_size() - 1) * 3;\n+                let mut pos = Size::from_bytes(0);\n+                let relocation_width = (self.pointer_size().bytes() - 1) * 3;\n                 for (i, target_id) in relocations {\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n-                    write!(msg, \"{:1$}\", \"\", ((i - pos) * 3) as usize).unwrap();\n+                    write!(msg, \"{:1$}\", \"\", ((i - pos) * 3).bytes() as usize).unwrap();\n                     let target = format!(\"({})\", target_id);\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n                     write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n@@ -476,45 +478,45 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn get_bytes_unchecked(\n         &self,\n         ptr: MemoryPointer,\n-        size: u64,\n+        size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n         self.check_align(ptr.into(), align)?;\n-        if size == 0 {\n+        if size.bytes() == 0 {\n             return Ok(&[]);\n         }\n         M::check_locks(self, ptr, size, AccessKind::Read)?;\n         self.check_bounds(ptr.offset(size, self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n-        assert_eq!(ptr.offset as usize as u64, ptr.offset);\n-        assert_eq!(size as usize as u64, size);\n-        let offset = ptr.offset as usize;\n-        Ok(&alloc.bytes[offset..offset + size as usize])\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n \n     fn get_bytes_unchecked_mut(\n         &mut self,\n         ptr: MemoryPointer,\n-        size: u64,\n+        size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n         self.check_align(ptr.into(), align)?;\n-        if size == 0 {\n+        if size.bytes() == 0 {\n             return Ok(&mut []);\n         }\n         M::check_locks(self, ptr, size, AccessKind::Write)?;\n         self.check_bounds(ptr.offset(size, &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n-        assert_eq!(ptr.offset as usize as u64, ptr.offset);\n-        assert_eq!(size as usize as u64, size);\n-        let offset = ptr.offset as usize;\n-        Ok(&mut alloc.bytes[offset..offset + size as usize])\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n \n-    fn get_bytes(&self, ptr: MemoryPointer, size: u64, align: Align) -> EvalResult<'tcx, &[u8]> {\n-        assert_ne!(size, 0);\n+    fn get_bytes(&self, ptr: MemoryPointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n+        assert_ne!(size.bytes(), 0);\n         if self.relocations(ptr, size)?.count() != 0 {\n             return err!(ReadPointerAsBytes);\n         }\n@@ -525,10 +527,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn get_bytes_mut(\n         &mut self,\n         ptr: MemoryPointer,\n-        size: u64,\n+        size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n-        assert_ne!(size, 0);\n+        assert_ne!(size.bytes(), 0);\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(ptr.into(), size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size, align)\n@@ -594,13 +596,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         src_align: Align,\n         dest: Pointer,\n         dest_align: Align,\n-        size: u64,\n+        size: Size,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be aligned\n         self.check_align(src, src_align)?;\n         self.check_align(dest, dest_align)?;\n-        if size == 0 {\n+        if size.bytes() == 0 {\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -625,7 +627,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n         // `dest` could possibly overlap.\n         unsafe {\n-            assert_eq!(size as usize as u64, size);\n+            assert_eq!(size.bytes() as usize as u64, size.bytes());\n             if src.alloc_id == dest.alloc_id {\n                 if nonoverlapping {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n@@ -636,9 +638,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                         ));\n                     }\n                 }\n-                ptr::copy(src_bytes, dest_bytes, size as usize);\n+                ptr::copy(src_bytes, dest_bytes, size.bytes() as usize);\n             } else {\n-                ptr::copy_nonoverlapping(src_bytes, dest_bytes, size as usize);\n+                ptr::copy_nonoverlapping(src_bytes, dest_bytes, size.bytes() as usize);\n             }\n         }\n \n@@ -651,26 +653,27 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn read_c_str(&self, ptr: MemoryPointer) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n-        assert_eq!(ptr.offset as usize as u64, ptr.offset);\n-        let offset = ptr.offset as usize;\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n         match alloc.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n-                if self.relocations(ptr, (size + 1) as u64)?.count() != 0 {\n+                let p1 = Size::from_bytes((size + 1) as u64);\n+                if self.relocations(ptr, p1)?.count() != 0 {\n                     return err!(ReadPointerAsBytes);\n                 }\n-                self.check_defined(ptr, (size + 1) as u64)?;\n-                M::check_locks(self, ptr, (size + 1) as u64, AccessKind::Read)?;\n+                self.check_defined(ptr, p1)?;\n+                M::check_locks(self, ptr, p1, AccessKind::Read)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             }\n             None => err!(UnterminatedCString(ptr)),\n         }\n     }\n \n-    pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_bytes(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         self.check_align(ptr, align)?;\n-        if size == 0 {\n+        if size.bytes() == 0 {\n             return Ok(&[]);\n         }\n         self.get_bytes(ptr.to_ptr()?, size, align)\n@@ -683,16 +686,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if src.is_empty() {\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, align)?;\n+        let bytes = self.get_bytes_mut(ptr.to_ptr()?, Size::from_bytes(src.len() as u64), align)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n+    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: Size) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         self.check_align(ptr, align)?;\n-        if count == 0 {\n+        if count.bytes() == 0 {\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, align)?;\n@@ -702,7 +705,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: u64) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n@@ -721,7 +724,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, bytes as u64))),\n+                Some(&alloc_id) => return Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, Size::from_bytes(bytes as u64)))),\n                 None => {},\n             }\n         }\n@@ -733,13 +736,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.read_primval(ptr, ptr_align, self.pointer_size())\n     }\n \n-    pub fn write_primval(&mut self, ptr: Pointer, ptr_align: Align, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n+    pub fn write_primval(&mut self, ptr: Pointer, ptr_align: Align, val: PrimVal, size: Size, signed: bool) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n \n         let bytes = match val {\n             PrimVal::Ptr(val) => {\n                 assert_eq!(size, self.pointer_size());\n-                val.offset as u128\n+                val.offset.bytes() as u128\n             }\n \n             PrimVal::Bytes(bytes) => bytes,\n@@ -782,16 +785,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.write_primval(ptr.into(), ptr_align, val, ptr_size, false)\n     }\n \n-    fn int_align(&self, size: u64) -> Align {\n+    fn int_align(&self, size: Size) -> Align {\n         // We assume pointer-sized integers have the same alignment as pointers.\n         // We also assume signed and unsigned integers of the same size have the same alignment.\n-        let ity = match size {\n+        let ity = match size.bytes() {\n             1 => layout::I8,\n             2 => layout::I16,\n             4 => layout::I32,\n             8 => layout::I64,\n             16 => layout::I128,\n-            _ => bug!(\"bad integer size: {}\", size),\n+            _ => bug!(\"bad integer size: {}\", size.bytes()),\n         };\n         ity.align(self)\n     }\n@@ -802,14 +805,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn relocations(\n         &self,\n         ptr: MemoryPointer,\n-        size: u64,\n-    ) -> EvalResult<'tcx, btree_map::Range<u64, AllocId>> {\n-        let start = ptr.offset.saturating_sub(self.pointer_size() - 1);\n+        size: Size,\n+    ) -> EvalResult<'tcx, btree_map::Range<Size, AllocId>> {\n+        let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n         let end = ptr.offset + size;\n-        Ok(self.get(ptr.alloc_id)?.relocations.range(start..end))\n+        Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n     }\n \n-    fn clear_relocations(&mut self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n+    fn clear_relocations(&mut self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n         // Find all relocations overlapping the given range.\n         let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n         if keys.is_empty() {\n@@ -841,9 +844,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n-        let overlapping_start = self.relocations(ptr, 0)?.count();\n-        let overlapping_end = self.relocations(ptr.offset(size, self)?, 0)?.count();\n+    fn check_relocation_edges(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n+        let overlapping_start = self.relocations(ptr, Size::from_bytes(0))?.count();\n+        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::from_bytes(0))?.count();\n         if overlapping_start + overlapping_end != 0 {\n             return err!(ReadPointerAsBytes);\n         }\n@@ -858,26 +861,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &mut self,\n         src: MemoryPointer,\n         dest: MemoryPointer,\n-        size: u64,\n+        size: Size,\n     ) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n-        assert_eq!(size as usize as u64, size);\n-        let mut v = Vec::with_capacity(size as usize);\n-        for i in 0..size {\n-            let defined = self.get(src.alloc_id)?.undef_mask.get(src.offset + i);\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let mut v = Vec::with_capacity(size.bytes() as usize);\n+        for i in 0..size.bytes() {\n+            let defined = self.get(src.alloc_id)?.undef_mask.get(src.offset + Size::from_bytes(i));\n             v.push(defined);\n         }\n         for (i, defined) in v.into_iter().enumerate() {\n             self.get_mut(dest.alloc_id)?.undef_mask.set(\n                 dest.offset +\n-                    i as u64,\n+                    Size::from_bytes(i as u64),\n                 defined,\n             );\n         }\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n+    fn check_defined(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(\n             ptr.offset,\n@@ -892,10 +895,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn mark_definedness(\n         &mut self,\n         ptr: Pointer,\n-        size: u64,\n+        size: Size,\n         new_state: bool,\n     ) -> EvalResult<'tcx> {\n-        if size == 0 {\n+        if size.bytes() == 0 {\n             return Ok(());\n         }\n         let ptr = ptr.to_ptr()?;"}, {"sha": "6ccbcf07370b0eb76f8c3a83e4b737fe57f8b653", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -1,6 +1,6 @@\n use rustc::mir;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, Size};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{GlobalId, Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n@@ -210,7 +210,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let alloc = Machine::init_static(self, cid)?;\n                 Place::Ptr {\n-                    ptr: MemoryPointer::new(alloc, 0).into(),\n+                    ptr: MemoryPointer::new(alloc, Size::from_bytes(0)).into(),\n                     align: layout.align,\n                     extra: PlaceExtra::None,\n                 }\n@@ -267,9 +267,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     base_layout.ty,\n                     base_ptr.to_value_with_vtable(tab),\n                 )?;\n-                offset.abi_align(align).bytes()\n+                offset.abi_align(align)\n             }\n-            _ => offset.bytes(),\n+            _ => offset,\n         };\n \n         let ptr = base_ptr.offset(offset, &self)?;\n@@ -325,14 +325,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let (base_ptr, align) = base.to_ptr_align();\n \n         let (elem_ty, len) = base.elem_ty_and_len(outer_ty, self.tcx.tcx);\n-        let elem_size = self.layout_of(elem_ty)?.size.bytes();\n+        let elem_size = self.layout_of(elem_ty)?.size;\n         assert!(\n             n < len,\n             \"Tried to access element {} of array/slice with length {}\",\n             n,\n             len\n         );\n-        let ptr = base_ptr.offset(n * elem_size, &*self)?;\n+        let ptr = base_ptr.offset(elem_size * n, &*self)?;\n         Ok(Place::Ptr {\n             ptr,\n             align,\n@@ -401,7 +401,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let (base_ptr, align) = base.to_ptr_align();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n-                let elem_size = self.layout_of(elem_ty)?.size.bytes();\n+                let elem_size = self.layout_of(elem_ty)?.size;\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -410,7 +410,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     u64::from(offset)\n                 };\n \n-                let ptr = base_ptr.offset(index * elem_size, &self)?;\n+                let ptr = base_ptr.offset(elem_size * index, &self)?;\n                 Ok(Place::Ptr { ptr, align, extra: PlaceExtra::None })\n             }\n \n@@ -420,9 +420,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let (base_ptr, align) = base.to_ptr_align();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n-                let elem_size = self.layout_of(elem_ty)?.size.bytes();\n+                let elem_size = self.layout_of(elem_ty)?.size;\n                 assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.offset(u64::from(from) * elem_size, &self)?;\n+                let ptr = base_ptr.offset(elem_size * u64::from(from), &self)?;\n                 // sublicing arrays produces arrays\n                 let extra = if self.type_is_sized(base_ty) {\n                     PlaceExtra::None"}, {"sha": "c5b823ca87b526cbf2968e2147317470d9e703dc", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                     Value::ByRef(ptr, align) => {\n                                         for (i, arg_local) in arg_locals.enumerate() {\n                                             let field = layout.field(&self, i)?;\n-                                            let offset = layout.fields.offset(i).bytes();\n+                                            let offset = layout.fields.offset(i);\n                                             let arg = Value::ByRef(ptr.offset(offset, &self)?,\n                                                                    align.min(field.align));\n                                             let dest ="}, {"sha": "2075400d04f5105cf752f01e9ee8143961b16c5a", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=7c25aa79c5aa7ea8dd2ebe3c99d483df08bd01ec", "patch": "@@ -221,7 +221,7 @@ pub enum Endian {\n }\n \n /// Size of a type in bytes.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Size {\n     raw: u64\n }"}]}