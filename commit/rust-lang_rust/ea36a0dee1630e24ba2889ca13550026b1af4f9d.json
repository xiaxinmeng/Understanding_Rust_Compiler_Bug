{"sha": "ea36a0dee1630e24ba2889ca13550026b1af4f9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMzZhMGRlZTE2MzBlMjRiYTI4ODljYTEzNTUwMDI2YjFhZjRmOWQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-27T04:18:01Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-27T04:48:12Z"}, "message": "libsyntax: add some more explicit copies", "tree": {"sha": "2f731e773566f899d82913d7e6ddf2b1547d018c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f731e773566f899d82913d7e6ddf2b1547d018c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea36a0dee1630e24ba2889ca13550026b1af4f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea36a0dee1630e24ba2889ca13550026b1af4f9d", "html_url": "https://github.com/rust-lang/rust/commit/ea36a0dee1630e24ba2889ca13550026b1af4f9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea36a0dee1630e24ba2889ca13550026b1af4f9d/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da7aedc2306a7ea2efee0864e8bdf6dbf53d73a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/da7aedc2306a7ea2efee0864e8bdf6dbf53d73a4", "html_url": "https://github.com/rust-lang/rust/commit/da7aedc2306a7ea2efee0864e8bdf6dbf53d73a4"}], "stats": {"total": 251, "additions": 160, "deletions": 91}, "files": [{"sha": "81d2aee46a6148f4cf0815419fc1993b70f46956", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -838,7 +838,7 @@ fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n     let self_str = ~\"self\";\n     let other_str = ~\"__other\";\n     let type_path = build::mk_raw_path(span, ~[type_ident]);\n-    let fields = struct_def.fields;\n+    let fields = copy struct_def.fields;\n \n     // Create comparison expression, comparing each of the fields\n     let mut match_body = None;"}, {"sha": "bb6d656d5cc12f9e940498a0dc2547529992199a", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -29,7 +29,11 @@ pub fn expand_trace_macros(cx: ext_ctxt, sp: span,\n         vec::from_slice(tt)\n     );\n     let rdr = tt_rdr as reader;\n-    let rust_parser = Parser(sess, cfg, rdr.dup());\n+    let rust_parser = Parser(\n+        sess,\n+        copy cfg,\n+        rdr.dup()\n+    );\n \n     if rust_parser.is_keyword(&~\"true\") {\n         cx.set_trace_macros(true);"}, {"sha": "419c051ea9791453f72fe713f06a48474469930c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -224,20 +224,25 @@ pub enum parse_result {\n     error(codemap::span, ~str)\n }\n \n-pub fn parse_or_else(sess: @mut ParseSess, cfg: ast::crate_cfg, rdr: reader,\n-                     ms: ~[matcher]) -> HashMap<ident, @named_match> {\n+pub fn parse_or_else(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    rdr: reader,\n+    ms: ~[matcher]\n+) -> HashMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n       failure(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str)),\n       error(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str))\n     }\n }\n \n-pub fn parse(sess: @mut ParseSess,\n-             cfg: ast::crate_cfg,\n-             rdr: reader,\n-             ms: ~[matcher])\n-          -> parse_result {\n+pub fn parse(\n+    sess: @mut ParseSess,\n+    cfg: ast::crate_cfg,\n+    rdr: reader,\n+    ms: ~[matcher]\n+) -> parse_result {\n     let mut cur_eis = ~[];\n     cur_eis.push(initial_matcher_pos(copy ms, None, rdr.peek().sp.lo));\n \n@@ -387,7 +392,7 @@ pub fn parse(sess: @mut ParseSess,\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let rust_parser = Parser(sess, cfg, rdr.dup());\n+                let rust_parser = Parser(sess, copy cfg, rdr.dup());\n \n                 let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {"}, {"sha": "99afd7958e99844c2c3e90d523b173d18147eb64", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -202,9 +202,9 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         match r.cur.readme[r.cur.idx] {\n-          tt_delim(tts) => {\n+          tt_delim(copy tts) => {\n             r.cur = @mut TtFrame {\n-                readme: @mut copy tts,\n+                readme: @mut tts,\n                 idx: 0u,\n                 dotdotdoted: false,\n                 sep: None,"}, {"sha": "d8c3ca06d76e52c5f4ead0c9d722fc7523e92c20", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 138, "deletions": 78, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -81,78 +81,116 @@ pub fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n \n // this appears to be the main entry point for rust parsing by\n // rustc and crate:\n-pub fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n-                         sess: @mut ParseSess) -> @ast::crate {\n-    let p = new_parser_from_file(sess, cfg, input);\n-    p.parse_crate_mod(cfg)\n+pub fn parse_crate_from_file(\n+    input: &Path,\n+    cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> @ast::crate {\n+    let p = new_parser_from_file(sess, /*bad*/ copy cfg, input);\n+    p.parse_crate_mod(/*bad*/ copy cfg)\n     // why is there no p.abort_if_errors here?\n }\n \n-pub fn parse_crate_from_source_str(name: ~str,\n-                                   source: @~str,\n-                                   cfg: ast::crate_cfg,\n-                                   sess: @mut ParseSess) -> @ast::crate {\n-    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n-                                       codemap::FssNone, source);\n-    let r = p.parse_crate_mod(cfg);\n+pub fn parse_crate_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> @ast::crate {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        /*bad*/ copy cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n+    let r = p.parse_crate_mod(/*bad*/ copy cfg);\n     p.abort_if_errors();\n-    return r;\n+    r\n }\n \n-pub fn parse_expr_from_source_str(name: ~str,\n-                                  source: @~str,\n-                                  cfg: ast::crate_cfg,\n-                                  sess: @mut ParseSess) -> @ast::expr {\n-    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n-                                       codemap::FssNone, source);\n+pub fn parse_expr_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> @ast::expr {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n     let r = p.parse_expr();\n     p.abort_if_errors();\n-    return r;\n+    r\n }\n \n-pub fn parse_item_from_source_str(name: ~str,\n-                                  source: @~str,\n-                                  cfg: ast::crate_cfg,\n-                                  +attrs: ~[ast::attribute],\n-                                  sess: @mut ParseSess)\n-                               -> Option<@ast::item> {\n-    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n-                                       codemap::FssNone, source);\n+pub fn parse_item_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    +attrs: ~[ast::attribute],\n+    sess: @mut ParseSess\n+) -> Option<@ast::item> {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n     let r = p.parse_item(attrs);\n     p.abort_if_errors();\n-    return r;\n+    r\n }\n \n-pub fn parse_stmt_from_source_str(name: ~str,\n-                                  source: @~str,\n-                                  cfg: ast::crate_cfg,\n-                                  +attrs: ~[ast::attribute],\n-                                  sess: @mut ParseSess) -> @ast::stmt {\n-    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n-                                       codemap::FssNone, source);\n+pub fn parse_stmt_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    +attrs: ~[ast::attribute],\n+    sess: @mut ParseSess\n+) -> @ast::stmt {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n     let r = p.parse_stmt(attrs);\n     p.abort_if_errors();\n-    return r;\n+    r\n }\n \n-pub fn parse_tts_from_source_str(name: ~str,\n-                                 source: @~str,\n-                                 cfg: ast::crate_cfg,\n-                                 sess: @mut ParseSess) -> ~[ast::token_tree] {\n-    let p = new_parser_from_source_str(sess, cfg, /*bad*/ copy name,\n-                                       codemap::FssNone, source);\n+pub fn parse_tts_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> ~[ast::token_tree] {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n     *p.quote_depth += 1u;\n     let r = p.parse_all_token_trees();\n     p.abort_if_errors();\n-    return r;\n+    r\n }\n \n-pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n-                            name: ~str, ss: codemap::FileSubstr,\n-                            source: @~str, cfg: ast::crate_cfg,\n-                            sess: @mut ParseSess)\n-    -> T\n-{\n+pub fn parse_from_source_str<T>(\n+    f: fn (Parser) -> T,\n+    name: ~str, ss: codemap::FileSubstr,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> T {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -176,40 +214,51 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n     return rv;\n }\n \n-pub fn new_parser_from_source_str(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                              +name: ~str, +ss: codemap::FileSubstr,\n-                              source: @~str) -> Parser {\n+pub fn new_parser_from_source_str(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    +name: ~str,\n+    +ss: codemap::FileSubstr,\n+    source: @~str\n+) -> Parser {\n     let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n-    let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n-                                        filemap,\n-                                        sess.interner);\n-    return Parser(sess, cfg, srdr as reader);\n+    let srdr = lexer::new_string_reader(\n+        copy sess.span_diagnostic,\n+        filemap,\n+        sess.interner\n+    );\n+    Parser(sess, cfg, srdr as reader)\n }\n \n // Read the entire source file, return a parser\n // that draws from that string\n-pub fn new_parser_result_from_file(sess: @mut ParseSess,\n-                            cfg: ast::crate_cfg,\n-                            path: &Path)\n-                         -> Result<Parser, ~str> {\n+pub fn new_parser_result_from_file(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    path: &Path\n+) -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n-      result::Ok(src) => {\n-\n-          let filemap = sess.cm.new_filemap(path.to_str(), @src);\n-          let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n-                                              filemap,\n-                                              sess.interner);\n-          Ok(Parser(sess, cfg, srdr as reader))\n+        Ok(src) => {\n+            let filemap = sess.cm.new_filemap(path.to_str(), @src);\n+            let srdr = lexer::new_string_reader(\n+                copy sess.span_diagnostic,\n+                filemap,\n+                sess.interner\n+            );\n+            Ok(Parser(sess, cfg, srdr as reader))\n \n-      }\n-      result::Err(e) => Err(e)\n+        }\n+        Err(e) => Err(e)\n     }\n }\n \n /// Create a new parser for an entire crate, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                              path: &Path) -> Parser {\n+pub fn new_parser_from_file(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    path: &Path\n+) -> Parser {\n     match new_parser_result_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n         Err(e) => {\n@@ -220,8 +269,12 @@ pub fn new_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n \n /// Create a new parser based on a span from an existing parser. Handles\n /// error messages correctly when the file does not exist.\n-pub fn new_sub_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                            path: &Path, sp: span) -> Parser {\n+pub fn new_sub_parser_from_file(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    path: &Path,\n+    sp: span\n+) -> Parser {\n     match new_parser_result_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n         Err(e) => {\n@@ -230,11 +283,18 @@ pub fn new_sub_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n     }\n }\n \n-pub fn new_parser_from_tts(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                           +tts: ~[ast::token_tree]) -> Parser {\n-    let trdr = lexer::new_tt_reader(copy sess.span_diagnostic, sess.interner,\n-                                    None, tts);\n-    return Parser(sess, cfg, trdr as reader)\n+pub fn new_parser_from_tts(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    +tts: ~[ast::token_tree]\n+) -> Parser {\n+    let trdr = lexer::new_tt_reader(\n+        copy sess.span_diagnostic,\n+        sess.interner,\n+        None,\n+        tts\n+    );\n+    Parser(sess, cfg, trdr as reader)\n }\n \n "}, {"sha": "dffa04ac1cab081cee246e78fc723288fe5fde76", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea36a0dee1630e24ba2889ca13550026b1af4f9d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ea36a0dee1630e24ba2889ca13550026b1af4f9d", "patch": "@@ -3492,7 +3492,7 @@ pub impl Parser {\n         };\n         let full_path = full_path.normalize();\n         let p0 =\n-            new_sub_parser_from_file(self.sess, self.cfg,\n+            new_sub_parser_from_file(self.sess, copy self.cfg,\n                                      &full_path, id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n         let mod_attrs = vec::append("}]}