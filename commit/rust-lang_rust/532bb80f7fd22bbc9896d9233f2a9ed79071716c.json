{"sha": "532bb80f7fd22bbc9896d9233f2a9ed79071716c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMmJiODBmN2ZkMjJiYmM5ODk2ZDkyMzNmMmE5ZWQ3OTA3MTcxNmM=", "commit": {"author": {"name": "Augie Fackler", "email": "augie@google.com", "date": "2021-09-07T18:49:03Z"}, "committer": {"name": "Augie Fackler", "email": "augie@google.com", "date": "2021-09-07T19:30:42Z"}, "message": "RustWrapper: avoid deleted unclear attribute methods\n\nThese were deleted in https://reviews.llvm.org/D108614, and in C++ I\ndefinitely see the argument for their removal. I didn't try and\npropagate the changes up into higher layers of rustc in this change\nbecause my initial goal was to get rustc working against LLVM HEAD\npromptly, but I'm happy to follow up with some refactoring to make the\nAPI on the Rust side match the LLVM API more directly (though the way\nthe enum works in Rust makes the API less scary IMO).\n\nr? @nagisa cc @nikic", "tree": {"sha": "bd8e157f2e8fcf94e327a0dbf5e0782fbb22600d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd8e157f2e8fcf94e327a0dbf5e0782fbb22600d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532bb80f7fd22bbc9896d9233f2a9ed79071716c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532bb80f7fd22bbc9896d9233f2a9ed79071716c", "html_url": "https://github.com/rust-lang/rust/commit/532bb80f7fd22bbc9896d9233f2a9ed79071716c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532bb80f7fd22bbc9896d9233f2a9ed79071716c/comments", "author": {"login": "durin42", "id": 20269, "node_id": "MDQ6VXNlcjIwMjY5", "avatar_url": "https://avatars.githubusercontent.com/u/20269?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durin42", "html_url": "https://github.com/durin42", "followers_url": "https://api.github.com/users/durin42/followers", "following_url": "https://api.github.com/users/durin42/following{/other_user}", "gists_url": "https://api.github.com/users/durin42/gists{/gist_id}", "starred_url": "https://api.github.com/users/durin42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durin42/subscriptions", "organizations_url": "https://api.github.com/users/durin42/orgs", "repos_url": "https://api.github.com/users/durin42/repos", "events_url": "https://api.github.com/users/durin42/events{/privacy}", "received_events_url": "https://api.github.com/users/durin42/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durin42", "id": 20269, "node_id": "MDQ6VXNlcjIwMjY5", "avatar_url": "https://avatars.githubusercontent.com/u/20269?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durin42", "html_url": "https://github.com/durin42", "followers_url": "https://api.github.com/users/durin42/followers", "following_url": "https://api.github.com/users/durin42/following{/other_user}", "gists_url": "https://api.github.com/users/durin42/gists{/gist_id}", "starred_url": "https://api.github.com/users/durin42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durin42/subscriptions", "organizations_url": "https://api.github.com/users/durin42/orgs", "repos_url": "https://api.github.com/users/durin42/repos", "events_url": "https://api.github.com/users/durin42/events{/privacy}", "received_events_url": "https://api.github.com/users/durin42/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "385f8e2078b00282a7a7ffcd58aad17b405f57bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/385f8e2078b00282a7a7ffcd58aad17b405f57bf", "html_url": "https://github.com/rust-lang/rust/commit/385f8e2078b00282a7a7ffcd58aad17b405f57bf"}], "stats": {"total": 88, "additions": 70, "deletions": 18}, "files": [{"sha": "b3143f14d29ccbdfba2ac73c247f74024b154e3d", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/532bb80f7fd22bbc9896d9233f2a9ed79071716c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/532bb80f7fd22bbc9896d9233f2a9ed79071716c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=532bb80f7fd22bbc9896d9233f2a9ed79071716c", "patch": "@@ -203,29 +203,67 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n   report_fatal_error(\"bad AttributeKind\");\n }\n \n+template<typename T> static inline void AddAttribute(T *t, unsigned Index, Attribute Attr) {\n+#if LLVM_VERSION_LT(14, 0)\n+  t->addAttribute(Index, Attr);\n+#else\n+  // TODO(durin42): we should probably surface the explicit functions to Rust\n+  // instead of this switch statement?\n+  switch (Index) {\n+    case AttributeList::ReturnIndex:\n+      t->addRetAttr(Attr);\n+      break;\n+    case AttributeList::FunctionIndex:\n+      t->addFnAttr(Attr);\n+      break;\n+    default:\n+      t->addParamAttr(Index-AttributeList::FirstArgIndex, Attr);\n+  }\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,\n                                              LLVMRustAttribute RustAttr) {\n   CallBase *Call = unwrap<CallBase>(Instr);\n   Attribute Attr = Attribute::get(Call->getContext(), fromRust(RustAttr));\n-  Call->addAttribute(Index, Attr);\n+  AddAttribute(Call, Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddCallSiteAttrString(LLVMValueRef Instr, unsigned Index,\n                                               const char *Name) {\n   CallBase *Call = unwrap<CallBase>(Instr);\n   Attribute Attr = Attribute::get(Call->getContext(), Name);\n-  Call->addAttribute(Index, Attr);\n+  AddAttribute(Call, Index, Attr);\n }\n \n+static inline void AddCallAttributes(CallBase *Call, unsigned Index, const AttrBuilder& B) {\n+  AttributeList Attrs = Call->getAttributes();\n+#if LLVM_VERSION_LT(14, 0)\n+  Attrs = Attrs.addAttributes(Call->getContext(), Index, B);\n+#else\n+  // TODO(durin42): we should probably surface the explicit functions to Rust\n+  // instead of this switch statement?\n+  switch (Index) {\n+    case AttributeList::ReturnIndex:\n+      Attrs = Attrs.addRetAttributes(Call->getContext(), B);\n+      break;\n+    case AttributeList::FunctionIndex:\n+      Attrs = Attrs.addFnAttributes(Call->getContext(), B);\n+      break;\n+    default:\n+      Attrs = Attrs.addParamAttributes(Call->getContext(), Index-AttributeList::FirstArgIndex, B);\n+  }\n+#endif\n+  Call->setAttributes(Attrs);\n+}\n \n extern \"C\" void LLVMRustAddAlignmentCallSiteAttr(LLVMValueRef Instr,\n                                                  unsigned Index,\n                                                  uint32_t Bytes) {\n   CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addAlignmentAttr(Bytes);\n-  Call->setAttributes(Call->getAttributes().addAttributes(\n-      Call->getContext(), Index, B));\n+  AddCallAttributes(Call, Index, B);\n }\n \n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n@@ -234,8 +272,7 @@ extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n   CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addDereferenceableAttr(Bytes);\n-  Call->setAttributes(Call->getAttributes().addAttributes(\n-      Call->getContext(), Index, B));\n+  AddCallAttributes(Call, Index, B);\n }\n \n extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n@@ -244,15 +281,14 @@ extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n   CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addDereferenceableOrNullAttr(Bytes);\n-  Call->setAttributes(Call->getAttributes().addAttributes(\n-      Call->getContext(), Index, B));\n+  AddCallAttributes(Call, Index, B);\n }\n \n extern \"C\" void LLVMRustAddByValCallSiteAttr(LLVMValueRef Instr, unsigned Index,\n                                              LLVMTypeRef Ty) {\n   CallBase *Call = unwrap<CallBase>(Instr);\n   Attribute Attr = Attribute::getWithByValType(Call->getContext(), unwrap(Ty));\n-  Call->addAttribute(Index, Attr);\n+  AddAttribute(Call, Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddStructRetCallSiteAttr(LLVMValueRef Instr, unsigned Index,\n@@ -263,44 +299,44 @@ extern \"C\" void LLVMRustAddStructRetCallSiteAttr(LLVMValueRef Instr, unsigned In\n #else\n   Attribute Attr = Attribute::get(Call->getContext(), Attribute::StructRet);\n #endif\n-  Call->addAttribute(Index, Attr);\n+  AddAttribute(Call, Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n                                              LLVMRustAttribute RustAttr) {\n   Function *A = unwrap<Function>(Fn);\n   Attribute Attr = Attribute::get(A->getContext(), fromRust(RustAttr));\n-  A->addAttribute(Index, Attr);\n+  AddAttribute(A, Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddAlignmentAttr(LLVMValueRef Fn,\n                                          unsigned Index,\n                                          uint32_t Bytes) {\n   Function *A = unwrap<Function>(Fn);\n-  A->addAttribute(Index, Attribute::getWithAlignment(\n+  AddAttribute(A, Index, Attribute::getWithAlignment(\n       A->getContext(), llvm::Align(Bytes)));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned Index,\n                                                uint64_t Bytes) {\n   Function *A = unwrap<Function>(Fn);\n-  A->addAttribute(Index, Attribute::getWithDereferenceableBytes(A->getContext(),\n+  AddAttribute(A, Index, Attribute::getWithDereferenceableBytes(A->getContext(),\n                                                                 Bytes));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableOrNullAttr(LLVMValueRef Fn,\n                                                      unsigned Index,\n                                                      uint64_t Bytes) {\n   Function *A = unwrap<Function>(Fn);\n-  A->addAttribute(Index, Attribute::getWithDereferenceableOrNullBytes(\n+  AddAttribute(A, Index, Attribute::getWithDereferenceableOrNullBytes(\n       A->getContext(), Bytes));\n }\n \n extern \"C\" void LLVMRustAddByValAttr(LLVMValueRef Fn, unsigned Index,\n                                      LLVMTypeRef Ty) {\n   Function *F = unwrap<Function>(Fn);\n   Attribute Attr = Attribute::getWithByValType(F->getContext(), unwrap(Ty));\n-  F->addAttribute(Index, Attr);\n+  AddAttribute(F, Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddStructRetAttr(LLVMValueRef Fn, unsigned Index,\n@@ -311,15 +347,15 @@ extern \"C\" void LLVMRustAddStructRetAttr(LLVMValueRef Fn, unsigned Index,\n #else\n   Attribute Attr = Attribute::get(F->getContext(), Attribute::StructRet);\n #endif\n-  F->addAttribute(Index, Attr);\n+  AddAttribute(F, Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n                                                    unsigned Index,\n                                                    const char *Name,\n                                                    const char *Value) {\n   Function *F = unwrap<Function>(Fn);\n-  F->addAttribute(Index, Attribute::get(\n+  AddAttribute(F, Index, Attribute::get(\n       F->getContext(), StringRef(Name), StringRef(Value)));\n }\n \n@@ -330,7 +366,23 @@ extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n   Attribute Attr = Attribute::get(F->getContext(), fromRust(RustAttr));\n   AttrBuilder B(Attr);\n   auto PAL = F->getAttributes();\n-  auto PALNew = PAL.removeAttributes(F->getContext(), Index, B);\n+  AttributeList PALNew;\n+#if LLVM_VERSION_LT(14, 0)\n+  PALNew = PAL.removeAttributes(F->getContext(), Index, B);\n+#else\n+  // TODO(durin42): we should probably surface the explicit functions to Rust\n+  // instead of this switch statement?\n+  switch (Index) {\n+    case AttributeList::ReturnIndex:\n+      PALNew = PAL.removeRetAttributes(F->getContext(), B);\n+      break;\n+    case AttributeList::FunctionIndex:\n+      PALNew = PAL.removeFnAttributes(F->getContext(), B);\n+      break;\n+    default:\n+      PALNew = PAL.removeParamAttributes(F->getContext(), Index-AttributeList::FirstArgIndex, B);\n+  }\n+#endif\n   F->setAttributes(PALNew);\n }\n "}]}