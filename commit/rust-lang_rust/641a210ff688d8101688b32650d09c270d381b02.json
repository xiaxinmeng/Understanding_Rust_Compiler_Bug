{"sha": "641a210ff688d8101688b32650d09c270d381b02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MWEyMTBmZjY4OGQ4MTAxNjg4YjMyNjUwZDA5YzI3MGQzODFiMDI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-07T16:08:38Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-26T09:29:35Z"}, "message": "Implement most 128bit binops", "tree": {"sha": "9977bfab9ba403a9224c0c923d9db1179477707f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9977bfab9ba403a9224c0c923d9db1179477707f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/641a210ff688d8101688b32650d09c270d381b02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/641a210ff688d8101688b32650d09c270d381b02", "html_url": "https://github.com/rust-lang/rust/commit/641a210ff688d8101688b32650d09c270d381b02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/641a210ff688d8101688b32650d09c270d381b02/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3080c73f50a286a7a6199bf88d7bad7570c2e646", "url": "https://api.github.com/repos/rust-lang/rust/commits/3080c73f50a286a7a6199bf88d7bad7570c2e646", "html_url": "https://github.com/rust-lang/rust/commit/3080c73f50a286a7a6199bf88d7bad7570c2e646"}], "stats": {"total": 281, "additions": 178, "deletions": 103}, "files": [{"sha": "c0ec0bb5b73fffadedbe5a009ab8d97f5e100b23", "filename": "example/std_example.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/641a210ff688d8101688b32650d09c270d381b02/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641a210ff688d8101688b32650d09c270d381b02/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=641a210ff688d8101688b32650d09c270d381b02", "patch": "@@ -3,23 +3,5 @@\n use std::io::Write;\n \n fn main() {\n-    assert_eq!((1u128 + 2) as u16, 3);\n-}\n-\n-#[derive(PartialEq)]\n-enum LoopState {\n-    Continue(()),\n-    Break(())\n-}\n-\n-pub enum Instruction {\n-    Increment,\n-    Loop,\n-}\n-\n-fn map(a: Option<(u8, Box<Instruction>)>) -> Option<Box<Instruction>> {\n-    match a {\n-        None => None,\n-        Some((_, instr)) => Some(instr),\n-    }\n+    assert_eq!(1u128 + 2, 3);\n }"}, {"sha": "c5dbe6dffa98130a0274a128f83420a931c66d5e", "filename": "src/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641a210ff688d8101688b32650d09c270d381b02/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641a210ff688d8101688b32650d09c270d381b02/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=641a210ff688d8101688b32650d09c270d381b02", "patch": "@@ -846,7 +846,7 @@ pub fn codegen_drop<'a, 'tcx: 'a>(\n                 );\n                 drop_place.write_place_ref(fx, arg_place);\n                 let arg_value = arg_place.to_cvalue(fx);\n-                crate::abi::codegen_call_inner(\n+                codegen_call_inner(\n                     fx,\n                     None,\n                     drop_fn_ty,"}, {"sha": "8821a629519e98a37bfbd6fccf491e138754f31b", "filename": "src/base.rs", "status": "modified", "additions": 68, "deletions": 83, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/641a210ff688d8101688b32650d09c270d381b02/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641a210ff688d8101688b32650d09c270d381b02/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=641a210ff688d8101688b32650d09c270d381b02", "patch": "@@ -831,18 +831,8 @@ pub fn trans_int_binop<'a, 'tcx: 'a>(\n         );\n     }\n \n-    if lhs.layout().ty == fx.tcx.types.u128 || lhs.layout().ty == fx.tcx.types.i128 {\n-        if out_ty == fx.tcx.types.bool {\n-            let layout = fx.layout_of(fx.tcx.types.bool);\n-            let val = fx.bcx.ins().iconst(types::I8, 0);\n-            return CValue::by_val(val, layout);\n-        } else {\n-            let layout = fx.layout_of(out_ty);\n-            let a = fx.bcx.ins().iconst(types::I64, 42);\n-            let b = fx.bcx.ins().iconst(types::I64, 0);\n-            let val = fx.bcx.ins().iconcat(a, b);\n-            return CValue::by_val(val, layout);\n-        }\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, signed, lhs, rhs, out_ty) {\n+        return res;\n     }\n \n     binop_match! {\n@@ -894,79 +884,74 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n \n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n-    let (res, has_overflow) = if in_lhs.layout().ty == fx.tcx.types.u128 || in_lhs.layout().ty == fx.tcx.types.i128 {\n-        match (bin_op, signed) {\n-            _ => {\n-                let a = fx.bcx.ins().iconst(types::I64, 42);\n-                let b = fx.bcx.ins().iconst(types::I64, 0);\n-                (fx.bcx.ins().iconcat(a, b), fx.bcx.ins().bconst(types::B1, false))\n-            }\n+\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, signed, in_lhs, in_rhs, out_ty) {\n+        return res;\n+    }\n+\n+    let (res, has_overflow) = match bin_op {\n+        BinOp::Add => {\n+            /*let (val, c_out) = fx.bcx.ins().iadd_cout(lhs, rhs);\n+            (val, c_out)*/\n+            // FIXME(CraneStation/cranelift#849) legalize iadd_cout for i8 and i16\n+            let val = fx.bcx.ins().iadd(lhs, rhs);\n+            let has_overflow = if !signed {\n+                fx.bcx.ins().icmp(IntCC::UnsignedLessThan, val, lhs)\n+            } else {\n+                let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n+                let slt = fx.bcx.ins().icmp(IntCC::SignedLessThan, val, lhs);\n+                fx.bcx.ins().bxor(rhs_is_negative, slt)\n+            };\n+            (val, has_overflow)\n         }\n-    } else {\n-        match bin_op {\n-            BinOp::Add => {\n-                /*let (val, c_out) = fx.bcx.ins().iadd_cout(lhs, rhs);\n-                (val, c_out)*/\n-                // FIXME(CraneStation/cranelift#849) legalize iadd_cout for i8 and i16\n-                let val = fx.bcx.ins().iadd(lhs, rhs);\n-                let has_overflow = if !signed {\n-                    fx.bcx.ins().icmp(IntCC::UnsignedLessThan, val, lhs)\n-                } else {\n-                    let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n-                    let slt = fx.bcx.ins().icmp(IntCC::SignedLessThan, val, lhs);\n-                    fx.bcx.ins().bxor(rhs_is_negative, slt)\n-                };\n-                (val, has_overflow)\n-            }\n-            BinOp::Sub => {\n-                /*let (val, b_out) = fx.bcx.ins().isub_bout(lhs, rhs);\n-                (val, b_out)*/\n-                // FIXME(CraneStation/cranelift#849) legalize isub_bout for i8 and i16\n-                let val = fx.bcx.ins().isub(lhs, rhs);\n-                let has_overflow = if !signed {\n-                    fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, val, lhs)\n-                } else {\n-                    let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n-                    let sgt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, val, lhs);\n-                    fx.bcx.ins().bxor(rhs_is_negative, sgt)\n-                };\n-                (val, has_overflow)\n-            }\n-            BinOp::Mul => {\n-                let val = fx.bcx.ins().imul(lhs, rhs);\n-                /*let val_hi = if !signed {\n-                    fx.bcx.ins().umulhi(lhs, rhs)\n-                } else {\n-                    fx.bcx.ins().smulhi(lhs, rhs)\n-                };\n-                let has_overflow = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);*/\n-                // TODO: check for overflow\n-                let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n-                (val, has_overflow)\n-            }\n-            BinOp::Shl => {\n-                let val = fx.bcx.ins().ishl(lhs, rhs);\n-                // TODO: check for overflow\n-                let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n-                (val, has_overflow)\n-            }\n-            BinOp::Shr => {\n-                let val = if !signed {\n-                    fx.bcx.ins().ushr(lhs, rhs)\n-                } else {\n-                    fx.bcx.ins().sshr(lhs, rhs)\n-                };\n-                // TODO: check for overflow\n-                let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n-                (val, has_overflow)\n-            }\n-            _ => bug!(\n-                \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n-                bin_op,\n-                in_lhs,\n-                in_rhs\n-            ),\n+        BinOp::Sub => {\n+            /*let (val, b_out) = fx.bcx.ins().isub_bout(lhs, rhs);\n+            (val, b_out)*/\n+            // FIXME(CraneStation/cranelift#849) legalize isub_bout for i8 and i16\n+            let val = fx.bcx.ins().isub(lhs, rhs);\n+            let has_overflow = if !signed {\n+                fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, val, lhs)\n+            } else {\n+                let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n+                let sgt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, val, lhs);\n+                fx.bcx.ins().bxor(rhs_is_negative, sgt)\n+            };\n+            (val, has_overflow)\n+        }\n+        BinOp::Mul => {\n+            let val = fx.bcx.ins().imul(lhs, rhs);\n+            /*let val_hi = if !signed {\n+                fx.bcx.ins().umulhi(lhs, rhs)\n+            } else {\n+                fx.bcx.ins().smulhi(lhs, rhs)\n+            };\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);*/\n+            // TODO: check for overflow\n+            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n+            (val, has_overflow)\n+        }\n+        BinOp::Shl => {\n+            let val = fx.bcx.ins().ishl(lhs, rhs);\n+            // TODO: check for overflow\n+            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n+            (val, has_overflow)\n+        }\n+        BinOp::Shr => {\n+            let val = if !signed {\n+                fx.bcx.ins().ushr(lhs, rhs)\n+            } else {\n+                fx.bcx.ins().sshr(lhs, rhs)\n+            };\n+            // TODO: check for overflow\n+            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n+            (val, has_overflow)\n         }\n+        _ => bug!(\n+            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n+            bin_op,\n+            in_lhs,\n+            in_rhs\n+        ),\n     };\n \n     let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);"}, {"sha": "ded6b597f26a42ce76ba05078b90d9344707ff8b", "filename": "src/codegen_i128.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/641a210ff688d8101688b32650d09c270d381b02/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641a210ff688d8101688b32650d09c270d381b02/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=641a210ff688d8101688b32650d09c270d381b02", "patch": "@@ -0,0 +1,107 @@\n+//! Replaces 128-bit operators with lang item calls\n+\n+use crate::prelude::*;\n+\n+pub fn maybe_codegen<'a, 'tcx>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    checked: bool,\n+    is_signed: bool,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    out_ty: Ty<'tcx>,\n+) -> Option<CValue<'tcx>> {\n+    if lhs.layout().ty != fx.tcx.types.u128 && lhs.layout().ty != fx.tcx.types.i128 {\n+        return None;\n+    }\n+\n+    let lhs_val = lhs.load_scalar(fx);\n+    let rhs_val = rhs.load_scalar(fx);\n+\n+    match bin_op {\n+        BinOp::Add | BinOp::Sub | BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => return None,\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n+        BinOp::Mul => {\n+            let res = if checked {\n+                if is_signed {\n+                    let oflow_place = CPlace::new_stack_slot(fx, fx.tcx.types.i32);\n+                    let oflow_addr = oflow_place.to_addr(fx);\n+                    let oflow_addr = CValue::by_val(oflow_addr, fx.layout_of(fx.tcx.mk_mut_ptr(fx.tcx.types.i32)));\n+                    let val = fx.easy_call(\"__muloti4\", &[lhs, rhs, oflow_addr], fx.tcx.types.i128);\n+                    let val = val.load_scalar(fx);\n+                    let oflow = oflow_place.to_cvalue(fx).load_scalar(fx);\n+                    let oflow = fx.bcx.ins().icmp_imm(IntCC::NotEqual, oflow, 0);\n+                    let oflow = fx.bcx.ins().bint(types::I8, oflow);\n+                    CValue::by_val_pair(val, oflow, fx.layout_of(out_ty))\n+                } else {\n+                    // FIXME implement it\n+                let out_layout = fx.layout_of(out_ty);\n+                    return Some(crate::trap::trap_unreachable_ret_value(fx, out_layout, format!(\"unimplemented 128bit checked binop unsigned mul\")));\n+                }\n+            } else {\n+                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n+                fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n+            };\n+            return Some(res);\n+        }\n+        BinOp::Div => {\n+            let res = if checked {\n+                // FIXME implement it\n+                let out_layout = fx.layout_of(out_ty);\n+                return Some(crate::trap::trap_unreachable_ret_value(fx, out_layout, format!(\"unimplemented 128bit checked binop div\")));\n+            } else {\n+                if is_signed {\n+                    fx.easy_call(\"__divti3\", &[lhs, rhs], fx.tcx.types.i128)\n+                } else {\n+                    fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.tcx.types.u128)\n+                }\n+            };\n+            return Some(res);\n+        }\n+        BinOp::Rem => {\n+            let res = if checked {\n+                // FIXME implement it\n+                let out_layout = fx.layout_of(out_ty);\n+                return Some(crate::trap::trap_unreachable_ret_value(fx, out_layout, format!(\"unimplemented 128bit checked binop rem\")));\n+            } else {\n+                if is_signed {\n+                    fx.easy_call(\"__modti3\", &[lhs, rhs], fx.tcx.types.i128)\n+                } else {\n+                    fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.tcx.types.u128)\n+                }\n+            };\n+            return Some(res);\n+        }\n+        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n+            assert!(!checked);\n+            let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n+            let (rhs_lsb, rhs_msb) = fx.bcx.ins().isplit(rhs_val);\n+            let res = match (bin_op, is_signed) {\n+                (BinOp::Eq, _) => {\n+                    let lsb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_lsb, rhs_lsb);\n+                    let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n+                    fx.bcx.ins().band(lsb_eq, msb_eq)\n+                }\n+                (BinOp::Ne, _) => {\n+                    let lsb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_lsb, rhs_lsb);\n+                    let msb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_msb, rhs_msb);\n+                    fx.bcx.ins().bor(lsb_ne, msb_ne)\n+                }\n+                _ => {\n+                    // FIXME implement it\n+                    let out_layout = fx.layout_of(out_ty);\n+                    return Some(crate::trap::trap_unreachable_ret_value(fx, out_layout, format!(\"unimplemented 128bit binop {:?}\", bin_op)));\n+                },\n+            };\n+\n+            let res = fx.bcx.ins().bint(types::I8, res);\n+            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.bool));\n+            return Some(res);\n+        }\n+        BinOp::Shl | BinOp::Shr => {\n+            // FIXME implement it\n+            let out_layout = fx.layout_of(out_ty);\n+            return Some(crate::trap::trap_unreachable_ret_value(fx, out_layout, format!(\"unimplemented 128bit binop {:?}\", bin_op)));\n+        }\n+    }\n+}"}, {"sha": "9bd985e3dc9f4219bd4de0fdd3f3860d3a067be8", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/641a210ff688d8101688b32650d09c270d381b02/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641a210ff688d8101688b32650d09c270d381b02/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=641a210ff688d8101688b32650d09c270d381b02", "patch": "@@ -34,6 +34,7 @@ mod allocator;\n mod analyze;\n mod archive;\n mod base;\n+mod codegen_i128;\n mod common;\n mod constant;\n mod debuginfo;"}]}