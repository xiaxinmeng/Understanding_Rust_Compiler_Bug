{"sha": "d0787284da6e25a018f2f94fcd3779d33d6150fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNzg3Mjg0ZGE2ZTI1YTAxOGYyZjk0ZmNkMzc3OWQzM2Q2MTUwZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-04T00:26:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-04T00:26:00Z"}, "message": "Auto merge of #54447 - KiChjang:issue-54331, r=nikomatsakis\n\nLower type ascriptions to HAIR and MIR\n\nFixes #54331.\n\nr? @nikomatsakis", "tree": {"sha": "016ba2eb4a57c74afa52a30593746117d0ca5390", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/016ba2eb4a57c74afa52a30593746117d0ca5390"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0787284da6e25a018f2f94fcd3779d33d6150fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0787284da6e25a018f2f94fcd3779d33d6150fc", "html_url": "https://github.com/rust-lang/rust/commit/d0787284da6e25a018f2f94fcd3779d33d6150fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0787284da6e25a018f2f94fcd3779d33d6150fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bf883b5e76f3a59770b891cb8b1b0576dfe359e", "html_url": "https://github.com/rust-lang/rust/commit/4bf883b5e76f3a59770b891cb8b1b0576dfe359e"}, {"sha": "8380b25d13eeeb387efd6442c4e3638198b06412", "url": "https://api.github.com/repos/rust-lang/rust/commits/8380b25d13eeeb387efd6442c4e3638198b06412", "html_url": "https://github.com/rust-lang/rust/commit/8380b25d13eeeb387efd6442c4e3638198b06412"}], "stats": {"total": 240, "additions": 176, "deletions": 64}, "files": [{"sha": "e2a9fd078a522acfbe0af29b5667c2971e236b37", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -1358,6 +1358,59 @@ impl Expr {\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n         }\n     }\n+\n+    pub fn is_place_expr(&self) -> bool {\n+         match self.node {\n+            ExprKind::Path(QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            ExprKind::Type(ref e, _) => {\n+                e.is_place_expr()\n+            }\n+\n+            ExprKind::Unary(UnDeref, _) |\n+            ExprKind::Field(..) |\n+            ExprKind::Index(..) => {\n+                true\n+            }\n+\n+            // Partially qualified paths in expressions can only legally\n+            // refer to associated items which are always rvalues.\n+            ExprKind::Path(QPath::TypeRelative(..)) |\n+\n+            ExprKind::Call(..) |\n+            ExprKind::MethodCall(..) |\n+            ExprKind::Struct(..) |\n+            ExprKind::Tup(..) |\n+            ExprKind::If(..) |\n+            ExprKind::Match(..) |\n+            ExprKind::Closure(..) |\n+            ExprKind::Block(..) |\n+            ExprKind::Repeat(..) |\n+            ExprKind::Array(..) |\n+            ExprKind::Break(..) |\n+            ExprKind::Continue(..) |\n+            ExprKind::Ret(..) |\n+            ExprKind::While(..) |\n+            ExprKind::Loop(..) |\n+            ExprKind::Assign(..) |\n+            ExprKind::InlineAsm(..) |\n+            ExprKind::AssignOp(..) |\n+            ExprKind::Lit(_) |\n+            ExprKind::Unary(..) |\n+            ExprKind::Box(..) |\n+            ExprKind::AddrOf(..) |\n+            ExprKind::Binary(..) |\n+            ExprKind::Yield(..) |\n+            ExprKind::Cast(..) => {\n+                false\n+            }\n+        }\n+    }\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "29c3fb6933967f913cab065de8c1c19769930bb1", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -16,6 +16,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use hair::*;\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::*;\n+use rustc::ty::Variance;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -136,6 +137,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ty: expr.ty,\n             }))),\n \n+            ExprKind::PlaceTypeAscription { source, user_ty } => {\n+                let place = unpack!(block = this.as_place(block, source));\n+                this.cfg.push(\n+                    block,\n+                    Statement {\n+                        source_info,\n+                        kind: StatementKind::AscribeUserType(\n+                            place.clone(),\n+                            Variance::Invariant,\n+                            user_ty,\n+                        ),\n+                    },\n+                );\n+                block.and(place)\n+            }\n+            ExprKind::ValueTypeAscription { source, user_ty } => {\n+                let source = this.hir.mirror(source);\n+                let temp = unpack!(\n+                    block = this.as_temp(block, source.temp_lifetime, source, mutability)\n+                );\n+                this.cfg.push(\n+                    block,\n+                    Statement {\n+                        source_info,\n+                        kind: StatementKind::AscribeUserType(\n+                            Place::Local(temp.clone()),\n+                            Variance::Invariant,\n+                            user_ty,\n+                        ),\n+                    },\n+                );\n+                block.and(Place::Local(temp))\n+            }\n+\n             ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }\n             | ExprKind::Adt { .. }"}, {"sha": "8fee74390cc6b26fcd1668e117d346dc0a75c9e2", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -386,7 +386,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::InlineAsm { .. }\n-            | ExprKind::StaticRef { .. } => {\n+            | ExprKind::StaticRef { .. }\n+            | ExprKind::PlaceTypeAscription { .. }\n+            | ExprKind::ValueTypeAscription { .. } => {\n                 // these do not have corresponding `Rvalue` variants,\n                 // so make an operand and then return that\n                 debug_assert!(match Category::of(&expr.kind) {"}, {"sha": "05a9079cdb1efcdf06be4518f214d23ac3d69427", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -50,7 +50,9 @@ impl Category {\n             | ExprKind::Index { .. }\n             | ExprKind::SelfRef\n             | ExprKind::VarRef { .. }\n-            | ExprKind::StaticRef { .. } => Some(Category::Place),\n+            | ExprKind::StaticRef { .. }\n+            | ExprKind::PlaceTypeAscription { .. }\n+            | ExprKind::ValueTypeAscription { .. } => Some(Category::Place),\n \n             ExprKind::LogicalOp { .. }\n             | ExprKind::If { .. }"}, {"sha": "9ea3805fdc65210dbae7a0f87ede997f4afe9992", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -345,7 +345,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             // Avoid creating a temporary\n-            ExprKind::VarRef { .. } | ExprKind::SelfRef | ExprKind::StaticRef { .. } => {\n+            ExprKind::VarRef { .. } |\n+            ExprKind::SelfRef |\n+            ExprKind::StaticRef { .. } |\n+            ExprKind::PlaceTypeAscription { .. } |\n+            ExprKind::ValueTypeAscription { .. } => {\n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n \n                 let place = unpack!(block = this.as_place(block, expr));\n@@ -393,7 +397,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             | ExprKind::Literal { .. }\n             | ExprKind::Yield { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n+                    // should be handled above\n                     Category::Rvalue(RvalueFunc::Into) => false,\n+\n+                    // must be handled above or else we get an\n+                    // infinite loop in the builder; see\n+                    // e.g. `ExprKind::VarRef` above\n+                    Category::Place => false,\n+\n                     _ => true,\n                 });\n "}, {"sha": "f94f1a1a8c8fededb17db6ab4b8ff33adca4c540", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -718,7 +718,23 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ExprKind::Cast { source }\n             }\n         }\n-        hir::ExprKind::Type(ref source, _) => return source.make_mirror(cx),\n+        hir::ExprKind::Type(ref source, ref ty) => {\n+            let user_provided_tys = cx.tables.user_provided_tys();\n+            let user_ty = *user_provided_tys\n+                .get(ty.hir_id)\n+                .expect(&format!(\"{:?} not found in user_provided_tys, source: {:?}\", ty, source));\n+            if source.is_place_expr() {\n+                ExprKind::PlaceTypeAscription {\n+                    source: source.to_ref(),\n+                    user_ty,\n+                }\n+            } else {\n+                ExprKind::ValueTypeAscription {\n+                    source: source.to_ref(),\n+                    user_ty,\n+                }\n+            }\n+        }\n         hir::ExprKind::Box(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),"}, {"sha": "9258845ad06a74535c9a7167e1277512f224248d", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -268,6 +268,16 @@ pub enum ExprKind<'tcx> {\n         fields: Vec<FieldExprRef<'tcx>>,\n         base: Option<FruInfo<'tcx>>\n     },\n+    PlaceTypeAscription {\n+        source: ExprRef<'tcx>,\n+        /// Type that the user gave to this expression\n+        user_ty: CanonicalTy<'tcx>,\n+    },\n+    ValueTypeAscription {\n+        source: ExprRef<'tcx>,\n+        /// Type that the user gave to this expression\n+        user_ty: CanonicalTy<'tcx>,\n+    },\n     Closure {\n         closure_id: DefId,\n         substs: UpvarSubsts<'tcx>,"}, {"sha": "529f1e6161be987dd9a429d0c9d173f8066b9a5b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 59, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -2469,59 +2469,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn is_place_expr(&self, expr: &hir::Expr) -> bool {\n-         match expr.node {\n-            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-                match path.def {\n-                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n-                    _ => false,\n-                }\n-            }\n-\n-            hir::ExprKind::Type(ref e, _) => {\n-                self.is_place_expr(e)\n-            }\n-\n-            hir::ExprKind::Unary(hir::UnDeref, _) |\n-            hir::ExprKind::Field(..) |\n-            hir::ExprKind::Index(..) => {\n-                true\n-            }\n-\n-            // Partially qualified paths in expressions can only legally\n-            // refer to associated items which are always rvalues.\n-            hir::ExprKind::Path(hir::QPath::TypeRelative(..)) |\n-\n-            hir::ExprKind::Call(..) |\n-            hir::ExprKind::MethodCall(..) |\n-            hir::ExprKind::Struct(..) |\n-            hir::ExprKind::Tup(..) |\n-            hir::ExprKind::If(..) |\n-            hir::ExprKind::Match(..) |\n-            hir::ExprKind::Closure(..) |\n-            hir::ExprKind::Block(..) |\n-            hir::ExprKind::Repeat(..) |\n-            hir::ExprKind::Array(..) |\n-            hir::ExprKind::Break(..) |\n-            hir::ExprKind::Continue(..) |\n-            hir::ExprKind::Ret(..) |\n-            hir::ExprKind::While(..) |\n-            hir::ExprKind::Loop(..) |\n-            hir::ExprKind::Assign(..) |\n-            hir::ExprKind::InlineAsm(..) |\n-            hir::ExprKind::AssignOp(..) |\n-            hir::ExprKind::Lit(_) |\n-            hir::ExprKind::Unary(..) |\n-            hir::ExprKind::Box(..) |\n-            hir::ExprKind::AddrOf(..) |\n-            hir::ExprKind::Binary(..) |\n-            hir::ExprKind::Yield(..) |\n-            hir::ExprKind::Cast(..) => {\n-                false\n-            }\n-        }\n-    }\n-\n     /// For the overloaded place expressions (`*x`, `x[3]`), the trait\n     /// returns a type of `&T`, but the actual type we assign to the\n     /// *expression* is `T`. So this function just peels off the return\n@@ -3799,10 +3746,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n-    fn check_expr_kind(&self,\n-                       expr: &'gcx hir::Expr,\n-                       expected: Expectation<'tcx>,\n-                       needs: Needs) -> Ty<'tcx> {\n+    fn check_expr_kind(\n+        &self,\n+        expr: &'gcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n@@ -3899,7 +3848,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                            if self.is_place_expr(&oprnd) {\n+                            if oprnd.is_place_expr() {\n                                 // Places may legitimately have unsized types.\n                                 // For example, dereferences of a fat pointer and\n                                 // the last field of a struct can be unsized.\n@@ -4075,7 +4024,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => {\n                         // Only check this if not in an `if` condition, as the\n                         // mistyped comparison help is more appropriate.\n-                        if !self.is_place_expr(&lhs) {\n+                        if !lhs.is_place_expr() {\n                             struct_span_err!(self.tcx.sess, expr.span, E0070,\n                                                 \"invalid left-hand side expression\")\n                                 .span_label(expr.span, \"left-hand of expression not valid\")\n@@ -4203,6 +4152,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Type(ref e, ref t) => {\n                 let ty = self.to_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n+                let c_ty = self.infcx.canonicalize_response(&ty);\n+                self.tables.borrow_mut().user_provided_tys_mut().insert(t.hir_id, c_ty);\n                 ty\n             }\n             hir::ExprKind::Array(ref args) => {"}, {"sha": "54f4406b4afc4ed175b4991d1c9b9a55e81be490", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return_ty\n         };\n \n-        if !self.is_place_expr(lhs_expr) {\n+        if !lhs_expr.is_place_expr() {\n             struct_span_err!(\n                 self.tcx.sess, lhs_expr.span,\n                 E0067, \"invalid left-hand side expression\")"}, {"sha": "2785f71ebcf6ba9779e7d0d8232f68b563ad24ee", "filename": "src/test/ui/nll/user-annotations/type_ascription_static_lifetime.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ftype_ascription_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ftype_ascription_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ftype_ascription_static_lifetime.rs?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(warnings)]\n+#![feature(nll)]\n+#![feature(type_ascription)]\n+\n+fn main() {\n+    let x = 22_u32;\n+    let y: &u32 = &x: &'static u32; //~ ERROR E0597\n+}"}, {"sha": "2303ed64db94da0203981e609ec2bd838941e486", "filename": "src/test/ui/nll/user-annotations/type_ascription_static_lifetime.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ftype_ascription_static_lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0787284da6e25a018f2f94fcd3779d33d6150fc/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ftype_ascription_static_lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ftype_ascription_static_lifetime.stderr?ref=d0787284da6e25a018f2f94fcd3779d33d6150fc", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/type_ascription_static_lifetime.rs:18:19\n+   |\n+LL |     let y: &u32 = &x: &'static u32; //~ ERROR E0597\n+   |                   ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}]}