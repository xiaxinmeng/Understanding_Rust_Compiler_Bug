{"sha": "3019af6c01fb40def845ac0b7b6f321d09f84e73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMTlhZjZjMDFmYjQwZGVmODQ1YWMwYjdiNmYzMjFkMDlmODRlNzM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-08-02T16:54:40Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-08-19T16:34:10Z"}, "message": "serialize: add json::{Integer,Floating} to parse large integers properly\n\n[breaking-change]", "tree": {"sha": "1d1d3a52678ae0803b80988b86905887c6ecd8f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d1d3a52678ae0803b80988b86905887c6ecd8f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3019af6c01fb40def845ac0b7b6f321d09f84e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3019af6c01fb40def845ac0b7b6f321d09f84e73", "html_url": "https://github.com/rust-lang/rust/commit/3019af6c01fb40def845ac0b7b6f321d09f84e73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3019af6c01fb40def845ac0b7b6f321d09f84e73/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8835104797335818bc1d5b0df61ce9f5907cd16", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8835104797335818bc1d5b0df61ce9f5907cd16", "html_url": "https://github.com/rust-lang/rust/commit/c8835104797335818bc1d5b0df61ce9f5907cd16"}], "stats": {"total": 311, "additions": 202, "deletions": 109}, "files": [{"sha": "02ec1ab6d7ab285892c8a8110fbb957089af473d", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 200, "deletions": 107, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/3019af6c01fb40def845ac0b7b6f321d09f84e73/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3019af6c01fb40def845ac0b7b6f321d09f84e73/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=3019af6c01fb40def845ac0b7b6f321d09f84e73", "patch": "@@ -209,7 +209,8 @@ use Encodable;\n /// Represents a json value\n #[deriving(Clone, PartialEq, PartialOrd)]\n pub enum Json {\n-    Number(f64),\n+    Integer(i64),\n+    Floating(f64),\n     String(String),\n     Boolean(bool),\n     List(List),\n@@ -836,7 +837,8 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n     fn encode(&self, e: &mut E) -> Result<(), S> {\n         match *self {\n-            Number(v) => v.encode(e),\n+            Integer(v) => v.encode(e),\n+            Floating(v) => v.encode(e),\n             String(ref v) => v.encode(e),\n             Boolean(v) => v.encode(e),\n             List(ref v) => v.encode(e),\n@@ -958,14 +960,42 @@ impl Json {\n \n     /// Returns true if the Json value is a Number. Returns false otherwise.\n     pub fn is_number(&self) -> bool {\n-        self.as_number().is_some()\n+        match *self {\n+            Integer(_) | Floating(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a i64. Returns false otherwise.\n+    pub fn is_i64(&self) -> bool {\n+        match *self {\n+            Integer(_) => true,\n+            _ => false,\n+        }\n     }\n \n-    /// If the Json value is a Number, returns the associated f64.\n+    /// Returns true if the Json value is a f64. Returns false otherwise.\n+    pub fn is_f64(&self) -> bool {\n+        match *self {\n+            Floating(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// If the Json value is a Integer, returns the associated i64.\n     /// Returns None otherwise.\n-    pub fn as_number(&self) -> Option<f64> {\n-        match self {\n-            &Number(n) => Some(n),\n+    pub fn as_i64(&self) -> Option<i64> {\n+        match *self {\n+            Integer(n) => Some(n),\n+            _ => None\n+        }\n+    }\n+\n+    /// If the Json value is a Floating, returns the associated f64.\n+    /// Returns None otherwise.\n+    pub fn as_f64(&self) -> Option<f64> {\n+        match *self {\n+            Floating(n) => Some(n),\n             _ => None\n         }\n     }\n@@ -1007,7 +1037,8 @@ pub enum JsonEvent {\n     ListStart,\n     ListEnd,\n     BooleanValue(bool),\n-    NumberValue(f64),\n+    IntegerValue(i64),\n+    FloatingValue(f64),\n     StringValue(String),\n     NullValue,\n     Error(ParserError),\n@@ -1257,29 +1288,44 @@ impl<T: Iterator<char>> Parser<T> {\n               self.ch_is('\\r') { self.bump(); }\n     }\n \n-    fn parse_number(&mut self) -> Result<f64, ParserError> {\n-        let mut neg = 1.0;\n+    fn parse_number(&mut self) -> JsonEvent {\n+        let mut neg = 1;\n \n         if self.ch_is('-') {\n             self.bump();\n-            neg = -1.0;\n+            neg = -1;\n         }\n \n-        let mut res = try!(self.parse_integer());\n+        let res = match self.parse_i64() {\n+            Ok(res) => res,\n+            Err(e) => { return Error(e); }\n+        };\n \n-        if self.ch_is('.') {\n-            res = try!(self.parse_decimal(res));\n-        }\n+        if self.ch_is('.') || self.ch_is('e') || self.ch_is('E') {\n+            let mut res = res as f64;\n \n-        if self.ch_is('e') || self.ch_is('E') {\n-            res = try!(self.parse_exponent(res));\n-        }\n+            if self.ch_is('.') {\n+                res = match self.parse_decimal(res) {\n+                    Ok(res) => res,\n+                    Err(e) => { return Error(e); }\n+                };\n+            }\n \n-        Ok(neg * res)\n+            if self.ch_is('e') || self.ch_is('E') {\n+                res = match self.parse_exponent(res) {\n+                    Ok(res) => res,\n+                    Err(e) => { return Error(e); }\n+                };\n+            }\n+\n+            FloatingValue((neg as f64) * res)\n+        } else {\n+            IntegerValue(neg * res)\n+        }\n     }\n \n-    fn parse_integer(&mut self) -> Result<f64, ParserError> {\n-        let mut res = 0.0;\n+    fn parse_i64(&mut self) -> Result<i64, ParserError> {\n+        let mut res = 0;\n \n         match self.ch_or_null() {\n             '0' => {\n@@ -1295,8 +1341,8 @@ impl<T: Iterator<char>> Parser<T> {\n                 while !self.eof() {\n                     match self.ch_or_null() {\n                         c @ '0' .. '9' => {\n-                            res *= 10.0;\n-                            res += ((c as int) - ('0' as int)) as f64;\n+                            res *= 10;\n+                            res += (c as i64) - ('0' as i64);\n                             self.bump();\n                         }\n                         _ => break,\n@@ -1654,10 +1700,7 @@ impl<T: Iterator<char>> Parser<T> {\n             'n' => { self.parse_ident(\"ull\", NullValue) }\n             't' => { self.parse_ident(\"rue\", BooleanValue(true)) }\n             'f' => { self.parse_ident(\"alse\", BooleanValue(false)) }\n-            '0' .. '9' | '-' => match self.parse_number() {\n-                Ok(f) => NumberValue(f),\n-                Err(e) => Error(e),\n-            },\n+            '0' .. '9' | '-' => self.parse_number(),\n             '\"' => match self.parse_str() {\n                 Ok(s) => StringValue(s),\n                 Err(e) => Error(e),\n@@ -1721,7 +1764,8 @@ impl<T: Iterator<char>> Builder<T> {\n     fn build_value(&mut self) -> Result<Json, BuilderError> {\n         return match self.token {\n             Some(NullValue) => { Ok(Null) }\n-            Some(NumberValue(n)) => { Ok(Number(n)) }\n+            Some(IntegerValue(n)) => { Ok(Integer(n)) }\n+            Some(FloatingValue(n)) => { Ok(Floating(n)) }\n             Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n             Some(StringValue(ref mut s)) => {\n                 let mut temp = String::new();\n@@ -1848,7 +1892,20 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_u8 (&mut self)  -> DecodeResult<u8  > { Ok(try!(self.read_f64()) as u8) }\n     fn read_uint(&mut self) -> DecodeResult<uint> { Ok(try!(self.read_f64()) as uint) }\n \n-    fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self.read_f64()) as i64) }\n+    fn read_i64(&mut self) -> DecodeResult<i64> {\n+        debug!(\"read_i64\");\n+        match self.pop() {\n+            Integer(f) => Ok(f),\n+            Floating(f) => Ok(f as i64),\n+            String(s) => {\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // is going to have a string here, as per JSON spec.\n+                Ok(std::from_str::from_str(s.as_slice()).unwrap())\n+            },\n+            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n+        }\n+    }\n+\n     fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self.read_f64()) as i32) }\n     fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self.read_f64()) as i16) }\n     fn read_i8 (&mut self) -> DecodeResult<i8 > { Ok(try!(self.read_f64()) as i8) }\n@@ -1862,7 +1919,8 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_f64(&mut self) -> DecodeResult<f64> {\n         debug!(\"read_f64\");\n         match self.pop() {\n-            Number(f) => Ok(f),\n+            Integer(f) => Ok(f as f64),\n+            Floating(f) => Ok(f),\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n@@ -2087,7 +2145,7 @@ pub trait ToJson {\n macro_rules! to_json_impl(\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n-            fn to_json(&self) -> Json { Number(*self as f64) }\n+            fn to_json(&self) -> Json { Integer(*self as i64) }\n         })+\n     )\n )\n@@ -2106,7 +2164,7 @@ impl ToJson for f64 {\n     fn to_json(&self) -> Json {\n         match self.classify() {\n             FPNaN | FPInfinite => Null,\n-            _                  => Number(*self)\n+            _                  => Floating(*self)\n         }\n     }\n }\n@@ -2210,12 +2268,12 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use {Encodable, Decodable};\n-    use super::{Encoder, Decoder, Error, Boolean, Number, List, String, Null,\n+    use super::{Encoder, Decoder, Error, Boolean, Integer, Floating, List, String, Null,\n                 PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n                 MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n                 JsonEvent, Parser, StackElement,\n-                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, NumberValue, StringValue,\n-                NullValue, SyntaxError, Key, Index, Stack,\n+                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, IntegerValue, FloatingValue,\n+                StringValue, NullValue, SyntaxError, Key, Index, Stack,\n                 InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n                 EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n                 TrailingCharacters};\n@@ -2264,29 +2322,40 @@ mod tests {\n         assert_eq!(Null.to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n+    #[test]\n+    fn test_write_i64() {\n+        assert_eq!(Integer(0).to_string().into_string(), \"0\".to_string());\n+        assert_eq!(Integer(0).to_pretty_str().into_string(), \"0\".to_string());\n+\n+        assert_eq!(Integer(1234).to_string().into_string(), \"1234\".to_string());\n+        assert_eq!(Integer(1234).to_pretty_str().into_string(), \"1234\".to_string());\n+\n+        assert_eq!(Integer(-5678).to_string().into_string(), \"-5678\".to_string());\n+        assert_eq!(Integer(-5678).to_pretty_str().into_string(), \"-5678\".to_string());\n+    }\n \n     #[test]\n-    fn test_write_number() {\n-        assert_eq!(Number(3.0).to_string().into_string(), \"3\".to_string());\n-        assert_eq!(Number(3.0).to_pretty_str().into_string(), \"3\".to_string());\n+    fn test_write_f64() {\n+        assert_eq!(Floating(3.0).to_string().into_string(), \"3\".to_string());\n+        assert_eq!(Floating(3.0).to_pretty_str().into_string(), \"3\".to_string());\n \n-        assert_eq!(Number(3.1).to_string().into_string(), \"3.1\".to_string());\n-        assert_eq!(Number(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n+        assert_eq!(Floating(3.1).to_string().into_string(), \"3.1\".to_string());\n+        assert_eq!(Floating(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n \n-        assert_eq!(Number(-1.5).to_string().into_string(), \"-1.5\".to_string());\n-        assert_eq!(Number(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n+        assert_eq!(Floating(-1.5).to_string().into_string(), \"-1.5\".to_string());\n+        assert_eq!(Floating(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n \n-        assert_eq!(Number(0.5).to_string().into_string(), \"0.5\".to_string());\n-        assert_eq!(Number(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n+        assert_eq!(Floating(0.5).to_string().into_string(), \"0.5\".to_string());\n+        assert_eq!(Floating(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n \n-        assert_eq!(Number(f64::NAN).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Number(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(Floating(f64::NAN).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(Floating(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n \n-        assert_eq!(Number(f64::INFINITY).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Number(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(Floating(f64::INFINITY).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(Floating(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n \n-        assert_eq!(Number(f64::NEG_INFINITY).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Number(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(Floating(f64::NEG_INFINITY).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(Floating(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n     #[test]\n@@ -2324,7 +2393,7 @@ mod tests {\n         let long_test_list = List(vec![\n             Boolean(false),\n             Null,\n-            List(vec![String(\"foo\\nbar\".to_string()), Number(3.5)])]);\n+            List(vec![String(\"foo\\nbar\".to_string()), Floating(3.5)])]);\n \n         assert_eq!(long_test_list.to_string().into_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_string());\n@@ -2539,14 +2608,14 @@ mod tests {\n         assert_eq!(from_str(\"1e\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n         assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n \n-        assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n-        assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n-        assert_eq!(from_str(\"-1.2\"), Ok(Number(-1.2)));\n-        assert_eq!(from_str(\"0.4\"), Ok(Number(0.4)));\n-        assert_eq!(from_str(\"0.4e5\"), Ok(Number(0.4e5)));\n-        assert_eq!(from_str(\"0.4e+15\"), Ok(Number(0.4e15)));\n-        assert_eq!(from_str(\"0.4e-01\"), Ok(Number(0.4e-01)));\n-        assert_eq!(from_str(\" 3 \"), Ok(Number(3.0)));\n+        assert_eq!(from_str(\"3\"), Ok(Integer(3)));\n+        assert_eq!(from_str(\"3.1\"), Ok(Floating(3.1)));\n+        assert_eq!(from_str(\"-1.2\"), Ok(Floating(-1.2)));\n+        assert_eq!(from_str(\"0.4\"), Ok(Floating(0.4)));\n+        assert_eq!(from_str(\"0.4e5\"), Ok(Floating(0.4e5)));\n+        assert_eq!(from_str(\"0.4e+15\"), Ok(Floating(0.4e15)));\n+        assert_eq!(from_str(\"0.4e-01\"), Ok(Floating(0.4e-01)));\n+        assert_eq!(from_str(\" 3 \"), Ok(Integer(3)));\n     }\n \n     #[test]\n@@ -2622,11 +2691,11 @@ mod tests {\n         assert_eq!(from_str(\"[ false ]\"), Ok(List(vec![Boolean(false)])));\n         assert_eq!(from_str(\"[null]\"), Ok(List(vec![Null])));\n         assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(vec![Number(3.0), Number(1.0)])));\n+                     Ok(List(vec![Integer(3), Integer(1)])));\n         assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(vec![Number(3.0), Number(2.0)])));\n+                     Ok(List(vec![Integer(3), Integer(2)])));\n         assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(vec![Number(2.0), List(vec![Number(4.0), Number(1.0)])])));\n+               Ok(List(vec![Integer(2), List(vec![Integer(4), Integer(1)])])));\n     }\n \n     #[test]\n@@ -2664,7 +2733,7 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(\"a\".to_string(), Number(3.0))]));\n+                  mk_object([(\"a\".to_string(), Integer(3))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n@@ -2678,7 +2747,7 @@ mod tests {\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_string(), Number(1.0)),\n+                      (\"a\".to_string(), Floating(1.0)),\n                       (\"b\".to_string(), List(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n@@ -2691,7 +2760,7 @@ mod tests {\n                           ]\\\n                       }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_string(), Number(1.0)),\n+                      (\"a\".to_string(), Floating(1.0)),\n                       (\"b\".to_string(), List(vec![\n                           Boolean(true),\n                           String(\"foo\\nbar\".to_string()),\n@@ -2898,11 +2967,35 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_number(){\n+    fn test_is_i64(){\n+        let json_value = from_str(\"12\").unwrap();\n+        assert!(json_value.is_i64());\n+\n+        let json_value = from_str(\"12.0\").unwrap();\n+        assert!(!json_value.is_i64());\n+    }\n+\n+    #[test]\n+    fn test_is_f64(){\n         let json_value = from_str(\"12\").unwrap();\n-        let json_num = json_value.as_number();\n-        let expected_num = 12f64;\n-        assert!(json_num.is_some() && json_num.unwrap() == expected_num);\n+        assert!(!json_value.is_f64());\n+\n+        let json_value = from_str(\"12.0\").unwrap();\n+        assert!(json_value.is_f64());\n+    }\n+\n+    #[test]\n+    fn test_as_i64(){\n+        let json_value = from_str(\"12\").unwrap();\n+        let json_num = json_value.as_i64();\n+        assert_eq!(json_num, Some(12));\n+    }\n+\n+    #[test]\n+    fn test_as_f64(){\n+        let json_value = from_str(\"12.0\").unwrap();\n+        let json_num = json_value.as_f64();\n+        assert_eq!(json_num, Some(12f64));\n     }\n \n     #[test]\n@@ -3007,17 +3100,17 @@ mod tests {\n     #[ignore(cfg(target_word_size = \"32\"))] // FIXME(#14064)\n     fn test_streaming_parser() {\n         assert_stream_equal(\n-            r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2,3 ,4,5], \"idents\":[null,true,false]}\"#,\n+            r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n             vec![\n                 (ObjectStart,             vec![]),\n                   (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n                   (ListStart,             vec![Key(\"array\")]),\n-                    (NumberValue(0.0),    vec![Key(\"array\"), Index(0)]),\n-                    (NumberValue(1.0),    vec![Key(\"array\"), Index(1)]),\n-                    (NumberValue(2.0),    vec![Key(\"array\"), Index(2)]),\n-                    (NumberValue(3.0),    vec![Key(\"array\"), Index(3)]),\n-                    (NumberValue(4.0),    vec![Key(\"array\"), Index(4)]),\n-                    (NumberValue(5.0),    vec![Key(\"array\"), Index(5)]),\n+                    (IntegerValue(0),         vec![Key(\"array\"), Index(0)]),\n+                    (IntegerValue(1),         vec![Key(\"array\"), Index(1)]),\n+                    (IntegerValue(2),         vec![Key(\"array\"), Index(2)]),\n+                    (IntegerValue(3),         vec![Key(\"array\"), Index(3)]),\n+                    (IntegerValue(4),         vec![Key(\"array\"), Index(4)]),\n+                    (IntegerValue(5),         vec![Key(\"array\"), Index(5)]),\n                   (ListEnd,               vec![Key(\"array\")]),\n                   (ListStart,             vec![Key(\"idents\")]),\n                     (NullValue,           vec![Key(\"idents\"), Index(0)]),\n@@ -3061,7 +3154,7 @@ mod tests {\n             \"{\\\"a\\\": 3}\",\n             vec![\n                 (ObjectStart,        vec![]),\n-                  (NumberValue(3.0), vec![Key(\"a\")]),\n+                  (IntegerValue(3),      vec![Key(\"a\")]),\n                 (ObjectEnd,          vec![]),\n             ]\n         );\n@@ -3078,7 +3171,7 @@ mod tests {\n             \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n             vec![\n                 (ObjectStart,           vec![]),\n-                  (NumberValue(1.0),    vec![Key(\"a\")]),\n+                  (FloatingValue(1.0),       vec![Key(\"a\")]),\n                   (ListStart,           vec![Key(\"b\")]),\n                     (BooleanValue(true),vec![Key(\"b\"), Index(0)]),\n                   (ListEnd,             vec![Key(\"b\")]),\n@@ -3096,7 +3189,7 @@ mod tests {\n             }\"#,\n             vec![\n                 (ObjectStart,                   vec![]),\n-                  (NumberValue(1.0),            vec![Key(\"a\")]),\n+                  (FloatingValue(1.0),               vec![Key(\"a\")]),\n                   (ListStart,                   vec![Key(\"b\")]),\n                     (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n                     (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n@@ -3155,30 +3248,30 @@ mod tests {\n             \"[3, 1]\",\n             vec![\n                 (ListStart,     vec![]),\n-                    (NumberValue(3.0), vec![Index(0)]),\n-                    (NumberValue(1.0), vec![Index(1)]),\n+                    (IntegerValue(3), vec![Index(0)]),\n+                    (IntegerValue(1), vec![Index(1)]),\n                 (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"\\n[3, 2]\\n\",\n             vec![\n                 (ListStart,     vec![]),\n-                    (NumberValue(3.0), vec![Index(0)]),\n-                    (NumberValue(2.0), vec![Index(1)]),\n+                    (IntegerValue(3), vec![Index(0)]),\n+                    (IntegerValue(2), vec![Index(1)]),\n                 (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[2, [4, 1]]\",\n             vec![\n-                (ListStart,                 vec![]),\n-                    (NumberValue(2.0),      vec![Index(0)]),\n-                    (ListStart,             vec![Index(1)]),\n-                        (NumberValue(4.0),  vec![Index(1), Index(0)]),\n-                        (NumberValue(1.0),  vec![Index(1), Index(1)]),\n-                    (ListEnd,               vec![Index(1)]),\n-                (ListEnd,                   vec![]),\n+                (ListStart,            vec![]),\n+                    (IntegerValue(2),      vec![Index(0)]),\n+                    (ListStart,        vec![Index(1)]),\n+                        (IntegerValue(4),  vec![Index(1), Index(0)]),\n+                        (IntegerValue(1),  vec![Index(1), Index(1)]),\n+                    (ListEnd,          vec![Index(1)]),\n+                (ListEnd,              vec![]),\n             ]\n         );\n \n@@ -3277,29 +3370,29 @@ mod tests {\n         use std::collections::{HashMap,TreeMap};\n         use super::ToJson;\n \n-        let list2 = List(vec!(Number(1.0_f64), Number(2.0_f64)));\n-        let list3 = List(vec!(Number(1.0f64), Number(2.0f64), Number(3.0f64)));\n+        let list2 = List(vec!(Integer(1), Integer(2)));\n+        let list3 = List(vec!(Integer(1), Integer(2), Integer(3)));\n         let object = {\n             let mut tree_map = TreeMap::new();\n-            tree_map.insert(\"a\".to_string(), Number(1.0_f64));\n-            tree_map.insert(\"b\".to_string(), Number(2.0_f64));\n+            tree_map.insert(\"a\".to_string(), Integer(1));\n+            tree_map.insert(\"b\".to_string(), Integer(2));\n             Object(tree_map)\n         };\n \n         assert_eq!(list2.to_json(), list2);\n         assert_eq!(object.to_json(), object);\n-        assert_eq!(3_i.to_json(), Number(3.0_f64));\n-        assert_eq!(4_i8.to_json(), Number(4.0_f64));\n-        assert_eq!(5_i16.to_json(), Number(5.0_f64));\n-        assert_eq!(6_i32.to_json(), Number(6.0_f64));\n-        assert_eq!(7_i64.to_json(), Number(7.0_f64));\n-        assert_eq!(8_u.to_json(), Number(8.0_f64));\n-        assert_eq!(9_u8.to_json(), Number(9.0_f64));\n-        assert_eq!(10_u16.to_json(), Number(10.0_f64));\n-        assert_eq!(11_u32.to_json(), Number(11.0_f64));\n-        assert_eq!(12_u64.to_json(), Number(12.0_f64));\n-        assert_eq!(13.0_f32.to_json(), Number(13.0_f64));\n-        assert_eq!(14.0_f64.to_json(), Number(14.0_f64));\n+        assert_eq!(3_i.to_json(), Integer(3));\n+        assert_eq!(4_i8.to_json(), Integer(4));\n+        assert_eq!(5_i16.to_json(), Integer(5));\n+        assert_eq!(6_i32.to_json(), Integer(6));\n+        assert_eq!(7_i64.to_json(), Integer(7));\n+        assert_eq!(8_u.to_json(), Integer(8));\n+        assert_eq!(9_u8.to_json(), Integer(9));\n+        assert_eq!(10_u16.to_json(), Integer(10));\n+        assert_eq!(11_u32.to_json(), Integer(11));\n+        assert_eq!(12_u64.to_json(), Integer(12));\n+        assert_eq!(13.0_f32.to_json(), Floating(13.0_f64));\n+        assert_eq!(14.0_f64.to_json(), Floating(14.0_f64));\n         assert_eq!(().to_json(), Null);\n         assert_eq!(f32::INFINITY.to_json(), Null);\n         assert_eq!(f64::NAN.to_json(), Null);\n@@ -3320,7 +3413,7 @@ mod tests {\n         hash_map.insert(\"a\".to_string(), 1i);\n         hash_map.insert(\"b\".to_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n-        assert_eq!(Some(15i).to_json(), Number(15f64));\n+        assert_eq!(Some(15i).to_json(), Integer(15));\n         assert_eq!(None::<int>.to_json(), Null);\n     }\n "}, {"sha": "ef6ad80512c26cc0066c3bb804a443d9a9f562ff", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3019af6c01fb40def845ac0b7b6f321d09f84e73/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3019af6c01fb40def845ac0b7b6f321d09f84e73/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3019af6c01fb40def845ac0b7b6f321d09f84e73", "patch": "@@ -1103,8 +1103,8 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n         let mut map = TreeMap::new();\n-        map.insert(\"value\".to_string(), json::Number(self.value));\n-        map.insert(\"noise\".to_string(), json::Number(self.noise));\n+        map.insert(\"value\".to_string(), json::Floating(self.value));\n+        map.insert(\"noise\".to_string(), json::Floating(self.noise));\n         json::Object(map)\n     }\n }"}]}