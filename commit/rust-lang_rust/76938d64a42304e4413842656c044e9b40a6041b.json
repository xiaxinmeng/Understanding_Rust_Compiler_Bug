{"sha": "76938d64a42304e4413842656c044e9b40a6041b", "node_id": "C_kwDOAAsO6NoAKDc2OTM4ZDY0YTQyMzA0ZTQ0MTM4NDI2NTZjMDQ0ZTliNDBhNjA0MWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-01T23:22:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-01T23:22:43Z"}, "message": "Auto merge of #90446 - cjgillot:late-elided, r=jackh726\n\nLint elided lifetimes in path during lifetime resolution.\n\nThe lifetime elision lint is known to be brittle and can be redundant with later lifetime resolution errors. This PR aims to remove the redundancy by performing the lint after lifetime resolution.\n\nThis PR proposes to carry the information that an elision should be linted against by using a special `LifetimeName`. I am not certain this is the best solution, but it is certainly the easiest.\n\nFixes https://github.com/rust-lang/rust/issues/60199\nFixes https://github.com/rust-lang/rust/issues/55768\nFixes https://github.com/rust-lang/rust/issues/63110\nFixes https://github.com/rust-lang/rust/issues/71957", "tree": {"sha": "d361d767a2519c7fd14acb95efad519ee7f0292d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d361d767a2519c7fd14acb95efad519ee7f0292d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76938d64a42304e4413842656c044e9b40a6041b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76938d64a42304e4413842656c044e9b40a6041b", "html_url": "https://github.com/rust-lang/rust/commit/76938d64a42304e4413842656c044e9b40a6041b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76938d64a42304e4413842656c044e9b40a6041b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48a5999fceeea84a8971634355287faa349909d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/48a5999fceeea84a8971634355287faa349909d4", "html_url": "https://github.com/rust-lang/rust/commit/48a5999fceeea84a8971634355287faa349909d4"}, {"sha": "aa2450f41bc49752c45b1b7d51a4b71098c0c9e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2450f41bc49752c45b1b7d51a4b71098c0c9e8", "html_url": "https://github.com/rust-lang/rust/commit/aa2450f41bc49752c45b1b7d51a4b71098c0c9e8"}], "stats": {"total": 638, "additions": 399, "deletions": 239}, "files": [{"sha": "2a246a99a7032dd352b895fdbf626940dc17b6ae", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -1786,7 +1786,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericArg::Lifetime(hir::Lifetime {\n                 hir_id: self.next_id(),\n                 span: self.lower_span(span),\n-                name: hir::LifetimeName::Implicit,\n+                name: hir::LifetimeName::Implicit(false),\n             })));\n         let generic_args = self.arena.alloc_from_iter(generic_args);\n \n@@ -1927,7 +1927,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     });\n                 let param_name = match lt.name {\n                     hir::LifetimeName::Param(param_name) => param_name,\n-                    hir::LifetimeName::Implicit\n+                    hir::LifetimeName::Implicit(_)\n                     | hir::LifetimeName::Underscore\n                     | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n                     hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n@@ -2290,7 +2290,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n \n-            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n+            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span, false),\n         }\n     }\n \n@@ -2322,11 +2322,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &'s mut self,\n         span: Span,\n         count: usize,\n+        param_mode: ParamMode,\n     ) -> impl Iterator<Item = hir::Lifetime> + Captures<'a> + Captures<'s> + Captures<'hir> {\n-        (0..count).map(move |_| self.elided_path_lifetime(span))\n+        (0..count).map(move |_| self.elided_path_lifetime(span, param_mode))\n     }\n \n-    fn elided_path_lifetime(&mut self, span: Span) -> hir::Lifetime {\n+    fn elided_path_lifetime(&mut self, span: Span, param_mode: ParamMode) -> hir::Lifetime {\n         match self.anonymous_lifetime_mode {\n             AnonymousLifetimeMode::CreateParameter => {\n                 // We should have emitted E0726 when processing this path above\n@@ -2342,7 +2343,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n             // later, at which point a suitable error will be emitted.\n             AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n-                self.new_implicit_lifetime(span)\n+                self.new_implicit_lifetime(span, param_mode == ParamMode::Explicit)\n             }\n         }\n     }\n@@ -2385,11 +2386,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         r\n     }\n \n-    fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n+    fn new_implicit_lifetime(&mut self, span: Span, missing: bool) -> hir::Lifetime {\n         hir::Lifetime {\n             hir_id: self.next_id(),\n             span: self.lower_span(span),\n-            name: hir::LifetimeName::Implicit,\n+            name: hir::LifetimeName::Implicit(missing),\n         }\n     }\n \n@@ -2536,7 +2537,7 @@ fn lifetimes_from_impl_trait_bounds(\n \n         fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n             let name = match lifetime.name {\n-                hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n+                hir::LifetimeName::Implicit(_) | hir::LifetimeName::Underscore => {\n                     if self.collect_elided_lifetimes {\n                         // Use `'_` for both implicit and underscore lifetimes in\n                         // `type Foo<'_> = impl SomeTrait<'_>;`."}, {"sha": "cf0ee4fc28fe28ff7ba8759c2e79cb91d404cbe0", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 33, "deletions": 55, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -7,8 +7,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, PartialRes, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n-use rustc_session::lint::builtin::ELIDED_LIFETIMES_IN_PATHS;\n-use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::symbol::Ident;\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n@@ -270,12 +268,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let has_lifetimes =\n             generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n-        if !generic_args.parenthesized && !has_lifetimes {\n+        if !generic_args.parenthesized && !has_lifetimes && expected_lifetimes > 0 {\n             // Note: these spans are used for diagnostics when they can't be inferred.\n             // See rustc_resolve::late::lifetimes::LifetimeContext::add_missing_lifetime_specifiers_label\n             let elided_lifetime_span = if generic_args.span.is_empty() {\n                 // If there are no brackets, use the identifier span.\n-                segment.ident.span\n+                path_span\n             } else if generic_args.is_empty() {\n                 // If there are brackets, but not generic arguments, then use the opening bracket\n                 generic_args.span.with_hi(generic_args.span.lo() + BytePos(1))\n@@ -284,67 +282,47 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 generic_args.span.with_lo(generic_args.span.lo() + BytePos(1)).shrink_to_lo()\n             };\n             generic_args.args = self\n-                .elided_path_lifetimes(elided_lifetime_span, expected_lifetimes)\n+                .elided_path_lifetimes(elided_lifetime_span, expected_lifetimes, param_mode)\n                 .map(GenericArg::Lifetime)\n                 .chain(generic_args.args.into_iter())\n                 .collect();\n-            if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n+            // In create-parameter mode we error here because we don't want to support\n+            // deprecated impl elision in new features like impl elision and `async fn`,\n+            // both of which work using the `CreateParameter` mode:\n+            //\n+            //     impl Foo for std::cell::Ref<u32> // note lack of '_\n+            //     async fn foo(_: std::cell::Ref<u32>) { ... }\n+            if let (ParamMode::Explicit, AnonymousLifetimeMode::CreateParameter) =\n+                (param_mode, self.anonymous_lifetime_mode)\n+            {\n                 let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n                 let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n                 let no_bindings = generic_args.bindings.is_empty();\n-                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n+                let (incl_angl_brckt, suggestion) = if no_non_lt_args && no_bindings {\n                     // If there are no generic args, our suggestion can include the angle brackets.\n-                    (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n+                    (true, format!(\"<{}>\", anon_lt_suggestion))\n                 } else {\n                     // Otherwise we'll insert a `'_, ` right after the opening bracket.\n-                    let span = generic_args\n-                        .span\n-                        .with_lo(generic_args.span.lo() + BytePos(1))\n-                        .shrink_to_lo();\n-                    (false, span, format!(\"{}, \", anon_lt_suggestion))\n+                    (false, format!(\"{}, \", anon_lt_suggestion))\n                 };\n-                match self.anonymous_lifetime_mode {\n-                    // In create-parameter mode we error here because we don't want to support\n-                    // deprecated impl elision in new features like impl elision and `async fn`,\n-                    // both of which work using the `CreateParameter` mode:\n-                    //\n-                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n-                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n-                    AnonymousLifetimeMode::CreateParameter => {\n-                        let mut err = struct_span_err!(\n-                            self.sess,\n-                            path_span,\n-                            E0726,\n-                            \"implicit elided lifetime not allowed here\"\n-                        );\n-                        rustc_errors::add_elided_lifetime_in_path_suggestion(\n-                            &self.sess.source_map(),\n-                            &mut err,\n-                            expected_lifetimes,\n-                            path_span,\n-                            incl_angl_brckt,\n-                            insertion_sp,\n-                            suggestion,\n-                        );\n-                        err.note(\"assuming a `'static` lifetime...\");\n-                        err.emit();\n-                    }\n-                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n-                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n-                            ELIDED_LIFETIMES_IN_PATHS,\n-                            CRATE_NODE_ID,\n-                            path_span,\n-                            \"hidden lifetime parameters in types are deprecated\",\n-                            BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n-                                expected_lifetimes,\n-                                path_span,\n-                                incl_angl_brckt,\n-                                insertion_sp,\n-                                suggestion,\n-                            ),\n-                        );\n-                    }\n-                }\n+                let insertion_sp = elided_lifetime_span.shrink_to_hi();\n+                let mut err = struct_span_err!(\n+                    self.sess,\n+                    path_span,\n+                    E0726,\n+                    \"implicit elided lifetime not allowed here\"\n+                );\n+                rustc_errors::add_elided_lifetime_in_path_suggestion(\n+                    &self.sess.source_map(),\n+                    &mut err,\n+                    expected_lifetimes,\n+                    path_span,\n+                    incl_angl_brckt,\n+                    insertion_sp,\n+                    suggestion,\n+                );\n+                err.note(\"assuming a `'static` lifetime...\");\n+                err.emit();\n             }\n         }\n "}, {"sha": "64a7a25dc86ac9a90c467bb30129eba6b9d3ba02", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -584,7 +584,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n-            hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Implicit => {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Implicit(_) => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "2466e69f83646b0ab092d3fc3b7066030989315e", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -92,7 +92,9 @@ pub enum LifetimeName {\n     Param(ParamName),\n \n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n-    Implicit,\n+    ///\n+    /// The bool indicates whether the user should have written something.\n+    Implicit(bool),\n \n     /// Implicit lifetime in a context like `dyn Foo`. This is\n     /// distinguished from implicit lifetimes elsewhere because the\n@@ -122,7 +124,7 @@ impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit\n+            | LifetimeName::Implicit(_)\n             | LifetimeName::Error => Ident::empty(),\n             LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n@@ -133,7 +135,7 @@ impl LifetimeName {\n     pub fn is_elided(&self) -> bool {\n         match self {\n             LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit\n+            | LifetimeName::Implicit(_)\n             | LifetimeName::Underscore => true,\n \n             // It might seem surprising that `Fresh(_)` counts as\n@@ -3298,7 +3300,7 @@ mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::Expr<'static>, 64);\n     rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n-    rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n+    rustc_data_structures::static_assert_size!(super::Ty<'static>, 80);\n \n     rustc_data_structures::static_assert_size!(super::Item<'static>, 184);\n     rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 128);"}, {"sha": "21f89104c4b5878f09c02b47a19507798e3a531c", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -545,7 +545,7 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         | LifetimeName::Param(ParamName::Error)\n         | LifetimeName::Static\n         | LifetimeName::Error\n-        | LifetimeName::Implicit\n+        | LifetimeName::Implicit(_)\n         | LifetimeName::ImplicitObjectLifetimeDefault\n         | LifetimeName::Underscore => {}\n     }"}, {"sha": "69697f275e180658a2ce5c0185a44267d22feb08", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 114, "deletions": 1, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -1871,6 +1871,117 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         err.emit();\n     }\n \n+    /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n+    crate fn report_elision_failure(\n+        &mut self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        params: &[ElisionFailureInfo],\n+    ) -> bool {\n+        let mut m = String::new();\n+        let len = params.len();\n+\n+        let elided_params: Vec<_> =\n+            params.iter().cloned().filter(|info| info.lifetime_count > 0).collect();\n+\n+        let elided_len = elided_params.len();\n+\n+        for (i, info) in elided_params.into_iter().enumerate() {\n+            let ElisionFailureInfo { parent, index, lifetime_count: n, have_bound_regions, span } =\n+                info;\n+\n+            db.span_label(span, \"\");\n+            let help_name = if let Some(ident) =\n+                parent.and_then(|body| self.tcx.hir().body(body).params[index].pat.simple_ident())\n+            {\n+                format!(\"`{}`\", ident)\n+            } else {\n+                format!(\"argument {}\", index + 1)\n+            };\n+\n+            m.push_str(\n+                &(if n == 1 {\n+                    help_name\n+                } else {\n+                    format!(\n+                        \"one of {}'s {} {}lifetimes\",\n+                        help_name,\n+                        n,\n+                        if have_bound_regions { \"free \" } else { \"\" }\n+                    )\n+                })[..],\n+            );\n+\n+            if elided_len == 2 && i == 0 {\n+                m.push_str(\" or \");\n+            } else if i + 2 == elided_len {\n+                m.push_str(\", or \");\n+            } else if i != elided_len - 1 {\n+                m.push_str(\", \");\n+            }\n+        }\n+\n+        if len == 0 {\n+            db.help(\n+                \"this function's return type contains a borrowed value, \\\n+                 but there is no value for it to be borrowed from\",\n+            );\n+            true\n+        } else if elided_len == 0 {\n+            db.help(\n+                \"this function's return type contains a borrowed value with \\\n+                 an elided lifetime, but the lifetime cannot be derived from \\\n+                 the arguments\",\n+            );\n+            true\n+        } else if elided_len == 1 {\n+            db.help(&format!(\n+                \"this function's return type contains a borrowed value, \\\n+                 but the signature does not say which {} it is borrowed from\",\n+                m\n+            ));\n+            false\n+        } else {\n+            db.help(&format!(\n+                \"this function's return type contains a borrowed value, \\\n+                 but the signature does not say whether it is borrowed from {}\",\n+                m\n+            ));\n+            false\n+        }\n+    }\n+\n+    crate fn report_elided_lifetime_in_ty(&self, lifetime_refs: &[&hir::Lifetime]) {\n+        let Some(missing_lifetime) = lifetime_refs.iter().find(|lt| {\n+            lt.name == hir::LifetimeName::Implicit(true)\n+        }) else { return };\n+\n+        let mut spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n+        spans.sort();\n+        let mut spans_dedup = spans.clone();\n+        spans_dedup.dedup();\n+        let spans_with_counts: Vec<_> = spans_dedup\n+            .into_iter()\n+            .map(|sp| (sp, spans.iter().filter(|nsp| *nsp == &sp).count()))\n+            .collect();\n+\n+        self.tcx.struct_span_lint_hir(\n+            rustc_session::lint::builtin::ELIDED_LIFETIMES_IN_PATHS,\n+            missing_lifetime.hir_id,\n+            spans,\n+            |lint| {\n+                let mut db = lint.build(\"hidden lifetime parameters in types are deprecated\");\n+                self.add_missing_lifetime_specifiers_label(\n+                    &mut db,\n+                    spans_with_counts,\n+                    &FxHashSet::from_iter([kw::UnderscoreLifetime]),\n+                    Vec::new(),\n+                    &[],\n+                );\n+                db.emit()\n+            },\n+        );\n+    }\n+\n     // FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n     // generics. We are disallowing this until we can decide on how we want to handle non-'static\n     // lifetimes in const generics. See issue #74052 for discussion.\n@@ -2297,7 +2408,9 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         );\n         let is_allowed_lifetime = matches!(\n             lifetime_ref.name,\n-            hir::LifetimeName::Implicit | hir::LifetimeName::Static | hir::LifetimeName::Underscore\n+            hir::LifetimeName::Implicit(_)\n+                | hir::LifetimeName::Static\n+                | hir::LifetimeName::Underscore\n         );\n \n         if !self.tcx.lazy_normalization() && is_anon_const && !is_allowed_lifetime {"}, {"sha": "1ff33689b53c7942708dea0ef483f61a385ca503", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 56, "deletions": 122, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -357,11 +357,11 @@ enum Elide {\n #[derive(Clone, Debug)]\n crate struct ElisionFailureInfo {\n     /// Where we can find the argument pattern.\n-    parent: Option<hir::BodyId>,\n+    crate parent: Option<hir::BodyId>,\n     /// The index of the argument in the original definition.\n-    index: usize,\n-    lifetime_count: usize,\n-    have_bound_regions: bool,\n+    crate index: usize,\n+    crate lifetime_count: usize,\n+    crate have_bound_regions: bool,\n     crate span: Span,\n }\n \n@@ -923,7 +923,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                 });\n                 match lifetime.name {\n-                    LifetimeName::Implicit => {\n+                    LifetimeName::Implicit(_) => {\n                         // For types like `dyn Foo`, we should\n                         // generate a special form of elided.\n                         span_bug!(ty.span, \"object-lifetime-default expected, not implicit\",);\n@@ -3057,9 +3057,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n-                Scope::Body { .. } => return,\n+                Scope::Body { .. } => break Ok(()),\n \n-                Scope::Root => break None,\n+                Scope::Root => break Err(None),\n \n                 Scope::Binder { s, ref lifetimes, scope_type, .. } => {\n                     // collect named lifetimes for suggestions\n@@ -3076,50 +3076,54 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Elision { ref elide, ref s, .. } => {\n-                    let lifetime = match *elide {\n-                        Elide::FreshLateAnon(named_late_bound_vars, ref counter) => {\n-                            for lifetime_ref in lifetime_refs {\n-                                let lifetime = Region::late_anon(named_late_bound_vars, counter)\n-                                    .shifted(late_depth);\n+                Scope::Elision {\n+                    elide: Elide::FreshLateAnon(named_late_bound_vars, ref counter),\n+                    ..\n+                } => {\n+                    for lifetime_ref in lifetime_refs {\n+                        let lifetime =\n+                            Region::late_anon(named_late_bound_vars, counter).shifted(late_depth);\n \n-                                self.insert_lifetime(lifetime_ref, lifetime);\n-                            }\n-                            return;\n-                        }\n-                        Elide::Exact(l) => l.shifted(late_depth),\n-                        Elide::Error(ref e) => {\n-                            let mut scope = s;\n-                            loop {\n-                                match scope {\n-                                    Scope::Binder { ref lifetimes, s, .. } => {\n-                                        // Collect named lifetimes for suggestions.\n-                                        for name in lifetimes.keys() {\n-                                            if let hir::ParamName::Plain(name) = name {\n-                                                lifetime_names.insert(name.name);\n-                                                lifetime_spans.push(name.span);\n-                                            }\n-                                        }\n-                                        scope = s;\n-                                    }\n-                                    Scope::ObjectLifetimeDefault { ref s, .. }\n-                                    | Scope::Elision { ref s, .. }\n-                                    | Scope::TraitRefBoundary { ref s, .. } => {\n-                                        scope = s;\n+                        self.insert_lifetime(lifetime_ref, lifetime);\n+                    }\n+                    break Ok(());\n+                }\n+\n+                Scope::Elision { elide: Elide::Exact(l), .. } => {\n+                    let lifetime = l.shifted(late_depth);\n+                    for lifetime_ref in lifetime_refs {\n+                        self.insert_lifetime(lifetime_ref, lifetime);\n+                    }\n+                    break Ok(());\n+                }\n+\n+                Scope::Elision { elide: Elide::Error(ref e), ref s, .. } => {\n+                    let mut scope = s;\n+                    loop {\n+                        match scope {\n+                            Scope::Binder { ref lifetimes, s, .. } => {\n+                                // Collect named lifetimes for suggestions.\n+                                for name in lifetimes.keys() {\n+                                    if let hir::ParamName::Plain(name) = name {\n+                                        lifetime_names.insert(name.name);\n+                                        lifetime_spans.push(name.span);\n                                     }\n-                                    _ => break,\n                                 }\n+                                scope = s;\n+                            }\n+                            Scope::ObjectLifetimeDefault { ref s, .. }\n+                            | Scope::Elision { ref s, .. }\n+                            | Scope::TraitRefBoundary { ref s, .. } => {\n+                                scope = s;\n                             }\n-                            break Some(&e[..]);\n+                            _ => break,\n                         }\n-                        Elide::Forbid => break None,\n-                    };\n-                    for lifetime_ref in lifetime_refs {\n-                        self.insert_lifetime(lifetime_ref, lifetime);\n                     }\n-                    return;\n+                    break Err(Some(&e[..]));\n                 }\n \n+                Scope::Elision { elide: Elide::Forbid, .. } => break Err(None),\n+\n                 Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n@@ -3128,6 +3132,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n+        let error = match error {\n+            Ok(()) => {\n+                self.report_elided_lifetime_in_ty(lifetime_refs);\n+                return;\n+            }\n+            Err(error) => error,\n+        };\n+\n         // If we specifically need the `scope_for_path` map, then we're in the\n         // diagnostic pass and we don't want to emit more errors.\n         if self.map.scope_for_path.is_some() {\n@@ -3166,84 +3178,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_elision_failure(\n-        &mut self,\n-        db: &mut DiagnosticBuilder<'_>,\n-        params: &[ElisionFailureInfo],\n-    ) -> bool /* add `'static` lifetime to lifetime list */ {\n-        let mut m = String::new();\n-        let len = params.len();\n-\n-        let elided_params: Vec<_> =\n-            params.iter().cloned().filter(|info| info.lifetime_count > 0).collect();\n-\n-        let elided_len = elided_params.len();\n-\n-        for (i, info) in elided_params.into_iter().enumerate() {\n-            let ElisionFailureInfo { parent, index, lifetime_count: n, have_bound_regions, span } =\n-                info;\n-\n-            db.span_label(span, \"\");\n-            let help_name = if let Some(ident) =\n-                parent.and_then(|body| self.tcx.hir().body(body).params[index].pat.simple_ident())\n-            {\n-                format!(\"`{}`\", ident)\n-            } else {\n-                format!(\"argument {}\", index + 1)\n-            };\n-\n-            m.push_str(\n-                &(if n == 1 {\n-                    help_name\n-                } else {\n-                    format!(\n-                        \"one of {}'s {} {}lifetimes\",\n-                        help_name,\n-                        n,\n-                        if have_bound_regions { \"free \" } else { \"\" }\n-                    )\n-                })[..],\n-            );\n-\n-            if elided_len == 2 && i == 0 {\n-                m.push_str(\" or \");\n-            } else if i + 2 == elided_len {\n-                m.push_str(\", or \");\n-            } else if i != elided_len - 1 {\n-                m.push_str(\", \");\n-            }\n-        }\n-\n-        if len == 0 {\n-            db.help(\n-                \"this function's return type contains a borrowed value, \\\n-                 but there is no value for it to be borrowed from\",\n-            );\n-            true\n-        } else if elided_len == 0 {\n-            db.help(\n-                \"this function's return type contains a borrowed value with \\\n-                 an elided lifetime, but the lifetime cannot be derived from \\\n-                 the arguments\",\n-            );\n-            true\n-        } else if elided_len == 1 {\n-            db.help(&format!(\n-                \"this function's return type contains a borrowed value, \\\n-                 but the signature does not say which {} it is borrowed from\",\n-                m\n-            ));\n-            false\n-        } else {\n-            db.help(&format!(\n-                \"this function's return type contains a borrowed value, \\\n-                 but the signature does not say whether it is borrowed from {}\",\n-                m\n-            ));\n-            false\n-        }\n-    }\n-\n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n@@ -3348,7 +3282,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 ))\n                                 .emit();\n                         }\n-                        hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n+                        hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit(_) => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n                         hir::LifetimeName::ImplicitObjectLifetimeDefault => {"}, {"sha": "87a79b8813777fb9acd137d5f0cb31dd72a14ff6", "filename": "src/test/ui/in-band-lifetimes/elided-lifetimes.fixed", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.fixed?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -5,23 +5,24 @@\n #![deny(elided_lifetimes_in_paths)]\n //~^ NOTE the lint level is defined here\n \n-use std::cell::{RefCell, Ref};\n+use std::cell::{Ref, RefCell};\n \n-\n-struct Foo<'a> { x: &'a u32 }\n+struct Foo<'a> {\n+    x: &'a u32,\n+}\n \n fn foo(x: &Foo<'_>) {\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected named lifetime parameter\n+    //~| HELP consider using the `'_` lifetime\n }\n \n fn bar(x: &Foo<'_>) {}\n \n-\n struct Wrapped<'a>(&'a str);\n \n struct WrappedWithBow<'a> {\n-    gift: &'a str\n+    gift: &'a str,\n }\n \n struct MatchedSet<'a, 'b> {\n@@ -31,22 +32,34 @@ struct MatchedSet<'a, 'b> {\n \n fn wrap_gift(gift: &str) -> Wrapped<'_> {\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected named lifetime parameter\n+    //~| HELP consider using the `'_` lifetime\n     Wrapped(gift)\n }\n \n fn wrap_gift_with_bow(gift: &str) -> WrappedWithBow<'_> {\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected named lifetime parameter\n+    //~| HELP consider using the `'_` lifetime\n     WrappedWithBow { gift }\n }\n \n fn inspect_matched_set(set: MatchedSet<'_, '_>) {\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected 2 lifetime parameters\n+    //~| HELP consider using the `'_` lifetime\n     println!(\"{} {}\", set.one, set.another);\n }\n \n+// Verify that the lint does not fire, because the added `'_` wouldn't be resolved correctly.\n+fn match_sets() -> MatchedSet<'static, 'static> {\n+    //~^ ERROR missing lifetime specifiers\n+    //~| NOTE expected 2 lifetime parameters\n+    //~| HELP this function's return type contains a borrowed value\n+    //~| HELP consider using the `'static` lifetime\n+    MatchedSet { one: \"one\", another: \"another\" }\n+}\n+\n macro_rules! autowrapper {\n     ($type_name:ident, $fn_name:ident, $lt:lifetime) => {\n         struct $type_name<$lt> {\n@@ -55,7 +68,11 @@ macro_rules! autowrapper {\n \n         fn $fn_name(gift: &str) -> $type_name<'_> {\n             //~^ ERROR hidden lifetime parameters in types are deprecated\n-            //~| HELP indicate the anonymous lifetime\n+            //~| NOTE expected named lifetime parameter\n+            //~| HELP consider using the `'_` lifetime\n+            //~| ERROR hidden lifetime parameters in types are deprecated\n+            //~| NOTE expected named lifetime parameter\n+            //~| HELP consider using the `'_` lifetime\n             $type_name { gift }\n         }\n     }\n@@ -65,19 +82,34 @@ autowrapper!(Autowrapped, autowrap_gift, 'a);\n //~^ NOTE in this expansion of autowrapper!\n //~| NOTE in this expansion of autowrapper!\n \n+// Verify that rustfix does not try to apply the fix twice.\n+autowrapper!(AutowrappedAgain, autowrap_gift_again, 'a);\n+//~^ NOTE in this expansion of autowrapper!\n+//~| NOTE in this expansion of autowrapper!\n+\n macro_rules! anytuple_ref_ty {\n     ($($types:ty),*) => {\n         Ref<'_, ($($types),*)>\n         //~^ ERROR hidden lifetime parameters in types are deprecated\n-        //~| HELP indicate the anonymous lifetime\n+        //~| NOTE expected named lifetime parameter\n+        //~| HELP consider using the `'_` lifetime\n     }\n }\n \n+#[allow(elided_lifetimes_in_paths)]\n+mod blah {\n+    struct Thing<'a>(&'a i32);\n+    struct Bar<T>(T);\n+\n+    fn foo(b: Bar<Thing>) {}\n+}\n+\n fn main() {\n     let honesty = RefCell::new((4, 'e'));\n     let loyalty: Ref<'_, (u32, char)> = honesty.borrow();\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected named lifetime parameter\n+    //~| HELP consider using the `'_` lifetime\n     let generosity = Ref::map(loyalty, |t| &t.0);\n \n     let laughter = RefCell::new((true, \"magic\"));"}, {"sha": "28323a22427b64c837644d183f7b2e90a65c2778", "filename": "src/test/ui/in-band-lifetimes/elided-lifetimes.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -5,23 +5,24 @@\n #![deny(elided_lifetimes_in_paths)]\n //~^ NOTE the lint level is defined here\n \n-use std::cell::{RefCell, Ref};\n+use std::cell::{Ref, RefCell};\n \n-\n-struct Foo<'a> { x: &'a u32 }\n+struct Foo<'a> {\n+    x: &'a u32,\n+}\n \n fn foo(x: &Foo) {\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected named lifetime parameter\n+    //~| HELP consider using the `'_` lifetime\n }\n \n fn bar(x: &Foo<'_>) {}\n \n-\n struct Wrapped<'a>(&'a str);\n \n struct WrappedWithBow<'a> {\n-    gift: &'a str\n+    gift: &'a str,\n }\n \n struct MatchedSet<'a, 'b> {\n@@ -31,22 +32,34 @@ struct MatchedSet<'a, 'b> {\n \n fn wrap_gift(gift: &str) -> Wrapped {\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected named lifetime parameter\n+    //~| HELP consider using the `'_` lifetime\n     Wrapped(gift)\n }\n \n fn wrap_gift_with_bow(gift: &str) -> WrappedWithBow {\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected named lifetime parameter\n+    //~| HELP consider using the `'_` lifetime\n     WrappedWithBow { gift }\n }\n \n fn inspect_matched_set(set: MatchedSet) {\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected 2 lifetime parameters\n+    //~| HELP consider using the `'_` lifetime\n     println!(\"{} {}\", set.one, set.another);\n }\n \n+// Verify that the lint does not fire, because the added `'_` wouldn't be resolved correctly.\n+fn match_sets() -> MatchedSet {\n+    //~^ ERROR missing lifetime specifiers\n+    //~| NOTE expected 2 lifetime parameters\n+    //~| HELP this function's return type contains a borrowed value\n+    //~| HELP consider using the `'static` lifetime\n+    MatchedSet { one: \"one\", another: \"another\" }\n+}\n+\n macro_rules! autowrapper {\n     ($type_name:ident, $fn_name:ident, $lt:lifetime) => {\n         struct $type_name<$lt> {\n@@ -55,7 +68,11 @@ macro_rules! autowrapper {\n \n         fn $fn_name(gift: &str) -> $type_name {\n             //~^ ERROR hidden lifetime parameters in types are deprecated\n-            //~| HELP indicate the anonymous lifetime\n+            //~| NOTE expected named lifetime parameter\n+            //~| HELP consider using the `'_` lifetime\n+            //~| ERROR hidden lifetime parameters in types are deprecated\n+            //~| NOTE expected named lifetime parameter\n+            //~| HELP consider using the `'_` lifetime\n             $type_name { gift }\n         }\n     }\n@@ -65,19 +82,34 @@ autowrapper!(Autowrapped, autowrap_gift, 'a);\n //~^ NOTE in this expansion of autowrapper!\n //~| NOTE in this expansion of autowrapper!\n \n+// Verify that rustfix does not try to apply the fix twice.\n+autowrapper!(AutowrappedAgain, autowrap_gift_again, 'a);\n+//~^ NOTE in this expansion of autowrapper!\n+//~| NOTE in this expansion of autowrapper!\n+\n macro_rules! anytuple_ref_ty {\n     ($($types:ty),*) => {\n         Ref<($($types),*)>\n         //~^ ERROR hidden lifetime parameters in types are deprecated\n-        //~| HELP indicate the anonymous lifetime\n+        //~| NOTE expected named lifetime parameter\n+        //~| HELP consider using the `'_` lifetime\n     }\n }\n \n+#[allow(elided_lifetimes_in_paths)]\n+mod blah {\n+    struct Thing<'a>(&'a i32);\n+    struct Bar<T>(T);\n+\n+    fn foo(b: Bar<Thing>) {}\n+}\n+\n fn main() {\n     let honesty = RefCell::new((4, 'e'));\n     let loyalty: Ref<(u32, char)> = honesty.borrow();\n     //~^ ERROR hidden lifetime parameters in types are deprecated\n-    //~| HELP indicate the anonymous lifetime\n+    //~| NOTE expected named lifetime parameter\n+    //~| HELP consider using the `'_` lifetime\n     let generosity = Ref::map(loyalty, |t| &t.0);\n \n     let laughter = RefCell::new((true, \"magic\"));"}, {"sha": "2e65461b321e989fc65ee61de24230228b9787bd", "filename": "src/test/ui/in-band-lifetimes/elided-lifetimes.stderr", "status": "modified", "additions": 75, "deletions": 15, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Felided-lifetimes.stderr?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -1,60 +1,120 @@\n error: hidden lifetime parameters in types are deprecated\n-  --> $DIR/elided-lifetimes.rs:13:12\n+  --> $DIR/elided-lifetimes.rs:14:12\n    |\n LL | fn foo(x: &Foo) {\n-   |            ^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |            ^^^ expected named lifetime parameter\n    |\n note: the lint level is defined here\n   --> $DIR/elided-lifetimes.rs:5:9\n    |\n LL | #![deny(elided_lifetimes_in_paths)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider using the `'_` lifetime\n+   |\n+LL | fn foo(x: &Foo<'_>) {\n+   |            ~~~~~~~\n \n error: hidden lifetime parameters in types are deprecated\n-  --> $DIR/elided-lifetimes.rs:32:29\n+  --> $DIR/elided-lifetimes.rs:33:29\n    |\n LL | fn wrap_gift(gift: &str) -> Wrapped {\n-   |                             ^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |                             ^^^^^^^ expected named lifetime parameter\n+   |\n+help: consider using the `'_` lifetime\n+   |\n+LL | fn wrap_gift(gift: &str) -> Wrapped<'_> {\n+   |                             ~~~~~~~~~~~\n \n error: hidden lifetime parameters in types are deprecated\n-  --> $DIR/elided-lifetimes.rs:38:38\n+  --> $DIR/elided-lifetimes.rs:40:38\n    |\n LL | fn wrap_gift_with_bow(gift: &str) -> WrappedWithBow {\n-   |                                      ^^^^^^^^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |                                      ^^^^^^^^^^^^^^ expected named lifetime parameter\n+   |\n+help: consider using the `'_` lifetime\n+   |\n+LL | fn wrap_gift_with_bow(gift: &str) -> WrappedWithBow<'_> {\n+   |                                      ~~~~~~~~~~~~~~~~~~\n \n error: hidden lifetime parameters in types are deprecated\n-  --> $DIR/elided-lifetimes.rs:44:29\n+  --> $DIR/elided-lifetimes.rs:47:29\n    |\n LL | fn inspect_matched_set(set: MatchedSet) {\n-   |                             ^^^^^^^^^^- help: indicate the anonymous lifetimes: `<'_, '_>`\n+   |                             ^^^^^^^^^^ expected 2 lifetime parameters\n+   |\n+help: consider using the `'_` lifetime\n+   |\n+LL | fn inspect_matched_set(set: MatchedSet<'_, '_>) {\n+   |                             ~~~~~~~~~~~~~~~~~~\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/elided-lifetimes.rs:55:20\n+   |\n+LL | fn match_sets() -> MatchedSet {\n+   |                    ^^^^^^^^^^ expected 2 lifetime parameters\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn match_sets() -> MatchedSet<'static, 'static> {\n+   |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: hidden lifetime parameters in types are deprecated\n-  --> $DIR/elided-lifetimes.rs:56:36\n+  --> $DIR/elided-lifetimes.rs:69:36\n    |\n LL |         fn $fn_name(gift: &str) -> $type_name {\n-   |                                    ^^^^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |                                    ^^^^^^^^^^ expected named lifetime parameter\n ...\n LL | autowrapper!(Autowrapped, autowrap_gift, 'a);\n    | -------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `autowrapper` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider using the `'_` lifetime\n+   |\n+LL |         fn $fn_name(gift: &str) -> $type_name<'_> {\n+   |                                    ~~~~~~~~~~~~~~\n \n error: hidden lifetime parameters in types are deprecated\n-  --> $DIR/elided-lifetimes.rs:78:18\n+  --> $DIR/elided-lifetimes.rs:69:36\n+   |\n+LL |         fn $fn_name(gift: &str) -> $type_name {\n+   |                                    ^^^^^^^^^^ expected named lifetime parameter\n+...\n+LL | autowrapper!(AutowrappedAgain, autowrap_gift_again, 'a);\n+   | ------------------------------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `autowrapper` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider using the `'_` lifetime\n+   |\n+LL |         fn $fn_name(gift: &str) -> $type_name<'_> {\n+   |                                    ~~~~~~~~~~~~~~\n+\n+error: hidden lifetime parameters in types are deprecated\n+  --> $DIR/elided-lifetimes.rs:109:22\n    |\n LL |     let loyalty: Ref<(u32, char)> = honesty.borrow();\n-   |                  ^^^^^^^^^^^^^^^^ help: indicate the anonymous lifetime: `Ref<'_, (u32, char)>`\n+   |                      ^ expected named lifetime parameter\n+   |\n+help: consider using the `'_` lifetime\n+   |\n+LL |     let loyalty: Ref<'_, (u32, char)> = honesty.borrow();\n+   |                      +++\n \n error: hidden lifetime parameters in types are deprecated\n-  --> $DIR/elided-lifetimes.rs:70:9\n+  --> $DIR/elided-lifetimes.rs:92:13\n    |\n LL |         Ref<($($types),*)>\n-   |         ^^^^^^^^^^^^^^^^^^ help: indicate the anonymous lifetime: `Ref<'_, ($($types),*)>`\n+   |             ^ expected named lifetime parameter\n ...\n LL |     let yellow: anytuple_ref_ty!(bool, &str) = laughter.borrow();\n    |                 ---------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `anytuple_ref_ty` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider using the `'_` lifetime\n+   |\n+LL |         Ref<'_, ($($types),*)>\n+   |             +++\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 9 previous errors\n \n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "f5e8b41b1634e5e2b7046af4aab722a0f5c6fefd", "filename": "src/test/ui/lint/force-warn/allowed-by-default-lint.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Flint%2Fforce-warn%2Fallowed-by-default-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Flint%2Fforce-warn%2Fallowed-by-default-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fforce-warn%2Fallowed-by-default-lint.stderr?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -2,9 +2,13 @@ warning: hidden lifetime parameters in types are deprecated\n   --> $DIR/allowed-by-default-lint.rs:9:12\n    |\n LL | fn foo(x: &Foo) {}\n-   |            ^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |            ^^^ expected named lifetime parameter\n    |\n    = note: requested on the command line with `--force-warn elided-lifetimes-in-paths`\n+help: consider using the `'_` lifetime\n+   |\n+LL | fn foo(x: &Foo<'_>) {}\n+   |            ~~~~~~~\n \n warning: 1 warning emitted\n "}, {"sha": "b1792e2e9cbf862a1b645cc78d83ebe9d377211a", "filename": "src/test/ui/lint/reasons.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Flint%2Freasons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Flint%2Freasons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Freasons.rs?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -1,7 +1,6 @@\n // check-pass\n \n #![feature(lint_reasons)]\n-\n #![warn(elided_lifetimes_in_paths,\n         //~^ NOTE the lint level is defined here\n         reason = \"explicit anonymous lifetimes aid reasoning about ownership\")]\n@@ -20,8 +19,9 @@ pub struct CheaterDetectionMechanism {}\n impl fmt::Debug for CheaterDetectionMechanism {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         //~^ WARN hidden lifetime parameters in types are deprecated\n+        //~| NOTE expected named lifetime parameter\n         //~| NOTE explicit anonymous lifetimes aid\n-        //~| HELP indicate the anonymous lifetime\n+        //~| HELP consider using the `'_` lifetime\n         fmt.debug_struct(\"CheaterDetectionMechanism\").finish()\n     }\n }"}, {"sha": "f797c89a0326994344b87cf92d752861fc593108", "filename": "src/test/ui/lint/reasons.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Flint%2Freasons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76938d64a42304e4413842656c044e9b40a6041b/src%2Ftest%2Fui%2Flint%2Freasons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Freasons.stderr?ref=76938d64a42304e4413842656c044e9b40a6041b", "patch": "@@ -1,15 +1,19 @@\n warning: hidden lifetime parameters in types are deprecated\n-  --> $DIR/reasons.rs:21:29\n+  --> $DIR/reasons.rs:20:29\n    |\n LL |     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-   |                             ^^^^^^^^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |                             ^^^^^^^^^^^^^^ expected named lifetime parameter\n    |\n    = note: explicit anonymous lifetimes aid reasoning about ownership\n note: the lint level is defined here\n-  --> $DIR/reasons.rs:5:9\n+  --> $DIR/reasons.rs:4:9\n    |\n LL | #![warn(elided_lifetimes_in_paths,\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider using the `'_` lifetime\n+   |\n+LL |     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+   |                             ~~~~~~~~~~~~~~~~~~\n \n warning: variable `Social_exchange_psychology` should have a snake case name\n   --> $DIR/reasons.rs:30:9\n@@ -20,7 +24,7 @@ LL |     let Social_exchange_psychology = CheaterDetectionMechanism {};\n    = note: people shouldn't have to change their usual style habits\n            to contribute to our project\n note: the lint level is defined here\n-  --> $DIR/reasons.rs:9:5\n+  --> $DIR/reasons.rs:8:5\n    |\n LL |     nonstandard_style,\n    |     ^^^^^^^^^^^^^^^^^"}]}