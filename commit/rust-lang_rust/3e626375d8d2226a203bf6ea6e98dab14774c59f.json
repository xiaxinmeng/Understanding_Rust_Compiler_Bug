{"sha": "3e626375d8d2226a203bf6ea6e98dab14774c59f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNjI2Mzc1ZDhkMjIyNmEyMDNiZjZlYTZlOThkYWIxNDc3NGM1OWY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-04T12:20:11Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-26T00:38:51Z"}, "message": "DST coercions and DST structs\n\n[breaking-change]\n\n1. The internal layout for traits has changed from (vtable, data) to (data, vtable). If you were relying on this in unsafe transmutes, you might get some very weird and apparently unrelated errors. You should not be doing this! Prefer not to do this at all, but if you must, you should use raw::TraitObject rather than hardcoding rustc's internal representation into your code.\n\n2. The minimal type of reference-to-vec-literals (e.g., `&[1, 2, 3]`) is now a fixed size vec (e.g., `&[int, ..3]`) where it used to be an unsized vec (e.g., `&[int]`). If you want the unszied type, you must explicitly give the type (e.g., `let x: &[_] = &[1, 2, 3]`). Note in particular where multiple blocks must have the same type (e.g., if and else clauses, vec elements), the compiler will not coerce to the unsized type without a hint. E.g., `[&[1], &[1, 2]]` used to be a valid expression of type '[&[int]]'. It no longer type checks since the first element now has type `&[int, ..1]` and the second has type &[int, ..2]` which are incompatible.\n\n3. The type of blocks (including functions) must be coercible to the expected type (used to be a subtype). Mostly this makes things more flexible and not less (in particular, in the case of coercing function bodies to the return type). However, in some rare cases, this is less flexible. TBH, I'm not exactly sure of the exact effects. I think the change causes us to resolve inferred type variables slightly earlier which might make us slightly more restrictive. Possibly it only affects blocks with unreachable code. E.g., `if ... { fail!(); \"Hello\" }` used to type check, it no longer does. The fix is to add a semicolon after the string.", "tree": {"sha": "9be8320420b1c904670b7e12ccff8bc3080b2eec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9be8320420b1c904670b7e12ccff8bc3080b2eec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e626375d8d2226a203bf6ea6e98dab14774c59f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e626375d8d2226a203bf6ea6e98dab14774c59f", "html_url": "https://github.com/rust-lang/rust/commit/3e626375d8d2226a203bf6ea6e98dab14774c59f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e626375d8d2226a203bf6ea6e98dab14774c59f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a94b80f207e86017e54056ced2dc9674907ae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a94b80f207e86017e54056ced2dc9674907ae3", "html_url": "https://github.com/rust-lang/rust/commit/37a94b80f207e86017e54056ced2dc9674907ae3"}], "stats": {"total": 5065, "additions": 3243, "deletions": 1822}, "files": [{"sha": "38216fa5b59b14002e87b2b6dad33c19e96e21cc", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -12,6 +12,7 @@\n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n //                and `nonnull`\n \n+use core::ptr::RawPtr;\n #[cfg(not(test))] use core::raw;\n #[cfg(not(test))] use util;\n \n@@ -69,6 +70,11 @@ pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n /// the value returned by `usable_size` for the requested size.\n #[inline]\n pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n+    // FIXME(14395) This is only required for DST ~[T], it should be removed once\n+    // we fix that representation to not use null pointers.\n+    if ptr.is_null() {\n+        return;\n+    }\n     imp::deallocate(ptr, size, align)\n }\n "}, {"sha": "71b9673d2792996f92ccb5c173e16108279d9985", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -92,8 +92,6 @@ use core::iter::{range_step, MultiplicativeIterator};\n \n use MutableSeq;\n use vec::Vec;\n-#[cfg(not(stage0))]\n-use raw::Slice;\n \n pub use core::slice::{Chunks, Slice, ImmutableSlice, ImmutablePartialEqSlice};\n pub use core::slice::{ImmutableOrdSlice, MutableSlice, Items, MutItems};\n@@ -284,64 +282,6 @@ pub trait CloneableVector<T> {\n \n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n-    #[cfg(not(stage0))]\n-    fn to_owned(&self) -> ~[T] {\n-        use num::CheckedMul;\n-        use option::Expect;\n-\n-        let len = self.len();\n-\n-        if len == 0 {\n-            unsafe {\n-                let slice: Slice<T> = Slice{data: 0 as *T, len: 0};\n-                mem::transmute(slice)\n-            }\n-        } else {\n-            let unit_size = mem::size_of::<T>();\n-            let data_size = if unit_size == 0 {\n-                len\n-            } else {\n-                let data_size = len.checked_mul(&unit_size);\n-                data_size.expect(\"overflow in from_iter()\")\n-            };\n-\n-            unsafe {\n-                // this should pass the real required alignment\n-                let ret = allocate(data_size, 8) as *mut T;\n-\n-                if unit_size > 0 {\n-                    // Be careful with the following loop. We want it to be optimized\n-                    // to a memcpy (or something similarly fast) when T is Copy. LLVM\n-                    // is easily confused, so any extra operations during the loop can\n-                    // prevent this optimization.\n-                    let mut i = 0;\n-                    let p = &mut (*ret) as *mut _ as *mut T;\n-                    try_finally(\n-                        &mut i, (),\n-                        |i, ()| while *i < len {\n-                            mem::move_val_init(\n-                                &mut(*p.offset(*i as int)),\n-                                self.unsafe_ref(*i).clone());\n-                            *i += 1;\n-                        },\n-                        |i| if *i < len {\n-                            // we must be failing, clean up after ourselves\n-                            for j in range(0, *i as int) {\n-                                ptr::read(&*p.offset(j));\n-                            }\n-                            // FIXME: #13994 (should pass align and size here)\n-                            deallocate(ret as *mut u8, 0, 8);\n-                        });\n-                }\n-                let slice: Slice<T> = Slice{data: ret as *T, len: len};\n-                mem::transmute(slice)\n-            }\n-        }\n-    }\n-\n-    /// Returns a copy of `v`.\n-    // NOTE: remove after snapshot\n-    #[cfg(stage0)]\n     #[inline]\n     fn to_vec(&self) -> Vec<T> { Vec::from_slice(*self) }\n "}, {"sha": "4ecc1b8f45fc09f0db753a96ae41894b589084ed", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -93,6 +93,8 @@ pub trait TyVisitor {\n     fn visit_char(&mut self) -> bool;\n \n     fn visit_estr_slice(&mut self) -> bool;\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;\n \n     fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n@@ -101,8 +103,13 @@ pub trait TyVisitor {\n     fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *const TyDesc) -> bool;\n+    #[cfg(not(stage0))]\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n+                        inner: *const TyDesc) -> bool;\n \n     fn visit_enter_rec(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;"}, {"sha": "aa8a4976867a67e9c6460fbe749f20016dc4738c", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -51,10 +51,16 @@ pub struct Procedure {\n ///\n /// This struct does not have a `Repr` implementation\n /// because there is no way to refer to all trait objects generically.\n+#[cfg(stage0)]\n pub struct TraitObject {\n     pub vtable: *mut (),\n     pub data: *mut (),\n }\n+#[cfg(not(stage0))]\n+pub struct TraitObject {\n+    pub data: *(),\n+    pub vtable: *(),\n+}\n \n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values."}, {"sha": "8c55662f16395063dccb4c96df7a4f0e6bb3018b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -1623,7 +1623,6 @@ pub mod bytes {\n \n \n \n-\n //\n // Boilerplate traits\n //"}, {"sha": "0d7209b599970321fa0d7ba5df3f9e57d4f4d8d0", "filename": "src/libdebug/reflect.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibdebug%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibdebug%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Freflect.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -193,6 +193,8 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_estr_fixed(&mut self, n: uint,\n                         sz: uint,\n                         align: uint) -> bool {\n@@ -237,6 +239,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align(align);\n@@ -246,6 +249,16 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         self.bump(sz);\n         true\n     }\n+    #[cfg(not(stage0))]\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n+                        inner: *TyDesc) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_evec_fixed(n, sz, align, inner) {\n+            return false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n \n     fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);"}, {"sha": "c810e1f64737f5f8c27ed017760ef696e677dcfd", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -275,6 +275,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     // Type no longer exists, vestigial function.\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n                         _align: uint) -> bool { fail!(); }\n \n@@ -328,6 +330,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n                         _: uint, inner: *const TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n@@ -336,6 +340,16 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n+    #[cfg(not(stage0))]\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n+                        inner: *TyDesc) -> bool {\n+        let assumed_size = if sz == 0 { n } else { sz };\n+        self.get::<()>(|this, b| {\n+            this.write_vec_range(b, assumed_size, inner)\n+        })\n+    }\n+\n+\n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n         try!(self, self.writer.write([b'{']));"}, {"sha": "296615e15ffa065cc1081035dfbff1e806a4697c", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -112,7 +112,7 @@ impl Context {\n                 // the stack limit to 0 to make morestack never fail\n                 None => stack::record_rust_managed_stack_bounds(0, uint::MAX),\n             }\n-            rust_swap_registers(out_regs, in_regs)\n+            rust_swap_registers(out_regs, in_regs);\n         }\n     }\n }"}, {"sha": "265d1e37ec3892568628b420c65541ed0eb42c3a", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -302,7 +302,7 @@ extern {}\n /// A wrapper for a nullable pointer. Don't use this except for interacting\n /// with libc. Basically Option, but without the dependence on libstd.\n // If/when libprim happens, this can be removed in favor of that\n-pub enum Nullable<T> {\n+pub enum Nullable<type T> {\n     Null,\n     NotNull(T)\n }"}, {"sha": "b43ad1eabf90c9c690bc1bc2470a50149df1084a", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -49,7 +49,7 @@\n // implementations below. If pointer arithmetic is done through integers the\n // optimizations start to break down.\n extern \"rust-intrinsic\" {\n-    fn offset<T>(dst: *const T, offset: int) -> *const T;\n+    fn offset<type T>(dst: *const T, offset: int) -> *const T;\n }\n \n #[no_mangle]"}, {"sha": "9984aba8d08ab145d8126bcff240371e8a3df58c", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -477,13 +477,14 @@ fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n \n     box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprVstore(box(GC) ast::Expr {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprVec(cx.testfns.iter().map(|test| {\n-                mk_test_desc_and_fn_rec(cx, test)\n+        node: ast::ExprAddrOf(box(GC) ast::MutImmutable,\n+            box(GC) ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                node: ast::ExprVec(cx.testfns.borrow().iter().map(|test| {\n+                    mk_test_desc_and_fn_rec(cx, test)\n             }).collect()),\n             span: DUMMY_SP,\n-        }, ast::ExprVstoreSlice),\n+        }),\n         span: DUMMY_SP,\n     }\n }"}, {"sha": "6cc1c6a7b37dfac992bd341c49e059cf9275e27a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -1240,18 +1240,8 @@ impl LintPass for UnnecessaryAllocation {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        // Warn if string and vector literals with sigils, or boxing expressions,\n-        // are immediately borrowed.\n+        // Warn if boxing expressions are immediately borrowed.\n         let allocation = match e.node {\n-            ast::ExprVstore(e2, ast::ExprVstoreUniq) => {\n-                match e2.node {\n-                    ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n-                        VectorAllocation\n-                    }\n-                    ast::ExprVec(..) => VectorAllocation,\n-                    _ => return\n-                }\n-            }\n             ast::ExprUnary(ast::UnUniq, _) |\n             ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n \n@@ -1261,19 +1251,19 @@ impl LintPass for UnnecessaryAllocation {\n         match cx.tcx.adjustments.borrow().find(&e.id) {\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n+                    ty::AutoDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n                         match (allocation, autoref) {\n-                            (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n+                            (VectorAllocation, &Some(ty::AutoPtr(_, _, None))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                              \"unnecessary allocation, the sigil can be removed\");\n                             }\n                             (BoxAllocation,\n-                             Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n+                             &Some(ty::AutoPtr(_, ast::MutImmutable, None))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use & instead\");\n                             }\n                             (BoxAllocation,\n-                             Some(ty::AutoPtr(_, ast::MutMutable))) => {\n+                             &Some(ty::AutoPtr(_, ast::MutMutable, None))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use &mut instead\");\n                             }"}, {"sha": "2ef5675caa1779ed9c9ff953d0488f63d09a827b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -377,9 +377,9 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_rptr(st.tcx, r, mt);\n       }\n       'V' => {\n-        let mt = parse_mt(st, |x,y| conv(x,y));\n+        let t = parse_ty(st, |x,y| conv(x,y));\n         let sz = parse_size(st);\n-        return ty::mk_vec(st.tcx, mt, sz);\n+        return ty::mk_vec(st.tcx, t, sz);\n       }\n       'v' => {\n         return ty::mk_str(st.tcx);"}, {"sha": "84ee49c207b0f5e6f6a55b35b9459c1a9c0fddcb", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -254,9 +254,9 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_region(w, cx, r);\n             enc_mt(w, cx, mt);\n         }\n-        ty::ty_vec(mt, sz) => {\n+        ty::ty_vec(t, sz) => {\n             mywrite!(w, \"V\");\n-            enc_mt(w, cx, mt);\n+            enc_ty(w, cx, t);\n             mywrite!(w, \"/\");\n             match sz {\n                 Some(n) => mywrite!(w, \"{}|\", n),\n@@ -292,6 +292,9 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n         ty::ty_err => {\n             mywrite!(w, \"e\");\n         }\n+        ty::ty_open(_) => {\n+            cx.diag.handler().bug(\"unexpected type in enc_sty (ty_open)\");\n+        }\n     }\n }\n "}, {"sha": "260e38f20708fa97ccc5aefe4e0cedc72ab07f01", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 213, "deletions": 59, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -495,25 +495,7 @@ impl tr for def::Def {\n }\n \n // ______________________________________________________________________\n-// Encoding and decoding of adjustment information\n-\n-impl tr for ty::AutoDerefRef {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef {\n-        ty::AutoDerefRef {\n-            autoderefs: self.autoderefs,\n-            autoref: match self.autoref {\n-                Some(ref autoref) => Some(autoref.tr(xcx)),\n-                None => None\n-            }\n-        }\n-    }\n-}\n-\n-impl tr for ty::AutoRef {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::AutoRef {\n-        self.map_region(|r| r.tr(xcx))\n-    }\n-}\n+// Encoding and decoding of ancillary information\n \n impl tr for ty::Region {\n     fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::Region {\n@@ -961,6 +943,9 @@ trait rbml_writer_helpers {\n                      pty: ty::Polytype);\n     fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs);\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n+    fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef);\n+    fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef);\n+    fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind);\n }\n \n impl<'a> rbml_writer_helpers for Encoder<'a> {\n@@ -1035,16 +1020,85 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n \n                 ty::AutoDerefRef(ref auto_deref_ref) => {\n                     this.emit_enum_variant(\"AutoDerefRef\", 1, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| auto_deref_ref.encode(this))\n+                        this.emit_enum_variant_arg(0,\n+                            |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n                     })\n                 }\n+            }\n+        });\n+    }\n \n-                ty::AutoObject(store, b, def_id, ref substs) => {\n-                    this.emit_enum_variant(\"AutoObject\", 2, 4, |this| {\n-                        this.emit_enum_variant_arg(0, |this| store.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| b.encode(this));\n-                        this.emit_enum_variant_arg(2, |this| def_id.encode(this));\n-                        this.emit_enum_variant_arg(3, |this| Ok(this.emit_substs(ecx, substs)))\n+    fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef) {\n+        self.emit_enum(\"AutoRef\", |this| {\n+            match autoref {\n+                &ty::AutoPtr(r, m, None) => {\n+                    this.emit_enum_variant(\"AutoPtr\", 0, 3, |this| {\n+                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| m.encode(this));\n+                        this.emit_enum_variant_arg(2,\n+                            |this| this.emit_option(|this| this.emit_option_none()))\n+                    })\n+                }\n+                &ty::AutoPtr(r, m, Some(box ref a)) => {\n+                    this.emit_enum_variant(\"AutoPtr\", 0, 3, |this| {\n+                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| m.encode(this));\n+                        this.emit_enum_variant_arg(2, |this| this.emit_option(\n+                            |this| this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a)))))\n+                    })\n+                }\n+                &ty::AutoUnsize(ref uk) => {\n+                    this.emit_enum_variant(\"AutoUnsize\", 1, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)))\n+                    })\n+                }\n+                &ty::AutoUnsizeUniq(ref uk) => {\n+                    this.emit_enum_variant(\"AutoUnsizeUniq\", 2, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)))\n+                    })\n+                }\n+                &ty::AutoUnsafe(m) => {\n+                    this.emit_enum_variant(\"AutoUnsafe\", 3, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| m.encode(this))\n+                    })\n+                }\n+            }\n+        });\n+    }\n+\n+    fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef) {\n+        self.emit_struct(\"AutoDerefRef\", 2, |this| {\n+            this.emit_struct_field(\"autoderefs\", 0, |this| auto_deref_ref.autoderefs.encode(this));\n+            this.emit_struct_field(\"autoref\", 1, |this| {\n+                this.emit_option(|this| {\n+                    match auto_deref_ref.autoref {\n+                        None => this.emit_option_none(),\n+                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a))),\n+                    }\n+                })\n+            })\n+        });\n+    }\n+\n+    fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind) {\n+        self.emit_enum(\"UnsizeKind\", |this| {\n+            match *uk {\n+                ty::UnsizeLength(len) => {\n+                    this.emit_enum_variant(\"UnsizeLength\", 0, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| len.encode(this))\n+                    })\n+                }\n+                ty::UnsizeStruct(box ref uk, idx) => {\n+                    this.emit_enum_variant(\"UnsizeStruct\", 1, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)));\n+                        this.emit_enum_variant_arg(1, |this| idx.encode(this))\n+                    })\n+                }\n+                ty::UnsizeVtable(b, def_id, ref substs) => {\n+                    this.emit_enum_variant(\"UnsizeVtable\", 2, 3, |this| {\n+                        this.emit_enum_variant_arg(0, |this| b.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| def_id.encode(this));\n+                        this.emit_enum_variant_arg(2, |this| Ok(this.emit_substs(ecx, substs)))\n                     })\n                 }\n             }\n@@ -1227,9 +1281,30 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &adj in tcx.adjustments.borrow().find(&id).iter() {\n-        match *adj {\n-            ty::AutoDerefRef(adj) => {\n+    for &adjustment in tcx.adjustments.borrow().find(&id).iter() {\n+        match *adjustment {\n+            _ if ty::adjust_is_object(adjustment) => {\n+                let method_call = MethodCall::autoobject(id);\n+                for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+                    rbml_w.tag(c::tag_table_method_map, |ebml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n+                        })\n+                    })\n+                }\n+\n+                for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n+                    rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+                        rbml_w.id(id);\n+                        rbml_w.tag(c::tag_table_val, |ebml_w| {\n+                            encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n+                        })\n+                    })\n+                }\n+            }\n+            ty::AutoDerefRef(ref adj) => {\n+                assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n                     for &method in tcx.method_map.borrow().find(&method_call).iter() {\n@@ -1253,27 +1328,9 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     }\n                 }\n             }\n-            ty::AutoObject(..) => {\n-                let method_call = MethodCall::autoobject(id);\n-                for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-                    rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n-                        })\n-                    })\n-                }\n-\n-                for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                    rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n-                        })\n-                    })\n-                }\n+            _ => {\n+                assert!(!ty::adjust_is_object(adjustment));\n             }\n-            _ => {}\n         }\n \n         rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n@@ -1321,6 +1378,9 @@ trait rbml_decoder_decoder_helpers {\n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n     fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n                             -> ty::UnboxedClosure;\n+    fn read_auto_deref_ref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef;\n+    fn read_autoref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoRef;\n+    fn read_unsize_kind(&mut self, xcx: &ExtendedDecodeContext) -> ty::UnsizeKind;\n     fn convert_def_id(&mut self,\n                       xcx: &ExtendedDecodeContext,\n                       source: DefIdSource,\n@@ -1460,34 +1520,128 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment {\n         self.read_enum(\"AutoAdjustment\", |this| {\n-            let variants = [\"AutoAddEnv\", \"AutoDerefRef\", \"AutoObject\"];\n+            let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n                         let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty:: AutoAddEnv(store.tr(xcx))\n+                        ty::AutoAddEnv(store.tr(xcx))\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n+                            this.read_enum_variant_arg(0,\n+                                |this| Ok(this.read_auto_deref_ref(xcx))).unwrap();\n+\n+                        ty::AutoDerefRef(auto_deref_ref)\n+                    }\n+                    _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n+                })\n+            })\n+        }).unwrap()\n+    }\n+\n+    fn read_auto_deref_ref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef {\n+        self.read_struct(\"AutoDerefRef\", 2, |this| {\n+            Ok(ty::AutoDerefRef {\n+                autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n+                    Decodable::decode(this)\n+                }).unwrap(),\n+                autoref: this.read_struct_field(\"autoref\", 1, |this| {\n+                    this.read_option(|this, b| {\n+                        if b {\n+                            Ok(Some(this.read_autoref(xcx)))\n+                        } else {\n+                            Ok(None)\n+                        }\n+                    })\n+                }).unwrap(),\n+            })\n+        }).unwrap()\n+    }\n+\n+    fn read_autoref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoRef {\n+        self.read_enum(\"AutoRef\", |this| {\n+            let variants = [\"AutoPtr\",\n+                            \"AutoUnsize\",\n+                            \"AutoUnsizeUniq\",\n+                            \"AutoUnsafe\"];\n+            this.read_enum_variant(variants, |this, i| {\n+                Ok(match i {\n+                    0 => {\n+                        let r: ty::Region =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n+                        let m: ast::Mutability =\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+                        let a: Option<Box<ty::AutoRef>> =\n+                            this.read_enum_variant_arg(2, |this| this.read_option(|this, b| {\n+                                if b {\n+                                    Ok(Some(box this.read_autoref(xcx)))\n+                                } else {\n+                                    Ok(None)\n+                                }\n+                            })).unwrap();\n+\n+                        ty::AutoPtr(r.tr(xcx), m, a)\n+                    }\n+                    1 => {\n+                        let uk: ty::UnsizeKind =\n+                            this.read_enum_variant_arg(0,\n+                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n \n-                        ty::AutoDerefRef(auto_deref_ref.tr(xcx))\n+                        ty::AutoUnsize(uk)\n                     }\n                     2 => {\n-                        let store: ty::TraitStore =\n+                        let uk: ty::UnsizeKind =\n+                            this.read_enum_variant_arg(0,\n+                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+\n+                        ty::AutoUnsizeUniq(uk)\n+                    }\n+                    3 => {\n+                        let m: ast::Mutability =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-                        let b: ty::BuiltinBounds =\n+\n+                        ty::AutoUnsafe(m)\n+                    }\n+                    _ => fail!(\"bad enum variant for ty::AutoRef\")\n+                })\n+            })\n+        }).unwrap()\n+    }\n+\n+    fn read_unsize_kind(&mut self, xcx: &ExtendedDecodeContext) -> ty::UnsizeKind {\n+        self.read_enum(\"UnsizeKind\", |this| {\n+            let variants = [\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n+            this.read_enum_variant(variants, |this, i| {\n+                Ok(match i {\n+                    0 => {\n+                        let len: uint =\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n+\n+                        ty::UnsizeLength(len)\n+                    }\n+                    1 => {\n+                        let uk: ty::UnsizeKind =\n+                            this.read_enum_variant_arg(0,\n+                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+                        let idx: uint =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+\n+                        ty::UnsizeStruct(box uk, idx)\n+                    }\n+                    2 => {\n+                        let b: ty::BuiltinBounds =\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n                         let def_id: ast::DefId =\n-                            this.read_enum_variant_arg(2, |this| Decodable::decode(this)).unwrap();\n-                        let substs = this.read_enum_variant_arg(3, |this| Ok(this.read_substs(xcx)))\n-                                    .unwrap();\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+                        let substs = this.read_enum_variant_arg(2,\n+                            |this| Ok(this.read_substs(xcx))).unwrap();\n \n-                        ty::AutoObject(store.tr(xcx), b, def_id.tr(xcx), substs)\n+                        ty::UnsizeVtable(b, def_id.tr(xcx), substs)\n                     }\n-                    _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n+                    _ => fail!(\"bad enum variant for ty::UnsizeKind\")\n                 })\n             })\n         }).unwrap()"}, {"sha": "230786924d7c4139352550f9c053e1950a493ac2", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -428,16 +428,15 @@ impl<'a> BorrowckCtxt<'a> {\n                                adj: &ty::AutoAdjustment)\n                                -> mc::cmt {\n         let r = match *adj {\n-            ty::AutoAddEnv(..) | ty::AutoObject(..) => {\n-                // no autoderefs\n-                self.mc().cat_expr_unadjusted(expr)\n-            }\n-\n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs, ..}) => {\n                 self.mc().cat_expr_autoderefd(expr, autoderefs)\n             }\n+            ty::AutoAddEnv(..) => {\n+                // no autoderefs\n+                self.mc().cat_expr_unadjusted(expr)\n+            }\n         };\n \n         match r {"}, {"sha": "0d77b01d9706dc22db8f99aba6fc80a504f88b4a", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -465,7 +465,6 @@ impl<'a> CFGBuilder<'a> {\n             ast::ExprCast(e, _) |\n             ast::ExprUnary(_, e) |\n             ast::ExprParen(e) |\n-            ast::ExprVstore(e, _) |\n             ast::ExprField(e, _, _) => {\n                 self.straightline(expr, pred, [e])\n             }"}, {"sha": "b0b2fe89c3f0fa9a834619e650b82cf21e7bb3ec", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -62,7 +62,7 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n     fn is_str(e: &Expr) -> bool {\n         match e.node {\n-            ExprVstore(expr, ExprVstoreUniq) => {\n+            ExprBox(_, expr) => {\n                 match expr.node {\n                     ExprLit(lit) => ast_util::lit_is_str(lit),\n                     _ => false,\n@@ -169,8 +169,6 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                 None => {}\n             }\n           }\n-          ExprVstore(_, ExprVstoreMutSlice) |\n-          ExprVstore(_, ExprVstoreSlice) |\n           ExprVec(_) |\n           ExprAddrOf(MutImmutable, _) |\n           ExprParen(..) |\n@@ -179,13 +177,14 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n           ExprTup(..) |\n           ExprRepeat(..) |\n           ExprStruct(..) => { }\n-          ExprAddrOf(..) => {\n-              span_err!(v.tcx.sess, e.span, E0017,\n-                  \"references in constants may only refer to immutable values\");\n-          },\n-          ExprVstore(_, ExprVstoreUniq) => {\n-              span_err!(v.tcx.sess, e.span, E0018,\n-                  \"cannot allocate vectors in constant expressions\");\n+          ExprAddrOf(_, inner) => {\n+                match inner.node {\n+                    // Mutable slices are allowed.\n+                    ExprVec(_) => {}\n+                    _ => span_err!(v.tcx.sess, e.span, E0017,\n+                                   \"references in constants may only refer to immutable values\");\n+\n+                }\n           },\n \n           _ => {"}, {"sha": "042a5b8f60aaf80a1e4be1400065cd5f815c63a0", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -107,21 +107,19 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n \n         match e.node {\n             ast::ExprField(..) | ast::ExprVec(..) |\n-            ast::ExprBlock(..) | ast::ExprTup(..) |\n-            ast::ExprVstore(_, ast::ExprVstoreSlice) => {\n+            ast::ExprBlock(..) | ast::ExprTup(..)  => {\n                 visit::walk_expr(self, e, is_const);\n             }\n-            ast::ExprVstore(_, ast::ExprVstoreMutSlice) => {\n+            ast::ExprAddrOf(ast::MutMutable, _) => {\n                 span_err!(self.tcx.sess, e.span, E0020,\n                     \"static items are not allowed to have mutable slices\");\n-           },\n+            },\n             ast::ExprUnary(ast::UnBox, _) => {\n                 span_err!(self.tcx.sess, e.span, E0021,\n                     \"static items are not allowed to have managed pointers\");\n             }\n             ast::ExprBox(..) |\n-            ast::ExprUnary(ast::UnUniq, _) |\n-            ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n+            ast::ExprUnary(ast::UnUniq, _) => {\n                 span_err!(self.tcx.sess, e.span, E0022,\n                     \"static items are not allowed to have custom pointers\");\n             }"}, {"sha": "03a7021b70d0b57a94622ed8abf7f01274517149", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -206,14 +206,6 @@ impl<'a> ConstEvalVisitor<'a> {\n             ast::ExprVec(ref es) =>\n                 join_all(es.iter().map(|e| self.classify(&**e))),\n \n-            ast::ExprVstore(ref e, vstore) => {\n-                match vstore {\n-                    ast::ExprVstoreSlice => self.classify(&**e),\n-                    ast::ExprVstoreUniq |\n-                    ast::ExprVstoreMutSlice => non_const\n-                }\n-            }\n-\n             ast::ExprStruct(_, ref fs, None) => {\n                 let cs = fs.iter().map(|f| self.classify(&*f.expr));\n                 join_all(cs)\n@@ -554,8 +546,6 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           }\n       }\n       ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n-      // If we have a vstore, just keep going; it has to be a string\n-      ExprVstore(ref e, _) => eval_const_expr_partial(tcx, &**e),\n       ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n       ExprBlock(ref block) => {\n         match block.expr {"}, {"sha": "67ee5c5e4be55325921c47d1c0d730e94bfbf9d4", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -474,10 +474,6 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 self.walk_captures(expr)\n             }\n \n-            ast::ExprVstore(ref base, _) => {\n-                self.consume_expr(&**base);\n-            }\n-\n             ast::ExprBox(ref place, ref base) => {\n                 self.consume_expr(&**place);\n                 self.consume_expr(&**base);\n@@ -672,11 +668,10 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n             None => { }\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoAddEnv(..) |\n-                    ty::AutoObject(..) => {\n-                        // Creating an object or closure consumes the\n-                        // input and stores it into the resulting rvalue.\n-                        debug!(\"walk_adjustment(AutoAddEnv|AutoObject)\");\n+                    ty::AutoAddEnv(..) => {\n+                        // Creating a closure consumes the input and stores it\n+                        // into the resulting rvalue.\n+                        debug!(\"walk_adjustment(AutoAddEnv)\");\n                         let cmt_unadjusted =\n                             return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n@@ -735,42 +730,39 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_autoref(&mut self,\n                     expr: &ast::Expr,\n                     autoref: &ty::AutoRef,\n-                    autoderefs: uint) {\n-        debug!(\"walk_autoref expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n+                    n: uint) {\n+        debug!(\"walk_autoref expr={}\", expr.repr(self.tcx()));\n \n-        let cmt_derefd = return_if_err!(\n-            self.mc.cat_expr_autoderefd(expr, autoderefs));\n+        // Match for unique trait coercions first, since we don't need the\n+        // call to cat_expr_autoderefd.\n+        match *autoref {\n+            ty::AutoUnsizeUniq(ty::UnsizeVtable(..)) |\n+            ty::AutoUnsize(ty::UnsizeVtable(..)) => {\n+                assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n+                                         AutoRefs, found: {}\", n));\n+                let cmt_unadjusted =\n+                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+                return;\n+            }\n+            _ => {}\n+        }\n \n-        debug!(\"walk_autoref: cmt_derefd={}\", cmt_derefd.repr(self.tcx()));\n+        let cmt_derefd = return_if_err!(\n+            self.mc.cat_expr_autoderefd(expr, n));\n+        debug!(\"walk_adjustment: cmt_derefd={}\",\n+               cmt_derefd.repr(self.tcx()));\n \n         match *autoref {\n-            ty::AutoPtr(r, m) => {\n+            ty::AutoPtr(r, m, _) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_derefd,\n                                      r,\n                                      ty::BorrowKind::from_mutbl(m),\n-                                     AutoRef)\n-            }\n-            ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n-                let cmt_index = self.mc.cat_index(expr, cmt_derefd, autoderefs+1);\n-                self.delegate.borrow(expr.id,\n-                                     expr.span,\n-                                     cmt_index,\n-                                     r,\n-                                     ty::BorrowKind::from_mutbl(m),\n-                                     AutoRef)\n-            }\n-            ty::AutoBorrowObj(r, m) => {\n-                let cmt_deref = self.mc.cat_deref_obj(expr, cmt_derefd);\n-                self.delegate.borrow(expr.id,\n-                                     expr.span,\n-                                     cmt_deref,\n-                                     r,\n-                                     ty::BorrowKind::from_mutbl(m),\n-                                     AutoRef)\n+                                     AutoRef);\n             }\n-            ty::AutoUnsafe(_) => {}\n+            ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) | ty::AutoUnsafe(_) => {}\n         }\n     }\n "}, {"sha": "b96a75cba94800cd136e98b96d5ccc97e0d5cb1e", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -405,14 +405,27 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                            \"repeated element will be copied\");\n             }\n         }\n+        ExprAssign(ref lhs, _) |\n+        ExprAssignOp(_, ref lhs, _) => {\n+            let lhs_ty = ty::expr_ty(cx.tcx, &**lhs);\n+            if !ty::type_is_sized(cx.tcx, lhs_ty) {\n+                cx.tcx.sess.span_err(lhs.span, \"dynamically sized type on lhs of assignment\");\n+            }\n+        }\n+        ExprStruct(..) => {\n+            let e_ty = ty::expr_ty(cx.tcx, e);\n+            if !ty::type_is_sized(cx.tcx, e_ty) {\n+                cx.tcx.sess.span_err(e.span, \"trying to initialise a dynamically sized struct\");\n+            }\n+        }\n         _ => {}\n     }\n \n     // Search for auto-adjustments to find trait coercions.\n     match cx.tcx.adjustments.borrow().find(&e.id) {\n         Some(adjustment) => {\n-            match *adjustment {\n-                ty::AutoObject(..) => {\n+            match adjustment {\n+                adj if ty::adjust_is_object(adj) => {\n                     let source_ty = ty::expr_ty(cx.tcx, e);\n                     let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n                     let method_call = MethodCall {\n@@ -425,8 +438,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                                      e.span,\n                                      method_call);\n                 }\n-                ty::AutoAddEnv(..) |\n-                ty::AutoDerefRef(..) => {}\n+                _ => {}\n             }\n         }\n         None => {}"}, {"sha": "38288bf301161b735c4be0c7c05d0e82af12cd0e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -511,7 +511,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n \n       // otherwise, live nodes are not required:\n-      ExprIndex(..) | ExprField(..) | ExprVstore(..) | ExprVec(..) |\n+      ExprIndex(..) | ExprField(..) | ExprVec(..) |\n       ExprCall(..) | ExprMethodCall(..) | ExprTup(..) |\n       ExprBinary(..) | ExprAddrOf(..) |\n       ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n@@ -1119,10 +1119,6 @@ impl<'a> Liveness<'a> {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          ExprVstore(ref expr, _) => {\n-            self.propagate_through_expr(&**expr, succ)\n-          }\n-\n           ExprVec(ref exprs) => {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n@@ -1449,8 +1445,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       // no correctness conditions related to liveness\n       ExprCall(..) | ExprMethodCall(..) | ExprIf(..) | ExprMatch(..) |\n       ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n-      ExprVstore(..) | ExprVec(..) | ExprTup(..) |\n-      ExprBinary(..) |\n+      ExprVec(..) | ExprTup(..) | ExprBinary(..) |\n       ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n       ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |"}, {"sha": "155b69d0a84c2749118c500c5939ea8c296dc7f5", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -205,7 +205,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n-        ty::ty_vec(_, Some(_)) => {\n+        ty::ty_vec(_, _) | ty::ty_str => {\n             Some(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n@@ -214,11 +214,12 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n }\n \n pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n+    debug!(\"deref_kind {}\", ty_to_str(tcx, t));\n     match opt_deref_kind(t) {\n       Some(k) => k,\n       None => {\n         tcx.sess.bug(\n-            format!(\"deref_cat() invoked on non-derefable type {}\",\n+            format!(\"deref_kind() invoked on non-derefable type {}\",\n                     ty_to_string(tcx, t)).as_slice());\n       }\n     }\n@@ -411,13 +412,6 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoObject(..) => {\n-                        // Implicitly cast a concrete object to trait object.\n-                        // Result is an rvalue.\n-                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n-                    }\n-\n                     ty::AutoAddEnv(..) => {\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n@@ -485,7 +479,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                 }\n                 None => {\n                     let base_cmt = if_ok!(self.cat_expr(&**base));\n-                    Ok(self.cat_index(expr, base_cmt, 0))\n+                    Ok(self.cat_index(expr, base_cmt))\n                 }\n             }\n           }\n@@ -504,7 +498,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           ast::ExprFnBlock(..) | ast::ExprProc(..) |\n           ast::ExprUnboxedFn(..) | ast::ExprRet(..) |\n           ast::ExprUnary(..) |\n-          ast::ExprMethodCall(..) | ast::ExprCast(..) | ast::ExprVstore(..) |\n+          ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprBinary(..) | ast::ExprWhile(..) |\n           ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n@@ -703,7 +697,10 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                            -> cmt {\n         match self.typer.temporary_scope(id) {\n             Some(scope) => {\n-                self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n+                match ty::get(expr_ty).sty {\n+                    ty::ty_vec(_, Some(0)) => self.cat_rvalue(id, span, ty::ReStatic, expr_ty),\n+                    _ => self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n+                }\n             }\n             None => {\n                 self.cat_rvalue(id, span, ty::ReStatic, expr_ty)\n@@ -751,10 +748,11 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                              implicit: bool)\n                              -> cmt {\n         let adjustment = match self.typer.adjustments().borrow().find(&node.id()) {\n-            Some(&ty::AutoObject(..)) => typeck::AutoObject,\n+            Some(adj) if ty::adjust_is_object(adj) => typeck::AutoObject,\n             _ if deref_cnt != 0 => typeck::AutoDeref(deref_cnt),\n             _ => typeck::NoAdjustment\n         };\n+\n         let method_call = typeck::MethodCall {\n             expr_id: node.id(),\n             adjustment: adjustment\n@@ -820,13 +818,9 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n-                                 mut base_cmt: cmt,\n-                                 derefs: uint)\n+                                 mut base_cmt: cmt)\n                                  -> cmt {\n-        //! Creates a cmt for an indexing operation (`[]`); this\n-        //! indexing operation may occurs as part of an\n-        //! AutoBorrowVec, which when converting a `~[]` to an `&[]`\n-        //! effectively takes the address of the 0th element.\n+        //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n         //! immediately obvious: for anything other than a fixed-length\n@@ -839,20 +833,9 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         //! cmt containing both this deref and the indexing,\n         //! presuming that `base_cmt` is not of fixed-length type.\n         //!\n-        //! In the event that a deref is needed, the \"deref count\"\n-        //! is taken from the parameter `derefs`. See the comment\n-        //! on the def'n of `root_map_key` in borrowck/mod.rs\n-        //! for more details about deref counts; the summary is\n-        //! that `derefs` should be 0 for an explicit indexing\n-        //! operation and N+1 for an indexing that is part of\n-        //! an auto-adjustment, where N is the number of autoderefs\n-        //! in that adjustment.\n-        //!\n         //! # Parameters\n         //! - `elt`: the AST node being indexed\n         //! - `base_cmt`: the cmt of `elt`\n-        //! - `derefs`: the deref number to be used for\n-        //!   the implicit index deref, if any (see above)\n \n         let method_call = typeck::MethodCall::expr(elt.id());\n         let method_ty = self.typer.node_method_ty(method_call);\n@@ -865,7 +848,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             }\n             None => {\n                 match ty::array_element_ty(base_cmt.ty) {\n-                    Some(ref mt) => mt.ty,\n+                    Some(ty) => ty,\n                     None => {\n                         self.tcx().sess.span_bug(\n                             elt.span(),\n@@ -876,30 +859,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             }\n         };\n \n-        return match deref_kind(self.tcx(), base_cmt.ty) {\n-          deref_ptr(ptr) => {\n-            // for unique ptrs, we inherit mutability from the\n-            // owning reference.\n-            let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n-\n-            // the deref is explicit in the resulting cmt\n-            let deref_cmt = Rc::new(cmt_ {\n-                id:elt.id(),\n-                span:elt.span(),\n-                cat:cat_deref(base_cmt.clone(), derefs, ptr),\n-                mutbl:m,\n-                ty:element_ty\n-            });\n-\n-            interior(elt, deref_cmt, base_cmt.ty, m.inherit(), element_ty)\n-          }\n-\n-          deref_interior(_) => {\n-            // fixed-length vectors have no deref\n-            let m = base_cmt.mutbl.inherit();\n-            interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty)\n-          }\n-        };\n+        let m = base_cmt.mutbl.inherit();\n+        return interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty);\n \n         fn interior<N: ast_node>(elt: &N,\n                                  of_cmt: cmt,\n@@ -917,6 +878,37 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         }\n     }\n \n+    // Takes either a vec or a reference to a vec and returns the cmt for the\n+    // underlying vec.\n+    fn deref_vec<N:ast_node>(&self,\n+                             elt: &N,\n+                             base_cmt: cmt)\n+                             -> cmt {\n+        match deref_kind(self.tcx(), base_cmt.ty) {\n+            deref_ptr(ptr) => {\n+                // for unique ptrs, we inherit mutability from the\n+                // owning reference.\n+                let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n+\n+                // the deref is explicit in the resulting cmt\n+                Rc::new(cmt_ {\n+                    id:elt.id(),\n+                    span:elt.span(),\n+                    cat:cat_deref(base_cmt.clone(), 0, ptr),\n+                    mutbl:m,\n+                    ty: match ty::deref(base_cmt.ty, false) {\n+                        Some(mt) => mt.ty,\n+                        None => self.tcx().sess.bug(\"Found non-derefable type\")\n+                    }\n+                })\n+            }\n+\n+            deref_interior(_) => {\n+                base_cmt\n+            }\n+        }\n+    }\n+\n     pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt,\n                              slice_pat: &ast::Pat)\n@@ -935,7 +927,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n                                                     slice_ty);\n-        let cmt_slice = self.cat_index(slice_pat, vec_cmt, 0);\n+        let cmt_slice = self.cat_index(slice_pat, self.deref_vec(slice_pat, vec_cmt));\n         return Ok((cmt_slice, slice_mutbl, slice_r));\n \n         fn vec_slice_info(tcx: &ty::ctxt,\n@@ -951,7 +943,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n             match ty::get(slice_ty).sty {\n                 ty::ty_rptr(r, ref mt) => match ty::get(mt.ty).sty {\n-                    ty::ty_vec(slice_mt, None) => (slice_mt.mutbl, r),\n+                    ty::ty_vec(_, None) => (mt.mutbl, r),\n                     _ => vec_slice_info(tcx, pat, mt.ty),\n                 },\n \n@@ -1143,7 +1135,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatVec(ref before, slice, ref after) => {\n-              let elt_cmt = self.cat_index(pat, cmt, 0);\n+              let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n               for before_pat in before.iter() {\n                   if_ok!(self.cat_pattern(elt_cmt.clone(), &**before_pat,\n                                           |x,y,z| op(x,y,z)));"}, {"sha": "1a884eaea2132276e5021199296231673815c02b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -740,10 +740,6 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n                         visitor, &*field.expr, blk_id);\n                 }\n             }\n-            ast::ExprVstore(ref subexpr, _) => {\n-                visitor.region_maps.record_rvalue_scope(subexpr.id, blk_id);\n-                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n-            }\n             ast::ExprVec(ref subexprs) |\n             ast::ExprTup(ref subexprs) => {\n                 for subexpr in subexprs.iter() {"}, {"sha": "4a26d4f800210e7d02e7cf612a8c2230919eeec2", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -289,8 +289,8 @@ fn trans_opt<'a>(mut bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n             return adt::trans_case(bcx, &**repr, disr_val);\n         }\n         range(ref l1, ref l2) => {\n-            let (l1, _) = consts::const_expr(ccx, &**l1, true);\n-            let (l2, _) = consts::const_expr(ccx, &**l2, true);\n+            let (l1, _, _) = consts::const_expr(ccx, &**l1, true);\n+            let (l2, _, _) = consts::const_expr(ccx, &**l2, true);\n             return range_result(Result::new(bcx, l1), Result::new(bcx, l2));\n         }\n         vec_len(n, vec_len_eq, _) => {\n@@ -692,7 +692,7 @@ fn extract_vec_elems<'a>(\n     let vec_datum = match_datum(bcx, val, pat_id);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n     let vec_ty = node_id_type(bcx, pat_id);\n-    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n+    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty)));\n \n     let mut elems = Vec::from_fn(elem_count, |i| {\n         match slice {\n@@ -863,7 +863,7 @@ fn compare_values<'a>(\n     match ty::get(rhs_t).sty {\n         ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n-            ty::ty_vec(mt, _) => match ty::get(mt.ty).sty {\n+            ty::ty_vec(ty, _) => match ty::get(ty).sty {\n                 ty::ty_uint(ast::TyU8) => {\n                     // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n                     // which calls memcmp()."}, {"sha": "3bcefe7ec9dbbf9285cabf795c151e7abb6aaef4", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -127,8 +127,11 @@ pub enum Repr {\n \n /// For structs, and struct-like parts of anything fancier.\n pub struct Struct {\n-    pub size: u64,\n-    pub align: u64,\n+    // If the struct is DST, then we will not know its size. We must be careful\n+    // never to use such a struct when a fixed size is required (e.g., stack\n+    // allocation).\n+    pub size: Option<u64>,\n+    pub align: Option<u64>,\n     pub packed: bool,\n     pub fields: Vec<ty::t>\n }\n@@ -265,7 +268,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 mk_struct(cx, ftys.as_slice(), false)\n             }).collect(), dtor);\n         }\n-        _ => cx.sess().bug(\"adt::represent_type called on non-ADT type\")\n+        _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n+                           ty_to_str(cx.tcx(), t)).as_slice())\n     }\n }\n \n@@ -284,8 +288,9 @@ pub enum PointerField {\n \n impl Case {\n     fn is_zerolen(&self, cx: &CrateContext) -> bool {\n-        mk_struct(cx, self.tys.as_slice(), false).size == 0\n+        mk_struct(cx, self.tys.as_slice(), false).size.unwrap() == 0\n     }\n+\n     fn find_ptr(&self) -> Option<PointerField> {\n         use back::abi::{fn_field_code, slice_elt_base, trt_field_box};\n \n@@ -342,13 +347,22 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<\n }\n \n fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n-    let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n-    let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n-    Struct {\n-        size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n-        align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n-        packed: packed,\n-        fields: Vec::from_slice(tys),\n+    if tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty)) {\n+        let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n+        let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n+        Struct {\n+            size: Some(machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64),\n+            align: Some(machine::llalign_of_min(cx, llty_rec) /*bad*/as u64),\n+            packed: packed,\n+            fields: Vec::from_slice(tys),\n+        }\n+    } else {\n+        Struct {\n+            size: None,\n+            align: None,\n+            packed: packed,\n+            fields: Vec::from_slice(tys),\n+        }        \n     }\n }\n \n@@ -496,9 +510,9 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let size = sts.iter().map(|st| st.size).max().unwrap();\n-            let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n-            let align = most_aligned.align;\n+            let size = sts.iter().map(|st| st.size.unwrap()).max().unwrap();\n+            let most_aligned = sts.iter().max_by(|st| st.align.unwrap()).unwrap();\n+            let align = most_aligned.align.unwrap();\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty) as u64;\n             let align_units = (size + align - 1) / align - 1;\n@@ -892,12 +906,12 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n         }\n         General(ity, ref cases, _) => {\n             let case = cases.get(discr as uint);\n-            let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n+            let max_sz = cases.iter().map(|x| x.size.unwrap()).max().unwrap();\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let contents = build_const_struct(ccx,\n                                               case,\n                                               (vec!(lldiscr)).append(vals).as_slice());\n-            C_struct(ccx, contents.append([padding(ccx, max_sz - case.size)]).as_slice(),\n+            C_struct(ccx, contents.append([padding(ccx, max_sz - case.size.unwrap())]).as_slice(),\n                      false)\n         }\n         Univariant(ref st, _dro) => {\n@@ -988,9 +1002,9 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n         offset += machine::llsize_of_alloc(ccx, val_ty(val)) as u64;\n     }\n \n-    assert!(offset <= st.size);\n-    if offset != st.size {\n-        cfields.push(padding(ccx, st.size - offset));\n+    assert!(offset <= st.size.unwrap());\n+    if offset != st.size.unwrap() {\n+        cfields.push(padding(ccx, st.size.unwrap() - offset));\n     }\n \n     cfields"}, {"sha": "b27afdb864b977dbc938bd5669c8b91f4f7d0328", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -195,16 +195,6 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n                                                llvm::NoReturnAttribute as uint64_t)\n             }\n         }\n-        // `~` pointer return values never alias because ownership is transferred\n-        ty::ty_uniq(t)\n-            => match ty::get(t).sty {\n-                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => {}\n-                _ => unsafe {\n-                    llvm::LLVMAddReturnAttribute(llfn,\n-                                                 lib::llvm::NoAliasAttribute as c_uint,\n-                                                 lib::llvm::NoReturnAttribute as uint64_t);\n-                }\n-            },\n         _ => {}\n     }\n \n@@ -965,14 +955,23 @@ pub fn invoke<'a>(\n               llfn: ValueRef,\n               llargs: Vec<ValueRef> ,\n               fn_ty: ty::t,\n-              call_info: Option<NodeInfo>)\n+              call_info: Option<NodeInfo>,\n+              // FIXME(15064) is_lang_item is a horrible hack, please remove it\n+              // at the soonest opportunity.\n+              is_lang_item: bool)\n               -> (ValueRef, &'a Block<'a>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n-    let attributes = get_fn_llvm_attributes(bcx.ccx(), fn_ty);\n+    // FIXME(15064) Lang item methods may (in the reflect case) not have proper\n+    // types, so doing an attribute lookup will fail.\n+    let attributes = if is_lang_item {\n+        Vec::new()\n+    } else {\n+        get_fn_llvm_attributes(bcx.ccx(), fn_ty)\n+    };\n \n     match bcx.opt_node_id {\n         None => {\n@@ -2311,9 +2310,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         match ty::get(ret_ty).sty {\n             // `~` pointer return values never alias because ownership\n             // is transferred\n-            ty::ty_uniq(it) if match ty::get(it).sty {\n-                ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n-            } => {}\n+            ty::ty_uniq(it) if !ty::type_is_sized(ccx.tcx(), it) => {}\n             ty::ty_uniq(_) => {\n                 attrs.ret(llvm::NoAliasAttribute);\n             }\n@@ -2324,9 +2321,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         match ty::get(ret_ty).sty {\n             // These are not really pointers but pairs, (pointer, len)\n             ty::ty_uniq(it) |\n-            ty::ty_rptr(_, ty::mt { ty: it, .. }) if match ty::get(it).sty {\n-                ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n-            } => {}\n+            ty::ty_rptr(_, ty::mt { ty: it, .. }) if !ty::type_is_sized(ccx.tcx(), it) => {}\n             ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n                 let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n                 attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n@@ -2593,7 +2588,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n-                    let (v, inlineable) = consts::const_expr(ccx, &**expr, is_local);\n+                    let (v, inlineable, _) = consts::const_expr(ccx, &**expr, is_local);\n                     ccx.const_values.borrow_mut().insert(id, v);\n                     let mut inlineable = inlineable;\n "}, {"sha": "1283cc19528a622d07960ef106185c9a261d95b2", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -51,6 +51,7 @@ use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n+use util::ppaux::ty_to_string;\n \n use std::gc::Gc;\n use syntax::abi as synabi;\n@@ -853,7 +854,8 @@ pub fn trans_call_inner<'a>(\n                                       llfn,\n                                       llargs,\n                                       callee_ty,\n-                                      call_info);\n+                                      call_info,\n+                                      dest.is_none());\n         bcx = b;\n         llresult = llret;\n \n@@ -1194,6 +1196,8 @@ pub fn trans_arg_datum<'a>(\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n             debug!(\"casting actual type ({}) to match formal ({})\",\n                    bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n+            debug!(\"Rust types: {}; {}\", ty_to_string(bcx.tcx(), arg_datum_ty),\n+                                         ty_to_string(bcx.tcx(), formal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);\n         }\n     }"}, {"sha": "f0876442ff5ae950a6b8070cb4c7f6a49dcde498", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -65,12 +65,13 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     use middle::trans::machine::llsize_of_alloc;\n     use middle::trans::type_of::sizing_type_of;\n+\n     let tcx = ccx.tcx();\n     let simple = ty::type_is_scalar(ty) || ty::type_is_boxed(ty) ||\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n         type_is_newtype_immediate(ccx, ty) || ty::type_is_bot(ty) ||\n         ty::type_is_simd(tcx, ty);\n-    if simple && !ty::type_is_trait(ty) {\n+    if simple && !ty::type_is_fat_ptr(tcx, ty) {\n         return true;\n     }\n     match ty::get(ty).sty {"}, {"sha": "e65a10b3bb243f319ba4d1071a346ba97e76238d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 96, "deletions": 98, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -11,11 +11,9 @@\n \n use back::abi;\n use llvm;\n-use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True,\n-    False};\n+use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True, False};\n use llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n     RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n-\n use metadata::csearch;\n use middle::const_eval;\n use middle::def;\n@@ -98,12 +96,17 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n+// Helper function because we don't have tuple-swizzling.\n+fn first_two<R, S, T>((a, b, _): (R, S, T)) -> (R, S) {\n+    (a, b)\n+}\n+\n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n              es: &[Gc<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, &**e, is_local)));\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| first_two(const_expr(cx, &**e, is_local))));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(cx, vs.as_slice(), false)\n@@ -119,7 +122,8 @@ pub fn const_addr_of(cx: &CrateContext, cv: ValueRef) -> ValueRef {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n-        llvm::LLVMSetGlobalConstant(gv, True);\n+        llvm::LLVMSetGlobalConstant(gv,\n+                                    if mutbl == ast::MutImmutable {True} else {False});\n         SetLinkage(gv, PrivateLinkage);\n         gv\n     }\n@@ -131,7 +135,6 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n         None => v\n     };\n     unsafe {\n-        assert_eq!(llvm::LLVMIsGlobalConstant(v), True);\n         llvm::LLVMGetInitializer(v)\n     }\n }\n@@ -146,25 +149,25 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n     match ty::deref(t, explicit) {\n         Some(ref mt) => {\n-            assert!(mt.mutbl != ast::MutMutable);\n-            let dv = match ty::get(t).sty {\n+            match ty::get(t).sty {\n                 ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n-                    match ty::get(mt.ty).sty {\n-                        ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => {\n-                            cx.sess().bug(\"unexpected unsized type\")\n-                        }\n-                        _ => const_deref_ptr(cx, v),\n+                    if ty::type_is_sized(cx.tcx(), mt.ty) {\n+                        (const_deref_ptr(cx, v), mt.ty)\n+                    } else {\n+                        // Derefing a fat pointer does not change the representation,\n+                        // just the type to ty_open.\n+                        (v, ty::mk_open(cx.tcx(), mt.ty))\n                     }\n                 }\n                 ty::ty_enum(..) | ty::ty_struct(..) => {\n-                    const_deref_newtype(cx, v, t)\n+                    assert!(mt.mutbl != ast::MutMutable);\n+                    (const_deref_newtype(cx, v, t), mt.ty)\n                 }\n                 _ => {\n                     cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n                                           ty_to_string(cx.tcx(), t)).as_slice())\n                 }\n-            };\n-            (dv, mt.ty)\n+            }\n         }\n         None => {\n             cx.sess().bug(format!(\"can't dereference const of type {}\",\n@@ -193,12 +196,12 @@ pub fn get_const_val(cx: &CrateContext,\n      !cx.non_inlineable_statics.borrow().contains(&def_id.node))\n }\n \n-pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool) {\n+pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool, ty::t) {\n     let (llconst, inlineable) = const_expr_unadjusted(cx, e, is_local);\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx(), e);\n-    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n+    let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n     let opt_adj = cx.tcx.adjustments.borrow().find_copy(&e.id);\n     match opt_adj {\n         None => { }\n@@ -219,51 +222,64 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                 format!(\"unexpected static function: {:?}\",\n                                         store).as_slice())\n                 }\n-                ty::AutoObject(..) => {\n-                    cx.sess()\n-                      .span_unimpl(e.span,\n-                                   \"unimplemented const coercion to trait \\\n-                                    object\");\n-                }\n                 ty::AutoDerefRef(ref adj) => {\n                     let mut ty = ety;\n-                    let mut maybe_ptr = None;\n-                    for _ in range(0, adj.autoderefs) {\n+                    // Save the last autoderef in case we can avoid it.\n+                    for _ in range(0, adj.autoderefs-1) {\n                         let (dv, dt) = const_deref(cx, llconst, ty, false);\n-                        maybe_ptr = Some(llconst);\n                         llconst = dv;\n                         ty = dt;\n                     }\n \n                     match adj.autoref {\n-                        None => { }\n+                        None => {\n+                            let (dv, dt) = const_deref(cx, llconst, ty, false);\n+                            llconst = dv;\n+\n+                            // If we derefed a fat pointer then we will have an\n+                            // open type here. So we need to update the type with\n+                            // the one returned from const_deref.\n+                            ety_adjusted = dt;\n+                        }\n                         Some(ref autoref) => {\n-                            // Don't copy data to do a deref+ref.\n-                            let llptr = match maybe_ptr {\n-                                Some(ptr) => ptr,\n-                                None => {\n-                                    inlineable = false;\n-                                    const_addr_of(cx, llconst)\n-                                }\n-                            };\n                             match *autoref {\n-                                ty::AutoUnsafe(m) |\n-                                ty::AutoPtr(ty::ReStatic, m) => {\n-                                    assert!(m != ast::MutMutable);\n-                                    llconst = llptr;\n+                                ty::AutoUnsafe(_) |\n+                                ty::AutoPtr(ty::ReStatic, _, None) => {\n+                                    // Don't copy data to do a deref+ref\n+                                    // (i.e., skip the last auto-deref).\n+                                    if adj.autoderefs == 0 {\n+                                        inlineable = false;\n+                                        llconst = const_addr_of(cx, llconst, ast::MutImmutable);\n+                                    }\n                                 }\n-                                ty::AutoBorrowVec(ty::ReStatic, m) => {\n-                                    assert!(m != ast::MutMutable);\n-                                    assert_eq!(abi::slice_elt_base, 0);\n-                                    assert_eq!(abi::slice_elt_len, 1);\n+                                ty::AutoPtr(ty::ReStatic, _, Some(box ty::AutoUnsize(..))) => {\n+                                    if adj.autoderefs > 0 {\n+                                        // Seeing as we are deref'ing here and take a reference\n+                                        // again to make the pointer part of the far pointer below,\n+                                        // we just skip the whole thing. We still need the type\n+                                        // though. This works even if we don't need to deref\n+                                        // because of byref semantics. Note that this is not just\n+                                        // an optimisation, it is necessary for mutable vectors to\n+                                        // work properly.\n+                                        let (_, dt) = const_deref(cx, llconst, ty, false);\n+                                        ty = dt;\n+                                    }\n+\n                                     match ty::get(ty).sty {\n-                                        ty::ty_vec(_, Some(len)) => {\n+                                        ty::ty_vec(unit_ty, Some(len)) => {\n+                                            inlineable = false;\n+                                            let llunitty = type_of::type_of(cx, unit_ty);\n+                                            let llptr = const_ptrcast(cx, llconst, llunitty);\n+                                            assert_eq!(abi::slice_elt_base, 0);\n+                                            assert_eq!(abi::slice_elt_len, 1);\n                                             llconst = C_struct(cx, [\n                                                 llptr,\n                                                 C_uint(cx, len)\n                                             ], false);\n                                         }\n-                                        _ => {}\n+                                        _ => cx.sess().span_bug(e.span,\n+                                            format!(\"unimplemented type in const unsize: {}\",\n+                                                    ty_to_str(cx.tcx(), ty)).as_slice())\n                                     }\n                                 }\n                                 _ => {\n@@ -294,15 +310,15 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n                          csize, tsize).as_slice());\n     }\n-    (llconst, inlineable)\n+    (llconst, inlineable, ety_adjusted)\n }\n \n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n     let map_list = |exprs: &[Gc<ast::Expr>]| {\n-        exprs.iter().map(|e| const_expr(cx, &**e, is_local))\n+        exprs.iter().map(|e| first_two(const_expr(cx, &**e, is_local)))\n              .fold((Vec::new(), true),\n                    |(l, all_inlineable), (val, inlineable)| {\n                 (l.append_one(val), all_inlineable && inlineable)\n@@ -315,8 +331,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               (consts::const_lit(cx, e, (**lit).clone()), true)\n           }\n           ast::ExprBinary(b, ref e1, ref e2) => {\n-            let (te1, _) = const_expr(cx, &**e1, is_local);\n-            let (te2, _) = const_expr(cx, &**e2, is_local);\n+            let (te1, _, _) = const_expr(cx, &**e1, is_local);\n+            let (te2, _, _) = const_expr(cx, &**e2, is_local);\n \n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n@@ -397,7 +413,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             }, true)\n           },\n           ast::ExprUnary(u, ref e) => {\n-            let (te, _) = const_expr(cx, &**e, is_local);\n+            let (te, _, _) = const_expr(cx, &**e, is_local);\n             let ty = ty::expr_ty(cx.tcx(), &**e);\n             let is_float = ty::type_is_fp(ty);\n             return (match u {\n@@ -413,18 +429,16 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             }, true)\n           }\n           ast::ExprField(ref base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), &**base);\n+              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n               let brepr = adt::represent_type(cx, bt);\n-              let (bv, inlineable) = const_expr(cx, &**base, is_local);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n                   (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n               })\n           }\n \n           ast::ExprIndex(ref base, ref index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), &**base);\n-              let (bv, inlineable) = const_expr(cx, &**base, is_local);\n+              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n               let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -433,16 +447,29 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               };\n               let (arr, len) = match ty::get(bt).sty {\n                   ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n-                  ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                  ty::ty_open(ty) => match ty::get(ty).sty {\n                       ty::ty_vec(_, None) | ty::ty_str => {\n                           let e1 = const_get_elt(cx, bv, [0]);\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                       },\n                       _ => cx.sess().span_bug(base.span,\n-                                              \"index-expr base must be a vector or string type\")\n+                                              format!(\"index-expr base must be a vector \\\n+                                                       or string type, found {}\",\n+                                                      ty_to_str(cx.tcx(), bt)).as_slice())\n+                  },\n+                  ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                      ty::ty_vec(_, Some(u)) => {\n+                          (const_deref_ptr(cx, bv), C_uint(cx, u))\n+                      },\n+                      _ => cx.sess().span_bug(base.span,\n+                                              format!(\"index-expr base must be a vector \\\n+                                                       or string type, found {}\",\n+                                                      ty_to_str(cx.tcx(), bt)).as_slice())\n                   },\n                   _ => cx.sess().span_bug(base.span,\n-                                          \"index-expr base must be a vector or string type\")\n+                                          format!(\"index-expr base must be a vector \\\n+                                                   or string type, found {}\",\n+                                                  ty_to_str(cx.tcx(), bt)).as_slice())\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -467,10 +494,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n           ast::ExprCast(ref base, _) => {\n             let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let basety = ty::expr_ty(cx.tcx(), &**base);\n-            let (v, inlineable) = const_expr(cx, &**base, is_local);\n-            return (match (expr::cast_type_kind(basety),\n-                           expr::cast_type_kind(ety)) {\n+            let (v, inlineable, basety) = const_expr(cx, &**base, is_local);\n+            return (match (expr::cast_type_kind(cx.tcx(), basety),\n+                           expr::cast_type_kind(cx.tcx(), ety)) {\n \n               (expr::cast_integral, expr::cast_integral) => {\n                 let s = ty::type_is_signed(basety) as Bool;\n@@ -494,7 +520,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 let repr = adt::represent_type(cx, basety);\n                 let discr = adt::const_get_discrim(cx, &*repr, v);\n                 let iv = C_integral(cx.int_type, discr, false);\n-                let ety_cast = expr::cast_type_kind(ety);\n+                let ety_cast = expr::cast_type_kind(cx.tcx(), ety);\n                 match ety_cast {\n                     expr::cast_integral => {\n                         let s = ty::type_is_signed(ety) as Bool;\n@@ -516,9 +542,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n             }, inlineable)\n           }\n-          ast::ExprAddrOf(ast::MutImmutable, ref sub) => {\n-              let (e, _) = const_expr(cx, &**sub, is_local);\n-              (const_addr_of(cx, e), false)\n+          ast::ExprAddrOf(mutbl, ref sub) => {\n+              let (e, _, _) = const_expr(cx, &**sub, is_local);\n+              (const_addr_of(cx, e, mutbl), false)\n           }\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -540,10 +566,10 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   let (cs, inlineable) = vec::unzip(field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr, is_local),\n+                          Some(ref f) => first_two(const_expr(cx, &*f.expr, is_local)),\n                           None => {\n                               match base_val {\n-                                Some((bv, inlineable)) => {\n+                                Some((bv, inlineable, _)) => {\n                                     (adt::const_get_field(cx, &*repr, bv, discr, ix),\n                                      inlineable)\n                                 }\n@@ -563,34 +589,6 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                                is_local);\n             (v, inlineable)\n           }\n-          ast::ExprVstore(ref sub, store @ ast::ExprVstoreSlice) |\n-          ast::ExprVstore(ref sub, store @ ast::ExprVstoreMutSlice) => {\n-            match sub.node {\n-              ast::ExprLit(ref lit) => {\n-                match lit.node {\n-                    ast::LitStr(..) => { const_expr(cx, &**sub, is_local) }\n-                    _ => { cx.sess().span_bug(e.span, \"bad const-slice lit\") }\n-                }\n-              }\n-              ast::ExprVec(ref es) => {\n-                let (cv, llunitty, _) = const_vec(cx,\n-                                                  e,\n-                                                  es.as_slice(),\n-                                                  is_local);\n-                let llty = val_ty(cv);\n-                let gv = \"const\".with_c_str(|name| {\n-                    llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n-                });\n-                llvm::LLVMSetInitializer(gv, cv);\n-                llvm::LLVMSetGlobalConstant(gv,\n-                      if store == ast::ExprVstoreMutSlice { False } else { True });\n-                SetLinkage(gv, PrivateLinkage);\n-                let p = const_ptrcast(cx, gv, llunitty);\n-                (C_struct(cx, [p, C_uint(cx, es.len())], false), false)\n-              }\n-              _ => cx.sess().span_bug(e.span, \"bad const-slice expr\")\n-            }\n-          }\n           ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);\n             let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n@@ -669,10 +667,10 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(ref e) => { const_expr(cx, &**e, is_local) }\n+          ast::ExprParen(ref e) => first_two(const_expr(cx, &**e, is_local)),\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr, is_local),\n+                Some(ref expr) => first_two(const_expr(cx, &**expr, is_local)),\n                 None => (C_nil(cx), true)\n             }\n           }"}, {"sha": "b7803d404b5bc68b7f89161555f1727a6f756073", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -450,6 +450,8 @@ impl Datum<Expr> {\n                                name: &str,\n                                expr_id: ast::NodeId)\n                                -> DatumBlock<'a, Lvalue> {\n+        assert!(ty::lltype_is_sized(bcx.tcx(), self.ty),\n+                \"Trying to convert unsized value to lval\");\n         self.match_kind(\n             |l| DatumBlock::new(bcx, l),\n             |r| {\n@@ -504,12 +506,28 @@ impl Datum<Lvalue> {\n         self.val\n     }\n \n-    pub fn get_element(&self,\n-                       ty: ty::t,\n-                       gep: |ValueRef| -> ValueRef)\n-                       -> Datum<Lvalue> {\n+    // Extracts a component of a compound data structure (e.g., a field from a\n+    // struct). Note that if self is an opened, unsized type then the returned\n+    // datum may also be unsized _without the size information_. It is the\n+    // callers responsibility to package the result in some way to make a valid\n+    // datum in that case (e.g., by making a fat pointer or opened pair).\n+    pub fn get_element<'a>(&self,\n+                           bcx: &'a Block<'a>,\n+                           ty: ty::t,\n+                           gep: |ValueRef| -> ValueRef)\n+                           -> Datum<Lvalue> {\n+        let val = match ty::get(self.ty).sty {\n+            _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n+            ty::ty_open(_) => {\n+                let base = Load(bcx, expr::get_dataptr(bcx, self.val));\n+                gep(base)\n+            }\n+            _ => bcx.tcx().sess.bug(\n+                format!(\"Unexpected unsized type in get_element: {}\",\n+                        bcx.ty_to_str(self.ty)).as_slice())\n+        };\n         Datum {\n-            val: gep(self.val),\n+            val: val,\n             kind: Lvalue,\n             ty: ty,\n         }"}, {"sha": "31b31224464938d60141ca8caf46af9905258e1b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 20, "deletions": 69, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -402,7 +402,7 @@ impl TypeMap {\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(inner_type_id.as_slice());\n             },\n-            ty::ty_vec(ty::mt { ty: inner_type, .. }, optional_length) => {\n+            ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n                         unique_type_id.push_str(format!(\"[{}]\", len).as_slice());\n@@ -595,18 +595,6 @@ impl TypeMap {\n         UniqueTypeId(interner_key)\n     }\n \n-    fn get_unique_type_id_of_heap_vec_box(&mut self,\n-                                          cx: &CrateContext,\n-                                          element_type: ty::t)\n-                                       -> UniqueTypeId {\n-        let element_type_id = self.get_unique_type_id_of_type(cx, element_type);\n-        let heap_vec_box_type_id = format!(\"{{HEAP_VEC_BOX<{}>}}\",\n-                                           self.get_unique_type_id_as_string(element_type_id)\n-                                               .as_slice());\n-        let interner_key = self.unique_id_interner.intern(Rc::new(heap_vec_box_type_id));\n-        UniqueTypeId(interner_key)\n-    }\n-\n     fn get_unique_type_id_of_gc_box(&mut self,\n                                     cx: &CrateContext,\n                                     element_type: ty::t)\n@@ -2811,26 +2799,13 @@ fn subroutine_type_metadata(cx: &CrateContext,\n }\n \n fn trait_pointer_metadata(cx: &CrateContext,\n-                          // trait_pointer_type must be the type of the fat\n-                          // pointer to the concrete trait object\n-                          trait_pointer_type: ty::t,\n+                          trait_object_type: ty::t,\n                           unique_type_id: UniqueTypeId)\n                        -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n \n-    let trait_object_type = match ty::get(trait_pointer_type).sty {\n-        ty::ty_uniq(pointee_type) => pointee_type,\n-        ty::ty_rptr(_, ty::mt { ty, .. }) => ty,\n-        _ => {\n-            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_pointer_type);\n-            cx.sess().bug(format!(\"debuginfo: Unexpected trait-pointer type in \\\n-                                   trait_pointer_metadata(): {}\",\n-                                   pp_type_name.as_slice()).as_slice());\n-        }\n-    };\n-\n     let def_id = match ty::get(trait_object_type).sty {\n         ty::ty_trait(box ty::TyTrait { def_id, .. }) => def_id,\n         _ => {\n@@ -2842,11 +2817,11 @@ fn trait_pointer_metadata(cx: &CrateContext,\n     };\n \n     let trait_pointer_type_name =\n-        compute_debuginfo_type_name(cx, trait_pointer_type, false);\n+        compute_debuginfo_type_name(cx, trait_object_type, false);\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n \n-    let trait_pointer_llvm_type = type_of::type_of(cx, trait_pointer_type);\n+    let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n \n     composite_type_metadata(cx,\n                             trait_pointer_llvm_type,\n@@ -2914,56 +2889,32 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_box(pointee_type) => {\n             at_box_metadata(cx, t, pointee_type, unique_type_id)\n         }\n-        ty::ty_vec(ref mt, Some(len)) => {\n-            fixed_vec_metadata(cx, unique_type_id, mt.ty, len, usage_site_span)\n+        ty::ty_vec(typ, Some(len)) => {\n+            fixed_vec_metadata(cx, unique_type_id, typ, len, usage_site_span)\n         }\n-        ty::ty_uniq(pointee_type) => {\n-            match ty::get(pointee_type).sty {\n-                ty::ty_vec(ref mt, None) => {\n-                    let vec_metadata = vec_slice_metadata(cx, t, mt.ty, usage_site_span);\n-                    pointer_type_metadata(cx, t, vec_metadata)\n-                }\n-                ty::ty_str => {\n-                    let i8_t = ty::mk_i8();\n-                    let vec_metadata = vec_slice_metadata(cx, t, i8_t, usage_site_span);\n-                    pointer_type_metadata(cx, t, vec_metadata)\n-                }\n-                ty::ty_trait(..) => {\n-                    MetadataCreationResult::new(\n+        // FIXME Can we do better than this for unsized vec/str fields?\n+        ty::ty_vec(typ, None) => fixed_vec_metadata(cx, unique_type_id, typ, 0, usage_site_span),\n+        ty::ty_str => fixed_vec_metadata(cx, unique_type_id, ty::mk_i8(), 0, usage_site_span),\n+        ty::ty_trait(..) => {\n+            MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, unique_type_id),\n-                        false)\n-                }\n-                _ => {\n-                    let pointee_metadata = type_metadata(cx,\n-                                                         pointee_type,\n-                                                         usage_site_span);\n-                    match debug_context(cx).type_map\n-                                           .borrow()\n-                                           .find_metadata_for_unique_id(unique_type_id) {\n-                        Some(metadata) => return metadata,\n-                        None => { /* proceed normally */ }\n-                    };\n-\n-                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n-                                                false)\n-                }\n-            }\n+            false)\n         }\n-        ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-            match ty::get(mt.ty).sty {\n-                ty::ty_vec(ref mt, None) => {\n-                    vec_slice_metadata(cx, t, mt.ty, unique_type_id, usage_site_span)\n+        ty::ty_uniq(ty) | ty::ty_ptr(ty::mt{ty, ..}) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+            match ty::get(ty).sty {\n+                ty::ty_vec(typ, None) => {\n+                    vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n                     vec_slice_metadata(cx, t, ty::mk_u8(), unique_type_id, usage_site_span)\n                 }\n                 ty::ty_trait(..) => {\n                     MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, t, unique_type_id),\n+                        trait_pointer_metadata(cx, ty, unique_type_id),\n                         false)\n                 }\n                 _ => {\n-                    let pointee = type_metadata(cx, mt.ty, usage_site_span);\n+                    let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n \n                     match debug_context(cx).type_map\n                                            .borrow()\n@@ -2972,7 +2923,8 @@ fn type_metadata(cx: &CrateContext,\n                         None => { /* proceed normally */ }\n                     };\n \n-                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee), false)\n+                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n+                                                false)\n                 }\n             }\n         }\n@@ -3471,7 +3423,6 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprAgain(_) |\n             ast::ExprPath(_)  => {}\n \n-            ast::ExprVstore(ref sub_exp, _)   |\n             ast::ExprCast(ref sub_exp, _)     |\n             ast::ExprAddrOf(_, ref sub_exp)  |\n             ast::ExprField(ref sub_exp, _, _) |"}, {"sha": "657cd72c2554340c18d1e8208fe62770caecab82", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 351, "deletions": 129, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -40,6 +40,7 @@ use metadata::csearch;\n use middle::def;\n use middle::lang_items::MallocFnLangItem;\n use middle::mem_categorization::Typer;\n+use middle::subst;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n@@ -62,8 +63,8 @@ use middle::trans::inline;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::struct_fields;\n-use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef};\n+use middle::ty::{AutoDerefRef, AutoAddEnv, AutoUnsafe};\n+use middle::ty::{AutoPtr};\n use middle::ty;\n use middle::typeck;\n use middle::typeck::MethodCall;\n@@ -160,6 +161,14 @@ pub fn trans<'a>(bcx: &'a Block<'a>,\n     return DatumBlock::new(bcx, datum);\n }\n \n+pub fn get_len(bcx: &Block, fat_ptr: ValueRef) -> ValueRef {\n+    GEPi(bcx, fat_ptr, [0u, abi::slice_elt_len])\n+}\n+\n+pub fn get_dataptr(bcx: &Block, fat_ptr: ValueRef) -> ValueRef {\n+    GEPi(bcx, fat_ptr, [0u, abi::slice_elt_base])\n+}\n+\n fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                          expr: &ast::Expr,\n                          datum: Datum<Expr>)\n@@ -184,71 +193,243 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n         }\n         AutoDerefRef(ref adj) => {\n-            if adj.autoderefs > 0 {\n+            // Extracting a value from a box counts as a deref, but if we are\n+            // just converting Box<[T, ..n]> to Box<[T]> we aren't really doing\n+            // a deref (and wouldn't if we could treat Box like a normal struct).\n+            let autoderefs = match adj.autoref {\n+                Some(ty::AutoUnsizeUniq(..)) => adj.autoderefs - 1,\n+                _ => adj.autoderefs\n+            };\n+\n+            if autoderefs > 0 {\n                 datum = unpack_datum!(\n-                    bcx, deref_multiple(bcx, expr, datum, adj.autoderefs));\n+                    bcx, deref_multiple(bcx, expr, datum, autoderefs));\n             }\n \n-            datum = match adj.autoref {\n-                None => {\n-                    datum\n-                }\n-                Some(AutoUnsafe(..)) | // region + unsafe ptrs have same repr\n-                Some(AutoPtr(..)) => {\n-                    unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n-                }\n-                Some(AutoBorrowVec(..)) => {\n-                    unpack_datum!(bcx, auto_slice(bcx, expr, datum))\n+            match adj.autoref {\n+                Some(ref a) => {\n+                    datum = unpack_datum!(bcx, apply_autoref(a,\n+                                                             bcx,\n+                                                             expr,\n+                                                             datum));\n                 }\n-                Some(AutoBorrowVecRef(..)) => {\n-                    unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n-                }\n-                Some(AutoBorrowObj(..)) => {\n-                    unpack_datum!(bcx, auto_borrow_obj(bcx, expr, datum))\n-                }\n-            };\n-        }\n-        AutoObject(..) => {\n-            let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr);\n-            let scratch = rvalue_scratch_datum(bcx, adjusted_ty, \"__adjust\");\n-            bcx = meth::trans_trait_cast(\n-                bcx, datum, expr.id, SaveIn(scratch.val));\n-            datum = scratch.to_expr_datum();\n+                _ => {}\n+            }\n         }\n     }\n     debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_slice<'a>(\n-                  bcx: &'a Block<'a>,\n-                  expr: &ast::Expr,\n-                  datum: Datum<Expr>)\n-                  -> DatumBlock<'a, Expr> {\n-        // This is not the most efficient thing possible; since slices\n-        // are two words it'd be better if this were compiled in\n-        // 'dest' mode, but I can't find a nice way to structure the\n-        // code and keep it DRY that accommodates that use case at the\n-        // moment.\n+    fn apply_autoref<'a>(autoref: &ty::AutoRef,\n+                         bcx: &'a Block<'a>,\n+                         expr: &ast::Expr,\n+                         datum: Datum<Expr>)\n+                         -> DatumBlock<'a, Expr> {\n+        let mut bcx = bcx;\n+        let mut datum = datum;\n+\n+        let datum = match autoref {\n+            &AutoUnsafe(..) => {\n+                debug!(\"  AutoUnsafe\");\n+                unpack_datum!(bcx, ref_ptr(bcx, expr, datum))\n+            }\n+            &AutoPtr(_, _, ref a) => {\n+                debug!(\"  AutoPtr\");\n+                match a {\n+                    &Some(box ref a) => datum = unpack_datum!(bcx,\n+                                                              apply_autoref(a, bcx, expr, datum)),\n+                    _ => {}\n+                }\n+                unpack_datum!(bcx, ref_ptr(bcx, expr, datum))\n+            }\n+            &ty::AutoUnsize(ref k) => {\n+                debug!(\"  AutoUnsize\");\n+                unpack_datum!(bcx, unsize_expr(bcx, expr, datum, k))\n+            }\n+\n+            &ty::AutoUnsizeUniq(ty::UnsizeLength(len)) => {\n+                debug!(\"  AutoUnsizeUniq(UnsizeLength)\");\n+                unpack_datum!(bcx, unsize_unique_vec(bcx, expr, datum, len))\n+            }\n+            &ty::AutoUnsizeUniq(ref k) => {\n+                debug!(\"  AutoUnsizeUniq\");\n+                unpack_datum!(bcx, unsize_unique_expr(bcx, expr, datum, k))\n+            }\n+        };\n \n+        DatumBlock::new(bcx, datum)\n+    }\n+\n+    fn ref_ptr<'a>(bcx: &'a Block<'a>,\n+                   expr: &ast::Expr,\n+                   datum: Datum<Expr>)\n+                   -> DatumBlock<'a, Expr> {\n+        if !ty::type_is_sized(bcx.tcx(), datum.ty) {\n+            debug!(\"Taking address of unsized type {}\",\n+                   bcx.ty_to_str(datum.ty));\n+            ref_fat_ptr(bcx, expr, datum)\n+        } else {\n+            debug!(\"Taking address of sized type {}\",\n+                   bcx.ty_to_str(datum.ty));\n+            auto_ref(bcx, datum, expr)\n+        }\n+    }\n+\n+    // Retrieve the information we are losing (making dynamic) in an unsizing\n+    // adjustment.\n+    fn unsized_info<'a>(bcx: &'a Block<'a>,\n+                        kind: &ty::UnsizeKind,\n+                        id: ast::NodeId,\n+                        sized_ty: ty::t) -> ValueRef {\n+        match kind {\n+            &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n+            &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(sized_ty).sty {\n+                ty::ty_struct(_, ref substs) => {\n+                    let ty_substs = substs.types.get_vec(subst::TypeSpace);\n+                    let sized_ty = ty_substs.get(tp_index);\n+                    unsized_info(bcx, k, id, *sized_ty)\n+                }\n+                _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n+                                          bcx.ty_to_str(sized_ty)).as_slice())\n+            },\n+            &ty::UnsizeVtable(..) =>\n+                PointerCast(bcx,\n+                            meth::vtable_ptr(bcx, id, sized_ty),\n+                            Type::vtable_ptr(bcx.ccx()))\n+        }\n+    }\n+\n+    fn unsize_expr<'a>(bcx: &'a Block<'a>,\n+                       expr: &ast::Expr,\n+                       datum: Datum<Expr>,\n+                       k: &ty::UnsizeKind)\n+                       -> DatumBlock<'a, Expr> {\n+        let tcx = bcx.tcx();\n+        let datum_ty = datum.ty;\n+        let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n+        let dest_ty = ty::mk_open(tcx, unsized_ty);\n+        // Closures for extracting and manipulating the data and payload parts of\n+        // the fat pointer.\n+        let base = match k {\n+            &ty::UnsizeStruct(..) =>\n+                |bcx, val| PointerCast(bcx,\n+                                       val,\n+                                       type_of::type_of(bcx.ccx(), unsized_ty).ptr_to()),\n+            &ty::UnsizeLength(..) =>\n+                |bcx, val| GEPi(bcx, val, [0u, 0u]),\n+            &ty::UnsizeVtable(..) =>\n+                |_bcx, val| PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n+        };\n+        let info = |bcx, _val| unsized_info(bcx, k, expr.id, datum_ty);\n+        into_fat_ptr(bcx, expr, datum, dest_ty, base, info)\n+    }\n+\n+    fn ref_fat_ptr<'a>(bcx: &'a Block<'a>,\n+                       expr: &ast::Expr,\n+                       datum: Datum<Expr>)\n+                       -> DatumBlock<'a, Expr> {\n+        let tcx = bcx.tcx();\n+        let dest_ty = ty::close_type(tcx, datum.ty);\n+        let base = |bcx, val| Load(bcx, get_dataptr(bcx, val));\n+        let len = |bcx, val| Load(bcx, get_len(bcx, val));\n+        into_fat_ptr(bcx, expr, datum, dest_ty, base, len)\n+    }\n+\n+    fn into_fat_ptr<'a>(bcx: &'a Block<'a>,\n+                        expr: &ast::Expr,\n+                        datum: Datum<Expr>,\n+                        dest_ty: ty::t,\n+                        base: |&'a Block<'a>, ValueRef| -> ValueRef,\n+                        info: |&'a Block<'a>, ValueRef| -> ValueRef)\n+                        -> DatumBlock<'a, Expr> {\n+        let mut bcx = bcx;\n+\n+        // Arrange cleanup\n+        let lval = unpack_datum!(bcx,\n+                                 datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n+        let base = base(bcx, lval.val);\n+        let info = info(bcx, lval.val);\n+\n+        let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n+        Store(bcx, base, get_dataptr(bcx, scratch.val));\n+        Store(bcx, info, get_len(bcx, scratch.val));\n+\n+        DatumBlock::new(bcx, scratch.to_expr_datum())\n+    }\n+\n+    fn unsize_unique_vec<'a>(bcx: &'a Block<'a>,\n+                             expr: &ast::Expr,\n+                             datum: Datum<Expr>,\n+                             len: uint)\n+                             -> DatumBlock<'a, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n-        let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n \n-        // Arrange cleanup, if not already done. This is needed in\n-        // case we are auto-slicing an owned vector or some such.\n-        let datum = unpack_datum!(\n-            bcx, datum.to_lvalue_datum(bcx, \"auto_slice\", expr.id));\n+        let datum_ty = datum.ty;\n+        // Arrange cleanup\n+        let lval = unpack_datum!(bcx,\n+                                 datum.to_lvalue_datum(bcx, \"unsize_unique_vec\", expr.id));\n+\n+        let ll_len = C_uint(bcx.ccx(), len);\n+        let unit_ty = ty::sequence_element_type(tcx, ty::type_content(datum_ty));\n+        let vec_ty = ty::mk_uniq(tcx, ty::mk_vec(tcx, unit_ty, None));\n+        let scratch = rvalue_scratch_datum(bcx, vec_ty, \"__unsize_unique\");\n+\n+        if len == 0 {\n+            Store(bcx,\n+                  C_null(type_of::type_of(bcx.ccx(), unit_ty).ptr_to()),\n+                  get_dataptr(bcx, scratch.val));\n+        } else {\n+            // Box<[(), ..n]> will not allocate, but ~[()] expects an\n+            // allocation of n bytes, so we must allocate here (yuck).\n+            let llty = type_of::type_of(bcx.ccx(), unit_ty);\n+            if llsize_of_alloc(bcx.ccx(), llty) == 0 {\n+                let ptr_unit_ty = type_of::type_of(bcx.ccx(), unit_ty).ptr_to();\n+                let align = C_uint(bcx.ccx(), 8);\n+                let alloc_result = malloc_raw_dyn(bcx, ptr_unit_ty, vec_ty, ll_len, align);\n+                bcx = alloc_result.bcx;\n+                let base = get_dataptr(bcx, scratch.val);\n+                Store(bcx, alloc_result.val, base);\n+            } else {\n+                let base = get_dataptr(bcx, scratch.val);\n+                let base = PointerCast(bcx,\n+                                       base,\n+                                       type_of::type_of(bcx.ccx(), datum_ty).ptr_to());\n+                bcx = lval.store_to(bcx, base);\n+            }\n+        }\n+\n+        Store(bcx, ll_len, get_len(bcx, scratch.val));\n+        DatumBlock::new(bcx, scratch.to_expr_datum())\n+    }\n+\n+    fn unsize_unique_expr<'a>(bcx: &'a Block<'a>,\n+                              expr: &ast::Expr,\n+                              datum: Datum<Expr>,\n+                              k: &ty::UnsizeKind)\n+                              -> DatumBlock<'a, Expr> {\n+        let mut bcx = bcx;\n+        let tcx = bcx.tcx();\n+\n+        let datum_ty = datum.ty;\n+        let unboxed_ty = match ty::get(datum_ty).sty {\n+            ty::ty_uniq(t) => t,\n+            _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n+                                        bcx.ty_to_str(datum_ty)).as_slice())\n+        };\n+        let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n+\n+        let lval = unpack_datum!(bcx,\n+                                 datum.to_lvalue_datum(bcx, \"unsize_unique_expr\", expr.id));\n \n-        let (base, len) = datum.get_vec_base_and_len(bcx);\n+        let scratch = rvalue_scratch_datum(bcx, result_ty, \"__fat_ptr\");\n+        let llbox_ty = type_of::type_of(bcx.ccx(), datum_ty);\n+        let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n+        bcx = lval.store_to(bcx, base);\n \n-        // this type may have a different region/mutability than the\n-        // real one, but it will have the same runtime representation\n-        let slice_ty = ty::mk_slice(tcx, ty::ReStatic,\n-                                    ty::mt { ty: unit_ty, mutbl: ast::MutImmutable });\n+        let info = unsized_info(bcx, k, expr.id, unboxed_ty);\n+        Store(bcx, info, get_len(bcx, scratch.val));\n \n-        let scratch = rvalue_scratch_datum(bcx, slice_ty, \"__adjust\");\n-        Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n-        Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n@@ -267,32 +448,6 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         let def = ty::resolve_expr(bcx.tcx(), expr);\n         closure::make_closure_from_bare_fn(bcx, closure_ty, def, fn_ptr)\n     }\n-\n-    fn auto_slice_and_ref<'a>(\n-                          bcx: &'a Block<'a>,\n-                          expr: &ast::Expr,\n-                          datum: Datum<Expr>)\n-                          -> DatumBlock<'a, Expr> {\n-        let DatumBlock { bcx, datum } = auto_slice(bcx, expr, datum);\n-        auto_ref(bcx, datum, expr)\n-    }\n-\n-    fn auto_borrow_obj<'a>(mut bcx: &'a Block<'a>,\n-                           expr: &ast::Expr,\n-                           source_datum: Datum<Expr>)\n-                           -> DatumBlock<'a, Expr> {\n-        let tcx = bcx.tcx();\n-        let target_obj_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"auto_borrow_obj(target={})\", target_obj_ty.repr(tcx));\n-\n-        // Arrange cleanup, if not already done. This is needed in\n-        // case we are auto-borrowing a Box<Trait> to &Trait\n-        let datum = unpack_datum!(\n-            bcx, source_datum.to_lvalue_datum(bcx, \"autoborrowobj\", expr.id));\n-        let mut datum = datum.to_expr_datum();\n-        datum.ty = target_obj_ty;\n-        DatumBlock::new(bcx, datum)\n-    }\n }\n \n pub fn trans_to_lvalue<'a>(bcx: &'a Block<'a>,\n@@ -398,27 +553,33 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprIndex(base, idx) => {\n             trans_index(bcx, expr.span, &**base, &**idx, MethodCall::expr(expr.id))\n         }\n-        ast::ExprVstore(ref contents, ast::ExprVstoreUniq) => {\n-            fcx.push_ast_cleanup_scope(contents.id);\n-            let datum = unpack_datum!(\n-                bcx, tvec::trans_uniq_vstore(bcx, expr, &**contents));\n-            bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n-            DatumBlock::new(bcx, datum)\n-        }\n         ast::ExprBox(_, ref contents) => {\n             // Special case for `Box<T>` and `Gc<T>`\n             let box_ty = expr_ty(bcx, expr);\n             let contents_ty = expr_ty(bcx, &**contents);\n             match ty::get(box_ty).sty {\n                 ty::ty_uniq(..) => {\n-                    trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n+                    match contents.node {\n+                        ast::ExprRepeat(..) | ast::ExprVec(..) => {\n+                            // Special case for owned vectors.\n+                            fcx.push_ast_cleanup_scope(contents.id);\n+                            let datum = unpack_datum!(\n+                                bcx, tvec::trans_uniq_vec(bcx, expr, &**contents));\n+                            bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n+                            DatumBlock::new(bcx, datum)\n+                        }\n+                        _ => {\n+                            trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n+                        }\n+                    }\n                 }\n                 ty::ty_box(..) => {\n                     trans_managed_expr(bcx, box_ty, &**contents, contents_ty)\n                 }\n                 _ => bcx.sess().span_bug(expr.span,\n                                          \"expected unique or managed box\")\n             }\n+\n         }\n         ast::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, (**lit).clone()),\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -428,7 +589,19 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             trans_unary(bcx, expr, op, &**x)\n         }\n         ast::ExprAddrOf(_, ref x) => {\n-            trans_addr_of(bcx, expr, &**x)\n+            match x.node {\n+                ast::ExprRepeat(..) | ast::ExprVec(..) => {\n+                    // Special case for slices.\n+                    fcx.push_ast_cleanup_scope(x.id);\n+                    let datum = unpack_datum!(\n+                        bcx, tvec::trans_slice_vec(bcx, expr, &**x));\n+                    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, x.id);\n+                    DatumBlock::new(bcx, datum)\n+                }\n+                _ => {\n+                    trans_addr_of(bcx, expr, &**x)\n+                }\n+            }\n         }\n         ast::ExprCast(ref val, _) => {\n             // Datum output mode means this is a scalar cast:\n@@ -454,14 +627,28 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n-    let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n-    with_field_tys(bcx.tcx(), base_datum.ty, None, |discr, field_tys| {\n-            let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n-            let d = base_datum.get_element(\n-                field_tys[ix].mt.ty,\n-                |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n+    let bare_ty = ty::unopen_type(base_datum.ty);\n+    let repr = adt::represent_type(bcx.ccx(), bare_ty);\n+    with_field_tys(bcx.tcx(), bare_ty, None, |discr, field_tys| {\n+        let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n+        let d = base_datum.get_element(\n+            bcx,\n+            field_tys[ix].mt.ty,\n+            |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n+\n+        if ty::type_is_sized(bcx.tcx(), d.ty) {\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n-        })\n+        } else {\n+            debug!(\"nrc: {}\", bcx.ty_to_str(d.ty))\n+            let scratch = rvalue_scratch_datum(bcx, ty::mk_open(bcx.tcx(), d.ty), \"\");\n+            Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n+            let info = Load(bcx, get_len(bcx, base_datum.val));\n+            Store(bcx, info, get_len(bcx, scratch.val));\n+\n+            DatumBlock::new(bcx, scratch.to_expr_datum())\n+\n+        }\n+    })\n }\n \n fn trans_index<'a>(bcx: &'a Block<'a>,\n@@ -727,7 +914,6 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n-    let fcx = bcx.fcx;\n \n     match expr.node {\n         ast::ExprParen(ref e) => {\n@@ -772,14 +958,8 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::ExprVstore(ref contents, ast::ExprVstoreSlice) |\n-        ast::ExprVstore(ref contents, ast::ExprVstoreMutSlice) => {\n-            fcx.push_ast_cleanup_scope(contents.id);\n-            bcx = tvec::trans_slice_vstore(bcx, expr, &**contents, dest);\n-            fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id)\n-        }\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n-            tvec::trans_fixed_vstore(bcx, expr, expr, dest)\n+            tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n         ast::ExprFnBlock(_, ref decl, ref body) |\n         ast::ExprProc(ref decl, ref body) => {\n@@ -1168,6 +1348,21 @@ pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n         fcx.schedule_drop_mem(scope, dest, e_ty);\n     }\n \n+    for base in optbase.iter() {\n+        // FIXME #6573: is it sound to use the destination's repr on the base?\n+        // And, would it ever be reasonable to be here with discr != 0?\n+        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n+        for &(i, t) in base.fields.iter() {\n+            let datum = base_datum.get_element(\n+                bcx,\n+                t,\n+                |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, i));\n+            assert!(ty::type_is_sized(bcx.tcx(), datum.ty));\n+            let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n+            bcx = datum.store_to(bcx, dest);\n+        }\n+    }\n+\n     adt::trans_set_discr(bcx, &*repr, addr, discr);\n \n     fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n@@ -1301,8 +1496,28 @@ fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n-    let ty = expr_ty(bcx, expr);\n-    return immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock();\n+    match ty::get(sub_datum.ty).sty {\n+        ty::ty_open(_) => {\n+            // Opened DST value, close to a fat pointer\n+            debug!(\"Closing fat pointer {}\", bcx.ty_to_str(sub_datum.ty));\n+\n+            let scratch = rvalue_scratch_datum(bcx,\n+                                               ty::close_type(bcx.tcx(), sub_datum.ty),\n+                                               \"fat_addr_of\");\n+            let base = Load(bcx, get_dataptr(bcx, sub_datum.val));\n+            Store(bcx, base, get_dataptr(bcx, scratch.val));\n+\n+            let len = Load(bcx, get_len(bcx, sub_datum.val));\n+            Store(bcx, len, get_len(bcx, scratch.val));\n+\n+            DatumBlock::new(bcx, scratch.to_expr_datum())\n+        }\n+        _ => {\n+            // Sized value, ref to a thin pointer\n+            let ty = expr_ty(bcx, expr);\n+            immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock()\n+        }\n+    }\n }\n \n // Important to get types for both lhs and rhs, because one might be _|_\n@@ -1590,15 +1805,18 @@ pub enum cast_kind {\n     cast_other,\n }\n \n-pub fn cast_type_kind(t: ty::t) -> cast_kind {\n+pub fn cast_type_kind(tcx: &ty::ctxt, t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n         ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n         ty::ty_ptr(..)     => cast_pointer,\n-        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty{\n-            ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => cast_other,\n-            _ => cast_pointer,\n-        },\n+        ty::ty_rptr(_, mt) => {\n+            if ty::type_is_sized(tcx, mt.ty) {\n+                cast_pointer\n+            } else {\n+                cast_other\n+            }\n+        }\n         ty::ty_bare_fn(..) => cast_pointer,\n         ty::ty_int(..)     => cast_integral,\n         ty::ty_uint(..)    => cast_integral,\n@@ -1618,8 +1836,8 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n \n     let t_in = expr_ty(bcx, expr);\n     let t_out = node_id_type(bcx, id);\n-    let k_in = cast_type_kind(t_in);\n-    let k_out = cast_type_kind(t_out);\n+    let k_in = cast_type_kind(bcx.tcx(), t_in);\n+    let k_out = cast_type_kind(bcx.tcx(), t_out);\n     let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n     let ll_t_in = type_of::arg_type_of(ccx, t_in);\n     let ll_t_out = type_of::arg_type_of(ccx, t_out);\n@@ -1807,10 +2025,14 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     let r = match ty::get(datum.ty).sty {\n         ty::ty_uniq(content_ty) => {\n-            match ty::get(content_ty).sty {\n-                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..)\n-                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected unsized box\"),\n-                _ => deref_owned_pointer(bcx, expr, datum, content_ty),\n+            if ty::type_is_sized(bcx.tcx(), content_ty) {\n+                deref_owned_pointer(bcx, expr, datum, content_ty)\n+            } else {\n+                // A fat pointer and an opened DST value have the same represenation\n+                // just different types.\n+                DatumBlock::new(bcx, Datum::new(datum.val,\n+                                                ty::mk_open(bcx.tcx(), content_ty),\n+                                                datum.kind))\n             }\n         }\n \n@@ -1825,21 +2047,21 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n         ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n         ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n-            match ty::get(content_ty).sty {\n-                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..)\n-                    => bcx.tcx().sess.span_bug(expr.span, \"unexpected unsized reference\"),\n-                _ => {\n-                    assert!(!ty::type_needs_drop(bcx.tcx(), datum.ty));\n-\n-                    let ptr = datum.to_llscalarish(bcx);\n-\n-                    // Always generate an lvalue datum, even if datum.mode is\n-                    // an rvalue.  This is because datum.mode is only an\n-                    // rvalue for non-owning pointers like &T or *T, in which\n-                    // case cleanup *is* scheduled elsewhere, by the true\n-                    // owner (or, in the case of *T, by the user).\n-                    DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n-                }\n+            if ty::type_is_sized(bcx.tcx(), content_ty) {\n+                let ptr = datum.to_llscalarish(bcx);\n+\n+                // Always generate an lvalue datum, even if datum.mode is\n+                // an rvalue.  This is because datum.mode is only an\n+                // rvalue for non-owning pointers like &T or *T, in which\n+                // case cleanup *is* scheduled elsewhere, by the true\n+                // owner (or, in the case of *T, by the user).\n+                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n+            } else {\n+                // A fat pointer and an opened DST value have the same represenation\n+                // just different types.\n+                DatumBlock::new(bcx, Datum::new(datum.val,\n+                                                ty::mk_open(bcx.tcx(), content_ty),\n+                                                datum.kind))\n             }\n         }\n "}, {"sha": "2994378f91caf15476946ca5ff8f37e897f191d7", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -98,18 +98,14 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n         ty::ty_box(typ) if !ty::type_needs_drop(tcx, typ) =>\n             ty::mk_box(tcx, ty::mk_i8()),\n \n-        ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n-            match ty::get(typ).sty {\n-                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => t,\n-                _ => {\n-                    let llty = sizing_type_of(ccx, typ);\n-                    // `Box<ZeroSizeType>` does not allocate.\n-                    if llsize_of_alloc(ccx, llty) == 0 {\n-                        ty::mk_i8()\n-                    } else {\n-                        ty::mk_uniq(tcx, ty::mk_i8())\n-                    }\n-                }\n+        ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ)\n+                         && ty::type_is_sized(tcx, typ) => {\n+            let llty = sizing_type_of(ccx, typ);\n+            // `Box<ZeroSizeType>` does not allocate.\n+            if llsize_of_alloc(ccx, llty) == 0 {\n+                ty::mk_i8()\n+            } else {\n+                ty::mk_uniq(tcx, ty::mk_i8())\n             }\n         }\n         _ => t\n@@ -276,8 +272,8 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n         }\n         ty::ty_uniq(content_ty) => {\n             match ty::get(content_ty).sty {\n-                ty::ty_vec(mt, None) => {\n-                    tvec::make_drop_glue_unboxed(bcx, v0, mt.ty)\n+                ty::ty_vec(ty, None) => {\n+                    tvec::make_drop_glue_unboxed(bcx, v0, ty)\n                 }\n                 ty::ty_str => {\n                     let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n@@ -297,7 +293,13 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                     })\n                 }\n                 _ => {\n-                    let llbox = Load(bcx, v0);\n+                    let llval = if ty::type_is_sized(bcx.tcx(), content_ty) {\n+                        v0\n+                    } else {\n+                        // The Box is a fat pointer\n+                        GEPi(bcx, v0, [0, abi::trt_field_box])\n+                    };\n+                    let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = drop_ty(bcx, llbox, content_ty);"}, {"sha": "3dc0904041911806616ea7a33c2a2ffc79c591af", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -666,6 +666,26 @@ fn emit_vtable_methods(bcx: &Block,\n     }).collect()\n }\n \n+pub fn vtable_ptr<'a>(bcx: &'a Block<'a>,\n+                      id: ast::NodeId,\n+                      self_ty: ty::t) -> ValueRef {\n+    let ccx = bcx.ccx();\n+    let origins = {\n+        let vtable_map = ccx.tcx.vtable_map.borrow();\n+        // This trait cast might be because of implicit coercion\n+        let adjs = ccx.tcx.adjustments.borrow();\n+        let adjust = adjs.find(&id);\n+        let method_call = if adjust.is_some() && ty::adjust_is_object(adjust.unwrap()) {\n+            MethodCall::autoobject(id)\n+        } else {\n+            MethodCall::expr(id)\n+        };\n+        let vres = vtable_map.get(&method_call).get_self().unwrap();\n+        resolve_param_vtables_under_param_substs(ccx.tcx(), bcx.fcx.param_substs, vres)\n+    };\n+    get_vtable(bcx, self_ty, origins)\n+}\n+\n pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n                             datum: Datum<Expr>,\n                             id: ast::NodeId,\n@@ -688,27 +708,16 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n         SaveIn(dest) => dest\n     };\n \n-    let ccx = bcx.ccx();\n     let v_ty = datum.ty;\n-    let llbox_ty = type_of(bcx.ccx(), datum.ty);\n+    let llbox_ty = type_of(bcx.ccx(), v_ty);\n \n     // Store the pointer into the first half of pair.\n-    let mut llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n-    llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n+    let llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n+    let llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let origins = {\n-        let vtable_map = ccx.tcx.vtable_map.borrow();\n-        // This trait cast might be because of implicit coercion\n-        let method_call = match ccx.tcx.adjustments.borrow().find(&id) {\n-            Some(&ty::AutoObject(..)) => MethodCall::autoobject(id),\n-            _ => MethodCall::expr(id)\n-        };\n-        let vres = vtable_map.get(&method_call).get_self().unwrap();\n-        resolve_param_vtables_under_param_substs(ccx.tcx(), bcx.fcx.param_substs, vres)\n-    };\n-    let vtable = get_vtable(bcx, v_ty, origins);\n+    let vtable = vtable_ptr(bcx, id, v_ty);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);"}, {"sha": "7b6d3430ae0dcb9a2b4f726a4770f06ddeec1e18", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -94,6 +94,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n             ty::MethodTraitItem(ref method) => (*method).clone(),\n         };\n         let mth_ty = ty::mk_bare_fn(tcx, method.fty.clone());\n+        debug!(\"Emit call visit method: visit_{}: {}\", ty_name, ty_to_str(tcx, mth_ty));\n         let v = self.visitor_val;\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n@@ -149,13 +150,21 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           ty::ty_float(ast::TyF32) => self.leaf(\"f32\"),\n           ty::ty_float(ast::TyF64) => self.leaf(\"f64\"),\n \n+          ty::ty_open(_) | ty::ty_str | ty::ty_vec(_, None) | ty::ty_trait(..) => {\n+              // Unfortunately we can't do anything here because at runtime we\n+              // pass around the value by pointer (*u8). But unsized pointers are\n+              // fat and so we can't just cast them to *u8 and back. So we have\n+              // to work with the pointer directly (see ty_rptr/ty_uniq). See\n+              // ty_struct for where this causes issues.\n+              fail!(\"Can't reflect unsized type\")\n+          }\n+\n           // Should rename to vec_*.\n-          ty::ty_vec(ref mt, Some(sz)) => {\n-              let extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n-              let extra = extra.append(self.c_mt(mt).as_slice());\n+          ty::ty_vec(ty, Some(sz)) => {\n+              let mut extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n+              extra.push(self.c_tydesc(ty));\n               self.visit(\"evec_fixed\", extra.as_slice())\n           }\n-          ty::ty_vec(..) | ty::ty_str | ty::ty_trait(..) => fail!(\"unexpected unsized type\"),\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n               let extra = self.c_mt(&ty::mt {\n@@ -170,19 +179,19 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           }\n           ty::ty_uniq(typ) => {\n               match ty::get(typ).sty {\n-                  ty::ty_vec(ref mt, None) => {\n-                      let extra = Vec::new();\n-                      let extra = extra.append(self.c_mt(mt).as_slice());\n-                      self.visit(\"evec_uniq\", extra.as_slice())\n-                  }\n-                  ty::ty_str => self.visit(\"estr_uniq\", &[]),\n                   ty::ty_trait(..) => {\n                       let extra = [\n                           self.c_slice(token::intern_and_get_ident(\n                                   ty_to_string(tcx, t).as_slice()))\n                       ];\n                       self.visit(\"trait\", extra);\n                   }\n+                  // FIXME(15049) allow reflection of Box<[T]>. You'll need to\n+                  // restore visit_evec_uniq.\n+                  ty::ty_vec(_, None) => {\n+                      fail!(\"Box<[T]> theoretically doesn't exist, so don't try to reflect it\")\n+                  }\n+                  ty::ty_str => fail!(\"Can't reflect Box<str> which shouldn't be used anyway\"),\n                   _ => {\n                       let extra = self.c_mt(&ty::mt {\n                           ty: typ,\n@@ -194,9 +203,8 @@ impl<'a, 'b> Reflector<'a, 'b> {\n           }\n           ty::ty_rptr(_, ref mt) => {\n               match ty::get(mt.ty).sty {\n-                  ty::ty_vec(ref mt, None) => {\n-                      let extra = Vec::new();\n-                      let extra = extra.append(self.c_mt(mt).as_slice());\n+                  ty::ty_vec(ty, None) => {\n+                      let extra = self.c_mt(&ty::mt{ty: ty, mutbl: mt.mutbl});\n                       self.visit(\"evec_slice\", extra.as_slice())\n                   }\n                   ty::ty_str => self.visit(\"estr_slice\", &[]),\n@@ -266,21 +274,34 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                       special_idents::unnamed_field.name;\n               }\n \n+              // This and the type_is_sized check on individual field types are\n+              // because we cannot reflect unsized types (see note above). We\n+              // just pretend the unsized field does not exist and print nothing.\n+              // This is sub-optimal.\n+              let len = if ty::type_is_sized(tcx, t) {\n+                  fields.len()\n+              } else {\n+                  assert!(fields.len() > 0);\n+                  fields.len() - 1\n+              };\n+\n               let extra = (vec!(\n                   self.c_slice(\n                       token::intern_and_get_ident(ty_to_string(tcx,\n                                                             t).as_slice())),\n                   self.c_bool(named_fields),\n-                  self.c_uint(fields.len())\n+                  self.c_uint(len)\n               )).append(self.c_size_and_align(t).as_slice());\n               self.bracketed(\"class\", extra.as_slice(), |this| {\n                   for (i, field) in fields.iter().enumerate() {\n-                      let extra = (vec!(\n-                        this.c_uint(i),\n-                        this.c_slice(token::get_ident(field.ident)),\n-                        this.c_bool(named_fields)\n-                      )).append(this.c_mt(&field.mt).as_slice());\n-                      this.visit(\"class_field\", extra.as_slice());\n+                      if ty::type_is_sized(tcx, field.mt.ty) {\n+                          let extra = (vec!(\n+                            this.c_uint(i),\n+                            this.c_slice(token::get_ident(field.ident)),\n+                            this.c_bool(named_fields)\n+                          )).append(this.c_mt(&field.mt).as_slice());\n+                          this.visit(\"class_field\", extra.as_slice());\n+                      }\n                   }\n               })\n           }"}, {"sha": "0ec18977139ed59411627f2692866f40919fc4a7", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 75, "deletions": 64, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -35,12 +35,12 @@ use syntax::parse::token::InternedString;\n \n fn get_len(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_lenl\");\n-    Load(bcx, GEPi(bcx, vptr, [0u, abi::slice_elt_len]))\n+    Load(bcx, expr::get_len(bcx, vptr))\n }\n \n fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n-    Load(bcx, GEPi(bcx, vptr, [0u, abi::slice_elt_base]))\n+    Load(bcx, expr::get_dataptr(bcx, vptr))\n }\n \n pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n@@ -68,7 +68,10 @@ pub fn make_drop_glue_unboxed<'a>(\n             bcx\n         };\n \n-        glue::trans_exchange_free(bcx, dataptr, 0, 8)\n+        let not_null = IsNotNull(bcx, dataptr);\n+        with_cond(bcx, not_null, |bcx| {\n+            glue::trans_exchange_free(bcx, dataptr, 0, 8)\n+        })\n     })\n }\n \n@@ -92,8 +95,7 @@ impl VecTypes {\n \n pub fn trans_fixed_vstore<'a>(\n                           bcx: &'a Block<'a>,\n-                          vstore_expr: &ast::Expr,\n-                          content_expr: &ast::Expr,\n+                          expr: &ast::Expr,\n                           dest: expr::Dest)\n                           -> &'a Block<'a> {\n     //!\n@@ -103,49 +105,53 @@ pub fn trans_fixed_vstore<'a>(\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(vstore_expr={}, dest={:?})\",\n-           bcx.expr_to_string(vstore_expr), dest.to_string(bcx.ccx()));\n+    debug!(\"trans_fixed_vstore(expr={}, dest={:?})\",\n+           bcx.expr_to_string(expr), dest.to_string(bcx.ccx()));\n \n-    let vt = vec_types_from_expr(bcx, vstore_expr);\n+    let vt = vec_types_from_expr(bcx, expr);\n \n     return match dest {\n-        Ignore => write_content(bcx, &vt, vstore_expr, content_expr, dest),\n+        Ignore => write_content(bcx, &vt, expr, expr, dest),\n         SaveIn(lldest) => {\n             // lldest will have type *[T x N], but we want the type *T,\n             // so use GEP to convert:\n             let lldest = GEPi(bcx, lldest, [0, 0]);\n-            write_content(bcx, &vt, vstore_expr, content_expr, SaveIn(lldest))\n+            write_content(bcx, &vt, expr, expr, SaveIn(lldest))\n         }\n     };\n }\n \n-pub fn trans_slice_vstore<'a>(bcx: &'a Block<'a>,\n-                              vstore_expr: &ast::Expr,\n-                              content_expr: &ast::Expr,\n-                              dest: expr::Dest)\n-                              -> &'a Block<'a> {\n+pub fn trans_slice_vec<'a>(bcx: &'a Block<'a>,\n+                           slice_expr: &ast::Expr,\n+                           content_expr: &ast::Expr)\n+                           -> DatumBlock<'a, Expr> {\n     /*!\n      * &[...] allocates memory on the stack and writes the values into it,\n-     * returning a slice (pair of ptr, len).  &\"...\" is similar except that\n-     * the memory can be statically allocated.\n+     * returning the vector (the caller must make the reference).  \"...\" is\n+     * similar except that the memory can be statically allocated and we return\n+     * a reference (strings are always by-ref).\n      */\n \n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n     let mut bcx = bcx;\n \n-    debug!(\"trans_slice_vstore(vstore_expr={}, dest={})\",\n-           bcx.expr_to_string(vstore_expr), dest.to_string(ccx));\n+    debug!(\"trans_slice_vec(slice_expr={})\",\n+           bcx.expr_to_string(slice_expr));\n+\n+    let vec_ty = node_id_type(bcx, slice_expr.id);\n \n-    // Handle the &\"...\" case:\n+    // Handle the \"...\" case (returns a slice since strings are always unsized):\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n-                    return trans_lit_str(bcx,\n-                                         content_expr,\n-                                         s.clone(),\n-                                         dest)\n+                    let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n+                    bcx = trans_lit_str(bcx,\n+                                        content_expr,\n+                                        s.clone(),\n+                                        SaveIn(scratch.val));\n+                    return DatumBlock::new(bcx, scratch.to_expr_datum());\n                 }\n                 _ => {}\n             }\n@@ -154,11 +160,16 @@ pub fn trans_slice_vstore<'a>(bcx: &'a Block<'a>,\n     }\n \n     // Handle the &[...] case:\n-    let vt = vec_types_from_expr(bcx, vstore_expr);\n+    let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n     debug!(\"    vt={}, count={:?}\", vt.to_str(ccx), count);\n     let llcount = C_uint(ccx, count);\n \n+    let fixed_ty = ty::mk_vec(bcx.tcx(),\n+                              vt.unit_ty,\n+                              Some(count));\n+    let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n+\n     let llfixed = if count == 0 {\n         // Just create a zero-sized alloca to preserve\n         // the non-null invariant of the inner slice ptr\n@@ -168,33 +179,19 @@ pub fn trans_slice_vstore<'a>(bcx: &'a Block<'a>,\n         let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n \n         // Arrange for the backing array to be cleaned up.\n-        let fixed_ty = ty::mk_vec(bcx.tcx(),\n-                                  ty::mt {ty: vt.unit_ty,\n-                                          mutbl: ast::MutMutable},\n-                                  Some(count));\n-        let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n         let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n         let cleanup_scope = cleanup::temporary_scope(bcx.tcx(), content_expr.id);\n         fcx.schedule_lifetime_end(cleanup_scope, llfixed_casted);\n         fcx.schedule_drop_mem(cleanup_scope, llfixed_casted, fixed_ty);\n \n         // Generate the content into the backing array.\n-        bcx = write_content(bcx, &vt, vstore_expr,\n+        bcx = write_content(bcx, &vt, slice_expr,\n                             content_expr, SaveIn(llfixed));\n \n-        llfixed\n+        llfixed_casted\n     };\n \n-    // Finally, create the slice pair itself.\n-    match dest {\n-        Ignore => {}\n-        SaveIn(lldest) => {\n-            Store(bcx, llfixed, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-            Store(bcx, llcount, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n-        }\n-    }\n-\n-    return bcx;\n+    immediate_rvalue_bcx(bcx, llfixed, vec_ty).to_expr_datumblock()\n }\n \n pub fn trans_lit_str<'a>(\n@@ -229,24 +226,23 @@ pub fn trans_lit_str<'a>(\n     }\n }\n \n-pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n-                             vstore_expr: &ast::Expr,\n-                             content_expr: &ast::Expr)\n-                             -> DatumBlock<'a, Expr> {\n+pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n+                          uniq_expr: &ast::Expr,\n+                          content_expr: &ast::Expr)\n+                          -> DatumBlock<'a, Expr> {\n     /*!\n      * ~[...] and \"...\".to_string() allocate boxes in the exchange heap and write\n      * the array elements into them.\n      */\n \n-    debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_string(vstore_expr));\n+    debug!(\"trans_uniq_vec(vstore_expr={})\", bcx.expr_to_string(uniq_expr));\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n-    let vt = vec_types_from_expr(bcx, vstore_expr);\n+    let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n     debug!(\"    vt={}, count={:?}\", vt.to_str(ccx), count);\n-    let llcount = C_uint(ccx, count);\n-    let vec_ty = node_id_type(bcx, vstore_expr.id);\n+    let vec_ty = node_id_type(bcx, uniq_expr.id);\n \n     let unit_sz = nonzero_llsize_of(ccx, type_of::type_of(ccx, vt.unit_ty));\n     let fill = Mul(bcx, C_uint(ccx, count), unit_sz);\n@@ -274,15 +270,19 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n         debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n                bcx.val_to_str(dataptr), count);\n \n-        let bcx = write_content(bcx, &vt, vstore_expr,\n+        let bcx = write_content(bcx, &vt, uniq_expr,\n                                 content_expr, SaveIn(dataptr));\n \n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n-    Store(bcx, dataptr, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n-    Store(bcx, llcount, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n-    DatumBlock(bcx, scratch.to_expr_datum())\n+    if ty::type_is_sized(bcx.tcx(), vec_ty) {\n+        immediate_rvalue_bcx(bcx, dataptr, vec_ty).to_expr_datumblock()\n+    } else {\n+        let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n+        Store(bcx, dataptr, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n+        Store(bcx, llcount, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n+        DatumBlock::new(bcx, scratch.to_expr_datum())\n+    }\n }\n \n pub fn write_content<'a>(\n@@ -439,11 +439,19 @@ pub fn get_fixed_base_and_len(bcx: &Block,\n \n     let ccx = bcx.ccx();\n \n-    let base = GEPi(bcx, llval, [0u, abi::slice_elt_base]);\n+    let base = expr::get_dataptr(bcx, llval);\n     let len = C_uint(ccx, vec_length);\n     (base, len)\n }\n \n+fn get_slice_base_and_len(bcx: &Block,\n+                          llval: ValueRef)\n+                          -> (ValueRef, ValueRef) {\n+    let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n+    let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+    (base, len)\n+}\n+\n pub fn get_base_and_len(bcx: &Block,\n                         llval: ValueRef,\n                         vec_ty: ty::t)\n@@ -459,15 +467,18 @@ pub fn get_base_and_len(bcx: &Block,\n     let ccx = bcx.ccx();\n \n     match ty::get(vec_ty).sty {\n-        ty::ty_vec(_, Some(n)) => {\n-            let base = GEPi(bcx, llval, [0u, 0u]);\n-            (base, C_uint(ccx, n))\n-        }\n+        ty::ty_vec(_, Some(n)) => get_fixed_base_and_len(bcx, llval, n),\n+        ty::ty_open(ty) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n+            _ => ccx.sess().bug(\"unexpected type in get_base_and_len\")\n+        },\n+\n+        // Only used for pattern matching.\n         ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n-            ty::ty_vec(_, None) | ty::ty_str => {\n-                let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n-                let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n-                (base, len)\n+            ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n+            ty::ty_vec(_, Some(n)) => {\n+                let base = GEPi(bcx, Load(bcx, llval), [0u, 0u]);\n+                (base, C_uint(ccx, n))\n             }\n             _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n         },"}, {"sha": "017d61137e4b0d0bcbcb59e79facd5071301613e", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -231,9 +231,16 @@ impl Type {\n         ], false)\n     }\n \n+    pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n+        Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n+    }\n+\n     pub fn opaque_trait(ccx: &CrateContext) -> Type {\n-        let vtable = Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to();\n-        Type::struct_(ccx, [vtable, Type::i8p(ccx)], false)\n+        Type::struct_(ccx, [Type::opaque_trait_data(ccx).ptr_to(), Type::vtable_ptr(ccx)], false)\n+    }\n+\n+    pub fn opaque_trait_data(ccx: &CrateContext) -> Type {\n+        Type::i8(ccx)\n     }\n \n     pub fn kind(&self) -> TypeKind {"}, {"sha": "9608672928d6186d3709ec33b3da3af7e4e4190f", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 66, "deletions": 25, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -15,6 +15,7 @@ use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::foreign;\n use middle::ty;\n+use util::ppaux;\n use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n@@ -160,6 +161,11 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let llsizingty = match ty::get(t).sty {\n+        _ if !ty::lltype_is_sized(cx.tcx(), t) => {\n+            cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n+                                  ppaux::ty_to_str(cx.tcx(), t)).as_slice())\n+        }\n+\n         ty::ty_nil | ty::ty_bot => Type::nil(cx),\n         ty::ty_bool => Type::bool(cx),\n         ty::ty_char => Type::char(cx),\n@@ -170,20 +176,18 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_box(..) |\n         ty::ty_ptr(..) => Type::i8p(cx),\n         ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n-            match ty::get(ty).sty {\n-                ty::ty_vec(_, None) | ty::ty_str => {\n-                    Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n-                }\n-                ty::ty_trait(..) => Type::opaque_trait(cx),\n-                _ => Type::i8p(cx),\n+            if ty::type_is_sized(cx.tcx(), ty) {\n+                Type::i8p(cx)\n+            } else {\n+                Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n             }\n         }\n \n         ty::ty_bare_fn(..) => Type::i8p(cx),\n         ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n \n-        ty::ty_vec(mt, Some(size)) => {\n-            Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n+        ty::ty_vec(ty, Some(size)) => {\n+            Type::array(&sizing_type_of(cx, ty), size as u64)\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n@@ -202,11 +206,15 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             }\n         }\n \n-        ty::ty_infer(..) | ty::ty_param(..) |\n-        ty::ty_err(..) | ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => {\n-            cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n-                                  ty::get(t).sty).as_slice())\n+        ty::ty_open(_) => {\n+            Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n+        }\n+\n+        ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n+            cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n+                                  ppaux::ty_to_str(cx.tcx(), t)).as_slice())\n         }\n+        ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => fail!(\"unreachable\")\n     };\n \n     cx.llsizingtypes.borrow_mut().insert(t, llsizingty);\n@@ -223,13 +231,22 @@ pub fn arg_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n+    fn type_of_unsize_info(cx: &CrateContext, t: ty::t) -> Type {\n+        match ty::get(ty::unsized_part_of_type(cx.tcx(), t)).sty {\n+            ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyU),\n+            ty::ty_trait(_) => Type::vtable_ptr(cx),\n+            _ => fail!(\"Unexpected type returned from unsized_part_of_type : {}\",\n+                       t.repr(cx.tcx()))\n+        }\n+    }\n+\n     // Check the cache.\n     match cx.lltypes.borrow().find(&t) {\n         Some(&llty) => return llty,\n         None => ()\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t);\n+    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), ty::get(t).sty);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n@@ -281,24 +298,33 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n           match ty::get(ty).sty {\n-              ty::ty_vec(mt, None) => {\n-                  let p_ty = type_of(cx, mt.ty).ptr_to();\n-                  let u_ty = Type::uint_from_ty(cx, ast::TyU);\n-                  Type::struct_(cx, [p_ty, u_ty], false)\n-              }\n               ty::ty_str => {\n-                  // This means we get a nicer name in the output\n+                  // This means we get a nicer name in the output (str is always\n+                  // unsized).\n                   cx.tn.find_type(\"str_slice\").unwrap()\n               }\n               ty::ty_trait(..) => Type::opaque_trait(cx),\n+              _ if !ty::type_is_sized(cx.tcx(), ty) => {\n+                  let p_ty = type_of(cx, ty).ptr_to();\n+                  Type::struct_(cx, [p_ty, type_of_unsize_info(cx, ty)], false)\n+              }\n               _ => type_of(cx, ty).ptr_to(),\n           }\n       }\n \n-      ty::ty_vec(ref mt, Some(n)) => {\n-          Type::array(&type_of(cx, mt.ty), n as u64)\n+      ty::ty_vec(ty, Some(n)) => {\n+          Type::array(&type_of(cx, ty), n as u64)\n+      }\n+      ty::ty_vec(ty, None) => {\n+          type_of(cx, ty)\n       }\n \n+      ty::ty_trait(..) => {\n+          Type::opaque_trait_data(cx)\n+      }\n+\n+      ty::ty_str => Type::i8(cx),\n+\n       ty::ty_bare_fn(_) => {\n           type_of_fn_from_ty(cx, t).ptr_to()\n       }\n@@ -326,12 +352,27 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           }\n       }\n \n-      ty::ty_vec(_, None) => cx.sess().bug(\"type_of with unsized ty_vec\"),\n-      ty::ty_str => cx.sess().bug(\"type_of with unsized (bare) ty_str\"),\n-      ty::ty_trait(..) => cx.sess().bug(\"type_of with unsized ty_trait\"),\n+      ty::ty_open(t) => match ty::get(t).sty {\n+          ty::ty_struct(..) => {\n+              let p_ty = type_of(cx, t).ptr_to();\n+              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+          }\n+          ty::ty_vec(ty, None) => {\n+              let p_ty = type_of(cx, ty).ptr_to();\n+              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+          }\n+          ty::ty_str => {\n+              let p_ty = Type::i8p(cx);\n+              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+          }\n+          ty::ty_trait(..) => Type::opaque_trait(cx),\n+          _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n+                                     ppaux::ty_to_str(cx.tcx(), t)).as_slice())\n+      },\n+\n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n-      ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\")\n+      ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\"),\n     };\n \n     debug!(\"--> mapped t={} {:?} to llty={}\","}, {"sha": "486ed71457471a34da4dfa3e52bc2115c25ca121", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 297, "deletions": 183, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -263,37 +263,141 @@ pub enum Variance {\n #[deriving(Clone)]\n pub enum AutoAdjustment {\n     AutoAddEnv(ty::TraitStore),\n-    AutoDerefRef(AutoDerefRef),\n-    AutoObject(ty::TraitStore,\n-               ty::BuiltinBounds,\n-               ast::DefId, /* Trait ID */\n-               subst::Substs /* Trait substitutions */)\n+    AutoDerefRef(AutoDerefRef)\n }\n \n-#[deriving(Clone, Decodable, Encodable)]\n+#[deriving(Clone, PartialEq)]\n+pub enum UnsizeKind {\n+    // [T, ..n] -> [T], the uint field is n.\n+    UnsizeLength(uint),\n+    // An unsize coercion applied to the tail field of a struct.\n+    // The uint is the index of the type parameter which is unsized.\n+    UnsizeStruct(Box<UnsizeKind>, uint),\n+    UnsizeVtable(ty::BuiltinBounds,\n+                 ast::DefId, /* Trait ID */\n+                 subst::Substs /* Trait substitutions */)\n+}\n+\n+#[deriving(Clone)]\n pub struct AutoDerefRef {\n     pub autoderefs: uint,\n     pub autoref: Option<AutoRef>\n }\n \n-#[deriving(Clone, Decodable, Encodable, PartialEq, Show)]\n+#[deriving(Clone, PartialEq)]\n pub enum AutoRef {\n     /// Convert from T to &T\n-    AutoPtr(Region, ast::Mutability),\n+    /// The third field allows us to wrap other AutoRef adjustments.\n+    AutoPtr(Region, ast::Mutability, Option<Box<AutoRef>>),\n \n-    /// Convert from ~[]/&[] to &[] or str\n-    AutoBorrowVec(Region, ast::Mutability),\n+    /// Convert [T, ..n] to [T] (or similar, depending on the kind)\n+    AutoUnsize(UnsizeKind),\n \n-    /// Convert from ~[]/&[] to &&[] or str\n-    AutoBorrowVecRef(Region, ast::Mutability),\n+    /// Convert Box<[T, ..n]> to Box<[T]> or something similar in a Box.\n+    /// With DST and Box a library type, this should be replaced by UnsizeStruct.\n+    AutoUnsizeUniq(UnsizeKind),\n \n     /// Convert from T to *T\n+    /// Value to thin pointer\n     AutoUnsafe(ast::Mutability),\n+}\n+\n+// Ugly little helper function. The bool in the returned tuple is true if there\n+// is an 'unsize to trait object' adjustment at the bottom of the adjustment. If\n+// that is surrounded by an AutoPtr, then we also return the region of the\n+// AutoPtr (in the third argument). The second bool is true if the adjustment is\n+// unique.\n+fn autoref_object_region(autoref: &AutoRef) -> (bool, bool, Option<Region>) {\n+    fn unsize_kind_region(k: &UnsizeKind) -> (bool, bool, Option<Region>) {\n+        match k {\n+            &UnsizeVtable(..) => (true, false, None),\n+            &UnsizeStruct(box ref k, _) => unsize_kind_region(k),\n+            _ => (false, false, None)\n+        }\n+    }\n+\n+    match autoref {\n+        &AutoUnsize(ref k) => unsize_kind_region(k),\n+        &AutoUnsizeUniq(ref k) => match k {\n+            &UnsizeVtable(..) => (true, true, None),\n+            _ => (false, false, None)\n+        },\n+        &AutoPtr(adj_r, _, Some(box ref autoref)) => {\n+            let (b, u, r) = autoref_object_region(autoref);\n+            if r.is_some() || u {\n+                (b, u, r)\n+            } else {\n+                (b, u, Some(adj_r))\n+            }\n+        }\n+        _ => (false, false, None)\n+    }\n+}\n+\n+// If the adjustment introduces a borrowed reference to a trait object, then\n+// returns the region of the borrowed reference.\n+pub fn adjusted_object_region(adj: &AutoAdjustment) -> Option<Region> {\n+    match adj {\n+        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+            let (b, _, r) = autoref_object_region(autoref);\n+            if b {\n+                r\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None\n+    }\n+}\n+\n+// Returns true if there is a trait cast at the bottom of the adjustment.\n+pub fn adjust_is_object(adj: &AutoAdjustment) -> bool {\n+    match adj {\n+        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+            let (b, _, _) = autoref_object_region(autoref);\n+            b\n+        }\n+        _ => false\n+    }\n+}\n+\n+// If possible, returns the type expected from the given adjustment. This is not\n+// possible if the adjustment depends on the type of the adjusted expression.\n+pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n+    fn type_of_autoref(cx: &ctxt, autoref: &AutoRef) -> Option<t> {\n+        match autoref {\n+            &AutoUnsize(ref k) => match k {\n+                &UnsizeVtable(bounds, def_id, ref substs) => {\n+                    Some(mk_trait(cx, def_id, substs.clone(), bounds))\n+                }\n+                _ => None\n+            },\n+            &AutoUnsizeUniq(ref k) => match k {\n+                &UnsizeVtable(bounds, def_id, ref substs) => {\n+                    Some(mk_uniq(cx, mk_trait(cx, def_id, substs.clone(), bounds)))\n+                }\n+                _ => None\n+            },\n+            &AutoPtr(r, m, Some(box ref autoref)) => {\n+                match type_of_autoref(cx, autoref) {\n+                    Some(t) => Some(mk_rptr(cx, r, mt {mutbl: m, ty: t})),\n+                    None => None\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n \n-    /// Convert from Box<Trait>/&Trait to &Trait\n-    AutoBorrowObj(Region, ast::Mutability),\n+    match adj {\n+        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+            type_of_autoref(cx, autoref)\n+        }\n+        _ => None\n+    }\n }\n \n+\n+\n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions.\n pub struct TransmuteRestriction {\n@@ -802,7 +906,7 @@ pub enum sty {\n     ty_box(t),\n     ty_uniq(t),\n     ty_str,\n-    ty_vec(mt, Option<uint>),  // Second field is length.\n+    ty_vec(t, Option<uint>), // Second field is length.\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n@@ -813,6 +917,12 @@ pub enum sty {\n     ty_tup(Vec<t>),\n \n     ty_param(ParamTy), // type parameter\n+    ty_open(t),  // A deref'ed fat pointer, i.e., a dynamically sized value\n+                 // and its size. Only ever used in trans. It is not necessary\n+                 // earlier since we don't need to distinguish a DST with its\n+                 // size (e.g., in a deref) vs a DST with the size elsewhere (\n+                 // e.g., in a field).\n+\n     ty_infer(InferTy), // something used only during inference/typeck\n     ty_err, // Also only used during inference/typeck, to represent\n             // the type of an erroneous expression (helps cut down\n@@ -1377,10 +1487,10 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_trait(box ty::TyTrait { ref substs, .. }) => {\n           flags |= sflags(substs);\n       }\n-      &ty_box(tt) | &ty_uniq(tt) => {\n+      &ty_box(tt) | &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n         flags |= get(tt).flags\n       }\n-      &ty_ptr(ref m) | &ty_vec(ref m, _) => {\n+      &ty_ptr(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n@@ -1558,14 +1668,14 @@ pub fn mk_nil_ptr(cx: &ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec(cx: &ctxt, tm: mt, sz: Option<uint>) -> t {\n-    mk_t(cx, ty_vec(tm, sz))\n+pub fn mk_vec(cx: &ctxt, t: t, sz: Option<uint>) -> t {\n+    mk_t(cx, ty_vec(t, sz))\n }\n \n pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n     mk_rptr(cx, r,\n             mt {\n-                ty: mk_vec(cx, tm, None),\n+                ty: mk_vec(cx, tm.ty, None),\n                 mutbl: tm.mutbl\n             })\n }\n@@ -1643,6 +1753,8 @@ pub fn mk_param_from_def(cx: &ctxt, def: &TypeParameterDef) -> t {\n     mk_param(cx, def.space, def.index, def.def_id)\n }\n \n+pub fn mk_open(cx: &ctxt, t: t) -> t { mk_t(cx, ty_open(t)) }\n+\n pub fn walk_ty(ty: t, f: |t|) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n@@ -1653,10 +1765,9 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(..) |\n-        ty_err => {}\n-        ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n-        ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_vec(ref tm, _) => {\n+        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(_) | ty_err => {}\n+        ty_box(ty) | ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n+        ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n@@ -1775,14 +1886,11 @@ pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n \n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n-        ty_vec(mt, _) => mt.ty,\n-        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n-        ty_box(t) | ty_uniq(t) => match get(t).sty {\n-            ty_vec(mt, None) => mt.ty,\n-            ty_str => mk_mach_uint(ast::TyU8),\n-            _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n-        },\n-        _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n+        ty_vec(ty, _) => ty,\n+        ty_str => mk_mach_uint(ast::TyU8),\n+        ty_open(ty) => sequence_element_type(cx, ty),\n+        _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n+                                 ty_to_string(cx, ty)).as_slice()),\n     }\n }\n \n@@ -1815,11 +1923,7 @@ pub fn type_is_boxed(ty: t) -> bool {\n \n pub fn type_is_region_ptr(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_rptr(_, mt) => match get(mt.ty).sty {\n-            // DST pointers should not be treated like regular pointers.\n-            ty_vec(_, None) | ty_str | ty_trait(..) => false,\n-            _ => true\n-        },\n+        ty_rptr(..) => true,\n         _ => false\n     }\n }\n@@ -1841,6 +1945,13 @@ pub fn type_is_unique(ty: t) -> bool {\n     }\n }\n \n+pub fn type_is_fat_ptr(cx: &ctxt, ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_rptr(_, mt{ty, ..}) | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n+        _ => false,\n+    }\n+}\n+\n /*\n  A scalar type is one that denotes an atomic datum, with no sub-components.\n  (A ty_ptr is scalar because it represents a non-managed pointer, so its\n@@ -2232,7 +2343,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n             // Scalar and unique types are sendable, and durable\n             ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-            ty_bare_fn(_) | ty::ty_char | ty_str => {\n+            ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n             }\n \n@@ -2267,10 +2378,15 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 }\n             }\n \n-            ty_vec(mt, _) => {\n-                tc_mt(cx, mt, cache)\n+            ty_vec(t, Some(_)) => {\n+                tc_ty(cx, t, cache)\n             }\n \n+            ty_vec(t, None) => {\n+                tc_ty(cx, t, cache) | TC::Nonsized\n+            }\n+            ty_str => TC::Nonsized,\n+\n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n@@ -2370,14 +2486,20 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 kind_bounds_to_contents(cx,\n                                         tp_def.bounds.builtin_bounds,\n                                         tp_def.bounds.trait_bounds.as_slice())\n-            }\n+           }\n \n             ty_infer(_) => {\n                 // This occurs during coherence, but shouldn't occur at other\n                 // times.\n                 TC::All\n             }\n \n+            ty_open(t) => {\n+                let result = tc_ty(cx, t, cache);\n+                assert!(!result.is_sized(cx))\n+                result.unsafe_pointer() | TC::Nonsized\n+            }\n+\n             ty_err => {\n                 cx.sess.bug(\"asked to compute contents of error type\");\n             }\n@@ -2539,7 +2661,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             // normal vectors, since they don't necessarily have the\n             // possibility to have length zero.\n             ty_vec(_, Some(0)) => false, // don't need no contents\n-            ty_vec(mt, Some(_)) => type_requires(cx, seen, r_ty, mt.ty),\n+            ty_vec(ty, Some(_)) => type_requires(cx, seen, r_ty, ty),\n \n             ty_nil |\n             ty_bot |\n@@ -2557,7 +2679,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             ty_vec(_, None) => {\n                 false\n             }\n-            ty_box(typ) | ty_uniq(typ) => {\n+            ty_box(typ) | ty_uniq(typ) | ty_open(typ) => {\n                 type_requires(cx, seen, r_ty, typ)\n             }\n             ty_rptr(_, ref mt) => {\n@@ -2680,8 +2802,8 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n-            ty_vec(mt, Some(_)) => {\n-                type_structurally_recursive(cx, sp, seen, mt.ty)\n+            ty_vec(ty, Some(_)) => {\n+                type_structurally_recursive(cx, sp, seen, ty)\n             }\n \n             // Push struct and enum def-ids onto `seen` before recursing.\n@@ -2800,11 +2922,40 @@ pub fn type_is_machine(ty: t) -> bool {\n }\n \n // Is the type's representation size known at compile time?\n-#[allow(dead_code)] // leaving in for DST\n-pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n+pub fn type_is_sized(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).is_sized(cx)\n }\n \n+pub fn lltype_is_sized(cx: &ctxt, ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_open(_) => true,\n+        _ => type_contents(cx, ty).is_sized(cx)\n+    }\n+}\n+\n+// Return the smallest part of t which is unsized. Fails if t is sized.\n+// 'Smallest' here means component of the static representation of the type; not\n+// the size of an object at runtime.\n+pub fn unsized_part_of_type(cx: &ctxt, ty: t) -> t {\n+    match get(ty).sty {\n+        ty_str | ty_trait(..) | ty_vec(..) => ty,\n+        ty_struct(_, ref substs) => {\n+            // Exactly one of the type parameters must be unsized.\n+            for tp in substs.types.get_vec(subst::TypeSpace).iter() {\n+                if !type_is_sized(cx, *tp) {\n+                    return unsized_part_of_type(cx, *tp);\n+                }\n+            }\n+            fail!(\"Unsized struct type with no unsized type params?\");\n+        }\n+        _ => {\n+            assert!(type_is_sized(cx, ty),\n+                    \"unsized_part_of_type failed even though ty is unsized\");\n+            fail!(\"called unsized_part_of_type with sized ty\");\n+        }\n+    }\n+}\n+\n // Whether a type is enum like, that is an enum type with only nullary\n // constructors\n pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n@@ -2827,49 +2978,58 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n pub fn deref(t: t, explicit: bool) -> Option<mt> {\n     match get(t).sty {\n-        ty_box(typ) | ty_uniq(typ) => match get(typ).sty {\n-            // Don't deref ~[] etc., might need to generalise this to all DST.\n-            ty_vec(_, None) | ty_str | ty_trait(..) => None,\n-            _ => Some(mt {\n-                ty: typ,\n+        ty_box(ty) | ty_uniq(ty) => {\n+            Some(mt {\n+                ty: ty,\n                 mutbl: ast::MutImmutable,\n-            }),\n-        },\n-        ty_rptr(_, mt) => match get(mt.ty).sty {\n-            // Don't deref &[], might need to generalise this to all DST.\n-            ty_vec(_, None) | ty_str | ty_trait(..) => None,\n-            _ => Some(mt),\n+            })\n         },\n+        ty_rptr(_, mt) => Some(mt),\n         ty_ptr(mt) if explicit => Some(mt),\n         _ => None\n     }\n }\n \n-// Returns the type of t[i]\n-pub fn index(t: t) -> Option<mt> {\n+pub fn close_type(cx: &ctxt, t: t) -> t {\n     match get(t).sty {\n-        ty_vec(mt, Some(_)) => Some(mt),\n-        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n-        ty_box(t) | ty_uniq(t) => match get(t).sty {\n-            ty_vec(mt, None) => Some(mt),\n-            _ => None,\n-        },\n+        ty_open(t) => mk_rptr(cx, ReStatic, mt {ty: t, mutbl:ast::MutImmutable}),\n+        _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n+                                 ty_to_str(cx, t)).as_slice())\n+    }\n+}\n+\n+pub fn type_content(t: t) -> t {\n+    match get(t).sty {\n+        ty_box(ty) | ty_uniq(ty) => ty,\n+        ty_rptr(_, mt) |ty_ptr(mt) => mt.ty,\n+        _ => t\n+    }\n+\n+}\n+\n+// Extract the unsized type in an open type (or just return t if it is not open).\n+pub fn unopen_type(t: t) -> t {\n+    match get(t).sty {\n+        ty_open(t) => t,\n+        _ => t\n+    }\n+}\n+\n+// Returns the type of t[i]\n+pub fn index(ty: t) -> Option<t> {\n+    match get(ty).sty {\n+        ty_vec(t, _) => Some(t),\n         _ => None\n     }\n }\n \n // Returns the type of elements contained within an 'array-like' type.\n // This is exactly the same as the above, except it supports strings,\n // which can't actually be indexed.\n-pub fn array_element_ty(t: t) -> Option<mt> {\n-    match get(t).sty {\n-        ty_vec(mt, Some(_)) => Some(mt),\n-        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n-        ty_box(t) | ty_uniq(t) => match get(t).sty {\n-            ty_vec(mt, None) => Some(mt),\n-            ty_str => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n-            _ => None,\n-        },\n+pub fn array_element_ty(t: t) -> Option<t> {\n+    match get(ty).sty {\n+        ty_vec(t, _) => Some(t),\n+        ty_str => Some(ty: mk_u8()),\n         _ => None\n     }\n }\n@@ -3152,126 +3312,84 @@ pub fn adjust_ty(cx: &ctxt,\n \n                     match adj.autoref {\n                         None => adjusted_ty,\n-                        Some(ref autoref) => {\n-                            match *autoref {\n-                                AutoPtr(r, m) => {\n-                                    mk_rptr(cx, r, mt {\n-                                        ty: adjusted_ty,\n-                                        mutbl: m\n-                                    })\n-                                }\n-\n-                                AutoBorrowVec(r, m) => {\n-                                    borrow_vec(cx, span, r, m, adjusted_ty)\n-                                }\n-\n-                                AutoBorrowVecRef(r, m) => {\n-                                    adjusted_ty = borrow_vec(cx,\n-                                                             span,\n-                                                             r,\n-                                                             m,\n-                                                             adjusted_ty);\n-                                    mk_rptr(cx, r, mt {\n-                                        ty: adjusted_ty,\n-                                        mutbl: ast::MutImmutable\n-                                    })\n-                                }\n-\n-                                AutoUnsafe(m) => {\n-                                    mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n-                                }\n-\n-                                AutoBorrowObj(r, m) => {\n-                                    borrow_obj(cx, span, r, m, adjusted_ty)\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                AutoObject(store, bounds, def_id, ref substs) => {\n-\n-                    let tr = mk_trait(cx, def_id, substs.clone(), bounds);\n-                    match store {\n-                        UniqTraitStore => {\n-                            mk_uniq(cx, tr)\n-                        }\n-                        RegionTraitStore(r, m) => {\n-                            mk_rptr(cx, r, mt {\n-                                ty: tr,\n-                                mutbl: m\n-                            })\n-                        }\n+                        Some(ref autoref) => adjust_for_autoref(cx, span, adjusted_ty, autoref)\n                     }\n                 }\n             }\n         }\n         None => unadjusted_ty\n     };\n \n-    fn borrow_vec(cx: &ctxt,\n-                  span: Span,\n-                  r: Region,\n-                  m: ast::Mutability,\n-                  ty: ty::t) -> ty::t {\n-        match get(ty).sty {\n-            ty_uniq(t) | ty_ptr(mt{ty: t, ..}) |\n-            ty_rptr(_, mt{ty: t, ..}) => match get(t).sty {\n-                ty::ty_vec(mt, None) => ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m}),\n-                ty::ty_str => ty::mk_str_slice(cx, r, m),\n-                _ => {\n-                    cx.sess.span_bug(\n-                        span,\n-                        format!(\"borrow-vec associated with bad sty: {:?}\",\n-                                get(ty).sty).as_slice());\n-                }\n-            },\n-            ty_vec(mt, Some(_)) => ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m}),\n+    fn adjust_for_autoref(cx: &ctxt,\n+                          span: Span,\n+                          ty: ty::t,\n+                          autoref: &AutoRef) -> ty::t{\n+        match *autoref {\n+            AutoPtr(r, m, ref a) => {\n+                let adjusted_ty = match a {\n+                    &Some(box ref a) => adjust_for_autoref(cx, span, ty, a),\n+                    &None => ty\n+                };\n+                mk_rptr(cx, r, mt {\n+                    ty: adjusted_ty,\n+                    mutbl: m\n+                })\n+            }\n \n-            ref s => {\n-                cx.sess.span_bug(\n-                    span,\n-                    format!(\"borrow-vec associated with bad sty: {:?}\",\n-                            s).as_slice());\n+            AutoUnsafe(m) => {\n+                mk_ptr(cx, mt {ty: ty, mutbl: m})\n             }\n+\n+            AutoUnsize(ref k) => unsize_ty(cx, ty, k, span),\n+            AutoUnsizeUniq(ref k) => ty::mk_uniq(cx, unsize_ty(cx, ty, k, span)),\n         }\n     }\n+}\n \n-    fn borrow_obj(cx: &ctxt, span: Span, r: Region,\n-                  m: ast::Mutability, ty: ty::t) -> ty::t {\n-        match get(ty).sty {\n-            ty_uniq(t) | ty_rptr(_, mt{ty: t, ..}) => match get(t).sty {\n-                ty_trait(box ty::TyTrait {def_id, ref substs, bounds, .. }) => {\n-                    mk_rptr(cx, r, mt {\n-                        ty: ty::mk_trait(cx, def_id, substs.clone(), bounds),\n-                        mutbl: m\n-                    })\n-                }\n-                _ => {\n-                    cx.sess.span_bug(\n-                        span,\n-                        format!(\"borrow-trait-obj associated with bad sty: {:?}\",\n-                                get(ty).sty).as_slice());\n-                }\n-            },\n-            ref s => {\n-                cx.sess.span_bug(\n-                    span,\n-                    format!(\"borrow-trait-obj associated with bad sty: {:?}\",\n-                            s).as_slice());\n+// Take a sized type and a sizing adjustment and produce an unsized version of\n+// the type.\n+pub fn unsize_ty(cx: &ctxt,\n+                 ty: ty::t,\n+                 kind: &UnsizeKind,\n+                 span: Span)\n+                 -> ty::t {\n+    match kind {\n+        &UnsizeLength(len) => match get(ty).sty {\n+            ty_vec(t, Some(n)) => {\n+                assert!(len == n);\n+                mk_vec(cx, t, None)\n+            }\n+            _ => cx.sess.span_bug(span,\n+                                  format!(\"UnsizeLength with bad sty: {}\",\n+                                          ty_to_str(cx, ty)).as_slice())\n+        },\n+        &UnsizeStruct(box ref k, tp_index) => match get(ty).sty {\n+            ty_struct(did, ref substs) => {\n+                let ty_substs = substs.types.get_vec(subst::TypeSpace);\n+                let old_ty = ty_substs.get(tp_index);\n+                let new_ty = unsize_ty(cx, *old_ty, k, span);\n+                let mut unsized_substs = substs.clone();\n+                *unsized_substs.types.get_mut_vec(subst::TypeSpace).get_mut(tp_index) = new_ty;\n+                mk_struct(cx, did, unsized_substs)\n             }\n+            _ => cx.sess.span_bug(span,\n+                                  format!(\"UnsizeStruct with bad sty: {}\",\n+                                          ty_to_str(cx, ty)).as_slice())\n+        },\n+        &UnsizeVtable(bounds, def_id, ref substs) => {\n+            mk_trait(cx, def_id, substs.clone(), bounds)\n         }\n     }\n }\n \n impl AutoRef {\n     pub fn map_region(&self, f: |Region| -> Region) -> AutoRef {\n         match *self {\n-            ty::AutoPtr(r, m) => ty::AutoPtr(f(r), m),\n-            ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(f(r), m),\n-            ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(f(r), m),\n+            ty::AutoPtr(r, m, None) => ty::AutoPtr(f(r), m, None),\n+            ty::AutoPtr(r, m, Some(ref a)) => ty::AutoPtr(f(r), m, Some(box a.map_region(f))),\n+            ty::AutoUnsize(ref k) => ty::AutoUnsize(k.clone()),\n+            ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.clone()),\n             ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n-            ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(f(r), m),\n         }\n     }\n }\n@@ -3422,8 +3540,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprUnboxedFn(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n-        ast::ExprVstore(_, ast::ExprVstoreSlice) |\n-        ast::ExprVstore(_, ast::ExprVstoreMutSlice) |\n         ast::ExprVec(..) => {\n             RvalueDpsExpr\n         }\n@@ -3473,8 +3589,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprLit(_) | // Note: LitStr is carved out above\n         ast::ExprUnary(..) |\n         ast::ExprAddrOf(..) |\n-        ast::ExprBinary(..) |\n-        ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n+        ast::ExprBinary(..) => {\n             RvalueDatumExpr\n         }\n \n@@ -3579,6 +3694,7 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n             }\n         }\n         ty_err => \"type error\".to_string(),\n+        ty_open(_) => \"opened DST\".to_string(),\n     }\n }\n \n@@ -4940,15 +5056,12 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_uniq(_) => {\n                 byte!(10);\n             }\n-            ty_vec(m, Some(n)) => {\n+            ty_vec(_, Some(n)) => {\n                 byte!(11);\n-                mt(&mut state, m);\n                 n.hash(&mut state);\n-                1u8.hash(&mut state);\n             }\n-            ty_vec(m, None) => {\n+            ty_vec(_, None) => {\n                 byte!(11);\n-                mt(&mut state, m);\n                 0u8.hash(&mut state);\n             }\n             ty_ptr(m) => {\n@@ -4997,6 +5110,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                 hash!(p.idx);\n                 did(&mut state, p.def_id);\n             }\n+            ty_open(_) => byte!(22),\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n             ty_unboxed_closure(d, r) => {"}, {"sha": "b246b5ce7a9528067515b631344e04d4e61c225e", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -360,8 +360,11 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_ptr(ref tm) => {\n             ty::ty_ptr(tm.fold_with(this))\n         }\n-        ty::ty_vec(ref tm, sz) => {\n-            ty::ty_vec(tm.fold_with(this), sz)\n+        ty::ty_vec(typ, sz) => {\n+            ty::ty_vec(typ.fold_with(this), sz)\n+        }\n+        ty::ty_open(typ) => {\n+            ty::ty_open(typ.fold_with(this))\n         }\n         ty::ty_enum(tid, ref substs) => {\n             ty::ty_enum(tid, substs.fold_with(this))\n@@ -420,11 +423,13 @@ pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n                                         -> ty::AutoRef\n {\n     match *autoref {\n-        ty::AutoPtr(r, m) => ty::AutoPtr(r.fold_with(this), m),\n-        ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(r.fold_with(this), m),\n-        ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(r.fold_with(this), m),\n+        ty::AutoPtr(r, m, None) => ty::AutoPtr(this.fold_region(r), m, None),\n+        ty::AutoPtr(r, m, Some(ref a)) => {\n+            ty::AutoPtr(this.fold_region(r), m, Some(box super_fold_autoref(this, a.clone())))\n+        }\n         ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n-        ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(r.fold_with(this), m),\n+        ty::AutoUnsize(ref k) => ty::AutoUnsize(k.clone()),\n+        ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.clone()),\n     }\n }\n "}, {"sha": "08e78b35e4d58c83dda4289d36a92756a90dc7e0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 42, "deletions": 76, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -398,10 +398,7 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n                             Some(ty::mk_mach_float(ft))\n                         }\n                         ast::TyStr => {\n-                            span_err!(tcx.sess, ast_ty.span, E0037,\n-                                      \"bare `str` is not a type\");\n-                            // return /something/ so they can at least get more errors\n-                            Some(ty::mk_uniq(tcx, ty::mk_str(tcx)))\n+                            Some(ty::mk_str(tcx))\n                         }\n                     }\n                 }\n@@ -462,21 +459,7 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                                                rscope,\n                                                &mt,\n                                                Uniq,\n-                                               |typ| {\n-                            match ty::get(typ).sty {\n-                                ty::ty_str => {\n-                                    span_err!(this.tcx().sess, path.span, E0111,\n-                                              \"`Box<str>` is not a type\");\n-                                    ty::mk_err()\n-                                }\n-                                ty::ty_vec(_, None) => {\n-                                        span_err!(this.tcx().sess, path.span, E0112,\n-                                                  \"`Box<[T]>` is not a type\");\n-                                    ty::mk_err()\n-                                }\n-                                _ => ty::mk_uniq(this.tcx(), typ),\n-                            }\n-                        }))\n+                                               |typ| ty::mk_uniq(this.tcx(), typ)));\n                     }\n                     span_err!(this.tcx().sess, path.span, E0113,\n                               \"not enough type parameters supplied to `Box<T>`\");\n@@ -537,12 +520,6 @@ enum PointerTy {\n     Uniq\n }\n \n-fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(this: &AC,\n-                                            rscope: &RS,\n-                                            ty: &ast::Ty) -> ty::mt {\n-    ty::mt {ty: ast_ty_to_ty(this, rscope, ty), mutbl: ast::MutImmutable}\n-}\n-\n pub fn trait_ref_for_unboxed_function<AC:AstConv,\n                                       RS:RegionScope>(\n                                       this: &AC,\n@@ -601,11 +578,8 @@ fn mk_pointer<AC:AstConv,\n \n     match a_seq_ty.ty.node {\n         ast::TyVec(ref ty) => {\n-            let mut mt = ast_ty_to_mt(this, rscope, &**ty);\n-            if a_seq_ty.mutbl == ast::MutMutable {\n-                mt.mutbl = ast::MutMutable;\n-            }\n-            return constr(ty::mk_vec(tcx, mt, None));\n+            let ty = ast_ty_to_ty(this, rscope, &**ty);\n+            return constr(ty::mk_vec(tcx, ty, None));\n         }\n         ast::TyUnboxedFn(ref unboxed_function) => {\n             let ty::TraitRef {\n@@ -662,37 +636,33 @@ fn mk_pointer<AC:AstConv,\n                 Some(&def::DefTrait(trait_def_id)) => {\n                     let result = ast_path_to_trait_ref(\n                         this, rscope, trait_def_id, None, path);\n-                    let trait_store = match ptr_ty {\n-                        Uniq => ty::UniqTraitStore,\n-                        RPtr(r) => {\n-                            ty::RegionTraitStore(r, a_seq_ty.mutbl)\n-                        }\n-                        _ => {\n-                            tcx.sess.span_err(\n-                                path.span,\n-                                \"~trait or &trait are the only supported \\\n-                                 forms of casting-to-trait\");\n-                            return ty::mk_err();\n-                        }\n+                    let static_region = match ptr_ty {\n+                        RPtr(r) if r == ty::ReStatic => true,\n+                        _ => false\n                     };\n                     let bounds = conv_builtin_bounds(this.tcx(),\n                                                      path.span,\n                                                      bounds,\n-                                                     trait_store);\n+                                                     static_region);\n                     let tr = ty::mk_trait(tcx,\n                                           result.def_id,\n                                           result.substs.clone(),\n                                           bounds);\n-                    // We could just match on ptr_ty, but we need to pass a trait\n-                    // store to conv_builtin_bounds, so mathc twice for now.\n-                    return match trait_store {\n-                        ty::UniqTraitStore => {\n+                    return match ptr_ty {\n+                        Uniq => {\n                             return ty::mk_uniq(tcx, tr);\n                         }\n-                        ty::RegionTraitStore(r, m) => {\n-                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: m, ty: tr});\n+                        RPtr(r) => {\n+                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: a_seq_ty.mutbl, ty: tr});\n                         }\n-                    }\n+                        _ => {\n+                            tcx.sess.span_err(\n+                                path.span,\n+                                \"~trait or &trait are the only supported \\\n+                                 forms of casting-to-trait\");\n+                            return ty::mk_err();\n+                        }\n+                    };\n                 }\n                 _ => {}\n             }\n@@ -738,10 +708,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                            |ty| ty::mk_uniq(tcx, ty))\n             }\n             ast::TyVec(ty) => {\n-                tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n-                // return /something/ so they can at least get more errors\n-                let vec_ty = ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty), None);\n-                ty::mk_uniq(tcx, vec_ty)\n+                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty), None)\n             }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n@@ -777,15 +744,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 let bound_region = opt_ast_region_to_region(this, rscope,\n                                                             ast_ty.span, region);\n \n-                let store = ty::RegionTraitStore(bound_region, ast::MutMutable);\n-\n                 // Use corresponding trait store to figure out default bounds\n                 // if none were specified.\n                 let bounds = conv_builtin_bounds(this.tcx(),\n                                                  ast_ty.span,\n                                                  &f.bounds,\n-                                                 store);\n+                                                 bound_region == ty::ReStatic);\n \n+                let store = ty::RegionTraitStore(bound_region, ast::MutMutable);\n                 let fn_decl = ty_of_closure(this,\n                                             ast_ty.id,\n                                             f.fn_style,\n@@ -803,7 +769,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 let bounds = conv_builtin_bounds(this.tcx(),\n                                                  ast_ty.span,\n                                                  &f.bounds,\n-                                                 ty::UniqTraitStore);\n+                                                 false);\n \n                 let fn_decl = ty_of_closure(this,\n                                             ast_ty.id,\n@@ -841,15 +807,17 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     _ => { },\n                 }\n                 match a_def {\n-                    def::DefTrait(_) => {\n-                        let path_str = path_to_string(path);\n-                        tcx.sess.span_err(\n-                            ast_ty.span,\n-                            format!(\"reference to trait `{name}` where a \\\n-                                     type is expected; try `Box<{name}>` or \\\n-                                     `&{name}`\",\n-                                    name=path_str).as_slice());\n-                        ty::mk_err()\n+                    def::DefTrait(trait_def_id) => {\n+                    let result = ast_path_to_trait_ref(\n+                        this, rscope, trait_def_id, None, path);\n+                    let bounds = conv_builtin_bounds(this.tcx(),\n+                                                     path.span,\n+                                                     bounds,\n+                                                     false);\n+                    ty::mk_trait(tcx,\n+                                 result.def_id,\n+                                 result.substs.clone(),\n+                                 bounds)\n                     }\n                     def::DefTy(did) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n@@ -887,10 +855,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty),\n                                            Some(i as uint)),\n                             const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty),\n                                            Some(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n@@ -1211,7 +1179,7 @@ pub fn ty_of_closure<AC:AstConv>(\n fn conv_builtin_bounds(tcx: &ty::ctxt,\n                        span: Span,\n                        ast_bounds: &Option<OwnedSlice<ast::TyParamBound>>,\n-                       store: ty::TraitStore)\n+                       static_region: bool)\n                        -> ty::BuiltinBounds {\n     //! Converts a list of bounds from the AST into a `BuiltinBounds`\n     //! struct. Reports an error if any of the bounds that appear\n@@ -1224,8 +1192,8 @@ fn conv_builtin_bounds(tcx: &ty::ctxt,\n     //! override this with an empty bounds list, e.g. \"Box<fn:()>\" or\n     //! \"Box<Trait:>\".\n \n-    match (ast_bounds, store) {\n-        (&Some(ref bound_vec), _) => {\n+    match ast_bounds {\n+        &Some(ref bound_vec) => {\n             let mut builtin_bounds = ty::empty_builtin_bounds();\n             for ast_bound in bound_vec.iter() {\n                 match *ast_bound {\n@@ -1265,12 +1233,10 @@ fn conv_builtin_bounds(tcx: &ty::ctxt,\n             builtin_bounds\n         },\n         // &'static Trait is sugar for &'static Trait:'static.\n-        (&None, ty::RegionTraitStore(ty::ReStatic, _)) => {\n+        &None if static_region => {\n             let mut set = ty::empty_builtin_bounds(); set.add(ty::BoundStatic); set\n         }\n-        // No bounds are automatically applied for &'r Trait or ~Trait\n-        (&None, ty::RegionTraitStore(..)) |\n-        (&None, ty::UniqTraitStore) => ty::empty_builtin_bounds(),\n+        &None => ty::empty_builtin_bounds(),\n     }\n }\n "}, {"sha": "77e5fbae6ee1cf53d108413029ae25642490f4f0", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -658,26 +658,26 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         let (elt_type, region_var, mutbl, fixed) = match *structure_of(fcx,\n                                                                 pat.span,\n                                                                 expected) {\n-          ty::ty_vec(mt, Some(fixed)) =>\n-            (mt.ty, default_region_var, ast::MutImmutable, Some(fixed)),\n+          ty::ty_vec(ty, Some(fixed)) =>\n+            (ty, default_region_var, ast::MutImmutable, Some(fixed)),\n           ty::ty_uniq(t) => match ty::get(t).sty {\n-              ty::ty_vec(mt, None) => {\n+              ty::ty_vec(ty, None) => {\n                   fcx.type_error_message(pat.span,\n                                          |_| {\n                                             \"unique vector patterns are no \\\n                                              longer supported\".to_string()\n                                          },\n                                          expected,\n                                          None);\n-                  (mt.ty, default_region_var, ast::MutImmutable, None)\n+                  (ty, default_region_var, ast::MutImmutable, None)\n               }\n               _ => {\n                   check_err(\"a vector pattern\".to_string());\n                   return;\n               }\n           },\n           ty::ty_rptr(r, mt) => match ty::get(mt.ty).sty {\n-              ty::ty_vec(mt, None) => (mt.ty, r, mt.mutbl, None),\n+              ty::ty_vec(ty, None) => (ty, r, mt.mutbl, None),\n               _ => {\n                   check_err(\"a vector pattern\".to_string());\n                   return;"}, {"sha": "1b10b30b3358ee1194d0d90e10cbdf9c5eba4a62", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -77,3 +77,17 @@ pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n       }\n     }\n }\n+\n+pub fn coerce_with_fn(fcx: &FnCtxt,\n+                      sp: Span,\n+                      expected: ty::t,\n+                      expr: &ast::Expr,\n+                      handle_err: |Span, ty::t, ty::t, &ty::type_err|) {\n+    let expr_ty = fcx.expr_ty(expr);\n+    match fcx.mk_assignty(expr, expr_ty, expected) {\n+      result::Ok(()) => { /* ok */ }\n+      result::Err(ref err) => {\n+        handle_err(sp, expected, expr_ty, err);\n+      }\n+    }\n+}"}, {"sha": "f3b829e60ca60e10b3d08be261795413d38baa89", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 96, "deletions": 72, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -356,23 +356,14 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let self_expr_id = self.self_expr.map(|e| e.id);\n \n-        let (self_ty, autoderefs, result) =\n+        let (_, _, result) =\n             check::autoderef(\n                 self.fcx, span, self_ty, self_expr_id, PreferMutLvalue,\n                 |self_ty, autoderefs| self.search_step(self_ty, autoderefs));\n \n         match result {\n             Some(Some(result)) => Some(result),\n-            _ => {\n-                if self.is_overloaded_deref() {\n-                    // If we are searching for an overloaded deref, no\n-                    // need to try coercing a `~[T]` to an `&[T]` and\n-                    // searching for an overloaded deref on *that*.\n-                    None\n-                } else {\n-                    self.search_for_autosliced_method(self_ty, autoderefs)\n-                }\n-            }\n+            _ => None\n         }\n     }\n \n@@ -408,6 +399,16 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n+        // If we are searching for an overloaded deref, no\n+        // need to try coercing a `~[T]` to an `&[T]` and\n+        // searching for an overloaded deref on *that*.\n+        if !self.is_overloaded_deref() {\n+            match self.search_for_autofatptrd_method(self_ty, autoderefs) {\n+                Some(result) => return Some(Some(result)),\n+                None => {}\n+            }\n+        }\n+\n         // Don't autoderef if we aren't supposed to.\n         if self.autoderef_receiver == DontAutoderefReceiver {\n             Some(None)\n@@ -441,13 +442,10 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n-                ty_uniq(ty) | ty_rptr(_, mt {ty, ..}) => match get(ty).sty{\n-                    ty_trait(box TyTrait { def_id, ref substs, .. }) => {\n-                        self.push_inherent_candidates_from_object(def_id, substs);\n-                        self.push_inherent_impl_candidates_for_type(def_id);\n-                    }\n-                    _ => {}\n-                },\n+                ty_trait(box TyTrait { def_id, ref substs, .. }) => {\n+                    self.push_inherent_candidates_from_object(def_id, substs);\n+                    self.push_inherent_impl_candidates_for_type(def_id);\n+                }\n                 ty_enum(did, _) |\n                 ty_struct(did, _) |\n                 ty_unboxed_closure(did, _) => {\n@@ -830,23 +828,22 @@ impl<'a> LookupContext<'a> {\n                                     self_ty: ty::t,\n                                     autoderefs: uint)\n                                     -> Option<MethodCallee> {\n-        let (self_ty, auto_deref_ref) =\n-            self.consider_reborrow(self_ty, autoderefs);\n-\n         // Hacky. For overloaded derefs, there may be an adjustment\n         // added to the expression from the outside context, so we do not store\n         // an explicit adjustment, but rather we hardwire the single deref\n         // that occurs in trans and mem_categorization.\n-        let adjustment = match self.self_expr {\n-            Some(expr) => Some((expr.id, ty::AutoDerefRef(auto_deref_ref))),\n-            None => return None\n-        };\n+        if self.self_expr.is_none() {\n+            return None;\n+        }\n+\n+        let (self_ty, auto_deref_ref) = self.consider_reborrow(self_ty, autoderefs);\n+        let adjustment = Some((self.self_expr.unwrap().id, ty::AutoDerefRef(auto_deref_ref)));\n \n         match self.search_for_method(self_ty) {\n             None => None,\n             Some(method) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment {:?} for {}\", adjustment, self.ty_to_string( self_ty));\n+                       adjustment {:?} for {}\", adjustment, self.ty_to_string(self_ty));\n                 match adjustment {\n                     Some((self_expr_id, adj)) => {\n                         self.fcx.write_adjustment(self_expr_id, adj);\n@@ -890,16 +887,10 @@ impl<'a> LookupContext<'a> {\n             ty::ty_rptr(_, self_mt) => {\n                 let region =\n                     self.infcx().next_region_var(infer::Autoref(self.span));\n-                let (extra_derefs, auto) = match ty::get(self_mt.ty).sty {\n-                    ty::ty_vec(_, None) => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n-                    ty::ty_str => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n-                    ty::ty_trait(..) => (0, ty::AutoBorrowObj(region, self_mt.mutbl)),\n-                    _ => (1, ty::AutoPtr(region, self_mt.mutbl)),\n-                };\n                 (ty::mk_rptr(tcx, region, self_mt),\n                  ty::AutoDerefRef {\n-                     autoderefs: autoderefs + extra_derefs,\n-                     autoref: Some(auto)})\n+                     autoderefs: autoderefs + 1,\n+                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl, None))})\n             }\n             _ => {\n                 (self_ty,\n@@ -920,26 +911,30 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn auto_slice_vec(&self, mt: ty::mt, autoderefs: uint) -> Option<MethodCallee> {\n+    // Takes an [T] - an unwrapped DST pointer (either ~ or &)\n+    // [T] to &[T] or &&[T] (note that we started with a &[T] or ~[T] which has\n+    // been implicitly derefed).\n+    fn auto_slice_vec(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n         let tcx = self.tcx();\n-        debug!(\"auto_slice_vec {}\", ppaux::ty_to_string(tcx, mt.ty));\n+        debug!(\"auto_slice_vec {}\", ppaux::ty_to_string(tcx, ty));\n \n         // First try to borrow to a slice\n         let entry = self.search_for_some_kind_of_autorefd_method(\n-            AutoBorrowVec, autoderefs, [MutImmutable, MutMutable],\n+            |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable, MutMutable],\n             |m,r| ty::mk_slice(tcx, r,\n-                               ty::mt {ty:mt.ty, mutbl:m}));\n+                               ty::mt {ty:ty, mutbl:m}));\n \n         if entry.is_some() {\n             return entry;\n         }\n \n         // Then try to borrow to a slice *and* borrow a pointer.\n         self.search_for_some_kind_of_autorefd_method(\n-            AutoBorrowVecRef, autoderefs, [MutImmutable, MutMutable],\n-            |m,r| {\n+            |r, m| AutoPtr(r, ast::MutImmutable, Some( box AutoPtr(r, m, None))),\n+            autoderefs, [MutImmutable, MutMutable],\n+            |m, r| {\n                 let slice_ty = ty::mk_slice(tcx, r,\n-                                            ty::mt {ty:mt.ty, mutbl:m});\n+                                            ty::mt {ty:ty, mutbl:m});\n                 // NB: we do not try to autoref to a mutable\n                 // pointer. That would be creating a pointer\n                 // to a temporary pointer (the borrowed\n@@ -949,29 +944,67 @@ impl<'a> LookupContext<'a> {\n             })\n     }\n \n+    // [T, ..len] -> [T] or &[T] or &&[T]\n+    fn auto_unsize_vec(&self, ty: ty::t, autoderefs: uint, len: uint) -> Option<MethodCallee> {\n+        let tcx = self.tcx();\n+        debug!(\"auto_unsize_vec {}\", ppaux::ty_to_str(tcx, ty));\n+\n+        // First try to borrow to an unsized vec.\n+        let entry = self.search_for_some_kind_of_autorefd_method(\n+            |_r, _m| AutoUnsize(ty::UnsizeLength(len)),\n+            autoderefs, [MutImmutable, MutMutable],\n+            |_m, _r| ty::mk_vec(tcx, ty, None));\n+\n+        if entry.is_some() {\n+            return entry;\n+        }\n+\n+        // Then try to borrow to a slice.\n+        let entry = self.search_for_some_kind_of_autorefd_method(\n+            |r, m| AutoPtr(r, m, Some(box AutoUnsize(ty::UnsizeLength(len)))),\n+            autoderefs, [MutImmutable, MutMutable],\n+            |m, r|  ty::mk_slice(tcx, r, ty::mt {ty:ty, mutbl:m}));\n+\n+        if entry.is_some() {\n+            return entry;\n+        }\n+\n+        // Then try to borrow to a slice *and* borrow a pointer.\n+        self.search_for_some_kind_of_autorefd_method(\n+            |r, m| AutoPtr(r, m,\n+                           Some(box AutoPtr(r, m,\n+                                            Some(box AutoUnsize(ty::UnsizeLength(len)))))),\n+            autoderefs, [MutImmutable, MutMutable],\n+            |m, r| {\n+                let slice_ty = ty::mk_slice(tcx, r, ty::mt {ty:ty, mutbl:m});\n+                ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:MutImmutable})\n+            })\n+    }\n \n     fn auto_slice_str(&self, autoderefs: uint) -> Option<MethodCallee> {\n         let tcx = self.tcx();\n         debug!(\"auto_slice_str\");\n \n         let entry = self.search_for_some_kind_of_autorefd_method(\n-            AutoBorrowVec, autoderefs, [MutImmutable],\n-            |_m,r| ty::mk_str_slice(tcx, r, MutImmutable));\n+            |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable],\n+            |_m, r| ty::mk_str_slice(tcx, r, MutImmutable));\n \n         if entry.is_some() {\n             return entry;\n         }\n \n         self.search_for_some_kind_of_autorefd_method(\n-            AutoBorrowVecRef, autoderefs, [MutImmutable],\n-            |m,r| {\n+            |r, m| AutoPtr(r, ast::MutImmutable, Some( box AutoPtr(r, m, None))),\n+            autoderefs, [MutImmutable],\n+            |m, r| {\n                 let slice_ty = ty::mk_str_slice(tcx, r, m);\n                 ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n             })\n     }\n \n     // Coerce Box/&Trait instances to &Trait.\n     fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n+        debug!(\"auto_slice_trait\");\n         match ty::get(ty).sty {\n             ty_trait(box ty::TyTrait {\n                     def_id: trt_did,\n@@ -980,7 +1013,8 @@ impl<'a> LookupContext<'a> {\n                     .. }) => {\n                 let tcx = self.tcx();\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n+                    |r, m| AutoPtr(r, m, None),\n+                    autoderefs, [MutImmutable, MutMutable],\n                     |m, r| {\n                         let tr = ty::mk_trait(tcx, trt_did, trt_substs.clone(), b);\n                         ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: m })\n@@ -990,31 +1024,24 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn search_for_autosliced_method(&self,\n-                                    self_ty: ty::t,\n-                                    autoderefs: uint)\n-                                    -> Option<MethodCallee> {\n+    fn search_for_autofatptrd_method(&self,\n+                                     self_ty: ty::t,\n+                                     autoderefs: uint)\n+                                     -> Option<MethodCallee> {\n         /*!\n          * Searches for a candidate by converting things like\n          * `~[]` to `&[]`.\n          */\n \n-        debug!(\"search_for_autosliced_method {}\", ppaux::ty_to_string(self.tcx(), self_ty));\n+        let tcx = self.tcx();\n+        debug!(\"search_for_autofatptrd_method {}\", ppaux::ty_to_string(tcx, self_ty));\n \n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n-            ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n-                ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n-                ty_trait(..) => self.auto_slice_trait(mt.ty, autoderefs),\n-                _ => None\n-            },\n-            ty_uniq(t) => match ty::get(t).sty {\n-                ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n-                ty_str => self.auto_slice_str(autoderefs),\n-                ty_trait(..) => self.auto_slice_trait(t, autoderefs),\n-                _ => None\n-            },\n-            ty_vec(mt, Some(_)) => self.auto_slice_vec(mt, autoderefs),\n+            ty_vec(ty, Some(len)) => self.auto_unsize_vec(ty, autoderefs, len),\n+            ty_vec(ty, None) => self.auto_slice_vec(ty, autoderefs),\n+            ty_str => self.auto_slice_str(autoderefs),\n+            ty_trait(..) => self.auto_slice_trait(self_ty, autoderefs),\n \n             ty_closure(..) => {\n                 // This case should probably be handled similarly to\n@@ -1042,10 +1069,10 @@ impl<'a> LookupContext<'a> {\n             ty_param(..) | ty_nil | ty_bot | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n             ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) |\n-            ty_unboxed_closure(..) | ty_tup(..) |\n+            ty_unboxed_closure(..) | ty_tup(..) | ty_open(..) |\n             ty_str | ty_vec(..) | ty_trait(..) | ty_closure(..) => {\n                 self.search_for_some_kind_of_autorefd_method(\n-                    AutoPtr, autoderefs, [MutImmutable, MutMutable],\n+                    |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable, MutMutable],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n             }\n \n@@ -1073,8 +1100,8 @@ impl<'a> LookupContext<'a> {\n             Some(expr) => Some(expr.id),\n             None => {\n                 assert_eq!(autoderefs, 0);\n-                assert_eq!(kind(ty::ReEmpty, ast::MutImmutable),\n-                           ty::AutoPtr(ty::ReEmpty, ast::MutImmutable));\n+                assert!(kind(ty::ReEmpty, ast::MutImmutable) ==\n+                        ty::AutoPtr(ty::ReEmpty, ast::MutImmutable, None));\n                 None\n             }\n         };\n@@ -1303,7 +1330,7 @@ impl<'a> LookupContext<'a> {\n         match self.fcx.mk_subty(false, infer::Misc(span),\n                                 rcvr_ty, transformed_self_ty) {\n             Ok(_) => {}\n-            Err(_) => {\n+            Err(e) => {\n                 self.bug(format!(\n                         \"{} was a subtype of {} but now is not?\",\n                         self.ty_to_string(rcvr_ty),\n@@ -1442,17 +1469,15 @@ impl<'a> LookupContext<'a> {\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         match ty::get(mt.ty).sty {\n-                            ty::ty_vec(_, None) | ty::ty_str => false,\n                             ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n                                 mutability_matches(mt.mutbl, m) &&\n                                 rcvr_matches_object(self_did, candidate)\n                             }\n                             _ => mutability_matches(mt.mutbl, m) &&\n-                                 rcvr_matches_ty(self.fcx, mt.ty, candidate),\n+                                 rcvr_matches_ty(self.fcx, mt.ty, candidate)\n                         }\n                     }\n \n-\n                     _ => false\n                 }\n             }\n@@ -1462,7 +1487,6 @@ impl<'a> LookupContext<'a> {\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {\n                         match ty::get(typ).sty {\n-                            ty::ty_vec(_, None) | ty::ty_str => false,\n                             ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n                                 rcvr_matches_object(self_did, candidate)\n                             }"}, {"sha": "6d3e001a00b0fa4038d0734d13138632bd8682eb", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 151, "deletions": 168, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -560,21 +560,6 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n \n     check_block_with_expected(&fcx, body, ExpectHasType(ret_ty));\n \n-    // We unify the tail expr's type with the\n-    // function result type, if there is a tail expr.\n-    match body.expr {\n-        Some(ref tail_expr) => {\n-            // Special case: we print a special error if there appears\n-            // to be do-block/for-loop confusion\n-            demand::suptype_with_fn(&fcx, tail_expr.span, false,\n-                fcx.ret_ty, fcx.expr_ty(&**tail_expr),\n-                |sp, e, a, s| {\n-                    fcx.report_mismatched_return_types(sp, e, a, s);\n-                });\n-        }\n-        None => {}\n-    }\n-\n     for (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n         fcx.write_ty(input.id, *arg);\n     }\n@@ -2436,8 +2421,20 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 // The tightest thing we can say is \"must unify with\n                 // else branch\". Note that in the case of a \"has type\"\n                 // constraint, this limitation does not hold.\n-                let expected = expected.only_has_type();\n \n+                // If the expected type is just a type variable, then don't use\n+                // an expected type. Otherwise, we might write parts of the type\n+                // when checking the 'then' block which are incompatible with the\n+                // 'else' branch.\n+                let expected = match expected.only_has_type() {\n+                    ExpectHasType(ety) => {\n+                        match infer::resolve_type(fcx.infcx(), ety, force_tvar) {\n+                            Ok(rty) if !ty::type_is_ty_var(rty) => ExpectHasType(rty),\n+                            _ => NoExpectation\n+                        }\n+                    }\n+                    None => None\n+                };\n                 check_block_with_expected(fcx, then_blk, expected);\n                 let then_ty = fcx.node_ty(then_blk.id);\n                 check_expr_with_expectation(fcx, &**else_expr, expected);\n@@ -3090,76 +3087,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     match expr.node {\n-        ast::ExprVstore(ev, vst) => {\n-            let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n-            let typ = match ev.node {\n-                ast::ExprVec(ref args) => {\n-                    let mutability = match vst {\n-                        ast::ExprVstoreMutSlice => ast::MutMutable,\n-                        _ => ast::MutImmutable,\n-                    };\n-                    let mut any_error = false;\n-                    let mut any_bot = false;\n-                    for e in args.iter() {\n-                        check(fcx, &**e, t);\n-                        let arg_t = fcx.expr_ty(&**e);\n-                        if ty::type_is_error(arg_t) {\n-                            any_error = true;\n-                        }\n-                        else if ty::type_is_bot(arg_t) {\n-                            any_bot = true;\n-                        }\n-                    }\n-                    if any_error {\n-                        ty::mk_err()\n-                    } else if any_bot {\n-                        ty::mk_bot()\n-                    } else {\n-                        ast_expr_vstore_to_ty(fcx, &*ev, vst, ||\n-                            ty::mt{ ty: ty::mk_vec(tcx,\n-                                                   ty::mt {ty: t, mutbl: mutability},\n-                                                   None),\n-                                                   mutbl: mutability })\n-                    }\n-                }\n-                ast::ExprRepeat(ref element, ref count_expr) => {\n-                    check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n-                    let _ = ty::eval_repeat_count(fcx, &**count_expr);\n-                    let mutability = match vst {\n-                        ast::ExprVstoreMutSlice => ast::MutMutable,\n-                        _ => ast::MutImmutable,\n-                    };\n-                    check(fcx, &**element, t);\n-                    let arg_t = fcx.expr_ty(&**element);\n-                    if ty::type_is_error(arg_t) {\n-                        ty::mk_err()\n-                    } else if ty::type_is_bot(arg_t) {\n-                        ty::mk_bot()\n-                    } else {\n-                        ast_expr_vstore_to_ty(fcx, &*ev, vst, ||\n-                            ty::mt{ ty: ty::mk_vec(tcx,\n-                                                   ty::mt {ty: t, mutbl: mutability},\n-                                                   None),\n-                                                   mutbl: mutability})\n-                    }\n-                }\n-                ast::ExprLit(_) => {\n-                    if vst == ast::ExprVstoreSlice {\n-                        span_err!(tcx.sess, expr.span, E0064,\n-                            \"`&\\\"string\\\"` has been removed; use `\\\"string\\\"` instead\");\n-                    } else {\n-                        span_err!(tcx.sess, expr.span, E0065,\n-                            \"`box \\\"string\\\"` has been removed; use \\\n-                             `\\\"string\\\".to_string()` instead\");\n-                    }\n-                    ty::mk_err()\n-                }\n-                _ => tcx.sess.span_bug(expr.span, \"vstore modifier on non-sequence\"),\n-            };\n-            fcx.write_ty(ev.id, typ);\n-            fcx.write_ty(id, typ);\n-        }\n-\n       ast::ExprBox(ref place, ref subexpr) => {\n           check_expr(fcx, &**place);\n           check_expr(fcx, &**subexpr);\n@@ -3337,30 +3264,38 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                     hint,\n                                                     lvalue_pref);\n \n-        // Note: at this point, we cannot say what the best lifetime\n-        // is to use for resulting pointer.  We want to use the\n-        // shortest lifetime possible so as to avoid spurious borrowck\n-        // errors.  Moreover, the longest lifetime will depend on the\n-        // precise details of the value whose address is being taken\n-        // (and how long it is valid), which we don't know yet until type\n-        // inference is complete.\n-        //\n-        // Therefore, here we simply generate a region variable.  The\n-        // region inferencer will then select the ultimate value.\n-        // Finally, borrowck is charged with guaranteeing that the\n-        // value whose address was taken can actually be made to live\n-        // as long as it needs to live.\n-        let region = fcx.infcx().next_region_var(\n-            infer::AddrOfRegion(expr.span));\n-\n         let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n             ty::mk_err()\n         } else if ty::type_is_bot(tm.ty) {\n             ty::mk_bot()\n         }\n         else {\n-            ty::mk_rptr(tcx, region, tm)\n+            // Note: at this point, we cannot say what the best lifetime\n+            // is to use for resulting pointer.  We want to use the\n+            // shortest lifetime possible so as to avoid spurious borrowck\n+            // errors.  Moreover, the longest lifetime will depend on the\n+            // precise details of the value whose address is being taken\n+            // (and how long it is valid), which we don't know yet until type\n+            // inference is complete.\n+            //\n+            // Therefore, here we simply generate a region variable.  The\n+            // region inferencer will then select the ultimate value.\n+            // Finally, borrowck is charged with guaranteeing that the\n+            // value whose address was taken can actually be made to live\n+            // as long as it needs to live.\n+            match oprnd.node {\n+                // String literals are already, implicitly converted to slices.\n+                //ast::ExprLit(lit) if ast_util::lit_is_str(lit) => fcx.expr_ty(oprnd),\n+                // Empty slices live in static memory.\n+                ast::ExprVec(ref elements) if elements.len() == 0 => {\n+                    ty::mk_rptr(tcx, ty::ReStatic, tm)\n+                }\n+                _ => {\n+                    let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n+                    ty::mk_rptr(tcx, region, tm)\n+                }\n+            }\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n@@ -3393,7 +3328,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n           },\n           Some(ref e) => {\n-              check_expr_has_type(fcx, &**e, ret_ty);\n+              //check_expr_has_type(fcx, e, ret_ty);\n+              check_expr_coercable_to_type(fcx, &**e, ret_ty);\n           }\n         }\n         fcx.write_bot(id);\n@@ -3547,29 +3483,60 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_cast(fcx, &**e, &**t, id, expr.span);\n       }\n       ast::ExprVec(ref args) => {\n-        let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n-        for e in args.iter() {\n-            check(fcx, &**e, t);\n-        }\n-        let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n-                             Some(args.len()));\n+        let uty = unpack_expected(\n+            fcx, expected,\n+            |sty| match *sty {\n+                ty::ty_vec(ty, _) => Some(ty),\n+                _ => None\n+        });\n+\n+        let typ = match uty {\n+            Some(uty) => {\n+                for e in args.iter() {\n+                    check_expr_coercable_to_type(fcx, &**e, uty);\n+                }\n+                uty\n+            }\n+            None => {\n+                let t: ty::t = fcx.infcx().next_ty_var();\n+                for e in args.iter() {\n+                    check_expr_has_type(fcx, &**e, t);\n+                }\n+                t\n+            }\n+        };\n+        let typ = ty::mk_vec(tcx, typ, Some(args.len()));\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n         let count = ty::eval_repeat_count(fcx, &**count_expr);\n-        let (check, t) = check_fn_for_vec_elements_expected(fcx, expected);\n-        check(fcx, &**element, t);\n-        let element_ty = fcx.expr_ty(&**element);\n+\n+        let uty = unpack_expected(\n+            fcx, expected,\n+            |sty| match *sty {\n+                ty::ty_vec(ty, _) => Some(ty),\n+                _ => None\n+        });\n+\n+        let (element_ty, t) = match uty {\n+            Some(uty) => {\n+                check_expr_coercable_to_type(fcx, &**element, uty);\n+                (uty, uty)\n+            }\n+            None => {\n+                let t: ty::t = fcx.infcx().next_ty_var();\n+                check_expr_has_type(fcx, &**element, t);\n+                (fcx.expr_ty(&**element), t)\n+            }\n+        };\n+\n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);\n-        }\n-        else if ty::type_is_bot(element_ty) {\n+        } else if ty::type_is_bot(element_ty) {\n             fcx.write_bot(id);\n-        }\n-        else {\n-            let t = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n-                               Some(count));\n+        } else {\n+            let t = ty::mk_vec(tcx, t, Some(count));\n             fcx.write_ty(id, t);\n         }\n       }\n@@ -3589,8 +3556,16 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 Some(ref fs) if i < fs.len() => ExpectHasType(*fs.get(i)),\n                 _ => NoExpectation\n             };\n-            check_expr_with_expectation(fcx, &**e, opt_hint);\n-            let t = fcx.expr_ty(&**e);\n+            let t = match opt_hint {\n+                ExpectHasType(ety) => {\n+                    check_expr_coercable_to_type(fcx, &**e, ety);\n+                    ety\n+                }\n+                _ => {\n+                    check_expr_with_expectation(fcx, &**e, opt_hint);\n+                    fcx.expr_ty(&**e)\n+                }\n+            };\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n@@ -3702,9 +3677,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n-                  Some(mt) => {\n+                  Some(ty) => {\n                       check_expr_has_type(fcx, &**idx, ty::mk_uint());\n-                      fcx.write_ty(id, mt.ty);\n+                      fcx.write_ty(id, ty);\n                       fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n                   None => {\n@@ -3985,15 +3960,23 @@ fn check_block_with_expected(fcx: &FnCtxt,\n                              e.span,\n                              \"unreachable expression\".to_string());\n             }\n-            check_expr_with_expectation(fcx, &*e, expected);\n-              let ety = fcx.expr_ty(&*e);\n-              fcx.write_ty(blk.id, ety);\n-              if any_err {\n-                  fcx.write_error(blk.id);\n-              }\n-              else if any_bot {\n-                  fcx.write_bot(blk.id);\n-              }\n+            let ety = match expected {\n+                ExpectHasType(ety) => {\n+                    check_expr_coercable_to_type(fcx, &*e, ety);\n+                    ety\n+                }\n+                _ => {\n+                    check_expr_with_expectation(fcx, &*e, expected);\n+                    fcx.expr_ty(e)\n+                }\n+            };\n+\n+            fcx.write_ty(blk.id, ety);\n+            if any_err {\n+                fcx.write_error(blk.id);\n+            } else if any_bot {\n+                fcx.write_bot(blk.id);\n+            }\n           }\n         };\n     });\n@@ -4040,9 +4023,8 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n     // emit a error.\n     GatherLocalsVisitor { fcx: fcx }.visit_expr(e, ());\n \n-    check_expr(fcx, e);\n-    let cty = fcx.expr_ty(e);\n-    demand::suptype(fcx, e.span, declty, cty);\n+    check_expr_with_hint(fcx, e, declty);\n+    demand::coerce(fcx, e.span, declty, e);\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }\n@@ -4132,6 +4114,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n+\n pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                                  vs: &[ast::P<ast::Variant>]) {\n     for &v in vs.iter() {\n@@ -4747,39 +4730,39 @@ pub fn type_is_uint(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_uint(typ_s);\n }\n \n-pub fn ast_expr_vstore_to_ty(fcx: &FnCtxt,\n-                             e: &ast::Expr,\n-                             v: ast::ExprVstore,\n-                             mk_inner: || -> ty::mt)\n-                             -> ty::t {\n-    match v {\n-        ast::ExprVstoreUniq => ty::mk_uniq(fcx.ccx.tcx, mk_inner().ty),\n-        ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n-            match e.node {\n-                ast::ExprLit(..) => {\n-                    // string literals and *empty slices* live in static memory\n-                    ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner())\n-                }\n-                ast::ExprVec(ref elements) if elements.len() == 0 => {\n-                    // string literals and *empty slices* live in static memory\n-                    ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner())\n-                }\n-                ast::ExprRepeat(..) |\n-                ast::ExprVec(..) => {\n-                    // vector literals are temporaries on the stack\n-                    match fcx.tcx().region_maps.temporary_scope(e.id) {\n-                        Some(scope) => ty::mk_rptr(fcx.ccx.tcx, ty::ReScope(scope), mk_inner()),\n-                        None => ty::mk_rptr(fcx.ccx.tcx, ty::ReStatic, mk_inner()),\n-                    }\n-                }\n-                _ => {\n-                    fcx.ccx.tcx.sess.span_bug(e.span,\n-                                              \"vstore with unexpected \\\n-                                               contents\")\n-                }\n-            }\n-        }\n-    }\n+pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_scalar(typ_s);\n+}\n+\n+pub fn type_is_char(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_char(typ_s);\n+}\n+\n+pub fn type_is_bare_fn(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_bare_fn(typ_s);\n+}\n+\n+pub fn type_is_floating_point(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_floating_point(typ_s);\n+}\n+\n+pub fn type_is_unsafe_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_unsafe_ptr(typ_s);\n+}\n+\n+pub fn type_is_region_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_region_ptr(typ_s);\n+}\n+\n+pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n // Returns true if b contains a break that can exit from b"}, {"sha": "4f77c89e86c1d5bbaea919ccf2fdd8646a1c93a6", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -413,40 +413,43 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n         debug!(\"adjustment={:?}\", adjustment);\n         match *adjustment {\n-            ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: opt_autoref}) => {\n+            ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n-                for autoref in opt_autoref.iter() {\n-                    link_autoref(rcx, expr, autoderefs, autoref);\n-\n-                    // Require that the resulting region encompasses\n-                    // the current node.\n-                    //\n-                    // FIXME(#6268) remove to support nested method calls\n-                    constrain_regions_in_type_of_node(\n-                        rcx, expr.id, ty::ReScope(expr.id),\n-                        infer::AutoBorrow(expr.span));\n+                match ty::adjusted_object_region(adjustment) {\n+                    Some(trait_region) => {\n+                        // Determine if we are casting `expr` to a trait\n+                        // instance.  If so, we have to be sure that the type of\n+                        // the source obeys the trait's region bound.\n+                        //\n+                        // Note: there is a subtle point here concerning type\n+                        // parameters.  It is possible that the type of `source`\n+                        // contains type parameters, which in turn may contain\n+                        // regions that are not visible to us (only the caller\n+                        // knows about them).  The kind checker is ultimately\n+                        // responsible for guaranteeing region safety in that\n+                        // particular case.  There is an extensive comment on the\n+                        // function check_cast_for_escaping_regions() in kind.rs\n+                        // explaining how it goes about doing that.\n+\n+                        constrain_regions_in_type(rcx, trait_region,\n+                                                  infer::RelateObjectBound(expr.span), expr_ty);\n+                    }\n+                    None => {\n+                        for autoref in opt_autoref.iter() {\n+                            link_autoref(rcx, expr, autoderefs, autoref);\n+\n+                            // Require that the resulting region encompasses\n+                            // the current node.\n+                            //\n+                            // FIXME(#6268) remove to support nested method calls\n+                            constrain_regions_in_type_of_node(\n+                                rcx, expr.id, ty::ReScope(expr.id),\n+                                infer::AutoBorrow(expr.span));\n+                        }\n+                    }\n                 }\n             }\n-            ty::AutoObject(ty::RegionTraitStore(trait_region, _), _, _, _) => {\n-                // Determine if we are casting `expr` to a trait\n-                // instance.  If so, we have to be sure that the type of\n-                // the source obeys the trait's region bound.\n-                //\n-                // Note: there is a subtle point here concerning type\n-                // parameters.  It is possible that the type of `source`\n-                // contains type parameters, which in turn may contain\n-                // regions that are not visible to us (only the caller\n-                // knows about them).  The kind checker is ultimately\n-                // responsible for guaranteeing region safety in that\n-                // particular case.  There is an extensive comment on the\n-                // function check_cast_for_escaping_regions() in kind.rs\n-                // explaining how it goes about doing that.\n-\n-                let source_ty = rcx.resolve_node_type(expr.id);\n-                constrain_regions_in_type(rcx, trait_region,\n-                                            infer::RelateObjectBound(expr.span), source_ty);\n-            }\n             _ => {}\n         }\n     }\n@@ -1176,24 +1179,12 @@ fn link_autoref(rcx: &Rcx,\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n-        ty::AutoPtr(r, m) => {\n-            link_region(rcx, expr.span, r,\n-                        ty::BorrowKind::from_mutbl(m), expr_cmt);\n-        }\n-\n-        ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n-            let cmt_index = mc.cat_index(expr, expr_cmt, autoderefs+1);\n-            link_region(rcx, expr.span, r,\n-                        ty::BorrowKind::from_mutbl(m), cmt_index);\n-        }\n-\n-        ty::AutoBorrowObj(r, m) => {\n-            let cmt_deref = mc.cat_deref_obj(expr, expr_cmt);\n+        ty::AutoPtr(r, m, _) => {\n             link_region(rcx, expr.span, r,\n-                        ty::BorrowKind::from_mutbl(m), cmt_deref);\n+                ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n-        ty::AutoUnsafe(_) => {}\n+        ty::AutoUnsafe(_) | ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) => {}\n     }\n }\n "}, {"sha": "5b14ee62b0aec3bb817491b0a9695921a33d1495", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 158, "deletions": 104, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -10,7 +10,7 @@\n \n \n use middle::ty;\n-use middle::ty::{AutoAddEnv, AutoDerefRef, AutoObject, ParamTy};\n+use middle::ty::{AutoDerefRef, ParamTy};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n@@ -388,7 +388,6 @@ fn search_for_vtable(vcx: &VtableContext,\n                      trait_ref: Rc<ty::TraitRef>,\n                      is_early: bool)\n                      -> Option<vtable_origin> {\n-    debug!(\"nrc - search_for_vtable\");\n     let tcx = vcx.tcx();\n \n     // First, check to see whether this is a call to the `call` method of an\n@@ -630,14 +629,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n-    let resolve_object_cast = |src: &ast::Expr, target_ty: ty::t, key: MethodCall| {\n-      // Look up vtables for the type we're casting to,\n-      // passing in the source and target type.  The source\n-      // must be a pointer type suitable to the object sigil,\n-      // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-      // Bounds of type's contents are not checked here, but in kind.rs.\n-      let src_ty = structurally_resolved_type(fcx, ex.span,\n-                                              fcx.expr_ty(src));\n+    let check_object_cast = |src_ty: ty::t, target_ty: ty::t| {\n+      // Check that a cast is of correct types.\n       match (&ty::get(target_ty).sty, &ty::get(src_ty).sty) {\n           (&ty::ty_rptr(_, ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n             if !mutability_allowed(mt.mutbl, mutbl) => {\n@@ -648,74 +641,14 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                   _ => {}\n               }\n           }\n-\n-          (&ty::ty_uniq(ty), &ty::ty_uniq(..) ) |\n-          (&ty::ty_rptr(_, ty::mt{ty, ..}), &ty::ty_rptr(..)) => {\n-              match ty::get(ty).sty {\n-                  ty::ty_trait(box ty::TyTrait {\n-                      def_id: target_def_id, substs: ref target_substs, ..\n-                  }) => {\n-                      debug!(\"nrc correct path\");\n-                      let typ = match &ty::get(src_ty).sty {\n-                          &ty::ty_uniq(typ) => typ,\n-                          &ty::ty_rptr(_, mt) => mt.ty,\n-                          _ => fail!(\"shouldn't get here\"),\n-                      };\n-\n-                      let vcx = fcx.vtable_context();\n-\n-                      // Take the type parameters from the object\n-                      // type, but set the Self type (which is\n-                      // unknown, for the object type) to be the type\n-                      // we are casting from.\n-                      let mut target_types = target_substs.types.clone();\n-                      assert!(target_types.get_self().is_none());\n-                      target_types.push(subst::SelfSpace, typ);\n-\n-                      let target_trait_ref = Rc::new(ty::TraitRef {\n-                          def_id: target_def_id,\n-                          substs: subst::Substs {\n-                              regions: target_substs.regions.clone(),\n-                              types: target_types\n-                          }\n-                      });\n-\n-                      let param_bounds = ty::ParamBounds {\n-                          builtin_bounds: ty::empty_builtin_bounds(),\n-                          trait_bounds: vec!(target_trait_ref)\n-                      };\n-                      let vtables =\n-                            lookup_vtables_for_param(&vcx,\n-                                                     ex.span,\n-                                                     None,\n-                                                     &param_bounds,\n-                                                     typ,\n-                                                     is_early);\n-\n-                      if !is_early {\n-                          let mut r = VecPerParamSpace::empty();\n-                          r.push(subst::SelfSpace, vtables);\n-                          insert_vtables(fcx, key, r);\n-                      }\n-\n-                      // Now, if this is &trait, we need to link the\n-                      // regions.\n-                      match (&ty::get(src_ty).sty, &ty::get(target_ty).sty) {\n-                          (&ty::ty_rptr(ra, _), &ty::ty_rptr(rb, _)) => {\n-                              debug!(\"nrc - make subr\");\n-                              infer::mk_subr(fcx.infcx(),\n-                                             false,\n-                                             infer::RelateObjectBound(ex.span),\n-                                             rb,\n-                                             ra);\n-                          }\n-                          _ => {}\n-                      }\n-                  }\n-                  _ => {}\n-              }\n+          (&ty::ty_uniq(..), &ty::ty_uniq(..) ) => {}\n+          (&ty::ty_rptr(r_t, _), &ty::ty_rptr(r_s, _)) => {\n+              infer::mk_subr(fcx.infcx(),\n+                             false,\n+                             infer::RelateObjectBound(ex.span),\n+                             r_t,\n+                             r_s);\n           }\n-\n           (&ty::ty_uniq(ty), _) => {\n               match ty::get(ty).sty {\n                   ty::ty_trait(..) => {\n@@ -737,7 +670,55 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                   _ => {}\n               }\n           }\n+          _ => {}\n+      }\n+    };\n+    let resolve_object_cast = |src_ty: ty::t, target_ty: ty::t, key: MethodCall| {\n+      // Look up vtables for the type we're casting to,\n+      // passing in the source and target type.  The source\n+      // must be a pointer type suitable to the object sigil,\n+      // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n+      // Bounds of type's contents are not checked here, but in kind.rs.\n+      match ty::get(target_ty).sty {\n+          ty::ty_trait(box ty::TyTrait {\n+              def_id: target_def_id, substs: ref target_substs, ..\n+          }) => {\n+              let vcx = fcx.vtable_context();\n+\n+              // Take the type parameters from the object\n+              // type, but set the Self type (which is\n+              // unknown, for the object type) to be the type\n+              // we are casting from.\n+              let mut target_types = target_substs.types.clone();\n+              assert!(target_types.get_self().is_none());\n+              target_types.push(subst::SelfSpace, src_ty);\n+\n+              let target_trait_ref = Rc::new(ty::TraitRef {\n+                  def_id: target_def_id,\n+                  substs: subst::Substs {\n+                      regions: target_substs.regions.clone(),\n+                      types: target_types\n+                  }\n+              });\n+\n+              let param_bounds = ty::ParamBounds {\n+                  builtin_bounds: ty::empty_builtin_bounds(),\n+                  trait_bounds: vec!(target_trait_ref)\n+              };\n+              let vtables =\n+                    lookup_vtables_for_param(&vcx,\n+                                             ex.span,\n+                                             None,\n+                                             &param_bounds,\n+                                             src_ty,\n+                                             is_early);\n \n+              if !is_early {\n+                  let mut r = VecPerParamSpace::empty();\n+                  r.push(subst::SelfSpace, vtables);\n+                  insert_vtables(fcx, key, r);\n+              }\n+          }\n           _ => {}\n       }\n     };\n@@ -792,8 +773,16 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       ast::ExprCast(ref src, _) => {\n           debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n-          let key = MethodCall::expr(ex.id);\n-          resolve_object_cast(&**src, target_ty, key);\n+          let src_ty = structurally_resolved_type(fcx, ex.span,\n+                                                  fcx.expr_ty(&**src));\n+          check_object_cast(src_ty, target_ty);\n+          match (ty::deref(src_ty, false), ty::deref(target_ty, false)) {\n+              (Some(s), Some(t)) => {\n+                  let key = MethodCall::expr(ex.id);\n+                  resolve_object_cast(s.ty, t.ty, key)\n+              }\n+              _ => {}\n+          }\n       }\n       _ => ()\n     }\n@@ -802,7 +791,26 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     match fcx.inh.adjustments.borrow().find(&ex.id) {\n         Some(adjustment) => {\n             match *adjustment {\n-                AutoDerefRef(adj) => {\n+                _ if ty::adjust_is_object(adjustment) => {\n+                    let src_ty = structurally_resolved_type(fcx, ex.span,\n+                                                            fcx.expr_ty(ex));\n+                    match ty::type_of_adjust(fcx.tcx(), adjustment) {\n+                        Some(target_ty) => {\n+                            check_object_cast(src_ty, target_ty)\n+                        }\n+                        None => {}\n+                    }\n+\n+                    match trait_cast_types(fcx, adjustment, src_ty, ex.span) {\n+                        Some((s, t)) => {\n+                            let key = MethodCall::autoobject(ex.id);\n+                            resolve_object_cast(s, t, key)\n+                        }\n+                        None => fail!(\"Couldn't extract types from adjustment\")\n+                    }\n+                }\n+                AutoDerefRef(ref adj) => {\n+                    assert!(!ty::adjust_is_object(adjustment));\n                     for autoderef in range(0, adj.autoderefs) {\n                         let method_call = MethodCall::autoderef(ex.id, autoderef);\n                         match fcx.inh.method_map.borrow().find(&method_call) {\n@@ -823,37 +831,83 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                         }\n                     }\n                 }\n-                AutoObject(store,\n-                           bounds,\n-                           def_id,\n-                           ref substs) => {\n-                    debug!(\"doing trait adjustment for expr {} {} \\\n-                            (early? {})\",\n-                           ex.id,\n-                           ex.repr(fcx.tcx()),\n-                           is_early);\n-\n-                    let trait_ty = ty::mk_trait(cx.tcx,\n-                                                def_id,\n-                                                substs.clone(),\n-                                                bounds);\n-                    let object_ty = match store {\n-                        ty::UniqTraitStore => ty::mk_uniq(cx.tcx, trait_ty),\n-                        ty::RegionTraitStore(r, m) => {\n-                            ty::mk_rptr(cx.tcx, r, ty::mt {ty: trait_ty, mutbl: m})\n-                        }\n-                    };\n-\n-                    let key = MethodCall::autoobject(ex.id);\n-                    resolve_object_cast(ex, object_ty, key);\n+                _ => {\n+                    assert!(!ty::adjust_is_object(adjustment));\n                 }\n-                AutoAddEnv(..) => {}\n             }\n         }\n         None => {}\n     }\n }\n \n+// When we coerce (possibly implicitly) from a concrete type to a trait type, this\n+// function returns the concrete type and trait. This might happen arbitrarily\n+// deep in the adjustment. This function will fail if the adjustment does not\n+// match the source type.\n+// This function will always return types if ty::adjust_is_object is true for the\n+// adjustment\n+fn trait_cast_types(fcx: &FnCtxt,\n+                    adj: &ty::AutoAdjustment,\n+                    src_ty: ty::t,\n+                    sp: Span)\n+                    -> Option<(ty::t, ty::t)> {\n+    fn trait_cast_types_autoref(fcx: &FnCtxt,\n+                                autoref: &ty::AutoRef,\n+                                src_ty: ty::t,\n+                                sp: Span)\n+                                -> Option<(ty::t, ty::t)> {\n+        fn trait_cast_types_unsize(fcx: &FnCtxt,\n+                                   k: &ty::UnsizeKind,\n+                                   src_ty: ty::t,\n+                                   sp: Span)\n+                                   -> Option<(ty::t, ty::t)> {\n+            match k {\n+                &ty::UnsizeVtable(bounds, def_id, ref substs) => {\n+                    Some((src_ty, ty::mk_trait(fcx.tcx(), def_id, substs.clone(), bounds)))\n+                }\n+                &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(src_ty).sty {\n+                    ty::ty_struct(_, ref substs) => {\n+                        let ty_substs = substs.types.get_vec(subst::TypeSpace);\n+                        let field_ty = *ty_substs.get(tp_index);\n+                        let field_ty = structurally_resolved_type(fcx, sp, field_ty);\n+                        trait_cast_types_unsize(fcx, k, field_ty, sp)\n+                    }\n+                    _ => fail!(\"Failed to find a ty_struct to correspond with \\\n+                                UnsizeStruct whilst walking adjustment. Found {}\",\n+                                ppaux::ty_to_str(fcx.tcx(), src_ty))\n+                },\n+                _ => None\n+            }\n+        }\n+\n+        match autoref {\n+            &ty::AutoUnsize(ref k) => trait_cast_types_unsize(fcx, k, src_ty, sp),\n+            &ty::AutoUnsizeUniq(ref k) => match k {\n+                &ty::UnsizeVtable(bounds, def_id, ref substs) => {\n+                    Some((src_ty, ty::mk_trait(fcx.tcx(), def_id, substs.clone(), bounds)))\n+                }\n+                _ => None\n+            },\n+            &ty::AutoPtr(_, _, Some(box ref autoref)) => {\n+                trait_cast_types_autoref(fcx, autoref, src_ty, sp)\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    match adj {\n+        &ty::AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), autoderefs}) => {\n+            let mut derefed_type = src_ty;\n+            for _ in range(0, autoderefs) {\n+                derefed_type = ty::deref(derefed_type, false).unwrap().ty;\n+                derefed_type = structurally_resolved_type(fcx, sp, derefed_type)\n+            }\n+            trait_cast_types_autoref(fcx, autoref, derefed_type, sp)\n+        }\n+        _ => None\n+    }\n+}\n+\n pub fn resolve_impl(tcx: &ty::ctxt,\n                     impl_item: &ast::Item,\n                     impl_generics: &ty::Generics,"}, {"sha": "7951c8dfc1980b8d087d2336ff2b95ef5964f091", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -259,6 +259,7 @@ impl<'cx> WritebackCx<'cx> {\n             }\n \n             Some(adjustment) => {\n+                let adj_object = ty::adjust_is_object(&adjustment);\n                 let resolved_adjustment = match adjustment {\n                     ty::AutoAddEnv(store) => {\n                         // FIXME(eddyb) #2190 Allow only statically resolved\n@@ -286,24 +287,17 @@ impl<'cx> WritebackCx<'cx> {\n                             self.visit_vtable_map_entry(reason, method_call);\n                         }\n \n+                        if adj_object {\n+                            let method_call = MethodCall::autoobject(id);\n+                            self.visit_method_map_entry(reason, method_call);\n+                            self.visit_vtable_map_entry(reason, method_call);\n+                        }\n+\n                         ty::AutoDerefRef(ty::AutoDerefRef {\n                             autoderefs: adj.autoderefs,\n                             autoref: self.resolve(&adj.autoref, reason),\n                         })\n                     }\n-\n-                    ty::AutoObject(trait_store, bb, def_id, substs) => {\n-                        let method_call = MethodCall::autoobject(id);\n-                        self.visit_method_map_entry(reason, method_call);\n-                        self.visit_vtable_map_entry(reason, method_call);\n-\n-                        ty::AutoObject(\n-                            self.resolve(&trait_store, reason),\n-                            self.resolve(&bb, reason),\n-                            def_id,\n-                            self.resolve(&substs, reason)\n-                        )\n-                    }\n                 };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n                 self.tcx().adjustments.borrow_mut().insert("}, {"sha": "a6fa9d84600bf6d5fb8fea5c95f6b16a79b64a4e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -23,7 +23,7 @@ use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{lookup_item_type};\n use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n-use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n+use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil, ty_open};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n@@ -86,7 +86,7 @@ fn get_base_type(inference_context: &InferCtxt,\n \n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n-        ty_infer(..) | ty_param(..) | ty_err |\n+        ty_infer(..) | ty_param(..) | ty_err | ty_open(..) |\n         ty_box(_) | ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n@@ -166,6 +166,9 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                                enum, struct, or trait\");\n                     }\n                 },\n+                ty_trait(box ty::TyTrait { def_id, .. }) => {\n+                    Some(def_id)\n+                }\n                 _ => {\n                     fail!(\"get_base_type() returned a type that wasn't an \\\n                            enum, struct, or trait\");"}, {"sha": "6d0b34e89d679da56a2837b904221daadcedaf39", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 199, "deletions": 107, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -65,14 +65,15 @@ we may want to adjust precisely when coercions occur.\n */\n \n use middle::subst;\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowObj, AutoDerefRef};\n+use middle::ty::{AutoPtr, AutoDerefRef, AutoUnsize};\n use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n use middle::typeck::infer::combine::{CombineFields, Combine};\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n use util::common::indenter;\n+use util::ppaux;\n use util::ppaux::Repr;\n \n use syntax::abi;\n@@ -94,38 +95,51 @@ impl<'f> Coerce<'f> {\n                b.repr(self.get_ref().infcx.tcx));\n         let _indent = indenter();\n \n+        // Special case: if the subtype is a sized array literal (`[T, ..n]`),\n+        // then it would get auto-borrowed to `&[T, ..n]` and then DST-ified\n+        // to `&[T]`. Doing it all at once makes the target code a bit more\n+        // efficient and spares us from having to handle multiple coercions.\n+        match ty::get(b).sty {\n+            ty::ty_rptr(_, mt_b) => {\n+                match ty::get(mt_b.ty).sty {\n+                    ty::ty_vec(_, None) => {\n+                        let unsize_and_ref = self.unpack_actual_value(a, |sty_a| {\n+                            self.coerce_unsized_with_borrow(a, sty_a, b, mt_b.mutbl)\n+                        });\n+                        if unsize_and_ref.is_ok() {\n+                            return unsize_and_ref;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // Consider coercing the subtype to a DST\n+        let unsize = self.unpack_actual_value(a, |sty_a| {\n+            self.coerce_unsized(a, sty_a, b)\n+        });\n+        if unsize.is_ok() {\n+            return unsize;\n+        }\n+\n         // Examine the supertype and consider auto-borrowing.\n         //\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n         match ty::get(b).sty {\n-            ty::ty_rptr(r_b, mt_b) => {\n+            ty::ty_rptr(_, mt_b) => {\n                 match ty::get(mt_b.ty).sty {\n-                    ty::ty_vec(mt_b, None) => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_vector(a, sty_a, b, mt_b.mutbl)\n-                        });\n-                    }\n-                    ty::ty_vec(_, _) => {},\n                     ty::ty_str => {\n                         return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_string(a, sty_a, b)\n+                            self.coerce_borrowed_pointer(a, sty_a, b, ast::MutImmutable)\n                         });\n                     }\n \n-                    ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds }) => {\n+                    ty::ty_trait(..) => {\n                         let result = self.unpack_actual_value(a, |sty_a| {\n-                            match *sty_a {\n-                                ty::ty_rptr(_, mt_a) => match ty::get(mt_a.ty).sty {\n-                                    ty::ty_trait(..) => {\n-                                        self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n-                                    }\n-                                    _ => self.coerce_object(a, sty_a, b, def_id, substs,\n-                                                            ty::RegionTraitStore(r_b, mt_b.mutbl),\n-                                                            bounds)\n-                                },\n-                                _ => self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n-                            }\n+                            self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n                         });\n \n                         match result {\n@@ -136,37 +150,12 @@ impl<'f> Coerce<'f> {\n \n                     _ => {\n                         return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n+                            self.coerce_borrowed_pointer(a, sty_a, b, mt_b.mutbl)\n                         });\n                     }\n                 };\n             }\n \n-            ty::ty_uniq(t_b) => {\n-                match ty::get(t_b).sty {\n-                    ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds }) => {\n-                        let result = self.unpack_actual_value(a, |sty_a| {\n-                            match *sty_a {\n-                                ty::ty_uniq(t_a) => match ty::get(t_a).sty {\n-                                    ty::ty_trait(..) => {\n-                                        Err(ty::terr_mismatch)\n-                                    }\n-                                    _ => self.coerce_object(a, sty_a, b, def_id, substs,\n-                                                            ty::UniqTraitStore, bounds)\n-                                },\n-                                _ => Err(ty::terr_mismatch)\n-                            }\n-                        });\n-\n-                        match result {\n-                            Ok(t) => return Ok(t),\n-                            Err(..) => {}\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n             ty::ty_closure(box ty::ClosureTy {\n                     store: ty::RegionTraitStore(..),\n                     ..\n@@ -221,20 +210,21 @@ impl<'f> Coerce<'f> {\n                 self.get_ref().infcx.tcx.sess.span_bug(\n                     self.get_ref().trace.origin.span(),\n                     format!(\"failed to resolve even without \\\n-                          any force options: {:?}\", e).as_slice());\n+                             any force options: {:?}\", e).as_slice());\n             }\n         }\n     }\n \n+    // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n     pub fn coerce_borrowed_pointer(&self,\n                                    a: ty::t,\n                                    sty_a: &ty::sty,\n                                    b: ty::t,\n-                                   mt_b: ty::mt)\n+                                   mutbl_b: ast::Mutability)\n                                    -> CoerceResult {\n-        debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={}, mt_b={:?})\",\n+        debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n-               b.repr(self.get_ref().infcx.tcx), mt_b);\n+               b.repr(self.get_ref().infcx.tcx));\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -256,64 +246,182 @@ impl<'f> Coerce<'f> {\n \n         let a_borrowed = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                      r_borrow,\n-                                     mt {ty: inner_ty, mutbl: mt_b.mutbl});\n+                                     mt {ty: inner_ty, mutbl: mutbl_b});\n         if_ok!(sub.tys(a_borrowed, b));\n+\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n-            autoref: Some(AutoPtr(r_borrow, mt_b.mutbl))\n+            autoref: Some(AutoPtr(r_borrow, mutbl_b, None))\n         })))\n     }\n \n-    pub fn coerce_borrowed_string(&self,\n+    // [T, ..n] -> &[T] or &mut [T]\n+    fn coerce_unsized_with_borrow(&self,\n                                   a: ty::t,\n                                   sty_a: &ty::sty,\n-                                  b: ty::t)\n+                                  b: ty::t,\n+                                  mutbl_b: ast::Mutability)\n                                   -> CoerceResult {\n-        debug!(\"coerce_borrowed_string(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsized_with_borrow(a={}, sty_a={:?}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n         match *sty_a {\n-            ty::ty_uniq(_) => return Err(ty::terr_mismatch),\n-            _ => return self.subtype(a, b),\n+            ty::ty_vec(t_a, Some(len)) => {\n+                let sub = Sub(self.get_ref().clone());\n+                let coercion = Coercion(self.get_ref().trace.clone());\n+                let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n+                let unsized_ty = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n+                                              mt {ty: t_a, mutbl: mutbl_b});\n+                if_ok!(self.get_ref().infcx.try(|| sub.tys(unsized_ty, b)));\n+                Ok(Some(AutoDerefRef(AutoDerefRef {\n+                    autoderefs: 0,\n+                    autoref: Some(ty::AutoPtr(r_borrow,\n+                                              mutbl_b,\n+                                              Some(box AutoUnsize(ty::UnsizeLength(len)))))\n+                })))\n+            }\n+            _ => Err(ty::terr_mismatch)\n         }\n     }\n \n-    pub fn coerce_borrowed_vector(&self,\n-                                  a: ty::t,\n-                                  sty_a: &ty::sty,\n-                                  b: ty::t,\n-                                  mutbl_b: ast::Mutability)\n-                                  -> CoerceResult {\n-        debug!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n+    // &[T, ..n] or &mut [T, ..n] -> &[T]\n+    // or &mut [T, ..n] -> &mut [T]\n+    // or &Concrete -> &Trait, etc.\n+    fn coerce_unsized(&self,\n+                      a: ty::t,\n+                      sty_a: &ty::sty,\n+                      b: ty::t)\n+                      -> CoerceResult {\n+        debug!(\"coerce_unsized(a={}, sty_a={:?}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n+        // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n+        // a DST unless we have to. This currently comes out in the wash since\n+        // we can't unify [T] with U. But to properly support DST, we need to allow\n+        // that, at which point we will need extra checks on b here.\n+\n         let sub = Sub(self.get_ref().clone());\n-        let coercion = Coercion(self.get_ref().trace.clone());\n-        let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n-        let ty_inner = match *sty_a {\n-            ty::ty_uniq(_) => return Err(ty::terr_mismatch),\n-            ty::ty_ptr(ty::mt{ty: t, ..}) |\n-            ty::ty_rptr(_, ty::mt{ty: t, ..}) => match ty::get(t).sty {\n-                ty::ty_vec(mt, None) => mt.ty,\n-                _ => {\n-                    return self.subtype(a, b);\n-                }\n-            },\n-            ty::ty_vec(mt, _) => mt.ty,\n-            _ => {\n-                return self.subtype(a, b);\n+\n+        let sty_b = &ty::get(b).sty;\n+        match (sty_a, sty_b) {\n+            (&ty::ty_uniq(t_a), &ty::ty_rptr(_, mt_b)) => Err(ty::terr_mismatch),\n+            (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_rptr(_, mt_b)) => {\n+                self.unpack_actual_value(t_a, |sty_a| {\n+                    match self.unsize_ty(sty_a, mt_b.ty) {\n+                        Some((ty, kind)) => {\n+                            let coercion = Coercion(self.get_ref().trace.clone());\n+                            let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n+                            let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n+                                                 r_borrow,\n+                                                 ty::mt{ty: ty, mutbl: mt_b.mutbl});\n+                            if_ok!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                    AutoPtr(AutoUnsize({:?})))\", kind);\n+                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                                autoderefs: 1,\n+                                autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n+                                                          Some(box AutoUnsize(kind))))\n+                            })))\n+                        }\n+                        _ => Err(ty::terr_mismatch)\n+                    }\n+                })\n             }\n-        };\n+            (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n+                self.unpack_actual_value(t_a, |sty_a| {\n+                    match self.unsize_ty(sty_a, t_b) {\n+                        Some((ty, kind)) => {\n+                            let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n+                            if_ok!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                    AutoUnsizeUniq({:?}))\", kind);\n+                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                                autoderefs: 1,\n+                                autoref: Some(ty::AutoUnsizeUniq(kind))\n+                            })))\n+                        }\n+                        _ => Err(ty::terr_mismatch)\n+                    }\n+                })\n+            }\n+            _ => Err(ty::terr_mismatch)\n+        }\n+    }\n \n-        let a_borrowed = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n-                                      mt {ty: ty_inner, mutbl: mutbl_b});\n-        if_ok!(sub.tys(a_borrowed, b));\n-        Ok(Some(AutoDerefRef(AutoDerefRef {\n-            autoderefs: 0,\n-            autoref: Some(AutoBorrowVec(r_borrow, mutbl_b))\n-        })))\n+    // Takes a type and returns an unsized version along with the adjustment\n+    // performed to unsize it.\n+    // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n+    fn unsize_ty(&self,\n+                 sty_a: &ty::sty,\n+                 ty_b: ty::t)\n+                 -> Option<(ty::t, ty::UnsizeKind)> {\n+        debug!(\"unsize_ty(sty_a={:?}\", sty_a);\n+\n+        let tcx = self.get_ref().infcx.tcx;\n+\n+        self.unpack_actual_value(ty_b, |sty_b|\n+            match (sty_a, sty_b) {\n+                (&ty::ty_vec(t_a, Some(len)), _) => {\n+                    let ty = ty::mk_vec(tcx, t_a, None);\n+                    Some((ty, ty::UnsizeLength(len)))\n+                }\n+                (&ty::ty_trait(..), &ty::ty_trait(..)) => None,\n+                (_, &ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds })) => {\n+                    let ty = ty::mk_trait(tcx,\n+                                          def_id,\n+                                          substs.clone(),\n+                                          bounds);\n+                    Some((ty, ty::UnsizeVtable(bounds,\n+                                               def_id,\n+                                               substs.clone())))\n+                }\n+                (&ty::ty_struct(did_a, ref substs_a), &ty::ty_struct(did_b, ref substs_b))\n+                  if did_a == did_b => {\n+                    debug!(\"unsizing a struct\");\n+                    // Try unsizing each type param in turn to see if we end up with ty_b.\n+                    let ty_substs_a = substs_a.types.get_vec(subst::TypeSpace);\n+                    let ty_substs_b = substs_b.types.get_vec(subst::TypeSpace);\n+                    assert!(ty_substs_a.len() == ty_substs_b.len());\n+\n+                    let sub = Sub(self.get_ref().clone());\n+\n+                    let mut result = None;\n+                    let mut tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n+                    for (i, (tp_a, tp_b)) in tps {\n+                        if self.get_ref().infcx.try(|| sub.tys(*tp_a, *tp_b)).is_ok() {\n+                            continue;\n+                        }\n+                        match self.unpack_actual_value(*tp_a, |tp| self.unsize_ty(tp, *tp_b)) {\n+                            Some((new_tp, k)) => {\n+                                // Check that the whole types match.\n+                                let mut new_substs = substs_a.clone();\n+                                *new_substs.types.get_mut_vec(subst::TypeSpace).get_mut(i) = new_tp;\n+                                let ty = ty::mk_struct(tcx, did_a, new_substs);\n+                                if self.get_ref().infcx.try(|| sub.tys(ty, ty_b)).is_err() {\n+                                    debug!(\"Unsized type parameter '{}', but still \\\n+                                            could not match types {} and {}\",\n+                                           ppaux::ty_to_string(tcx, *tp_a),\n+                                           ppaux::ty_to_string(tcx, ty),\n+                                           ppaux::ty_to_string(tcx, ty_b));\n+                                    // We can only unsize a single type parameter, so\n+                                    // if we unsize one and it doesn't give us the\n+                                    // type we want, then we won't succeed later.\n+                                    break;\n+                                }\n+\n+                                result = Some((ty, ty::UnsizeStruct(box k, i)));\n+                                break;\n+                            }\n+                            None => {}\n+                        }\n+                    }\n+                    result\n+                }\n+                _ => None\n+            }\n+        )\n     }\n \n     fn coerce_borrowed_object(&self,\n@@ -331,7 +439,8 @@ impl<'f> Coerce<'f> {\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n         let a_borrowed = match *sty_a {\n-            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+            ty::ty_uniq(ty) => return Err(ty::terr_mismatch),\n+            ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n                 ty::ty_trait(box ty::TyTrait {\n                         def_id,\n                         ref substs,\n@@ -352,8 +461,8 @@ impl<'f> Coerce<'f> {\n \n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n-            autoderefs: 0,\n-            autoref: Some(AutoBorrowObj(r_a, b_mutbl))\n+            autoderefs: 1,\n+            autoref: Some(AutoPtr(r_a, b_mutbl, None))\n         })))\n     }\n \n@@ -438,21 +547,4 @@ impl<'f> Coerce<'f> {\n             autoref: Some(ty::AutoUnsafe(mt_b.mutbl))\n         })))\n     }\n-\n-    pub fn coerce_object(&self,\n-                         a: ty::t,\n-                         sty_a: &ty::sty,\n-                         b: ty::t,\n-                         trait_def_id: ast::DefId,\n-                         trait_substs: &subst::Substs,\n-                         trait_store: ty::TraitStore,\n-                         bounds: ty::BuiltinBounds) -> CoerceResult {\n-\n-        debug!(\"coerce_object(a={}, sty_a={:?}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n-               b.repr(self.get_ref().infcx.tcx));\n-\n-        Ok(Some(ty::AutoObject(trait_store, bounds,\n-                               trait_def_id, trait_substs.clone())))\n-    }\n }"}, {"sha": "a57dec9045522a74dba8ca4a1a73f39150855b30", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -529,10 +529,10 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n             check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_rptr(tcx, r, mt))\n       }\n \n-      (&ty::ty_vec(ref a_mt, sz_a), &ty::ty_vec(ref b_mt, sz_b)) => {\n-        this.mts(a_mt, b_mt).and_then(|mt| {\n+      (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n+        this.tys(a_t, b_t).and_then(|t| {\n             if sz_a == sz_b {\n-                Ok(ty::mk_vec(tcx, mt, sz_a))\n+                Ok(ty::mk_vec(tcx, t, sz_a))\n             } else {\n                 Err(ty::terr_sorts(expected_found(this, a, b)))\n             }"}, {"sha": "920fa23f31df3860ace504d21aac992ce981f7ce", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -1411,8 +1411,8 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             infer::AutoBorrow(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that automatically reference is valid \\\n-                     at the time of borrow\");\n+                    \"...so that reference is valid \\\n+                     at the time of implicit borrow\");\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note("}, {"sha": "a54afb1102fb99019cb832150399677c2868dd48", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -129,10 +129,23 @@ impl<'f> Combine for Sub<'f> {\n                 if_ok!(self.get_ref().var_sub_var(a_id, b_id));\n                 Ok(a)\n             }\n+            // The vec/str check here and below is so that we don't unify\n+            // T with [T], this is necessary so we reflect subtyping of references\n+            // (&T does not unify with &[T]) where that in turn is to reflect\n+            // the historical non-typedness of [T].\n+            (&ty::ty_infer(TyVar(_)), &ty::ty_str) |\n+            (&ty::ty_infer(TyVar(_)), &ty::ty_vec(_, None)) => {\n+                Err(ty::terr_sorts(expected_found(self, a, b)))\n+            }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n                 if_ok!(self.get_ref().var_sub_t(a_id, b));\n                 Ok(a)\n             }\n+\n+            (&ty::ty_str, &ty::ty_infer(TyVar(_))) |\n+            (&ty::ty_vec(_, None), &ty::ty_infer(TyVar(_))) => {\n+                Err(ty::terr_sorts(expected_found(self, a, b)))\n+            }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n                 if_ok!(self.get_ref().t_sub_var(a, b_id));\n                 Ok(a)"}, {"sha": "e6227b9c12829df69edfa10f721479fa3e13684d", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -741,11 +741,7 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n-            ty::ty_vec(ref mt, _) => {\n-                self.add_constraints_from_mt(mt, variance);\n-            }\n-\n-            ty::ty_uniq(typ) | ty::ty_box(typ) => {\n+            ty::ty_uniq(typ) | ty::ty_box(typ) | ty::ty_vec(typ, _) | ty::ty_open(typ) => {\n                 self.add_constraints_from_ty(typ, variance);\n             }\n "}, {"sha": "4f68d42de966c48ce15c30eeedf7e359480fff3c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -19,7 +19,7 @@ use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{mt, t, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup};\n+use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n use middle::ty::{ty_unboxed_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n@@ -370,6 +370,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n           buf.push_str(mt_to_string(cx, tm).as_slice());\n           buf\n       }\n+      ty_open(typ) => format!(\"opened<{}>\", ty_to_str(cx, typ)),\n       ty_tup(ref elems) => {\n         let strs: Vec<String> = elems.iter().map(|elem| ty_to_string(cx, *elem)).collect();\n         format!(\"({})\", strs.connect(\",\"))\n@@ -407,7 +408,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n           let trait_def = ty::lookup_trait_def(cx, did);\n           let ty = parameterized(cx, base.as_slice(),\n                                  substs, &trait_def.generics);\n-          let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n+          let bound_sep = if bounds.is_empty() { \"\" } else { \"+\" };\n           let bound_str = bounds.repr(cx);\n           format!(\"{}{}{}\",\n                   ty,\n@@ -416,12 +417,12 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n       }\n       ty_str => \"str\".to_string(),\n       ty_unboxed_closure(..) => \"closure\".to_string(),\n-      ty_vec(ref mt, sz) => {\n+      ty_vec(t, sz) => {\n           match sz {\n               Some(n) => {\n-                  format!(\"[{}, .. {}]\", mt_to_string(cx, mt), n)\n+                  format!(\"[{}, .. {}]\", ty_to_string(cx, t), n)\n               }\n-              None => format!(\"[{}]\", ty_to_string(cx, mt.ty)),\n+              None => format!(\"[{}]\", ty_to_string(cx, t)),\n           }\n       }\n     }"}, {"sha": "e859a5d21d7e75095a8520ac975cf2855bc67644", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -20,8 +20,8 @@ pub static fn_field_box: uint = 1u;\n \n // The two fields of a trait object/trait instance: vtable and box.\n // The vtable contains the type descriptor as first element.\n-pub static trt_field_vtable: uint = 0u;\n-pub static trt_field_box: uint = 1u;\n+pub static trt_field_box: uint = 0u;\n+pub static trt_field_vtable: uint = 1u;\n \n pub static slice_elt_base: uint = 0u;\n pub static slice_elt_len: uint = 1u;"}, {"sha": "6af19d948e0e8b467c153ae03fb825d3394ae441", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -225,7 +225,6 @@ mod svh_visitor {\n         SawExprBreak(Option<token::InternedString>),\n         SawExprAgain(Option<token::InternedString>),\n \n-        SawExprVstore,\n         SawExprBox,\n         SawExprVec,\n         SawExprCall,\n@@ -257,7 +256,6 @@ mod svh_visitor {\n \n     fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n         match *node {\n-            ExprVstore(..)           => SawExprVstore,\n             ExprBox(..)              => SawExprBox,\n             ExprVec(..)              => SawExprVec,\n             ExprCall(..)             => SawExprCall,"}, {"sha": "dc2c0d1d0830d89ce98cdc81128ab365a74d543e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -1250,8 +1250,8 @@ impl Clean<Type> for ty::t {\n                 });\n                 lang_struct(box_did, t, \"Box\", Unique)\n             }\n-            ty::ty_vec(mt, None) => Vector(box mt.ty.clean()),\n-            ty::ty_vec(mt, Some(i)) => FixedVector(box mt.ty.clean(),\n+            ty::ty_vec(ty, None) => Vector(box ty.clean()),\n+            ty::ty_vec(ty, Some(i)) => FixedVector(box ty.clean(),\n                                                    format!(\"{}\", i)),\n             ty::ty_ptr(mt) => RawPointer(mt.mutbl.clean(), box mt.ty.clean()),\n             ty::ty_rptr(r, mt) => BorrowedRef {\n@@ -1315,6 +1315,7 @@ impl Clean<Type> for ty::t {\n             ty::ty_unboxed_closure(..) => Primitive(Unit), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => fail!(\"ty_infer\"),\n+            ty::ty_open(..) => fail!(\"ty_open\"),\n             ty::ty_err => fail!(\"ty_err\"),\n         }\n     }"}, {"sha": "6415ee85f5704d5f5861f5dbf8518a71b8610c2b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -259,7 +259,8 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n-    match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n+    let default: &[_] = &[];\n+    match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(default)) {\n         Some(attrs) => {\n             for attr in attrs.iter() {\n                 match *attr {"}, {"sha": "55d9811ccadc05a65a0a770c4bb3f264521bc4d1", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -72,13 +72,15 @@ impl Clone for HomeHandle {\n }\n \n pub fn local_id() -> uint {\n+    use std::raw::TraitObject;\n+\n     let mut io = match LocalIo::borrow() {\n         Some(io) => io, None => return 0,\n     };\n     let io = io.get();\n     unsafe {\n-        let (_vtable, ptr): (uint, uint) = mem::transmute(io);\n-        return ptr;\n+        let obj: TraitObject = mem::transmute(io);\n+        return mem::transmute(obj.data);\n     }\n }\n "}, {"sha": "6e948992979d86e8c4044be8ea5e9f21c32d427b", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -462,13 +462,14 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n // This function is full of lies!\n #[cfg(test)]\n fn local_loop() -> &'static mut uvio::UvIoFactory {\n+    use std::raw::TraitObject;\n     unsafe {\n         mem::transmute({\n             let mut task = Local::borrow(None::<Task>);\n             let mut io = task.local_io().unwrap();\n-            let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n+            let obj: TraitObject =\n                 mem::transmute(io.get());\n-            uvio\n+            obj.data\n         })\n     }\n }"}, {"sha": "06eab31d7bff56cab0e62b43ffee63b8ee1af3c3", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -464,6 +464,7 @@ static dot_dot_static: &'static [u8] = b\"..\";\n mod tests {\n     use prelude::*;\n     use super::*;\n+    use mem;\n     use str;\n     use str::StrSlice;\n \n@@ -621,8 +622,10 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::new($path);\n-                    assert!(path.$op() == ($exp).as_bytes());\n+                    unsafe {\n+                        let path = Path::new($path);\n+                        assert!(path.$op() == mem::transmute(($exp).as_bytes()));\n+                    }\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n@@ -634,9 +637,11 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let arg = $path;\n-                    let path = Path::new(arg);\n-                    assert!(path.$op() == $exp);\n+                    unsafe {\n+                        let arg = $path;\n+                        let path = Path::new(arg);\n+                        assert!(path.$op() == mem::transmute($exp));\n+                    }\n                 }\n             );\n         )\n@@ -684,8 +689,9 @@ mod tests {\n         t!(v: b\"hi/there.txt\", extension, Some(b\"txt\"));\n         t!(v: b\"hi/there\\x80.txt\", extension, Some(b\"txt\"));\n         t!(v: b\"hi/there.t\\x80xt\", extension, Some(b\"t\\x80xt\"));\n-        t!(v: b\"hi/there\", extension, None);\n-        t!(v: b\"hi/there\\x80\", extension, None);\n+        let no: Option<&'static [u8]> = None;\n+        t!(v: b\"hi/there\", extension, no);\n+        t!(v: b\"hi/there\\x80\", extension, no);\n         t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n         t!(s: \"hi/there\", extension, None, opt);\n         t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n@@ -974,57 +980,62 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    let path = $path;\n-                    let filename = $filename;\n-                    assert!(path.filename_str() == filename,\n-                            \"{}.filename_str(): Expected `{:?}`, found {:?}\",\n-                            path.as_str().unwrap(), filename, path.filename_str());\n-                    let dirname = $dirname;\n-                    assert!(path.dirname_str() == dirname,\n-                            \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), dirname, path.dirname_str());\n-                    let filestem = $filestem;\n-                    assert!(path.filestem_str() == filestem,\n-                            \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), filestem, path.filestem_str());\n-                    let ext = $ext;\n-                    assert!(path.extension_str() == ext,\n-                            \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), ext, path.extension_str());\n+                    unsafe {\n+                        let path = $path;\n+                        let filename = $filename;\n+                        assert!(path.filename_str() == filename,\n+                                \"{}.filename_str(): Expected `{:?}`, found {:?}\",\n+                                path.as_str().unwrap(), filename, path.filename_str());\n+                        let dirname = $dirname;\n+                        assert!(path.dirname_str() == dirname,\n+                                \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), dirname, path.dirname_str());\n+                        let filestem = $filestem;\n+                        assert!(path.filestem_str() == filestem,\n+                                \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), filestem, path.filestem_str());\n+                        let ext = $ext;\n+                        assert!(path.extension_str() == mem::transmute(ext),\n+                                \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), ext, path.extension_str());\n+                    }\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    let path = $path;\n-                    assert!(path.filename() == $filename);\n-                    assert!(path.dirname() == $dirname);\n-                    assert!(path.filestem() == $filestem);\n-                    assert!(path.extension() == $ext);\n+                    unsafe {\n+                        let path = $path;\n+                        assert!(path.filename() == mem::transmute($filename));\n+                        assert!(path.dirname() == mem::transmute($dirname));\n+                        assert!(path.filestem() == mem::transmute($filestem));\n+                        assert!(path.extension() == mem::transmute($ext));\n+                    }\n                 }\n             )\n         )\n \n-        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n-        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n+        let no: Option<&'static str> = None;\n+        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), no);\n+        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), no);\n         t!(v: Path::new(b\"hi/there.\\xFF\"), Some(b\"there.\\xFF\"), b\"hi\",\n               Some(b\"there\"), Some(b\"\\xFF\"));\n-        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n-        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, None);\n+        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), no);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, no);\n+        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, no);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, no);\n+        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, no);\n         t!(s: Path::new(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), no);\n         t!(s: Path::new(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), no);\n         t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, no);\n         t!(s: Path::new(b\"a/b/\\xFF.txt\"), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), None);\n+        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), no);\n+        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), no);\n     }\n \n     #[test]"}, {"sha": "d9864cfaa6130a35a3e4946ae835bdc271056761", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -1141,6 +1141,7 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n \n #[cfg(test)]\n mod tests {\n+    use mem;\n     use prelude::*;\n     use super::*;\n     use super::parse_prefix;\n@@ -1383,9 +1384,11 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = $path;\n-                    let path = Path::new(path);\n-                    assert!(path.$op() == Some($exp));\n+                    unsafe {\n+                        let path = $path;\n+                        let path = Path::new(path);\n+                        assert!(path.$op() == Some(mem::transmute($exp)));\n+                    }\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n@@ -1398,9 +1401,11 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = $path;\n-                    let path = Path::new(path);\n-                    assert!(path.$op() == $exp);\n+                    unsafe {\n+                        let path = $path;\n+                        let path = Path::new(path);\n+                        assert!(path.$op() == mem::transmute($exp));\n+                    }\n                 }\n             )\n         )\n@@ -1485,7 +1490,8 @@ mod tests {\n         // filestem is based on filename, so we don't need the full set of prefix tests\n \n         t!(v: b\"hi\\\\there.txt\", extension, Some(b\"txt\"));\n-        t!(v: b\"hi\\\\there\", extension, None);\n+        let no: Option<&'static [u8]> = None;\n+        t!(v: b\"hi\\\\there\", extension, no);\n         t!(s: \"hi\\\\there.txt\", extension_str, Some(\"txt\"), opt);\n         t!(s: \"hi\\\\there\", extension_str, None, opt);\n         t!(s: \"there.txt\", extension_str, Some(\"txt\"), opt);\n@@ -1892,48 +1898,53 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    let path = $path;\n-                    let filename = $filename;\n-                    assert!(path.filename_str() == filename,\n-                            \"`{}`.filename_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), filename, path.filename_str());\n-                    let dirname = $dirname;\n-                    assert!(path.dirname_str() == dirname,\n-                            \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), dirname, path.dirname_str());\n-                    let filestem = $filestem;\n-                    assert!(path.filestem_str() == filestem,\n-                            \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), filestem, path.filestem_str());\n-                    let ext = $ext;\n-                    assert!(path.extension_str() == ext,\n-                            \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n-                            path.as_str().unwrap(), ext, path.extension_str());\n+                    unsafe {\n+                        let path = $path;\n+                        let filename = $filename;\n+                        assert!(path.filename_str() == filename,\n+                                \"`{}`.filename_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), filename, path.filename_str());\n+                        let dirname = $dirname;\n+                        assert!(path.dirname_str() == dirname,\n+                                \"`{}`.dirname_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), dirname, path.dirname_str());\n+                        let filestem = $filestem;\n+                        assert!(path.filestem_str() == filestem,\n+                                \"`{}`.filestem_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), filestem, path.filestem_str());\n+                        let ext = $ext;\n+                        assert!(path.extension_str() == mem::transmute(ext),\n+                                \"`{}`.extension_str(): Expected `{:?}`, found `{:?}`\",\n+                                path.as_str().unwrap(), ext, path.extension_str());\n+                    }\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    let path = $path;\n-                    assert!(path.filename() == $filename);\n-                    assert!(path.dirname() == $dirname);\n-                    assert!(path.filestem() == $filestem);\n-                    assert!(path.extension() == $ext);\n+                    unsafe {\n+                        let path = $path;\n+                        assert!(path.filename() == mem::transmute($filename));\n+                        assert!(path.dirname() == mem::transmute($dirname));\n+                        assert!(path.filestem() == mem::transmute($filestem));\n+                        assert!(path.extension() == mem::transmute($ext));\n+                    }\n                 }\n             )\n         )\n \n-        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n-        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n-        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n-        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n+        let no: Option<&'static str> = None;\n+        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), no);\n+        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), no);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, no);\n+        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, no);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, no);\n+        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, no);\n         t!(s: Path::new(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), no);\n         t!(s: Path::new(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), no);\n         t!(s: Path::new(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n "}, {"sha": "7d5787092a5c5df13f1b8910a82db15c8c450121", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -394,16 +394,6 @@ pub enum Mutability {\n     MutImmutable,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub enum ExprVstore {\n-    /// ~[1, 2, 3, 4]\n-    ExprVstoreUniq,\n-    /// &[1, 2, 3, 4]\n-    ExprVstoreSlice,\n-    /// &mut [1, 2, 3, 4]\n-    ExprVstoreMutSlice,\n-}\n-\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum BinOp {\n     BiAdd,\n@@ -522,7 +512,6 @@ pub struct Expr {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Expr_ {\n-    ExprVstore(Gc<Expr>, ExprVstore),\n     /// First expr is the place; second expr is the value.\n     ExprBox(Gc<Expr>, Gc<Expr>),\n     ExprVec(Vec<Gc<Expr>>),"}, {"sha": "909f8f1e78ce42e9768cff7c5aa4fe9234b42e97", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -143,12 +143,10 @@ pub trait AstBuilder {\n     fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr>;\n     fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr>;\n \n-    fn expr_vstore(&self, sp: Span, expr: Gc<ast::Expr>, vst: ast::ExprVstore) -> Gc<ast::Expr>;\n     fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n     fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr>;\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n     fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n-    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n \n     fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n     fn expr_none(&self, sp: Span) -> Gc<ast::Expr>;\n@@ -654,9 +652,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_lit(sp, ast::LitBool(value))\n     }\n \n-    fn expr_vstore(&self, sp: Span, expr: Gc<ast::Expr>, vst: ast::ExprVstore) -> Gc<ast::Expr> {\n-        self.expr(sp, ast::ExprVstore(expr, vst))\n-    }\n     fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprVec(exprs))\n     }\n@@ -669,15 +664,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               Vec::new())\n     }\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n-        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n+        self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n     fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n-    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n-        self.expr_vstore(sp, self.expr_str(sp, s), ast::ExprVstoreUniq)\n-    }\n-\n \n     fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>, ty: P<ast::Ty>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprCast(expr, ty))"}, {"sha": "4a0787aeb9efab7a472c765749caa75be8a46c90", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -1088,9 +1088,6 @@ pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n     let id = folder.new_id(e.id);\n     let node = match e.node {\n-        ExprVstore(e, v) => {\n-            ExprVstore(folder.fold_expr(e), v)\n-        }\n         ExprBox(p, e) => {\n             ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n         }"}, {"sha": "585b98925cc58f963aa804775e736347f215ab20", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -1137,7 +1137,8 @@ mod test {\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n         let docs = item.attrs.iter().filter(|a| a.name().get() == \"doc\")\n                     .map(|a| a.value_str().unwrap().get().to_string()).collect::<Vec<_>>();\n-        assert_eq!(docs.as_slice(), &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()]);\n+        let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n+        assert_eq!(docs.as_slice(), b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();"}, {"sha": "00513f7f67c3165be57a280c3018fa4723db9b5a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 53, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -27,9 +27,8 @@ use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n-use ast::{ExprVec, ExprVstore, ExprVstoreSlice};\n-use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, Field, FnDecl};\n-use ast::{ExprVstoreUniq, Once, Many};\n+use ast::{ExprVec, ExprWhile, ExprForLoop, Field, FnDecl};\n+use ast::{Once, Many};\n use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n@@ -1428,13 +1427,16 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n-            let last_span = self.last_span;\n+            let span = self.last_span;\n             match self.token {\n-                token::LBRACKET =>\n-                    self.obsolete(last_span, ObsoleteOwnedVector),\n-                _ => self.obsolete(last_span, ObsoleteOwnedType),\n-            };\n-            TyUniq(self.parse_ty(true))\n+                token::IDENT(ref ident, _)\n+                        if \"str\" == token::get_ident(*ident).get() => {\n+                    // This is OK (for now).\n+                }\n+                token::LBRACKET => {}   // Also OK.\n+                _ => self.obsolete(span, ObsoleteOwnedType)\n+            }\n+            TyUniq(self.parse_ty(false))\n         } else if self.token == token::BINOP(token::STAR) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n@@ -2549,16 +2551,7 @@ impl<'a> Parser<'a> {\n             let m = self.parse_mutability();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn &[...] into a &-vec\n-            ex = match e.node {\n-              ExprVec(..) if m == MutImmutable => {\n-                ExprVstore(e, ExprVstoreSlice)\n-              }\n-              ExprVec(..) if m == MutMutable => {\n-                ExprVstore(e, ExprVstoreMutSlice)\n-              }\n-              _ => ExprAddrOf(m, e)\n-            };\n+            ex = ExprAddrOf(m, e);\n           }\n           token::AT => {\n             self.bump();\n@@ -2570,25 +2563,18 @@ impl<'a> Parser<'a> {\n           }\n           token::TILDE => {\n             self.bump();\n+            let span = self.last_span;\n+            match self.token {\n+                token::LIT_STR(_) => {\n+                    // This is OK (for now).\n+                }\n+                token::LBRACKET => {}   // Also OK.\n+                _ => self.obsolete(span, ObsoleteOwnedExpr)\n+            }\n \n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn ~[...] into a ~-vec\n-            let last_span = self.last_span;\n-            ex = match e.node {\n-              ExprVec(..) | ExprRepeat(..) => {\n-                  self.obsolete(last_span, ObsoleteOwnedVector);\n-                  ExprVstore(e, ExprVstoreUniq)\n-              }\n-              ExprLit(lit) if lit_is_str(lit) => {\n-                  self.obsolete(last_span, ObsoleteOwnedExpr);\n-                  ExprVstore(e, ExprVstoreUniq)\n-              }\n-              _ => {\n-                  self.obsolete(last_span, ObsoleteOwnedExpr);\n-                  self.mk_unary(UnUniq, e)\n-              }\n-            };\n+            ex = self.mk_unary(UnUniq, e);\n           }\n           token::IDENT(_, _) => {\n               if self.is_keyword(keywords::Box) {\n@@ -2607,24 +2593,10 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n \n-                // Otherwise, we use the unique pointer default.\n-                let subexpression = self.parse_prefix_expr();\n-                hi = subexpression.span.hi;\n-                // HACK: turn `box [...]` into a boxed-vec\n-                ex = match subexpression.node {\n-                    ExprVec(..) | ExprRepeat(..) => {\n-                        let last_span = self.last_span;\n-                        self.obsolete(last_span, ObsoleteOwnedVector);\n-                        ExprVstore(subexpression, ExprVstoreUniq)\n-                    }\n-                    ExprLit(lit) if lit_is_str(lit) => {\n-                        ExprVstore(subexpression, ExprVstoreUniq)\n-                    }\n-                    _ => self.mk_unary(UnUniq, subexpression)\n-                };\n-              } else {\n-                return self.parse_dot_or_call_expr()\n-              }\n+            // Otherwise, we use the unique pointer default.\n+            let subexpression = self.parse_prefix_expr();\n+            hi = subexpression.span.hi;\n+            ex = self.mk_unary(UnUniq, subexpression);\n           }\n           _ => return self.parse_dot_or_call_expr()\n         }"}, {"sha": "d5b6c5652a0ccf9a9eb95775ceb1a23d23d6a795", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -159,14 +159,16 @@ impl<'a> State<'a> {\n }\n \n pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n+    use std::raw::TraitObject;\n     let mut s = rust_printer(box MemWriter::new());\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n     unsafe {\n         // FIXME(pcwalton): A nasty function to extract the string from an `io::Writer`\n         // that we \"know\" to be a `MemWriter` that works around the lack of checked\n         // downcasts.\n-        let (_, wr): (uint, Box<MemWriter>) = mem::transmute_copy(&s.s.out);\n+        let obj: TraitObject = mem::transmute_copy(&s.s.out);\n+        let wr: Box<MemWriter> = mem::transmute(obj.data);\n         let result =\n             String::from_utf8(Vec::from_slice(wr.get_ref().as_slice())).unwrap();\n         mem::forget(wr);\n@@ -1321,16 +1323,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_expr_vstore(&mut self, t: ast::ExprVstore) -> IoResult<()> {\n-        match t {\n-            ast::ExprVstoreUniq => word(&mut self.s, \"box \"),\n-            ast::ExprVstoreSlice => word(&mut self.s, \"&\"),\n-            ast::ExprVstoreMutSlice => {\n-                try!(word(&mut self.s, \"&\"));\n-                word(&mut self.s, \"mut\")\n-            }\n-        }\n-    }\n \n     fn print_call_post(&mut self, args: &[Gc<ast::Expr>]) -> IoResult<()> {\n         try!(self.popen());\n@@ -1355,10 +1347,6 @@ impl<'a> State<'a> {\n         try!(self.ibox(indent_unit));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprVstore(ref e, v) => {\n-                try!(self.print_expr_vstore(v));\n-                try!(self.print_expr(&**e));\n-            },\n             ast::ExprBox(ref p, ref e) => {\n                 try!(word(&mut self.s, \"box\"));\n                 try!(word(&mut self.s, \"(\"));"}, {"sha": "517c5e5bf47da3ca809503387efdc79740bc8090", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -64,7 +64,10 @@ impl<T> SmallVector<T> {\n \n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n         match self.repr {\n-            Zero => &[],\n+            Zero => {\n+                let result: &[T] = &[];\n+                result\n+            }\n             One(ref v) => slice::ref_slice(v),\n             Many(ref vs) => vs.as_slice()\n         }"}, {"sha": "6c6f59f0df6391de5e4aff636685253dafa0d39f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -729,9 +729,6 @@ pub fn walk_mac<E, V: Visitor<E>>(_: &mut V, _: &Mac, _: E) {\n \n pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, env: E) {\n     match expression.node {\n-        ExprVstore(ref subexpression, _) => {\n-            visitor.visit_expr(&**subexpression, env.clone())\n-        }\n         ExprBox(ref place, ref subexpression) => {\n             visitor.visit_expr(&**place, env.clone());\n             visitor.visit_expr(&**subexpression, env.clone())"}, {"sha": "4f53694ebd622b6e074ced8b10c58d185db3071b", "filename": "src/test/compile-fail/const-cast-different-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n static a: &'static str = \"foo\";\n-static b: *const u8 = a as *const u8; //~ ERROR non-scalar cast\n-static c: *const u8 = &a as *const u8; //~ ERROR mismatched types\n+static b: *const u8 = a as *const u8; //~ ERROR mismatched types: expected `*u8` but found `&'static str`\n+static c: *const u8 = &a as *const u8; //~ ERROR mismatched types: expected `*u8` but found `&&'static str`\n \n fn main() {\n }"}, {"sha": "282cf57df26c0d6cb5f2a06a64d9ca8efff7570f", "filename": "src/test/compile-fail/dst-bad-assign-2.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Forbid assignment into a dynamically sized type.\n+\n+struct Fat<type T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar1 {\n+    f: int\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> int;\n+}\n+\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> int {\n+        self.f\n+    }\n+}\n+\n+pub fn main() {\n+    // Assignment.\n+    let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    let z: Box<ToBar> = box Bar1 {f: 36};\n+    f5.ptr = *z;  //~ ERROR dynamically sized type on lhs of assignment\n+}"}, {"sha": "e069eb01ae18456445a11422d380835ffe9f007b", "filename": "src/test/compile-fail/dst-bad-assign.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Forbid assignment into a dynamically sized type.\n+\n+struct Fat<type T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar1 {\n+    f: int\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> int;\n+}\n+\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> int {\n+        self.f\n+    }\n+}\n+\n+pub fn main() {\n+    // Assignment.\n+    let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    let z: Box<ToBar> = box Bar1 {f: 36};\n+    f5.ptr = Bar1 {f: 36}; //~ ERROR mismatched types: expected `ToBar` but found `Bar1`\n+}"}, {"sha": "a7dc4e123aff8a27d7e100c1e8ad2a247737484d", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Attempt to change the type as well as unsizing.\n+\n+struct Fat<type T> {\n+    ptr: T\n+}\n+\n+struct Foo;\n+trait Bar {}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    let f2: &Fat<[int, ..3]> = &f1;\n+    let f3: &Fat<[uint]> = f2;\n+    //~^ ERROR mismatched types: expected `&Fat<[uint]>` but found `&Fat<[int, .. 3]>`\n+\n+    // With a trait.\n+    let f1 = Fat { ptr: Foo };\n+    let f2: &Fat<Foo> = &f1;\n+    let f3: &Fat<Bar> = f2;\n+    //~^ ERROR failed to find an implementation of trait Bar for Foo\n+}"}, {"sha": "d4ce59b726162b5782473903a677301e8304ecc5", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Attempt to change the mutability as well as unsizing.\n+\n+struct Fat<type T> {\n+    ptr: T\n+}\n+\n+struct Foo;\n+trait Bar {}\n+impl Bar for Foo {}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    let f2: &Fat<[int, ..3]> = &f1;\n+    let f3: &mut Fat<[int]> = f2; //~ ERROR cannot borrow immutable dereference\n+\n+    // With a trait.\n+    let f1 = Fat { ptr: Foo };\n+    let f2: &Fat<Foo> = &f1;\n+    let f3: &mut Fat<Bar> = f2; //~ ERROR cannot borrow immutable dereference\n+}"}, {"sha": "bd7c46060a5124ce6f4cff31e037bf6b467787b1", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Attempt to extend the lifetime as well as unsizing.\n+\n+struct Fat<type T> {\n+    ptr: T\n+}\n+\n+struct Foo;\n+trait Bar {}\n+impl Bar for Foo {}\n+\n+fn baz<'a>() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    let f2: &Fat<[int, ..3]> = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a Fat<[int]> = f2;\n+\n+    // With a trait.\n+    let f1 = Fat { ptr: Foo };\n+    let f2: &Fat<Foo> = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a Fat<Bar> = f2;\n+}\n+\n+pub fn main() {\n+    baz();\n+}"}, {"sha": "0916fa08a3924c877abe2b01ad35cd9be033fd74", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Attempt to coerce from unsized to sized.\n+\n+struct Fat<type T> {\n+    ptr: T\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1: &Fat<[int]> = &Fat { ptr: [1, 2, 3] };\n+    let f2: &Fat<[int, ..3]> = f1;\n+    //~^ ERROR  mismatched types: expected `&Fat<[int, .. 3]>` but found `&Fat<[int]>`\n+}"}, {"sha": "b18e7dad4ac558f719ad8f7c136e4ad960fb0b23", "filename": "src/test/compile-fail/dst-bad-deep.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Try to initialise a DST struct where the lost information is deeply nested.\n+// This is an error because it requires an unsized rvalue. This is a problem\n+// because it would require stack allocation of an unsized temporary (*g in the\n+// test).\n+\n+struct Fat<type T> {\n+    ptr: T\n+}\n+\n+pub fn main() {\n+    let f: Fat<[int, ..3]> = Fat { ptr: [5i, 6, 7] };\n+    let g: &Fat<[int]> = &f;\n+    let h: &Fat<Fat<[int]>> = &Fat { ptr: *g };\n+    //~^ ERROR trying to initialise a dynamically sized struct\n+}"}, {"sha": "8ae20dfde9123e68e869ee3a6e53a176de7b5032", "filename": "src/test/compile-fail/issue-10291.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn test<'x>(x: &'x int) { //~ NOTE the lifetime 'x as defined\n+fn test<'x>(x: &'x int) {\n     drop::< <'z>|&'z int| -> &'z int>(|z| {\n-        //~^ ERROR mismatched types\n-        //~^^ ERROR cannot infer an appropriate lifetime\n         x\n+        //~^ ERROR cannot infer an appropriate lifetime\n     });\n }\n "}, {"sha": "162324b7c59b25e1b2473c343f64803e7c910dca", "filename": "src/test/compile-fail/issue-13446.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -11,7 +11,9 @@\n \n // Used to cause ICE\n \n-static VEC: [u32, ..256] = vec!(); //~ ERROR mismatched types\n+// error-pattern: mismatched types\n+\n+static VEC: [u32, ..256] = vec!();\n \n fn main() {}\n "}, {"sha": "5063a78e38348d6eb0e4e8fcbdaf4ebfe70f7e30", "filename": "src/test/compile-fail/issue-4523.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -10,8 +10,8 @@\n \n fn foopy() {}\n \n-static f: ||: 'static = foopy; //~ ERROR found extern fn\n+static f: ||: 'static = foopy;\n \n fn main () {\n-    f();\n+    f(); //~ ERROR closure invocation in a static location\n }"}, {"sha": "f7199a92d27cc42c7772f63527a798541b231c41", "filename": "src/test/compile-fail/issue-4972.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -17,7 +17,7 @@ pub enum TraitWrapper {\n \n fn get_tw_map(tw: &TraitWrapper) -> &MyTrait {\n     match *tw {\n-        A(box ref map) => map, //~ ERROR cannot be dereferenced\n+        A(box ref map) => map, //~ ERROR mismatched types: expected `Box<MyTrait>` but found a box\n     }\n }\n "}, {"sha": "3703d4f39acef8424fddbebff4d13ccc8ee7be8d", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -11,15 +11,14 @@\n trait A {}\n \n struct Struct {\n-    r: A //~ ERROR reference to trait `A` where a type is expected; try `Box<A>` or `&A`\n+    r: A\n }\n \n fn new_struct(r: A) -> Struct {\n-    //~^ ERROR reference to trait `A` where a type is expected; try `Box<A>` or `&A`\n+    //~^ ERROR variable `r` has dynamically sized type `A`\n     Struct { r: r }\n }\n \n trait Curve {}\n enum E {X(Curve)}\n-//~^ ERROR reference to trait `Curve` where a type is expected; try `Box<Curve>` or `&Curve`\n fn main() {}"}, {"sha": "efd8e75d3d6d3e70b8dd6cf7d0521c477791b954", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -32,7 +32,7 @@ struct A {\n \n fn main() {\n     let a = A {v: box B{v: None} as Box<Foo+Send>};\n-    //~^ ERROR cannot pack type `Box<B>`, which does not fulfill `Send`\n+    //~^ ERROR cannot pack type `Box<B>` as a trait bounded by Send because the type does not fulfil\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();\n     let b = &*v;"}, {"sha": "481fb3dee73a83630671978f74cf740339fdf98b", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -36,14 +36,14 @@ fn foo4<'a, 'b>(x: &'a Foo) -> (&'b int, &'a int, &'b int) {\n struct Bar<'x, 'y, 'z> { bar: &'y int, baz: int }\n fn bar1<'a>(x: &Bar) -> (&'a int, &'a int, &'a int) {\n //~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a int, &'a int, &'a int)\n-    (x.bar, &x.baz, &x.baz) //~ ERROR: mismatched types\n+    (x.bar, &x.baz, &x.baz) //~ ERROR: cannot infer\n     //~^ ERROR: cannot infer\n     //~^^ ERROR: cannot infer\n }\n \n fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&'a int, &'a int, &'a int) {\n //~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a int, &'a int, &'a int)\n-    (x.bar, &x.baz, &x.baz) //~ ERROR: mismatched types\n+    (x.bar, &x.baz, &x.baz) //~ ERROR: cannot infer\n     //~^ ERROR: cannot infer\n     //~^^ ERROR: cannot infer\n }\n@@ -53,21 +53,19 @@ struct Dog<'y> { dog: &'y int }\n \n fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &'x int {\n //~^ NOTE: consider using an explicit lifetime parameter as shown: fn cat2<'x>(x: Cat<'x, Dog<'x>>) -> &'x int\n-    x.t.dog //~ ERROR: mismatched types\n+    x.t.dog //~ ERROR: cannot infer\n }\n \n struct Baz<'x> {\n     bar: &'x int\n }\n \n-\n impl<'a> Baz<'a> {\n     fn baz2<'b>(&self, x: &int) -> (&'b int, &'b int) {\n         // The lifetime that gets assigned to `x` seems somewhat random.\n         // I have disabled this test for the time being. --pcwalton\n         (self.bar, x) //~ ERROR: cannot infer\n-        //~^ ERROR: mismatched types\n-        //~^^ ERROR: mismatched types\n+        //~^ ERROR: cannot infer\n     }\n }\n "}, {"sha": "5440219e55eb969b09d1a21d3074774b9550d998", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -31,18 +31,18 @@ pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n }\n \n pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    if maybestr.is_none() { //~ ERROR mismatched types\n+    if maybestr.is_none() {\n         \"(none)\"\n     } else {\n         let s: &'a str = maybestr.get_ref().as_slice();\n-        s\n+        s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n     }\n }\n \n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    if maybestr.is_some() {  //~ ERROR mismatched types\n+    if maybestr.is_some() {\n         let s: &'a str = maybestr.get_ref().as_slice();\n-        s\n+        s  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to conflicting\n     } else {\n         \"(none)\"\n     }"}, {"sha": "febe5f45d96b07bcee63a2c52f5b193e245d0f9e", "filename": "src/test/compile-fail/lub-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -33,7 +33,7 @@ pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n }\n \n pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    match *maybestr { //~ ERROR mismatched types\n+    match *maybestr {  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n         None => \"(none)\",\n         Some(ref s) => {\n             let s: &'a str = s.as_slice();\n@@ -43,7 +43,7 @@ pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n }\n \n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    match *maybestr { //~ ERROR mismatched types\n+    match *maybestr {  //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n         Some(ref s) => {\n             let s: &'a str = s.as_slice();\n             s"}, {"sha": "0cb88b924f85c204d660790c8fdf86db0aad0843", "filename": "src/test/compile-fail/regions-early-bound-error-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -27,7 +27,7 @@ impl<'a> GetRef<'a> for Box<'a> {\n \n impl<'a> Box<'a> {\n     fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a int {\n-        g2.get() //~ ERROR lifetime mismatch\n+        g2.get() //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n     }\n }\n "}, {"sha": "25016c104adc8f58f0e096f3b019c9410193fdac", "filename": "src/test/compile-fail/regions-early-bound-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -26,7 +26,7 @@ impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n }\n \n fn get<'a,'b,G:GetRef<'a, int>>(g1: G, b: &'b int) -> &'b int {\n-    g1.get() //~ ERROR lifetime mismatch\n+    g1.get() //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n }\n \n fn main() {"}, {"sha": "0eb47da16b600cbe3d869725aa8c82e51bf4e05f", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -22,9 +22,9 @@ mod argparse {\n \n     impl<'a> Flag<'a> {\n         pub fn set_desc(self, s: &str) -> Flag<'a> {\n-            Flag { //~ ERROR cannot infer\n+            Flag {\n                 name: self.name,\n-                desc: s,\n+                desc: s, //~ ERROR cannot infer an appropriate lifetime for automatic coercion due t\n                 max_count: self.max_count,\n                 value: self.value\n             }"}, {"sha": "7dc57d37e2496461c25c19757d28f275219f8957", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -21,8 +21,7 @@ fn nested<'x>(x: &'x int) {\n     });\n \n     ignore::< <'z>|&'z int| -> &'z int>(|z| {\n-        if false { return x; }  //~ ERROR mismatched types\n-        //~^ ERROR cannot infer\n+        if false { return x; }  //~ ERROR cannot infer an appropriate lifetime for automatic\n         if false { return ay; }\n         return z;\n     });"}, {"sha": "df46b2aaac0134b6f56c4af5a42e23e3ff14e81b", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -17,7 +17,7 @@ fn with<R>(f: <'a>|x: &'a int| -> R) -> R {\n }\n \n fn return_it<'a>() -> &'a int {\n-    with(|o| o) //~ ERROR mismatched types\n+    with(|o| o)\n         //~^ ERROR lifetime of return value does not outlive the function call\n         //~^^ ERROR cannot infer\n }"}, {"sha": "507a48fb741704ee9127610fb088aef9a201b5bb", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -20,7 +20,7 @@ fn with<R>(f: |x: &int| -> R) -> R {\n }\n \n fn return_it<'a>() -> &'a int {\n-    with(|o| o) //~ ERROR mismatched types\n+    with(|o| o)\n         //~^ ERROR lifetime of return value does not outlive the function call\n         //~^^ ERROR cannot infer\n }"}, {"sha": "3c5423c44d089df13a60efedb3260b7042bd4998", "filename": "src/test/compile-fail/regions-return-stack-allocated-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-return-stack-allocated-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Fregions-return-stack-allocated-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-return-stack-allocated-vec.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -11,7 +11,7 @@\n // Test that we cannot return a stack allocated slice\n \n fn function(x: int) -> &'static [int] {\n-    &[x] //~ ERROR mismatched types\n+    &[x] //~ ERROR borrowed value does not live long enough\n }\n \n fn main() {"}, {"sha": "78b4ab817bfacd3dc2cf81ec3ea54820173a0a04", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -14,7 +14,7 @@ trait Foo {\n // This should emit the less confusing error, not the more confusing one.\n \n fn foo(_x: Foo + Send) {\n-    //~^ERROR reference to trait `Foo` where a type is expected; try `Box<Foo>` or `&Foo`\n+    //~^ERROR variable `_x` has dynamically sized type `Foo+Send`\n }\n \n fn main() { }"}, {"sha": "978cca56b56048d598fcccd404fcc6f3c27a9f37", "filename": "src/test/run-make/graphviz-flowgraph/f15.dot-expected.dot", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -6,37 +6,37 @@ digraph block {\n     N4[label=\"expr 151i\"];\n     N5[label=\"local mut y\"];\n     N6[label=\"(dummy_node)\"];\n-    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l                if y >= 2i { break ; \\\"unreachable\\\" }\\l                y -= 3i;\\l            }\\l        y -= 4i;\\l        x -= 5i;\\l    }\\l\"];\n+    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2i { break ; \\\"unreachable\\\"; }\\l                y -= 3i;\\l            }\\l        y -= 4i;\\l        x -= 5i;\\l    }\\l\"];\n     N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l        if y >= 2i { break ; \\\"unreachable\\\" }\\l        y -= 3i;\\l    }\\l\"];\n+    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l\"];\n     N10[label=\"expr x\"];\n     N11[label=\"expr 1i\"];\n     N12[label=\"expr x == 1i\"];\n     N13[label=\"expr break \\'outer\"];\n     N14[label=\"(dummy_node)\"];\n     N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { break \\'outer ; \\\"unreachable\\\" }\"];\n-    N17[label=\"expr if x == 1i { break \\'outer ; \\\"unreachable\\\" }\"];\n+    N16[label=\"block { break \\'outer ; \\\"unreachable\\\"; }\"];\n+    N17[label=\"expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\"];\n     N18[label=\"expr y\"];\n     N19[label=\"expr 2i\"];\n     N20[label=\"expr y >= 2i\"];\n     N21[label=\"expr break\"];\n     N22[label=\"(dummy_node)\"];\n     N23[label=\"expr \\\"unreachable\\\"\"];\n-    N24[label=\"block { break ; \\\"unreachable\\\" }\"];\n-    N25[label=\"expr if y >= 2i { break ; \\\"unreachable\\\" }\"];\n+    N24[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N25[label=\"expr if y >= 2i { break ; \\\"unreachable\\\"; }\"];\n     N26[label=\"expr 3i\"];\n     N27[label=\"expr y\"];\n     N28[label=\"expr y -= 3i\"];\n-    N29[label=\"block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l    if y >= 2i { break ; \\\"unreachable\\\" }\\l    y -= 3i;\\l}\\l\"];\n+    N29[label=\"block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l\"];\n     N30[label=\"expr 4i\"];\n     N31[label=\"expr y\"];\n     N32[label=\"expr y -= 4i\"];\n     N33[label=\"expr 5i\"];\n     N34[label=\"expr x\"];\n     N35[label=\"expr x -= 5i\"];\n-    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l            if y >= 2i { break ; \\\"unreachable\\\" }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n-    N37[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l                    if y >= 2i { break ; \\\"unreachable\\\" }\\l                    y -= 3i;\\l                }\\l            y -= 4i;\\l            x -= 5i;\\l        }\\l}\\l\"];\n+    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { break ; \\\"unreachable\\\"; }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n+    N37[label=\"block {\\l    let mut x = 15i;\\l    let mut y = 151i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 2i { break ; \\\"unreachable\\\"; }\\l                    y -= 3i;\\l                }\\l            y -= 4i;\\l            x -= 5i;\\l        }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -47,7 +47,7 @@ digraph block {\n     N10 -> N11;\n     N11 -> N12;\n     N12 -> N13;\n-    N13 -> N7[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\" },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\" },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\" },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l    if y >= 2i { break ; \\\"unreachable\\\" }\\l    y -= 3i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l        if y >= 2i { break ; \\\"unreachable\\\" }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l        if y >= 2i { break ; \\\"unreachable\\\" }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l            if y >= 2i { break ; \\\"unreachable\\\" }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n+    N13 -> N7[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { break ; \\\"unreachable\\\"; }\\l        y -= 3;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { break ; \\\"unreachable\\\"; }\\l        y -= 3;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { break ; \\\"unreachable\\\"; }\\l            y -= 3;\\l        }\\l    y -= 4;\\l    x -= 5;\\l}\\l\"];\n     N14 -> N15;\n     N15 -> N16;\n     N12 -> N17;\n@@ -56,7 +56,7 @@ digraph block {\n     N18 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n-    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\" },\\lexiting scope_3 expr if y >= 2i { break ; \\\"unreachable\\\" },\\lexiting scope_4 stmt if y >= 2i { break ; \\\"unreachable\\\" },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\" }\\l    if y >= 2i { break ; \\\"unreachable\\\" }\\l    y -= 3i;\\l}\\l\"];\n+    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 2i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l\"];\n     N22 -> N23;\n     N23 -> N24;\n     N20 -> N25;"}, {"sha": "62233dcb7d8a18cfba44f8971606ace62202ea41", "filename": "src/test/run-make/graphviz-flowgraph/f15.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -16,11 +16,11 @@ pub fn expr_break_label_15() {\n         'inner: loop {\n             if x == 1i {\n                 break 'outer;\n-                \"unreachable\"\n+                \"unreachable\";\n             }\n             if y >= 2i {\n                 break;\n-                \"unreachable\"\n+                \"unreachable\";\n             }\n             y -= 3i;\n         }"}, {"sha": "963c4b43531959a283e0a01f12818af65d9c4d8d", "filename": "src/test/run-make/graphviz-flowgraph/f16.dot-expected.dot", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -6,38 +6,38 @@ digraph block {\n     N4[label=\"expr 16i\"];\n     N5[label=\"local mut y\"];\n     N6[label=\"(dummy_node)\"];\n-    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l                if y >= 1i { break ; \\\"unreachable\\\" }\\l                y -= 1i;\\l            }\\l        y -= 1i;\\l        x -= 1i;\\l    }\\l\"];\n+    N7[label=\"expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 1i { break ; \\\"unreachable\\\"; }\\l                y -= 1i;\\l            }\\l        y -= 1i;\\l        x -= 1i;\\l    }\\l\"];\n     N8[label=\"(dummy_node)\"];\n-    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l        if y >= 1i { break ; \\\"unreachable\\\" }\\l        y -= 1i;\\l    }\\l\"];\n+    N9[label=\"expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l\"];\n     N10[label=\"expr x\"];\n     N11[label=\"expr 1i\"];\n     N12[label=\"expr x == 1i\"];\n     N13[label=\"expr continue \\'outer\"];\n     N14[label=\"(dummy_node)\"];\n     N15[label=\"expr \\\"unreachable\\\"\"];\n-    N16[label=\"block { continue \\'outer ; \\\"unreachable\\\" }\"];\n-    N17[label=\"expr if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\"];\n+    N16[label=\"block { continue \\'outer ; \\\"unreachable\\\"; }\"];\n+    N17[label=\"expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\"];\n     N18[label=\"expr y\"];\n     N19[label=\"expr 1i\"];\n     N20[label=\"expr y >= 1i\"];\n     N21[label=\"expr break\"];\n     N22[label=\"(dummy_node)\"];\n     N23[label=\"expr \\\"unreachable\\\"\"];\n-    N24[label=\"block { break ; \\\"unreachable\\\" }\"];\n-    N25[label=\"expr if y >= 1i { break ; \\\"unreachable\\\" }\"];\n+    N24[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N25[label=\"expr if y >= 1i { break ; \\\"unreachable\\\"; }\"];\n     N26[label=\"expr 1i\"];\n     N27[label=\"expr y\"];\n     N28[label=\"expr y -= 1i\"];\n-    N29[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l    if y >= 1i { break ; \\\"unreachable\\\" }\\l    y -= 1i;\\l}\\l\"];\n-    N30[label=\"expr 1i\"];\n+    N29[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n+    N30[label=\"expr 1\"];\n     N31[label=\"expr y\"];\n     N32[label=\"expr y -= 1i\"];\n     N33[label=\"expr 1i\"];\n     N34[label=\"expr x\"];\n     N35[label=\"expr x -= 1i\"];\n-    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l            if y >= 1i { break ; \\\"unreachable\\\" }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n+    N36[label=\"block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n     N37[label=\"expr \\\"unreachable\\\"\"];\n-    N38[label=\"block {\\l    let mut x = 16i;\\l    let mut y = 16i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l                    if y >= 1i { break ; \\\"unreachable\\\" }\\l                    y -= 1i;\\l                }\\l            y -= 1i;\\l            x -= 1i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N38[label=\"block {\\l    let mut x = 16i;\\l    let mut y = 16i;\\l    \\'outer:\\l        loop  {\\l            \\'inner:\\l                loop  {\\l                    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l                    if y >= 1i { break ; \\\"unreachable\\\"; }\\l                    y -= 1i;\\l                }\\l            y -= 1i;\\l            x -= 1i;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -48,7 +48,7 @@ digraph block {\n     N10 -> N11;\n     N11 -> N12;\n     N12 -> N13;\n-    N13 -> N6[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\" },\\lexiting scope_3 expr if x == 1i { continue \\'outer ; \\\"unreachable\\\" },\\lexiting scope_4 stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\" },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l    if y >= 1i { break ; \\\"unreachable\\\" }\\l    y -= 1i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l        if y >= 1i { break ; \\\"unreachable\\\" }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l        if y >= 1i { break ; \\\"unreachable\\\" }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l            if y >= 1i { break ; \\\"unreachable\\\" }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n+    N13 -> N6[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1i { break ; \\\"unreachable\\\"; }\\l        y -= 1i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1i { break ; \\\"unreachable\\\"; }\\l            y -= 1i;\\l        }\\l    y -= 1i;\\l    x -= 1i;\\l}\\l\"];\n     N14 -> N15;\n     N15 -> N16;\n     N12 -> N17;\n@@ -57,7 +57,7 @@ digraph block {\n     N18 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n-    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\" },\\lexiting scope_3 expr if y >= 1i { break ; \\\"unreachable\\\" },\\lexiting scope_4 stmt if y >= 1i { break ; \\\"unreachable\\\" },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\" }\\l    if y >= 1i { break ; \\\"unreachable\\\" }\\l    y -= 1i;\\l}\\l\"];\n+    N21 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 1i { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 1i { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n     N22 -> N23;\n     N23 -> N24;\n     N20 -> N25;"}, {"sha": "2683d8bd06b9792479b247ce03ff2597399c1638", "filename": "src/test/run-make/graphviz-flowgraph/f16.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -16,11 +16,11 @@ pub fn expr_continue_label_16() {\n         'inner: loop {\n             if x == 1i {\n                 continue 'outer;\n-                \"unreachable\"\n+                \"unreachable\";\n             }\n             if y >= 1i {\n                 break;\n-                \"unreachable\"\n+                \"unreachable\";\n             }\n             y -= 1i;\n         }"}, {"sha": "17957dbcc1389504de451c9b01dc526b22c21c11", "filename": "src/test/run-pass/check-static-slice.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the various ways of getting to a reference to a vec (both sized\n+// and unsized) work properly.\n+\n+static aa: [int, ..3] = [1, 2, 3];\n+static ab: &'static [int, ..3] = &aa;\n+static ac: &'static [int] = ab;\n+static ad: &'static [int] = &aa;\n+static ae: &'static [int, ..3] = &[1, 2, 3];\n+static af: &'static [int] = &[1, 2, 3];\n+\n+static ca: int = aa[0];\n+static cb: int = ab[1];\n+static cc: int = ac[2];\n+static cd: int = ad[0];\n+static ce: int = ae[1];\n+static cf: int = af[2];\n+\n+fn main () {\n+    let b: &[int] = &[1, 2, 3];\n+    assert!(ac == b);\n+    assert!(ad == b);\n+    assert!(af == b);\n+\n+    assert!(ca == 1);\n+    assert!(cb == 2);\n+    assert!(cc == 3);\n+    assert!(cd == 1);\n+    assert!(ce == 2);\n+    assert!(cf == 3);\n+}"}, {"sha": "5be21696bd1edcd730d7955c07a60e78b3f389bd", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -12,6 +12,9 @@ enum E { V1(int), V0 }\n static C: &'static [E] = &[V0, V1(0xDEADBEE)];\n static C0: E = C[0];\n static C1: E = C[1];\n+static D: &'static [E, ..2] = &[V0, V1(0xDEADBEE)];\n+static D0: E = C[0];\n+static D1: E = C[1];\n \n pub fn main() {\n     match C0 {\n@@ -22,4 +25,13 @@ pub fn main() {\n         V1(n) => assert!(n == 0xDEADBEE),\n         _ => fail!()\n     }\n+\n+    match D0 {\n+        V0 => (),\n+        _ => fail!()\n+    }\n+    match D1 {\n+        V1(n) => assert!(n == 0xDEADBEE),\n+        _ => fail!()\n+    }\n }"}, {"sha": "297880a8b53de18ef64769a1e9aa5c6a3a345d22", "filename": "src/test/run-pass/dst-struct-reflect.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that structs with unsized fields work with {:?} reflection.\n+\n+extern crate debug;\n+\n+struct Fat<type T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn reflect(x: &Fat<[int]>, cmp: &str) {\n+    // Don't test this result because reflecting unsized fields is undefined for now.\n+    let _s = format!(\"{:?}\", x);\n+    let s = format!(\"{:?}\", &x.ptr);\n+    assert!(s == cmp.to_string())\n+\n+    println!(\"{:?}\", x);\n+    println!(\"{:?}\", &x.ptr);\n+}\n+\n+fn reflect_0(x: &Fat<[int]>) {\n+    let _s = format!(\"{:?}\", x.ptr[0]);\n+    println!(\"{:?}\", x.ptr[0]);\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    reflect(&f1, \"&[1, 2, 3]\");\n+    reflect_0(&f1);\n+    let f2 = &f1;\n+    reflect(f2, \"&[1, 2, 3]\");\n+    reflect_0(f2);\n+    let f3: &Fat<[int]> = f2;\n+    reflect(f3, \"&[1, 2, 3]\");\n+    reflect_0(f3);\n+    let f4: &Fat<[int]> = &f1;\n+    reflect(f4, \"&[1, 2, 3]\");\n+    reflect_0(f4);\n+    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    reflect(f5, \"&[1, 2, 3]\");\n+    reflect_0(f5);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    reflect(f5, \"&[]\");\n+}\n+"}, {"sha": "3f01d013cee326820b14c49b5511420c71615c6a", "filename": "src/test/run-pass/dst-struct-sole.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// As dst-struct.rs, but the unsized field is the only field in the struct.\n+\n+struct Fat<type T> {\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[int]>) {\n+    let y = &x.ptr;\n+    assert!(x.ptr.len() == 3);\n+    assert!(y[0] == 1);\n+    assert!(x.ptr[1] == 2);\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.ptr;\n+    let bar = Bar;\n+    assert!(x.ptr.len() == 3);\n+    assert!(y[0].to_bar() == bar);\n+    assert!(x.ptr[1].to_bar() == bar);\n+}\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[int]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[int]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[int]> = &Fat { ptr: [1, 2, 3] };\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = Fat { ptr: [bar, bar, bar] };\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &Fat { ptr: [bar, bar, bar] };\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[int]> = &mut Fat { ptr: [1, 2, 3] };\n+    f5.ptr[1] = 34;\n+    assert!(f5.ptr[0] == 1);\n+    assert!(f5.ptr[1] == 34);\n+    assert!(f5.ptr[2] == 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[int]> = &Fat { ptr: [] };\n+    assert!(f5.ptr.len() == 0);\n+    let f5: &Fat<[Bar]> = &Fat { ptr: [] };\n+    assert!(f5.ptr.len() == 0);\n+}"}, {"sha": "ae1f854ccab34803b8a1bd969be898a42695581e", "filename": "src/test/run-pass/dst-struct.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Fat<type T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[int]>) {\n+    let y = &x.ptr;\n+    assert!(x.ptr.len() == 3);\n+    assert!(y[0] == 1);\n+    assert!(x.ptr[1] == 2);\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.ptr;\n+    let bar = Bar;\n+    assert!(x.ptr.len() == 3);\n+    assert!(y[0].to_bar() == bar);\n+    assert!(x.ptr[1].to_bar() == bar);\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+}\n+\n+fn foo3(x: &Fat<Fat<[int]>>) {\n+    let y = &x.ptr.ptr;\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+    assert!(x.ptr.f1 == 8);\n+    assert!(x.ptr.f2 == \"deep str\");\n+    assert!(x.ptr.ptr.len() == 3);\n+    assert!(y[0] == 1);\n+    assert!(x.ptr.ptr[1] == 2);\n+}\n+\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[int]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[int]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[int]> = &mut Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    f5.ptr[1] = 34;\n+    assert!(f5.ptr[0] == 1);\n+    assert!(f5.ptr[1] == 34);\n+    assert!(f5.ptr[2] == 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[int]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    assert!(f5.ptr.len() == 0);\n+    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n+    assert!(f5.ptr.len() == 0);\n+\n+    // Deeply nested.\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    foo3(&f1);\n+    let f2 = &f1;\n+    foo3(f2);\n+    let f3: &Fat<Fat<[int]>> = f2;\n+    foo3(f3);\n+    let f4: &Fat<Fat<[int]>> = &f1;\n+    foo3(f4);\n+    let f5: &Fat<Fat<[int]>> =\n+        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n+    foo3(f5);\n+\n+    // Box.\n+    let f1 = box [1i, 2, 3];\n+    assert!((*f1)[1] == 2);\n+    let f2: Box<[int]> = f1;\n+    assert!((*f2)[1] == 2);\n+\n+    // Nested Box.\n+    let f1 : Box<Fat<[int, ..3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&*f1);\n+    let f2 : Box<Fat<[int]>> = f1;\n+    foo(&*f2);\n+    let f3 : Box<Fat<[int]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    foo(&*f3);\n+}"}, {"sha": "7429136716c965a141bc8b6687c7e2a074e0fd58", "filename": "src/test/run-pass/dst-trait.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-trait.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Fat<type T> {\n+    f1: int,\n+    f2: &'static str,\n+    ptr: T\n+}\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar;\n+\n+#[deriving(PartialEq,Eq)]\n+struct Bar1 {\n+    f: int\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> int;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+    fn to_val(&self) -> int {\n+        0\n+    }\n+}\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> int {\n+        self.f\n+    }\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<ToBar>) {\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+    assert!(x.ptr.to_bar() == Bar);\n+    assert!(x.ptr.to_val() == 42);\n+\n+    let y = &x.ptr;\n+    assert!(y.to_bar() == Bar);\n+    assert!(y.to_val() == 42);\n+}\n+\n+fn bar(x: &ToBar) {\n+    assert!(x.to_bar() == Bar);\n+    assert!(x.to_val() == 42);\n+}\n+\n+fn baz(x: &Fat<Fat<ToBar>>) {\n+    assert!(x.f1 == 5);\n+    assert!(x.f2 == \"some str\");\n+    assert!(x.ptr.f1 == 8);\n+    assert!(x.ptr.f2 == \"deep str\");\n+    assert!(x.ptr.ptr.to_bar() == Bar);\n+    assert!(x.ptr.ptr.to_val() == 42);\n+\n+    let y = &x.ptr.ptr;\n+    assert!(y.to_bar() == Bar);\n+    assert!(y.to_val() == 42);\n+\n+}\n+\n+pub fn main() {\n+    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<ToBar> = f2;\n+    foo(f3);\n+    let f4: &Fat<ToBar> = &f1;\n+    foo(f4);\n+    let f5: &Fat<ToBar> = &Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    foo(f5);\n+\n+    // Zero size object.\n+    let f6: &Fat<ToBar> = &Fat { f1: 5, f2: \"some str\", ptr: Bar };\n+    assert!(f6.ptr.to_bar() == Bar);\n+\n+    // &*\n+    let f7: Box<ToBar> = box Bar1 {f :42};\n+    bar(&*f7);\n+\n+    // Deep nesting\n+    let f1 =\n+        Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: Bar1 {f :42}} };\n+    baz(&f1);\n+    let f2 = &f1;\n+    baz(f2);\n+    let f3: &Fat<Fat<ToBar>> = f2;\n+    baz(f3);\n+    let f4: &Fat<Fat<ToBar>> = &f1;\n+    baz(f4);\n+    let f5: &Fat<Fat<ToBar>> =\n+        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: Bar1 {f :42}} };\n+    baz(f5);\n+}"}, {"sha": "4a112f145c3ed9ec91276c71d50a3a680fe0496f", "filename": "src/test/run-pass/evec-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fevec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fevec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fevec-slice.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -14,7 +14,7 @@ extern crate debug;\n \n pub fn main() {\n     let x : &[int] = &[1,2,3,4,5];\n-    let mut z = &[1,2,3,4,5];\n+    let mut z : &[int] = &[1,2,3,4,5];\n     z = x;\n     assert_eq!(z[0], 1);\n     assert_eq!(z[4], 5);"}, {"sha": "d2f43aacd66ab5af3873797042372d7ffd0ab1d0", "filename": "src/test/run-pass/gc-vec.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fgc-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fgc-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgc-vec.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::gc::{GC};\n+\n+fn main() {\n+    // A fixed-size array allocated in a garbage-collected box\n+    let x = box(GC) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(x[0], 1);\n+    assert_eq!(x[6], 7);\n+    assert_eq!(x[9], 10);\n+\n+    let y = x;\n+    assert!(*y == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}"}, {"sha": "96db28f4a101fbaab6d30fe890a47e48d310e992", "filename": "src/test/run-pass/issue-7012.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fissue-7012.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fissue-7012.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7012.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -22,6 +22,7 @@ static test1: signature<'static> =  signature {\n };\n \n pub fn main() {\n-  let test = &[0x243f6a88u32,0x85a308d3u32,0x13198a2eu32,0x03707344u32,0xa4093822u32,0x299f31d0u32];\n+  let test: &[u32] = &[0x243f6a88u32,0x85a308d3u32,0x13198a2eu32,\n+                       0x03707344u32,0xa4093822u32,0x299f31d0u32];\n   println!(\"{}\",test==test1.pattern);\n }"}, {"sha": "2818b8249692a1fd499bba4f75fe0e9d0694b627", "filename": "src/test/run-pass/issue-9259.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fissue-9259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fissue-9259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9259.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -14,7 +14,7 @@ struct A<'a> {\n }\n \n pub fn main() {\n-    let b = &[\"foo\".to_string()];\n+    let b: &[String] = &[\"foo\".to_string()];\n     let a = A {\n         a: &[\"test\".to_string()],\n         b: Some(b),"}, {"sha": "2d54663993925e1e1fc2c74d0b23e8ef49dfea09", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -81,5 +81,6 @@ pub fn main() {\n \n     // Check the final states.\n     assert_eq!(*n, 2);\n-    assert_eq!((*v).as_slice(), &[1, 2]);\n+    let expected: &[_] = &[1, 2];\n+    assert_eq!((*v).as_slice(), expected);\n }"}, {"sha": "f599a2b7ad55c9f04923cd15840917c7a7261fd5", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -61,6 +61,8 @@ impl TyVisitor for MyVisitor {\n     fn visit_char(&mut self) -> bool { true }\n \n     fn visit_estr_slice(&mut self) -> bool { true }\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     fn visit_estr_fixed(&mut self,\n                         _sz: uint, _sz2: uint,\n                         _align: uint) -> bool { true }\n@@ -72,7 +74,7 @@ impl TyVisitor for MyVisitor {\n \n     fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n     fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n-                        _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n+                        _inner: *const TyDesc) -> bool { true }\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }"}, {"sha": "52e7118653766d4b6130fecbc3ff189844dc7146", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -22,6 +22,7 @@ extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"sized\"] pub trait Sized {}\n \n #[start]\n #[no_split_stack]"}, {"sha": "809dde38eb498fd51b10251e6bdb78cc63a42395", "filename": "src/test/run-pass/vec-dst.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e626375d8d2226a203bf6ea6e98dab14774c59f/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-dst.rs?ref=3e626375d8d2226a203bf6ea6e98dab14774c59f", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate debug;\n+\n+fn reflect() {\n+    // Tests for reflective printing.\n+    // Also tests drop glue.\n+    let x = [1, 2, 3, 4];\n+    let x2 = [(), (), ()];\n+    let e1: [uint, ..0] = [];\n+    let e2: [&'static str, ..0] = [];\n+    let e3: [(), ..0] = [];\n+    assert!(format!(\"{:?}\", x) == \"[1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", x2) == \"[(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", e1) == \"[]\".to_string());\n+    assert!(format!(\"{:?}\", e2) == \"[]\".to_string());\n+    assert!(format!(\"{:?}\", e3) == \"[]\".to_string());\n+\n+    let rx: &[uint, ..4] = &x;\n+    let rx2: &[(), ..3] = &x2;\n+    let re1: &[uint, ..0] = &e1;\n+    let re2: &[&'static str, ..0] = &e2;\n+    let re3: &[(), ..0] = &e3;\n+    assert!(format!(\"{:?}\", rx) == \"&[1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", rx2) == \"&[(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", re1) == \"&[]\".to_string());\n+    assert!(format!(\"{:?}\", re2) == \"&[]\".to_string());\n+    assert!(format!(\"{:?}\", re3) == \"&[]\".to_string());\n+\n+    let rx: &[uint] = &x;\n+    let rx2: &[()] = &x2;\n+    let re1: &[uint] = &e1;\n+    let re2: &[&'static str] = &e2;\n+    let re3: &[()] = &e3;\n+    assert!(format!(\"{:?}\", rx) == \"&[1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", rx2) == \"&[(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", re1) == \"&[]\".to_string());\n+    assert!(format!(\"{:?}\", re2) == \"&[]\".to_string());\n+    assert!(format!(\"{:?}\", re3) == \"&[]\".to_string());\n+\n+    // FIXME(15049) These should all work some day.\n+    /*let rx: Box<[uint, ..4]> = box x;\n+    let rx2: Box<[(), ..3]> = box x2;\n+    let re1: Box<[uint, ..0]> = box e1;\n+    let re2: Box<[&'static str, ..0]> = box e2;\n+    let re3: Box<[(), ..0]> = box e3;\n+    assert!(format!(\"{:?}\", rx) == \"box [1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", rx2) == \"box [(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", re1) == \"box []\".to_string());\n+    assert!(format!(\"{:?}\", re2) == \"box []\".to_string());\n+    assert!(format!(\"{:?}\", re3) == \"box []\".to_string());\n+\n+    let x = [1, 2, 3, 4];\n+    let x2 = [(), (), ()];\n+    let e1: [uint, ..0] = [];\n+    let e2: [&'static str, ..0] = [];\n+    let e3: [(), ..0] = [];\n+    let rx: Box<[uint]> = box x;\n+    let rx2: Box<[()]> = box x2;\n+    let re1: Box<[uint]> = box e1;\n+    let re2: Box<[&'static str]> = box e2;\n+    let re3: Box<[()]> = box e3;\n+    assert!(format!(\"{:?}\", rx) == \"box [1u, 2u, 3u, 4u]\".to_string());\n+    assert!(format!(\"{:?}\", rx2) == \"box [(), (), ()]\".to_string());\n+    assert!(format!(\"{:?}\", re1) == \"box []\".to_string());\n+    assert!(format!(\"{:?}\", re2) == \"box []\".to_string());\n+    assert!(format!(\"{:?}\", re3) == \"box []\".to_string());*/\n+}\n+\n+fn sub_expr() {\n+    // Test for a &[T] => &&[T] coercion in sub-expression position\n+    // (surpisingly, this can cause errors which are not caused by either of:\n+    //    `let x = vec.mut_slice(0, 2);`\n+    //    `foo(vec.mut_slice(0, 2));` ).\n+    let mut vec: Vec<int> = vec!(1, 2, 3, 4);\n+    let b: &mut [int] = [1, 2];\n+    assert!(vec.mut_slice(0, 2) == b);\n+}\n+\n+fn index() {\n+    // Tests for indexing into box/& [T, ..n]\n+    let x: [int, ..3] = [1, 2, 3];\n+    let mut x: Box<[int, ..3]> = box x;\n+    assert!(x[0] == 1);\n+    assert!(x[1] == 2);\n+    assert!(x[2] == 3);\n+    x[1] = 45;\n+    assert!(x[0] == 1);\n+    assert!(x[1] == 45);\n+    assert!(x[2] == 3);\n+\n+    let mut x: [int, ..3] = [1, 2, 3];\n+    let x: &mut [int, ..3] = &mut x;\n+    assert!(x[0] == 1);\n+    assert!(x[1] == 2);\n+    assert!(x[2] == 3);\n+    x[1] = 45;\n+    assert!(x[0] == 1);\n+    assert!(x[1] == 45);\n+    assert!(x[2] == 3);\n+}\n+\n+pub fn main() {\n+    reflect();\n+    sub_expr();\n+    index();\n+}"}]}