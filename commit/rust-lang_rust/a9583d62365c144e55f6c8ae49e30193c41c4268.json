{"sha": "a9583d62365c144e55f6c8ae49e30193c41c4268", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NTgzZDYyMzY1YzE0NGU1NWY2YzhhZTQ5ZTMwMTkzYzQxYzQyNjg=", "commit": {"author": {"name": "mdinger", "email": "mdinger.bugzilla@gmail.com", "date": "2015-02-02T06:33:38Z"}, "committer": {"name": "mdinger", "email": "mdinger.bugzilla@gmail.com", "date": "2015-02-02T06:33:38Z"}, "message": "Give more detail about eq in book about enums", "tree": {"sha": "fb41102a49a4f832021f0cde883046ca320716e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb41102a49a4f832021f0cde883046ca320716e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9583d62365c144e55f6c8ae49e30193c41c4268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9583d62365c144e55f6c8ae49e30193c41c4268", "html_url": "https://github.com/rust-lang/rust/commit/a9583d62365c144e55f6c8ae49e30193c41c4268", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9583d62365c144e55f6c8ae49e30193c41c4268/comments", "author": {"login": "mdinger", "id": 4156987, "node_id": "MDQ6VXNlcjQxNTY5ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/4156987?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdinger", "html_url": "https://github.com/mdinger", "followers_url": "https://api.github.com/users/mdinger/followers", "following_url": "https://api.github.com/users/mdinger/following{/other_user}", "gists_url": "https://api.github.com/users/mdinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdinger/subscriptions", "organizations_url": "https://api.github.com/users/mdinger/orgs", "repos_url": "https://api.github.com/users/mdinger/repos", "events_url": "https://api.github.com/users/mdinger/events{/privacy}", "received_events_url": "https://api.github.com/users/mdinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mdinger", "id": 4156987, "node_id": "MDQ6VXNlcjQxNTY5ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/4156987?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdinger", "html_url": "https://github.com/mdinger", "followers_url": "https://api.github.com/users/mdinger/followers", "following_url": "https://api.github.com/users/mdinger/following{/other_user}", "gists_url": "https://api.github.com/users/mdinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdinger/subscriptions", "organizations_url": "https://api.github.com/users/mdinger/orgs", "repos_url": "https://api.github.com/users/mdinger/repos", "events_url": "https://api.github.com/users/mdinger/events{/privacy}", "received_events_url": "https://api.github.com/users/mdinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca4b9674c26c1de07a2042cb68e6a062d7184cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4b9674c26c1de07a2042cb68e6a062d7184cef", "html_url": "https://github.com/rust-lang/rust/commit/ca4b9674c26c1de07a2042cb68e6a062d7184cef"}], "stats": {"total": 183, "additions": 90, "deletions": 93}, "files": [{"sha": "8b99278acb1f67e3d917b5421b03662a10c7350a", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 90, "deletions": 93, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/a9583d62365c144e55f6c8ae49e30193c41c4268/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9583d62365c144e55f6c8ae49e30193c41c4268/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=a9583d62365c144e55f6c8ae49e30193c41c4268", "patch": "@@ -200,8 +200,62 @@ destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n ## Enums\n \n Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n-feature of Rust, and are used throughout the standard library. This is an enum\n-that is provided by the Rust standard library:\n+feature of Rust, and are used throughout the standard library. An `enum` is\n+a type which ties a set of alternates to a specific name. For example, below\n+we define `Character` to be either a `Digit` or something else. These\n+can be used via their fully scoped names: `Character::Other` (more about `::`\n+below).\n+\n+```rust\n+enum Character {\n+    Digit(i32),\n+    Other,\n+}\n+```\n+\n+An `enum` variant can be defined as most normal types. Below are some example\n+types have been listed which also would be allowed in an `enum`.\n+\n+```rust\n+struct Empty;\n+struct Color(i32, i32, i32);\n+struct Length(i32);\n+struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n+struct HeightDatabase(Vec<i32>);\n+```\n+\n+So you see that depending on the sub-datastructure, the `enum` variant, same as\n+a struct, may or may not hold data. That is, in `Character`, `Digit` is a name\n+tied to an `i32` where `Other` is just a name. However, the fact that they are\n+distinct makes this very useful.\n+\n+As with structures, enums don't by default have access to operators such as\n+compare ( `==` and `!=`), binary operations (`*` and `+`), and order\n+(`<` and `>=`). As such, using the previous `Character` type, the\n+following code is invalid:\n+\n+```{rust,ignore}\n+// These assignments both succeed\n+let ten  = Character::Digit(10);\n+let four = Character::Digit(4);\n+\n+// Error: `*` is not implemented for type `Character`\n+let forty = ten * four;\n+\n+// Error: `<=` is not implemented for type `Character`\n+let four_is_smaller = four <= ten;\n+\n+// Error: `==` is not implemented for type `Character`\n+let four_equals_ten = four == ten;\n+```\n+\n+This may seem rather limiting, particularly equality being invalid; in\n+many cases however, it's unnecessary. Rust provides the [`match`][match]\n+keyword, which will be examined in more detail in the next section, which\n+often allows better and easier branch control than a series of `if`/`else`\n+statements would. However, for our [game][game] we need the comparisons\n+to work so we will utilize the `Ordering` `enum` provided by the standard\n+library which supports such comparisons. It has this form:\n \n ```{rust}\n enum Ordering {\n@@ -211,14 +265,9 @@ enum Ordering {\n }\n ```\n \n-An `Ordering` can only be _one_ of `Less`, `Equal`, or `Greater` at any given\n-time.\n-\n-Because `Ordering` is provided by the standard library, we can use the `use`\n-keyword to use it in our code. We'll learn more about `use` later, but it's\n-used to bring names into scope.\n-\n-Here's an example of how to use `Ordering`:\n+Because we did not define `Ordering`, we must import it (from the std\n+library) with the `use` keyword. Here's an example of how `Ordering` is\n+used:\n \n ```{rust}\n use std::cmp::Ordering;\n@@ -245,11 +294,10 @@ fn main() {\n }\n ```\n \n-There's a symbol here we haven't seen before: the double colon (`::`).\n-This is used to indicate a namespace. In this case, `Ordering` lives in\n-the `cmp` submodule of the `std` module. We'll talk more about modules\n-later in the guide. For now, all you need to know is that you can `use`\n-things from the standard library if you need them.\n+The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives\n+in the `cmp` submodule of the `std` module. We'll talk more about modules later\n+in the guide. For now, all you need to know is that you can `use` things from\n+the standard library if you need them.\n \n Okay, let's talk about the actual code in the example. `cmp` is a function that\n compares two things, and returns an `Ordering`. We return either\n@@ -259,95 +307,44 @@ the two values are less, greater, or equal. Note that each variant of the\n `Greater`.\n \n The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We can then do a bunch of `if`/`else` comparisons to check which\n-one it is. However, repeated `if`/`else` comparisons get quite tedious. Rust\n-has a feature that not only makes them nicer to read, but also makes sure that\n-you never miss a case. Before we get to that, though, let's talk about another\n-kind of enum: one with values.\n+three values. We then do a bunch of `if`/`else` comparisons to check which\n+one it is.\n \n-This enum has two variants, one of which has a value:\n+This `Ordering::Greater` notation is too long. Lets use `use` to import can\n+the `enum` variants instead. This will avoid full scoping:\n \n ```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-```\n-\n-This enum represents an `i32` that we may or may not have. In the `Missing`\n-case, we have no value, but in the `Value` case, we do. This enum is specific\n-to `i32`s, though. We can make it usable by any type, but we haven't quite\n-gotten there yet!\n-\n-You can also have any number of values in an enum:\n+use std::cmp::Ordering::{self, Equal, Less, Greater};\n \n-```{rust}\n-enum OptionalColor {\n-    Color(i32, i32, i32),\n-    Missing,\n-}\n-```\n-\n-And you can also have something like this:\n-\n-```{rust}\n-enum StringResult {\n-    StringOK(String),\n-    ErrorReason(String),\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n }\n-```\n-Where a `StringResult` is either a `StringResult::StringOK`, with the result of\n-a computation, or a `StringResult::ErrorReason` with a `String` explaining\n-what caused the computation to fail. These kinds of `enum`s are actually very\n-useful and are even part of the standard library.\n \n-Here is an example of using our `StringResult`:\n+fn main() {\n+    let x = 5;\n+    let y = 10;\n \n-```rust\n-enum StringResult {\n-    StringOK(String),\n-    ErrorReason(String),\n-}\n+    let ordering = cmp(x, y); // ordering: Ordering\n \n-fn respond(greeting: &str) -> StringResult {\n-    if greeting == \"Hello\" {\n-        StringResult::StringOK(\"Good morning!\".to_string())\n-    } else {\n-        StringResult::ErrorReason(\"I didn't understand you!\".to_string())\n-    }\n+    if ordering == Less { println!(\"less\"); }\n+    else if ordering == Greater { println!(\"greater\"); }\n+    else if ordering == Equal { println!(\"equal\"); }\n }\n ```\n \n-That's a lot of typing! We can use the `use` keyword to make it shorter:\n+Importing variants is convenient and compact, but can also cause name conflicts,\n+so do this with caution. It's considered good style to rarely import variants\n+for this reason.\n \n-```rust\n-use StringResult::StringOK;\n-use StringResult::ErrorReason;\n+As you can see, `enum`s are quite a powerful tool for data representation, and are\n+even more useful when they're [generic][generics] across types. Before we\n+get to generics, though, let's talk about how to use them with pattern matching, a\n+tool that will let us deconstruct this sum type (the type theory term for enums)\n+in a very elegant way and avoid all these messy `if`/`else`s.\n \n-enum StringResult {\n-    StringOK(String),\n-    ErrorReason(String),\n-}\n-\n-# fn main() {}\n-\n-fn respond(greeting: &str) -> StringResult {\n-    if greeting == \"Hello\" {\n-        StringOK(\"Good morning!\".to_string())\n-    } else {\n-        ErrorReason(\"I didn't understand you!\".to_string())\n-    }\n-}\n-```\n \n-`use` declarations must come before anything else, which looks a little strange in this example,\n-since we `use` the variants before we define them. Anyway, in the body of `respond`, we can just\n-say `StringOK` now, rather than the full `StringResult::StringOK`. Importing variants can be\n-convenient, but can also cause name conflicts, so do this with caution. It's considered good style\n-to rarely import variants for this reason.\n-\n-As you can see, `enum`s with values are quite a powerful tool for data representation,\n-and can be even more useful when they're generic across types. Before we get to generics,\n-though, let's talk about how to use them with pattern matching, a tool that will\n-let us deconstruct this sum type (the type theory term for enums) in a very elegant\n-way and avoid all these messy `if`/`else`s.\n+[match]: ./match.html\n+[game]: ./guessing-game.html#comparing-guesses\n+[generics]: ./generics.html"}]}