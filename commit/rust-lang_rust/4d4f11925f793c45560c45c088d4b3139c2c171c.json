{"sha": "4d4f11925f793c45560c45c088d4b3139c2c171c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNGYxMTkyNWY3OTNjNDU1NjBjNDVjMDg4ZDRiMzEzOWMyYzE3MWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-08T13:10:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-08T13:10:28Z"}, "message": "Merge #6706\n\n6706: Move import text edit calculation into a completion resolve request r=matklad a=SomeoneToIgnore\n\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/6612 (presumably fixing it)\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/6366 (does not cover all possible resolve capabilities we can do)\r\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/6594\r\n\r\nFurther improves imports on completion performance by deferring the computations for import inserts.\r\n\r\nTo use the new mode, you have to have the experimental completions enabled and use the LSP 3.16-compliant client that reports `additionalTextEdits` in its `CompletionItemCapabilityResolveSupport` field in the client capabilities.\r\nrust-analyzer VSCode extension does this already hence picks up the changes completely.\r\n\r\nPerformance implications are descrbed in: https://github.com/rust-analyzer/rust-analyzer/issues/6633#issuecomment-737295182\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "f8c5e3c14a0bb55d4b435b8389bccf305975d39a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c5e3c14a0bb55d4b435b8389bccf305975d39a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d4f11925f793c45560c45c088d4b3139c2c171c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfz3tECRBK7hj4Ov3rIwAAdHIIAC5guyS2IbYvb4KG4/JOwQ/M\naBbzGsc49XoFI5jf1xovpVSfXtlvHmxl7hkEslr6eDk16fEo1ekdWNKL+r9KwMjH\njZ3IghopY1PnKcb9o2KVFA0MpxAhlyr80oJ33lm4pAZEFQK1ty+pBzxNqSRDJsTy\nHqIcL7XbsBgJXVnam/5zuE+3rEy+8M38tXD3qEa1HNBR/qNFSNxFL+eVGCtTOJiG\n5BLvGTSpuVqrByDDFu5HYfEXjGxeMICr5gOq33eqOfdm3T65bJj4RI0jfQNwY7/W\n6L73jCun2hGI4NMCw6EIFt2LSOQ37aNZGLEO2B/9oEeL2x5qEoch6PLXb/ZAIP0=\n=OZ4J\n-----END PGP SIGNATURE-----\n", "payload": "tree f8c5e3c14a0bb55d4b435b8389bccf305975d39a\nparent 021e97ea03cf67ad7785ab39580e04bc69506b8c\nparent bf24cb3e8db94a84fb4a24c407797ab6ff5ee109\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1607433028 +0000\ncommitter GitHub <noreply@github.com> 1607433028 +0000\n\nMerge #6706\n\n6706: Move import text edit calculation into a completion resolve request r=matklad a=SomeoneToIgnore\n\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/6612 (presumably fixing it)\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/6366 (does not cover all possible resolve capabilities we can do)\r\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/6594\r\n\r\nFurther improves imports on completion performance by deferring the computations for import inserts.\r\n\r\nTo use the new mode, you have to have the experimental completions enabled and use the LSP 3.16-compliant client that reports `additionalTextEdits` in its `CompletionItemCapabilityResolveSupport` field in the client capabilities.\r\nrust-analyzer VSCode extension does this already hence picks up the changes completely.\r\n\r\nPerformance implications are descrbed in: https://github.com/rust-analyzer/rust-analyzer/issues/6633#issuecomment-737295182\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d4f11925f793c45560c45c088d4b3139c2c171c", "html_url": "https://github.com/rust-lang/rust/commit/4d4f11925f793c45560c45c088d4b3139c2c171c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d4f11925f793c45560c45c088d4b3139c2c171c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "021e97ea03cf67ad7785ab39580e04bc69506b8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/021e97ea03cf67ad7785ab39580e04bc69506b8c", "html_url": "https://github.com/rust-lang/rust/commit/021e97ea03cf67ad7785ab39580e04bc69506b8c"}, {"sha": "bf24cb3e8db94a84fb4a24c407797ab6ff5ee109", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf24cb3e8db94a84fb4a24c407797ab6ff5ee109", "html_url": "https://github.com/rust-lang/rust/commit/bf24cb3e8db94a84fb4a24c407797ab6ff5ee109"}], "stats": {"total": 683, "additions": 565, "deletions": 118}, "files": [{"sha": "4e4e2b36f07c75a3e56f6351e45e05295489c690", "filename": "crates/completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 78, "deletions": 14, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -9,7 +9,7 @@ use test_utils::mark;\n \n use crate::{\n     render::{render_resolution_with_import, RenderContext},\n-    CompletionContext, Completions,\n+    CompletionContext, Completions, ImportEdit,\n };\n \n pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -44,7 +44,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         acc.add_resolution(ctx, name.to_string(), &res)\n     });\n \n-    if ctx.config.enable_experimental_completions {\n+    if ctx.config.enable_autoimport_completions && ctx.config.resolve_additional_edits_lazily() {\n         fuzzy_completion(acc, ctx).unwrap_or_default()\n     }\n }\n@@ -73,19 +73,64 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n     }\n }\n \n+// Feature: Fuzzy Completion and Autoimports\n+//\n+// When completing names in the current scope, proposes additional imports from other modules or crates,\n+// if they can be qualified in the scope and their name contains all symbols from the completion input\n+// (case-insensitive, in any order or places).\n+//\n+// ```\n+// fn main() {\n+//     pda<|>\n+// }\n+// # pub mod std { pub mod marker { pub struct PhantomData { } } }\n+// ```\n+// ->\n+// ```\n+// use std::marker::PhantomData;\n+//\n+// fn main() {\n+//     PhantomData\n+// }\n+// # pub mod std { pub mod marker { pub struct PhantomData { } } }\n+// ```\n+//\n+// .Fuzzy search details\n+//\n+// To avoid an excessive amount of the results returned, completion input is checked for inclusion in the identifiers only\n+// (i.e. in `HashMap` in the `std::collections::HashMap` path), also not in the module indentifiers.\n+//\n+// .Merge Behaviour\n+//\n+// It is possible to configure how use-trees are merged with the `importMergeBehaviour` setting.\n+// Mimics the corresponding behaviour of the `Auto Import` feature.\n+//\n+// .LSP and performance implications\n+//\n+// The feature is enabled only if the LSP client supports LSP protocol version 3.16+ and reports the `additionalTextEdits`\n+// (case sensitive) resolve client capability in its client capabilities.\n+// This way the server is able to defer the costly computations, doing them for a selected completion item only.\n+// For clients with no such support, all edits have to be calculated on the completion request, including the fuzzy search completion ones,\n+// which might be slow ergo the feature is automatically disabled.\n+//\n+// .Feature toggle\n+//\n+// The feature can be forcefully turned off in the settings with the `rust-analyzer.completion.enableAutoimportCompletions` flag.\n+// Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n+// capability enabled.\n fn fuzzy_completion(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n     let _p = profile::span(\"fuzzy_completion\");\n+    let potential_import_name = ctx.token.to_string();\n+\n     let current_module = ctx.scope.module()?;\n     let anchor = ctx.name_ref_syntax.as_ref()?;\n     let import_scope = ImportScope::find_insert_use_container(anchor.syntax(), &ctx.sema)?;\n \n-    let potential_import_name = ctx.token.to_string();\n-\n     let possible_imports = imports_locator::find_similar_imports(\n         &ctx.sema,\n         ctx.krate?,\n+        Some(100),\n         &potential_import_name,\n-        50,\n         true,\n     )\n     .filter_map(|import_candidate| {\n@@ -99,13 +144,14 @@ fn fuzzy_completion(acc: &mut Completions, ctx: &CompletionContext) -> Option<()\n         })\n     })\n     .filter(|(mod_path, _)| mod_path.len() > 1)\n-    .take(20)\n     .filter_map(|(import_path, definition)| {\n         render_resolution_with_import(\n             RenderContext::new(ctx),\n-            import_path.clone(),\n-            import_scope.clone(),\n-            ctx.config.merge,\n+            ImportEdit {\n+                import_path: import_path.clone(),\n+                import_scope: import_scope.clone(),\n+                merge_behaviour: ctx.config.merge,\n+            },\n             &definition,\n         )\n     });\n@@ -120,8 +166,8 @@ mod tests {\n     use test_utils::mark;\n \n     use crate::{\n-        test_utils::{check_edit, completion_list},\n-        CompletionKind,\n+        test_utils::{check_edit, check_edit_with_config, completion_list},\n+        CompletionConfig, CompletionKind,\n     };\n \n     fn check(ra_fixture: &str, expect: Expect) {\n@@ -730,7 +776,13 @@ impl My<|>\n \n     #[test]\n     fn function_fuzzy_completion() {\n-        check_edit(\n+        let mut completion_config = CompletionConfig::default();\n+        completion_config\n+            .active_resolve_capabilities\n+            .insert(crate::CompletionResolveCapability::AdditionalTextEdits);\n+\n+        check_edit_with_config(\n+            completion_config,\n             \"stdin\",\n             r#\"\n //- /lib.rs crate:dep\n@@ -755,7 +807,13 @@ fn main() {\n \n     #[test]\n     fn macro_fuzzy_completion() {\n-        check_edit(\n+        let mut completion_config = CompletionConfig::default();\n+        completion_config\n+            .active_resolve_capabilities\n+            .insert(crate::CompletionResolveCapability::AdditionalTextEdits);\n+\n+        check_edit_with_config(\n+            completion_config,\n             \"macro_with_curlies!\",\n             r#\"\n //- /lib.rs crate:dep\n@@ -782,7 +840,13 @@ fn main() {\n \n     #[test]\n     fn struct_fuzzy_completion() {\n-        check_edit(\n+        let mut completion_config = CompletionConfig::default();\n+        completion_config\n+            .active_resolve_capabilities\n+            .insert(crate::CompletionResolveCapability::AdditionalTextEdits);\n+\n+        check_edit_with_config(\n+            completion_config,\n             \"ThirdStruct\",\n             r#\"\n //- /lib.rs crate:dep"}, {"sha": "5175b9d69dc2517a7f585dfd6bb6d0a2245e62c2", "filename": "crates/completion/src/config.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fconfig.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -5,21 +5,42 @@\n //! completions if we are allowed to.\n \n use ide_db::helpers::insert_use::MergeBehaviour;\n+use rustc_hash::FxHashSet;\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct CompletionConfig {\n     pub enable_postfix_completions: bool,\n-    pub enable_experimental_completions: bool,\n+    pub enable_autoimport_completions: bool,\n     pub add_call_parenthesis: bool,\n     pub add_call_argument_snippets: bool,\n     pub snippet_cap: Option<SnippetCap>,\n     pub merge: Option<MergeBehaviour>,\n+    /// A set of capabilities, enabled on the client and supported on the server.\n+    pub active_resolve_capabilities: FxHashSet<CompletionResolveCapability>,\n+}\n+\n+/// A resolve capability, supported on the server.\n+/// If the client registers any completion resolve capabilities,\n+/// the server is able to render completion items' corresponding fields later,\n+/// not during an initial completion item request.\n+/// See https://github.com/rust-analyzer/rust-analyzer/issues/6366 for more details.\n+#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n+pub enum CompletionResolveCapability {\n+    Documentation,\n+    Detail,\n+    AdditionalTextEdits,\n }\n \n impl CompletionConfig {\n     pub fn allow_snippets(&mut self, yes: bool) {\n         self.snippet_cap = if yes { Some(SnippetCap { _private: () }) } else { None }\n     }\n+\n+    /// Whether the completions' additional edits are calculated when sending an initional completions list\n+    /// or later, in a separate resolve request.\n+    pub fn resolve_additional_edits_lazily(&self) -> bool {\n+        self.active_resolve_capabilities.contains(&CompletionResolveCapability::AdditionalTextEdits)\n+    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n@@ -31,11 +52,12 @@ impl Default for CompletionConfig {\n     fn default() -> Self {\n         CompletionConfig {\n             enable_postfix_completions: true,\n-            enable_experimental_completions: true,\n+            enable_autoimport_completions: true,\n             add_call_parenthesis: true,\n             add_call_argument_snippets: true,\n             snippet_cap: Some(SnippetCap { _private: () }),\n             merge: Some(MergeBehaviour::Full),\n+            active_resolve_capabilities: FxHashSet::default(),\n         }\n     }\n }"}, {"sha": "bd94402d75364ed43cf130687c2b742ddf8510eb", "filename": "crates/completion/src/item.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fitem.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -15,6 +15,7 @@ use crate::config::SnippetCap;\n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n /// `CompletionItem`, use `new` method and the `Builder` struct.\n+#[derive(Clone)]\n pub struct CompletionItem {\n     /// Used only internally in tests, to check only specific kind of\n     /// completion (postfix, keyword, reference, etc).\n@@ -65,6 +66,9 @@ pub struct CompletionItem {\n     /// Indicates that a reference or mutable reference to this variable is a\n     /// possible match.\n     ref_match: Option<(Mutability, CompletionScore)>,\n+\n+    /// The import data to add to completion's edits.\n+    import_to_add: Option<ImportEdit>,\n }\n \n // We use custom debug for CompletionItem to make snapshot tests more readable.\n@@ -256,14 +260,37 @@ impl CompletionItem {\n     pub fn ref_match(&self) -> Option<(Mutability, CompletionScore)> {\n         self.ref_match\n     }\n+\n+    pub fn import_to_add(&self) -> Option<&ImportEdit> {\n+        self.import_to_add.as_ref()\n+    }\n }\n \n /// An extra import to add after the completion is applied.\n-#[derive(Clone)]\n-pub(crate) struct ImportToAdd {\n-    pub(crate) import_path: ModPath,\n-    pub(crate) import_scope: ImportScope,\n-    pub(crate) merge_behaviour: Option<MergeBehaviour>,\n+#[derive(Debug, Clone)]\n+pub struct ImportEdit {\n+    pub import_path: ModPath,\n+    pub import_scope: ImportScope,\n+    pub merge_behaviour: Option<MergeBehaviour>,\n+}\n+\n+impl ImportEdit {\n+    /// Attempts to insert the import to the given scope, producing a text edit.\n+    /// May return no edit in edge cases, such as scope already containing the import.\n+    pub fn to_text_edit(&self) -> Option<TextEdit> {\n+        let _p = profile::span(\"ImportEdit::to_text_edit\");\n+\n+        let rewriter = insert_use::insert_use(\n+            &self.import_scope,\n+            mod_path_to_ast(&self.import_path),\n+            self.merge_behaviour,\n+        );\n+        let old_ast = rewriter.rewrite_root()?;\n+        let mut import_insert = TextEdit::builder();\n+        algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n+\n+        Some(import_insert.finish())\n+    }\n }\n \n /// A helper to make `CompletionItem`s.\n@@ -272,7 +299,7 @@ pub(crate) struct ImportToAdd {\n pub(crate) struct Builder {\n     source_range: TextRange,\n     completion_kind: CompletionKind,\n-    import_to_add: Option<ImportToAdd>,\n+    import_to_add: Option<ImportEdit>,\n     label: String,\n     insert_text: Option<String>,\n     insert_text_format: InsertTextFormat,\n@@ -294,11 +321,9 @@ impl Builder {\n         let mut label = self.label;\n         let mut lookup = self.lookup;\n         let mut insert_text = self.insert_text;\n-        let mut text_edits = TextEdit::builder();\n \n-        if let Some(import_data) = self.import_to_add {\n-            let import = mod_path_to_ast(&import_data.import_path);\n-            let mut import_path_without_last_segment = import_data.import_path;\n+        if let Some(import_to_add) = self.import_to_add.as_ref() {\n+            let mut import_path_without_last_segment = import_to_add.import_path.to_owned();\n             let _ = import_path_without_last_segment.segments.pop();\n \n             if !import_path_without_last_segment.segments.is_empty() {\n@@ -310,32 +335,20 @@ impl Builder {\n                 }\n                 label = format!(\"{}::{}\", import_path_without_last_segment, label);\n             }\n-\n-            let rewriter = insert_use::insert_use(\n-                &import_data.import_scope,\n-                import,\n-                import_data.merge_behaviour,\n-            );\n-            if let Some(old_ast) = rewriter.rewrite_root() {\n-                algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut text_edits);\n-            }\n         }\n \n-        let original_edit = match self.text_edit {\n+        let text_edit = match self.text_edit {\n             Some(it) => it,\n             None => {\n                 TextEdit::replace(self.source_range, insert_text.unwrap_or_else(|| label.clone()))\n             }\n         };\n \n-        let mut resulting_edit = text_edits.finish();\n-        resulting_edit.union(original_edit).expect(\"Failed to unite text edits\");\n-\n         CompletionItem {\n             source_range: self.source_range,\n             label,\n             insert_text_format: self.insert_text_format,\n-            text_edit: resulting_edit,\n+            text_edit,\n             detail: self.detail,\n             documentation: self.documentation,\n             lookup,\n@@ -345,6 +358,7 @@ impl Builder {\n             trigger_call_info: self.trigger_call_info.unwrap_or(false),\n             score: self.score,\n             ref_match: self.ref_match,\n+            import_to_add: self.import_to_add,\n         }\n     }\n     pub(crate) fn lookup_by(mut self, lookup: impl Into<String>) -> Builder {\n@@ -407,7 +421,7 @@ impl Builder {\n         self.trigger_call_info = Some(true);\n         self\n     }\n-    pub(crate) fn add_import(mut self, import_to_add: Option<ImportToAdd>) -> Builder {\n+    pub(crate) fn add_import(mut self, import_to_add: Option<ImportEdit>) -> Builder {\n         self.import_to_add = import_to_add;\n         self\n     }"}, {"sha": "f60f87243fb03862c4faee8045284addbce4ffaa", "filename": "crates/completion/src/lib.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Flib.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -11,14 +11,17 @@ mod render;\n \n mod completions;\n \n-use ide_db::base_db::FilePosition;\n-use ide_db::RootDatabase;\n+use ide_db::{\n+    base_db::FilePosition, helpers::insert_use::ImportScope, imports_locator, RootDatabase,\n+};\n+use syntax::AstNode;\n+use text_edit::TextEdit;\n \n use crate::{completions::Completions, context::CompletionContext, item::CompletionKind};\n \n pub use crate::{\n-    config::CompletionConfig,\n-    item::{CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat},\n+    config::{CompletionConfig, CompletionResolveCapability},\n+    item::{CompletionItem, CompletionItemKind, CompletionScore, ImportEdit, InsertTextFormat},\n };\n \n //FIXME: split the following feature into fine-grained features.\n@@ -70,12 +73,9 @@ pub use crate::{\n // }\n // ```\n //\n-// And experimental completions, enabled with the `rust-analyzer.completion.enableExperimental` setting.\n-// This flag enables or disables:\n-//\n-// - Auto import: additional completion options with automatic `use` import and options from all project importable items, matched for the input\n-//\n-// Experimental completions might cause issues with performance and completion list look.\n+// And the auto import completions, enabled with the `rust-analyzer.completion.autoimport.enable` setting and the corresponding LSP client capabilities.\n+// Those are the additional completion options with automatic `use` import and options from all project importable items,\n+// fuzzy matched agains the completion imput.\n \n /// Main entry point for completion. We run completion as a two-phase process.\n ///\n@@ -131,6 +131,33 @@ pub fn completions(\n     Some(acc)\n }\n \n+/// Resolves additional completion data at the position given.\n+pub fn resolve_completion_edits(\n+    db: &RootDatabase,\n+    config: &CompletionConfig,\n+    position: FilePosition,\n+    full_import_path: &str,\n+    imported_name: &str,\n+) -> Option<Vec<TextEdit>> {\n+    let ctx = CompletionContext::new(db, position, config)?;\n+    let anchor = ctx.name_ref_syntax.as_ref()?;\n+    let import_scope = ImportScope::find_insert_use_container(anchor.syntax(), &ctx.sema)?;\n+\n+    let current_module = ctx.sema.scope(anchor.syntax()).module()?;\n+    let current_crate = current_module.krate();\n+\n+    let import_path = imports_locator::find_exact_imports(&ctx.sema, current_crate, imported_name)\n+        .filter_map(|candidate| {\n+            let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n+            current_module.find_use_path(db, item)\n+        })\n+        .find(|mod_path| mod_path.to_string() == full_import_path)?;\n+\n+    ImportEdit { import_path, import_scope, merge_behaviour: config.merge }\n+        .to_text_edit()\n+        .map(|edit| vec![edit])\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::config::CompletionConfig;"}, {"sha": "b940388df26aabbd40dddbeed4f27092763c7ca4", "filename": "crates/completion/src/render.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -9,14 +9,13 @@ pub(crate) mod type_alias;\n \n mod builder_ext;\n \n-use hir::{Documentation, HasAttrs, HirDisplay, ModPath, Mutability, ScopeDef, Type};\n-use ide_db::helpers::insert_use::{ImportScope, MergeBehaviour};\n+use hir::{Documentation, HasAttrs, HirDisplay, Mutability, ScopeDef, Type};\n use ide_db::RootDatabase;\n use syntax::TextRange;\n use test_utils::mark;\n \n use crate::{\n-    config::SnippetCap, item::ImportToAdd, CompletionContext, CompletionItem, CompletionItemKind,\n+    config::SnippetCap, item::ImportEdit, CompletionContext, CompletionItem, CompletionItemKind,\n     CompletionKind, CompletionScore,\n };\n \n@@ -48,15 +47,12 @@ pub(crate) fn render_resolution<'a>(\n \n pub(crate) fn render_resolution_with_import<'a>(\n     ctx: RenderContext<'a>,\n-    import_path: ModPath,\n-    import_scope: ImportScope,\n-    merge_behaviour: Option<MergeBehaviour>,\n+    import_edit: ImportEdit,\n     resolution: &ScopeDef,\n ) -> Option<CompletionItem> {\n-    let local_name = import_path.segments.last()?.to_string();\n     Render::new(ctx).render_resolution(\n-        local_name,\n-        Some(ImportToAdd { import_path, import_scope, merge_behaviour }),\n+        import_edit.import_path.segments.last()?.to_string(),\n+        Some(import_edit),\n         resolution,\n     )\n }\n@@ -147,7 +143,7 @@ impl<'a> Render<'a> {\n     fn render_resolution(\n         self,\n         local_name: String,\n-        import_to_add: Option<ImportToAdd>,\n+        import_to_add: Option<ImportEdit>,\n         resolution: &ScopeDef,\n     ) -> Option<CompletionItem> {\n         let _p = profile::span(\"render_resolution\");\n@@ -450,28 +446,6 @@ fn main() { let _: m::Spam = S<|> }\n                         insert: \"m\",\n                         kind: Module,\n                     },\n-                    CompletionItem {\n-                        label: \"m::Spam\",\n-                        source_range: 75..76,\n-                        text_edit: TextEdit {\n-                            indels: [\n-                                Indel {\n-                                    insert: \"use m::Spam;\",\n-                                    delete: 0..0,\n-                                },\n-                                Indel {\n-                                    insert: \"\\n\\n\",\n-                                    delete: 0..0,\n-                                },\n-                                Indel {\n-                                    insert: \"Spam\",\n-                                    delete: 75..76,\n-                                },\n-                            ],\n-                        },\n-                        kind: Enum,\n-                        lookup: \"Spam\",\n-                    },\n                     CompletionItem {\n                         label: \"m::Spam::Foo\",\n                         source_range: 75..76,"}, {"sha": "8e0fea6c0fc5768e6ee2acfa912371f323c371ea", "filename": "crates/completion/src/render/enum_variant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -5,13 +5,13 @@ use itertools::Itertools;\n use test_utils::mark;\n \n use crate::{\n-    item::{CompletionItem, CompletionItemKind, CompletionKind, ImportToAdd},\n+    item::{CompletionItem, CompletionItemKind, CompletionKind, ImportEdit},\n     render::{builder_ext::Params, RenderContext},\n };\n \n pub(crate) fn render_enum_variant<'a>(\n     ctx: RenderContext<'a>,\n-    import_to_add: Option<ImportToAdd>,\n+    import_to_add: Option<ImportEdit>,\n     local_name: Option<String>,\n     variant: hir::EnumVariant,\n     path: Option<ModPath>,\n@@ -62,7 +62,7 @@ impl<'a> EnumVariantRender<'a> {\n         }\n     }\n \n-    fn render(self, import_to_add: Option<ImportToAdd>) -> CompletionItem {\n+    fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n         let mut builder = CompletionItem::new(\n             CompletionKind::Reference,\n             self.ctx.source_range(),"}, {"sha": "d16005249c0cee3b2f22f181fa523cfbb3623303", "filename": "crates/completion/src/render/function.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -5,13 +5,13 @@ use syntax::{ast::Fn, display::function_declaration};\n use test_utils::mark;\n \n use crate::{\n-    item::{CompletionItem, CompletionItemKind, CompletionKind, ImportToAdd},\n+    item::{CompletionItem, CompletionItemKind, CompletionKind, ImportEdit},\n     render::{builder_ext::Params, RenderContext},\n };\n \n pub(crate) fn render_fn<'a>(\n     ctx: RenderContext<'a>,\n-    import_to_add: Option<ImportToAdd>,\n+    import_to_add: Option<ImportEdit>,\n     local_name: Option<String>,\n     fn_: hir::Function,\n ) -> CompletionItem {\n@@ -39,7 +39,7 @@ impl<'a> FunctionRender<'a> {\n         FunctionRender { ctx, name, func: fn_, ast_node }\n     }\n \n-    fn render(self, import_to_add: Option<ImportToAdd>) -> CompletionItem {\n+    fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n         let params = self.params();\n         CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), self.name.clone())\n             .kind(self.kind())"}, {"sha": "eb3209bee3dcf8e6a599110763e048dd255bcaa6", "filename": "crates/completion/src/render/macro_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -5,13 +5,13 @@ use syntax::display::macro_label;\n use test_utils::mark;\n \n use crate::{\n-    item::{CompletionItem, CompletionItemKind, CompletionKind, ImportToAdd},\n+    item::{CompletionItem, CompletionItemKind, CompletionKind, ImportEdit},\n     render::RenderContext,\n };\n \n pub(crate) fn render_macro<'a>(\n     ctx: RenderContext<'a>,\n-    import_to_add: Option<ImportToAdd>,\n+    import_to_add: Option<ImportEdit>,\n     name: String,\n     macro_: hir::MacroDef,\n ) -> Option<CompletionItem> {\n@@ -38,7 +38,7 @@ impl<'a> MacroRender<'a> {\n         MacroRender { ctx, name, macro_, docs, bra, ket }\n     }\n \n-    fn render(&self, import_to_add: Option<ImportToAdd>) -> Option<CompletionItem> {\n+    fn render(&self, import_to_add: Option<ImportEdit>) -> Option<CompletionItem> {\n         // FIXME: Currently proc-macro do not have ast-node,\n         // such that it does not have source\n         if self.macro_.is_proc_macro() {"}, {"sha": "25f5f4924cd53ee06768135dad297194ec9994e0", "filename": "crates/completion/src/test_utils.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -96,7 +96,16 @@ pub(crate) fn check_edit_with_config(\n         .collect_tuple()\n         .unwrap_or_else(|| panic!(\"can't find {:?} completion in {:#?}\", what, completions));\n     let mut actual = db.file_text(position.file_id).to_string();\n-    completion.text_edit().apply(&mut actual);\n+\n+    let mut combined_edit = completion.text_edit().to_owned();\n+    if let Some(import_text_edit) = completion.import_to_add().and_then(|edit| edit.to_text_edit())\n+    {\n+        combined_edit.union(import_text_edit).expect(\n+            \"Failed to apply completion resolve changes: change ranges overlap, but should not\",\n+        )\n+    }\n+\n+    combined_edit.apply(&mut actual);\n     assert_eq_text!(&ra_fixture_after, &actual)\n }\n "}, {"sha": "71068cac28aa9021c25784de64d6bfc8429aa7bd", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -80,7 +80,8 @@ pub use crate::{\n     },\n };\n pub use completion::{\n-    CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat,\n+    CompletionConfig, CompletionItem, CompletionItemKind, CompletionResolveCapability,\n+    CompletionScore, ImportEdit, InsertTextFormat,\n };\n pub use ide_db::{\n     call_info::CallInfo,\n@@ -468,6 +469,27 @@ impl Analysis {\n         self.with_db(|db| completion::completions(db, config, position).map(Into::into))\n     }\n \n+    /// Resolves additional completion data at the position given.\n+    pub fn resolve_completion_edits(\n+        &self,\n+        config: &CompletionConfig,\n+        position: FilePosition,\n+        full_import_path: &str,\n+        imported_name: &str,\n+    ) -> Cancelable<Vec<TextEdit>> {\n+        Ok(self\n+            .with_db(|db| {\n+                completion::resolve_completion_edits(\n+                    db,\n+                    config,\n+                    position,\n+                    full_import_path,\n+                    imported_name,\n+                )\n+            })?\n+            .unwrap_or_default())\n+    }\n+\n     /// Computes resolved assists with source changes for the given position.\n     pub fn resolved_assists(\n         &self,"}, {"sha": "b2980a5d69df2e651791ddc74c1b92e0d679f062", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -34,27 +34,25 @@ pub fn find_exact_imports<'a>(\n pub fn find_similar_imports<'a>(\n     sema: &Semantics<'a, RootDatabase>,\n     krate: Crate,\n+    limit: Option<usize>,\n     name_to_import: &str,\n-    limit: usize,\n     ignore_modules: bool,\n ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n     let _p = profile::span(\"find_similar_imports\");\n \n-    let mut external_query = import_map::Query::new(name_to_import).limit(limit);\n+    let mut external_query = import_map::Query::new(name_to_import);\n     if ignore_modules {\n         external_query = external_query.exclude_import_kind(import_map::ImportKind::Module);\n     }\n \n-    find_imports(\n-        sema,\n-        krate,\n-        {\n-            let mut local_query = symbol_index::Query::new(name_to_import.to_string());\n-            local_query.limit(limit);\n-            local_query\n-        },\n-        external_query,\n-    )\n+    let mut local_query = symbol_index::Query::new(name_to_import.to_string());\n+\n+    if let Some(limit) = limit {\n+        local_query.limit(limit);\n+        external_query = external_query.limit(limit);\n+    }\n+\n+    find_imports(sema, krate, local_query, external_query)\n }\n \n fn find_imports<'a>("}, {"sha": "5e4c22bc5c88c1e7e28303b293655c54a8f67bd7", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -1,6 +1,7 @@\n //! Advertizes the capabilities of the LSP Server.\n use std::env;\n \n+use ide::CompletionResolveCapability;\n use lsp_types::{\n     CallHierarchyServerCapability, ClientCapabilities, CodeActionKind, CodeActionOptions,\n     CodeActionProviderCapability, CodeLensOptions, CompletionOptions,\n@@ -11,6 +12,7 @@ use lsp_types::{\n     TextDocumentSyncKind, TextDocumentSyncOptions, TypeDefinitionProviderCapability,\n     WorkDoneProgressOptions,\n };\n+use rustc_hash::FxHashSet;\n use serde_json::json;\n \n use crate::semantic_tokens;\n@@ -30,7 +32,7 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n         })),\n         hover_provider: Some(HoverProviderCapability::Simple(true)),\n         completion_provider: Some(CompletionOptions {\n-            resolve_provider: None,\n+            resolve_provider: completions_resolve_provider(client_caps),\n             trigger_characters: Some(vec![\":\".to_string(), \".\".to_string()]),\n             work_done_progress_options: WorkDoneProgressOptions { work_done_progress: None },\n         }),\n@@ -93,6 +95,40 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n     }\n }\n \n+fn completions_resolve_provider(client_caps: &ClientCapabilities) -> Option<bool> {\n+    if enabled_completions_resolve_capabilities(client_caps)?.is_empty() {\n+        log::info!(\"No `additionalTextEdits` completion resolve capability was found in the client capabilities, autoimport completion is disabled\");\n+        None\n+    } else {\n+        Some(true)\n+    }\n+}\n+\n+/// Parses client capabilities and returns all completion resolve capabilities rust-analyzer supports.\n+pub(crate) fn enabled_completions_resolve_capabilities(\n+    caps: &ClientCapabilities,\n+) -> Option<FxHashSet<CompletionResolveCapability>> {\n+    Some(\n+        caps.text_document\n+            .as_ref()?\n+            .completion\n+            .as_ref()?\n+            .completion_item\n+            .as_ref()?\n+            .resolve_support\n+            .as_ref()?\n+            .properties\n+            .iter()\n+            .filter_map(|cap_string| match cap_string.as_str() {\n+                \"additionalTextEdits\" => Some(CompletionResolveCapability::AdditionalTextEdits),\n+                \"detail\" => Some(CompletionResolveCapability::Detail),\n+                \"documentation\" => Some(CompletionResolveCapability::Documentation),\n+                _unsupported => None,\n+            })\n+            .collect(),\n+    )\n+}\n+\n fn code_action_capabilities(client_caps: &ClientCapabilities) -> CodeActionProviderCapability {\n     client_caps\n         .text_document"}, {"sha": "5243b50c801c47e71d19e942c381280e2f5ff618", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -19,7 +19,7 @@ use rustc_hash::FxHashSet;\n use serde::Deserialize;\n use vfs::AbsPathBuf;\n \n-use crate::diagnostics::DiagnosticsMapConfig;\n+use crate::{caps::enabled_completions_resolve_capabilities, diagnostics::DiagnosticsMapConfig};\n \n #[derive(Debug, Clone)]\n pub struct Config {\n@@ -182,7 +182,7 @@ impl Config {\n             },\n             completion: CompletionConfig {\n                 enable_postfix_completions: true,\n-                enable_experimental_completions: true,\n+                enable_autoimport_completions: true,\n                 add_call_parenthesis: true,\n                 add_call_argument_snippets: true,\n                 ..CompletionConfig::default()\n@@ -305,7 +305,7 @@ impl Config {\n         };\n \n         self.completion.enable_postfix_completions = data.completion_postfix_enable;\n-        self.completion.enable_experimental_completions = data.completion_enableExperimental;\n+        self.completion.enable_autoimport_completions = data.completion_autoimport_enable;\n         self.completion.add_call_parenthesis = data.completion_addCallParenthesis;\n         self.completion.add_call_argument_snippets = data.completion_addCallArgumentSnippets;\n         self.completion.merge = self.assist.insert_use.merge;\n@@ -388,6 +388,8 @@ impl Config {\n             }\n \n             self.completion.allow_snippets(false);\n+            self.completion.active_resolve_capabilities =\n+                enabled_completions_resolve_capabilities(caps).unwrap_or_default();\n             if let Some(completion) = &doc_caps.completion {\n                 if let Some(completion_item) = &completion.completion_item {\n                     if let Some(value) = completion_item.snippet_support {\n@@ -506,7 +508,7 @@ config_data! {\n         completion_addCallArgumentSnippets: bool = true,\n         completion_addCallParenthesis: bool      = true,\n         completion_postfix_enable: bool          = true,\n-        completion_enableExperimental: bool      = true,\n+        completion_autoimport_enable: bool       = true,\n \n         diagnostics_enable: bool                = true,\n         diagnostics_enableExperimental: bool    = true,"}, {"sha": "89c7fd2c7ba2048d3818c635a890f7d69fa0d775", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 117, "deletions": 4, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -8,8 +8,8 @@ use std::{\n };\n \n use ide::{\n-    FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, NavigationTarget, Query,\n-    RangeInfo, Runnable, RunnableKind, SearchScope, TextEdit,\n+    CompletionResolveCapability, FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData,\n+    NavigationTarget, Query, RangeInfo, Runnable, RunnableKind, SearchScope, TextEdit,\n };\n use itertools::Itertools;\n use lsp_server::ErrorCode;\n@@ -21,7 +21,7 @@ use lsp_types::{\n     HoverContents, Location, NumberOrString, Position, PrepareRenameResponse, Range, RenameParams,\n     SemanticTokensDeltaParams, SemanticTokensFullDeltaResult, SemanticTokensParams,\n     SemanticTokensRangeParams, SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation,\n-    SymbolTag, TextDocumentIdentifier, Url, WorkspaceEdit,\n+    SymbolTag, TextDocumentIdentifier, TextDocumentPositionParams, Url, WorkspaceEdit,\n };\n use project_model::TargetKind;\n use serde::{Deserialize, Serialize};\n@@ -35,6 +35,7 @@ use crate::{\n     from_json, from_proto,\n     global_state::{GlobalState, GlobalStateSnapshot},\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n+    lsp_utils::all_edits_are_disjoint,\n     to_proto, LspError, Result,\n };\n \n@@ -539,6 +540,7 @@ pub(crate) fn handle_completion(\n     params: lsp_types::CompletionParams,\n ) -> Result<Option<lsp_types::CompletionResponse>> {\n     let _p = profile::span(\"handle_completion\");\n+    let text_document_position = params.text_document_position.clone();\n     let position = from_proto::file_position(&snap, params.text_document_position)?;\n     let completion_triggered_after_single_colon = {\n         let mut res = false;\n@@ -568,15 +570,99 @@ pub(crate) fn handle_completion(\n     };\n     let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let line_endings = snap.file_line_endings(position.file_id);\n+\n     let items: Vec<CompletionItem> = items\n         .into_iter()\n-        .flat_map(|item| to_proto::completion_item(&line_index, line_endings, item))\n+        .flat_map(|item| {\n+            let mut new_completion_items =\n+                to_proto::completion_item(&line_index, line_endings, item.clone());\n+\n+            if snap.config.completion.resolve_additional_edits_lazily() {\n+                for new_item in &mut new_completion_items {\n+                    let _ = fill_resolve_data(&mut new_item.data, &item, &text_document_position)\n+                        .take();\n+                }\n+            }\n+\n+            new_completion_items\n+        })\n         .collect();\n \n     let completion_list = lsp_types::CompletionList { is_incomplete: true, items };\n     Ok(Some(completion_list.into()))\n }\n \n+pub(crate) fn handle_completion_resolve(\n+    snap: GlobalStateSnapshot,\n+    mut original_completion: CompletionItem,\n+) -> Result<CompletionItem> {\n+    let _p = profile::span(\"handle_completion_resolve\");\n+\n+    if !all_edits_are_disjoint(&original_completion, &[]) {\n+        return Err(LspError::new(\n+            ErrorCode::InvalidParams as i32,\n+            \"Received a completion with overlapping edits, this is not LSP-compliant\".into(),\n+        )\n+        .into());\n+    }\n+\n+    // FIXME resolve the other capabilities also?\n+    if !snap\n+        .config\n+        .completion\n+        .active_resolve_capabilities\n+        .contains(&CompletionResolveCapability::AdditionalTextEdits)\n+    {\n+        return Ok(original_completion);\n+    }\n+\n+    let resolve_data = match original_completion\n+        .data\n+        .take()\n+        .map(|data| serde_json::from_value::<CompletionResolveData>(data))\n+        .transpose()?\n+    {\n+        Some(data) => data,\n+        None => return Ok(original_completion),\n+    };\n+\n+    let file_id = from_proto::file_id(&snap, &resolve_data.position.text_document.uri)?;\n+    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_endings = snap.file_line_endings(file_id);\n+    let offset = from_proto::offset(&line_index, resolve_data.position.position);\n+\n+    let additional_edits = snap\n+        .analysis\n+        .resolve_completion_edits(\n+            &snap.config.completion,\n+            FilePosition { file_id, offset },\n+            &resolve_data.full_import_path,\n+            &resolve_data.imported_name,\n+        )?\n+        .into_iter()\n+        .flat_map(|edit| {\n+            edit.into_iter().map(|indel| to_proto::text_edit(&line_index, line_endings, indel))\n+        })\n+        .collect_vec();\n+\n+    if !all_edits_are_disjoint(&original_completion, &additional_edits) {\n+        return Err(LspError::new(\n+            ErrorCode::InternalError as i32,\n+            \"Import edit overlaps with the original completion edits, this is not LSP-compliant\"\n+                .into(),\n+        )\n+        .into());\n+    }\n+\n+    if let Some(original_additional_edits) = original_completion.additional_text_edits.as_mut() {\n+        original_additional_edits.extend(additional_edits.into_iter())\n+    } else {\n+        original_completion.additional_text_edits = Some(additional_edits);\n+    }\n+\n+    Ok(original_completion)\n+}\n+\n pub(crate) fn handle_folding_range(\n     snap: GlobalStateSnapshot,\n     params: FoldingRangeParams,\n@@ -1534,3 +1620,30 @@ fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&CargoTargetSpec>)\n         _ => false,\n     }\n }\n+\n+#[derive(Debug, Serialize, Deserialize)]\n+struct CompletionResolveData {\n+    position: lsp_types::TextDocumentPositionParams,\n+    full_import_path: String,\n+    imported_name: String,\n+}\n+\n+fn fill_resolve_data(\n+    resolve_data: &mut Option<serde_json::Value>,\n+    item: &ide::CompletionItem,\n+    position: &TextDocumentPositionParams,\n+) -> Option<()> {\n+    let import_edit = item.import_to_add()?;\n+    let full_import_path = import_edit.import_path.to_string();\n+    let imported_name = import_edit.import_path.segments.clone().pop()?.to_string();\n+\n+    *resolve_data = Some(\n+        to_value(CompletionResolveData {\n+            position: position.to_owned(),\n+            full_import_path,\n+            imported_name,\n+        })\n+        .unwrap(),\n+    );\n+    Some(())\n+}"}, {"sha": "60c12e4e2eacfa9cb5a0cbc1113dd4ff7fc72264", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 163, "deletions": 1, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -129,9 +129,40 @@ pub(crate) fn apply_document_changes(\n     }\n }\n \n+/// Checks that the edits inside the completion and the additional edits do not overlap.\n+/// LSP explicitly forbits the additional edits to overlap both with the main edit and themselves.\n+pub(crate) fn all_edits_are_disjoint(\n+    completion: &lsp_types::CompletionItem,\n+    additional_edits: &[lsp_types::TextEdit],\n+) -> bool {\n+    let mut edit_ranges = Vec::new();\n+    match completion.text_edit.as_ref() {\n+        Some(lsp_types::CompletionTextEdit::Edit(edit)) => {\n+            edit_ranges.push(edit.range);\n+        }\n+        Some(lsp_types::CompletionTextEdit::InsertAndReplace(edit)) => {\n+            edit_ranges.push(edit.insert);\n+            edit_ranges.push(edit.replace);\n+        }\n+        None => {}\n+    }\n+    if let Some(additional_changes) = completion.additional_text_edits.as_ref() {\n+        edit_ranges.extend(additional_changes.iter().map(|edit| edit.range));\n+    };\n+    edit_ranges.extend(additional_edits.iter().map(|edit| edit.range));\n+    edit_ranges.sort_by_key(|range| (range.start, range.end));\n+    edit_ranges\n+        .iter()\n+        .zip(edit_ranges.iter().skip(1))\n+        .all(|(previous, next)| previous.end <= next.start)\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use lsp_types::{Position, Range, TextDocumentContentChangeEvent};\n+    use lsp_types::{\n+        CompletionItem, CompletionTextEdit, InsertReplaceEdit, Position, Range,\n+        TextDocumentContentChangeEvent,\n+    };\n \n     use super::*;\n \n@@ -197,4 +228,135 @@ mod tests {\n         apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n+\n+    #[test]\n+    fn empty_completion_disjoint_tests() {\n+        let empty_completion =\n+            CompletionItem::new_simple(\"label\".to_string(), \"detail\".to_string());\n+\n+        let disjoint_edit_1 = lsp_types::TextEdit::new(\n+            Range::new(Position::new(2, 2), Position::new(3, 3)),\n+            \"new_text\".to_string(),\n+        );\n+        let disjoint_edit_2 = lsp_types::TextEdit::new(\n+            Range::new(Position::new(3, 3), Position::new(4, 4)),\n+            \"new_text\".to_string(),\n+        );\n+\n+        let joint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(5, 5)),\n+            \"new_text\".to_string(),\n+        );\n+\n+        assert!(\n+            all_edits_are_disjoint(&empty_completion, &[]),\n+            \"Empty completion has all its edits disjoint\"\n+        );\n+        assert!(\n+            all_edits_are_disjoint(\n+                &empty_completion,\n+                &[disjoint_edit_1.clone(), disjoint_edit_2.clone()]\n+            ),\n+            \"Empty completion is disjoint to whatever disjoint extra edits added\"\n+        );\n+\n+        assert!(\n+            !all_edits_are_disjoint(\n+                &empty_completion,\n+                &[disjoint_edit_1, disjoint_edit_2, joint_edit]\n+            ),\n+            \"Empty completion does not prevent joint extra edits from failing the validation\"\n+        );\n+    }\n+\n+    #[test]\n+    fn completion_with_joint_edits_disjoint_tests() {\n+        let disjoint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(2, 2)),\n+            \"new_text\".to_string(),\n+        );\n+        let disjoint_edit_2 = lsp_types::TextEdit::new(\n+            Range::new(Position::new(2, 2), Position::new(3, 3)),\n+            \"new_text\".to_string(),\n+        );\n+        let joint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(5, 5)),\n+            \"new_text\".to_string(),\n+        );\n+\n+        let mut completion_with_joint_edits =\n+            CompletionItem::new_simple(\"label\".to_string(), \"detail\".to_string());\n+        completion_with_joint_edits.additional_text_edits =\n+            Some(vec![disjoint_edit.clone(), joint_edit.clone()]);\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_joint_edits, &[]),\n+            \"Completion with disjoint edits fails the validaton even with empty extra edits\"\n+        );\n+\n+        completion_with_joint_edits.text_edit =\n+            Some(CompletionTextEdit::Edit(disjoint_edit.clone()));\n+        completion_with_joint_edits.additional_text_edits = Some(vec![joint_edit.clone()]);\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_joint_edits, &[]),\n+            \"Completion with disjoint edits fails the validaton even with empty extra edits\"\n+        );\n+\n+        completion_with_joint_edits.text_edit =\n+            Some(CompletionTextEdit::InsertAndReplace(InsertReplaceEdit {\n+                new_text: \"new_text\".to_string(),\n+                insert: disjoint_edit.range,\n+                replace: joint_edit.range,\n+            }));\n+        completion_with_joint_edits.additional_text_edits = None;\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_joint_edits, &[]),\n+            \"Completion with disjoint edits fails the validaton even with empty extra edits\"\n+        );\n+\n+        completion_with_joint_edits.text_edit =\n+            Some(CompletionTextEdit::InsertAndReplace(InsertReplaceEdit {\n+                new_text: \"new_text\".to_string(),\n+                insert: disjoint_edit.range,\n+                replace: disjoint_edit_2.range,\n+            }));\n+        completion_with_joint_edits.additional_text_edits = Some(vec![joint_edit]);\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_joint_edits, &[]),\n+            \"Completion with disjoint edits fails the validaton even with empty extra edits\"\n+        );\n+    }\n+\n+    #[test]\n+    fn completion_with_disjoint_edits_disjoint_tests() {\n+        let disjoint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(2, 2)),\n+            \"new_text\".to_string(),\n+        );\n+        let disjoint_edit_2 = lsp_types::TextEdit::new(\n+            Range::new(Position::new(2, 2), Position::new(3, 3)),\n+            \"new_text\".to_string(),\n+        );\n+        let joint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(5, 5)),\n+            \"new_text\".to_string(),\n+        );\n+\n+        let mut completion_with_disjoint_edits =\n+            CompletionItem::new_simple(\"label\".to_string(), \"detail\".to_string());\n+        completion_with_disjoint_edits.text_edit = Some(CompletionTextEdit::Edit(disjoint_edit));\n+        let completion_with_disjoint_edits = completion_with_disjoint_edits;\n+\n+        assert!(\n+            all_edits_are_disjoint(&completion_with_disjoint_edits, &[]),\n+            \"Completion with disjoint edits is valid\"\n+        );\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_disjoint_edits, &[joint_edit.clone()]),\n+            \"Completion with disjoint edits and joint extra edit is invalid\"\n+        );\n+        assert!(\n+            all_edits_are_disjoint(&completion_with_disjoint_edits, &[disjoint_edit_2.clone()]),\n+            \"Completion with disjoint edits and joint extra edit is valid\"\n+        );\n+    }\n }"}, {"sha": "95be2ebd397e81aace24ca7da9ef316e527f74f8", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -454,6 +454,7 @@ impl GlobalState {\n             .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)\n             .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)\n             .on::<lsp_types::request::Completion>(handlers::handle_completion)\n+            .on::<lsp_types::request::ResolveCompletionItem>(handlers::handle_completion_resolve)\n             .on::<lsp_types::request::CodeLensRequest>(handlers::handle_code_lens)\n             .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)\n             .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)"}, {"sha": "dbde37005c92aae22d848b26f6e6e20c3be41853", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -460,10 +460,13 @@\n                     \"default\": true,\n                     \"markdownDescription\": \"Whether to show postfix snippets like `dbg`, `if`, `not`, etc.\"\n                 },\n-                \"rust-analyzer.completion.enableExperimental\": {\n+                \"rust-analyzer.completion.autoimport.enable\": {\n                     \"type\": \"boolean\",\n                     \"default\": true,\n-                    \"markdownDescription\": \"Display additional completions with potential false positives and performance issues\"\n+                    \"markdownDescription\": [\n+                        \"Toggles the additional completions that automatically add imports when completed.\",\n+                        \"Note that your client have to specify the `additionalTextEdits` LSP client capability to truly have this feature enabled\"\n+                    ]\n                 },\n                 \"rust-analyzer.callInfo.full\": {\n                     \"type\": \"boolean\","}]}