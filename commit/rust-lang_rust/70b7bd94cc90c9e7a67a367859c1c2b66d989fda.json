{"sha": "70b7bd94cc90c9e7a67a367859c1c2b66d989fda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYjdiZDk0Y2M5MGM5ZTdhNjdhMzY3ODU5YzFjMmI2NmQ5ODlmZGE=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-01-04T03:07:32Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-01-04T03:07:32Z"}, "message": "Fix build after rebase", "tree": {"sha": "5f3b2c29ab4514ea8f04953c15962dbebb1f1d13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f3b2c29ab4514ea8f04953c15962dbebb1f1d13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70b7bd94cc90c9e7a67a367859c1c2b66d989fda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70b7bd94cc90c9e7a67a367859c1c2b66d989fda", "html_url": "https://github.com/rust-lang/rust/commit/70b7bd94cc90c9e7a67a367859c1c2b66d989fda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70b7bd94cc90c9e7a67a367859c1c2b66d989fda/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0cd145c1f6c29b2ef1f08b666394eb28bef0de4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0cd145c1f6c29b2ef1f08b666394eb28bef0de4", "html_url": "https://github.com/rust-lang/rust/commit/c0cd145c1f6c29b2ef1f08b666394eb28bef0de4"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "f4b3646fce02c02840c0bc1061961273b0c67653", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/70b7bd94cc90c9e7a67a367859c1c2b66d989fda/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b7bd94cc90c9e7a67a367859c1c2b66d989fda/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=70b7bd94cc90c9e7a67a367859c1c2b66d989fda", "patch": "@@ -29,8 +29,6 @@ use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n \n-use syntax::ast::DUMMY_NODE_ID;\n-use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n@@ -272,8 +270,14 @@ impl<'tcx> Witness<'tcx> {\n         ty: Ty<'tcx>)\n         -> Self\n     {\n-        let arity = constructor_arity(cx, ctor, ty);\n-        self.0.extend(repeat(cx.wild_pattern).take(arity).cloned());\n+        let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n+        self.0.extend(sub_pattern_tys.into_iter().map(|ty| {\n+            Pattern {\n+                ty: ty,\n+                span: DUMMY_SP,\n+                kind: box PatternKind::Wild,\n+            }\n+        }));\n         self.apply_constructor(cx, ctor, ty)\n     }\n \n@@ -313,10 +317,11 @@ impl<'tcx> Witness<'tcx> {\n                         }\n                     }).collect();\n \n-                    if let ty::TyAdt(adt, _) = ty.sty {\n+                    if let ty::TyAdt(adt, substs) = ty.sty {\n                         if adt.variants.len() > 1 {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n+                                substs: substs,\n                                 variant_index: ctor.variant_index_for_adt(adt),\n                                 subpatterns: pats\n                             }\n@@ -604,11 +609,11 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         // All constructors are unused. Add wild patterns\n                         // rather than each individual constructor\n                         pats.into_iter().map(|mut witness| {\n-                            witness.0.push(P(hir::Pat {\n-                                id: DUMMY_NODE_ID,\n-                                node: PatKind::Wild,\n+                            witness.0.push(Pattern {\n+                                ty: pcx.ty,\n                                 span: DUMMY_SP,\n-                            }));\n+                                kind: box PatternKind::Wild,\n+                            });\n                             witness\n                         }).collect()\n                     } else {\n@@ -740,7 +745,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n         },\n         ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n         ty::TyAdt(adt, substs) => {\n-            ctor.variant_for_adt(adt).fields.iter().map(|field| {\n+            adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n                 field.ty(cx.tcx, substs)\n             }).collect()\n         }"}, {"sha": "2949cf0d535bfd286bca8e4554dc7f243d7417cc", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70b7bd94cc90c9e7a67a367859c1c2b66d989fda/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b7bd94cc90c9e7a67a367859c1c2b66d989fda/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=70b7bd94cc90c9e7a67a367859c1c2b66d989fda", "patch": "@@ -358,7 +358,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n-                vec![cx.wild_pattern]\n+                vec![&wild_pattern]\n             } else {\n                 pats.iter().map(|w| w.single_pattern()).collect()\n             };"}, {"sha": "42394f4745f6611067c0793bc2b78a6b7776e35e", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/70b7bd94cc90c9e7a67a367859c1c2b66d989fda/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b7bd94cc90c9e7a67a367859c1c2b66d989fda/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=70b7bd94cc90c9e7a67a367859c1c2b66d989fda", "patch": "@@ -393,8 +393,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n                 let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n-                let adt_def = match pat_ty.sty {\n+                let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n@@ -413,8 +412,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n                 let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n-                let adt_def = match pat_ty.sty {\n+                let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n                         span_bug!(\n@@ -537,11 +535,14 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     {\n         match def {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                let (adt_def, substs) = match ty.sty {\n-                    TypeVariants::TyAdt(adt_def, substs) => (adt_def, substs),\n-                    _ => bug!(\"inappropriate type for def\"),\n-                };\n+                let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n+                let adt_def = self.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n+                    let substs = match ty.sty {\n+                        TypeVariants::TyAdt(_, substs) => substs,\n+                        TypeVariants::TyFnDef(_, substs, _) => substs,\n+                        _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n+                    };\n                     PatternKind::Variant {\n                         adt_def: adt_def,\n                         substs: substs,\n@@ -568,6 +569,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                   pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n+        let ty = self.tcx.tables().node_id_to_type(id);\n         let def = self.tcx.tables().qpath_def(qpath, id);\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n@@ -584,12 +586,12 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            _ => self.lower_variant_or_leaf(def, ty, vec![])\n+            _ => self.lower_variant_or_leaf(def, ty, vec![]),\n         };\n \n         Pattern {\n             span: span,\n-            ty: self.tcx.tables().node_id_to_type(id),\n+            ty: ty,\n             kind: Box::new(kind),\n         }\n     }\n@@ -657,6 +659,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                     hir::ExprPath(ref qpath) => qpath,\n                     _ => bug!()\n                 };\n+                let ty = self.tcx.tables().node_id_to_type(callee.id);\n                 let def = self.tcx.tables().qpath_def(qpath, callee.id);\n                 match def {\n                     Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n@@ -667,7 +670,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                                 pattern: self.lower_const_expr(expr, pat_id, span)\n                             }\n                         }).collect();\n-                        self.lower_variant_or_leaf(def, subpatterns)\n+                        self.lower_variant_or_leaf(def, ty, subpatterns)\n                     }\n                 }\n             }\n@@ -702,7 +705,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(def, subpatterns)\n+                self.lower_variant_or_leaf(def, pat_ty, subpatterns)\n             }\n \n             hir::ExprArray(ref exprs) => {"}]}