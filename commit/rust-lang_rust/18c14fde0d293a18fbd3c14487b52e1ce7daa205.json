{"sha": "18c14fde0d293a18fbd3c14487b52e1ce7daa205", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YzE0ZmRlMGQyOTNhMThmYmQzYzE0NDg3YjUyZTFjZTdkYWEyMDU=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-29T19:19:43Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-04T12:27:56Z"}, "message": "Misc cleanup\n\n- Preserve suffixes when displaying\n- Rename test file to match `intra-link*`\n- Remove unnecessary .clone()s\n- Improve comments and naming\n- Fix more bugs and add tests\n- Escape intra-doc link example in public documentation", "tree": {"sha": "43dc28a0a45aaf49d2a8b538ac2618921e78beb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43dc28a0a45aaf49d2a8b538ac2618921e78beb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18c14fde0d293a18fbd3c14487b52e1ce7daa205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18c14fde0d293a18fbd3c14487b52e1ce7daa205", "html_url": "https://github.com/rust-lang/rust/commit/18c14fde0d293a18fbd3c14487b52e1ce7daa205", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18c14fde0d293a18fbd3c14487b52e1ce7daa205/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d7e797514ed1ea60a761d272c1ba8426bc31739", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7e797514ed1ea60a761d272c1ba8426bc31739", "html_url": "https://github.com/rust-lang/rust/commit/9d7e797514ed1ea60a761d272c1ba8426bc31739"}], "stats": {"total": 177, "additions": 114, "deletions": 63}, "files": [{"sha": "223fda84871e9725392f8c3c1717a34c0d3db1a9", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18c14fde0d293a18fbd3c14487b52e1ce7daa205/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14fde0d293a18fbd3c14487b52e1ce7daa205/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=18c14fde0d293a18fbd3c14487b52e1ce7daa205", "patch": "@@ -439,15 +439,17 @@ pub struct ItemLink {\n     /// The link text displayed in the HTML.\n     ///\n     /// This may not be the same as `link` if there was a disambiguator\n-    /// in an intra-doc link (e.g. [`fn@f`])\n+    /// in an intra-doc link (e.g. \\[`fn@f`\\])\n     pub(crate) link_text: String,\n     pub(crate) did: Option<DefId>,\n     /// The url fragment to append to the link\n     pub(crate) fragment: Option<String>,\n }\n \n pub struct RenderedLink {\n-    /// The text the link was original written as\n+    /// The text the link was original written as.\n+    ///\n+    /// This could potentially include disambiguators and backticks.\n     pub(crate) original_text: String,\n     /// The text to display in the HTML\n     pub(crate) new_text: String,"}, {"sha": "58d75c0747295a003d8ef75b6a50918477c38233", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/18c14fde0d293a18fbd3c14487b52e1ce7daa205/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14fde0d293a18fbd3c14487b52e1ce7daa205/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=18c14fde0d293a18fbd3c14487b52e1ce7daa205", "patch": "@@ -338,83 +338,102 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n }\n \n /// Make headings links with anchor IDs and build up TOC.\n-struct LinkReplacer<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+struct LinkReplacer<'a, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n     links: &'a [RenderedLink],\n-    shortcut_link: Option<&'b RenderedLink>,\n+    shortcut_link: Option<&'a RenderedLink>,\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, '_, I> {\n+impl<'a, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, I> {\n     fn new(iter: I, links: &'a [RenderedLink]) -> Self {\n         LinkReplacer { inner: iter, links, shortcut_link: None }\n     }\n }\n \n-impl<'a: 'b, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I> {\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n+        use pulldown_cmark::LinkType;\n+\n         let mut event = self.inner.next();\n \n-        // Remove disambiguators from shortcut links (`[fn@f]`)\n+        // Replace intra-doc links and remove disambiguators from shortcut links (`[fn@f]`).\n         match &mut event {\n+            // This is a shortcut link that was resolved by the broken_link_callback: `[fn@f]`\n+            // Remove any disambiguator.\n             Some(Event::Start(Tag::Link(\n-                pulldown_cmark::LinkType::ShortcutUnknown,\n+                // [fn@f] or [fn@f][]\n+                LinkType::ShortcutUnknown | LinkType::CollapsedUnknown,\n                 dest,\n                 title,\n             ))) => {\n                 debug!(\"saw start of shortcut link to {} with title {}\", dest, title);\n-                let link = if let Some(link) =\n-                    self.links.iter().find(|&link| *link.original_text == **dest)\n-                {\n-                    // Not sure why this is necessary - maybe the broken_link_callback doesn't always work?\n-                    *dest = CowStr::Borrowed(link.href.as_ref());\n-                    Some(link)\n-                } else {\n-                    self.links.iter().find(|&link| *link.href == **dest)\n-                };\n+                // If this is a shortcut link, it was resolved by the broken_link_callback.\n+                // So the URL will already be updated properly.\n+                let link = self.links.iter().find(|&link| *link.href == **dest);\n+                // Since this is an external iterator, we can't replace the inner text just yet.\n+                // Store that we saw a link so we know to replace it later.\n                 if let Some(link) = link {\n                     trace!(\"it matched\");\n                     assert!(self.shortcut_link.is_none(), \"shortcut links cannot be nested\");\n                     self.shortcut_link = Some(link);\n                 }\n             }\n-            Some(Event::End(Tag::Link(pulldown_cmark::LinkType::ShortcutUnknown, dest, _))) => {\n+            // Now that we're done with the shortcut link, don't replace any more text.\n+            Some(Event::End(Tag::Link(\n+                LinkType::ShortcutUnknown | LinkType::CollapsedUnknown,\n+                dest,\n+                _,\n+            ))) => {\n                 debug!(\"saw end of shortcut link to {}\", dest);\n-                if let Some(_link) = self.links.iter().find(|&link| *link.href == **dest) {\n+                if self.links.iter().find(|&link| *link.href == **dest).is_some() {\n                     assert!(self.shortcut_link.is_some(), \"saw closing link without opening tag\");\n                     self.shortcut_link = None;\n                 }\n             }\n-            // Handle backticks in inline code blocks\n+            // Handle backticks in inline code blocks, but only if we're in the middle of a shortcut link.\n+            // [`fn@f`]\n             Some(Event::Code(text)) => {\n                 trace!(\"saw code {}\", text);\n                 if let Some(link) = self.shortcut_link {\n                     trace!(\"original text was {}\", link.original_text);\n+                    // NOTE: this only replaces if the code block is the *entire* text.\n+                    // If only part of the link has code highlighting, the disambiguator will not be removed.\n+                    // e.g. [fn@`f`]\n+                    // This is a limitation from `collect_intra_doc_links`: it passes a full link,\n+                    // and does not distinguish at all between code blocks.\n+                    // So we could never be sure we weren't replacing too much:\n+                    // [fn@my_`f`unc] is treated the same as [my_func()] in that pass.\n+                    //\n+                    // NOTE: &[1..len() - 1] is to strip the backticks\n                     if **text == link.original_text[1..link.original_text.len() - 1] {\n                         debug!(\"replacing {} with {}\", text, link.new_text);\n-                        *text = link.new_text.clone().into();\n+                        *text = CowStr::Borrowed(&link.new_text);\n                     }\n                 }\n             }\n-            // Replace plain text in links\n+            // Replace plain text in links, but only in the middle of a shortcut link.\n+            // [fn@f]\n             Some(Event::Text(text)) => {\n                 trace!(\"saw text {}\", text);\n                 if let Some(link) = self.shortcut_link {\n                     trace!(\"original text was {}\", link.original_text);\n+                    // NOTE: same limitations as `Event::Code`\n                     if **text == *link.original_text {\n                         debug!(\"replacing {} with {}\", text, link.new_text);\n-                        *text = link.new_text.clone().into();\n+                        *text = CowStr::Borrowed(&link.new_text);\n                     }\n                 }\n             }\n+            // If this is a link, but not a shortcut link,\n+            // replace the URL, since the broken_link_callback was not called.\n             Some(Event::Start(Tag::Link(_, dest, _))) => {\n                 if let Some(link) = self.links.iter().find(|&link| *link.original_text == **dest) {\n-                    // Not sure why this is necessary - maybe the broken_link_callback doesn't always work?\n                     *dest = CowStr::Borrowed(link.href.as_ref());\n                 }\n             }\n-            // Anything else couldn't have been a valid Rust path\n+            // Anything else couldn't have been a valid Rust path, so no need to replace the text.\n             _ => {}\n         }\n "}, {"sha": "9a705293376a09284b352349395c9d1135ba4b59", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18c14fde0d293a18fbd3c14487b52e1ce7daa205/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14fde0d293a18fbd3c14487b52e1ce7daa205/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=18c14fde0d293a18fbd3c14487b52e1ce7daa205", "patch": "@@ -717,11 +717,11 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     continue;\n                 }\n \n-                // We stripped ` characters for `path_str`.\n-                // The original link might have had multiple pairs of backticks,\n-                // but we don't handle this case.\n-                //link_text = if had_backticks { format!(\"`{}`\", path_str) } else { path_str.to_owned() };\n-                link_text = path_str.to_owned();\n+                // We stripped `()` and `!` when parsing the disambiguator.\n+                // Add them back to be displayed, but not prefix disambiguators.\n+                link_text = disambiguator\n+                    .map(|d| d.display_for(path_str))\n+                    .unwrap_or_else(|| path_str.to_owned());\n \n                 // In order to correctly resolve intra-doc-links we need to\n                 // pick a base AST node to work from.  If the documentation for\n@@ -1000,6 +1000,18 @@ enum Disambiguator {\n }\n \n impl Disambiguator {\n+    /// The text that should be displayed when the path is rendered as HTML.\n+    ///\n+    /// NOTE: `path` is not the original link given by the user, but a name suitable for passing to `resolve`.\n+    fn display_for(&self, path: &str) -> String {\n+        match self {\n+            // FIXME: this will have different output if the user had `m!()` originally.\n+            Self::Kind(DefKind::Macro(MacroKind::Bang)) => format!(\"{}!\", path),\n+            Self::Kind(DefKind::Fn) => format!(\"{}()\", path),\n+            _ => path.to_owned(),\n+        }\n+    }\n+\n     /// (disambiguator, path_str)\n     fn from_str(link: &str) -> Result<(Self, &str), ()> {\n         use Disambiguator::{Kind, Namespace as NS, Primitive};"}, {"sha": "74411870e9f8a50681320800b912ae1b03dbcbb5", "filename": "src/test/rustdoc/disambiguator_removed.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9d7e797514ed1ea60a761d272c1ba8426bc31739/src%2Ftest%2Frustdoc%2Fdisambiguator_removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7e797514ed1ea60a761d272c1ba8426bc31739/src%2Ftest%2Frustdoc%2Fdisambiguator_removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdisambiguator_removed.rs?ref=9d7e797514ed1ea60a761d272c1ba8426bc31739", "patch": "@@ -1,33 +0,0 @@\n-#![deny(intra_doc_link_resolution_failure)]\n-// first try backticks\n-/// Trait: [`trait@Name`], fn: [`fn@Name`], [`Name`][`macro@Name`]\n-// @has disambiguator_removed/struct.AtDisambiguator.html\n-// @has - '//a[@href=\"../disambiguator_removed/trait.Name.html\"][code]' \"Name\"\n-// @has - '//a[@href=\"../disambiguator_removed/fn.Name.html\"][code]' \"Name\"\n-// @has - '//a[@href=\"../disambiguator_removed/macro.Name.html\"][code]' \"Name\"\n-pub struct AtDisambiguator;\n-\n-/// fn: [`Name()`], macro: [`Name!`]\n-// @has disambiguator_removed/struct.SymbolDisambiguator.html\n-// @has - '//a[@href=\"../disambiguator_removed/fn.Name.html\"][code]' \"Name()\"\n-// @has - '//a[@href=\"../disambiguator_removed/macro.Name.html\"][code]' \"Name!\"\n-pub struct SymbolDisambiguator;\n-\n-// Now make sure that backticks aren't added if they weren't already there\n-/// [fn@Name]\n-// @has disambiguator_removed/trait.Name.html\n-// @has - '//a[@href=\"../disambiguator_removed/fn.Name.html\"]' \"Name\"\n-// @!has - '//a[@href=\"../disambiguator_removed/fn.Name.html\"][code]' \"Name\"\n-\n-// FIXME: this will turn !() into ! alone\n-/// [Name!()]\n-// @has - '//a[@href=\"../disambiguator_removed/macro.Name.html\"]' \"Name!\"\n-pub trait Name {}\n-\n-#[allow(non_snake_case)]\n-pub fn Name() {}\n-\n-#[macro_export]\n-macro_rules! Name {\n-    () => ()\n-}"}, {"sha": "26d05b484b919b73ec6b0729eecfae0038b0d815", "filename": "src/test/rustdoc/intra-link-disambiguators-removed.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/18c14fde0d293a18fbd3c14487b52e1ce7daa205/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14fde0d293a18fbd3c14487b52e1ce7daa205/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs?ref=18c14fde0d293a18fbd3c14487b52e1ce7daa205", "patch": "@@ -0,0 +1,51 @@\n+// ignore-tidy-linelength\n+#![deny(intra_doc_link_resolution_failure)]\n+// first try backticks\n+/// Trait: [`trait@Name`], fn: [`fn@Name`], [`Name`][`macro@Name`]\n+// @has intra_link_disambiguators_removed/struct.AtDisambiguator.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"][code]' \"Name\"\n+pub struct AtDisambiguator;\n+\n+/// fn: [`Name()`], macro: [`Name!`]\n+// @has intra_link_disambiguators_removed/struct.SymbolDisambiguator.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name()\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"][code]' \"Name!\"\n+pub struct SymbolDisambiguator;\n+\n+// Now make sure that backticks aren't added if they weren't already there\n+/// [fn@Name]\n+// @has intra_link_disambiguators_removed/trait.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"]' \"Name\"\n+// @!has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n+\n+// FIXME: this will turn !() into ! alone\n+/// [Name!()]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"]' \"Name!\"\n+pub trait Name {}\n+\n+#[allow(non_snake_case)]\n+\n+// Try collapsed reference links\n+/// [macro@Name][]\n+// @has intra_link_disambiguators_removed/fn.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"]' \"Name\"\n+\n+// Try links that have the same text as a generated URL\n+/// Weird URL aligned [../intra_link_disambiguators_removed/macro.Name.html][trait@Name]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"]' \"../intra_link_disambiguators_removed/macro.Name.html\"\n+pub fn Name() {}\n+\n+#[macro_export]\n+// Rustdoc doesn't currently handle links that have weird interspersing of inline code blocks.\n+/// [fn@Na`m`e]\n+// @has intra_link_disambiguators_removed/macro.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"]' \"fn@Name\"\n+\n+// It also doesn't handle any case where the code block isn't the whole link text:\n+/// [trait@`Name`]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"]' \"trait@Name\"\n+macro_rules! Name {\n+    () => ()\n+}"}]}