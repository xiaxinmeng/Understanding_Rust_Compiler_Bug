{"sha": "33ea1e330ccdda85a1501078c0b997fd27ce1e72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZWExZTMzMGNjZGRhODVhMTUwMTA3OGMwYjk5N2ZkMjdjZTFlNzI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T02:14:27Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T02:15:04Z"}, "message": "Rollup merge of #33943 - jseyfried:libsyntax_cleanup, r=nrc\n\nMiscellaneous low priority cleanup in `libsyntax`.", "tree": {"sha": "dae80adb693a2c470cb2e44106569f408221d8e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dae80adb693a2c470cb2e44106569f408221d8e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33ea1e330ccdda85a1501078c0b997fd27ce1e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33ea1e330ccdda85a1501078c0b997fd27ce1e72", "html_url": "https://github.com/rust-lang/rust/commit/33ea1e330ccdda85a1501078c0b997fd27ce1e72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33ea1e330ccdda85a1501078c0b997fd27ce1e72/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82a15a6a0af724e71004c735f8a99ec5f2a03920", "url": "https://api.github.com/repos/rust-lang/rust/commits/82a15a6a0af724e71004c735f8a99ec5f2a03920", "html_url": "https://github.com/rust-lang/rust/commit/82a15a6a0af724e71004c735f8a99ec5f2a03920"}, {"sha": "0644aba0b3f5e8c8e71f4fcfdf8841ba62034565", "url": "https://api.github.com/repos/rust-lang/rust/commits/0644aba0b3f5e8c8e71f4fcfdf8841ba62034565", "html_url": "https://github.com/rust-lang/rust/commit/0644aba0b3f5e8c8e71f4fcfdf8841ba62034565"}], "stats": {"total": 634, "additions": 269, "deletions": 365}, "files": [{"sha": "a1c04dfcab5e66be6616e59a307ff81eaa5fbff4", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -95,7 +95,7 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for CheckAttrVisitor<'a> {\n+impl<'a> Visitor for CheckAttrVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         let target = Target::from_item(item);\n         for attr in &item.attrs {"}, {"sha": "2b2313b217ceebc04c5658067c9903c982ebb776", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -138,8 +138,8 @@ impl<'a> LoweringContext<'a> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n-        impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n-            fn visit_item(&mut self, item: &'lcx Item) {\n+        impl<'lcx, 'interner> Visitor for ItemLowerer<'lcx, 'interner> {\n+            fn visit_item(&mut self, item: &Item) {\n                 self.items.insert(item.id, self.lctx.lower_item(item));\n                 visit::walk_item(self, item);\n             }"}, {"sha": "ccb3e154d9204906146d775d032b8a088cb45896", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -98,7 +98,7 @@ impl<'ast> DefCollector<'ast> {\n         self.parent_def = parent;\n     }\n \n-    fn visit_ast_const_integer(&mut self, expr: &'ast Expr) {\n+    fn visit_ast_const_integer(&mut self, expr: &Expr) {\n         // Find the node which will be used after lowering.\n         if let ExprKind::Paren(ref inner) = expr.node {\n             return self.visit_ast_const_integer(inner);\n@@ -124,8 +124,8 @@ impl<'ast> DefCollector<'ast> {\n     }\n }\n \n-impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n-    fn visit_item(&mut self, i: &'ast Item) {\n+impl<'ast> visit::Visitor for DefCollector<'ast> {\n+    fn visit_item(&mut self, i: &Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n         // Pick the def data. This need not be unique, but the more\n@@ -183,23 +183,23 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.ident.name));\n \n         self.with_parent(def, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n-    fn visit_generics(&mut self, generics: &'ast Generics) {\n+    fn visit_generics(&mut self, generics: &Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name));\n         }\n \n         visit::walk_generics(self, generics);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.name),\n@@ -217,7 +217,7 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name),\n@@ -235,7 +235,7 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         });\n     }\n \n-    fn visit_pat(&mut self, pat: &'ast Pat) {\n+    fn visit_pat(&mut self, pat: &Pat) {\n         let parent_def = self.parent_def;\n \n         if let PatKind::Ident(_, id, _) = pat.node {\n@@ -247,7 +247,7 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_expr(&mut self, expr: &'ast Expr) {\n+    fn visit_expr(&mut self, expr: &Expr) {\n         let parent_def = self.parent_def;\n \n         if let ExprKind::Repeat(_, ref count) = expr.node {\n@@ -263,18 +263,18 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_ty(&mut self, ty: &'ast Ty) {\n+    fn visit_ty(&mut self, ty: &Ty) {\n         if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n             self.visit_ast_const_integer(length);\n         }\n         visit::walk_ty(self, ty);\n     }\n \n-    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name));\n     }\n }"}, {"sha": "1113d046e43bc931bf75a4fa722f4c896a82bc29", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -905,7 +905,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n+impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n     fn visit_item(&mut self, it: &ast::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, early_passes, it);\n@@ -939,8 +939,8 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         ast_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: ast_visit::FnKind<'v>, decl: &'v ast::FnDecl,\n-                body: &'v ast::Block, span: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: ast_visit::FnKind, decl: &ast::FnDecl,\n+                body: &ast::Block, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, early_passes, fk, decl, body, span, id);\n         ast_visit::walk_fn(self, fk, decl, body, span);\n         run_lints!(self, check_fn_post, early_passes, fk, decl, body, span, id);"}, {"sha": "2ccac91ae910545de2e0d3f0c822ab6c942623bb", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -59,8 +59,8 @@ pub struct CrateReader<'a> {\n     local_crate_name: String,\n }\n \n-impl<'a, 'ast> visit::Visitor<'ast> for LocalCrateReader<'a> {\n-    fn visit_item(&mut self, a: &'ast ast::Item) {\n+impl<'a> visit::Visitor for LocalCrateReader<'a> {\n+    fn visit_item(&mut self, a: &ast::Item) {\n         self.process_item(a);\n         visit::walk_item(self, a);\n     }"}, {"sha": "db1fb2b791aa6b7f226cda9b86093c70f18edf53", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -57,7 +57,7 @@ impl<'a> AstValidator<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for AstValidator<'a> {\n+impl<'a> Visitor for AstValidator<'a> {\n     fn visit_lifetime(&mut self, lt: &Lifetime) {\n         if lt.name.as_str() == \"'_\" {\n             self.session.add_lint("}, {"sha": "314513a974ecdb826b728523403a5056c635a062", "filename": "src/librustc_passes/no_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -29,7 +29,7 @@ struct CheckNoAsm<'a> {\n     sess: &'a Session,\n }\n \n-impl<'a, 'v> Visitor<'v> for CheckNoAsm<'a> {\n+impl<'a> Visitor for CheckNoAsm<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprKind::InlineAsm(_) => span_err!(self.sess, e.span, E0472,"}, {"sha": "91e2190acdd48f466df659e669d01bf6bdbe208c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -505,7 +505,7 @@ struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n     parent: Module<'b>,\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item) {\n         let old_parent = self.parent;\n         self.resolver.build_reduced_graph_for_item(item, &mut self.parent);"}, {"sha": "3084d9abbe1e4f8cab3a93f271145c4ad03a8f9e", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n+impl<'a, 'b> Visitor for UnusedImportCheckVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         visit::walk_item(self, item);\n         // Ignore is_public import statements because there's no way to be sure"}, {"sha": "65a2adf797074b73a2833303643eacb334757332", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -498,7 +498,7 @@ pub enum Namespace {\n     ValueNS,\n }\n \n-impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n+impl<'a> Visitor for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n     }\n@@ -557,9 +557,9 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n         });\n     }\n     fn visit_fn(&mut self,\n-                function_kind: FnKind<'v>,\n-                declaration: &'v FnDecl,\n-                block: &'v Block,\n+                function_kind: FnKind,\n+                declaration: &FnDecl,\n+                block: &Block,\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {"}, {"sha": "19a804691ace24f7e65ef47bb49af6c391f56691", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -1038,7 +1038,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n }\n \n-impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx, 'll, D> {\n+impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span, item.id);"}, {"sha": "8eaf398778380be7724bc42cd60dc8d5c60c5e54", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -693,7 +693,7 @@ impl PathCollector {\n     }\n }\n \n-impl<'v> Visitor<'v> for PathCollector {\n+impl Visitor for PathCollector {\n     fn visit_pat(&mut self, p: &ast::Pat) {\n         match p.node {\n             PatKind::Struct(ref path, _, _) => {"}, {"sha": "c8ea514600e55350129ea7e939ea22fa45d4722b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -15,7 +15,7 @@ pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n \n-use attr::{ThinAttributes, HasAttrs};\n+use attr::ThinAttributes;\n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n@@ -846,10 +846,6 @@ impl StmtKind {\n             StmtKind::Mac(..) => None,\n         }\n     }\n-\n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -879,12 +875,6 @@ pub struct Local {\n     pub attrs: ThinAttributes,\n }\n \n-impl Local {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n-}\n-\n pub type Decl = Spanned<DeclKind>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -895,12 +885,6 @@ pub enum DeclKind {\n     Item(P<Item>),\n }\n \n-impl Decl {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n-}\n-\n /// An arm of a 'match'.\n ///\n /// E.g. `0...10 => { println!(\"match!\") }` as in\n@@ -949,12 +933,6 @@ pub struct Expr {\n     pub attrs: ThinAttributes\n }\n \n-impl Expr {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n-}\n-\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id, pprust::expr_to_string(self))\n@@ -1143,7 +1121,6 @@ pub type Mac = Spanned<Mac_>;\n pub struct Mac_ {\n     pub path: Path,\n     pub tts: Vec<TokenTree>,\n-    pub ctxt: SyntaxContext,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1916,12 +1893,6 @@ pub struct Item {\n     pub span: Span,\n }\n \n-impl Item {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        &self.attrs\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ItemKind {\n     /// An`extern crate` item, with optional original crate name."}, {"sha": "09d7f28157a43da5ef49d7baead047d635bf5d7c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -882,21 +882,6 @@ pub trait HasAttrs: Sized {\n     fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;\n }\n \n-/// A cheap way to add Attributes to an AST node.\n-pub trait WithAttrs {\n-    // FIXME: Could be extended to anything IntoIter<Item=Attribute>\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self;\n-}\n-\n-impl<T: HasAttrs> WithAttrs for T {\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n-        self.map_attrs(|mut orig_attrs| {\n-            orig_attrs.extend(attrs.into_attr_vec());\n-            orig_attrs\n-        })\n-    }\n-}\n-\n impl HasAttrs for Vec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n         &self"}, {"sha": "5e34428a3173034c2c0668f3b179e31a591b6b3f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -14,9 +14,8 @@ use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast;\n use attr::HasAttrs;\n use ext::mtwt;\n-use ext::build::AstBuilder;\n use attr;\n-use attr::{AttrMetaMethods, WithAttrs, ThinAttributesExt};\n+use attr::{AttrMetaMethods, ThinAttributesExt};\n use codemap::{Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n@@ -42,7 +41,7 @@ trait MacroGenerable: Sized {\n \n     // Fold this node or list of nodes using the given folder.\n     fn fold_with<F: Folder>(self, folder: &mut F) -> Self;\n-    fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V);\n+    fn visit_with<V: Visitor>(&self, visitor: &mut V);\n \n     // Return a placeholder expansion to allow compilation to continue after an erroring expansion.\n     fn dummy(span: Span) -> Self;\n@@ -63,7 +62,7 @@ macro_rules! impl_macro_generable {\n                 $( folder.$fold(self) )*\n                 $( self.into_iter().flat_map(|item| folder. $fold_elt (item)).collect() )*\n             }\n-            fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V) {\n+            fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n                 $( visitor.$visit(self) )*\n                 $( for item in self.as_slice() { visitor. $visit_elt (item) } )*\n             }\n@@ -98,24 +97,23 @@ impl MacroGenerable for Option<P<ast::Expr>> {\n     fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n         self.and_then(|expr| folder.fold_opt_expr(expr))\n     }\n-    fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V) {\n+    fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n         self.as_ref().map(|expr| visitor.visit_expr(expr));\n     }\n }\n \n-pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n+pub fn expand_expr(mut expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n     match expr.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n-            expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, fld)\n+            return expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, fld);\n         }\n \n         ast::ExprKind::While(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(expr.span, ast::ExprKind::While(cond, body, opt_ident))\n-                .with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::While(cond, body, opt_ident);\n         }\n \n         ast::ExprKind::WhileLet(pat, cond, body, opt_ident) => {\n@@ -132,14 +130,12 @@ pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n             });\n             assert!(rewritten_pats.len() == 1);\n \n-            let wl = ast::ExprKind::WhileLet(rewritten_pats.remove(0), cond, body, opt_ident);\n-            fld.cx.expr(expr.span, wl).with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::WhileLet(rewritten_pats.remove(0), cond, body, opt_ident);\n         }\n \n         ast::ExprKind::Loop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            fld.cx.expr(expr.span, ast::ExprKind::Loop(loop_block, opt_ident))\n-                .with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::Loop(loop_block, opt_ident);\n         }\n \n         ast::ExprKind::ForLoop(pat, head, body, opt_ident) => {\n@@ -156,8 +152,7 @@ pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n             assert!(rewritten_pats.len() == 1);\n \n             let head = fld.fold_expr(head);\n-            let fl = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n-            fld.cx.expr(expr.span, fl).with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n         }\n \n         ast::ExprKind::IfLet(pat, sub_expr, body, else_opt) => {\n@@ -175,25 +170,21 @@ pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n             let sub_expr = fld.fold_expr(sub_expr);\n-            let il = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n-            fld.cx.expr(expr.span, il).with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n         }\n \n         ast::ExprKind::Closure(capture_clause, fn_decl, block, fn_decl_span) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            let new_node = ast::ExprKind::Closure(capture_clause,\n-                                                  rewritten_fn_decl,\n-                                                  rewritten_block,\n-                                                  fn_decl_span);\n-            P(ast::Expr{ id: expr.id,\n-                         node: new_node,\n-                         span: expr.span,\n-                         attrs: fold_thin_attrs(expr.attrs, fld) })\n+            expr.node = ast::ExprKind::Closure(capture_clause,\n+                                               rewritten_fn_decl,\n+                                               rewritten_block,\n+                                               fn_decl_span);\n         }\n \n-        _ => P(noop_fold_expr(expr, fld)),\n-    }\n+        _ => expr = noop_fold_expr(expr, fld),\n+    };\n+    P(expr)\n }\n \n /// Expand a macro invocation. Returns the result of expansion.\n@@ -252,7 +243,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     },\n                 });\n \n-                let marked_tts = mark_tts(&tts[..], mark);\n+                let marked_tts = mark_tts(tts, mark);\n                 Some(expandfun.expand(fld.cx, call_site, &marked_tts))\n             }\n \n@@ -272,7 +263,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     }\n                 });\n \n-                let marked_tts = mark_tts(&tts, mark);\n+                let marked_tts = mark_tts(tts, mark);\n                 Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n             }\n \n@@ -599,7 +590,7 @@ struct PatIdentFinder {\n     ident_accumulator: Vec<ast::Ident>\n }\n \n-impl<'v> Visitor<'v> for PatIdentFinder {\n+impl Visitor for PatIdentFinder {\n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         match *pattern {\n             ast::Pat { id: _, node: PatKind::Ident(_, ref path1, ref inner), span: _ } => {\n@@ -993,9 +984,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             at_crate_root: bool,\n         }\n \n-        impl<'a, 'b, 'v> Visitor<'v> for MacroLoadingVisitor<'a, 'b> {\n-            fn visit_mac(&mut self, _: &'v ast::Mac) {}\n-            fn visit_item(&mut self, item: &'v ast::Item) {\n+        impl<'a, 'b> Visitor for MacroLoadingVisitor<'a, 'b> {\n+            fn visit_mac(&mut self, _: &ast::Mac) {}\n+            fn visit_item(&mut self, item: &ast::Item) {\n                 if let ast::ItemKind::ExternCrate(..) = item.node {\n                     // We need to error on `#[macro_use] extern crate` when it isn't at the\n                     // crate root, because `$crate` won't work properly.\n@@ -1008,7 +999,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.at_crate_root = at_crate_root;\n                 }\n             }\n-            fn visit_block(&mut self, block: &'v ast::Block) {\n+            fn visit_block(&mut self, block: &ast::Block) {\n                 let at_crate_root = ::std::mem::replace(&mut self.at_crate_root, false);\n                 visit::walk_block(self, block);\n                 self.at_crate_root = at_crate_root;\n@@ -1215,8 +1206,7 @@ impl Folder for Marker {\n         Spanned {\n             node: Mac_ {\n                 path: self.fold_path(node.path),\n-                tts: self.fold_tts(&node.tts),\n-                ctxt: mtwt::apply_mark(self.mark, node.ctxt),\n+                tts: self.fold_tts(node.tts),\n             },\n             span: self.new_span(span),\n         }\n@@ -1231,7 +1221,7 @@ impl Folder for Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n+fn mark_tts(tts: Vec<TokenTree>, m: Mrk) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n \n@@ -1261,7 +1251,7 @@ mod tests {\n         path_accumulator: Vec<ast::Path> ,\n     }\n \n-    impl<'v> Visitor<'v> for PathExprFinderContext {\n+    impl Visitor for PathExprFinderContext {\n         fn visit_expr(&mut self, expr: &ast::Expr) {\n             if let ast::ExprKind::Path(None, ref p) = expr.node {\n                 self.path_accumulator.push(p.clone());\n@@ -1283,7 +1273,7 @@ mod tests {\n         ident_accumulator: Vec<ast::Ident>\n     }\n \n-    impl<'v> Visitor<'v> for IdentFinder {\n+    impl Visitor for IdentFinder {\n         fn visit_ident(&mut self, _: syntax_pos::Span, id: ast::Ident){\n             self.ident_accumulator.push(id);\n         }"}, {"sha": "4ffcb295619eb6ed9bcca1ae0030ff5a3c26f62a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -32,7 +32,6 @@ pub mod rt {\n     use ext::base::ExtCtxt;\n     use parse::{self, token, classify};\n     use ptr::P;\n-    use std::rc::Rc;\n \n     use tokenstream::{self, TokenTree};\n \n@@ -216,12 +215,12 @@ pub mod rt {\n             if self.node.style == ast::AttrStyle::Inner {\n                 r.push(TokenTree::Token(self.span, token::Not));\n             }\n-            r.push(TokenTree::Delimited(self.span, Rc::new(tokenstream::Delimited {\n+            r.push(TokenTree::Delimited(self.span, tokenstream::Delimited {\n                 delim: token::Bracket,\n                 open_span: self.span,\n                 tts: self.node.value.to_tokens(cx),\n                 close_span: self.span,\n-            })));\n+            }));\n             r\n         }\n     }\n@@ -236,12 +235,12 @@ pub mod rt {\n \n     impl ToTokens for () {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Delimited(DUMMY_SP, Rc::new(tokenstream::Delimited {\n+            vec![TokenTree::Delimited(DUMMY_SP, tokenstream::Delimited {\n                 delim: token::Paren,\n                 open_span: DUMMY_SP,\n                 tts: vec![],\n                 close_span: DUMMY_SP,\n-            }))]\n+            })]\n         }\n     }\n \n@@ -793,14 +792,9 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stm\n                                 id_ext(\"tokenstream\"),\n                                 id_ext(\"SequenceRepetition\")];\n             let e_seq_struct = cx.expr_struct(sp, cx.path_global(sp, seq_path), fields);\n-            let e_rc_new = cx.expr_call_global(sp, vec![id_ext(\"std\"),\n-                                                        id_ext(\"rc\"),\n-                                                        id_ext(\"Rc\"),\n-                                                        id_ext(\"new\")],\n-                                                   vec![e_seq_struct]);\n             let e_tok = cx.expr_call(sp,\n                                      mk_tt_path(cx, sp, \"Sequence\"),\n-                                     vec!(e_sp, e_rc_new));\n+                                     vec!(e_sp, e_seq_struct));\n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),"}, {"sha": "23f0b1fff0ae72b79c28763d4bfab6befbfc8706", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -28,7 +28,6 @@ use util::small_vector::SmallVector;\n use std::cell::RefCell;\n use std::collections::{HashMap};\n use std::collections::hash_map::{Entry};\n-use std::rc::Rc;\n \n struct ParserAnyMacro<'a> {\n     parser: RefCell<Parser<'a>>,\n@@ -262,27 +261,25 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     // These spans won't matter, anyways\n     let match_lhs_tok = MatchNt(lhs_nm, token::str_to_ident(\"tt\"));\n     let match_rhs_tok = MatchNt(rhs_nm, token::str_to_ident(\"tt\"));\n-    let argument_gram = vec!(\n-        TokenTree::Sequence(DUMMY_SP,\n-                   Rc::new(tokenstream::SequenceRepetition {\n-                       tts: vec![\n-                           TokenTree::Token(DUMMY_SP, match_lhs_tok),\n-                           TokenTree::Token(DUMMY_SP, token::FatArrow),\n-                           TokenTree::Token(DUMMY_SP, match_rhs_tok)],\n-                       separator: Some(token::Semi),\n-                       op: tokenstream::KleeneOp::OneOrMore,\n-                       num_captures: 2\n-                   })),\n-        //to phase into semicolon-termination instead of\n-        //semicolon-separation\n-        TokenTree::Sequence(DUMMY_SP,\n-                   Rc::new(tokenstream::SequenceRepetition {\n-                       tts: vec![TokenTree::Token(DUMMY_SP, token::Semi)],\n-                       separator: None,\n-                       op: tokenstream::KleeneOp::ZeroOrMore,\n-                       num_captures: 0\n-                   })));\n-\n+    let argument_gram = vec![\n+        TokenTree::Sequence(DUMMY_SP, tokenstream::SequenceRepetition {\n+            tts: vec![\n+                TokenTree::Token(DUMMY_SP, match_lhs_tok),\n+                TokenTree::Token(DUMMY_SP, token::FatArrow),\n+                TokenTree::Token(DUMMY_SP, match_rhs_tok),\n+            ],\n+            separator: Some(token::Semi),\n+            op: tokenstream::KleeneOp::OneOrMore,\n+            num_captures: 2,\n+        }),\n+        // to phase into semicolon-termination instead of semicolon-separation\n+        TokenTree::Sequence(DUMMY_SP, tokenstream::SequenceRepetition {\n+            tts: vec![TokenTree::Token(DUMMY_SP, token::Semi)],\n+            separator: None,\n+            op: tokenstream::KleeneOp::ZeroOrMore,\n+            num_captures: 0\n+        }),\n+    ];\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,"}, {"sha": "58328eb4246756607aa037cf4d35a8731a929224", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -79,11 +79,11 @@ pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n     let mut r = TtReader {\n         sp_diag: sp_diag,\n         stack: vec!(TtFrame {\n-            forest: TokenTree::Sequence(DUMMY_SP, Rc::new(tokenstream::SequenceRepetition {\n+            forest: TokenTree::Sequence(DUMMY_SP, tokenstream::SequenceRepetition {\n                 tts: src,\n                 // doesn't matter. This merely holds the root unzipping.\n                 separator: None, op: tokenstream::KleeneOp::ZeroOrMore, num_captures: 0\n-            })),\n+            }),\n             idx: 0,\n             dotdotdoted: false,\n             sep: None,"}, {"sha": "d6476fdb2f0159fbb001f51daf2cd500912c0af4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -800,7 +800,7 @@ macro_rules! gate_feature_post {\n     }}\n }\n \n-impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n+impl<'a> Visitor for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if !self.context.cm.span_allows_unstable(attr.span) {\n             self.context.check_attribute(attr, false);\n@@ -996,9 +996,9 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_fn(&mut self,\n-                fn_kind: FnKind<'v>,\n-                fn_decl: &'v ast::FnDecl,\n-                block: &'v ast::Block,\n+                fn_kind: FnKind,\n+                fn_decl: &ast::FnDecl,\n+                block: &ast::Block,\n                 span: Span,\n                 _node_id: NodeId) {\n         // check for const fn declarations\n@@ -1037,7 +1037,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_fn(self, fn_kind, fn_decl, block, span);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n         match ti.node {\n             ast::TraitItemKind::Const(..) => {\n                 gate_feature_post!(&self, associated_consts,\n@@ -1058,7 +1058,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_trait_item(self, ti);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n         if ii.defaultness == ast::Defaultness::Default {\n             gate_feature_post!(&self, specialization,\n                               ii.span,\n@@ -1081,7 +1081,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_vis(&mut self, vis: &'v ast::Visibility) {\n+    fn visit_vis(&mut self, vis: &ast::Visibility) {\n         let span = match *vis {\n             ast::Visibility::Crate(span) => span,\n             ast::Visibility::Restricted { ref path, .. } => path.span,"}, {"sha": "73c2957bbcfaad125b7511bf84fed54b7ec0b980", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -29,8 +29,6 @@ use tokenstream::*;\n use util::small_vector::SmallVector;\n use util::move_map::MoveMap;\n \n-use std::rc::Rc;\n-\n pub trait Folder : Sized {\n     // Any additions to this trait should happen in form\n     // of a call to a public `noop_*` function that only calls\n@@ -229,11 +227,11 @@ pub trait Folder : Sized {\n         noop_fold_ty_params(tps, self)\n     }\n \n-    fn fold_tt(&mut self, tt: &TokenTree) -> TokenTree {\n+    fn fold_tt(&mut self, tt: TokenTree) -> TokenTree {\n         noop_fold_tt(tt, self)\n     }\n \n-    fn fold_tts(&mut self, tts: &[TokenTree]) -> Vec<TokenTree> {\n+    fn fold_tts(&mut self, tts: Vec<TokenTree>) -> Vec<TokenTree> {\n         noop_fold_tts(tts, self)\n     }\n \n@@ -521,8 +519,7 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     Spanned {\n         node: Mac_ {\n             path: fld.fold_path(node.path),\n-            tts: fld.fold_tts(&node.tts),\n-            ctxt: node.ctxt,\n+            tts: fld.fold_tts(node.tts),\n         },\n         span: fld.new_span(span)\n     }\n@@ -549,34 +546,26 @@ pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n     }\n }\n \n-pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n-    match *tt {\n+pub fn noop_fold_tt<T: Folder>(tt: TokenTree, fld: &mut T) -> TokenTree {\n+    match tt {\n         TokenTree::Token(span, ref tok) =>\n             TokenTree::Token(span, fld.fold_token(tok.clone())),\n-        TokenTree::Delimited(span, ref delimed) => {\n-            TokenTree::Delimited(span, Rc::new(\n-                            Delimited {\n-                                delim: delimed.delim,\n-                                open_span: delimed.open_span,\n-                                tts: fld.fold_tts(&delimed.tts),\n-                                close_span: delimed.close_span,\n-                            }\n-                        ))\n-        },\n-        TokenTree::Sequence(span, ref seq) =>\n-            TokenTree::Sequence(span,\n-                       Rc::new(SequenceRepetition {\n-                           tts: fld.fold_tts(&seq.tts),\n-                           separator: seq.separator.clone().map(|tok| fld.fold_token(tok)),\n-                           ..**seq\n-                       })),\n+        TokenTree::Delimited(span, delimed) => TokenTree::Delimited(span, Delimited {\n+            delim: delimed.delim,\n+            open_span: delimed.open_span,\n+            tts: fld.fold_tts(delimed.tts),\n+            close_span: delimed.close_span,\n+        }),\n+        TokenTree::Sequence(span, seq) => TokenTree::Sequence(span, SequenceRepetition {\n+            tts: fld.fold_tts(seq.tts),\n+            separator: seq.separator.clone().map(|tok| fld.fold_token(tok)),\n+            ..seq\n+        }),\n     }\n }\n \n-pub fn noop_fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n-    // FIXME: Does this have to take a tts slice?\n-    // Could use move_map otherwise...\n-    tts.iter().map(|tt| fld.fold_tt(tt)).collect()\n+pub fn noop_fold_tts<T: Folder>(tts: Vec<TokenTree>, fld: &mut T) -> Vec<TokenTree> {\n+    tts.move_map(|tt| fld.fold_tt(tt))\n }\n \n // apply ident folder if it's an ident, apply other folds to interpolated nodes\n@@ -634,7 +623,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n             token::NtIdent(Box::new(Spanned::<Ident>{node: fld.fold_ident(id.node), ..*id})),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n         token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n-        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&tt))),\n+        token::NtTT(tt) => token::NtTT(tt.map(|tt| fld.fold_tt(tt))),\n         token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n         token::NtImplItem(arm) =>\n             token::NtImplItem(arm.map(|arm| fld.fold_impl_item(arm)"}, {"sha": "d0863b0551a309b779793a9b9ce39f214931194b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -662,7 +662,6 @@ pub fn integer_lit(s: &str,\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use std::rc::Rc;\n     use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n     use codemap::Spanned;\n     use ast::{self, PatKind};\n@@ -763,7 +762,7 @@ mod tests {\n                             )\n                             if first_delimed.delim == token::Paren\n                             && ident.name.as_str() == \"a\" => {},\n-                            _ => panic!(\"value 3: {:?}\", **first_delimed),\n+                            _ => panic!(\"value 3: {:?}\", *first_delimed),\n                         }\n                         let tts = &second_delimed.tts[..];\n                         match (tts.len(), tts.get(0), tts.get(1)) {\n@@ -774,10 +773,10 @@ mod tests {\n                             )\n                             if second_delimed.delim == token::Paren\n                             && ident.name.as_str() == \"a\" => {},\n-                            _ => panic!(\"value 4: {:?}\", **second_delimed),\n+                            _ => panic!(\"value 4: {:?}\", *second_delimed),\n                         }\n                     },\n-                    _ => panic!(\"value 2: {:?}\", **macro_delimed),\n+                    _ => panic!(\"value 2: {:?}\", *macro_delimed),\n                 }\n             },\n             _ => panic!(\"value: {:?}\",tts),\n@@ -793,7 +792,7 @@ mod tests {\n             TokenTree::Token(sp(3, 4), token::Ident(str_to_ident(\"a\"))),\n             TokenTree::Delimited(\n                 sp(5, 14),\n-                Rc::new(tokenstream::Delimited {\n+                tokenstream::Delimited {\n                     delim: token::DelimToken::Paren,\n                     open_span: sp(5, 6),\n                     tts: vec![\n@@ -802,18 +801,18 @@ mod tests {\n                         TokenTree::Token(sp(10, 13), token::Ident(str_to_ident(\"i32\"))),\n                     ],\n                     close_span: sp(13, 14),\n-                })),\n+                }),\n             TokenTree::Delimited(\n                 sp(15, 21),\n-                Rc::new(tokenstream::Delimited {\n+                tokenstream::Delimited {\n                     delim: token::DelimToken::Brace,\n                     open_span: sp(15, 16),\n                     tts: vec![\n                         TokenTree::Token(sp(17, 18), token::Ident(str_to_ident(\"b\"))),\n                         TokenTree::Token(sp(18, 19), token::Semi),\n                     ],\n                     close_span: sp(20, 21),\n-                }))\n+                })\n         ];\n \n         assert_eq!(tts, expected);\n@@ -996,8 +995,8 @@ mod tests {\n         struct PatIdentVisitor {\n             spans: Vec<Span>\n         }\n-        impl<'v> ::visit::Visitor<'v> for PatIdentVisitor {\n-            fn visit_pat(&mut self, p: &'v ast::Pat) {\n+        impl ::visit::Visitor for PatIdentVisitor {\n+            fn visit_pat(&mut self, p: &ast::Pat) {\n                 match p.node {\n                     PatKind::Ident(_ , ref spannedident, _) => {\n                         self.spans.push(spannedident.span.clone());"}, {"sha": "f383b34d1ca1e0e1d11402e79ef38520d4eccb56", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -17,7 +17,7 @@ use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n use ast::{Decl, DeclKind, Defaultness};\n-use ast::{EMPTY_CTXT, EnumDef};\n+use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n@@ -1273,7 +1273,7 @@ impl<'a> Parser<'a> {\n                 let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                              SeqSep::none(),\n                                              |pp| pp.parse_token_tree())?;\n-                let m_ = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n+                let m_ = Mac_ { path: pth, tts: tts };\n                 let m: ast::Mac = codemap::Spanned { node: m_,\n                                                      span: mk_sp(lo,\n                                                                  self.last_span.hi) };\n@@ -1494,7 +1494,7 @@ impl<'a> Parser<'a> {\n                                                 SeqSep::none(),\n                                                 |p| p.parse_token_tree())?;\n                 let hi = self.span.hi;\n-                TyKind::Mac(spanned(lo, hi, Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT }))\n+                TyKind::Mac(spanned(lo, hi, Mac_ { path: path, tts: tts }))\n             } else {\n                 // NAMED TYPE\n                 TyKind::Path(None, path)\n@@ -2375,7 +2375,7 @@ impl<'a> Parser<'a> {\n \n                         return Ok(self.mk_mac_expr(lo,\n                                                    hi,\n-                                                   Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT },\n+                                                   Mac_ { path: pth, tts: tts },\n                                                    attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n@@ -2698,13 +2698,12 @@ impl<'a> Parser<'a> {\n                     )?;\n                     let (sep, repeat) = self.parse_sep_and_kleene_op()?;\n                     let name_num = macro_parser::count_names(&seq);\n-                    return Ok(TokenTree::Sequence(mk_sp(sp.lo, seq_span.hi),\n-                                      Rc::new(SequenceRepetition {\n-                                          tts: seq,\n-                                          separator: sep,\n-                                          op: repeat,\n-                                          num_captures: name_num\n-                                      })));\n+                    return Ok(TokenTree::Sequence(mk_sp(sp.lo, seq_span.hi), SequenceRepetition {\n+                        tts: seq,\n+                        separator: sep,\n+                        op: repeat,\n+                        num_captures: name_num\n+                    }));\n                 } else if self.token.is_keyword(keywords::Crate) {\n                     self.bump();\n                     return Ok(TokenTree::Token(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar)));\n@@ -2860,12 +2859,12 @@ impl<'a> Parser<'a> {\n                     _ => {}\n                 }\n \n-                Ok(TokenTree::Delimited(span, Rc::new(Delimited {\n+                Ok(TokenTree::Delimited(span, Delimited {\n                     delim: delim,\n                     open_span: open_span,\n                     tts: tts,\n                     close_span: close_span,\n-                })))\n+                }))\n             },\n             _ => {\n                 // invariants: the current token is not a left-delimiter,\n@@ -3689,7 +3688,7 @@ impl<'a> Parser<'a> {\n                         let tts = self.parse_seq_to_end(\n                             &token::CloseDelim(delim),\n                             SeqSep::none(), |p| p.parse_token_tree())?;\n-                        let mac = Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT };\n+                        let mac = Mac_ { path: path, tts: tts };\n                         pat = PatKind::Mac(codemap::Spanned {node: mac,\n                                                                span: mk_sp(lo, self.last_span.hi)});\n                     } else {\n@@ -4002,7 +4001,7 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == keywords::Invalid.name() {\n-                let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n+                let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts }));\n                 let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n                 spanned(lo, hi, stmt)\n             } else {\n@@ -4023,7 +4022,7 @@ impl<'a> Parser<'a> {\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             ItemKind::Mac(spanned(lo, hi,\n-                                            Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n+                                            Mac_ { path: pth, tts: tts })),\n                             Visibility::Inherited, attrs)))),\n                     ast::DUMMY_NODE_ID))\n             }\n@@ -4936,7 +4935,7 @@ impl<'a> Parser<'a> {\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n-            let m_ = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n+            let m_ = Mac_ { path: pth, tts: tts };\n             let m: ast::Mac = codemap::Spanned { node: m_,\n                                                     span: mk_sp(lo,\n                                                                 self.last_span.hi) };\n@@ -6021,7 +6020,7 @@ impl<'a> Parser<'a> {\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n             // single-variant-enum... :\n-            let m = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n+            let m = Mac_ { path: pth, tts: tts };\n             let m: ast::Mac = codemap::Spanned { node: m,\n                                                  span: mk_sp(mac_lo,\n                                                              self.last_span.hi) };"}, {"sha": "928ffb202d0b331594608d40be1c3cc00ed4c22d", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -44,7 +44,7 @@ struct ShowSpanVisitor<'a> {\n     mode: Mode,\n }\n \n-impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n+impl<'a> Visitor for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         if let Mode::Expression = self.mode {\n             self.span_diagnostic.span_warn(e.span, \"expression\");"}, {"sha": "35377d14bab7cc0fe4618fb7be541311b1a987c9", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -20,7 +20,6 @@ use ext::tt::macro_parser;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::lexer;\n use parse::token;\n-use std::rc::Rc;\n \n /// A delimited sequence of token trees\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -95,13 +94,13 @@ pub enum TokenTree {\n     /// A single token\n     Token(Span, token::Token),\n     /// A delimited sequence of token trees\n-    Delimited(Span, Rc<Delimited>),\n+    Delimited(Span, Delimited),\n \n     // This only makes sense in MBE macros.\n \n     /// A kleene-style repetition sequence with a span\n     // FIXME(eddyb) #12938 Use DST.\n-    Sequence(Span, Rc<SequenceRepetition>),\n+    Sequence(Span, SequenceRepetition),\n }\n \n impl TokenTree {\n@@ -150,15 +149,15 @@ impl TokenTree {\n                     Some(*cnt)\n                 }).max().unwrap_or(0);\n \n-                TokenTree::Delimited(sp, Rc::new(Delimited {\n+                TokenTree::Delimited(sp, Delimited {\n                     delim: token::Bracket,\n                     open_span: sp,\n                     tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"))),\n                               TokenTree::Token(sp, token::Eq),\n                               TokenTree::Token(sp, token::Literal(\n                                   token::StrRaw(token::intern(&stripped), num_of_hashes), None))],\n                     close_span: sp,\n-                }))\n+                })\n             }\n             (&TokenTree::Delimited(_, ref delimed), _) => {\n                 if index == 0 {"}, {"sha": "7c364a1603ee06485a221b97426d3922fc239fbd", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -26,133 +26,133 @@ impl NodeCounter {\n     }\n }\n \n-impl<'v> Visitor<'v> for NodeCounter {\n+impl Visitor for NodeCounter {\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n         self.count += 1;\n         walk_ident(self, span, ident);\n     }\n-    fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) {\n+    fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) {\n         self.count += 1;\n         walk_mod(self, m)\n     }\n-    fn visit_foreign_item(&mut self, i: &'v ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &ForeignItem) {\n         self.count += 1;\n         walk_foreign_item(self, i)\n     }\n-    fn visit_item(&mut self, i: &'v Item) {\n+    fn visit_item(&mut self, i: &Item) {\n         self.count += 1;\n         walk_item(self, i)\n     }\n-    fn visit_local(&mut self, l: &'v Local) {\n+    fn visit_local(&mut self, l: &Local) {\n         self.count += 1;\n         walk_local(self, l)\n     }\n-    fn visit_block(&mut self, b: &'v Block) {\n+    fn visit_block(&mut self, b: &Block) {\n         self.count += 1;\n         walk_block(self, b)\n     }\n-    fn visit_stmt(&mut self, s: &'v Stmt) {\n+    fn visit_stmt(&mut self, s: &Stmt) {\n         self.count += 1;\n         walk_stmt(self, s)\n     }\n-    fn visit_arm(&mut self, a: &'v Arm) {\n+    fn visit_arm(&mut self, a: &Arm) {\n         self.count += 1;\n         walk_arm(self, a)\n     }\n-    fn visit_pat(&mut self, p: &'v Pat) {\n+    fn visit_pat(&mut self, p: &Pat) {\n         self.count += 1;\n         walk_pat(self, p)\n     }\n-    fn visit_decl(&mut self, d: &'v Decl) {\n+    fn visit_decl(&mut self, d: &Decl) {\n         self.count += 1;\n         walk_decl(self, d)\n     }\n-    fn visit_expr(&mut self, ex: &'v Expr) {\n+    fn visit_expr(&mut self, ex: &Expr) {\n         self.count += 1;\n         walk_expr(self, ex)\n     }\n-    fn visit_ty(&mut self, t: &'v Ty) {\n+    fn visit_ty(&mut self, t: &Ty) {\n         self.count += 1;\n         walk_ty(self, t)\n     }\n-    fn visit_generics(&mut self, g: &'v Generics) {\n+    fn visit_generics(&mut self, g: &Generics) {\n         self.count += 1;\n         walk_generics(self, g)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n         self.count += 1;\n         walk_fn(self, fk, fd, b, s)\n     }\n-    fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &TraitItem) {\n         self.count += 1;\n         walk_trait_item(self, ti)\n     }\n-    fn visit_impl_item(&mut self, ii: &'v ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &ImplItem) {\n         self.count += 1;\n         walk_impl_item(self, ii)\n     }\n-    fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n+    fn visit_trait_ref(&mut self, t: &TraitRef) {\n         self.count += 1;\n         walk_trait_ref(self, t)\n     }\n-    fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n+    fn visit_ty_param_bound(&mut self, bounds: &TyParamBound) {\n         self.count += 1;\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &PolyTraitRef, m: &TraitBoundModifier) {\n         self.count += 1;\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_variant_data(&mut self, s: &'v VariantData, _: Ident,\n-                        _: &'v Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &VariantData, _: Ident,\n+                          _: &Generics, _: NodeId, _: Span) {\n         self.count += 1;\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &'v StructField) {\n+    fn visit_struct_field(&mut self, s: &StructField) {\n         self.count += 1;\n         walk_struct_field(self, s)\n     }\n-    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n-                      generics: &'v Generics, item_id: NodeId, _: Span) {\n+    fn visit_enum_def(&mut self, enum_definition: &EnumDef,\n+                      generics: &Generics, item_id: NodeId, _: Span) {\n         self.count += 1;\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n         self.count += 1;\n         walk_variant(self, v, g, item_id)\n     }\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n         self.count += 1;\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lifetime: &LifetimeDef) {\n         self.count += 1;\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_mac(&mut self, _mac: &'v Mac) {\n+    fn visit_mac(&mut self, _mac: &Mac) {\n         self.count += 1;\n         walk_mac(self, _mac)\n     }\n-    fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n+    fn visit_path(&mut self, path: &Path, _id: NodeId) {\n         self.count += 1;\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &'v Path, item: &'v PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &Path, item: &PathListItem) {\n         self.count += 1;\n         walk_path_list_item(self, prefix, item)\n     }\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &PathParameters) {\n         self.count += 1;\n         walk_path_parameters(self, path_span, path_parameters)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) {\n         self.count += 1;\n         walk_assoc_type_binding(self, type_binding)\n     }\n-    fn visit_attribute(&mut self, _attr: &'v Attribute) {\n+    fn visit_attribute(&mut self, _attr: &Attribute) {\n         self.count += 1;\n     }\n-    fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         self.count += 1;\n         walk_macro_def(self, macro_def)\n     }"}, {"sha": "9a52c0b32be7591403f4298cd014410a189620e1", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 90, "deletions": 109, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -50,84 +50,84 @@ pub enum FnKind<'a> {\n /// explicitly, you need to override each method.  (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor<'v> : Sized {\n+pub trait Visitor: Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n         walk_ident(self, span, ident);\n     }\n-    fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n-    fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n-    fn visit_item(&mut self, i: &'v Item) { walk_item(self, i) }\n-    fn visit_local(&mut self, l: &'v Local) { walk_local(self, l) }\n-    fn visit_block(&mut self, b: &'v Block) { walk_block(self, b) }\n-    fn visit_stmt(&mut self, s: &'v Stmt) { walk_stmt(self, s) }\n-    fn visit_arm(&mut self, a: &'v Arm) { walk_arm(self, a) }\n-    fn visit_pat(&mut self, p: &'v Pat) { walk_pat(self, p) }\n-    fn visit_decl(&mut self, d: &'v Decl) { walk_decl(self, d) }\n-    fn visit_expr(&mut self, ex: &'v Expr) { walk_expr(self, ex) }\n-    fn visit_expr_post(&mut self, _ex: &'v Expr) { }\n-    fn visit_ty(&mut self, t: &'v Ty) { walk_ty(self, t) }\n-    fn visit_generics(&mut self, g: &'v Generics) { walk_generics(self, g) }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n+    fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n+    fn visit_foreign_item(&mut self, i: &ForeignItem) { walk_foreign_item(self, i) }\n+    fn visit_item(&mut self, i: &Item) { walk_item(self, i) }\n+    fn visit_local(&mut self, l: &Local) { walk_local(self, l) }\n+    fn visit_block(&mut self, b: &Block) { walk_block(self, b) }\n+    fn visit_stmt(&mut self, s: &Stmt) { walk_stmt(self, s) }\n+    fn visit_arm(&mut self, a: &Arm) { walk_arm(self, a) }\n+    fn visit_pat(&mut self, p: &Pat) { walk_pat(self, p) }\n+    fn visit_decl(&mut self, d: &Decl) { walk_decl(self, d) }\n+    fn visit_expr(&mut self, ex: &Expr) { walk_expr(self, ex) }\n+    fn visit_expr_post(&mut self, _ex: &Expr) { }\n+    fn visit_ty(&mut self, t: &Ty) { walk_ty(self, t) }\n+    fn visit_generics(&mut self, g: &Generics) { walk_generics(self, g) }\n+    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, b, s)\n     }\n-    fn visit_trait_item(&mut self, ti: &'v TraitItem) { walk_trait_item(self, ti) }\n-    fn visit_impl_item(&mut self, ii: &'v ImplItem) { walk_impl_item(self, ii) }\n-    fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n-    fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n+    fn visit_trait_item(&mut self, ti: &TraitItem) { walk_trait_item(self, ti) }\n+    fn visit_impl_item(&mut self, ii: &ImplItem) { walk_impl_item(self, ii) }\n+    fn visit_trait_ref(&mut self, t: &TraitRef) { walk_trait_ref(self, t) }\n+    fn visit_ty_param_bound(&mut self, bounds: &TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &PolyTraitRef, m: &TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_variant_data(&mut self, s: &'v VariantData, _: Ident,\n-                        _: &'v Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &VariantData, _: Ident,\n+                          _: &Generics, _: NodeId, _: Span) {\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &'v StructField) { walk_struct_field(self, s) }\n-    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n-                      generics: &'v Generics, item_id: NodeId, _: Span) {\n+    fn visit_struct_field(&mut self, s: &StructField) { walk_struct_field(self, s) }\n+    fn visit_enum_def(&mut self, enum_definition: &EnumDef,\n+                      generics: &Generics, item_id: NodeId, _: Span) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n         walk_variant(self, v, g, item_id)\n     }\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lifetime: &LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_mac(&mut self, _mac: &'v Mac) {\n+    fn visit_mac(&mut self, _mac: &Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a visitor that\n         // works on macros, use this\n         // definition in your trait impl:\n         // visit::walk_mac(self, _mac)\n     }\n-    fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n+    fn visit_path(&mut self, path: &Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &'v Path, item: &'v PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &Path, item: &PathListItem) {\n         walk_path_list_item(self, prefix, item)\n     }\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &PathParameters) {\n         walk_path_parameters(self, path_span, path_parameters)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) {\n         walk_assoc_type_binding(self, type_binding)\n     }\n-    fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n-    fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n+    fn visit_attribute(&mut self, _attr: &Attribute) {}\n+    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         walk_macro_def(self, macro_def)\n     }\n-    fn visit_vis(&mut self, vis: &'v Visibility) {\n+    fn visit_vis(&mut self, vis: &Visibility) {\n         walk_vis(self, vis)\n     }\n }\n@@ -146,46 +146,45 @@ macro_rules! walk_list {\n     }\n }\n \n-pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n+pub fn walk_opt_name<V: Visitor>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n     if let Some(name) = opt_name {\n         visitor.visit_name(span, name);\n     }\n }\n \n-pub fn walk_opt_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n+pub fn walk_opt_ident<V: Visitor>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n     if let Some(ident) = opt_ident {\n         visitor.visit_ident(span, ident);\n     }\n }\n \n-pub fn walk_opt_sp_ident<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             opt_sp_ident: &Option<Spanned<Ident>>) {\n+pub fn walk_opt_sp_ident<V: Visitor>(visitor: &mut V, opt_sp_ident: &Option<Spanned<Ident>>) {\n     if let Some(ref sp_ident) = *opt_sp_ident {\n         visitor.visit_ident(sp_ident.span, sp_ident.node);\n     }\n }\n \n-pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n+pub fn walk_ident<V: Visitor>(visitor: &mut V, span: Span, ident: Ident) {\n     visitor.visit_name(span, ident.name);\n }\n \n-pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n+pub fn walk_crate<V: Visitor>(visitor: &mut V, krate: &Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n     walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n }\n \n-pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n+pub fn walk_macro_def<V: Visitor>(visitor: &mut V, macro_def: &MacroDef) {\n     visitor.visit_ident(macro_def.span, macro_def.ident);\n     walk_opt_ident(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n+pub fn walk_mod<V: Visitor>(visitor: &mut V, module: &Mod) {\n     walk_list!(visitor, visit_item, &module.items);\n }\n \n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+pub fn walk_local<V: Visitor>(visitor: &mut V, local: &Local) {\n     for attr in local.attrs.as_attr_slice() {\n         visitor.visit_attribute(attr);\n     }\n@@ -194,33 +193,27 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     walk_list!(visitor, visit_expr, &local.init);\n }\n \n-pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+pub fn walk_lifetime<V: Visitor>(visitor: &mut V, lifetime: &Lifetime) {\n     visitor.visit_name(lifetime.span, lifetime.name);\n }\n \n-pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              lifetime_def: &'v LifetimeDef) {\n+pub fn walk_lifetime_def<V: Visitor>(visitor: &mut V, lifetime_def: &LifetimeDef) {\n     visitor.visit_lifetime(&lifetime_def.lifetime);\n     walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n-pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n-                                  trait_ref: &'v PolyTraitRef,\n-                                  _modifier: &'v TraitBoundModifier)\n-    where V: Visitor<'v>\n+pub fn walk_poly_trait_ref<V>(visitor: &mut V, trait_ref: &PolyTraitRef, _: &TraitBoundModifier)\n+    where V: Visitor,\n {\n     walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n-pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n-                                   trait_ref: &'v TraitRef)\n-    where V: Visitor<'v>\n-{\n+pub fn walk_trait_ref<V: Visitor>(visitor: &mut V, trait_ref: &TraitRef) {\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n }\n \n-pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n+pub fn walk_item<V: Visitor>(visitor: &mut V, item: &Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n@@ -299,25 +292,24 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n-pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                         enum_definition: &'v EnumDef,\n-                                         generics: &'v Generics,\n-                                         item_id: NodeId) {\n+pub fn walk_enum_def<V: Visitor>(visitor: &mut V,\n+                                 enum_definition: &EnumDef,\n+                                 generics: &Generics,\n+                                 item_id: NodeId) {\n     walk_list!(visitor, visit_variant, &enum_definition.variants, generics, item_id);\n }\n \n-pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                        variant: &'v Variant,\n-                                        generics: &'v Generics,\n-                                        item_id: NodeId) {\n+pub fn walk_variant<V>(visitor: &mut V, variant: &Variant, generics: &Generics, item_id: NodeId)\n+    where V: Visitor,\n+{\n     visitor.visit_ident(variant.span, variant.node.name);\n     visitor.visit_variant_data(&variant.node.data, variant.node.name,\n                              generics, item_id, variant.span);\n     walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n-pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n+pub fn walk_ty<V: Visitor>(visitor: &mut V, typ: &Ty) {\n     match typ.node {\n         TyKind::Vec(ref ty) | TyKind::Paren(ref ty) => {\n             visitor.visit_ty(ty)\n@@ -363,28 +355,25 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n+pub fn walk_path<V: Visitor>(visitor: &mut V, path: &Path) {\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n }\n \n-pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, _prefix: &'v Path,\n-                                               item: &'v PathListItem) {\n+pub fn walk_path_list_item<V: Visitor>(visitor: &mut V, _prefix: &Path, item: &PathListItem) {\n     walk_opt_ident(visitor, item.span, item.node.name());\n     walk_opt_ident(visitor, item.span, item.node.rename());\n }\n \n-pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             path_span: Span,\n-                                             segment: &'v PathSegment) {\n+pub fn walk_path_segment<V: Visitor>(visitor: &mut V, path_span: Span, segment: &PathSegment) {\n     visitor.visit_ident(path_span, segment.identifier);\n     visitor.visit_path_parameters(path_span, &segment.parameters);\n }\n \n-pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                _path_span: Span,\n-                                                path_parameters: &'v PathParameters) {\n+pub fn walk_path_parameters<V>(visitor: &mut V, _path_span: Span, path_parameters: &PathParameters)\n+    where V: Visitor,\n+{\n     match *path_parameters {\n         PathParameters::AngleBracketed(ref data) => {\n             walk_list!(visitor, visit_ty, &data.types);\n@@ -398,13 +387,12 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                   type_binding: &'v TypeBinding) {\n+pub fn walk_assoc_type_binding<V: Visitor>(visitor: &mut V, type_binding: &TypeBinding) {\n     visitor.visit_ident(type_binding.span, type_binding.ident);\n     visitor.visit_ty(&type_binding.ty);\n }\n \n-pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n+pub fn walk_pat<V: Visitor>(visitor: &mut V, pattern: &Pat) {\n     match pattern.node {\n         PatKind::TupleStruct(ref path, ref children, _) => {\n             visitor.visit_path(path, pattern.id);\n@@ -449,8 +437,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     }\n }\n \n-pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             foreign_item: &'v ForeignItem) {\n+pub fn walk_foreign_item<V: Visitor>(visitor: &mut V, foreign_item: &ForeignItem) {\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.span, foreign_item.ident);\n \n@@ -465,8 +452,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n     walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n }\n \n-pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                               bound: &'v TyParamBound) {\n+pub fn walk_ty_param_bound<V: Visitor>(visitor: &mut V, bound: &TyParamBound) {\n     match *bound {\n         TraitTyParamBound(ref typ, ref modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n@@ -477,7 +463,7 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n+pub fn walk_generics<V: Visitor>(visitor: &mut V, generics: &Generics) {\n     for param in &generics.ty_params {\n         visitor.visit_ident(param.span, param.ident);\n         walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n@@ -511,22 +497,21 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n+pub fn walk_fn_ret_ty<V: Visitor>(visitor: &mut V, ret_ty: &FunctionRetTy) {\n     if let FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n \n-pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n+pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, function_declaration: &FnDecl) {\n     for argument in &function_declaration.inputs {\n         visitor.visit_pat(&argument.pat);\n         visitor.visit_ty(&argument.ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n-pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                        function_kind: FnKind<'v>) {\n+pub fn walk_fn_kind<V: Visitor>(visitor: &mut V, function_kind: FnKind) {\n     match function_kind {\n         FnKind::ItemFn(_, generics, _, _, _, _) => {\n             visitor.visit_generics(generics);\n@@ -538,17 +523,15 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                   function_kind: FnKind<'v>,\n-                                   function_declaration: &'v FnDecl,\n-                                   function_body: &'v Block,\n-                                   _span: Span) {\n-    walk_fn_decl(visitor, function_declaration);\n-    walk_fn_kind(visitor, function_kind);\n-    visitor.visit_block(function_body)\n+pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, body: &Block, _span: Span)\n+    where V: Visitor,\n+{\n+    walk_fn_decl(visitor, declaration);\n+    walk_fn_kind(visitor, kind);\n+    visitor.visit_block(body)\n }\n \n-pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n+pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_item: &TraitItem) {\n     visitor.visit_ident(trait_item.span, trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n@@ -574,7 +557,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     }\n }\n \n-pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n+pub fn walk_impl_item<V: Visitor>(visitor: &mut V, impl_item: &ImplItem) {\n     visitor.visit_vis(&impl_item.vis);\n     visitor.visit_ident(impl_item.span, impl_item.ident);\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n@@ -596,25 +579,23 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     }\n }\n \n-pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                           struct_definition: &'v VariantData) {\n+pub fn walk_struct_def<V: Visitor>(visitor: &mut V, struct_definition: &VariantData) {\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n-pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             struct_field: &'v StructField) {\n+pub fn walk_struct_field<V: Visitor>(visitor: &mut V, struct_field: &StructField) {\n     visitor.visit_vis(&struct_field.vis);\n     walk_opt_ident(visitor, struct_field.span, struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n }\n \n-pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n+pub fn walk_block<V: Visitor>(visitor: &mut V, block: &Block) {\n     walk_list!(visitor, visit_stmt, &block.stmts);\n     walk_list!(visitor, visit_expr, &block.expr);\n }\n \n-pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n+pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {\n     match statement.node {\n         StmtKind::Decl(ref declaration, _) => visitor.visit_decl(declaration),\n         StmtKind::Expr(ref expression, _) | StmtKind::Semi(ref expression, _) => {\n@@ -629,18 +610,18 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     }\n }\n \n-pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n+pub fn walk_decl<V: Visitor>(visitor: &mut V, declaration: &Decl) {\n     match declaration.node {\n         DeclKind::Local(ref local) => visitor.visit_local(local),\n         DeclKind::Item(ref item) => visitor.visit_item(item),\n     }\n }\n \n-pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n+pub fn walk_mac<V: Visitor>(_: &mut V, _: &Mac) {\n     // Empty!\n }\n \n-pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n+pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n     for attr in expression.attrs.as_attr_slice() {\n         visitor.visit_attribute(attr);\n     }\n@@ -790,14 +771,14 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     visitor.visit_expr_post(expression)\n }\n \n-pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n+pub fn walk_arm<V: Visitor>(visitor: &mut V, arm: &Arm) {\n     walk_list!(visitor, visit_pat, &arm.pats);\n     walk_list!(visitor, visit_expr, &arm.guard);\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }\n \n-pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n+pub fn walk_vis<V: Visitor>(visitor: &mut V, vis: &Visibility) {\n     if let Visibility::Restricted { ref path, id } = *vis {\n         visitor.visit_path(path, id);\n     }"}, {"sha": "7d454fe38cc84f69f6dbf4f18488ff0fc5135bbe", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ea1e330ccdda85a1501078c0b997fd27ce1e72/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=33ea1e330ccdda85a1501078c0b997fd27ce1e72", "patch": "@@ -353,8 +353,8 @@ fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast\n         types: Vec<P<ast::Ty>>,\n     }\n \n-    impl<'a> visit::Visitor<'a> for Visitor<'a> {\n-        fn visit_ty(&mut self, ty: &'a ast::Ty) {\n+    impl<'a> visit::Visitor for Visitor<'a> {\n+        fn visit_ty(&mut self, ty: &ast::Ty) {\n             match ty.node {\n                 ast::TyKind::Path(_, ref path) if !path.global => {\n                     match path.segments.first() {"}]}