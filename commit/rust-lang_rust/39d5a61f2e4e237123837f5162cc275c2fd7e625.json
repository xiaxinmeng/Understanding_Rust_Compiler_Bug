{"sha": "39d5a61f2e4e237123837f5162cc275c2fd7e625", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZDVhNjFmMmU0ZTIzNzEyMzgzN2Y1MTYyY2MyNzVjMmZkN2U2MjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-17T17:25:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-17T17:25:09Z"}, "message": "Auto merge of #72983 - Lezzz:rename-typeck, r=nikomatsakis\n\nRename TypeckTables to TypeckResults.\n\nOriginally suggested by @eddyb.", "tree": {"sha": "c156b2555cc34eaec1ff7c083b66e07db68745bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c156b2555cc34eaec1ff7c083b66e07db68745bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39d5a61f2e4e237123837f5162cc275c2fd7e625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39d5a61f2e4e237123837f5162cc275c2fd7e625", "html_url": "https://github.com/rust-lang/rust/commit/39d5a61f2e4e237123837f5162cc275c2fd7e625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39d5a61f2e4e237123837f5162cc275c2fd7e625/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3014f23ddd437d2ba9947383c4565d09c1eb39f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3014f23ddd437d2ba9947383c4565d09c1eb39f2", "html_url": "https://github.com/rust-lang/rust/commit/3014f23ddd437d2ba9947383c4565d09c1eb39f2"}, {"sha": "1e6adad33f3664d7f09742b73fd97aca63d6406f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6adad33f3664d7f09742b73fd97aca63d6406f", "html_url": "https://github.com/rust-lang/rust/commit/1e6adad33f3664d7f09742b73fd97aca63d6406f"}], "stats": {"total": 2752, "additions": 1439, "deletions": 1313}, "files": [{"sha": "2864e46cadcf96c69a74029e8fe884606c37b68c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -80,7 +80,7 @@ where\n         PpmTyped => {\n             abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n \n-            let annotation = TypedAnnotation { tcx, maybe_typeck_tables: Cell::new(None) };\n+            let annotation = TypedAnnotation { tcx, maybe_typeck_results: Cell::new(None) };\n             tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().krate()))\n         }\n         _ => panic!(\"Should use call_with_pp_support\"),\n@@ -305,16 +305,18 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n \n struct TypedAnnotation<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    maybe_typeck_tables: Cell<Option<&'tcx ty::TypeckTables<'tcx>>>,\n+    maybe_typeck_results: Cell<Option<&'tcx ty::TypeckResults<'tcx>>>,\n }\n \n impl<'tcx> TypedAnnotation<'tcx> {\n-    /// Gets the type-checking side-tables for the current body.\n+    /// Gets the type-checking results for the current body.\n     /// As this will ICE if called outside bodies, only call when working with\n     /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n     #[track_caller]\n-    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n-        self.maybe_typeck_tables.get().expect(\"`TypedAnnotation::tables` called outside of body\")\n+    fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n+        self.maybe_typeck_results\n+            .get()\n+            .expect(\"`TypedAnnotation::typeck_results` called outside of body\")\n     }\n }\n \n@@ -338,13 +340,13 @@ impl<'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n \n impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.get();\n+        let old_maybe_typeck_results = self.maybe_typeck_results.get();\n         if let pprust_hir::Nested::Body(id) = nested {\n-            self.maybe_typeck_tables.set(Some(self.tcx.body_tables(id)));\n+            self.maybe_typeck_results.set(Some(self.tcx.typeck_body(id)));\n         }\n         let pp_ann = &(&self.tcx.hir() as &dyn hir::intravisit::Map<'_>);\n         pprust_hir::PpAnn::nested(pp_ann, state, nested);\n-        self.maybe_typeck_tables.set(old_maybe_typeck_tables);\n+        self.maybe_typeck_results.set(old_maybe_typeck_results);\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         if let pprust_hir::AnnNode::Expr(_) = node {\n@@ -356,7 +358,7 @@ impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n             s.s.space();\n             s.s.word(\"as\");\n             s.s.space();\n-            s.s.word(self.tables().expr_ty(expr).to_string());\n+            s.s.word(self.typeck_results().expr_ty(expr).to_string());\n             s.pclose();\n         }\n     }"}, {"sha": "f56522406b0a707f36cda83862b4bc684f47fb6b", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1571,7 +1571,7 @@ pub enum ExprKind<'hir> {\n     /// To resolve the called method to a `DefId`, call [`type_dependent_def_id`] with\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n-    /// [`type_dependent_def_id`]: ../ty/struct.TypeckTables.html#method.type_dependent_def_id\n+    /// [`type_dependent_def_id`]: ../ty/struct.TypeckResults.html#method.type_dependent_def_id\n     MethodCall(&'hir PathSegment<'hir>, Span, &'hir [Expr<'hir>], Span),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(&'hir [Expr<'hir>]),\n@@ -1659,7 +1659,7 @@ pub enum ExprKind<'hir> {\n ///\n /// To resolve the path to a `DefId`, call [`qpath_res`].\n ///\n-/// [`qpath_res`]: ../rustc_middle/ty/struct.TypeckTables.html#method.qpath_res\n+/// [`qpath_res`]: ../rustc_middle/ty/struct.TypeckResults.html#method.qpath_res\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum QPath<'hir> {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`"}, {"sha": "d48810f1cf103a0c5eee130e32e9fd23d79ab01f", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -3,9 +3,9 @@\n //! we will compare the fingerprint from the current and from the previous\n //! compilation session as appropriate:\n //!\n-//! - `#[rustc_clean(cfg=\"rev2\", except=\"typeck_tables_of\")]` if we are\n+//! - `#[rustc_clean(cfg=\"rev2\", except=\"typeck\")]` if we are\n //!   in `#[cfg(rev2)]`, then the fingerprints associated with\n-//!   `DepNode::typeck_tables_of(X)` must be DIFFERENT (`X` is the `DefId` of the\n+//!   `DepNode::typeck(X)` must be DIFFERENT (`X` is the `DefId` of the\n //!   current node).\n //! - `#[rustc_clean(cfg=\"rev2\")]` same as above, except that the\n //!   fingerprints must be the SAME (along with all other fingerprints).\n@@ -48,7 +48,7 @@ const BASE_FN: &[&str] = &[\n     label_strs::type_of,\n     // And a big part of compilation (that we eventually want to cache) is type inference\n     // information:\n-    label_strs::typeck_tables_of,\n+    label_strs::typeck,\n ];\n \n /// DepNodes for Hir, which is pretty much everything"}, {"sha": "633589db2704cd7e37ed882b7d3f64b64bfcb997", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -624,8 +624,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n                         let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n                             let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n-                            self.in_progress_tables\n-                                .and_then(|tables| tables.borrow().expr_ty_opt(arg_expr))\n+                            self.in_progress_typeck_results.and_then(|typeck_results| {\n+                                typeck_results.borrow().expr_ty_opt(arg_expr)\n+                            })\n                         } else {\n                             bug!(\"try desugaring w/out call expr as scrutinee\");\n                         };\n@@ -1683,9 +1684,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let hir = &self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n-        let generics =\n-            self.in_progress_tables.map(|table| table.borrow().hir_owner).map(|table_owner| {\n-                let hir_id = hir.as_local_hir_id(table_owner);\n+        let generics = self\n+            .in_progress_typeck_results\n+            .map(|typeck_results| typeck_results.borrow().hir_owner)\n+            .map(|owner| {\n+                let hir_id = hir.as_local_hir_id(owner);\n                 let parent_id = hir.get_parent_item(hir_id);\n                 (\n                     // Parent item could be a `mod`, so we check the HIR before calling:\n@@ -1698,7 +1701,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     } else {\n                         None\n                     },\n-                    self.tcx.generics_of(table_owner.to_def_id()),\n+                    self.tcx.generics_of(owner.to_def_id()),\n                 )\n             });\n         let type_param_span = match (generics, bound_kind) {"}, {"sha": "bf087dfacfa43c0be057c025832e47559821bd67", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -42,8 +42,10 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n     }\n \n     fn node_ty_contains_target(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n-        let ty_opt =\n-            self.infcx.in_progress_tables.and_then(|tables| tables.borrow().node_type_opt(hir_id));\n+        let ty_opt = self\n+            .infcx\n+            .in_progress_typeck_results\n+            .and_then(|typeck_results| typeck_results.borrow().node_type_opt(hir_id));\n         match ty_opt {\n             Some(ty) => {\n                 let ty = self.infcx.resolve_vars_if_possible(&ty);\n@@ -123,8 +125,11 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n         if let ExprKind::MethodCall(_, call_span, exprs, _) = expr.kind {\n             if call_span == self.target_span\n                 && Some(self.target)\n-                    == self.infcx.in_progress_tables.and_then(|tables| {\n-                        tables.borrow().node_type_opt(exprs.first().unwrap().hir_id).map(Into::into)\n+                    == self.infcx.in_progress_typeck_results.and_then(|typeck_results| {\n+                        typeck_results\n+                            .borrow()\n+                            .node_type_opt(exprs.first().unwrap().hir_id)\n+                            .map(Into::into)\n                     })\n             {\n                 self.found_exact_method_call = Some(&expr);\n@@ -580,8 +585,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         e: &Expr<'_>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n-        if let (Some(tables), None) = (self.in_progress_tables, &segment.args) {\n-            let borrow = tables.borrow();\n+        if let (Some(typeck_results), None) = (self.in_progress_typeck_results, &segment.args) {\n+            let borrow = typeck_results.borrow();\n             if let Some((DefKind::AssocFn, did)) = borrow.type_dependent_def(e.hir_id) {\n                 let generics = self.tcx.generics_of(did);\n                 if !generics.params.is_empty() {"}, {"sha": "37883fcb07468e7256f7e50b7fe2b671695860e2", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -283,11 +283,11 @@ impl<'tcx> InferCtxtInner<'tcx> {\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n-    /// During type-checking/inference of a body, `in_progress_tables`\n-    /// contains a reference to the tables being built up, which are\n+    /// During type-checking/inference of a body, `in_progress_typeck_results`\n+    /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n     /// and for error reporting logic to read arbitrary node types.\n-    pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n+    pub in_progress_typeck_results: Option<&'a RefCell<ty::TypeckResults<'tcx>>>,\n \n     pub inner: RefCell<InferCtxtInner<'tcx>>,\n \n@@ -571,7 +571,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n /// `F: for<'b, 'tcx> where 'tcx FnOnce(InferCtxt<'b, 'tcx>)`.\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n+    fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -580,15 +580,15 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { tcx: self, fresh_tables: None }\n+        InferCtxtBuilder { tcx: self, fresh_typeck_results: None }\n     }\n }\n \n impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n-    /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n-    pub fn with_fresh_in_progress_tables(mut self, table_owner: LocalDefId) -> Self {\n-        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::new(table_owner)));\n+    /// will initialize `in_progress_typeck_results` with fresh `TypeckResults`.\n+    pub fn with_fresh_in_progress_typeck_results(mut self, table_owner: LocalDefId) -> Self {\n+        self.fresh_typeck_results = Some(RefCell::new(ty::TypeckResults::new(table_owner)));\n         self\n     }\n \n@@ -616,11 +616,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { tcx, ref fresh_tables } = *self;\n-        let in_progress_tables = fresh_tables.as_ref();\n+        let InferCtxtBuilder { tcx, ref fresh_typeck_results } = *self;\n+        let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n-            in_progress_tables,\n+            in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n             selection_cache: Default::default(),\n@@ -667,7 +667,7 @@ pub struct CombinedSnapshot<'a, 'tcx> {\n     region_constraints_snapshot: RegionSnapshot,\n     universe: ty::UniverseIndex,\n     was_in_snapshot: bool,\n-    _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n+    _in_progress_typeck_results: Option<Ref<'a, ty::TypeckResults<'tcx>>>,\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -789,9 +789,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n-            // Borrow tables \"in progress\" (i.e., during typeck)\n+            // Borrow typeck results \"in progress\" (i.e., during typeck)\n             // to ban writes from within a snapshot to them.\n-            _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n+            _in_progress_typeck_results: self\n+                .in_progress_typeck_results\n+                .map(|typeck_results| typeck_results.borrow()),\n         }\n     }\n \n@@ -802,7 +804,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_constraints_snapshot,\n             universe,\n             was_in_snapshot,\n-            _in_progress_tables,\n+            _in_progress_typeck_results,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n@@ -820,7 +822,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_constraints_snapshot: _,\n             universe: _,\n             was_in_snapshot,\n-            _in_progress_tables,\n+            _in_progress_typeck_results,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);"}, {"sha": "9d74ad3b2f558c3982d89462c2b4046d2a66f851", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -31,7 +31,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n \n             // Check if the method call actually calls the libcore\n             // `IntoIterator::into_iter`.\n-            let def_id = cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n+            let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n             match cx.tcx.trait_of_item(def_id) {\n                 Some(trait_id) if cx.tcx.is_diagnostic_item(sym::IntoIterator, trait_id) => {}\n                 _ => return,\n@@ -45,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             // `Box` is the only thing that values can be moved out of via\n             // method call. `Box::new([1]).into_iter()` should trigger this\n             // lint.\n-            let mut recv_ty = cx.tables().expr_ty(receiver_arg);\n+            let mut recv_ty = cx.typeck_results().expr_ty(receiver_arg);\n             let mut num_box_derefs = 0;\n             while recv_ty.is_box() {\n                 num_box_derefs += 1;\n@@ -60,13 +60,13 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             // Make sure that there is an autoref coercion at the expected\n             // position. The first `num_box_derefs` adjustments are the derefs\n             // of the box.\n-            match cx.tables().expr_adjustments(receiver_arg).get(num_box_derefs) {\n+            match cx.typeck_results().expr_adjustments(receiver_arg).get(num_box_derefs) {\n                 Some(Adjustment { kind: Adjust::Borrow(_), .. }) => {}\n                 _ => return,\n             }\n \n             // Emit lint diagnostic.\n-            let target = match cx.tables().expr_ty_adjusted(receiver_arg).kind {\n+            let target = match cx.typeck_results().expr_ty_adjusted(receiver_arg).kind {\n                 ty::Ref(_, ty::TyS { kind: ty::Array(..), .. }, _) => \"[T; N]\",\n                 ty::Ref(_, ty::TyS { kind: ty::Slice(..), .. }, _) => \"[T]\",\n "}, {"sha": "69b564c573d6a004f0c4c8d0a1162e44f9b1cf54", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -144,7 +144,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n-        let ty = cx.tables().node_type(e.hir_id);\n+        let ty = cx.typeck_results().node_type(e.hir_id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -161,7 +161,7 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext<'_>, pat: &hir::Pat<'_>) {\n         if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n             let variant = cx\n-                .tables()\n+                .typeck_results()\n                 .pat_ty(pat)\n                 .ty_adt_def()\n                 .expect(\"struct pattern type is not an ADT\")\n@@ -178,7 +178,7 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                 }\n                 if let PatKind::Binding(binding_annot, _, ident, None) = fieldpat.pat.kind {\n                     if cx.tcx.find_field_index(ident, &variant)\n-                        == Some(cx.tcx.field_index(fieldpat.hir_id, cx.tables()))\n+                        == Some(cx.tcx.field_index(fieldpat.hir_id, cx.typeck_results()))\n                     {\n                         cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span, |lint| {\n                             let mut err = lint\n@@ -909,7 +909,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let sig = cx.tables().node_type(expr.hir_id).fn_sig(cx.tcx);\n+                let sig = cx.typeck_results().node_type(expr.hir_id).fn_sig(cx.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = sig.output().skip_binder();\n                 return Some((from, to));\n@@ -1901,7 +1901,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 }\n             } else if let hir::ExprKind::MethodCall(_, _, ref args, _) = expr.kind {\n                 // Find problematic calls to `MaybeUninit::assume_init`.\n-                let def_id = cx.tables().type_dependent_def_id(expr.hir_id)?;\n+                let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n                 if cx.tcx.is_diagnostic_item(sym::assume_init, def_id) {\n                     // This is a call to *some* method named `assume_init`.\n                     // See if the `self` parameter is one of the dangerous constructors.\n@@ -2020,7 +2020,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             // This conjures an instance of a type out of nothing,\n             // using zeroed or uninitialized memory.\n             // We are extremely conservative with what we warn about.\n-            let conjured_ty = cx.tables().expr_ty(expr);\n+            let conjured_ty = cx.typeck_results().expr_ty(expr);\n             if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n                 cx.struct_span_lint(INVALID_VALUE, expr.span, |lint| {\n                     let mut err = lint.build(&format!("}, {"sha": "84f5ea7bcda85cd11056c80acc5eb24ce132160d", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -431,11 +431,11 @@ pub struct LateContext<'tcx> {\n     /// Current body, or `None` if outside a body.\n     pub enclosing_body: Option<hir::BodyId>,\n \n-    /// Type-checking side-tables for the current body. Access using the `tables`\n-    /// and `maybe_tables` methods, which handle querying the tables on demand.\n+    /// Type-checking results for the current body. Access using the `typeck_results`\n+    /// and `maybe_typeck_results` methods, which handle querying the typeck results on demand.\n     // FIXME(eddyb) move all the code accessing internal fields like this,\n     // to this module, to avoid exposing it to lint logic.\n-    pub(super) cached_typeck_tables: Cell<Option<&'tcx ty::TypeckTables<'tcx>>>,\n+    pub(super) cached_typeck_results: Cell<Option<&'tcx ty::TypeckResults<'tcx>>>,\n \n     /// Parameter environment for the item we are in.\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -677,35 +677,35 @@ impl LintContext for EarlyContext<'_> {\n }\n \n impl<'tcx> LateContext<'tcx> {\n-    /// Gets the type-checking side-tables for the current body,\n+    /// Gets the type-checking results for the current body,\n     /// or `None` if outside a body.\n-    pub fn maybe_typeck_tables(&self) -> Option<&'tcx ty::TypeckTables<'tcx>> {\n-        self.cached_typeck_tables.get().or_else(|| {\n+    pub fn maybe_typeck_results(&self) -> Option<&'tcx ty::TypeckResults<'tcx>> {\n+        self.cached_typeck_results.get().or_else(|| {\n             self.enclosing_body.map(|body| {\n-                let tables = self.tcx.body_tables(body);\n-                self.cached_typeck_tables.set(Some(tables));\n-                tables\n+                let typeck_results = self.tcx.typeck_body(body);\n+                self.cached_typeck_results.set(Some(typeck_results));\n+                typeck_results\n             })\n         })\n     }\n \n-    /// Gets the type-checking side-tables for the current body.\n+    /// Gets the type-checking results for the current body.\n     /// As this will ICE if called outside bodies, only call when working with\n     /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n     #[track_caller]\n-    pub fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n-        self.maybe_typeck_tables().expect(\"`LateContext::tables` called outside of body\")\n+    pub fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n+        self.maybe_typeck_results().expect(\"`LateContext::typeck_results` called outside of body\")\n     }\n \n     /// Returns the final resolution of a `QPath`, or `Res::Err` if unavailable.\n-    /// Unlike `.tables().qpath_res(qpath, id)`, this can be used even outside\n+    /// Unlike `.typeck_results().qpath_res(qpath, id)`, this can be used even outside\n     /// bodies (e.g. for paths in `hir::Ty`), without any risk of ICE-ing.\n     pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.res,\n             hir::QPath::TypeRelative(..) => self\n-                .maybe_typeck_tables()\n-                .and_then(|tables| tables.type_dependent_def(id))\n+                .maybe_typeck_results()\n+                .and_then(|typeck_results| typeck_results.type_dependent_def(id))\n                 .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n         }\n     }"}, {"sha": "f43c197d2d201ace7a1fa4ea8d44bbdfa71991b6", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -105,13 +105,13 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n         let old_enclosing_body = self.context.enclosing_body.replace(body_id);\n-        let old_cached_typeck_tables = self.context.cached_typeck_tables.get();\n+        let old_cached_typeck_results = self.context.cached_typeck_results.get();\n \n-        // HACK(eddyb) avoid trashing `cached_typeck_tables` when we're\n+        // HACK(eddyb) avoid trashing `cached_typeck_results` when we're\n         // nested in `visit_fn`, which may have already resulted in them\n         // being queried.\n         if old_enclosing_body != Some(body_id) {\n-            self.context.cached_typeck_tables.set(None);\n+            self.context.cached_typeck_results.set(None);\n         }\n \n         let body = self.context.tcx.hir().body(body_id);\n@@ -120,7 +120,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n \n         // See HACK comment above.\n         if old_enclosing_body != Some(body_id) {\n-            self.context.cached_typeck_tables.set(old_cached_typeck_tables);\n+            self.context.cached_typeck_results.set(old_cached_typeck_results);\n         }\n     }\n \n@@ -191,16 +191,16 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         span: Span,\n         id: hir::HirId,\n     ) {\n-        // Wrap in tables here, not just in visit_nested_body,\n+        // Wrap in typeck results here, not just in visit_nested_body,\n         // in order for `check_fn` to be able to use them.\n         let old_enclosing_body = self.context.enclosing_body.replace(body_id);\n-        let old_cached_typeck_tables = self.context.cached_typeck_tables.take();\n+        let old_cached_typeck_results = self.context.cached_typeck_results.take();\n         let body = self.context.tcx.hir().body(body_id);\n         lint_callback!(self, check_fn, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         lint_callback!(self, check_fn_post, fk, decl, body, span, id);\n         self.context.enclosing_body = old_enclosing_body;\n-        self.context.cached_typeck_tables.set(old_cached_typeck_tables);\n+        self.context.cached_typeck_results.set(old_cached_typeck_results);\n     }\n \n     fn visit_variant_data(\n@@ -375,7 +375,7 @@ fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n     let context = LateContext {\n         tcx,\n         enclosing_body: None,\n-        cached_typeck_tables: Cell::new(None),\n+        cached_typeck_results: Cell::new(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_store: unerased_lint_store(tcx),\n@@ -423,7 +423,7 @@ fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T)\n     let context = LateContext {\n         tcx,\n         enclosing_body: None,\n-        cached_typeck_tables: Cell::new(None),\n+        cached_typeck_results: Cell::new(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_store: unerased_lint_store(tcx),"}, {"sha": "8c82765c45d43e7ae4c945876dc7da450093bff7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -168,7 +168,7 @@ fn report_bin_hex_error(\n             repr_str, val, t, actually, t\n         ));\n         if let Some(sugg_ty) =\n-            get_type_suggestion(&cx.tables().node_type(expr.hir_id), val, negative)\n+            get_type_suggestion(&cx.typeck_results().node_type(expr.hir_id), val, negative)\n         {\n             if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n                 let (sans_suffix, _) = repr_str.split_at(pos);\n@@ -302,7 +302,7 @@ fn lint_uint_literal<'tcx>(\n         if let Node::Expr(par_e) = cx.tcx.hir().get(parent_id) {\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n-                    if let ty::Char = cx.tables().expr_ty(par_e).kind {\n+                    if let ty::Char = cx.typeck_results().expr_ty(par_e).kind {\n                         cx.struct_span_lint(OVERFLOWING_LITERALS, par_e.span, |lint| {\n                             lint.build(\"only `u8` can be cast into `char`\")\n                                 .span_suggestion(\n@@ -353,7 +353,7 @@ fn lint_literal<'tcx>(\n     e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n ) {\n-    match cx.tables().node_type(e.hir_id).kind {\n+    match cx.typeck_results().node_type(e.hir_id).kind {\n         ty::Int(t) => {\n             match lit.node {\n                 ast::LitKind::Int(v, ast::LitIntType::Signed(_) | ast::LitIntType::Unsuffixed) => {\n@@ -449,7 +449,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match cx.tables().node_type(expr.hir_id).kind {\n+            match cx.typeck_results().node_type(expr.hir_id).kind {\n                 ty::Int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.kind {"}, {"sha": "6d6c7b24101ca3d3587d0185ccafefcd12bc11dc", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             return;\n         }\n \n-        let ty = cx.tables().expr_ty(&expr);\n+        let ty = cx.typeck_results().expr_ty(&expr);\n         let type_permits_lack_of_use = check_must_use_ty(cx, ty, &expr, s.span, \"\", \"\", 1);\n \n         let mut fn_warned = false;\n@@ -65,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     _ => None,\n                 }\n             }\n-            hir::ExprKind::MethodCall(..) => cx.tables().type_dependent_def_id(expr.hir_id),\n+            hir::ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n             _ => None,\n         };\n         if let Some(def_id) = maybe_def_id {\n@@ -950,7 +950,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n             _ => return,\n         }\n \n-        for adj in cx.tables().expr_adjustments(e) {\n+        for adj in cx.typeck_results().expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n                 cx.struct_span_lint(UNUSED_ALLOCATION, e.span, |lint| {\n                     let msg = match m {"}, {"sha": "a8c46d3e32e6a7fedc2ed9dd11a5bd03b00641f7", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1369,9 +1369,9 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n-        // including on the signature, which is inferred in `typeck_tables_of.\n+        // including on the signature, which is inferred in `typeck.\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n-        let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n+        let ty = self.tcx.typeck(def_id).node_type(hir_id);\n \n         record!(self.tables.kind[def_id.to_def_id()] <- match ty.kind {\n             ty::Generator(..) => {"}, {"sha": "f2259e5e9f857bece5a479903f03b361cf0ccb45", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -40,7 +40,7 @@ macro_rules! arena_types {\n                     rustc_middle::mir::Promoted,\n                     rustc_middle::mir::Body<'_x>\n                 >;\n-            [decode] tables: rustc_middle::ty::TypeckTables<$tcx>, rustc_middle::ty::TypeckTables<'_x>;\n+            [decode] typeck_results: rustc_middle::ty::TypeckResults<$tcx>, rustc_middle::ty::TypeckResults<'_x>;\n             [decode] borrowck_result:\n                 rustc_middle::mir::BorrowCheckResult<$tcx>,\n                 rustc_middle::mir::BorrowCheckResult<'_x>;"}, {"sha": "402a5c421a7b5ccbf97d28239e91bbf4a81a8f6a", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -223,7 +223,7 @@ impl Debug for GeneratorLayout<'_> {\n #[derive(Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n-    /// by this function. Unlike the value in `TypeckTables`, this has\n+    /// by this function. Unlike the value in `TypeckResults`, this has\n     /// unerased regions.\n     pub concrete_opaque_types: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,"}, {"sha": "4dd8723bd72a11d4dc4069e0c8036c41b472db8b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -583,27 +583,27 @@ rustc_queries! {\n             desc { \"type-checking all item bodies\" }\n         }\n \n-        query typeck_tables_of(key: LocalDefId) -> &'tcx ty::TypeckTables<'tcx> {\n+        query typeck(key: LocalDefId) -> &'tcx ty::TypeckResults<'tcx> {\n             desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if { true }\n         }\n-        query typeck_tables_of_const_arg(\n+        query typeck_const_arg(\n             key: (LocalDefId, DefId)\n-        ) -> &'tcx ty::TypeckTables<'tcx> {\n+        ) -> &'tcx ty::TypeckResults<'tcx> {\n             desc {\n                 |tcx| \"type-checking the const argument `{}`\",\n                 tcx.def_path_str(key.0.to_def_id()),\n             }\n         }\n-        query diagnostic_only_typeck_tables_of(key: LocalDefId) -> &'tcx ty::TypeckTables<'tcx> {\n+        query diagnostic_only_typeck(key: LocalDefId) -> &'tcx ty::TypeckResults<'tcx> {\n             desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if { true }\n             load_cached(tcx, id) {\n-                let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n+                let typeck_results: Option<ty::TypeckResults<'tcx>> = tcx\n                     .queries.on_disk_cache\n                     .try_load_query_result(tcx, id);\n \n-                typeck_tables.map(|x| &*tcx.arena.alloc(x))\n+                typeck_results.map(|x| &*tcx.arena.alloc(x))\n             }\n         }\n     }\n@@ -616,7 +616,7 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query has_typeck_tables(def_id: DefId) -> bool {\n+        query has_typeck_results(def_id: DefId) -> bool {\n             desc { |tcx| \"checking whether `{}` has a body\", tcx.def_path_str(def_id) }\n         }\n "}, {"sha": "3dd57eea2348f0b1871ef030e78975aa1206d023", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -193,17 +193,17 @@ pub struct LocalTableInContext<'a, V> {\n }\n \n /// Validate that the given HirId (respectively its `local_id` part) can be\n-/// safely used as a key in the tables of a TypeckTable. For that to be\n+/// safely used as a key in the maps of a TypeckResults. For that to be\n /// the case, the HirId must have the same `owner` as all the other IDs in\n /// this table (signified by `hir_owner`). Otherwise the HirId\n /// would be in a different frame of reference and using its `local_id`\n /// would result in lookup errors, or worse, in silently wrong data being\n /// stored/returned.\n-fn validate_hir_id_for_typeck_tables(hir_owner: LocalDefId, hir_id: hir::HirId) {\n+fn validate_hir_id_for_typeck_results(hir_owner: LocalDefId, hir_id: hir::HirId) {\n     if hir_id.owner != hir_owner {\n         ty::tls::with(|tcx| {\n             bug!(\n-                \"node {} with HirId::owner {:?} cannot be placed in TypeckTables with hir_owner {:?}\",\n+                \"node {} with HirId::owner {:?} cannot be placed in TypeckResults with hir_owner {:?}\",\n                 tcx.hir().node_to_string(hir_id),\n                 hir_id.owner,\n                 hir_owner\n@@ -214,12 +214,12 @@ fn validate_hir_id_for_typeck_tables(hir_owner: LocalDefId, hir_id: hir::HirId)\n \n impl<'a, V> LocalTableInContext<'a, V> {\n     pub fn contains_key(&self, id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.contains_key(&id.local_id)\n     }\n \n     pub fn get(&self, id: hir::HirId) -> Option<&V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.get(&id.local_id)\n     }\n \n@@ -243,22 +243,22 @@ pub struct LocalTableInContextMut<'a, V> {\n \n impl<'a, V> LocalTableInContextMut<'a, V> {\n     pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.get_mut(&id.local_id)\n     }\n \n     pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.entry(id.local_id)\n     }\n \n     pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.insert(id.local_id, val)\n     }\n \n     pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.remove(&id.local_id)\n     }\n }\n@@ -307,7 +307,7 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub struct TypeckTables<'tcx> {\n+pub struct TypeckResults<'tcx> {\n     /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n     pub hir_owner: LocalDefId,\n \n@@ -416,9 +416,9 @@ pub struct TypeckTables<'tcx> {\n     pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n }\n \n-impl<'tcx> TypeckTables<'tcx> {\n-    pub fn new(hir_owner: LocalDefId) -> TypeckTables<'tcx> {\n-        TypeckTables {\n+impl<'tcx> TypeckResults<'tcx> {\n+    pub fn new(hir_owner: LocalDefId) -> TypeckResults<'tcx> {\n+        TypeckResults {\n             hir_owner,\n             type_dependent_defs: Default::default(),\n             field_indices: Default::default(),\n@@ -459,7 +459,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n     }\n \n@@ -506,7 +506,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.node_types.get(&id.local_id).cloned()\n     }\n \n@@ -515,12 +515,12 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n     }\n \n     pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n@@ -563,7 +563,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, expr.hir_id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, expr.hir_id);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n@@ -642,7 +642,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, hir_id);\n+        validate_hir_id_for_typeck_results(self.hir_owner, hir_id);\n         self.coercion_casts.contains(&hir_id.local_id)\n     }\n \n@@ -655,9 +655,9 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let ty::TypeckTables {\n+        let ty::TypeckResults {\n             hir_owner,\n             ref type_dependent_defs,\n             ref field_indices,\n@@ -980,14 +980,14 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn typeck_tables_of_opt_const_arg(\n+    pub fn typeck_opt_const_arg(\n         self,\n         def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> &'tcx TypeckTables<'tcx> {\n+    ) -> &'tcx TypeckResults<'tcx> {\n         if let Some(param_did) = def.const_param_did {\n-            self.typeck_tables_of_const_arg((def.did, param_did))\n+            self.typeck_const_arg((def.did, param_did))\n         } else {\n-            self.typeck_tables_of(def.did)\n+            self.typeck(def.did)\n         }\n     }\n "}, {"sha": "21745977b04b1b805b9f84db86653b68ae05c486", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -76,7 +76,7 @@ pub use self::context::{\n     UserType, UserTypeAnnotationIndex,\n };\n pub use self::context::{\n-    CtxtInterners, GeneratorInteriorTypeCause, GlobalCtxt, Lift, TypeckTables,\n+    CtxtInterners, GeneratorInteriorTypeCause, GlobalCtxt, Lift, TypeckResults,\n };\n \n pub use self::instance::{Instance, InstanceDef};\n@@ -1575,7 +1575,7 @@ pub type PlaceholderConst = Placeholder<BoundVar>;\n /// in case `did` is a const argument.\n ///\n /// This is used to prevent cycle errors during typeck\n-/// as `type_of(const_arg)` depends on `typeck_tables_of(owning_body)`\n+/// as `type_of(const_arg)` depends on `typeck(owning_body)`\n /// which once again requires the type of its generic arguments.\n ///\n /// Luckily we only need to deal with const arguments once we\n@@ -2759,8 +2759,8 @@ pub enum ImplOverlapKind {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn body_tables(self, body: hir::BodyId) -> &'tcx TypeckTables<'tcx> {\n-        self.typeck_tables_of(self.hir().body_owner_def_id(body))\n+    pub fn typeck_body(self, body: hir::BodyId) -> &'tcx TypeckResults<'tcx> {\n+        self.typeck(self.hir().body_owner_def_id(body))\n     }\n \n     /// Returns an iterator of the `DefId`s for all body-owners in this\n@@ -2807,8 +2807,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         is_associated_item.then(|| self.associated_item(def_id))\n     }\n \n-    pub fn field_index(self, hir_id: hir::HirId, tables: &TypeckTables<'_>) -> usize {\n-        tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n+    pub fn field_index(self, hir_id: hir::HirId, typeck_results: &TypeckResults<'_>) -> usize {\n+        typeck_results.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n     }\n \n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {"}, {"sha": "1ba305e63fb9cc8cd06275c84c98e1df4491ae96", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -35,7 +35,7 @@ const TAG_INVALID_SPAN: u8 = 1;\n \n /// Provides an interface to incremental compilation data cached from the\n /// previous compilation session. This data will eventually include the results\n-/// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n+/// of a few selected queries (like `typeck` and `mir_optimized`) and\n /// any diagnostics that have been emitted during a query.\n pub struct OnDiskCache<'sess> {\n     // The complete cache data in serialized form."}, {"sha": "adba45facc9b4beabc61f2101a59619e6a852876", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -471,8 +471,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// This is a significant `DefId` because, when we do\n     /// type-checking, we type-check this fn item and all of its\n     /// (transitive) closures together. Therefore, when we fetch the\n-    /// `typeck_tables_of` the closure, for example, we really wind up\n-    /// fetching the `typeck_tables_of` the enclosing fn item.\n+    /// `typeck` the closure, for example, we really wind up\n+    /// fetching the `typeck` the enclosing fn item.\n     pub fn closure_base_def_id(self, def_id: DefId) -> DefId {\n         let mut def_id = def_id;\n         while self.is_closure(def_id) {"}, {"sha": "8e7c97c4a1baca8c8cac927fd02b158b0348590e", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -262,7 +262,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     .ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n-                    let tables = self.infcx.tcx.typeck_tables_of(id.expect_local());\n+                    let tables = self.infcx.tcx.typeck(id.expect_local());\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(id.expect_local());\n \n                     tables.closure_kind_origins().get(hir_id).is_none()\n@@ -966,12 +966,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         .opt_name(fn_hir_id)\n                         .map(|name| format!(\"function `{}`\", name))\n                         .unwrap_or_else(|| {\n-                            match &self\n-                                .infcx\n-                                .tcx\n-                                .typeck_tables_of(self.mir_def_id)\n-                                .node_type(fn_hir_id)\n-                                .kind\n+                            match &self.infcx.tcx.typeck(self.mir_def_id).node_type(fn_hir_id).kind\n                             {\n                                 ty::Closure(..) => \"enclosing closure\",\n                                 ty::Generator(..) => \"enclosing generator\","}, {"sha": "d8f6abd92f6b88a87dcc3fcacda7234a86f0cf77", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -107,7 +107,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(did);\n \n                     if let Some((span, name)) =\n-                        self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n+                        self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n                     {\n                         diag.span_note(\n                             *span,\n@@ -130,7 +130,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let hir_id = self.infcx.tcx.hir().as_local_hir_id(did);\n \n                 if let Some((span, name)) =\n-                    self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n+                    self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n                 {\n                     diag.span_note(\n                         *span,"}, {"sha": "ef0fe71abecb25da3c077da05de1a86b8b10661e", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -507,7 +507,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 .map(|(pos, _)| pos)\n                 .next();\n             let def_id = hir.local_def_id(item_id);\n-            let tables = self.infcx.tcx.typeck_tables_of(def_id);\n+            let tables = self.infcx.tcx.typeck(def_id);\n             if let Some(ty::FnDef(def_id, _)) =\n                 tables.node_type_opt(func.hir_id).as_ref().map(|ty| &ty.kind)\n             {"}, {"sha": "1972b7149d569fb42a1066dd06eefe71129099a8", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -150,7 +150,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     }\n \n     // Gather the upvars of a closure, if any.\n-    let tables = tcx.typeck_tables_of_opt_const_arg(def);\n+    let tables = tcx.typeck_opt_const_arg(def);\n     if let Some(ErrorReported) = tables.tainted_by_errors {\n         infcx.set_tainted_by_errors();\n     }"}, {"sha": "4846ef06a8b6ab81eadc0f946ca4bf2ef5a62702", "filename": "src/librustc_mir/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -36,9 +36,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if !self.tcx().is_closure(self.mir_def_id.to_def_id()) {\n             user_provided_sig = None;\n         } else {\n-            let typeck_tables = self.tcx().typeck_tables_of(self.mir_def_id);\n+            let typeck_results = self.tcx().typeck(self.mir_def_id);\n             user_provided_sig =\n-                match typeck_tables.user_provided_sigs.get(&self.mir_def_id.to_def_id()) {\n+                match typeck_results.user_provided_sigs.get(&self.mir_def_id.to_def_id()) {\n                     None => None,\n                     Some(user_provided_poly_sig) => {\n                         // Instantiate the canonicalized variables from"}, {"sha": "bede9b22bbb0af46888c96d1953156bb19d4b95f", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1239,7 +1239,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let body = self.body;\n-        let concrete_opaque_types = &tcx.typeck_tables_of(anon_owner_def_id).concrete_opaque_types;\n+        let concrete_opaque_types = &tcx.typeck(anon_owner_def_id).concrete_opaque_types;\n         let mut opaque_type_values = Vec::new();\n \n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);"}, {"sha": "c5aa5c5ebc7f2368fce8dd59ed78391dc0c0e593", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -515,7 +515,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let defining_ty = if self.mir_def.did.to_def_id() == closure_base_def_id {\n                     tcx.type_of(closure_base_def_id)\n                 } else {\n-                    let tables = tcx.typeck_tables_of(self.mir_def.did);\n+                    let tables = tcx.typeck(self.mir_def.did);\n                     tables.node_type(self.mir_hir_id)\n                 };\n "}, {"sha": "dc3e01f3d156128793a69a789b1b25c187fb4bac", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -291,9 +291,8 @@ pub fn const_eval_raw_provider<'tcx>(\n     let def = cid.instance.def.with_opt_param();\n \n     if let Some(def) = def.as_local() {\n-        if tcx.has_typeck_tables(def.did) {\n-            if let Some(error_reported) = tcx.typeck_tables_of_opt_const_arg(def).tainted_by_errors\n-            {\n+        if tcx.has_typeck_results(def.did) {\n+            if let Some(error_reported) = tcx.typeck_opt_const_arg(def).tainted_by_errors {\n                 return Err(ErrorHandled::Reported(error_reported));\n             }\n         }"}, {"sha": "ba462ec35eacf100f8c26cea6a9398ad6017ea73", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -396,10 +396,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let def = instance.with_opt_param();\n         if let Some(def) = def.as_local() {\n-            if self.tcx.has_typeck_tables(def.did) {\n-                if let Some(error_reported) =\n-                    self.tcx.typeck_tables_of_opt_const_arg(def).tainted_by_errors\n-                {\n+            if self.tcx.has_typeck_results(def.did) {\n+                if let Some(error_reported) = self.tcx.typeck_opt_const_arg(def).tainted_by_errors {\n                     throw_inval!(TypeckError(error_reported))\n                 }\n             }"}, {"sha": "270be98606454516c75556e848315006030428b9", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -922,7 +922,7 @@ where\n             // FIXME: This should be an assert instead of an error, but if we transmute within an\n             // array length computation, `typeck` may not have yet been run and errored out. In fact\n             // most likey we *are* running `typeck` right now. Investigate whether we can bail out\n-            // on `typeck_tables().has_errors` at all const eval entry points.\n+            // on `typeck_results().has_errors` at all const eval entry points.\n             debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n             self.tcx.sess.delay_span_bug(\n                 self.cur_span(),"}, {"sha": "84f39ac8955b6f0d91e7033801bff073e6f604f9", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -226,7 +226,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 let mut name = None;\n                 if let Some(def_id) = def_id.as_local() {\n-                    let tables = self.ecx.tcx.typeck_tables_of(def_id);\n+                    let tables = self.ecx.tcx.typeck(def_id);\n                     if let Some(upvars) = tables.closure_captures.get(&def_id.to_def_id()) {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator)."}, {"sha": "eb47195c06278d189fff0ac7c9c8204af936e97e", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -21,7 +21,10 @@ use rustc_target::spec::PanicStrategy;\n \n use super::lints;\n \n-crate fn mir_built<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) -> &'tcx ty::steal::Steal<Body<'tcx>> {\n+crate fn mir_built<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+) -> &'tcx ty::steal::Steal<Body<'tcx>> {\n     if def.const_param_did.is_none() {\n         if let const_param_did @ Some(_) = tcx.opt_const_param_of(def.did) {\n             return tcx.mir_built(ty::WithOptConstParam { const_param_did, ..def });\n@@ -68,12 +71,12 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n \n     tcx.infer_ctxt().enter(|infcx| {\n         let cx = Cx::new(&infcx, def, id);\n-        let body = if let Some(ErrorReported) = cx.tables().tainted_by_errors {\n+        let body = if let Some(ErrorReported) = cx.typeck_results().tainted_by_errors {\n             build::construct_error(cx, body_id)\n         } else if cx.body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs()[id];\n+            let fn_sig = cx.typeck_results().liberated_fn_sigs()[id];\n             let fn_def_id = tcx.hir().local_def_id(id);\n \n             let safety = match fn_sig.unsafety {\n@@ -92,7 +95,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n                     vec![ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None)]\n                 }\n                 ty::Generator(..) => {\n-                    let gen_ty = tcx.body_tables(body_id).node_type(id);\n+                    let gen_ty = tcx.typeck_body(body_id).node_type(id);\n \n                     // The resume argument may be missing, in that case we need to provide it here.\n                     // It will always be `()` in this case.\n@@ -147,7 +150,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n \n             let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n-                let gen_ty = tcx.body_tables(body_id).node_type(id);\n+                let gen_ty = tcx.typeck_body(body_id).node_type(id);\n                 let gen_sig = match gen_ty.kind {\n                     ty::Generator(_, gen_substs, ..) => gen_substs.as_generator().sig(),\n                     _ => span_bug!(tcx.hir().span(id), \"generator w/o generator type: {:?}\", ty),\n@@ -182,7 +185,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             // place to be the type of the constant because NLL typeck will\n             // equate them.\n \n-            let return_ty = cx.tables().node_type(id);\n+            let return_ty = cx.typeck_results().node_type(id);\n \n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n@@ -214,7 +217,7 @@ fn liberated_closure_env_ty(\n     closure_expr_id: hir::HirId,\n     body_id: hir::BodyId,\n ) -> Ty<'_> {\n-    let closure_ty = tcx.body_tables(body_id).node_type(closure_expr_id);\n+    let closure_ty = tcx.typeck_body(body_id).node_type(closure_expr_id);\n \n     let (closure_def_id, closure_substs) = match closure_ty.kind {\n         ty::Closure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n@@ -816,14 +819,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let tcx = self.hir.tcx();\n         let tcx_hir = tcx.hir();\n-        let hir_tables = self.hir.tables();\n+        let hir_typeck_results = self.hir.typeck_results();\n \n         // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n-        // indexed closure and we stored in a map called closure_captures in TypeckTables\n+        // indexed closure and we stored in a map called closure_captures in TypeckResults\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar\n         // debuginfo and to fill `self.upvar_mutbls`.\n-        if let Some(upvars) = hir_tables.closure_captures.get(&fn_def_id) {\n+        if let Some(upvars) = hir_typeck_results.closure_captures.get(&fn_def_id) {\n             let closure_env_arg = Local::new(1);\n             let mut closure_env_projs = vec![];\n             let mut closure_ty = self.local_decls[closure_env_arg].ty;\n@@ -841,14 +844,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.upvar_mutbls = upvars_with_tys\n                 .enumerate()\n                 .map(|(i, ((&var_id, &upvar_id), ty))| {\n-                    let capture = hir_tables.upvar_capture(upvar_id);\n+                    let capture = hir_typeck_results.upvar_capture(upvar_id);\n \n                     let mut mutability = Mutability::Not;\n                     let mut name = kw::Invalid;\n                     if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                         if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                             name = ident.name;\n-                            match hir_tables.extract_binding_mode(tcx.sess, pat.hir_id, pat.span) {\n+                            match hir_typeck_results\n+                                .extract_binding_mode(tcx.sess, pat.hir_id, pat.span)\n+                            {\n                                 Some(ty::BindByValue(hir::Mutability::Mut)) => {\n                                     mutability = Mutability::Mut;\n                                 }"}, {"sha": "a5381781d1d8074e892a954d9b0ef4a009148ca0", "filename": "src/librustc_mir_build/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -65,7 +65,7 @@ fn mirror_stmts<'a, 'tcx>(\n                 let mut pattern = cx.pattern_from_hir(&local.pat);\n \n                 if let Some(ty) = &local.ty {\n-                    if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n+                    if let Some(&user_ty) = cx.typeck_results.user_provided_types().get(ty.hir_id) {\n                         debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n                         pattern = Pat {\n                             ty: pattern.ty,\n@@ -105,7 +105,7 @@ crate fn to_expr_ref<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n     block: &'tcx hir::Block<'tcx>,\n ) -> ExprRef<'tcx> {\n-    let block_ty = cx.tables().node_type(block.hir_id);\n+    let block_ty = cx.typeck_results().node_type(block.hir_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(block.hir_id.local_id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "6e1d8a8fc40121c6539d3eaa2e8804660830b3e6", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -27,7 +27,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr<'tcx> {\n         let mut expr = make_mirror_unadjusted(cx, self);\n \n         // Now apply adjustments, if any.\n-        for adjustment in cx.tables().expr_adjustments(self) {\n+        for adjustment in cx.typeck_results().expr_adjustments(self) {\n             debug!(\"make_mirror: expr={:?} applying adjustment={:?}\", expr, adjustment);\n             expr = apply_adjustment(cx, self, expr, adjustment);\n         }\n@@ -134,7 +134,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n     expr: &'tcx hir::Expr<'tcx>,\n ) -> Expr<'tcx> {\n-    let expr_ty = cx.tables().expr_ty(expr);\n+    let expr_ty = cx.typeck_results().expr_ty(expr);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n     let kind = match expr.kind {\n@@ -147,7 +147,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         }\n \n         hir::ExprKind::Call(ref fun, ref args) => {\n-            if cx.tables().is_method_call(expr) {\n+            if cx.typeck_results().is_method_call(expr) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n@@ -157,7 +157,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n                 let method = method_callee(cx, expr, fun.span, None);\n \n-                let arg_tys = args.iter().map(|e| cx.tables().expr_ty_adjusted(e));\n+                let arg_tys = args.iter().map(|e| cx.typeck_results().expr_ty_adjusted(e));\n                 let tupled_args = Expr {\n                     ty: cx.tcx.mk_tup(arg_tys),\n                     temp_lifetime,\n@@ -187,8 +187,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                         None\n                     };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tables().node_substs(fun.hir_id);\n-                    let user_provided_types = cx.tables().user_provided_types();\n+                    let substs = cx.typeck_results().node_substs(fun.hir_id);\n+                    let user_provided_types = cx.typeck_results().user_provided_types();\n                     let user_ty = user_provided_types.get(fun.hir_id).copied().map(|mut u_ty| {\n                         if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n                             *did = adt_def.did;\n@@ -212,7 +212,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tables().node_type(fun.hir_id),\n+                        ty: cx.typeck_results().node_type(fun.hir_id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                         from_hir_call: true,\n@@ -237,7 +237,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         }\n \n         hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tables().is_method_call(expr) {\n+            if cx.typeck_results().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n                 ExprKind::AssignOp { op: bin_op(op.node), lhs: lhs.to_ref(), rhs: rhs.to_ref() }\n@@ -250,7 +250,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         },\n \n         hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-            if cx.tables().is_method_call(expr) {\n+            if cx.typeck_results().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n                 // FIXME overflow\n@@ -275,31 +275,31 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         }\n \n         hir::ExprKind::Index(ref lhs, ref index) => {\n-            if cx.tables().is_method_call(expr) {\n+            if cx.typeck_results().is_method_call(expr) {\n                 overloaded_place(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n             } else {\n                 ExprKind::Index { lhs: lhs.to_ref(), index: index.to_ref() }\n             }\n         }\n \n         hir::ExprKind::Unary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tables().is_method_call(expr) {\n+            if cx.typeck_results().is_method_call(expr) {\n                 overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n         hir::ExprKind::Unary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tables().is_method_call(expr) {\n+            if cx.typeck_results().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Unary { op: UnOp::Not, arg: arg.to_ref() }\n             }\n         }\n \n         hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tables().is_method_call(expr) {\n+            if cx.typeck_results().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n                 if let hir::ExprKind::Lit(ref lit) = arg.kind {\n@@ -316,7 +316,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         hir::ExprKind::Struct(ref qpath, ref fields, ref base) => match expr_ty.kind {\n             ty::Adt(adt, substs) => match adt.adt_kind() {\n                 AdtKind::Struct | AdtKind::Union => {\n-                    let user_provided_types = cx.tables().user_provided_types();\n+                    let user_provided_types = cx.typeck_results().user_provided_types();\n                     let user_ty = user_provided_types.get(expr.hir_id).copied();\n                     debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n                     ExprKind::Adt {\n@@ -327,18 +327,18 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                         fields: field_refs(cx, fields),\n                         base: base.as_ref().map(|base| FruInfo {\n                             base: base.to_ref(),\n-                            field_types: cx.tables().fru_field_types()[expr.hir_id].clone(),\n+                            field_types: cx.typeck_results().fru_field_types()[expr.hir_id].clone(),\n                         }),\n                     }\n                 }\n                 AdtKind::Enum => {\n-                    let res = cx.tables().qpath_res(qpath, expr.hir_id);\n+                    let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n                     match res {\n                         Res::Def(DefKind::Variant, variant_id) => {\n                             assert!(base.is_none());\n \n                             let index = adt.variant_index_with_id(variant_id);\n-                            let user_provided_types = cx.tables().user_provided_types();\n+                            let user_provided_types = cx.typeck_results().user_provided_types();\n                             let user_ty = user_provided_types.get(expr.hir_id).copied();\n                             debug!(\"make_mirror_unadjusted: (variant) user_ty={:?}\", user_ty);\n                             ExprKind::Adt {\n@@ -362,7 +362,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         },\n \n         hir::ExprKind::Closure(..) => {\n-            let closure_ty = cx.tables().expr_ty(expr);\n+            let closure_ty = cx.typeck_results().expr_ty(expr);\n             let (def_id, substs, movability) = match closure_ty.kind {\n                 ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n                 ty::Generator(def_id, substs, movability) => {\n@@ -384,7 +384,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         }\n \n         hir::ExprKind::Path(ref qpath) => {\n-            let res = cx.tables().qpath_res(qpath, expr.hir_id);\n+            let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n             convert_path_expr(cx, expr, res)\n         }\n \n@@ -433,11 +433,11 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                             };\n                             let temp_lifetime =\n                                 cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-                            let res = cx.tables().qpath_res(qpath, expr.hir_id);\n+                            let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n                             let ty;\n                             match res {\n                                 Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n-                                    ty = cx.tables().node_type(expr.hir_id);\n+                                    ty = cx.typeck_results().node_type(expr.hir_id);\n                                     let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n                                     InlineAsmOperand::SymFn {\n                                         expr: Expr {\n@@ -523,11 +523,11 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         }\n         hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n             lhs: source.to_ref(),\n-            name: Field::new(cx.tcx.field_index(expr.hir_id, cx.tables)),\n+            name: Field::new(cx.tcx.field_index(expr.hir_id, cx.typeck_results)),\n         },\n         hir::ExprKind::Cast(ref source, ref cast_ty) => {\n             // Check for a user-given type annotation on this `cast`\n-            let user_provided_types = cx.tables.user_provided_types();\n+            let user_provided_types = cx.typeck_results.user_provided_types();\n             let user_ty = user_provided_types.get(cast_ty.hir_id);\n \n             debug!(\n@@ -537,10 +537,10 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            let cast = if cx.tables().is_coercion_cast(source.hir_id) {\n+            let cast = if cx.typeck_results().is_coercion_cast(source.hir_id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n-            } else if cx.tables().expr_ty(source).is_region_ptr() {\n+            } else if cx.typeck_results().expr_ty(source).is_region_ptr() {\n                 // Special cased so that we can type check that the element\n                 // type of the source matches the pointed to type of the\n                 // destination.\n@@ -558,9 +558,9 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 // The correct solution would be to add symbolic computations to miri,\n                 // so we wouldn't have to compute and store the actual value\n                 let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n-                    let res = cx.tables().qpath_res(qpath, source.hir_id);\n-                    cx.tables().node_type(source.hir_id).ty_adt_def().and_then(\n-                        |adt_def| match res {\n+                    let res = cx.typeck_results().qpath_res(qpath, source.hir_id);\n+                    cx.typeck_results().node_type(source.hir_id).ty_adt_def().and_then(|adt_def| {\n+                        match res {\n                             Res::Def(\n                                 DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n                                 variant_ctor_id,\n@@ -573,8 +573,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                                 Some((d, o, ty))\n                             }\n                             _ => None,\n-                        },\n-                    )\n+                        }\n+                    })\n                 } else {\n                     None\n                 };\n@@ -634,7 +634,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             }\n         }\n         hir::ExprKind::Type(ref source, ref ty) => {\n-            let user_provided_types = cx.tables.user_provided_types();\n+            let user_provided_types = cx.typeck_results.user_provided_types();\n             let user_ty = user_provided_types.get(ty.hir_id).copied();\n             debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n             if source.is_syntactic_place_expr() {\n@@ -670,7 +670,7 @@ fn user_substs_applied_to_res<'tcx>(\n         | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n         | Res::Def(DefKind::Const, _)\n         | Res::Def(DefKind::AssocConst, _) => {\n-            cx.tables().user_provided_types().get(hir_id).copied()\n+            cx.typeck_results().user_provided_types().get(hir_id).copied()\n         }\n \n         // A unit struct/variant which is used as a value (e.g.,\n@@ -701,12 +701,12 @@ fn method_callee<'a, 'tcx>(\n         Some((def_id, substs)) => (def_id, substs, None),\n         None => {\n             let (kind, def_id) = cx\n-                .tables()\n+                .typeck_results()\n                 .type_dependent_def(expr.hir_id)\n                 .unwrap_or_else(|| span_bug!(expr.span, \"no type-dependent def for method callee\"));\n             let user_ty = user_substs_applied_to_res(cx, expr.hir_id, Res::Def(kind, def_id));\n             debug!(\"method_callee: user_ty={:?}\", user_ty);\n-            (def_id, cx.tables().node_substs(expr.hir_id), user_ty)\n+            (def_id, cx.typeck_results().node_substs(expr.hir_id), user_ty)\n         }\n     };\n     let ty = cx.tcx().mk_fn_def(def_id, substs);\n@@ -765,7 +765,7 @@ fn convert_path_expr<'a, 'tcx>(\n     expr: &'tcx hir::Expr<'tcx>,\n     res: Res,\n ) -> ExprKind<'tcx> {\n-    let substs = cx.tables().node_substs(expr.hir_id);\n+    let substs = cx.typeck_results().node_substs(expr.hir_id);\n     match res {\n         // A regular function, constructor function or a constant.\n         Res::Def(DefKind::Fn, _)\n@@ -775,7 +775,7 @@ fn convert_path_expr<'a, 'tcx>(\n             let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n             debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n-                literal: ty::Const::zero_sized(cx.tcx, cx.tables().node_type(expr.hir_id)),\n+                literal: ty::Const::zero_sized(cx.tcx, cx.typeck_results().node_type(expr.hir_id)),\n                 user_ty,\n             }\n         }\n@@ -790,7 +790,9 @@ fn convert_path_expr<'a, 'tcx>(\n             let name = cx.tcx.hir().name(hir_id);\n             let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n-                literal: cx.tcx.mk_const(ty::Const { val, ty: cx.tables().node_type(expr.hir_id) }),\n+                literal: cx\n+                    .tcx\n+                    .mk_const(ty::Const { val, ty: cx.typeck_results().node_type(expr.hir_id) }),\n                 user_ty: None,\n             }\n         }\n@@ -805,17 +807,17 @@ fn convert_path_expr<'a, 'tcx>(\n                         substs,\n                         None,\n                     ),\n-                    ty: cx.tables().node_type(expr.hir_id),\n+                    ty: cx.typeck_results().node_type(expr.hir_id),\n                 }),\n                 user_ty,\n             }\n         }\n \n         Res::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {\n-            let user_provided_types = cx.tables.user_provided_types();\n+            let user_provided_types = cx.typeck_results.user_provided_types();\n             let user_provided_type = user_provided_types.get(expr.hir_id).copied();\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n-            let ty = cx.tables().node_type(expr.hir_id);\n+            let ty = cx.typeck_results().node_type(expr.hir_id);\n             match ty.kind {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n@@ -860,7 +862,7 @@ fn convert_var<'tcx>(\n     var_hir_id: hir::HirId,\n ) -> ExprKind<'tcx> {\n     let upvar_index = cx\n-        .tables()\n+        .typeck_results()\n         .closure_captures\n         .get(&cx.body_owner)\n         .and_then(|upvars| upvars.get_full(&var_hir_id).map(|(i, _, _)| i));\n@@ -881,11 +883,11 @@ fn convert_var<'tcx>(\n                 var_path: ty::UpvarPath { hir_id: var_hir_id },\n                 closure_expr_id: closure_def_id.expect_local(),\n             };\n-            let var_ty = cx.tables().node_type(var_hir_id);\n+            let var_ty = cx.typeck_results().node_type(var_hir_id);\n \n             // FIXME free regions in closures are not right\n             let closure_ty = cx\n-                .tables()\n+                .typeck_results()\n                 .node_type(cx.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n \n             // FIXME we're just hard-coding the idea that the\n@@ -956,7 +958,7 @@ fn convert_var<'tcx>(\n \n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n-            match cx.tables().upvar_capture(upvar_id) {\n+            match cx.typeck_results().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => ExprKind::Deref {\n                     arg: Expr {\n@@ -1018,7 +1020,7 @@ fn overloaded_place<'a, 'tcx>(\n     // line up (this is because `*x` and `x[y]` represent places):\n \n     let recv_ty = match args[0] {\n-        ExprRef::Hair(e) => cx.tables().expr_ty_adjusted(e),\n+        ExprRef::Hair(e) => cx.typeck_results().expr_ty_adjusted(e),\n         ExprRef::Mirror(ref e) => e.ty,\n     };\n \n@@ -1062,9 +1064,9 @@ fn capture_upvar<'tcx>(\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n         closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id),\n     };\n-    let upvar_capture = cx.tables().upvar_capture(upvar_id);\n+    let upvar_capture = cx.typeck_results().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-    let var_ty = cx.tables().node_type(var_hir_id);\n+    let var_ty = cx.typeck_results().node_type(var_hir_id);\n     let captured_var = Expr {\n         temp_lifetime,\n         ty: var_ty,\n@@ -1098,7 +1100,7 @@ fn field_refs<'a, 'tcx>(\n     fields\n         .iter()\n         .map(|field| FieldExprRef {\n-            name: Field::new(cx.tcx.field_index(field.hir_id, cx.tables)),\n+            name: Field::new(cx.tcx.field_index(field.hir_id, cx.typeck_results)),\n             expr: field.expr.to_ref(),\n         })\n         .collect()"}, {"sha": "2694cde14fde70e44db9a5cbf6660c67bd226921", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -33,7 +33,7 @@ crate struct Cx<'a, 'tcx> {\n     crate identity_substs: &'tcx InternalSubsts<'tcx>,\n \n     crate region_scope_tree: &'tcx region::ScopeTree,\n-    crate tables: &'a ty::TypeckTables<'tcx>,\n+    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n \n     /// This is `Constness::Const` if we are compiling a `static`,\n     /// `const`, or the body of a `const fn`.\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         src_id: hir::HirId,\n     ) -> Cx<'a, 'tcx> {\n         let tcx = infcx.tcx;\n-        let tables = tcx.typeck_tables_of_opt_const_arg(def);\n+        let typeck_results = tcx.typeck_opt_const_arg(def);\n         let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n \n         let constness = match body_owner_kind {\n@@ -84,7 +84,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             param_env: tcx.param_env(def.did),\n             identity_substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n-            tables,\n+            typeck_results,\n             constness,\n             body_owner: def.did.to_def_id(),\n             body_owner_kind,\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node),\n         };\n-        Pat::from_hir(self.tcx, self.param_env, self.tables(), p)\n+        Pat::from_hir(self.tcx, self.param_env, self.typeck_results(), p)\n     }\n \n     crate fn trait_method(\n@@ -191,8 +191,8 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         self.tcx\n     }\n \n-    crate fn tables(&self) -> &'a ty::TypeckTables<'tcx> {\n-        self.tables\n+    crate fn typeck_results(&self) -> &'a ty::TypeckResults<'tcx> {\n+        self.typeck_results\n     }\n \n     crate fn check_overflow(&self) -> bool {\n@@ -209,8 +209,8 @@ impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n         self.tcx()\n     }\n \n-    fn tables(&self) -> &ty::TypeckTables<'tcx> {\n-        self.tables()\n+    fn typeck_results(&self) -> &ty::TypeckResults<'tcx> {\n+        self.typeck_results()\n     }\n }\n "}, {"sha": "744f319205f94a18bf18eaec1699344d9d346c72", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -28,7 +28,7 @@ crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n \n     let mut visitor = MatchVisitor {\n         tcx,\n-        tables: tcx.body_tables(body_id),\n+        typeck_results: tcx.typeck_body(body_id),\n         param_env: tcx.param_env(def_id),\n         pattern_arena: TypedArena::default(),\n     };\n@@ -41,7 +41,7 @@ fn create_e0004(sess: &Session, sp: Span, error_message: String) -> DiagnosticBu\n \n struct MatchVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     pattern_arena: TypedArena<super::Pat<'tcx>>,\n }\n@@ -136,7 +136,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         pat: &'tcx hir::Pat<'tcx>,\n         have_errors: &mut bool,\n     ) -> (&'p super::Pat<'tcx>, Ty<'tcx>) {\n-        let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n+        let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.typeck_results);\n         patcx.include_lint_checks();\n         let pattern = patcx.lower_pattern(pat);\n         let pattern_ty = pattern.ty;\n@@ -190,7 +190,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         // Fifth, check if the match is exhaustive.\n         // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n         // since an empty matrix can occur when there are arms, if those arms all have guards.\n-        let scrut_ty = self.tables.expr_ty_adjusted(scrut);\n+        let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n         let is_empty_match = inlined_arms.is_empty();\n         check_exhaustive(&mut cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n     }\n@@ -286,9 +286,9 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n     pat.walk_always(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(ty::BindByValue(hir::Mutability::Not)) =\n-                cx.tables.extract_binding_mode(cx.tcx.sess, p.hir_id, p.span)\n+                cx.typeck_results.extract_binding_mode(cx.tcx.sess, p.hir_id, p.span)\n             {\n-                let pat_ty = cx.tables.pat_ty(p).peel_refs();\n+                let pat_ty = cx.typeck_results.pat_ty(p).peel_refs();\n                 if let ty::Adt(edef, _) = pat_ty.kind {\n                     if edef.is_enum()\n                         && edef.variants.iter().any(|variant| {\n@@ -598,18 +598,20 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n \n /// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> bool {\n-    !cx.tables.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n+    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n }\n \n /// Check the legality of legality of by-move bindings.\n fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat<'_>) {\n     let sess = cx.tcx.sess;\n-    let tables = cx.tables;\n+    let typeck_results = cx.typeck_results;\n \n     // Find all by-ref spans.\n     let mut by_ref_spans = Vec::new();\n     pat.each_binding(|_, hir_id, span, _| {\n-        if let Some(ty::BindByReference(_)) = tables.extract_binding_mode(sess, hir_id, span) {\n+        if let Some(ty::BindByReference(_)) =\n+            typeck_results.extract_binding_mode(sess, hir_id, span)\n+        {\n             by_ref_spans.push(span);\n         }\n     });\n@@ -630,7 +632,9 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     };\n     pat.walk_always(|p| {\n         if let hir::PatKind::Binding(.., sub) = &p.kind {\n-            if let Some(ty::BindByValue(_)) = tables.extract_binding_mode(sess, p.hir_id, p.span) {\n+            if let Some(ty::BindByValue(_)) =\n+                typeck_results.extract_binding_mode(sess, p.hir_id, p.span)\n+            {\n                 if is_binding_by_move(cx, p.hir_id, p.span) {\n                     check_move(p, sub.as_deref());\n                 }\n@@ -674,16 +678,16 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_\n     };\n     let binding_span = pat.span.with_hi(name.span.hi());\n \n-    let tables = cx.tables;\n+    let typeck_results = cx.typeck_results;\n     let sess = cx.tcx.sess;\n \n     // Get the binding move, extract the mutability if by-ref.\n-    let mut_outer = match tables.extract_binding_mode(sess, pat.hir_id, pat.span) {\n+    let mut_outer = match typeck_results.extract_binding_mode(sess, pat.hir_id, pat.span) {\n         Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id, pat.span) => {\n             // We have `x @ pat` where `x` is by-move. Reject all borrows in `pat`.\n             let mut conflicts_ref = Vec::new();\n             sub.each_binding(|_, hir_id, span, _| {\n-                match tables.extract_binding_mode(sess, hir_id, span) {\n+                match typeck_results.extract_binding_mode(sess, hir_id, span) {\n                     Some(ty::BindByValue(_)) | None => {}\n                     Some(ty::BindByReference(_)) => conflicts_ref.push(span),\n                 }\n@@ -692,7 +696,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_\n                 let occurs_because = format!(\n                     \"move occurs because `{}` has type `{}` which does not implement the `Copy` trait\",\n                     name,\n-                    tables.node_type(pat.hir_id),\n+                    typeck_results.node_type(pat.hir_id),\n                 );\n                 sess.struct_span_err(pat.span, \"borrow of moved value\")\n                     .span_label(binding_span, format!(\"value moved into `{}` here\", name))\n@@ -712,7 +716,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_\n     let mut conflicts_mut_mut = Vec::new();\n     let mut conflicts_mut_ref = Vec::new();\n     sub.each_binding(|_, hir_id, span, name| {\n-        match tables.extract_binding_mode(sess, hir_id, span) {\n+        match typeck_results.extract_binding_mode(sess, hir_id, span) {\n             Some(ty::BindByReference(mut_inner)) => match (mut_outer, mut_inner) {\n                 (Mutability::Not, Mutability::Not) => {} // Both sides are `ref`.\n                 (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push((span, name)), // 2x `ref mut`."}, {"sha": "4fa23906a35684c0b3048eba6a1155885f1a9393", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -349,7 +349,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n crate struct PatCtxt<'a, 'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     crate param_env: ty::ParamEnv<'tcx>,\n-    crate tables: &'a ty::TypeckTables<'tcx>,\n+    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n     crate errors: Vec<PatternError>,\n     include_lint_checks: bool,\n }\n@@ -358,10 +358,10 @@ impl<'a, 'tcx> Pat<'tcx> {\n     crate fn from_hir(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        tables: &'a ty::TypeckTables<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n         pat: &'tcx hir::Pat<'tcx>,\n     ) -> Self {\n-        let mut pcx = PatCtxt::new(tcx, param_env, tables);\n+        let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n             let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n@@ -376,9 +376,9 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        tables: &'a ty::TypeckTables<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> Self {\n-        PatCtxt { tcx, param_env, tables, errors: vec![], include_lint_checks: false }\n+        PatCtxt { tcx, param_env, typeck_results, errors: vec![], include_lint_checks: false }\n     }\n \n     crate fn include_lint_checks(&mut self) -> &mut Self {\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         // adjustments in *reverse order* (last-in-first-out, so that the last `Deref` inserted\n         // gets the least-dereferenced type).\n         let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n-        self.tables.pat_adjustments().get(pat.hir_id).unwrap_or(&vec![]).iter().rev().fold(\n+        self.typeck_results.pat_adjustments().get(pat.hir_id).unwrap_or(&vec![]).iter().rev().fold(\n             unadjusted_pat,\n             |pat, ref_ty| {\n                 debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     }\n \n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n-        let mut ty = self.tables.node_type(pat.hir_id);\n+        let mut ty = self.typeck_results.node_type(pat.hir_id);\n \n         if let ty::Error(_) = ty.kind {\n             // Avoid ICEs (e.g., #50577 and #50585).\n@@ -573,8 +573,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             hir::PatKind::Binding(_, id, ident, ref sub) => {\n-                let bm =\n-                    *self.tables.pat_binding_modes().get(pat.hir_id).expect(\"missing binding mode\");\n+                let bm = *self\n+                    .typeck_results\n+                    .pat_binding_modes()\n+                    .get(pat.hir_id)\n+                    .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n                     ty::BindByValue(mutbl) => (mutbl, BindingMode::ByValue),\n                     ty::BindByReference(hir::Mutability::Mut) => (\n@@ -609,7 +612,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             hir::PatKind::TupleStruct(ref qpath, ref pats, ddpos) => {\n-                let res = self.tables.qpath_res(qpath, pat.hir_id);\n+                let res = self.typeck_results.qpath_res(qpath, pat.hir_id);\n                 let adt_def = match ty.kind {\n                     ty::Adt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT {:?}\", ty),\n@@ -620,11 +623,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             hir::PatKind::Struct(ref qpath, ref fields, _) => {\n-                let res = self.tables.qpath_res(qpath, pat.hir_id);\n+                let res = self.typeck_results.qpath_res(qpath, pat.hir_id);\n                 let subpatterns = fields\n                     .iter()\n                     .map(|field| FieldPat {\n-                        field: Field::new(self.tcx.field_index(field.hir_id, self.tables)),\n+                        field: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n                         pattern: self.lower_pattern(&field.pat),\n                     })\n                     .collect();\n@@ -764,8 +767,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// it to `const_to_pat`. Any other path (like enum variants without fields)\n     /// is converted to the corresponding pattern via `lower_variant_or_leaf`.\n     fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Pat<'tcx> {\n-        let ty = self.tables.node_type(id);\n-        let res = self.tables.qpath_res(qpath, id);\n+        let ty = self.typeck_results.node_type(id);\n+        let res = self.typeck_results.qpath_res(qpath, id);\n \n         let pat_from_kind = |kind| Pat { span, ty, kind: Box::new(kind) };\n \n@@ -779,7 +782,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         // Use `Reveal::All` here because patterns are always monomorphic even if their function\n         // isn't.\n         let param_env_reveal_all = self.param_env.with_reveal_all();\n-        let substs = self.tables.node_substs(id);\n+        let substs = self.typeck_results.node_substs(id);\n         let instance = match ty::Instance::resolve(self.tcx, param_env_reveal_all, def_id, substs) {\n             Ok(Some(i)) => i,\n             Ok(None) => {\n@@ -806,15 +809,16 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n             Ok(value) => {\n-                let const_ = ty::Const::from_value(self.tcx, value, self.tables.node_type(id));\n+                let const_ =\n+                    ty::Const::from_value(self.tcx, value, self.typeck_results.node_type(id));\n \n                 let pattern = self.const_to_pat(&const_, id, span, mir_structural_match_violation);\n \n                 if !is_associated_const {\n                     return pattern;\n                 }\n \n-                let user_provided_types = self.tables().user_provided_types();\n+                let user_provided_types = self.typeck_results().user_provided_types();\n                 if let Some(u_ty) = user_provided_types.get(id) {\n                     let user_ty = PatTyProj::from_user_type(*u_ty);\n                     Pat {\n@@ -862,7 +866,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n             };\n \n-            let lit_input = LitToConstInput { lit: &lit.node, ty: self.tables.expr_ty(expr), neg };\n+            let lit_input =\n+                LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n             match self.tcx.at(expr.span).lit_to_const(lit_input) {\n                 Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span, false).kind,\n                 Err(LitToConstError::UnparseableFloat) => {\n@@ -881,8 +886,8 @@ impl<'tcx> UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n         self.tcx\n     }\n \n-    fn tables(&self) -> &ty::TypeckTables<'tcx> {\n-        self.tables\n+    fn typeck_results(&self) -> &ty::TypeckResults<'tcx> {\n+        self.typeck_results\n     }\n }\n "}, {"sha": "7de60ddda41a3fcbdba2b65c3006bf27d88838b5", "filename": "src/librustc_mir_build/hair/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_mir_build%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Futil.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -4,7 +4,7 @@ use rustc_middle::ty::{self, CanonicalUserType, TyCtxt, UserType};\n crate trait UserAnnotatedTyHelpers<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n-    fn tables(&self) -> &ty::TypeckTables<'tcx>;\n+    fn typeck_results(&self) -> &ty::TypeckResults<'tcx>;\n \n     /// Looks up the type associated with this hir-id and applies the\n     /// user-given substitutions; the hir-id must map to a suitable\n@@ -13,10 +13,10 @@ crate trait UserAnnotatedTyHelpers<'tcx> {\n         &self,\n         hir_id: hir::HirId,\n     ) -> Option<CanonicalUserType<'tcx>> {\n-        let user_provided_types = self.tables().user_provided_types();\n+        let user_provided_types = self.typeck_results().user_provided_types();\n         let mut user_ty = *user_provided_types.get(hir_id)?;\n         debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n-        let ty = self.tables().node_type(hir_id);\n+        let ty = self.typeck_results().node_type(hir_id);\n         match ty.kind {\n             ty::Adt(adt_def, ..) => {\n                 if let UserType::TypeOf(ref mut did, _) = &mut user_ty.value {"}, {"sha": "ab75c8ebf4c89f13469aa3c6d37243adf9b04e35", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -40,7 +40,7 @@ fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n struct MarkSymbolVisitor<'tcx> {\n     worklist: Vec<hir::HirId>,\n     tcx: TyCtxt<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n     live_symbols: FxHashSet<hir::HirId>,\n     repr_has_repr_c: bool,\n     in_pat: bool,\n@@ -51,12 +51,13 @@ struct MarkSymbolVisitor<'tcx> {\n }\n \n impl<'tcx> MarkSymbolVisitor<'tcx> {\n-    /// Gets the type-checking side-tables for the current body.\n+    /// Gets the type-checking results for the current body.\n     /// As this will ICE if called outside bodies, only call when working with\n     /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n     #[track_caller]\n-    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n-        self.maybe_typeck_tables.expect(\"`MarkSymbolVisitor::tables` called outside of body\")\n+    fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n+        self.maybe_typeck_results\n+            .expect(\"`MarkSymbolVisitor::typeck_results` called outside of body\")\n     }\n \n     fn check_def_id(&mut self, def_id: DefId) {\n@@ -115,17 +116,17 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     }\n \n     fn lookup_and_handle_method(&mut self, id: hir::HirId) {\n-        if let Some(def_id) = self.tables().type_dependent_def_id(id) {\n+        if let Some(def_id) = self.typeck_results().type_dependent_def_id(id) {\n             self.check_def_id(def_id);\n         } else {\n             bug!(\"no type-dependent def for method\");\n         }\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr<'_>, hir_id: hir::HirId) {\n-        match self.tables().expr_ty_adjusted(lhs).kind {\n+        match self.typeck_results().expr_ty_adjusted(lhs).kind {\n             ty::Adt(def, _) => {\n-                let index = self.tcx.field_index(hir_id, self.tables());\n+                let index = self.tcx.field_index(hir_id, self.typeck_results());\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::Tuple(..) => {}\n@@ -139,15 +140,15 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         res: Res,\n         pats: &[hir::FieldPat<'_>],\n     ) {\n-        let variant = match self.tables().node_type(lhs.hir_id).kind {\n+        let variant = match self.typeck_results().node_type(lhs.hir_id).kind {\n             ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\"),\n         };\n         for pat in pats {\n             if let PatKind::Wild = pat.pat.kind {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.hir_id, self.tables());\n+            let index = self.tcx.field_index(pat.hir_id, self.typeck_results());\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -212,7 +213,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &[hir::Field<'_>]) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n             for field in fields {\n-                let index = self.tcx.field_index(field.hir_id, self.tables());\n+                let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n                 self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }\n@@ -227,10 +228,11 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n+        let old_maybe_typeck_results =\n+            self.maybe_typeck_results.replace(self.tcx.typeck_body(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn visit_variant_data(\n@@ -255,7 +257,7 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         match expr.kind {\n             hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let res = self.tables().qpath_res(qpath, expr.hir_id);\n+                let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n                 self.handle_res(res);\n             }\n             hir::ExprKind::MethodCall(..) => {\n@@ -265,9 +267,9 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n                 self.handle_field_access(&lhs, expr.hir_id);\n             }\n             hir::ExprKind::Struct(ref qpath, ref fields, _) => {\n-                let res = self.tables().qpath_res(qpath, expr.hir_id);\n+                let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n                 self.handle_res(res);\n-                if let ty::Adt(ref adt, _) = self.tables().expr_ty(expr).kind {\n+                if let ty::Adt(ref adt, _) = self.typeck_results().expr_ty(expr).kind {\n                     self.mark_as_used_if_union(adt, fields);\n                 }\n             }\n@@ -290,11 +292,11 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n     fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         match pat.kind {\n             PatKind::Struct(ref path, ref fields, _) => {\n-                let res = self.tables().qpath_res(path, pat.hir_id);\n+                let res = self.typeck_results().qpath_res(path, pat.hir_id);\n                 self.handle_field_pattern_match(pat, res, fields);\n             }\n             PatKind::Path(ref qpath) => {\n-                let res = self.tables().qpath_res(qpath, pat.hir_id);\n+                let res = self.typeck_results().qpath_res(qpath, pat.hir_id);\n                 self.handle_res(res);\n             }\n             _ => (),\n@@ -480,7 +482,7 @@ fn find_live<'tcx>(\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n         tcx,\n-        maybe_typeck_tables: None,\n+        maybe_typeck_results: None,\n         live_symbols: Default::default(),\n         repr_has_repr_c: false,\n         in_pat: false,"}, {"sha": "931a8cb5f7d02e19ce05b7207e95a926be5a9c14", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -28,7 +28,7 @@ struct ItemVisitor<'tcx> {\n \n struct ExprVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    tables: &'tcx ty::TypeckTables<'tcx>,\n+    typeck_results: &'tcx ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -142,7 +142,7 @@ impl ExprVisitor<'tcx> {\n         tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n     ) -> Option<InlineAsmType> {\n         // Check the type against the allowed types for inline asm.\n-        let ty = self.tables.expr_ty_adjusted(expr);\n+        let ty = self.typeck_results.expr_ty_adjusted(expr);\n         let asm_ty_isize = match self.tcx.sess.target.ptr_width {\n             16 => InlineAsmType::I16,\n             32 => InlineAsmType::I32,\n@@ -236,7 +236,7 @@ impl ExprVisitor<'tcx> {\n                 let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n                 err.span_label(\n                     in_expr.span,\n-                    &format!(\"type `{}`\", self.tables.expr_ty_adjusted(in_expr)),\n+                    &format!(\"type `{}`\", self.typeck_results.expr_ty_adjusted(in_expr)),\n                 );\n                 err.span_label(expr.span, &format!(\"type `{}`\", ty));\n                 err.note(\n@@ -373,7 +373,7 @@ impl ExprVisitor<'tcx> {\n                     }\n                 }\n                 hir::InlineAsmOperand::Const { ref expr } => {\n-                    let ty = self.tables.expr_ty_adjusted(expr);\n+                    let ty = self.typeck_results.expr_ty_adjusted(expr);\n                     match ty.kind {\n                         ty::Int(_) | ty::Uint(_) | ty::Float(_) => {}\n                         _ => {\n@@ -400,8 +400,8 @@ impl Visitor<'tcx> for ItemVisitor<'tcx> {\n         let owner_def_id = self.tcx.hir().body_owner_def_id(body_id);\n         let body = self.tcx.hir().body(body_id);\n         let param_env = self.tcx.param_env(owner_def_id.to_def_id());\n-        let tables = self.tcx.typeck_tables_of(owner_def_id);\n-        ExprVisitor { tcx: self.tcx, param_env, tables }.visit_body(body);\n+        let typeck_results = self.tcx.typeck(owner_def_id);\n+        ExprVisitor { tcx: self.tcx, param_env, typeck_results }.visit_body(body);\n         self.visit_body(body);\n     }\n }\n@@ -416,10 +416,10 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         match expr.kind {\n             hir::ExprKind::Path(ref qpath) => {\n-                let res = self.tables.qpath_res(qpath, expr.hir_id);\n+                let res = self.typeck_results.qpath_res(qpath, expr.hir_id);\n                 if let Res::Def(DefKind::Fn, did) = res {\n                     if self.def_id_is_transmute(did) {\n-                        let typ = self.tables.node_type(expr.hir_id);\n+                        let typ = self.typeck_results.node_type(expr.hir_id);\n                         let sig = typ.fn_sig(self.tcx);\n                         let from = sig.inputs().skip_binder()[0];\n                         let to = sig.output().skip_binder();"}, {"sha": "45193c4556962bcac596243c78a3d8bd6f7a7a7c", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -650,7 +650,7 @@ const ACC_USE: u32 = 4;\n \n struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n@@ -670,15 +670,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             exit_ln: ir.add_live_node(ExitNode),\n         };\n \n-        let tables = ir.tcx.typeck_tables_of(def_id);\n+        let typeck_results = ir.tcx.typeck(def_id);\n         let param_env = ir.tcx.param_env(def_id);\n \n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n \n         Liveness {\n             ir,\n-            tables,\n+            typeck_results,\n             param_env,\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n@@ -939,7 +939,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: self.ir.body_owner,\n                 };\n-                match self.tables.upvar_capture(upvar_id) {\n+                match self.typeck_results.upvar_capture(upvar_id) {\n                     ty::UpvarCapture::ByRef(_) => {\n                         let var = self.variable(var_hir_id, upvar.span);\n                         self.acc(self.s.exit_ln, var, ACC_READ | ACC_USE);\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             FnKind::Closure(..) => {}\n         }\n \n-        let ty = self.tables.node_type(id);\n+        let ty = self.typeck_results.node_type(id);\n         match ty.kind {\n             ty::Closure(_def_id, substs) => match substs.as_closure().kind() {\n                 ty::ClosureKind::Fn => {}\n@@ -1151,7 +1151,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::AssignOp(_, ref l, ref r) => {\n                 // an overloaded assign op is like a method call\n-                if self.tables.is_method_call(expr) {\n+                if self.typeck_results.is_method_call(expr) {\n                     let succ = self.propagate_through_expr(&l, succ);\n                     self.propagate_through_expr(&r, succ)\n                 } else {\n@@ -1178,7 +1178,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(\n                     m,\n-                    self.tables.expr_ty(expr),\n+                    self.typeck_results.expr_ty(expr),\n                     self.param_env,\n                 ) {\n                     self.s.exit_ln\n@@ -1193,7 +1193,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(\n                     m,\n-                    self.tables.expr_ty(expr),\n+                    self.typeck_results.expr_ty(expr),\n                     self.param_env,\n                 ) {\n                     self.s.exit_ln\n@@ -1497,7 +1497,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n         }\n \n         hir::ExprKind::AssignOp(_, ref l, _) => {\n-            if !this.tables.is_method_call(expr) {\n+            if !this.typeck_results.is_method_call(expr) {\n                 this.check_place(&l);\n             }\n         }\n@@ -1607,7 +1607,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 var_path: ty::UpvarPath { hir_id: var_hir_id },\n                 closure_expr_id: self.ir.body_owner,\n             };\n-            match self.tables.upvar_capture(upvar_id) {\n+            match self.typeck_results.upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => {}\n                 ty::UpvarCapture::ByRef(..) => continue,\n             };"}, {"sha": "c71dbdf515aa932dd677a9a78bf1fbff27787fd4", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -63,7 +63,7 @@ fn method_might_be_inlined(\n struct ReachableContext<'tcx> {\n     // The type context.\n     tcx: TyCtxt<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: HirIdSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -81,17 +81,20 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n+        let old_maybe_typeck_results =\n+            self.maybe_typeck_results.replace(self.tcx.typeck_body(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         let res = match expr.kind {\n-            hir::ExprKind::Path(ref qpath) => Some(self.tables().qpath_res(qpath, expr.hir_id)),\n+            hir::ExprKind::Path(ref qpath) => {\n+                Some(self.typeck_results().qpath_res(qpath, expr.hir_id))\n+            }\n             hir::ExprKind::MethodCall(..) => self\n-                .tables()\n+                .typeck_results()\n                 .type_dependent_def(expr.hir_id)\n                 .map(|(kind, def_id)| Res::Def(kind, def_id)),\n             _ => None,\n@@ -133,12 +136,13 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n }\n \n impl<'tcx> ReachableContext<'tcx> {\n-    /// Gets the type-checking side-tables for the current body.\n+    /// Gets the type-checking results for the current body.\n     /// As this will ICE if called outside bodies, only call when working with\n     /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n     #[track_caller]\n-    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n-        self.maybe_typeck_tables.expect(\"`ReachableContext::tables` called outside of body\")\n+    fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n+        self.maybe_typeck_results\n+            .expect(\"`ReachableContext::typeck_results` called outside of body\")\n     }\n \n     // Returns true if the given def ID represents a local item that is\n@@ -388,7 +392,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n         });\n     let mut reachable_context = ReachableContext {\n         tcx,\n-        maybe_typeck_tables: None,\n+        maybe_typeck_results: None,\n         reachable_symbols: Default::default(),\n         worklist: Vec::new(),\n         any_library,"}, {"sha": "1ecb0320744ff8753abb10b985926f39af7232d2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1020,17 +1020,18 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n \n struct NamePrivacyVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n     current_item: Option<hir::HirId>,\n }\n \n impl<'tcx> NamePrivacyVisitor<'tcx> {\n-    /// Gets the type-checking side-tables for the current body.\n+    /// Gets the type-checking results for the current body.\n     /// As this will ICE if called outside bodies, only call when working with\n     /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n     #[track_caller]\n-    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n-        self.maybe_typeck_tables.expect(\"`NamePrivacyVisitor::tables` called outside of body\")\n+    fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n+        self.maybe_typeck_results\n+            .expect(\"`NamePrivacyVisitor::typeck_results` called outside of body\")\n     }\n \n     // Checks that a field in a struct constructor (expression or pattern) is accessible.\n@@ -1083,10 +1084,11 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n+        let old_maybe_typeck_results =\n+            self.maybe_typeck_results.replace(self.tcx.typeck_body(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n@@ -1097,17 +1099,17 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Struct(ref qpath, fields, ref base) = expr.kind {\n-            let res = self.tables().qpath_res(qpath, expr.hir_id);\n-            let adt = self.tables().expr_ty(expr).ty_adt_def().unwrap();\n+            let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n+            let adt = self.typeck_results().expr_ty(expr).ty_adt_def().unwrap();\n             let variant = adt.variant_of_res(res);\n             if let Some(ref base) = *base {\n                 // If the expression uses FRU we need to make sure all the unmentioned fields\n                 // are checked for privacy (RFC 736). Rather than computing the set of\n                 // unmentioned fields, just check them all.\n                 for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n-                    let field = fields\n-                        .iter()\n-                        .find(|f| self.tcx.field_index(f.hir_id, self.tables()) == vf_index);\n+                    let field = fields.iter().find(|f| {\n+                        self.tcx.field_index(f.hir_id, self.typeck_results()) == vf_index\n+                    });\n                     let (use_ctxt, span) = match field {\n                         Some(field) => (field.ident.span, field.span),\n                         None => (base.span, base.span),\n@@ -1117,7 +1119,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n             } else {\n                 for field in fields {\n                     let use_ctxt = field.ident.span;\n-                    let index = self.tcx.field_index(field.hir_id, self.tables());\n+                    let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n                 }\n             }\n@@ -1128,12 +1130,12 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         if let PatKind::Struct(ref qpath, fields, _) = pat.kind {\n-            let res = self.tables().qpath_res(qpath, pat.hir_id);\n-            let adt = self.tables().pat_ty(pat).ty_adt_def().unwrap();\n+            let res = self.typeck_results().qpath_res(qpath, pat.hir_id);\n+            let adt = self.typeck_results().pat_ty(pat).ty_adt_def().unwrap();\n             let variant = adt.variant_of_res(res);\n             for field in fields {\n                 let use_ctxt = field.ident.span;\n-                let index = self.tcx.field_index(field.hir_id, self.tables());\n+                let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n                 self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n             }\n         }\n@@ -1150,18 +1152,19 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n \n struct TypePrivacyVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n     current_item: LocalDefId,\n     span: Span,\n }\n \n impl<'tcx> TypePrivacyVisitor<'tcx> {\n-    /// Gets the type-checking side-tables for the current body.\n+    /// Gets the type-checking results for the current body.\n     /// As this will ICE if called outside bodies, only call when working with\n     /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n     #[track_caller]\n-    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n-        self.maybe_typeck_tables.expect(\"`TypePrivacyVisitor::tables` called outside of body\")\n+    fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n+        self.maybe_typeck_results\n+            .expect(\"`TypePrivacyVisitor::typeck_results` called outside of body\")\n     }\n \n     fn item_is_accessible(&self, did: DefId) -> bool {\n@@ -1173,11 +1176,11 @@ impl<'tcx> TypePrivacyVisitor<'tcx> {\n     // Take node-id of an expression or pattern and check its type for privacy.\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n-        let tables = self.tables();\n-        if self.visit(tables.node_type(id)) || self.visit(tables.node_substs(id)) {\n+        let typeck_results = self.typeck_results();\n+        if self.visit(typeck_results.node_type(id)) || self.visit(typeck_results.node_substs(id)) {\n             return true;\n         }\n-        if let Some(adjustments) = tables.adjustments().get(id) {\n+        if let Some(adjustments) = typeck_results.adjustments().get(id) {\n             for adjustment in adjustments {\n                 if self.visit(adjustment.target) {\n                     return true;\n@@ -1215,17 +1218,18 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n+        let old_maybe_typeck_results =\n+            self.maybe_typeck_results.replace(self.tcx.typeck_body(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         self.span = hir_ty.span;\n-        if let Some(tables) = self.maybe_typeck_tables {\n+        if let Some(typeck_results) = self.maybe_typeck_results {\n             // Types in bodies.\n-            if self.visit(tables.node_type(hir_ty.hir_id)) {\n+            if self.visit(typeck_results.node_type(hir_ty.hir_id)) {\n                 return;\n             }\n         } else {\n@@ -1242,7 +1246,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n     fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef<'tcx>) {\n         self.span = trait_ref.path.span;\n-        if self.maybe_typeck_tables.is_none() {\n+        if self.maybe_typeck_results.is_none() {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n             let bounds = rustc_typeck::hir_trait_to_predicates(\n@@ -1288,7 +1292,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             hir::ExprKind::MethodCall(_, span, _, _) => {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n-                if let Some(def_id) = self.tables().type_dependent_def_id(expr.hir_id) {\n+                if let Some(def_id) = self.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     if self.visit(self.tcx.type_of(def_id)) {\n                         return;\n                     }\n@@ -1316,9 +1320,9 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 Res::Def(kind, def_id) => Some((kind, def_id)),\n                 _ => None,\n             },\n-            hir::QPath::TypeRelative(..) => {\n-                self.maybe_typeck_tables.and_then(|tables| tables.type_dependent_def(id))\n-            }\n+            hir::QPath::TypeRelative(..) => self\n+                .maybe_typeck_results\n+                .and_then(|typeck_results| typeck_results.type_dependent_def(id)),\n         };\n         let def = def.filter(|(kind, _)| match kind {\n             DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Static => true,\n@@ -1374,9 +1378,9 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let orig_current_item =\n             mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.hir_id));\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.take();\n+        let old_maybe_typeck_results = self.maybe_typeck_results.take();\n         intravisit::walk_item(self, item);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n         self.current_item = orig_current_item;\n     }\n }\n@@ -2039,15 +2043,15 @@ pub fn provide(providers: &mut Providers) {\n \n fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     // Check privacy of names not checked in previous compilation stages.\n-    let mut visitor = NamePrivacyVisitor { tcx, maybe_typeck_tables: None, current_item: None };\n+    let mut visitor = NamePrivacyVisitor { tcx, maybe_typeck_results: None, current_item: None };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n \n     intravisit::walk_mod(&mut visitor, module, hir_id);\n \n     // Check privacy of explicitly written types and traits as well as\n     // inferred types of expressions and patterns.\n     let mut visitor =\n-        TypePrivacyVisitor { tcx, maybe_typeck_tables: None, current_item: module_def_id, span };\n+        TypePrivacyVisitor { tcx, maybe_typeck_results: None, current_item: module_def_id, span };\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n "}, {"sha": "5aa676e3fce8eafb8a7663d97f124ea344440df6", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -104,20 +104,20 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.dumper.analysis()\n     }\n \n-    fn nest_tables<F>(&mut self, item_def_id: LocalDefId, f: F)\n+    fn nest_typeck_results<F>(&mut self, item_def_id: LocalDefId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n-        let tables = if self.tcx.has_typeck_tables(item_def_id) {\n-            Some(self.tcx.typeck_tables_of(item_def_id))\n+        let typeck_results = if self.tcx.has_typeck_results(item_def_id) {\n+            Some(self.tcx.typeck(item_def_id))\n         } else {\n             None\n         };\n \n-        let old_maybe_typeck_tables = self.save_ctxt.maybe_typeck_tables;\n-        self.save_ctxt.maybe_typeck_tables = tables;\n+        let old_maybe_typeck_results = self.save_ctxt.maybe_typeck_results;\n+        self.save_ctxt.maybe_typeck_results = typeck_results;\n         f(self);\n-        self.save_ctxt.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.save_ctxt.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn span_from_span(&self, span: Span) -> SpanData {\n@@ -226,7 +226,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             collector.visit_pat(&arg.pat);\n \n             for (hir_id, ident, ..) in collector.collected_idents {\n-                let typ = match self.save_ctxt.tables().node_type_opt(hir_id) {\n+                let typ = match self.save_ctxt.typeck_results().node_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n@@ -269,7 +269,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         debug!(\"process_method: {}:{}\", hir_id, ident);\n \n         let map = &self.tcx.hir();\n-        self.nest_tables(map.local_def_id(hir_id), |v| {\n+        self.nest_typeck_results(map.local_def_id(hir_id), |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(hir_id, ident, span) {\n                 if let Some(body) = body {\n                     v.process_formals(map.body(body).params, &method_data.qualname);\n@@ -363,7 +363,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         body: hir::BodyId,\n     ) {\n         let map = &self.tcx.hir();\n-        self.nest_tables(map.local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(map.local_def_id(item.hir_id), |v| {\n             let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n@@ -391,7 +391,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) {\n-        self.nest_tables(self.tcx.hir().local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(self.tcx.hir().local_def_id(item.hir_id), |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n                 v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id), var_data);\n@@ -438,7 +438,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         // walk type and init value\n-        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+        self.nest_typeck_results(self.tcx.hir().local_def_id(hir_id), |v| {\n             v.visit_ty(typ);\n             if let Some(expr) = expr {\n                 v.visit_expr(expr);\n@@ -508,7 +508,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             );\n         }\n \n-        self.nest_tables(self.tcx.hir().local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(self.tcx.hir().local_def_id(item.hir_id), |v| {\n             for field in def.fields() {\n                 v.process_struct_field_def(field, item.hir_id);\n                 v.visit_ty(&field.ty);\n@@ -641,7 +641,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         let map = &self.tcx.hir();\n-        self.nest_tables(map.local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(map.local_def_id(item.hir_id), |v| {\n             v.visit_ty(&typ);\n             if let &Some(ref trait_ref) = trait_ref {\n                 v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n@@ -859,7 +859,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         match p.kind {\n             hir::PatKind::Struct(ref _path, fields, _) => {\n                 // FIXME do something with _path?\n-                let adt = match self.save_ctxt.tables().node_type_opt(p.hir_id) {\n+                let adt = match self.save_ctxt.typeck_results().node_type_opt(p.hir_id) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n                         intravisit::walk_pat(self, p);\n@@ -900,7 +900,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 Res::Local(hir_id) => {\n                     let typ = self\n                         .save_ctxt\n-                        .tables()\n+                        .typeck_results()\n                         .node_type_opt(hir_id)\n                         .map(|t| t.to_string())\n                         .unwrap_or_default();\n@@ -1375,13 +1375,15 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::TyKind::Array(ref ty, ref anon_const) => {\n                 self.visit_ty(ty);\n                 let map = self.tcx.hir();\n-                self.nest_tables(self.tcx.hir().local_def_id(anon_const.hir_id), |v| {\n+                self.nest_typeck_results(self.tcx.hir().local_def_id(anon_const.hir_id), |v| {\n                     v.visit_expr(&map.body(anon_const.body).value)\n                 });\n             }\n             hir::TyKind::OpaqueDef(item_id, _) => {\n                 let item = self.tcx.hir().item(item_id.id);\n-                self.nest_tables(self.tcx.hir().local_def_id(item_id.id), |v| v.visit_item(item));\n+                self.nest_typeck_results(self.tcx.hir().local_def_id(item_id.id), |v| {\n+                    v.visit_item(item)\n+                });\n             }\n             _ => intravisit::walk_ty(self, t),\n         }\n@@ -1393,7 +1395,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n         match ex.kind {\n             hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.hir_id);\n-                let adt = match self.save_ctxt.tables().expr_ty_opt(&hir_expr) {\n+                let adt = match self.save_ctxt.typeck_results().expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n                         intravisit::walk_expr(self, ex);\n@@ -1430,7 +1432,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n \n                 // walk the body\n                 let map = self.tcx.hir();\n-                self.nest_tables(self.tcx.hir().local_def_id(ex.hir_id), |v| {\n+                self.nest_typeck_results(self.tcx.hir().local_def_id(ex.hir_id), |v| {\n                     let body = map.body(body);\n                     v.process_formals(body.params, &id);\n                     v.visit_expr(&body.value)\n@@ -1439,7 +1441,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ExprKind::Repeat(ref expr, ref anon_const) => {\n                 self.visit_expr(expr);\n                 let map = self.tcx.hir();\n-                self.nest_tables(self.tcx.hir().local_def_id(anon_const.hir_id), |v| {\n+                self.nest_typeck_results(self.tcx.hir().local_def_id(anon_const.hir_id), |v| {\n                     v.visit_expr(&map.body(anon_const.body).value)\n                 });\n             }"}, {"sha": "22526fc61e6e0d7a6a0f4657a9d4b86c560f849c", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -49,7 +49,7 @@ use log::{debug, error, info};\n \n pub struct SaveContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n     access_levels: &'tcx AccessLevels,\n     span_utils: SpanUtils<'tcx>,\n     config: Config,\n@@ -64,12 +64,12 @@ pub enum Data {\n }\n \n impl<'tcx> SaveContext<'tcx> {\n-    /// Gets the type-checking side-tables for the current body.\n+    /// Gets the type-checking results for the current body.\n     /// As this will ICE if called outside bodies, only call when working with\n     /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n     #[track_caller]\n-    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n-        self.maybe_typeck_tables.expect(\"`SaveContext::tables` called outside of body\")\n+    fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n+        self.maybe_typeck_results.expect(\"`SaveContext::typeck_results` called outside of body\")\n     }\n \n     fn span_from_span(&self, span: Span) -> SpanData {\n@@ -482,7 +482,7 @@ impl<'tcx> SaveContext<'tcx> {\n                     None => {\n                         debug!(\"could not find container for method {} at {:?}\", hir_id, span);\n                         // This is not necessarily a bug, if there was a compilation error,\n-                        // the tables we need might not exist.\n+                        // the typeck results we need might not exist.\n                         return None;\n                     }\n                 },\n@@ -523,13 +523,13 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n-        let ty = self.tables().expr_ty_adjusted_opt(expr)?;\n+        let ty = self.typeck_results().expr_ty_adjusted_opt(expr)?;\n         if matches!(ty.kind, ty::Error(_)) {\n             return None;\n         }\n         match expr.kind {\n             hir::ExprKind::Field(ref sub_ex, ident) => {\n-                match self.tables().expr_ty_adjusted(&sub_ex).kind {\n+                match self.typeck_results().expr_ty_adjusted(&sub_ex).kind {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         filter!(self.span_utils, ident.span);\n@@ -574,7 +574,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 }\n             }\n             hir::ExprKind::MethodCall(ref seg, ..) => {\n-                let method_id = match self.tables().type_dependent_def_id(expr.hir_id) {\n+                let method_id = match self.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     Some(id) => id,\n                     None => {\n                         debug!(\"could not resolve method id for {:?}\", expr);\n@@ -623,7 +623,7 @@ impl<'tcx> SaveContext<'tcx> {\n             },\n \n             Node::Expr(&hir::Expr { kind: hir::ExprKind::Struct(ref qpath, ..), .. }) => {\n-                self.tables().qpath_res(qpath, hir_id)\n+                self.typeck_results().qpath_res(qpath, hir_id)\n             }\n \n             Node::Expr(&hir::Expr { kind: hir::ExprKind::Path(ref qpath), .. })\n@@ -637,8 +637,8 @@ impl<'tcx> SaveContext<'tcx> {\n             | Node::Ty(&hir::Ty { kind: hir::TyKind::Path(ref qpath), .. }) => match qpath {\n                 hir::QPath::Resolved(_, path) => path.res,\n                 hir::QPath::TypeRelative(..) => self\n-                    .maybe_typeck_tables\n-                    .map_or(Res::Err, |tables| tables.qpath_res(qpath, hir_id)),\n+                    .maybe_typeck_results\n+                    .map_or(Res::Err, |typeck_results| typeck_results.qpath_res(qpath, hir_id)),\n             },\n \n             Node::Binding(&hir::Pat {\n@@ -1009,7 +1009,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n \n         let save_ctxt = SaveContext {\n             tcx,\n-            maybe_typeck_tables: None,\n+            maybe_typeck_results: None,\n             access_levels: &access_levels,\n             span_utils: SpanUtils::new(&tcx.sess),\n             config: find_config(config),"}, {"sha": "112de6846608446dca9fccf999e6b41a3bdcaefd", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -593,9 +593,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n-                        if let Some(tables) = self.in_progress_tables {\n-                            let tables = tables.borrow();\n-                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n+                        if let Some(typeck_results) = self.in_progress_typeck_results {\n+                            let typeck_results = typeck_results.borrow();\n+                            match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, name))) => {\n                                     err.span_label(\n                                         *span,"}, {"sha": "0a6fb72ca51eae890af70698ac34d8b50d788cf9", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::{\n     self, suggest_constraining_type_param, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty,\n     TyCtxt, TypeFoldable, WithConstness,\n };\n-use rustc_middle::ty::{TypeAndMut, TypeckTables};\n+use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n@@ -145,7 +145,7 @@ pub trait InferCtxtExt<'tcx> {\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'tcx>,\n         target_ty: Ty<'tcx>,\n-        tables: &ty::TypeckTables<'tcx>,\n+        typeck_results: &ty::TypeckResults<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n     );\n@@ -968,12 +968,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut visitor = ReturnsVisitor::default();\n         visitor.visit_body(&body);\n \n-        let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+        let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n \n         let mut ret_types = visitor\n             .returns\n             .iter()\n-            .filter_map(|expr| tables.node_type_opt(expr.hir_id))\n+            .filter_map(|expr| typeck_results.node_type_opt(expr.hir_id))\n             .map(|ty| self.resolve_vars_if_possible(&ty));\n         let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n             (None, true, true),\n@@ -1000,7 +1000,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             },\n         );\n         let all_returns_conform_to_trait =\n-            if let Some(ty_ret_ty) = tables.node_type_opt(ret_ty.hir_id) {\n+            if let Some(ty_ret_ty) = typeck_results.node_type_opt(ret_ty.hir_id) {\n                 match ty_ret_ty.kind {\n                     ty::Dynamic(predicates, _) => {\n                         let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n@@ -1128,9 +1128,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // Point at all the `return`s in the function as they have failed trait bounds.\n             let mut visitor = ReturnsVisitor::default();\n             visitor.visit_body(&body);\n-            let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+            let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n             for expr in &visitor.returns {\n-                if let Some(returned_ty) = tables.node_type_opt(expr.hir_id) {\n+                if let Some(returned_ty) = typeck_results.node_type_opt(expr.hir_id) {\n                     let ty = self.resolve_vars_if_possible(&returned_ty);\n                     err.span_label(expr.span, &format!(\"this returned value is of type `{}`\", ty));\n                 }\n@@ -1360,25 +1360,25 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return false;\n         }\n \n-        // Get the tables from the infcx if the generator is the function we are\n+        // Get the typeck results from the infcx if the generator is the function we are\n         // currently type-checking; otherwise, get them by performing a query.\n         // This is needed to avoid cycles.\n-        let in_progress_tables = self.in_progress_tables.map(|t| t.borrow());\n+        let in_progress_typeck_results = self.in_progress_typeck_results.map(|t| t.borrow());\n         let generator_did_root = self.tcx.closure_base_def_id(generator_did);\n         debug!(\n             \"maybe_note_obligation_cause_for_async_await: generator_did={:?} \\\n-             generator_did_root={:?} in_progress_tables.hir_owner={:?} span={:?}\",\n+             generator_did_root={:?} in_progress_typeck_results.hir_owner={:?} span={:?}\",\n             generator_did,\n             generator_did_root,\n-            in_progress_tables.as_ref().map(|t| t.hir_owner),\n+            in_progress_typeck_results.as_ref().map(|t| t.hir_owner),\n             span\n         );\n-        let query_tables;\n-        let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n+        let query_typeck_results;\n+        let typeck_results: &TypeckResults<'tcx> = match &in_progress_typeck_results {\n             Some(t) if t.hir_owner.to_def_id() == generator_did_root => t,\n             _ => {\n-                query_tables = self.tcx.typeck_tables_of(generator_did.expect_local());\n-                &query_tables\n+                query_typeck_results = self.tcx.typeck(generator_did.expect_local());\n+                &query_typeck_results\n             }\n         };\n \n@@ -1425,7 +1425,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         if let Some(upvars) = self.tcx.upvars_mentioned(generator_did) {\n             interior_or_upvar_span = upvars.iter().find_map(|(upvar_id, upvar)| {\n-                let upvar_ty = tables.node_type(*upvar_id);\n+                let upvar_ty = typeck_results.node_type(*upvar_id);\n                 let upvar_ty = self.resolve_vars_if_possible(&upvar_ty);\n                 if ty_matches(&upvar_ty) {\n                     Some(GeneratorInteriorOrUpvar::Upvar(upvar.span))\n@@ -1435,7 +1435,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             });\n         };\n \n-        tables\n+        typeck_results\n             .generator_interior_types\n             .iter()\n             .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty_matches(ty))\n@@ -1446,7 +1446,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .into_iter()\n                     .map(|id| hir.expect_expr(id))\n                     .find(|await_expr| {\n-                        let ty = tables.expr_ty_adjusted(&await_expr);\n+                        let ty = typeck_results.expr_ty_adjusted(&await_expr);\n                         debug!(\n                             \"maybe_note_obligation_cause_for_async_await: await_expr={:?}\",\n                             await_expr\n@@ -1464,7 +1464,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         debug!(\n             \"maybe_note_obligation_cause_for_async_await: interior_or_upvar={:?} \\\n                 generator_interior_types={:?}\",\n-            interior_or_upvar_span, tables.generator_interior_types\n+            interior_or_upvar_span, typeck_results.generator_interior_types\n         );\n         if let Some(interior_or_upvar_span) = interior_or_upvar_span {\n             self.note_obligation_cause_for_async_await(\n@@ -1475,7 +1475,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 outer_generator,\n                 trait_ref,\n                 target_ty,\n-                tables,\n+                typeck_results,\n                 obligation,\n                 next_code,\n             );\n@@ -1496,7 +1496,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'tcx>,\n         target_ty: Ty<'tcx>,\n-        tables: &ty::TypeckTables<'tcx>,\n+        typeck_results: &ty::TypeckResults<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n     ) {\n@@ -1613,7 +1613,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // Look at the last interior type to get a span for the `.await`.\n                         debug!(\n                             \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n-                            tables.generator_interior_types\n+                            typeck_results.generator_interior_types\n                         );\n                         explain_yield(interior_span, yield_span, scope_span);\n                     }\n@@ -1634,7 +1634,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             // ^^^^^^^ a temporary `&T` created inside this method call due to `&self`\n                             // ```\n                             //\n-                            let is_region_borrow = tables\n+                            let is_region_borrow = typeck_results\n                                 .expr_adjustments(expr)\n                                 .iter()\n                                 .any(|adj| adj.is_region_borrow());\n@@ -1651,7 +1651,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                     _ => false,\n                                 };\n \n-                            if (tables.is_method_call(e) && is_region_borrow)\n+                            if (typeck_results.is_method_call(e) && is_region_borrow)\n                                 || is_raw_borrow_inside_fn_like_call\n                             {\n                                 err.span_help("}, {"sha": "4ba64035ca44ab78fea3260cb5022587403c98ed", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -337,7 +337,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut inner_callee_path = None;\n                     let def = match callee.kind {\n                         hir::ExprKind::Path(ref qpath) => {\n-                            self.tables.borrow().qpath_res(qpath, callee.hir_id)\n+                            self.typeck_results.borrow().qpath_res(qpath, callee.hir_id)\n                         }\n                         hir::ExprKind::Call(ref inner_callee, _) => {\n                             // If the call spans more than one line and the callee kind is\n@@ -355,7 +355,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                             if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n                                 inner_callee_path = Some(inner_qpath);\n-                                self.tables.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n+                                self.typeck_results\n+                                    .borrow()\n+                                    .qpath_res(inner_qpath, inner_callee.hir_id)\n                             } else {\n                                 Res::Err\n                             }"}, {"sha": "a877df68326d6b61f5117bd6b34b274e3d034d36", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 Ok(()) => {\n                     self.trivial_cast_lint(fcx);\n                     debug!(\" -> CoercionCast\");\n-                    fcx.tables.borrow_mut().set_coercion_cast(self.expr.hir_id.local_id);\n+                    fcx.typeck_results.borrow_mut().set_coercion_cast(self.expr.hir_id.local_id);\n                 }\n                 Err(ty::error::TypeError::ObjectUnsafeCoercion(did)) => {\n                     self.report_object_unsafe_cast(&fcx, did);"}, {"sha": "8b18e759026b1bb1c6678c7c578506c612582af7", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -416,7 +416,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Up till this point, we have ignored the annotations that the user\n         // gave. This function will check that they unify successfully.\n         // Along the way, it also writes out entries for types that the user\n-        // wrote into our tables, which are then later used by the privacy\n+        // wrote into our typeck results, which are then later used by the privacy\n         // check.\n         match self.check_supplied_sig_against_expectation(expr_def_id, decl, body, &closure_sigs) {\n             Ok(infer_ok) => self.register_infer_ok_obligations(infer_ok),\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"supplied_sig_of_closure: result={:?}\", result);\n \n         let c_result = self.inh.infcx.canonicalize_response(&result);\n-        self.tables.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n+        self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n \n         result\n     }"}, {"sha": "5cf2e2d64100c9957c55e01aabeba6e36c0cf5ac", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1000,7 +1000,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // First try to coerce the new expression to the type of the previous ones,\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n-        if !self.tables.borrow().adjustments().contains_key(new.hir_id) {\n+        if !self.typeck_results.borrow().adjustments().contains_key(new.hir_id) {\n             let result = self.commit_if_ok(|_| coerce.coerce(new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n         for expr in exprs {\n             let expr = expr.as_coercion_site();\n-            let noop = match self.tables.borrow().expr_adjustments(expr) {\n+            let noop = match self.typeck_results.borrow().expr_adjustments(expr) {\n                 &[Adjustment { kind: Adjust::Deref(_), .. }, Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }] =>\n                 {\n                     match self.node_ty(expr.hir_id).kind {"}, {"sha": "be83ab259c2ecc0bcc96bd9484b099a70a593434", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -320,7 +320,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return None,\n         };\n \n-        let self_ty = self.tables.borrow().node_type(method_expr[0].hir_id);\n+        let self_ty = self.typeck_results.borrow().node_type(method_expr[0].hir_id);\n         let self_ty = format!(\"{:?}\", self_ty);\n         let name = method_path.ident.name;\n         let is_as_ref_able = (self_ty.starts_with(\"&std::option::Option\")\n@@ -466,10 +466,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let clone_trait = self.tcx.require_lang_item(CloneTraitLangItem, Some(sp));\n                         if let ([arg], Some(true), sym::clone) = (\n                             &args[..],\n-                            self.tables.borrow().type_dependent_def_id(expr.hir_id).map(|did| {\n-                                let ai = self.tcx.associated_item(did);\n-                                ai.container == ty::TraitContainer(clone_trait)\n-                            }),\n+                            self.typeck_results.borrow().type_dependent_def_id(expr.hir_id).map(\n+                                |did| {\n+                                    let ai = self.tcx.associated_item(did);\n+                                    ai.container == ty::TraitContainer(clone_trait)\n+                                },\n+                            ),\n                             segment.ident.name,\n                         ) {\n                             // If this expression had a clone call when suggesting borrowing"}, {"sha": "63c100d5fad4f17bd399cdea8c571f6459621275", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // coercions from ! to `expected`.\n         if ty.is_never() {\n             assert!(\n-                !self.tables.borrow().adjustments().contains_key(expr.hir_id),\n+                !self.typeck_results.borrow().adjustments().contains_key(expr.hir_id),\n                 \"expression with never type wound up being adjusted\"\n             );\n             let adj_ty = self.next_diverging_ty_var(TypeVariableOrigin {\n@@ -430,7 +430,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // This is maybe too permissive, since it allows\n             // `let u = &raw const Box::new((1,)).0`, which creates an\n             // immediately dangling raw pointer.\n-            self.tables.borrow().adjustments().get(base.hir_id).map_or(false, |x| {\n+            self.typeck_results.borrow().adjustments().get(base.hir_id).map_or(false, |x| {\n                 x.iter().any(|adj| if let Adjust::Deref(_) = adj.kind { true } else { false })\n             })\n         });\n@@ -509,7 +509,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // We always require that the type provided as the value for\n         // a type parameter outlives the moment of instantiation.\n-        let substs = self.tables.borrow().node_substs(expr.hir_id);\n+        let substs = self.typeck_results.borrow().node_substs(expr.hir_id);\n         self.add_wf_bounds(substs, expr);\n \n         ty\n@@ -1123,7 +1123,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             })\n                             .collect();\n \n-                        self.tables\n+                        self.typeck_results\n                             .borrow_mut()\n                             .fru_field_types_mut()\n                             .insert(expr.hir_id, fru_field_types);"}, {"sha": "c5004e4ce119b4ba75d46f94a3d438b51809e44b", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -190,8 +190,8 @@ pub fn resolve_interior<'a, 'tcx>(\n     let type_list = fcx.tcx.mk_type_list(type_causes.iter().map(|cause| cause.ty));\n     let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list));\n \n-    // Store the generator types and spans into the tables for this generator.\n-    visitor.fcx.inh.tables.borrow_mut().generator_interior_types = type_causes;\n+    // Store the generator types and spans into the typeck results for this generator.\n+    visitor.fcx.inh.typeck_results.borrow_mut().generator_interior_types = type_causes;\n \n     debug!(\n         \"types in generator after region replacement {:?}, span = {:?}\",\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n         if let PatKind::Binding(..) = pat.kind {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n-            let ty = self.fcx.tables.borrow().pat_ty(pat);\n+            let ty = self.fcx.typeck_results.borrow().pat_ty(pat);\n             self.record(ty, Some(scope), None, pat.span);\n         }\n     }\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         match &expr.kind {\n             ExprKind::Call(callee, args) => match &callee.kind {\n                 ExprKind::Path(qpath) => {\n-                    let res = self.fcx.tables.borrow().qpath_res(qpath, callee.hir_id);\n+                    let res = self.fcx.typeck_results.borrow().qpath_res(qpath, callee.hir_id);\n                     match res {\n                         // Direct calls never need to keep the callee `ty::FnDef`\n                         // ZST in a temporary, so skip its type, just in case it\n@@ -263,7 +263,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n         // If there are adjustments, then record the final type --\n         // this is the actual value that is being produced.\n-        if let Some(adjusted_ty) = self.fcx.tables.borrow().expr_ty_adjusted_opt(expr) {\n+        if let Some(adjusted_ty) = self.fcx.typeck_results.borrow().expr_ty_adjusted_opt(expr) {\n             self.record(adjusted_ty, scope, Some(expr), expr.span);\n         }\n \n@@ -291,7 +291,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         //\n         // The type table might not have information for this expression\n         // if it is in a malformed scope. (#66387)\n-        if let Some(ty) = self.fcx.tables.borrow().expr_ty_opt(expr) {\n+        if let Some(ty) = self.fcx.typeck_results.borrow().expr_ty_opt(expr) {\n             self.record(ty, scope, Some(expr), expr.span);\n         } else {\n             self.fcx.tcx.sess.delay_span_bug(expr.span, \"no type for node\");"}, {"sha": "96248e18aaf87a44fb6b9be380a14c112dfbd38d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         pick: &probe::Pick<'tcx>,\n     ) -> Ty<'tcx> {\n         // Commit the autoderefs by calling `autoderef` again, but this\n-        // time writing the results into the various tables.\n+        // time writing the results into the various typeck results.\n         let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n         let (_, n) = match autoderef.nth(pick.autoderefs) {\n             Some(n) => n,"}, {"sha": "64dce3e1738e38115fd37a66536d3acc37a24fdc", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         for import_id in &pick.import_ids {\n             debug!(\"used_trait_import: {:?}\", import_id);\n-            Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n+            Lrc::get_mut(&mut self.typeck_results.borrow_mut().used_trait_imports)\n                 .unwrap()\n                 .insert(*import_id);\n         }\n@@ -456,8 +456,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )?;\n         debug!(\"resolve_ufcs: pick={:?}\", pick);\n         {\n-            let mut tables = self.tables.borrow_mut();\n-            let used_trait_imports = Lrc::get_mut(&mut tables.used_trait_imports).unwrap();\n+            let mut typeck_results = self.typeck_results.borrow_mut();\n+            let used_trait_imports = Lrc::get_mut(&mut typeck_results.used_trait_imports).unwrap();\n             for import_id in pick.import_ids {\n                 debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_id);\n                 used_trait_imports.insert(import_id);"}, {"sha": "b9f1f8064c861062c253efc98188957f0e829fd9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1043,7 +1043,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             // Obtain the span for `param` and use it for a structured suggestion.\n             let mut suggested = false;\n-            if let (Some(ref param), Some(ref table)) = (param_type, self.in_progress_tables) {\n+            if let (Some(ref param), Some(ref table)) =\n+                (param_type, self.in_progress_typeck_results)\n+            {\n                 let table_owner = table.borrow().hir_owner;\n                 let generics = self.tcx.generics_of(table_owner.to_def_id());\n                 let type_param = generics.type_param(param, self.tcx);"}, {"sha": "04e02704296defd79c3b2a8cbfc98eaee84c2eaf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 79, "deletions": 69, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -51,7 +51,7 @@ and `fcx.expr_ty()` / `fcx.node_ty()` to write/obtain the types of\n nodes within the function.\n \n The types of top-level items, which never contain unbound type\n-variables, are stored directly into the `tcx` tables.\n+variables, are stored directly into the `tcx` typeck_results.\n \n N.B., a type variable is not the same thing as a type parameter.  A\n type variable is rather an \"instance\" of a type parameter: that is,\n@@ -182,24 +182,28 @@ pub struct LocalTy<'tcx> {\n     revealed_ty: Ty<'tcx>,\n }\n \n-/// A wrapper for `InferCtxt`'s `in_progress_tables` field.\n+/// A wrapper for `InferCtxt`'s `in_progress_typeck_results` field.\n #[derive(Copy, Clone)]\n struct MaybeInProgressTables<'a, 'tcx> {\n-    maybe_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n+    maybe_typeck_results: Option<&'a RefCell<ty::TypeckResults<'tcx>>>,\n }\n \n impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n-    fn borrow(self) -> Ref<'a, ty::TypeckTables<'tcx>> {\n-        match self.maybe_tables {\n-            Some(tables) => tables.borrow(),\n-            None => bug!(\"MaybeInProgressTables: inh/fcx.tables.borrow() with no tables\"),\n+    fn borrow(self) -> Ref<'a, ty::TypeckResults<'tcx>> {\n+        match self.maybe_typeck_results {\n+            Some(typeck_results) => typeck_results.borrow(),\n+            None => bug!(\n+                \"MaybeInProgressTables: inh/fcx.typeck_results.borrow() with no typeck results\"\n+            ),\n         }\n     }\n \n-    fn borrow_mut(self) -> RefMut<'a, ty::TypeckTables<'tcx>> {\n-        match self.maybe_tables {\n-            Some(tables) => tables.borrow_mut(),\n-            None => bug!(\"MaybeInProgressTables: inh/fcx.tables.borrow_mut() with no tables\"),\n+    fn borrow_mut(self) -> RefMut<'a, ty::TypeckResults<'tcx>> {\n+        match self.maybe_typeck_results {\n+            Some(typeck_results) => typeck_results.borrow_mut(),\n+            None => bug!(\n+                \"MaybeInProgressTables: inh/fcx.typeck_results.borrow_mut() with no typeck results\"\n+            ),\n         }\n     }\n }\n@@ -216,7 +220,7 @@ impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n pub struct Inherited<'a, 'tcx> {\n     infcx: InferCtxt<'a, 'tcx>,\n \n-    tables: MaybeInProgressTables<'a, 'tcx>,\n+    typeck_results: MaybeInProgressTables<'a, 'tcx>,\n \n     locals: RefCell<HirIdMap<LocalTy<'tcx>>>,\n \n@@ -645,7 +649,7 @@ impl Inherited<'_, 'tcx> {\n         let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(hir_owner),\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_typeck_results(hir_owner),\n             def_id,\n         }\n     }\n@@ -668,7 +672,9 @@ impl Inherited<'a, 'tcx> {\n         let body_id = tcx.hir().maybe_body_owned_by(item_id);\n \n         Inherited {\n-            tables: MaybeInProgressTables { maybe_tables: infcx.in_progress_tables },\n+            typeck_results: MaybeInProgressTables {\n+                maybe_typeck_results: infcx.in_progress_typeck_results,\n+            },\n             infcx,\n             fulfillment_cx: RefCell::new(TraitEngine::new(tcx)),\n             locals: RefCell::new(Default::default()),\n@@ -744,7 +750,7 @@ fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n fn typeck_item_bodies(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.par_body_owners(|body_owner_def_id| {\n-        tcx.ensure().typeck_tables_of(body_owner_def_id);\n+        tcx.ensure().typeck(body_owner_def_id);\n     });\n }\n \n@@ -764,10 +770,10 @@ pub fn provide(providers: &mut Providers) {\n     method::provide(providers);\n     *providers = Providers {\n         typeck_item_bodies,\n-        typeck_tables_of_const_arg,\n-        typeck_tables_of,\n-        diagnostic_only_typeck_tables_of,\n-        has_typeck_tables,\n+        typeck_const_arg,\n+        typeck,\n+        diagnostic_only_typeck,\n+        has_typeck_results,\n         adt_destructor,\n         used_trait_imports,\n         check_item_well_formed,\n@@ -787,10 +793,10 @@ fn adt_destructor(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::Destructor> {\n /// it's body-id, fn-header and fn-decl (if any). Otherwise,\n /// returns `None`.\n ///\n-/// If this function returns `Some`, then `typeck_tables(def_id)` will\n-/// succeed; if it returns `None`, then `typeck_tables(def_id)` may or\n+/// If this function returns `Some`, then `typeck_results(def_id)` will\n+/// succeed; if it returns `None`, then `typeck_results(def_id)` may or\n /// may not succeed. In some cases where this function returns `None`\n-/// (notably closures), `typeck_tables(def_id)` would wind up\n+/// (notably closures), `typeck_results(def_id)` would wind up\n /// redirecting to the owning function.\n fn primary_body_of(\n     tcx: TyCtxt<'_>,\n@@ -825,12 +831,12 @@ fn primary_body_of(\n     }\n }\n \n-fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    // Closures' tables come from their outermost function,\n+fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    // Closures' typeck results come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n     if outer_def_id != def_id {\n-        return tcx.has_typeck_tables(outer_def_id);\n+        return tcx.has_typeck_results(outer_def_id);\n     }\n \n     if let Some(def_id) = def_id.as_local() {\n@@ -842,7 +848,7 @@ fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n }\n \n fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDefId> {\n-    &*tcx.typeck_tables_of(def_id).used_trait_imports\n+    &*tcx.typeck(def_id).used_trait_imports\n }\n \n /// Inspects the substs of opaque types, replacing any inference variables\n@@ -956,46 +962,43 @@ where\n     val.fold_with(&mut FixupFolder { tcx })\n }\n \n-fn typeck_tables_of_const_arg<'tcx>(\n+fn typeck_const_arg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (did, param_did): (LocalDefId, DefId),\n-) -> &ty::TypeckTables<'tcx> {\n+) -> &ty::TypeckResults<'tcx> {\n     let fallback = move || tcx.type_of(param_did);\n-    typeck_tables_of_with_fallback(tcx, did, fallback)\n+    typeck_with_fallback(tcx, did, fallback)\n }\n \n-fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckTables<'tcx> {\n+fn typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n     if let Some(param_did) = tcx.opt_const_param_of(def_id) {\n-        tcx.typeck_tables_of_const_arg((def_id, param_did))\n+        tcx.typeck_const_arg((def_id, param_did))\n     } else {\n         let fallback = move || tcx.type_of(def_id.to_def_id());\n-        typeck_tables_of_with_fallback(tcx, def_id, fallback)\n+        typeck_with_fallback(tcx, def_id, fallback)\n     }\n }\n \n-/// Used only to get `TypeckTables` for type inference during error recovery.\n+/// Used only to get `TypeckResults` for type inference during error recovery.\n /// Currently only used for type inference of `static`s and `const`s to avoid type cycle errors.\n-fn diagnostic_only_typeck_tables_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-) -> &ty::TypeckTables<'tcx> {\n+fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n     let fallback = move || {\n         let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id));\n         tcx.ty_error_with_message(span, \"diagnostic only typeck table used\")\n     };\n-    typeck_tables_of_with_fallback(tcx, def_id, fallback)\n+    typeck_with_fallback(tcx, def_id, fallback)\n }\n \n-fn typeck_tables_of_with_fallback<'tcx>(\n+fn typeck_with_fallback<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n     fallback: impl Fn() -> Ty<'tcx> + 'tcx,\n-) -> &'tcx ty::TypeckTables<'tcx> {\n-    // Closures' tables come from their outermost function,\n+) -> &'tcx ty::TypeckResults<'tcx> {\n+    // Closures' typeck results come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id.to_def_id()).expect_local();\n     if outer_def_id != def_id {\n-        return tcx.typeck_tables_of(outer_def_id);\n+        return tcx.typeck(outer_def_id);\n     }\n \n     let id = tcx.hir().as_local_hir_id(def_id);\n@@ -1007,7 +1010,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n     });\n     let body = tcx.hir().body(body_id);\n \n-    let tables = Inherited::build(tcx, def_id).enter(|inh| {\n+    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let (Some(header), Some(decl)) = (fn_header, fn_decl) {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n@@ -1137,11 +1140,11 @@ fn typeck_tables_of_with_fallback<'tcx>(\n         fcx.resolve_type_vars_in_body(body)\n     });\n \n-    // Consistency check our TypeckTables instance can hold all ItemLocalIds\n+    // Consistency check our TypeckResults instance can hold all ItemLocalIds\n     // it will need to hold.\n-    assert_eq!(tables.hir_owner, id.owner);\n+    assert_eq!(typeck_results.hir_owner, id.owner);\n \n-    tables\n+    typeck_results\n }\n \n fn check_abi(tcx: TyCtxt<'_>, span: Span, abi: Abi) {\n@@ -1214,7 +1217,11 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                     \"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n                     ty.hir_id, o_ty, revealed_ty, c_ty\n                 );\n-                self.fcx.tables.borrow_mut().user_provided_types_mut().insert(ty.hir_id, c_ty);\n+                self.fcx\n+                    .typeck_results\n+                    .borrow_mut()\n+                    .user_provided_types_mut()\n+                    .insert(ty.hir_id, c_ty);\n \n                 Some(LocalTy { decl_ty: o_ty, revealed_ty })\n             }\n@@ -1369,7 +1376,7 @@ fn check_fn<'a, 'tcx>(\n         fcx.write_ty(param.hir_id, param_ty);\n     }\n \n-    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n+    inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n     if let ty::Dynamic(..) = declared_ret_ty.kind {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n@@ -1758,17 +1765,17 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n \n     let mut label = false;\n     if let Some((hir_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n-        let tables = tcx.typeck_tables_of(tcx.hir().local_def_id(hir_id));\n+        let typeck_results = tcx.typeck(tcx.hir().local_def_id(hir_id));\n         if visitor\n             .returns\n             .iter()\n-            .filter_map(|expr| tables.node_type_opt(expr.hir_id))\n+            .filter_map(|expr| typeck_results.node_type_opt(expr.hir_id))\n             .all(|ty| matches!(ty.kind, ty::Never))\n         {\n             let spans = visitor\n                 .returns\n                 .iter()\n-                .filter(|expr| tables.node_type_opt(expr.hir_id).is_some())\n+                .filter(|expr| typeck_results.node_type_opt(expr.hir_id).is_some())\n                 .map(|expr| expr.span)\n                 .collect::<Vec<Span>>();\n             let span_len = spans.len();\n@@ -1791,7 +1798,7 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n             for (sp, ty) in visitor\n                 .returns\n                 .iter()\n-                .filter_map(|e| tables.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n+                .filter_map(|e| typeck_results.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n                 .filter(|(_, ty)| !matches!(ty.kind, ty::Never))\n             {\n                 struct VisitTypes(Vec<DefId>);\n@@ -1861,9 +1868,9 @@ fn binding_opaque_type_cycle_error(\n                 ..\n             }) => {\n                 let hir_id = tcx.hir().as_local_hir_id(def_id);\n-                let tables =\n-                    tcx.typeck_tables_of(tcx.hir().local_def_id(tcx.hir().get_parent_item(hir_id)));\n-                if let Some(ty) = tables.node_type_opt(expr.hir_id) {\n+                let typeck_results =\n+                    tcx.typeck(tcx.hir().local_def_id(tcx.hir().get_parent_item(hir_id)));\n+                if let Some(ty) = typeck_results.node_type_opt(expr.hir_id) {\n                     err.span_label(\n                         expr.span,\n                         &format!(\n@@ -1931,11 +1938,11 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n-            tcx.ensure().typeck_tables_of(def_id);\n+            tcx.ensure().typeck(def_id);\n             maybe_check_static_with_link_section(tcx, def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n-            tcx.ensure().typeck_tables_of(tcx.hir().local_def_id(it.hir_id));\n+            tcx.ensure().typeck(tcx.hir().local_def_id(it.hir_id));\n         }\n         hir::ItemKind::Enum(ref enum_definition, _) => {\n             check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n@@ -2843,7 +2850,7 @@ pub fn check_enum<'tcx>(\n \n     for v in vs {\n         if let Some(ref e) = v.disr_expr {\n-            tcx.ensure().typeck_tables_of(tcx.hir().local_def_id(e.hir_id));\n+            tcx.ensure().typeck(tcx.hir().local_def_id(e.hir_id));\n         }\n     }\n \n@@ -3212,7 +3219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.resolve_vars_if_possible(&ty),\n             self.tag()\n         );\n-        self.tables.borrow_mut().node_types_mut().insert(id, ty);\n+        self.typeck_results.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n@@ -3221,11 +3228,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn write_field_index(&self, hir_id: hir::HirId, index: usize) {\n-        self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n+        self.typeck_results.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n     fn write_resolution(&self, hir_id: hir::HirId, r: Result<(DefKind, DefId), ErrorReported>) {\n-        self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, r);\n+        self.typeck_results.borrow_mut().type_dependent_defs_mut().insert(hir_id, r);\n     }\n \n     pub fn write_method_call(&self, hir_id: hir::HirId, method: MethodCallee<'tcx>) {\n@@ -3279,7 +3286,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !substs.is_noop() {\n             debug!(\"write_substs({:?}, {:?}) in fcx {}\", node_id, substs, self.tag());\n \n-            self.tables.borrow_mut().node_substs_mut().insert(node_id, substs);\n+            self.typeck_results.borrow_mut().node_substs_mut().insert(node_id, substs);\n         }\n     }\n \n@@ -3330,7 +3337,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         if !canonical_user_type_annotation.is_identity() {\n-            self.tables\n+            self.typeck_results\n                 .borrow_mut()\n                 .user_provided_types_mut()\n                 .insert(hir_id, canonical_user_type_annotation);\n@@ -3353,7 +3360,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             })\n         });\n \n-        match self.tables.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n+        match self.typeck_results.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n             Entry::Vacant(entry) => {\n                 entry.insert(adj);\n             }\n@@ -3538,7 +3545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if Self::can_contain_user_lifetime_bounds(ty) {\n             let c_ty = self.infcx.canonicalize_response(&UserType::Ty(ty));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n-            self.tables.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n+            self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n \n         ty\n@@ -3588,7 +3595,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n-        match self.tables.borrow().node_types().get(id) {\n+        match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => t,\n             None if self.is_tainted_by_errors() => self.tcx.ty_error(),\n             None => {\n@@ -4527,7 +4534,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             QPath::TypeRelative(ref qself, ref segment) => (self.to_ty(qself), qself, segment),\n         };\n-        if let Some(&cached_result) = self.tables.borrow().type_dependent_defs().get(hir_id) {\n+        if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n+        {\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n             let def =\n@@ -4701,8 +4709,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let arm_spans: Vec<Span> = arms\n                 .iter()\n                 .filter_map(|arm| {\n-                    self.in_progress_tables\n-                        .and_then(|tables| tables.borrow().node_type_opt(arm.body.hir_id))\n+                    self.in_progress_typeck_results\n+                        .and_then(|typeck_results| {\n+                            typeck_results.borrow().node_type_opt(arm.body.hir_id)\n+                        })\n                         .and_then(|arm_ty| {\n                             if arm_ty.is_never() {\n                                 None"}, {"sha": "41aac3569d115f8e2e364eeb393e61db8f41add5", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -240,7 +240,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // some cases applied on the RHS, on top of which we need\n                         // to autoref, which is not allowed by apply_adjustments.\n                         // self.apply_adjustments(rhs_expr, vec![autoref]);\n-                        self.tables\n+                        self.typeck_results\n                             .borrow_mut()\n                             .adjustments_mut()\n                             .entry(rhs_expr.hir_id)\n@@ -496,14 +496,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.span_label(span, ty.to_string());\n         if let FnDef(def_id, _) = ty.kind {\n             let source_map = self.tcx.sess.source_map();\n-            if !self.tcx.has_typeck_tables(def_id) {\n+            if !self.tcx.has_typeck_results(def_id) {\n                 return false;\n             }\n             // We're emitting a suggestion, so we can just ignore regions\n             let fn_sig = self.tcx.fn_sig(def_id).skip_binder();\n \n             let other_ty = if let FnDef(def_id, _) = other_ty.kind {\n-                if !self.tcx.has_typeck_tables(def_id) {\n+                if !self.tcx.has_typeck_results(def_id) {\n                     return false;\n                 }\n                 // We're emitting a suggestion, so we can just ignore regions"}, {"sha": "42170bc199cbc3d9f0a281cc9842bcafc26645f7", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -363,7 +363,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !pat_adjustments.is_empty() {\n             debug!(\"default binding mode is now {:?}\", def_bm);\n-            self.inh.tables.borrow_mut().pat_adjustments_mut().insert(pat.hir_id, pat_adjustments);\n+            self.inh\n+                .typeck_results\n+                .borrow_mut()\n+                .pat_adjustments_mut()\n+                .insert(pat.hir_id, pat_adjustments);\n         }\n \n         (expected, def_bm)\n@@ -534,7 +538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => BindingMode::convert(ba),\n         };\n         // ...and store it in a side table:\n-        self.inh.tables.borrow_mut().pat_binding_modes_mut().insert(pat.hir_id, bm);\n+        self.inh.typeck_results.borrow_mut().pat_binding_modes_mut().insert(pat.hir_id, bm);\n \n         debug!(\"check_pat_ident: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n "}, {"sha": "12468750923554ffc79b4db2ff62b9c50cfa706f", "filename": "src/librustc_typeck/check/place_op.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -221,9 +221,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut source = self.node_ty(expr.hir_id);\n             // Do not mutate adjustments in place, but rather take them,\n             // and replace them after mutating them, to avoid having the\n-            // tables borrowed during (`deref_mut`) method resolution.\n+            // typeck results borrowed during (`deref_mut`) method resolution.\n             let previous_adjustments =\n-                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n+                self.typeck_results.borrow_mut().adjustments_mut().remove(expr.hir_id);\n             if let Some(mut adjustments) = previous_adjustments {\n                 for adjustment in &mut adjustments {\n                     if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n@@ -241,14 +241,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     source = adjustment.target;\n                 }\n-                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n+                self.typeck_results.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n             }\n \n             match expr.kind {\n                 hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n                     // We need to get the final type in case dereferences were needed for the trait\n                     // to apply (#72002).\n-                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n+                    let index_expr_ty = self.typeck_results.borrow().expr_ty_adjusted(index_expr);\n                     self.convert_place_op_to_mutable(\n                         PlaceOp::Index,\n                         expr,\n@@ -272,14 +272,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         arg_tys: &[Ty<'tcx>],\n     ) {\n         debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n-        if !self.tables.borrow().is_method_call(expr) {\n+        if !self.typeck_results.borrow().is_method_call(expr) {\n             debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n             return;\n         }\n \n         // Need to deref because overloaded place ops take self by-reference.\n         let base_ty = self\n-            .tables\n+            .typeck_results\n             .borrow()\n             .expr_ty_adjusted(base_expr)\n             .builtin_deref(false)\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // region and mutability.\n         let base_expr_ty = self.node_ty(base_expr.hir_id);\n         if let Some(adjustments) =\n-            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n+            self.typeck_results.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n         {\n             let mut source = base_expr_ty;\n             for adjustment in &mut adjustments[..] {"}, {"sha": "d8d904a15f39c39d9130c2335f0a467cc11a4c2e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n \n         let fn_sig = {\n-            match self.tables.borrow().liberated_fn_sigs().get(id) {\n+            match self.typeck_results.borrow().liberated_fn_sigs().get(id) {\n                 Some(f) => *f,\n                 None => {\n                     bug!(\"No fn-sig entry for id={:?}\", id);\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             &self.infcx,\n             self.outlives_environment.param_env,\n             self.body_owner,\n-            &self.tables.borrow(),\n+            &self.typeck_results.borrow(),\n         ))\n     }\n \n@@ -447,8 +447,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n         let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n \n-        let tables = self.tables.borrow();\n-        let adjustments = tables.expr_adjustments(&expr);\n+        let typeck_results = self.typeck_results.borrow();\n+        let adjustments = typeck_results.expr_adjustments(&expr);\n         if adjustments.is_empty() {\n             return Ok(place);\n         }\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 // `ref x` pattern\n                 if let PatKind::Binding(..) = kind {\n                     if let Some(ty::BindByReference(mutbl)) =\n-                        mc.tables.extract_binding_mode(self.tcx.sess, *hir_id, *span)\n+                        mc.typeck_results.extract_binding_mode(self.tcx.sess, *hir_id, *span)\n                     {\n                         self.link_region_from_node_type(*span, *hir_id, mutbl, &sub_cmt);\n                     }\n@@ -773,7 +773,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         debug!(\"link_upvar_region(borrorw_region={:?}, upvar_id={:?}\", borrow_region, upvar_id);\n         // A by-reference upvar can't be borrowed for longer than the\n         // upvar is borrowed from the environment.\n-        match self.tables.borrow().upvar_capture(upvar_id) {\n+        match self.typeck_results.borrow().upvar_capture(upvar_id) {\n             ty::UpvarCapture::ByRef(upvar_borrow) => {\n                 self.sub_regions(\n                     infer::ReborrowUpvar(span, upvar_id),"}, {"sha": "ffaf9ef7c9fc22b3ee13f9b932cc46eaafbb0969", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -135,13 +135,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n \n-                self.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n+                self.typeck_results.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n             }\n             // Add the vector of upvars to the map keyed with the closure id.\n             // This gives us an easier access to them without having to call\n             // tcx.upvars again..\n             if !closure_captures.is_empty() {\n-                self.tables.borrow_mut().closure_captures.insert(closure_def_id, closure_captures);\n+                self.typeck_results\n+                    .borrow_mut()\n+                    .closure_captures\n+                    .insert(closure_def_id, closure_captures);\n             }\n         }\n \n@@ -159,7 +162,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &self.infcx,\n             body_owner_def_id,\n             self.param_env,\n-            &self.tables.borrow(),\n+            &self.typeck_results.borrow(),\n         )\n         .consume_body(body);\n \n@@ -172,11 +175,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // If we have an origin, store it.\n             if let Some(origin) = delegate.current_origin {\n-                self.tables.borrow_mut().closure_kind_origins_mut().insert(closure_hir_id, origin);\n+                self.typeck_results\n+                    .borrow_mut()\n+                    .closure_kind_origins_mut()\n+                    .insert(closure_hir_id, origin);\n             }\n         }\n \n-        self.tables.borrow_mut().upvar_capture_map.extend(delegate.adjust_upvar_captures);\n+        self.typeck_results.borrow_mut().upvar_capture_map.extend(delegate.adjust_upvar_captures);\n \n         // Now that we've analyzed the closure, we know how each\n         // variable is borrowed, and we know what traits the closure\n@@ -227,7 +233,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         var_path: ty::UpvarPath { hir_id: var_hir_id },\n                         closure_expr_id: closure_def_id,\n                     };\n-                    let capture = self.tables.borrow().upvar_capture(upvar_id);\n+                    let capture = self.typeck_results.borrow().upvar_capture(upvar_id);\n \n                     debug!(\"var_id={:?} upvar_ty={:?} capture={:?}\", var_hir_id, upvar_ty, capture);\n \n@@ -392,7 +398,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             .adjust_upvar_captures\n             .get(&upvar_id)\n             .copied()\n-            .unwrap_or_else(|| self.fcx.tables.borrow().upvar_capture(upvar_id));\n+            .unwrap_or_else(|| self.fcx.typeck_results.borrow().upvar_capture(upvar_id));\n         debug!(\n             \"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n             upvar_id, upvar_capture, kind"}, {"sha": "82ee48f0b53461448e4565705e1a08999f6e9893", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 100, "deletions": 86, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -23,18 +23,18 @@ use std::mem;\n \n // During type inference, partially inferred types are\n // represented using Type variables (ty::Infer). These don't appear in\n-// the final TypeckTables since all of the types should have been\n-// inferred once typeck_tables_of is done.\n+// the final TypeckResults since all of the types should have been\n+// inferred once typeck is done.\n // When type inference is running however, having to update the typeck\n-// tables every time a new type is inferred would be unreasonably slow,\n+// typeck results every time a new type is inferred would be unreasonably slow,\n // so instead all of the replacement happens at the end in\n // resolve_type_vars_in_body, which creates a new TypeTables which\n // doesn't contain any inference types.\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn resolve_type_vars_in_body(\n         &self,\n         body: &'tcx hir::Body<'tcx>,\n-    ) -> &'tcx ty::TypeckTables<'tcx> {\n+    ) -> &'tcx ty::TypeckResults<'tcx> {\n         let item_id = self.tcx.hir().body_owner(body.id());\n         let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n@@ -65,36 +65,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_user_provided_sigs();\n         wbcx.visit_generator_interior_types();\n \n-        let used_trait_imports = mem::take(&mut self.tables.borrow_mut().used_trait_imports);\n+        let used_trait_imports =\n+            mem::take(&mut self.typeck_results.borrow_mut().used_trait_imports);\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n-        wbcx.tables.used_trait_imports = used_trait_imports;\n+        wbcx.typeck_results.used_trait_imports = used_trait_imports;\n \n-        wbcx.tables.closure_captures =\n-            mem::replace(&mut self.tables.borrow_mut().closure_captures, Default::default());\n+        wbcx.typeck_results.closure_captures = mem::replace(\n+            &mut self.typeck_results.borrow_mut().closure_captures,\n+            Default::default(),\n+        );\n \n         if self.is_tainted_by_errors() {\n             // FIXME(eddyb) keep track of `ErrorReported` from where the error was emitted.\n-            wbcx.tables.tainted_by_errors = Some(ErrorReported);\n+            wbcx.typeck_results.tainted_by_errors = Some(ErrorReported);\n         }\n \n-        debug!(\"writeback: tables for {:?} are {:#?}\", item_def_id, wbcx.tables);\n+        debug!(\"writeback: typeck results for {:?} are {:#?}\", item_def_id, wbcx.typeck_results);\n \n-        self.tcx.arena.alloc(wbcx.tables)\n+        self.tcx.arena.alloc(wbcx.typeck_results)\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // The Writeback context. This visitor walks the AST, checking the\n-// fn-specific tables to find references to types or regions. It\n+// fn-specific typeck results to find references to types or regions. It\n // resolves those regions to remove inference variables and writes the\n-// final result back into the master tables in the tcx. Here and\n+// final result back into the master typeck results in the tcx. Here and\n // there, it applies a few ad-hoc checks that were not convenient to\n // do elsewhere.\n \n struct WritebackCx<'cx, 'tcx> {\n     fcx: &'cx FnCtxt<'cx, 'tcx>,\n \n-    tables: ty::TypeckTables<'tcx>,\n+    typeck_results: ty::TypeckResults<'tcx>,\n \n     body: &'tcx hir::Body<'tcx>,\n \n@@ -109,17 +112,22 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     ) -> WritebackCx<'cx, 'tcx> {\n         let owner = body.id().hir_id.owner;\n \n-        WritebackCx { fcx, tables: ty::TypeckTables::new(owner), body, rustc_dump_user_substs }\n+        WritebackCx {\n+            fcx,\n+            typeck_results: ty::TypeckResults::new(owner),\n+            body,\n+            rustc_dump_user_substs,\n+        }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fcx.tcx\n     }\n \n-    fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'tcx>) {\n-        debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id, ty);\n+    fn write_ty_to_typeck_results(&mut self, hir_id: hir::HirId, ty: Ty<'tcx>) {\n+        debug!(\"write_ty_to_typeck_results({:?}, {:?})\", hir_id, ty);\n         assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n-        self.tables.node_types_mut().insert(hir_id, ty);\n+        self.typeck_results.node_types_mut().insert(hir_id, ty);\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n@@ -133,9 +141,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 let inner_ty = self.fcx.resolve_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n-                    let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.type_dependent_defs_mut().remove(e.hir_id);\n-                    tables.node_substs_mut().remove(e.hir_id);\n+                    let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n+                    typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n+                    typeck_results.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n             hir::ExprKind::Binary(ref op, ref lhs, ref rhs)\n@@ -147,14 +155,14 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 let rhs_ty = self.fcx.resolve_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                    let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.type_dependent_defs_mut().remove(e.hir_id);\n-                    tables.node_substs_mut().remove(e.hir_id);\n+                    let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n+                    typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n+                    typeck_results.node_substs_mut().remove(e.hir_id);\n \n                     match e.kind {\n                         hir::ExprKind::Binary(..) => {\n                             if !op.node.is_by_value() {\n-                                let mut adjustments = tables.adjustments_mut();\n+                                let mut adjustments = typeck_results.adjustments_mut();\n                                 if let Some(a) = adjustments.get_mut(lhs.hir_id) {\n                                     a.pop();\n                                 }\n@@ -164,7 +172,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             }\n                         }\n                         hir::ExprKind::AssignOp(..) => {\n-                            if let Some(a) = tables.adjustments_mut().get_mut(lhs.hir_id) {\n+                            if let Some(a) = typeck_results.adjustments_mut().get_mut(lhs.hir_id) {\n                                 a.pop();\n                             }\n                         }\n@@ -182,18 +190,18 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // usize-ish\n     fn fix_index_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         if let hir::ExprKind::Index(ref base, ref index) = e.kind {\n-            let mut tables = self.fcx.tables.borrow_mut();\n+            let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n \n             // All valid indexing looks like this; might encounter non-valid indexes at this point.\n-            let base_ty = tables.expr_ty_adjusted_opt(&base).map(|t| &t.kind);\n+            let base_ty = typeck_results.expr_ty_adjusted_opt(&base).map(|t| &t.kind);\n             if base_ty.is_none() {\n                 // When encountering `return [0][0]` outside of a `fn` body we can encounter a base\n                 // that isn't in the type table. We assume more relevant errors have already been\n                 // emitted, so we delay an ICE if none have. (#64638)\n                 self.tcx().sess.delay_span_bug(e.span, &format!(\"bad base: `{:?}`\", base));\n             }\n             if let Some(ty::Ref(_, base_ty, _)) = base_ty {\n-                let index_ty = tables.expr_ty_adjusted_opt(&index).unwrap_or_else(|| {\n+                let index_ty = typeck_results.expr_ty_adjusted_opt(&index).unwrap_or_else(|| {\n                     // When encountering `return [0][0]` outside of a `fn` body we would attempt\n                     // to access an unexistend index. We assume that more relevant errors will\n                     // already have been emitted, so we only gate on this with an ICE if no\n@@ -207,10 +215,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n                 if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n                     // Remove the method call record\n-                    tables.type_dependent_defs_mut().remove(e.hir_id);\n-                    tables.node_substs_mut().remove(e.hir_id);\n+                    typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n+                    typeck_results.node_substs_mut().remove(e.hir_id);\n \n-                    if let Some(a) = tables.adjustments_mut().get_mut(base.hir_id) {\n+                    if let Some(a) = typeck_results.adjustments_mut().get_mut(base.hir_id) {\n                         // Discard the need for a mutable borrow\n \n                         // Extra adjustment made when indexing causes a drop\n@@ -237,7 +245,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n // This is the master code which walks the AST. It delegates most of\n // the heavy lifting to the generic visit and resolve functions\n // below. In general, a function is made into a `visitor` if it must\n-// traffic in node-ids or update tables in the type context etc.\n+// traffic in node-ids or update typeck results in the type context etc.\n \n impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n     type Map = intravisit::ErasedMap<'tcx>;\n@@ -283,9 +291,11 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n     fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         match p.kind {\n             hir::PatKind::Binding(..) => {\n-                let tables = self.fcx.tables.borrow();\n-                if let Some(bm) = tables.extract_binding_mode(self.tcx().sess, p.hir_id, p.span) {\n-                    self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n+                let typeck_results = self.fcx.typeck_results.borrow();\n+                if let Some(bm) =\n+                    typeck_results.extract_binding_mode(self.tcx().sess, p.hir_id, p.span)\n+                {\n+                    self.typeck_results.pat_binding_modes_mut().insert(p.hir_id, bm);\n                 }\n             }\n             hir::PatKind::Struct(_, fields, _) => {\n@@ -306,20 +316,20 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         intravisit::walk_local(self, l);\n         let var_ty = self.fcx.local_ty(l.span, l.hir_id).decl_ty;\n         let var_ty = self.resolve(&var_ty, &l.span);\n-        self.write_ty_to_tables(l.hir_id, var_ty);\n+        self.write_ty_to_typeck_results(l.hir_id, var_ty);\n     }\n \n     fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         intravisit::walk_ty(self, hir_ty);\n         let ty = self.fcx.node_ty(hir_ty.hir_id);\n         let ty = self.resolve(&ty, &hir_ty.span);\n-        self.write_ty_to_tables(hir_ty.hir_id, ty);\n+        self.write_ty_to_typeck_results(hir_ty.hir_id, ty);\n     }\n }\n \n impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_upvar_capture_map(&mut self) {\n-        for (upvar_id, upvar_capture) in self.fcx.tables.borrow().upvar_capture_map.iter() {\n+        for (upvar_id, upvar_capture) in self.fcx.typeck_results.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n@@ -330,38 +340,38 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 }\n             };\n             debug!(\"Upvar capture for {:?} resolved to {:?}\", upvar_id, new_upvar_capture);\n-            self.tables.upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n+            self.typeck_results.upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n     fn visit_closures(&mut self) {\n-        let fcx_tables = self.fcx.tables.borrow();\n-        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner;\n+        let fcx_typeck_results = self.fcx.typeck_results.borrow();\n+        assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n+        let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&id, &origin) in fcx_tables.closure_kind_origins().iter() {\n+        for (&id, &origin) in fcx_typeck_results.closure_kind_origins().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id: id };\n-            self.tables.closure_kind_origins_mut().insert(hir_id, origin);\n+            self.typeck_results.closure_kind_origins_mut().insert(hir_id, origin);\n         }\n     }\n \n     fn visit_coercion_casts(&mut self) {\n-        let fcx_tables = self.fcx.tables.borrow();\n-        let fcx_coercion_casts = fcx_tables.coercion_casts();\n-        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let fcx_typeck_results = self.fcx.typeck_results.borrow();\n+        let fcx_coercion_casts = fcx_typeck_results.coercion_casts();\n+        assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n \n         for local_id in fcx_coercion_casts {\n-            self.tables.set_coercion_cast(*local_id);\n+            self.typeck_results.set_coercion_cast(*local_id);\n         }\n     }\n \n     fn visit_user_provided_tys(&mut self) {\n-        let fcx_tables = self.fcx.tables.borrow();\n-        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner;\n+        let fcx_typeck_results = self.fcx.typeck_results.borrow();\n+        assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n+        let common_hir_owner = fcx_typeck_results.hir_owner;\n \n         let mut errors_buffer = Vec::new();\n-        for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n+        for (&local_id, c_ty) in fcx_typeck_results.user_provided_types().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n             if cfg!(debug_assertions) && c_ty.needs_infer() {\n@@ -372,7 +382,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 );\n             };\n \n-            self.tables.user_provided_types_mut().insert(hir_id, *c_ty);\n+            self.typeck_results.user_provided_types_mut().insert(hir_id, *c_ty);\n \n             if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n                 if self.rustc_dump_user_substs {\n@@ -398,10 +408,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_user_provided_sigs(&mut self) {\n-        let fcx_tables = self.fcx.tables.borrow();\n-        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let fcx_typeck_results = self.fcx.typeck_results.borrow();\n+        assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n \n-        for (&def_id, c_sig) in fcx_tables.user_provided_sigs.iter() {\n+        for (&def_id, c_sig) in fcx_typeck_results.user_provided_sigs.iter() {\n             if cfg!(debug_assertions) && c_sig.needs_infer() {\n                 span_bug!(\n                     self.fcx.tcx.hir().span_if_local(def_id).unwrap(),\n@@ -410,14 +420,15 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 );\n             };\n \n-            self.tables.user_provided_sigs.insert(def_id, *c_sig);\n+            self.typeck_results.user_provided_sigs.insert(def_id, *c_sig);\n         }\n     }\n \n     fn visit_generator_interior_types(&mut self) {\n-        let fcx_tables = self.fcx.tables.borrow();\n-        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        self.tables.generator_interior_types = fcx_tables.generator_interior_types.clone();\n+        let fcx_typeck_results = self.fcx.typeck_results.borrow();\n+        assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n+        self.typeck_results.generator_interior_types =\n+            fcx_typeck_results.generator_interior_types.clone();\n     }\n \n     fn visit_opaque_types(&mut self, span: Span) {\n@@ -472,7 +483,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         substs: opaque_defn.substs,\n                     };\n \n-                    let old = self.tables.concrete_opaque_types.insert(def_id, new);\n+                    let old = self.typeck_results.concrete_opaque_types.insert(def_id, new);\n                     if let Some(old) = old {\n                         if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n                             span_bug!(\n@@ -494,15 +505,18 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_field_id(&mut self, hir_id: hir::HirId) {\n-        if let Some(index) = self.fcx.tables.borrow_mut().field_indices_mut().remove(hir_id) {\n-            self.tables.field_indices_mut().insert(hir_id, index);\n+        if let Some(index) = self.fcx.typeck_results.borrow_mut().field_indices_mut().remove(hir_id)\n+        {\n+            self.typeck_results.field_indices_mut().insert(hir_id, index);\n         }\n     }\n \n     fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         // Export associated path extensions and method resolutions.\n-        if let Some(def) = self.fcx.tables.borrow_mut().type_dependent_defs_mut().remove(hir_id) {\n-            self.tables.type_dependent_defs_mut().insert(hir_id, def);\n+        if let Some(def) =\n+            self.fcx.typeck_results.borrow_mut().type_dependent_defs_mut().remove(hir_id)\n+        {\n+            self.typeck_results.type_dependent_defs_mut().insert(hir_id, def);\n         }\n \n         // Resolve any borrowings for the node with id `node_id`\n@@ -511,20 +525,20 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // Resolve the type of the node with id `node_id`\n         let n_ty = self.fcx.node_ty(hir_id);\n         let n_ty = self.resolve(&n_ty, &span);\n-        self.write_ty_to_tables(hir_id, n_ty);\n+        self.write_ty_to_typeck_results(hir_id, n_ty);\n         debug!(\"node {:?} has type {:?}\", hir_id, n_ty);\n \n         // Resolve any substitutions\n-        if let Some(substs) = self.fcx.tables.borrow().node_substs_opt(hir_id) {\n+        if let Some(substs) = self.fcx.typeck_results.borrow().node_substs_opt(hir_id) {\n             let substs = self.resolve(&substs, &span);\n             debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n             assert!(!substs.needs_infer() && !substs.has_placeholders());\n-            self.tables.node_substs_mut().insert(hir_id, substs);\n+            self.typeck_results.node_substs_mut().insert(hir_id, substs);\n         }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n-        let adjustment = self.fcx.tables.borrow_mut().adjustments_mut().remove(hir_id);\n+        let adjustment = self.fcx.typeck_results.borrow_mut().adjustments_mut().remove(hir_id);\n         match adjustment {\n             None => {\n                 debug!(\"no adjustments for node {:?}\", hir_id);\n@@ -533,13 +547,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\"adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n-                self.tables.adjustments_mut().insert(hir_id, resolved_adjustment);\n+                self.typeck_results.adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n \n     fn visit_pat_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n-        let adjustment = self.fcx.tables.borrow_mut().pat_adjustments_mut().remove(hir_id);\n+        let adjustment = self.fcx.typeck_results.borrow_mut().pat_adjustments_mut().remove(hir_id);\n         match adjustment {\n             None => {\n                 debug!(\"no pat_adjustments for node {:?}\", hir_id);\n@@ -548,32 +562,32 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\"pat_adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n-                self.tables.pat_adjustments_mut().insert(hir_id, resolved_adjustment);\n+                self.typeck_results.pat_adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n \n     fn visit_liberated_fn_sigs(&mut self) {\n-        let fcx_tables = self.fcx.tables.borrow();\n-        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner;\n+        let fcx_typeck_results = self.fcx.typeck_results.borrow();\n+        assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n+        let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n+        for (&local_id, fn_sig) in fcx_typeck_results.liberated_fn_sigs().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n-            self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig);\n+            self.typeck_results.liberated_fn_sigs_mut().insert(hir_id, fn_sig);\n         }\n     }\n \n     fn visit_fru_field_types(&mut self) {\n-        let fcx_tables = self.fcx.tables.borrow();\n-        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner;\n+        let fcx_typeck_results = self.fcx.typeck_results.borrow();\n+        assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n+        let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n+        for (&local_id, ftys) in fcx_typeck_results.fru_field_types().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let ftys = self.resolve(ftys, &hir_id);\n-            self.tables.fru_field_types_mut().insert(hir_id, ftys);\n+            self.typeck_results.fru_field_types_mut().insert(hir_id, ftys);\n         }\n     }\n \n@@ -588,11 +602,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n \n         // We may have introduced e.g. `ty::Error`, if inference failed, make sure\n-        // to mark the `TypeckTables` as tainted in that case, so that downstream\n-        // users of the tables don't produce extra errors, or worse, ICEs.\n+        // to mark the `TypeckResults` as tainted in that case, so that downstream\n+        // users of the typeck results don't produce extra errors, or worse, ICEs.\n         if resolver.replaced_with_error {\n             // FIXME(eddyb) keep track of `ErrorReported` from where the error was emitted.\n-            self.tables.tainted_by_errors = Some(ErrorReported);\n+            self.typeck_results.tainted_by_errors = Some(ErrorReported);\n         }\n \n         x"}, {"sha": "ec534aa925d4f2b58fd12463e33022440bff6de4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1515,7 +1515,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         | Item(hir::Item { kind: ItemKind::Fn(sig, generics, _), ident, .. }) => {\n             match get_infer_ret_ty(&sig.decl.output) {\n                 Some(ty) => {\n-                    let fn_sig = tcx.typeck_tables_of(def_id).liberated_fn_sigs()[hir_id];\n+                    let fn_sig = tcx.typeck(def_id).liberated_fn_sigs()[hir_id];\n                     let mut visitor = PlaceholderHirTyCollector::default();\n                     visitor.visit_ty(ty);\n                     let mut diag = bad_placeholder_type(tcx, visitor.0);"}, {"sha": "8c9cd50a17d6a63ba6b95102951e16b70d4e6b1f", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -36,7 +36,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                 ..\n             }) => {\n                 let body_owner = tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n-                let tables = tcx.typeck_tables_of(body_owner);\n+                let tables = tcx.typeck(body_owner);\n                 // This may fail in case the method/path does not actually exist.\n                 // As there is no relevant param for `def_id`, we simply return\n                 // `None` here.\n@@ -76,7 +76,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                     }) => {\n                         let body_owner =\n                             tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n-                        let _tables = tcx.typeck_tables_of(body_owner);\n+                        let _tables = tcx.typeck(body_owner);\n                         &*path\n                     }\n                     _ => span_bug!(DUMMY_SP, \"unexpected const parent path {:?}\", parent_node),\n@@ -222,12 +222,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                             tcx.sess.delay_span_bug(\n                                 DUMMY_SP,\n                                 &format!(\n-                                    \"owner {:?} has no opaque type for {:?} in its tables\",\n+                                    \"owner {:?} has no opaque type for {:?} in its typeck results\",\n                                     owner, def_id,\n                                 ),\n                             );\n                             if let Some(ErrorReported) =\n-                                tcx.typeck_tables_of(owner.expect_local()).tainted_by_errors\n+                                tcx.typeck(owner.expect_local()).tainted_by_errors\n                             {\n                                 // Some error in the\n                                 // owner fn prevented us from populating\n@@ -411,16 +411,16 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     impl ConstraintLocator<'_> {\n         fn check(&mut self, def_id: LocalDefId) {\n             // Don't try to check items that cannot possibly constrain the type.\n-            if !self.tcx.has_typeck_tables(def_id) {\n+            if !self.tcx.has_typeck_results(def_id) {\n                 debug!(\n-                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`: no typeck results\",\n                     self.def_id, def_id,\n                 );\n                 return;\n             }\n             // Calling `mir_borrowck` can lead to cycle errors through\n             // const-checking, avoid calling it if we don't have to.\n-            if !self.tcx.typeck_tables_of(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n+            if !self.tcx.typeck(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n                 debug!(\n                     \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n                     self.def_id, def_id,\n@@ -604,20 +604,20 @@ fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty\n \n     let opaque_ty_def_id = opaque_ty_id.to_def_id();\n \n-    let owner_tables = tcx.typeck_tables_of(scope_def_id);\n-    let concrete_ty = owner_tables\n+    let owner_typeck_results = tcx.typeck(scope_def_id);\n+    let concrete_ty = owner_typeck_results\n         .concrete_opaque_types\n         .get(&opaque_ty_def_id)\n         .map(|opaque| opaque.concrete_type)\n         .unwrap_or_else(|| {\n             tcx.sess.delay_span_bug(\n                 DUMMY_SP,\n                 &format!(\n-                    \"owner {:?} has no opaque type for {:?} in its tables\",\n+                    \"owner {:?} has no opaque type for {:?} in its typeck results\",\n                     scope_def_id, opaque_ty_id\n                 ),\n             );\n-            if let Some(ErrorReported) = owner_tables.tainted_by_errors {\n+            if let Some(ErrorReported) = owner_typeck_results.tainted_by_errors {\n                 // Some error in the owner fn prevented us from populating the\n                 // `concrete_opaque_types` table.\n                 tcx.ty_error()\n@@ -649,7 +649,7 @@ fn infer_placeholder_type(\n     span: Span,\n     item_ident: Ident,\n ) -> Ty<'_> {\n-    let ty = tcx.diagnostic_only_typeck_tables_of(def_id).node_type(body_id.hir_id);\n+    let ty = tcx.diagnostic_only_typeck(def_id).node_type(body_id.hir_id);\n \n     // If this came from a free `const` or `static mut?` item,\n     // then the user may have written e.g. `const A = 42;`."}, {"sha": "e5bd34ff148af5000c5ff3f5915d1ad280ca2a85", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -82,16 +82,16 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     ///\n     /// - `delegate` -- who receives the callbacks\n     /// - `param_env` --- parameter environment for trait lookups (esp. pertaining to `Copy`)\n-    /// - `tables` --- typeck results for the code being analyzed\n+    /// - `typeck_results` --- typeck results for the code being analyzed\n     pub fn new(\n         delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         body_owner: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n-        tables: &'a ty::TypeckTables<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> Self {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(infcx, param_env, body_owner, tables),\n+            mc: mc::MemCategorizationContext::new(infcx, param_env, body_owner, typeck_results),\n             delegate,\n         }\n     }\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n-                if self.mc.tables.is_method_call(expr) {\n+                if self.mc.typeck_results.is_method_call(expr) {\n                     self.consume_expr(lhs);\n                 } else {\n                     self.mutate_expr(lhs);\n@@ -390,9 +390,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n-                    let is_mentioned = fields\n-                        .iter()\n-                        .any(|f| self.tcx().field_index(f.hir_id, self.mc.tables) == f_index);\n+                    let is_mentioned = fields.iter().any(|f| {\n+                        self.tcx().field_index(f.hir_id, self.mc.typeck_results) == f_index\n+                    });\n                     if !is_mentioned {\n                         let field_place = self.mc.cat_projection(\n                             &*with_expr,\n@@ -424,7 +424,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr<'_>) {\n-        let adjustments = self.mc.tables.expr_adjustments(expr);\n+        let adjustments = self.mc.typeck_results.expr_adjustments(expr);\n         let mut place_with_id = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n@@ -508,7 +508,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat,);\n-                if let Some(bm) = mc.tables.extract_binding_mode(tcx.sess, pat.hir_id, pat.span) {\n+                if let Some(bm) =\n+                    mc.typeck_results.extract_binding_mode(tcx.sess, pat.hir_id, pat.span)\n+                {\n                     debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n \n                     // pat_ty: the type of the binding being produced.\n@@ -549,7 +551,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     var_path: ty::UpvarPath { hir_id: var_id },\n                     closure_expr_id: closure_def_id,\n                 };\n-                let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n+                let upvar_capture = self.mc.typeck_results.upvar_capture(upvar_id);\n                 let captured_place = return_if_err!(self.cat_captured_var(\n                     closure_expr.hir_id,\n                     fn_decl_span,"}, {"sha": "2d7ae14d7d5a33e84d4ee870d3a1355de5abf57d", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -199,7 +199,7 @@ impl HirNode for hir::Pat<'_> {\n \n #[derive(Clone)]\n crate struct MemCategorizationContext<'a, 'tcx> {\n-    crate tables: &'a ty::TypeckTables<'tcx>,\n+    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_owner: LocalDefId,\n@@ -214,10 +214,10 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_owner: LocalDefId,\n-        tables: &'a ty::TypeckTables<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> MemCategorizationContext<'a, 'tcx> {\n         MemCategorizationContext {\n-            tables,\n+            typeck_results,\n             infcx,\n             param_env,\n             body_owner,\n@@ -272,15 +272,15 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     }\n \n     crate fn node_ty(&self, hir_id: hir::HirId) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(hir_id, self.tables.node_type_opt(hir_id))\n+        self.resolve_type_vars_or_error(hir_id, self.typeck_results.node_type_opt(hir_id))\n     }\n \n     fn expr_ty(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_opt(expr))\n+        self.resolve_type_vars_or_error(expr.hir_id, self.typeck_results.expr_ty_opt(expr))\n     }\n \n     crate fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_adjusted_opt(expr))\n+        self.resolve_type_vars_or_error(expr.hir_id, self.typeck_results.expr_ty_adjusted_opt(expr))\n     }\n \n     /// Returns the type of value that this pattern matches against.\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // that these are never attached to binding patterns, so\n         // actually this is somewhat \"disjoint\" from the code below\n         // that aims to account for `ref x`.\n-        if let Some(vec) = self.tables.pat_adjustments().get(pat.hir_id) {\n+        if let Some(vec) = self.typeck_results.pat_adjustments().get(pat.hir_id) {\n             if let Some(first_ty) = vec.first() {\n                 debug!(\"pat_ty(pat={:?}) found adjusted ty `{:?}`\", pat, first_ty);\n                 return Ok(first_ty);\n@@ -317,8 +317,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // and if so, figures out what the type *being borrowed* is.\n         let ret_ty = match pat.kind {\n             PatKind::Binding(..) => {\n-                let bm =\n-                    *self.tables.pat_binding_modes().get(pat.hir_id).expect(\"missing binding mode\");\n+                let bm = *self\n+                    .typeck_results\n+                    .pat_binding_modes()\n+                    .get(pat.hir_id)\n+                    .expect(\"missing binding mode\");\n \n                 if let ty::BindByReference(_) = bm {\n                     // a bind-by-ref means that the base_ty will be the type of the ident itself,\n@@ -358,7 +361,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n         }\n \n-        helper(self, expr, self.tables.expr_adjustments(expr))\n+        helper(self, expr, self.typeck_results.expr_adjustments(expr))\n     }\n \n     crate fn cat_expr_adjusted(\n@@ -410,7 +413,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let expr_ty = self.expr_ty(expr)?;\n         match expr.kind {\n             hir::ExprKind::Unary(hir::UnOp::UnDeref, ref e_base) => {\n-                if self.tables.is_method_call(expr) {\n+                if self.typeck_results.is_method_call(expr) {\n                     self.cat_overloaded_place(expr, e_base)\n                 } else {\n                     let base = self.cat_expr(&e_base)?;\n@@ -423,7 +426,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\", expr.hir_id, expr, base);\n \n                 let field_idx = self\n-                    .tables\n+                    .typeck_results\n                     .field_indices()\n                     .get(expr.hir_id)\n                     .cloned()\n@@ -438,7 +441,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Index(ref base, _) => {\n-                if self.tables.is_method_call(expr) {\n+                if self.typeck_results.is_method_call(expr) {\n                     // If this is an index implemented by a method call, then it\n                     // will include an implicit deref of the result.\n                     // The call to index() returns a `&T` value, which\n@@ -452,7 +455,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Path(ref qpath) => {\n-                let res = self.tables.qpath_res(qpath, expr.hir_id);\n+                let res = self.typeck_results.qpath_res(qpath, expr.hir_id);\n                 self.cat_res(expr.hir_id, expr.span, expr_ty, res)\n             }\n \n@@ -646,8 +649,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         pat_hir_id: hir::HirId,\n         span: Span,\n     ) -> McResult<VariantIdx> {\n-        let res = self.tables.qpath_res(qpath, pat_hir_id);\n-        let ty = self.tables.node_type(pat_hir_id);\n+        let res = self.typeck_results.qpath_res(qpath, pat_hir_id);\n+        let ty = self.typeck_results.node_type(pat_hir_id);\n         let adt_def = match ty.kind {\n             ty::Adt(adt_def, _) => adt_def,\n             _ => {\n@@ -682,7 +685,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         variant_index: VariantIdx,\n         span: Span,\n     ) -> McResult<usize> {\n-        let ty = self.tables.node_type(pat_hir_id);\n+        let ty = self.typeck_results.node_type(pat_hir_id);\n         match ty.kind {\n             ty::Adt(adt_def, _) => Ok(adt_def.variants[variant_index].fields.len()),\n             _ => {\n@@ -697,7 +700,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Returns the total number of fields in a tuple used within a Tuple pattern.\n     /// Here `pat_hir_id` is the HirId of the pattern itself.\n     fn total_fields_in_tuple(&self, pat_hir_id: hir::HirId, span: Span) -> McResult<usize> {\n-        let ty = self.tables.node_type(pat_hir_id);\n+        let ty = self.typeck_results.node_type(pat_hir_id);\n         match ty.kind {\n             ty::Tuple(substs) => Ok(substs.len()),\n             _ => {\n@@ -758,7 +761,9 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // Then we see that to get the same result, we must start with\n         // `deref { deref { place_foo }}` instead of `place_foo` since the pattern is now `Some(x,)`\n         // and not `&&Some(x,)`, even though its assigned type is that of `&&Some(x,)`.\n-        for _ in 0..self.tables.pat_adjustments().get(pat.hir_id).map(|v| v.len()).unwrap_or(0) {\n+        for _ in\n+            0..self.typeck_results.pat_adjustments().get(pat.hir_id).map(|v| v.len()).unwrap_or(0)\n+        {\n             debug!(\"cat_pattern: applying adjustment to place_with_id={:?}\", place_with_id);\n             place_with_id = self.cat_deref(pat, place_with_id)?;\n         }\n@@ -813,7 +818,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n                     let field_index = self\n-                        .tables\n+                        .typeck_results\n                         .field_indices()\n                         .get(fp.hir_id)\n                         .cloned()"}, {"sha": "bbe2555d56c265555cb3c64c6a33201040d1abb2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -380,30 +380,30 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         override_queries: Some(|_sess, providers, _external_providers| {\n             // Most lints will require typechecking, so just don't run them.\n             providers.lint_mod = |_, _| {};\n-            // Prevent `rustc_typeck::check_crate` from calling `typeck_tables_of` on all bodies.\n+            // Prevent `rustc_typeck::check_crate` from calling `typeck` on all bodies.\n             providers.typeck_item_bodies = |_, _| {};\n-            // hack so that `used_trait_imports` won't try to call typeck_tables_of\n+            // hack so that `used_trait_imports` won't try to call typeck\n             providers.used_trait_imports = |_, _| {\n                 lazy_static! {\n                     static ref EMPTY_SET: FxHashSet<LocalDefId> = FxHashSet::default();\n                 }\n                 &EMPTY_SET\n             };\n             // In case typeck does end up being called, don't ICE in case there were name resolution errors\n-            providers.typeck_tables_of = move |tcx, def_id| {\n+            providers.typeck = move |tcx, def_id| {\n                 // Closures' tables come from their outermost function,\n                 // as they are part of the same \"inference environment\".\n-                // This avoids emitting errors for the parent twice (see similar code in `typeck_tables_of_with_fallback`)\n+                // This avoids emitting errors for the parent twice (see similar code in `typeck_with_fallback`)\n                 let outer_def_id = tcx.closure_base_def_id(def_id.to_def_id()).expect_local();\n                 if outer_def_id != def_id {\n-                    return tcx.typeck_tables_of(outer_def_id);\n+                    return tcx.typeck(outer_def_id);\n                 }\n \n                 let hir = tcx.hir();\n                 let body = hir.body(hir.body_owned_by(hir.as_local_hir_id(def_id)));\n                 debug!(\"visiting body for {:?}\", def_id);\n                 EmitIgnoredResolutionErrors::new(tcx).visit_body(body);\n-                (rustc_interface::DEFAULT_QUERY_PROVIDERS.typeck_tables_of)(tcx, def_id)\n+                (rustc_interface::DEFAULT_QUERY_PROVIDERS.typeck)(tcx, def_id)\n             };\n         }),\n         registry: rustc_driver::diagnostics_registry(),"}, {"sha": "2af72f0e98764838b2241b6c6537ed2267e70a87", "filename": "src/test/incremental/add_private_fn_at_krate_root_cc/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fstruct_point.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -24,7 +24,7 @@ extern crate point;\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -35,7 +35,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_free_fn {\n     use point::{self, Point};\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         point::distance_squared(&x);\n@@ -46,7 +46,7 @@ pub mod fn_calls_free_fn {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -56,7 +56,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -66,7 +66,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "0245374007985c3f2bab1dd5855585a1608d3f45", "filename": "src/test/incremental/callee_caller_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -6,12 +6,12 @@\n \n extern crate a;\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn call_function0() {\n     a::function0(77);\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn call_function1() {\n     a::function1(77);\n }"}, {"sha": "89699bce209f0e8cfae4d5fcebeb2890b6b67df9", "filename": "src/test/incremental/change_add_field/struct_point.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -70,7 +70,7 @@ pub mod point {\n pub mod fn_with_type_in_sig {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn boop(p: Option<&Point>) -> f32 {\n         p.map(|p| p.total()).unwrap_or(0.0)\n     }\n@@ -86,7 +86,7 @@ pub mod fn_with_type_in_sig {\n pub mod call_fn_with_type_in_sig {\n     use fn_with_type_in_sig;\n \n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn bip() -> f32 {\n         fn_with_type_in_sig::boop(None)\n     }\n@@ -102,7 +102,7 @@ pub mod call_fn_with_type_in_sig {\n pub mod fn_with_type_in_body {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn boop() -> f32 {\n         Point::origin().total()\n     }\n@@ -115,7 +115,7 @@ pub mod fn_with_type_in_body {\n pub mod call_fn_with_type_in_body {\n     use fn_with_type_in_body;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn bip() -> f32 {\n         fn_with_type_in_body::boop()\n     }\n@@ -125,7 +125,7 @@ pub mod call_fn_with_type_in_body {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn make_origin(p: Point) -> Point {\n         Point { ..p }\n     }\n@@ -135,7 +135,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -145,7 +145,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "7448b54dd079c4870172f4b3ad874d13520caac5", "filename": "src/test/incremental/change_crate_order/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_crate_order%2Fmain.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -18,7 +18,7 @@ extern crate a;\n use a::A;\n use b::B;\n \n-//? #[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+//? #[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn main() {\n     A + B;\n }"}, {"sha": "ba4bf4e7b7d20a2126554045777b33000649ed23", "filename": "src/test/incremental/change_private_fn/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -51,7 +51,7 @@ pub mod point {\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -62,7 +62,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n@@ -73,7 +73,7 @@ pub mod fn_calls_methods_in_another_impl {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -83,7 +83,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -93,7 +93,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "5072ef609e2cc951e947dad39d1c6787c64dc61d", "filename": "src/test/incremental/change_private_fn_cc/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -23,7 +23,7 @@ extern crate point;\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -34,7 +34,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n@@ -45,7 +45,7 @@ pub mod fn_calls_methods_in_another_impl {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -55,7 +55,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -65,7 +65,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "5c024ed91a3bfb1717938bec35a1130b57ed72ff", "filename": "src/test/incremental/change_private_impl_method/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -51,7 +51,7 @@ pub mod point {\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -62,7 +62,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n@@ -73,7 +73,7 @@ pub mod fn_calls_methods_in_another_impl {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -83,7 +83,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -93,7 +93,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "2aeecfc89d5c099875349be8c0dc7e73836653cd", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -24,7 +24,7 @@ extern crate point;\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -35,7 +35,7 @@ pub mod fn_calls_methods_in_same_impl {\n pub mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn dirty() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n@@ -46,7 +46,7 @@ pub mod fn_calls_methods_in_another_impl {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -56,7 +56,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -66,7 +66,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "c944901e34542ecdcbbc81702f41b45e69c434a7", "filename": "src/test/incremental/change_pub_inherent_method_body/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_body%2Fstruct_point.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -42,7 +42,7 @@ pub mod point {\n pub mod fn_calls_changed_method {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.distance_from_origin();\n@@ -53,7 +53,7 @@ pub mod fn_calls_changed_method {\n pub mod fn_calls_another_method {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.x();\n@@ -64,7 +64,7 @@ pub mod fn_calls_another_method {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -74,7 +74,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -84,7 +84,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "4a5aac682f5aaa173f3b4e63f73467c2deef25df", "filename": "src/test/incremental/change_pub_inherent_method_sig/struct_point.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_pub_inherent_method_sig%2Fstruct_point.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -52,7 +52,7 @@ pub mod point {\n pub mod fn_calls_changed_method {\n     use point::Point;\n \n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.distance_from_point(None);\n@@ -63,7 +63,7 @@ pub mod fn_calls_changed_method {\n pub mod fn_calls_another_method {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn check() {\n         let p = Point { x: 2.0, y: 2.0 };\n         p.x();\n@@ -74,7 +74,7 @@ pub mod fn_calls_another_method {\n pub mod fn_make_struct {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -84,7 +84,7 @@ pub mod fn_make_struct {\n pub mod fn_read_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -94,7 +94,7 @@ pub mod fn_read_field {\n pub mod fn_write_field {\n     use point::Point;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "2a1056df4cecacb99ed020dc81accb6029398383", "filename": "src/test/incremental/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fdirty_clean.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -25,16 +25,16 @@ mod x {\n mod y {\n     use x;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn y() {\n-        //[cfail2]~^ ERROR `typeck_tables_of(y::y)` should be clean but is not\n+        //[cfail2]~^ ERROR `typeck(y::y)` should be clean but is not\n         x::x();\n     }\n }\n \n mod z {\n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n     pub fn z() {\n-        //[cfail2]~^ ERROR `typeck_tables_of(z::z)` should be dirty but is not\n+        //[cfail2]~^ ERROR `typeck(z::z)` should be dirty but is not\n     }\n }"}, {"sha": "d4511cee75bb9740d43c3d6f218ffbf545492896", "filename": "src/test/incremental/hashes/call_expressions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -25,7 +25,7 @@ pub fn change_callee_function() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_callee_function() {\n     callee2(1, 2)\n@@ -81,7 +81,7 @@ pub fn change_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_callee_method() {\n     let s = Struct;\n@@ -115,7 +115,7 @@ pub fn change_ufcs_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_ufcs_callee_method() {\n     let s = Struct;\n@@ -149,7 +149,7 @@ pub fn change_to_ufcs() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n // One might think this would be expanded in the hir_owner_nodes/Mir, but it actually\n // results in slightly different hir_owner/Mir.\n@@ -171,7 +171,7 @@ pub mod change_ufcs_callee_indirectly {\n     #[cfg(not(cfail1))]\n     use super::Struct2 as Struct;\n \n-    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n \n "}, {"sha": "7372cbc9156086d21c16f31073eb315e7f89c3e2", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -37,7 +37,7 @@ pub fn add_parameter() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_parameter() {\n     let x = 0u32;\n@@ -53,7 +53,7 @@ pub fn change_parameter_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_parameter_pattern() {\n     let _ = |(x,): (u32,)| x;\n@@ -84,7 +84,7 @@ pub fn add_type_ascription_to_parameter() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner_nodes, typeck_tables_of\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner_nodes, typeck\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn add_type_ascription_to_parameter() {\n     let closure = |x: u32| x + 1u32;\n@@ -101,7 +101,7 @@ pub fn change_parameter_type() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_parameter_type() {\n     let closure = |x: u16| (x as u64) + 1;"}, {"sha": "4161c6a6bfcded44ab9d24b3472c72303b941d20", "filename": "src/test/incremental/hashes/enum_constructors.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -57,7 +57,7 @@ pub fn change_field_order_struct_like() -> Enum {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n // FIXME(michaelwoerister):Interesting. I would have thought that that changes the MIR. And it\n // would if it were not all constants\n@@ -96,7 +96,7 @@ pub fn change_constructor_path_struct_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_struct_like() {\n     let _ = Enum2::Struct {\n@@ -140,7 +140,7 @@ pub mod change_constructor_path_indirectly_struct_like {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n         except=\"fn_sig,hir_owner,hir_owner_nodes,optimized_mir,\\\n-                typeck_tables_of\"\n+                typeck\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> TheEnum {\n@@ -197,7 +197,7 @@ pub fn change_constructor_path_tuple_like() {\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\"\n+    except=\"hir_owner_nodes,optimized_mir,typeck\"\n )]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_tuple_like() {\n@@ -215,7 +215,7 @@ pub fn change_constructor_variant_tuple_like() {\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\"\n+    except=\"hir_owner_nodes,optimized_mir,typeck\"\n )]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_variant_tuple_like() {\n@@ -233,7 +233,7 @@ pub mod change_constructor_path_indirectly_tuple_like {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n         except=\"fn_sig,hir_owner,hir_owner_nodes,optimized_mir,\\\n-                typeck_tables_of\"\n+                typeck\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> TheEnum {\n@@ -251,7 +251,7 @@ pub mod change_constructor_variant_indirectly_tuple_like {\n     #[cfg(not(cfail1))]\n     use super::Enum2::Tuple2 as Variant;\n \n-    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Enum2 {\n         Variant(0, 1, 2)\n@@ -278,7 +278,7 @@ pub fn change_constructor_path_c_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_c_like() {\n     let _x = Clike2::B;\n@@ -310,7 +310,7 @@ pub mod change_constructor_path_indirectly_c_like {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n         except=\"fn_sig,hir_owner,hir_owner_nodes,optimized_mir,\\\n-                typeck_tables_of\"\n+                typeck\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> TheEnum {"}, {"sha": "e1460503d2d9424d0a0adf515ef7cf1e40342c72", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -71,7 +71,7 @@ pub fn change_iteration_variable_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_iteration_variable_pattern() {\n     let mut _x = 0;\n@@ -116,7 +116,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;"}, {"sha": "706cbcf4caf34da5b54aebd6f53f98fa7f29a35b", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -22,7 +22,7 @@ pub fn add_parameter() {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck_tables_of, fn_sig\"\n+    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck, fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn add_parameter(p: i32) {}\n@@ -45,7 +45,7 @@ pub fn type_of_parameter(p: i32) {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck_tables_of, fn_sig\"\n+    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck, fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn type_of_parameter(p: i64) {}\n@@ -58,7 +58,7 @@ pub fn type_of_parameter_ref(p: &i32) {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck_tables_of, fn_sig\"\n+    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck, fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn type_of_parameter_ref(p: &mut i32) {}\n@@ -71,7 +71,7 @@ pub fn order_of_parameters(p1: i32, p2: i64) {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck_tables_of, fn_sig\"\n+    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck, fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn order_of_parameters(p2: i64, p1: i32) {}\n@@ -84,7 +84,7 @@ pub fn make_unsafe() {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck_tables_of, fn_sig\"\n+    except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck, fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub unsafe fn make_unsafe() {}\n@@ -95,7 +95,7 @@ pub unsafe fn make_unsafe() {}\n pub fn make_extern() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck_tables_of, fn_sig\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub extern \"C\" fn make_extern() {}\n \n@@ -241,7 +241,7 @@ pub fn return_impl_trait() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck_tables_of, fn_sig\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn return_impl_trait() -> impl Clone {\n     0\n@@ -274,7 +274,7 @@ pub mod change_return_type_indirectly {\n \n     #[rustc_clean(\n         cfg = \"cfail2\",\n-        except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck_tables_of, fn_sig\"\n+        except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck, fn_sig\"\n     )]\n     #[rustc_clean(cfg = \"cfail3\")]\n     pub fn indirect_return_type() -> ReturnType {\n@@ -292,7 +292,7 @@ pub mod change_parameter_type_indirectly {\n \n     #[rustc_clean(\n         cfg = \"cfail2\",\n-        except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck_tables_of, fn_sig\"\n+        except = \"hir_owner, hir_owner_nodes, optimized_mir, typeck, fn_sig\"\n     )]\n     #[rustc_clean(cfg = \"cfail3\")]\n     pub fn indirect_parameter_type(p: ParameterType) {}"}, {"sha": "59af1fc09c2de5097aa4db459dee89ae2612c6b6", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -25,7 +25,7 @@ pub fn change_condition(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_condition(x: bool) -> u32 {\n     if !x {\n@@ -120,7 +120,7 @@ pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n     if let Some(_) = x {\n@@ -143,7 +143,7 @@ pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {"}, {"sha": "fcd12ad30ebc92955adf0e61c5b7467c6248ce8a", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -44,7 +44,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner_nodes,optimized_mir,promoted_mir,typeck_tables_of\"\n+        except=\"hir_owner_nodes,optimized_mir,promoted_mir,typeck\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn method_body() {\n@@ -68,7 +68,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner_nodes,optimized_mir,promoted_mir,typeck_tables_of\"\n+        except=\"hir_owner_nodes,optimized_mir,promoted_mir,typeck\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     #[inline]\n@@ -120,7 +120,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner,hir_owner_nodes,fn_sig,typeck_tables_of,optimized_mir\"\n+        except=\"hir_owner,hir_owner_nodes,fn_sig,typeck,optimized_mir\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn method_selfmutness(&mut self) { }\n@@ -160,7 +160,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner,hir_owner_nodes,fn_sig,typeck_tables_of,optimized_mir\"\n+        except=\"hir_owner,hir_owner_nodes,fn_sig,typeck,optimized_mir\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_method_parameter(&self, _: i32) { }\n@@ -197,7 +197,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner,hir_owner_nodes,fn_sig,optimized_mir,typeck_tables_of\")]\n+        except=\"hir_owner,hir_owner_nodes,fn_sig,optimized_mir,typeck\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn change_method_return_type(&self) -> u8 { 0 }\n }\n@@ -251,7 +251,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner,hir_owner_nodes,fn_sig,typeck_tables_of,optimized_mir\"\n+        except=\"hir_owner,hir_owner_nodes,fn_sig,typeck,optimized_mir\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub unsafe fn make_method_unsafe(&self) { }\n@@ -269,7 +269,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,fn_sig,typeck_tables_of\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,fn_sig,typeck\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub extern fn make_method_extern(&self) { }\n }\n@@ -286,7 +286,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,fn_sig,typeck_tables_of\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,fn_sig,typeck\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub extern \"system\" fn change_method_calling_convention(&self) { }\n }\n@@ -303,15 +303,15 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    // Warning: Note that `typeck_tables_of` are coming up clean here.\n+    // Warning: Note that `typeck` are coming up clean here.\n     // The addition or removal of lifetime parameters that don't\n     // appear in the arguments or fn body in any way does not, in\n-    // fact, affect the `typeck_tables_of` in any semantic way (at least\n+    // fact, affect the `typeck` in any semantic way (at least\n     // as of this writing). **However,** altering the order of\n-    // lowering **can** cause it appear to affect the `typeck_tables_of`:\n+    // lowering **can** cause it appear to affect the `typeck`:\n     // if we lower generics before the body, then the `HirId` for\n     // things in the body will be affected. So if you start to see\n-    // `typeck_tables_of` appear dirty, that might be the cause. -nmatsakis\n+    // `typeck` appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_parameter_to_method<'a>(&self) { }\n@@ -329,14 +329,14 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    // Warning: Note that `typeck_tables_of` are coming up clean here.\n+    // Warning: Note that `typeck` are coming up clean here.\n     // The addition or removal of type parameters that don't appear in\n     // the arguments or fn body in any way does not, in fact, affect\n-    // the `typeck_tables_of` in any semantic way (at least as of this\n+    // the `typeck` in any semantic way (at least as of this\n     // writing). **However,** altering the order of lowering **can**\n-    // cause it appear to affect the `typeck_tables_of`: if we lower\n+    // cause it appear to affect the `typeck`: if we lower\n     // generics before the body, then the `HirId` for things in the\n-    // body will be affected. So if you start to see `typeck_tables_of`\n+    // body will be affected. So if you start to see `typeck`\n     // appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(\n         cfg=\"cfail2\",\n@@ -378,14 +378,14 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    // Warning: Note that `typeck_tables_of` are coming up clean here.\n+    // Warning: Note that `typeck` are coming up clean here.\n     // The addition or removal of bounds that don't appear in the\n     // arguments or fn body in any way does not, in fact, affect the\n-    // `typeck_tables_of` in any semantic way (at least as of this\n+    // `typeck` in any semantic way (at least as of this\n     // writing). **However,** altering the order of lowering **can**\n-    // cause it appear to affect the `typeck_tables_of`: if we lower\n+    // cause it appear to affect the `typeck`: if we lower\n     // generics before the body, then the `HirId` for things in the\n-    // body will be affected. So if you start to see `typeck_tables_of`\n+    // body will be affected. So if you start to see `typeck`\n     // appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of,\\\n                                         type_of\")]\n@@ -405,14 +405,14 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    // Warning: Note that `typeck_tables_of` are coming up clean here.\n+    // Warning: Note that `typeck` are coming up clean here.\n     // The addition or removal of bounds that don't appear in the\n     // arguments or fn body in any way does not, in fact, affect the\n-    // `typeck_tables_of` in any semantic way (at least as of this\n+    // `typeck` in any semantic way (at least as of this\n     // writing). **However,** altering the order of lowering **can**\n-    // cause it appear to affect the `typeck_tables_of`: if we lower\n+    // cause it appear to affect the `typeck`: if we lower\n     // generics before the body, then the `HirId` for things in the\n-    // body will be affected. So if you start to see `typeck_tables_of`\n+    // body will be affected. So if you start to see `typeck`\n     // appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n@@ -453,7 +453,7 @@ impl Bar<u32> {\n impl<T> Bar<T> {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"generics_of,fn_sig,typeck_tables_of,type_of,optimized_mir\"\n+        except=\"generics_of,fn_sig,typeck,type_of,optimized_mir\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_type_parameter_to_impl(&self) { }\n@@ -471,7 +471,7 @@ impl Bar<u32> {\n #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Bar<u64> {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"fn_sig,optimized_mir,typeck_tables_of\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"fn_sig,optimized_mir,typeck\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn change_impl_self_type(&self) { }\n }"}, {"sha": "918e72582d6978289c736000f5d769463f933372", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -38,7 +38,7 @@ pub fn add_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_type() {\n     let _x: u32 = 2u32;\n@@ -54,7 +54,7 @@ pub fn change_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of,optimized_mir\")]\n+    except=\"hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_type() {\n     let _x: u8 = 2;\n@@ -70,7 +70,7 @@ pub fn change_mutability_of_reference_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of,optimized_mir\")]\n+    except=\"hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_reference_type() {\n     let _x: &mut u64;\n@@ -86,7 +86,7 @@ pub fn change_mutability_of_slot() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of,optimized_mir\")]\n+    except=\"hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_slot() {\n     let _x: u64 = 0;\n@@ -102,7 +102,7 @@ pub fn change_simple_binding_to_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of,optimized_mir\")]\n+    except=\"hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_simple_binding_to_pattern() {\n     let (_a, _b) = (0u8, 'x');\n@@ -134,7 +134,7 @@ pub fn add_ref_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of,optimized_mir\")]\n+    except=\"hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_ref_in_pattern() {\n     let (ref _a, _b) = (1u8, 'y');\n@@ -150,7 +150,7 @@ pub fn add_amp_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of,optimized_mir\")]\n+    except=\"hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_amp_in_pattern() {\n     let (&_a, _b) = (&1u8, 'y');\n@@ -166,7 +166,7 @@ pub fn change_mutability_of_binding_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of,optimized_mir\")]\n+    except=\"hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern() {\n     let (mut _a, _b) = (99u8, 'q');\n@@ -182,7 +182,7 @@ pub fn add_initializer() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,typeck_tables_of,optimized_mir\")]\n+    except=\"hir_owner_nodes,typeck,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_initializer() {\n     let _x: i16 = 3i16;"}, {"sha": "178def016a25f0ed607100204add86289fa9f475", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -47,7 +47,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -118,7 +118,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -168,7 +168,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -193,7 +193,7 @@ pub fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "969f930f57bdfb2f675b978fc199befd240a69fa", "filename": "src/test/incremental/hashes/match_expressions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -26,7 +26,7 @@ pub fn add_arm(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_arm(x: u32) -> u32 {\n     match x {\n@@ -75,7 +75,7 @@ pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -99,7 +99,7 @@ pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -123,7 +123,7 @@ pub fn add_at_binding(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_at_binding(x: u32) -> u32 {\n     match x {\n@@ -170,7 +170,7 @@ pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -216,7 +216,7 @@ pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -238,7 +238,7 @@ pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -260,7 +260,7 @@ pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n     match (&x, x & 1) {\n@@ -307,7 +307,7 @@ pub fn add_alternative_to_arm(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+    except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_alternative_to_arm(x: u32) -> u32 {\n     match x {"}, {"sha": "edec03d4f057e01556e4fad11b11db31a211e56a", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -54,7 +54,7 @@ pub fn change_field_order_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_order_regular_struct() -> RegularStruct {\n     RegularStruct {\n@@ -82,7 +82,7 @@ pub fn add_field_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_field_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -117,7 +117,7 @@ pub fn change_field_label_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_label_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -152,7 +152,7 @@ pub fn change_constructor_path_regular_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_regular_struct() {\n     let _ = RegularStruct2 {\n@@ -173,7 +173,7 @@ pub mod change_constructor_path_indirectly_regular_struct {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"fn_sig,hir_owner,hir_owner_nodes,optimized_mir,typeck_tables_of\"\n+        except=\"fn_sig,hir_owner,hir_owner_nodes,optimized_mir,typeck\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Struct {\n@@ -213,7 +213,7 @@ pub fn change_constructor_path_tuple_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_tuple_struct() {\n     let _ = TupleStruct2(0, 1, 2);\n@@ -230,7 +230,7 @@ pub mod change_constructor_path_indirectly_tuple_struct {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"fn_sig,hir_owner,hir_owner_nodes,optimized_mir,typeck_tables_of\"\n+        except=\"fn_sig,hir_owner,hir_owner_nodes,optimized_mir,typeck\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Struct {"}, {"sha": "687580ec8afb24b10b3ae5ba5e2ce0c95ca674f6", "filename": "src/test/incremental/hashes/unary_and_binary_exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -368,7 +368,7 @@ pub fn type_cast(a: u8) -> u64 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"hir_owner_nodes,optimized_mir,typeck_tables_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner_nodes,optimized_mir,typeck\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn type_cast(a: u8) -> u64 {\n     let b = a as u32;"}, {"sha": "290f1b66a73690047e1d076cccc337363d5ecc85", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -70,7 +70,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;"}, {"sha": "1049dabacf2e1e9731d028db1f52281b905fe6d3", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -70,7 +70,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, optimized_mir, typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;"}, {"sha": "4c60d7bd9d52653aba2c9df8a98815399013dda7", "filename": "src/test/incremental/hello_world.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fhello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhello_world.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -21,7 +21,7 @@ mod x {\n mod y {\n     use x;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n     pub fn yyyy() {\n         x::xxxx();\n     }\n@@ -30,7 +30,7 @@ mod y {\n mod z {\n     use y;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n     pub fn z() {\n         y::yyyy();\n     }"}, {"sha": "6d7d446cb7c55bca785d230f16011d1376dd0c7e", "filename": "src/test/incremental/ich_method_call_trait_scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -28,14 +28,14 @@ mod mod3 {\n \n     #[rustc_clean(label=\"hir_owner\", cfg=\"rpass2\")]\n     #[rustc_clean(label=\"hir_owner_nodes\", cfg=\"rpass2\")]\n-    #[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n     fn bar() {\n         ().method();\n     }\n \n     #[rustc_clean(label=\"hir_owner\", cfg=\"rpass2\")]\n     #[rustc_clean(label=\"hir_owner_nodes\", cfg=\"rpass2\")]\n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n     fn baz() {\n         22; // no method call, traits in scope don't matter\n     }"}, {"sha": "73846712b59606303827df982fdacca965838e60", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -12,15 +12,15 @@\n \n extern crate a;\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass3\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass3\")]\n pub fn use_X() -> u32 {\n     let x: a::X = 22;\n     x as u32\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass3\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass3\")]\n pub fn use_Y() {\n     let x: a::Y = 'c';\n }"}, {"sha": "2fc725294313bc94f8af36cd3823f6392776c383", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -28,7 +28,7 @@ pub mod x {\n pub mod y {\n     use x;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"optimized_mir\", cfg=\"cfail2\")]\n     pub fn y() {\n         x::x();\n@@ -38,7 +38,7 @@ pub mod y {\n pub mod z {\n     use y;\n \n-    #[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"optimized_mir\", cfg=\"cfail2\")]\n     pub fn z() {\n         y::y();"}, {"sha": "4c29f196f67c975fb70f0af8decbe0167c4fb7f8", "filename": "src/test/incremental/struct_add_field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_add_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_add_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_add_field.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -21,17 +21,17 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_X(x: X) -> u32 {\n     x.x as u32\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_EmbedX(embed: EmbedX) -> u32 {\n     embed.x.x as u32\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "ee88fbdf59275b9ab48069618febdf9971b778c7", "filename": "src/test/incremental/struct_change_field_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -24,21 +24,21 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n     //[cfail2]~^ ERROR struct `X` has no field named `x`\n     x.x as u32\n     //[cfail2]~^ ERROR no field `x` on type `X`\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"cfail2\")]\n pub fn use_EmbedX(embed: EmbedX) -> u32 {\n     embed.x.x as u32\n     //[cfail2]~^ ERROR no field `x` on type `X`\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"cfail2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "b60b4b311eeb33cf4dcc534497e5ab591625bd66", "filename": "src/test/incremental/struct_change_field_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -24,19 +24,19 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_EmbedX(x: EmbedX) -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "0221d510eaba7dfed6d272bc0fac3bd80cbd7df0", "filename": "src/test/incremental/struct_change_field_type_cross_crate/b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -8,18 +8,18 @@ extern crate a;\n \n use a::*;\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_EmbedX(embed: EmbedX) -> u32 {\n     embed.x.x as u32\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "3ab90e966fb6d7bea2cee20dadc412fcbc2732fe", "filename": "src/test/incremental/struct_change_nothing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -24,19 +24,19 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_EmbedX(x: EmbedX) -> u32 {\n     let x: X = X { x: 22 };\n     x.x as u32\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "f6017b1b1c3a66c47dfaeae160af69b29be494cd", "filename": "src/test/incremental/struct_remove_field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -25,17 +25,17 @@ pub struct Y {\n     pub y: char\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_X(x: X) -> u32 {\n     x.x as u32\n }\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_EmbedX(embed: EmbedX) -> u32 {\n     embed.x.x as u32\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n pub fn use_Y() {\n     let x: Y = Y { y: 'c' };\n }"}, {"sha": "05c926fdded7c82a466b291ca449ec1fdeaa75df", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -6,15 +6,15 @@\n \n extern crate a;\n \n-#[rustc_dirty(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass3\")]\n+#[rustc_dirty(label=\"typeck\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass3\")]\n pub fn use_X() -> u32 {\n     let x: a::X = 22;\n     x as u32\n }\n \n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"typeck_tables_of\", cfg=\"rpass3\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"typeck\", cfg=\"rpass3\")]\n pub fn use_Y() {\n     let x: a::Y = 'c';\n }"}, {"sha": "0d11d933af04e16af507ce8098260a03dab6f9f2", "filename": "src/test/ui/dep-graph/dep-graph-assoc-type-codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -25,7 +25,7 @@ mod x {\n mod y {\n     use Foo;\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn use_char_assoc() {\n         // Careful here: in the representation, <char as Foo>::T gets\n         // normalized away, so at a certain point we had no edge to"}, {"sha": "4e659648e9edce5a2d07fdbad3287b57c4b5b8f9", "filename": "src/test/ui/dep-graph/dep-graph-assoc-type-codegen.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-assoc-type-codegen.stderr?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1,8 +1,8 @@\n error: OK\n   --> $DIR/dep-graph-assoc-type-codegen.rs:28:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b12c635d2e733db2b5c00c5f41085f44b632b71a", "filename": "src/test/ui/dep-graph/dep-graph-caller-callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -17,7 +17,7 @@ mod y {\n     use x;\n \n     // These dependencies SHOULD exist:\n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn y() {\n         x::x();\n     }\n@@ -28,7 +28,7 @@ mod z {\n \n     // These are expected to yield errors, because changes to `x`\n     // affect the BODY of `y`, but not its signature.\n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR no path\n     pub fn z() {\n         y::y();\n     }"}, {"sha": "164c474183ad04ec1cfe1db64ed811a2c9c8afdf", "filename": "src/test/ui/dep-graph/dep-graph-caller-callee.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-caller-callee.stderr?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1,14 +1,14 @@\n error: OK\n   --> $DIR/dep-graph-caller-callee.rs:20:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `x::x` to `typeck_tables_of`\n+error: no path from `x::x` to `typeck`\n   --> $DIR/dep-graph-caller-callee.rs:31:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7ef6fac48c3a6c54f17d541b607839c78b645f69", "filename": "src/test/ui/dep-graph/dep-graph-struct-signature.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -33,26 +33,26 @@ mod signatures {\n     }\n \n     #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     fn some_fn(x: WillChange) { }\n \n     #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     fn new_foo(x: u32, y: u32) -> WillChange {\n         WillChange { x: x, y: y }\n     }\n \n     #[rustc_then_this_would_need(type_of)] //~ ERROR OK\n     impl WillChange {\n         #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n-        #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+        #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n         fn new(x: u32, y: u32) -> WillChange { loop { } }\n     }\n \n     #[rustc_then_this_would_need(type_of)] //~ ERROR OK\n     impl WillChange {\n         #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n-        #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+        #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n         fn method(&self, x: u32) { }\n     }\n \n@@ -81,6 +81,6 @@ mod invalid_signatures {\n     fn b(x: WontChange) { }\n \n     #[rustc_then_this_would_need(fn_sig)] //~ ERROR no path from `WillChange`\n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path from `WillChange`\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR no path from `WillChange`\n     fn c(x: u32) { }\n }"}, {"sha": "9d1644a00d0024eab79548a7af3d05551022efbd", "filename": "src/test/ui/dep-graph/dep-graph-struct-signature.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -25,8 +25,8 @@ LL |     #[rustc_then_this_would_need(fn_sig)]\n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:36:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:39:5\n@@ -37,8 +37,8 @@ LL |     #[rustc_then_this_would_need(fn_sig)]\n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:40:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:45:5\n@@ -88,11 +88,11 @@ error: no path from `WillChange` to `fn_sig`\n LL |     #[rustc_then_this_would_need(fn_sig)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `WillChange` to `typeck_tables_of`\n+error: no path from `WillChange` to `typeck`\n   --> $DIR/dep-graph-struct-signature.rs:84:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:31:9\n@@ -115,8 +115,8 @@ LL |         #[rustc_then_this_would_need(fn_sig)]\n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:48:9\n    |\n-LL |         #[rustc_then_this_would_need(typeck_tables_of)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_then_this_would_need(typeck)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:54:9\n@@ -127,8 +127,8 @@ LL |         #[rustc_then_this_would_need(fn_sig)]\n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:55:9\n    |\n-LL |         #[rustc_then_this_would_need(typeck_tables_of)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[rustc_then_this_would_need(typeck)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 22 previous errors\n "}, {"sha": "1b3bf5a3933fe2c2b537173129c03d509a970a90", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits-same-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -29,7 +29,7 @@ mod x {\n mod y {\n     use {Foo, Bar};\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn with_char() {\n         char::method('a');\n     }\n@@ -38,7 +38,7 @@ mod y {\n mod z {\n     use y;\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR no path\n     pub fn z() {\n         y::with_char();\n     }"}, {"sha": "ae3d725e1c051a091220df9413487aa5de8d4a85", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits-same-method.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits-same-method.stderr?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1,14 +1,14 @@\n error: OK\n   --> $DIR/dep-graph-trait-impl-two-traits-same-method.rs:32:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `x::<impl Foo for u32>` to `typeck_tables_of`\n+error: no path from `x::<impl Foo for u32>` to `typeck`\n   --> $DIR/dep-graph-trait-impl-two-traits-same-method.rs:41:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ebfe8ccc3dfaffeb79e2df5434af4f28ce57937a", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -28,7 +28,7 @@ mod x {\n mod y {\n     use {Foo, Bar};\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR no path\n     pub fn call_bar() {\n         char::bar('a');\n     }\n@@ -37,7 +37,7 @@ mod y {\n mod z {\n     use y;\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR no path\n     pub fn z() {\n         y::call_bar();\n     }"}, {"sha": "4823927477fe08e19ef499997d0498d65dc838ed", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1,14 +1,14 @@\n-error: no path from `x::<impl Foo for char>` to `typeck_tables_of`\n+error: no path from `x::<impl Foo for char>` to `typeck`\n   --> $DIR/dep-graph-trait-impl-two-traits.rs:31:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `x::<impl Foo for char>` to `typeck_tables_of`\n+error: no path from `x::<impl Foo for char>` to `typeck`\n   --> $DIR/dep-graph-trait-impl-two-traits.rs:40:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9dd201e2a1fbcc6bee18b5e917ec1363408d11ef", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -24,22 +24,22 @@ mod x {\n mod y {\n     use Foo;\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn with_char() {\n         char::method('a');\n     }\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn take_foo_with_char() {\n         take_foo::<char>('a');\n     }\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn with_u32() {\n         u32::method(22);\n     }\n \n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn take_foo_with_u32() {\n         take_foo::<u32>(22);\n     }\n@@ -52,7 +52,7 @@ mod z {\n \n     // These are expected to yield errors, because changes to `x`\n     // affect the BODY of `y`, but not its signature.\n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR no path\n     pub fn z() {\n         y::with_char();\n         y::with_u32();"}, {"sha": "f8ead80894276400d1de6be0b3c8d8f79a30177c", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl.stderr?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1,32 +1,32 @@\n error: OK\n   --> $DIR/dep-graph-trait-impl.rs:27:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-trait-impl.rs:32:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-trait-impl.rs:37:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-trait-impl.rs:42:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: no path from `x::<impl Foo for char>` to `typeck_tables_of`\n+error: no path from `x::<impl Foo for char>` to `typeck`\n   --> $DIR/dep-graph-trait-impl.rs:55:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "c9151ce79c5f64d806c42c1d08f489a7b331758f", "filename": "src/test/ui/dep-graph/dep-graph-type-alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -41,15 +41,15 @@ struct SomeType;\n #[rustc_then_this_would_need(type_of)] //~ ERROR no path\n impl SomeType {\n     #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n-    #[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     fn method(&self, _: TypeAlias) {}\n }\n \n #[rustc_then_this_would_need(type_of)] //~ ERROR OK\n type TypeAlias2 = TypeAlias;\n \n #[rustc_then_this_would_need(fn_sig)] //~ ERROR OK\n-#[rustc_then_this_would_need(typeck_tables_of)] //~ ERROR OK\n+#[rustc_then_this_would_need(typeck)] //~ ERROR OK\n fn function(_: TypeAlias) {\n \n }"}, {"sha": "9baaf746fc2107b45e1410a1c49163a9a0d80b82", "filename": "src/test/ui/dep-graph/dep-graph-type-alias.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -49,8 +49,8 @@ LL | #[rustc_then_this_would_need(fn_sig)]\n error: OK\n   --> $DIR/dep-graph-type-alias.rs:52:1\n    |\n-LL | #[rustc_then_this_would_need(typeck_tables_of)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[rustc_then_this_would_need(typeck)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: OK\n   --> $DIR/dep-graph-type-alias.rs:35:5\n@@ -67,8 +67,8 @@ LL |     #[rustc_then_this_would_need(fn_sig)]\n error: OK\n   --> $DIR/dep-graph-type-alias.rs:44:5\n    |\n-LL |     #[rustc_then_this_would_need(typeck_tables_of)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 12 previous errors\n "}, {"sha": "e84481f9b5385a2a538cbfc1b3ffb75a0afc702d", "filename": "src/tools/clippy/clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n                     _ => (),\n                 }\n \n-                let (l_ty, r_ty) = (cx.tables().expr_ty(l), cx.tables().expr_ty(r));\n+                let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n                 if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.expr_span = Some(expr.span);\n@@ -96,8 +96,8 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n                 }\n             },\n             hir::ExprKind::Unary(hir::UnOp::UnNeg, arg) => {\n-                let ty = cx.tables().expr_ty(arg);\n-                if constant_simple(cx, cx.tables(), expr).is_none() {\n+                let ty = cx.typeck_results().expr_ty(arg);\n+                if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n                     if ty.is_integral() {\n                         span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                         self.expr_span = Some(expr.span);"}, {"sha": "982d5ecf8d02f03aae9cc3fd52b19be5685fb266", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n             }\n             if_chain! {\n                 if let ExprKind::Unary(_, ref lit) = e.kind;\n-                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables(), lit);\n+                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), lit);\n                 if is_true;\n                 then {\n                     lint_true(true);\n@@ -121,7 +121,7 @@ fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n         if let ExprKind::DropTemps(ref expr) = expr.kind;\n         if let ExprKind::Unary(UnOp::UnNot, ref expr) = expr.kind;\n         // bind the first argument of the `assert!` macro\n-        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables(), expr);\n+        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n         // arm 1 pattern\n         if let PatKind::Lit(ref lit_expr) = arms[0].pat.kind;\n         if let ExprKind::Lit(ref lit) = lit_expr.kind;"}, {"sha": "dab1e96e282f051c75f8184b718f745fb711cace", "filename": "src/tools/clippy/clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -82,8 +82,8 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n             hir::ExprKind::Assign(assignee, e, _) => {\n                 if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n                     let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n-                        let ty = cx.tables().expr_ty(assignee);\n-                        let rty = cx.tables().expr_ty(rhs);\n+                        let ty = cx.typeck_results().expr_ty(assignee);\n+                        let rty = cx.typeck_results().expr_ty(rhs);\n                         macro_rules! ops {\n                             ($op:expr,\n                              $cx:expr,\n@@ -167,7 +167,7 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n                         // a = b commutative_op a\n                         // Limited to primitive type as these ops are know to be commutative\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n-                            && cx.tables().expr_ty(assignee).is_primitive_ty()\n+                            && cx.typeck_results().expr_ty(assignee).is_primitive_ty()\n                         {\n                             match op.node {\n                                 hir::BinOpKind::Add"}, {"sha": "277fe350055ec357a81f6a4a0f0a95f03e74fca6", "filename": "src/tools/clippy/clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -53,7 +53,7 @@ const ATOMIC_TYPES: [&str; 12] = [\n ];\n \n fn type_is_atomic(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.tables().expr_ty(expr).kind {\n+    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.typeck_results().expr_ty(expr).kind {\n         ATOMIC_TYPES\n             .iter()\n             .any(|ty| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", ty]))"}, {"sha": "27a7fa8862237196e2cd6c08efeeb95a90aa7b4c", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -461,15 +461,15 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMet\n \n fn is_relevant_item(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Fn(_, _, eid) = item.kind {\n-        is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n+        is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext<'_>, item: &ImplItem<'_>) -> bool {\n     match item.kind {\n-        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value),\n+        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n@@ -478,31 +478,34 @@ fn is_relevant_trait(cx: &LateContext<'_>, item: &TraitItem<'_>) -> bool {\n     match item.kind {\n         TraitItemKind::Fn(_, TraitFn::Required(_)) => true,\n         TraitItemKind::Fn(_, TraitFn::Provided(eid)) => {\n-            is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n+            is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n         },\n         _ => false,\n     }\n }\n \n-fn is_relevant_block(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n+fn is_relevant_block(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>, block: &Block<'_>) -> bool {\n     block.stmts.first().map_or(\n-        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e)),\n+        block\n+            .expr\n+            .as_ref()\n+            .map_or(false, |e| is_relevant_expr(cx, typeck_results, e)),\n         |stmt| match &stmt.kind {\n             StmtKind::Local(_) => true,\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, tables, expr),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, typeck_results, expr),\n             _ => false,\n         },\n     )\n }\n \n-fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n+fn is_relevant_expr(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n-        ExprKind::Block(block, _) => is_relevant_block(cx, tables, block),\n-        ExprKind::Ret(Some(e)) => is_relevant_expr(cx, tables, e),\n+        ExprKind::Block(block, _) => is_relevant_block(cx, typeck_results, block),\n+        ExprKind::Ret(Some(e)) => is_relevant_expr(cx, typeck_results, e),\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n         ExprKind::Call(path_expr, _) => {\n             if let ExprKind::Path(qpath) = &path_expr.kind {\n-                tables\n+                typeck_results\n                     .qpath_res(qpath, path_expr.hir_id)\n                     .opt_def_id()\n                     .map_or(true, |fun_id| !match_def_path(cx, fun_id, &paths::BEGIN_PANIC))"}, {"sha": "b10b1e0a65ab94e0b3ea232fdad304ba689ab776", "filename": "src/tools/clippy/clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -59,8 +59,8 @@ impl LateLintPass<'_> for AwaitHoldingLock {\n                 hir_id: body.value.hir_id,\n             };\n             let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n-            let tables = cx.tcx.typeck_tables_of(def_id);\n-            check_interior_types(cx, &tables.generator_interior_types, body.value.span);\n+            let typeck_results = cx.tcx.typeck(def_id);\n+            check_interior_types(cx, &typeck_results.generator_interior_types, body.value.span);\n         }\n     }\n }"}, {"sha": "81a34021e8a018aa78faf6cf5b57deb9ba40bf23", "filename": "src/tools/clippy/clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -319,7 +319,7 @@ fn check_ineffective_gt(cx: &LateContext<'_>, span: Span, m: u128, c: u128, op:\n }\n \n fn fetch_int_literal(cx: &LateContext<'_>, lit: &Expr<'_>) -> Option<u128> {\n-    match constant(cx, cx.tables(), lit)?.0 {\n+    match constant(cx, cx.typeck_results(), lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,\n     }"}, {"sha": "18529f2113e77bc16a36b798f3a71ac1539c2917", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -111,8 +111,12 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             match &e.kind {\n                 ExprKind::Unary(UnOp::UnNot, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n                 ExprKind::Binary(binop, lhs, rhs) => match &binop.node {\n-                    BinOpKind::Or => return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?)),\n-                    BinOpKind::And => return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?)),\n+                    BinOpKind::Or => {\n+                        return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?));\n+                    },\n+                    BinOpKind::And => {\n+                        return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?));\n+                    },\n                     _ => (),\n                 },\n                 ExprKind::Lit(lit) => match lit.node {\n@@ -248,7 +252,7 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n             })\n         },\n         ExprKind::MethodCall(path, _, args, _) if args.len() == 1 => {\n-            let type_of_receiver = cx.tables().expr_ty(&args[0]);\n+            let type_of_receiver = cx.typeck_results().expr_ty(&args[0]);\n             if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type))\n                 && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type))\n             {\n@@ -450,7 +454,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n                 self.bool_expr(e)\n             },\n             ExprKind::Unary(UnOp::UnNot, inner) => {\n-                if self.cx.tables().node_types()[inner.hir_id].is_bool() {\n+                if self.cx.typeck_results().node_types()[inner.hir_id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n                     walk_expr(self, e);\n@@ -465,7 +469,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n }\n \n fn implements_ord<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n "}, {"sha": "dde799fcae4cc4165b82ca6f153c97d4286f5cbb", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                     if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n                     if op.node == BinOpKind::Eq;\n                     if match_type(cx,\n-                               walk_ptrs_ty(cx.tables().expr_ty(&filter_args[0])),\n+                               walk_ptrs_ty(cx.typeck_results().expr_ty(&filter_args[0])),\n                                &paths::SLICE_ITER);\n                     then {\n                         let needle = match get_path_name(l) {\n@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                                 _ => { return; }\n                             }\n                         };\n-                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables().expr_ty(needle)).kind {\n+                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.typeck_results().expr_ty(needle)).kind {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) ="}, {"sha": "14ef8c319eff1c63b322e21c935fd0c94af8381c", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -60,7 +60,7 @@ impl CognitiveComplexity {\n         let mut helper = CCHelper { cc: 1, returns: 0 };\n         helper.visit_expr(expr);\n         let CCHelper { cc, returns } = helper;\n-        let ret_ty = cx.tables().node_type(expr.hir_id);\n+        let ret_ty = cx.typeck_results().node_type(expr.hir_id);\n         let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym!(result_type)) {\n             returns\n         } else {"}, {"sha": "99f161a0510f4286c7f682016562dd7e99439a6a", "filename": "src/tools/clippy/clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -99,7 +99,7 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n                 }\n \n                 // Check that the type being compared implements `core::cmp::Ord`\n-                let ty = cx.tables().expr_ty(lhs1);\n+                let ty = cx.typeck_results().expr_ty(lhs1);\n                 let is_ord = get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]));\n \n                 if !is_ord {"}, {"sha": "49ff86a205d96cb20bb7a5d4a4a510b2e6f5d7f4", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -174,12 +174,12 @@ pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n \n pub fn constant<'tcx>(\n     lcx: &LateContext<'tcx>,\n-    tables: &ty::TypeckTables<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,\n ) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n         lcx,\n-        tables,\n+        typeck_results,\n         param_env: lcx.param_env,\n         needed_resolution: false,\n         substs: lcx.tcx.intern_substs(&[]),\n@@ -189,20 +189,20 @@ pub fn constant<'tcx>(\n \n pub fn constant_simple<'tcx>(\n     lcx: &LateContext<'tcx>,\n-    tables: &ty::TypeckTables<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,\n ) -> Option<Constant> {\n-    constant(lcx, tables, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n-/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckTables`.\n+/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n pub fn constant_context<'a, 'tcx>(\n     lcx: &'a LateContext<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n ) -> ConstEvalLateContext<'a, 'tcx> {\n     ConstEvalLateContext {\n         lcx,\n-        tables,\n+        typeck_results,\n         param_env: lcx.param_env,\n         needed_resolution: false,\n         substs: lcx.tcx.intern_substs(&[]),\n@@ -211,7 +211,7 @@ pub fn constant_context<'a, 'tcx>(\n \n pub struct ConstEvalLateContext<'a, 'tcx> {\n     lcx: &'a LateContext<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     needed_resolution: bool,\n     substs: SubstsRef<'tcx>,\n@@ -224,21 +224,21 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n             return self.ifthenelse(cond, then, otherwise);\n         }\n         match e.kind {\n-            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.tables.expr_ty(e)),\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n             ExprKind::Block(ref block, _) => self.block(block),\n-            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty_opt(e))),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n             ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(ref value, _) => {\n-                let n = match self.tables.expr_ty(e).kind {\n+                let n = match self.typeck_results.expr_ty(e).kind {\n                     ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n             },\n             ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n-                UnOp::UnNot => self.constant_not(&o, self.tables.expr_ty(e)),\n-                UnOp::UnNeg => self.constant_negate(&o, self.tables.expr_ty(e)),\n+                UnOp::UnNot => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::UnNeg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n                 UnOp::UnDeref => Some(o),\n             }),\n             ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n@@ -247,7 +247,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 if_chain! {\n                     if args.is_empty();\n                     if let ExprKind::Path(qpath) = &callee.kind;\n-                    let res = self.tables.qpath_res(qpath, callee.hir_id);\n+                    let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n                     if let Some(def_id) = res.opt_def_id();\n                     let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n                     let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n@@ -319,10 +319,10 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n \n     /// Lookup a possibly constant expression from a `ExprKind::Path`.\n     fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n-        let res = self.tables.qpath_res(qpath, id);\n+        let res = self.typeck_results.qpath_res(qpath, id);\n         match res {\n             Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n-                let substs = self.tables.node_substs(id);\n+                let substs = self.typeck_results.node_substs(id);\n                 let substs = if self.substs.is_empty() {\n                     substs\n                 } else {\n@@ -332,7 +332,13 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 let result = self\n                     .lcx\n                     .tcx\n-                    .const_eval_resolve(self.param_env, ty::WithOptConstParam::unknown(def_id), substs, None, None)\n+                    .const_eval_resolve(\n+                        self.param_env,\n+                        ty::WithOptConstParam::unknown(def_id),\n+                        substs,\n+                        None,\n+                        None,\n+                    )\n                     .ok()\n                     .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n                 let result = miri_to_const(&result);\n@@ -396,7 +402,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         let l = self.expr(left)?;\n         let r = self.expr(right);\n         match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => match self.tables.expr_ty_opt(left)?.kind {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match self.typeck_results.expr_ty_opt(left)?.kind {\n                 ty::Int(ity) => {\n                     let l = sext(self.lcx.tcx, l, ity);\n                     let r = sext(self.lcx.tcx, r, ity);\n@@ -488,23 +494,25 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n     use rustc_middle::mir::interpret::{ConstValue, Scalar};\n     match result.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => match result.ty.kind {\n-            ty::Bool => Some(Constant::Bool(d == 1)),\n-            ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n-            ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n-                d.try_into().expect(\"invalid f32 bit representation\"),\n-            ))),\n-            ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n-                d.try_into().expect(\"invalid f64 bit representation\"),\n-            ))),\n-            ty::RawPtr(type_and_mut) => {\n-                if let ty::Uint(_) = type_and_mut.ty.kind {\n-                    return Some(Constant::RawPtr(d));\n-                }\n-                None\n-            },\n-            // FIXME: implement other conversions.\n-            _ => None,\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => {\n+            match result.ty.kind {\n+                ty::Bool => Some(Constant::Bool(d == 1)),\n+                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n+                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n+                    d.try_into().expect(\"invalid f32 bit representation\"),\n+                ))),\n+                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n+                    d.try_into().expect(\"invalid f64 bit representation\"),\n+                ))),\n+                ty::RawPtr(type_and_mut) => {\n+                    if let ty::Uint(_) = type_and_mut.ty.kind {\n+                        return Some(Constant::RawPtr(d));\n+                    }\n+                    None\n+                },\n+                // FIXME: implement other conversions.\n+                _ => None,\n+            }\n         },\n         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind {\n             ty::Ref(_, tam, _) => match tam.kind {"}, {"sha": "1f8bff8d71e0f33d77c8e1c3b06237196d98baf6", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -320,7 +320,7 @@ fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty\n             },\n             PatKind::Binding(.., ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.name) {\n-                    v.insert(cx.tables().pat_ty(pat));\n+                    v.insert(cx.typeck_results().pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);"}, {"sha": "ea2447681293de4d1e438e15330fdc7d239f8a7e", "filename": "src/tools/clippy/clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n \n                         // TODO: Work out a way to put \"whatever the imported way of referencing\n                         // this type in this file\" rather than a fully-qualified type.\n-                        let expr_ty = cx.tables().expr_ty(expr);\n+                        let expr_ty = cx.typeck_results().expr_ty(expr);\n                         if let ty::Adt(..) = expr_ty.kind {\n                             let replacement = format!(\"{}::default()\", expr_ty);\n                             span_lint_and_sugg("}, {"sha": "102cf597d22e368ee04d86b01ffd5a57de24cbd0", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -74,7 +74,7 @@ fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var\n     match method_name {\n         \"deref\" => {\n             let impls_deref_trait = cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n-                implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n+                implements_trait(cx, cx.typeck_results().expr_ty(&call_expr), id, &[])\n             });\n             if impls_deref_trait {\n                 span_lint_and_sugg(\n@@ -90,7 +90,7 @@ fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var\n         },\n         \"deref_mut\" => {\n             let impls_deref_mut_trait = cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n-                implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n+                implements_trait(cx, cx.typeck_results().expr_ty(&call_expr), id, &[])\n             });\n             if impls_deref_mut_trait {\n                 span_lint_and_sugg("}, {"sha": "57ff569f14b0f7bb18d54817b5a38742172254f2", "filename": "src/tools/clippy/clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n                 let lint;\n                 let msg;\n                 let arg = &args[0];\n-                let arg_ty = cx.tables().expr_ty(arg);\n+                let arg_ty = cx.typeck_results().expr_ty(arg);\n \n                 if let ty::Ref(..) = arg_ty.kind {\n                     if match_def_path(cx, def_id, &paths::DROP) {"}, {"sha": "1dfb2eaa579728d98bf628f9e3b467f9ca6725c5", "filename": "src/tools/clippy/clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -43,8 +43,8 @@ impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n             if let ExprKind::MethodCall(ref method_path, _ , ref args, _) = left.kind;\n-            if match_type(cx, walk_ptrs_ty(cx.tables().expr_ty(&args[0])), &paths::DURATION);\n-            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables(), right);\n+            if match_type(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0])), &paths::DURATION);\n+            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n             then {\n                 let suggested_fn = match (method_path.ident.as_str().as_ref(), divisor) {\n                     (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\","}, {"sha": "d616502a82a0c07adbbbda1150fb47580ca3558e", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -106,7 +106,7 @@ fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref key) = params[1].kind;\n         then {\n             let map = &params[0];\n-            let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(map));\n+            let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(map));\n \n             return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n                 Some((\"BTreeMap\", map, key))"}, {"sha": "140cd21c34e67916b9922565cbaf11ec46a9adef", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -103,8 +103,8 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar\n                     (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n-                        let lty = cx.tables().expr_ty(l);\n-                        let rty = cx.tables().expr_ty(r);\n+                        let lty = cx.typeck_results().expr_ty(l);\n+                        let rty = cx.typeck_results().expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n                         let rcpy = is_copy(cx, rty);\n                         // either operator autorefs or both args are copyable\n@@ -126,7 +126,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                             )\n                         } else if lcpy\n                             && !rcpy\n-                            && implements_trait(cx, lty, trait_id, &[cx.tables().expr_ty(right).into()])\n+                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -145,7 +145,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                             )\n                         } else if !lcpy\n                             && rcpy\n-                            && implements_trait(cx, cx.tables().expr_ty(left), trait_id, &[rty.into()])\n+                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -166,10 +166,10 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     },\n                     // &foo == bar\n                     (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), _) => {\n-                        let lty = cx.tables().expr_ty(l);\n+                        let lty = cx.typeck_results().expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy)\n-                            && implements_trait(cx, lty, trait_id, &[cx.tables().expr_ty(right).into()])\n+                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -190,10 +190,10 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     },\n                     // foo == &bar\n                     (_, &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n-                        let rty = cx.tables().expr_ty(r);\n+                        let rty = cx.typeck_results().expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy)\n-                            && implements_trait(cx, cx.tables().expr_ty(left), trait_id, &[rty.into()])\n+                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n                         {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();"}, {"sha": "dbd1ff514f0e13292b6d7a8a0aa2efc7b2e220d6", "filename": "src/tools/clippy/clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for ErasingOp {\n }\n \n fn check(cx: &LateContext<'_>, e: &Expr<'_>, span: Span) {\n-    if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables(), e) {\n+    if let Some(Constant::Int(0)) = constant_simple(cx, cx.typeck_results(), e) {\n         span_lint(\n             cx,\n             ERASING_OP,"}, {"sha": "82549c12d0a207c31b839bcc726dba37d9e61e07", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n \n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n         cx.tcx.infer_ctxt().enter(|infcx| {\n-            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.tables()).consume_body(body);\n+            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.typeck_results()).consume_body(body);\n         });\n \n         for node in v.set {"}, {"sha": "87254c1dbc490a9fac3706194fa35d9759f4d4cc", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -97,7 +97,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             // Are the expression or the arguments type-adjusted? Then we need the closure\n             if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n \n-            let fn_ty = cx.tables().expr_ty(caller);\n+            let fn_ty = cx.typeck_results().expr_ty(caller);\n \n             if matches!(fn_ty.kind, ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n \n@@ -128,7 +128,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             // Are the expression or the arguments type-adjusted? Then we need the closure\n             if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n \n-            let method_def_id = cx.tables().type_dependent_def_id(ex.hir_id).unwrap();\n+            let method_def_id = cx.typeck_results().type_dependent_def_id(ex.hir_id).unwrap();\n             if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n \n             if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n@@ -153,7 +153,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n /// Tries to determine the type for universal function call to be used instead of the closure\n fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n     let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n-    let actual_type_of_self = &cx.tables().node_type(self_arg.hir_id);\n+    let actual_type_of_self = &cx.typeck_results().node_type(self_arg.hir_id);\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n         if match_borrow_depth(expected_type_of_self, &actual_type_of_self)"}, {"sha": "c00638ecc0c1d26619ef188f3b66da2f1e6a5bc4", "filename": "src/tools/clippy/clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n         match e.kind {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n             ExprKind::Call(ref func, _) => {\n-                let typ = self.cx.tables().expr_ty(func);\n+                let typ = self.cx.typeck_results().expr_ty(func);\n                 match typ.kind {\n                     ty::FnDef(..) | ty::FnPtr(_) => {\n                         let sig = typ.fn_sig(self.cx.tcx);\n@@ -149,7 +149,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 }\n             },\n             ExprKind::MethodCall(..) => {\n-                let borrowed_table = self.cx.tables();\n+                let borrowed_table = self.cx.typeck_results();\n                 if borrowed_table.expr_ty(e).is_never() {\n                     self.report_diverging_sub_expr(e);\n                 }"}, {"sha": "000762334f61eb022944aa0ca69fb84e3a21bf41", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -73,7 +73,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n     struct FindPanicUnwrap<'a, 'tcx> {\n         lcx: &'a LateContext<'tcx>,\n-        tables: &'tcx ty::TypeckTables<'tcx>,\n+        typeck_results: &'tcx ty::TypeckResults<'tcx>,\n         result: Vec<Span>,\n     }\n \n@@ -96,7 +96,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n+                let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n                 if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n                     || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n                 {\n@@ -124,7 +124,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n                 let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.id.hir_id);\n                 let mut fpu = FindPanicUnwrap {\n                     lcx: cx,\n-                    tables: cx.tcx.typeck_tables_of(impl_item_def_id),\n+                    typeck_results: cx.tcx.typeck(impl_item_def_id),\n                     result: Vec::new(),\n                 };\n                 fpu.visit_expr(&body.value);"}, {"sha": "358b9f6dcd0a5eb3cd66c092c3d238c1ee1376a9", "filename": "src/tools/clippy/clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -61,7 +61,7 @@ declare_lint_pass!(FloatLiteral => [EXCESSIVE_PRECISION, LOSSY_FLOAT_LITERAL]);\n impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            let ty = cx.tables().expr_ty(expr);\n+            let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Float(fty) = ty.kind;\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, lit_float_ty) = lit.node;"}, {"sha": "93f6ec92ec71328512aeb92b4b6b5976139fc45b", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -112,7 +112,7 @@ declare_lint_pass!(FloatingPointArithmetic => [\n // Returns the specialized log method for a given base if base is constant\n // and is one of 2, 10 and e\n fn get_specialized_log_method(cx: &LateContext<'_>, base: &Expr<'_>) -> Option<&'static str> {\n-    if let Some((value, _)) = constant(cx, cx.tables(), base) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), base) {\n         if F32(2.0) == value || F64(2.0) == value {\n             return Some(\"log2\");\n         } else if F32(10.0) == value || F64(10.0) == value {\n@@ -136,7 +136,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     if_chain! {\n         // if the expression is a float literal and it is unsuffixed then\n         // add a suffix so the suggestion is valid and unambiguous\n-        if let ty::Float(float_ty) = cx.tables().expr_ty(expr).kind;\n+        if let ty::Float(float_ty) = cx.typeck_results().expr_ty(expr).kind;\n         if let ExprKind::Lit(lit) = &expr.kind;\n         if let ast::LitKind::Float(sym, ast::LitFloatType::Unsuffixed) = lit.node;\n         then {\n@@ -188,7 +188,10 @@ fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n         rhs,\n     ) = &args[0].kind\n     {\n-        let recv = match (constant(cx, cx.tables(), lhs), constant(cx, cx.tables(), rhs)) {\n+        let recv = match (\n+            constant(cx, cx.typeck_results(), lhs),\n+            constant(cx, cx.typeck_results(), rhs),\n+        ) {\n             (Some((value, _)), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n             (_, Some((value, _))) if F32(1.0) == value || F64(1.0) == value => lhs,\n             _ => return,\n@@ -233,7 +236,7 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n \n fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n-    if let Some((value, _)) = constant(cx, cx.tables(), &args[0]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n         let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n             \"exp\"\n         } else if F32(2.0) == value || F64(2.0) == value {\n@@ -254,7 +257,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n \n     // Check argument\n-    if let Some((value, _)) = constant(cx, cx.tables(), &args[1]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n         let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n             (\n                 SUBOPTIMAL_FLOPS,\n@@ -294,7 +297,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n }\n \n fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some((value, _)) = constant(cx, cx.tables(), &args[1]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n         if value == Int(2) {\n             if let Some(parent) = get_parent_expr(cx, expr) {\n                 if let Some(grandparent) = get_parent_expr(cx, parent) {\n@@ -382,8 +385,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n                 _\n             ) = add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n-            if let Some((lvalue, _)) = constant(cx, cx.tables(), &largs[1]);\n-            if let Some((rvalue, _)) = constant(cx, cx.tables(), &rargs[1]);\n+            if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), &largs[1]);\n+            if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), &rargs[1]);\n             if Int(2) == lvalue && Int(2) == rvalue;\n             then {\n                 return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &largs[0], \"..\"), Sugg::hir(cx, &rargs[0], \"..\")));\n@@ -413,11 +416,11 @@ fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) = expr.kind;\n-        if cx.tables().expr_ty(lhs).is_floating_point();\n-        if let Some((value, _)) = constant(cx, cx.tables(), rhs);\n+        if cx.typeck_results().expr_ty(lhs).is_floating_point();\n+        if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n         if let ExprKind::MethodCall(ref path, _, ref method_args, _) = lhs.kind;\n-        if cx.tables().expr_ty(&method_args[0]).is_floating_point();\n+        if cx.typeck_results().expr_ty(&method_args[0]).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n             span_lint_and_sugg(\n@@ -439,8 +442,8 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n fn is_float_mul_expr<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lhs, ref rhs) = &expr.kind;\n-        if cx.tables().expr_ty(lhs).is_floating_point();\n-        if cx.tables().expr_ty(rhs).is_floating_point();\n+        if cx.typeck_results().expr_ty(lhs).is_floating_point();\n+        if cx.typeck_results().expr_ty(rhs).is_floating_point();\n         then {\n             return Some((lhs, rhs));\n         }\n@@ -527,7 +530,7 @@ fn are_exprs_equal(cx: &LateContext<'_>, expr1: &Expr<'_>, expr2: &Expr<'_>) ->\n \n /// Returns true iff expr is some zero literal\n fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    match constant_simple(cx, cx.tables(), expr) {\n+    match constant_simple(cx, cx.typeck_results(), expr) {\n         Some(Constant::Int(i)) => i == 0,\n         Some(Constant::F32(f)) => f == 0.0,\n         Some(Constant::F64(f)) => f == 0.0,\n@@ -662,8 +665,8 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             mul_lhs,\n             mul_rhs,\n         ) = &div_lhs.kind;\n-        if let Some((rvalue, _)) = constant(cx, cx.tables(), div_rhs);\n-        if let Some((lvalue, _)) = constant(cx, cx.tables(), mul_rhs);\n+        if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), div_rhs);\n+        if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), mul_rhs);\n         then {\n             // TODO: also check for constant values near PI/180 or 180/PI\n             if (F32(f32_consts::PI) == rvalue || F64(f64_consts::PI) == rvalue) &&\n@@ -699,7 +702,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n-            let recv_ty = cx.tables().expr_ty(&args[0]);\n+            let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n \n             if recv_ty.is_floating_point() {\n                 match &*path.ident.name.as_str() {"}, {"sha": "572c839502f4f20acc62d6a6182e918706421622", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -90,7 +90,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n         if pats.len() == 1;\n         then {\n-            let ty = walk_ptrs_ty(cx.tables().pat_ty(&pats[0]));\n+            let ty = walk_ptrs_ty(cx.typeck_results().pat_ty(&pats[0]));\n             if ty.kind != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n                 return None;\n             }"}, {"sha": "3ee0b3f74b8c5a3bf96e3877fa6fbe91d757f9b8", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -392,11 +392,11 @@ impl<'tcx> Functions {\n                 .collect::<FxHashSet<_>>();\n \n             if !raw_ptrs.is_empty() {\n-                let tables = cx.tcx.body_tables(body.id());\n+                let typeck_results = cx.tcx.typeck_body(body.id());\n                 let mut v = DerefVisitor {\n                     cx,\n                     ptrs: raw_ptrs,\n-                    tables,\n+                    typeck_results,\n                 };\n \n                 intravisit::walk_expr(&mut v, expr);\n@@ -494,13 +494,8 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<\n         return false; // ignore `_` patterns\n     }\n     let def_id = pat.hir_id.owner.to_def_id();\n-    if cx.tcx.has_typeck_tables(def_id) {\n-        is_mutable_ty(\n-            cx,\n-            &cx.tcx.typeck_tables_of(def_id.expect_local()).pat_ty(pat),\n-            pat.span,\n-            tys,\n-        )\n+    if cx.tcx.has_typeck_results(def_id) {\n+        is_mutable_ty(cx, &cx.tcx.typeck(def_id.expect_local()).pat_ty(pat), pat.span, tys)\n     } else {\n         false\n     }\n@@ -539,7 +534,7 @@ fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n struct DerefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     ptrs: FxHashSet<hir::HirId>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n }\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n@@ -548,7 +543,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         match expr.kind {\n             hir::ExprKind::Call(ref f, args) => {\n-                let ty = self.tables.expr_ty(f);\n+                let ty = self.typeck_results.expr_ty(f);\n \n                 if type_is_unsafe_function(self.cx, ty) {\n                     for arg in args {\n@@ -557,7 +552,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                 }\n             },\n             hir::ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.tables.type_dependent_def_id(expr.hir_id).unwrap();\n+                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n                 if type_is_unsafe_function(self.cx, base_type) {\n@@ -614,10 +609,10 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                 let mut tys = FxHashSet::default();\n                 for arg in args {\n                     let def_id = arg.hir_id.owner.to_def_id();\n-                    if self.cx.tcx.has_typeck_tables(def_id)\n+                    if self.cx.tcx.has_typeck_results(def_id)\n                         && is_mutable_ty(\n                             self.cx,\n-                            self.cx.tcx.typeck_tables_of(def_id.expect_local()).expr_ty(arg),\n+                            self.cx.tcx.typeck(def_id.expect_local()).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )"}, {"sha": "48ebcf5ebcd9c03db387dfa8a249d4ebd3cc189f", "filename": "src/tools/clippy/clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n \n             // Argument 0 (the struct we're calling the method on) is a vector\n             if let Some(struct_calling_on) = args.get(0);\n-            let struct_ty = cx.tables().expr_ty(struct_calling_on);\n+            let struct_ty = cx.typeck_results().expr_ty(struct_calling_on);\n             if is_type_diagnostic_item(cx, struct_ty, sym!(vec_type));\n \n             // Argument to \"get\" is a subtraction"}, {"sha": "4c62637858cde2b64cd942f9a45741772c9ee7fb", "filename": "src/tools/clippy/clippy_lints/src/identity_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -62,8 +62,8 @@ fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_\n     // `1 << 0` is a common pattern in bit manipulation code\n     if_chain! {\n         if let BinOpKind::Shl = cmp.node;\n-        if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables(), right);\n-        if let Some(Constant::Int(1)) = constant_simple(cx, cx.tables(), left);\n+        if let Some(Constant::Int(0)) = constant_simple(cx, cx.typeck_results(), right);\n+        if let Some(Constant::Int(1)) = constant_simple(cx, cx.typeck_results(), left);\n         then {\n             return true;\n         }\n@@ -74,8 +74,8 @@ fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_\n \n #[allow(clippy::cast_possible_wrap)]\n fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n-    if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables(), e) {\n-        let check = match cx.tables().expr_ty(e).kind {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e) {\n+        let check = match cx.typeck_results().expr_ty(e).kind {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n             ty::Uint(uty) => clip(cx.tcx, !0, uty),\n             _ => return,"}, {"sha": "2e55094d90c6f33f5ca4e24c68dea3239fe1ac31", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -146,7 +146,7 @@ fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Opt\n     if_chain! {\n         if let ExprKind::MethodCall(path, _span, args, _) = &expr.kind;\n         if path.ident.to_string() == \"lock\";\n-        let ty = cx.tables().expr_ty(&args[0]);\n+        let ty = cx.typeck_results().expr_ty(&args[0]);\n         if is_type_diagnostic_item(cx, ty, sym!(mutex_type));\n         then {\n             Some(&args[0])"}, {"sha": "5b22df5fe491e70e3afcadb2933e176a6492ff47", "filename": "src/tools/clippy/clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n             if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            if is_type_diagnostic_item(cx, cx.tables().expr_ty(&result_types[0]), sym!(result_type));\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym!(result_type));\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {"}, {"sha": "5f931a0addedf6b3781460b545d15a7ec46dc629", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -81,7 +81,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                 };\n \n                 // Check if the variable in the condition statement is an integer\n-                if !cx.tables().expr_ty(cond_var).is_integral() {\n+                if !cx.typeck_results().expr_ty(cond_var).is_integral() {\n                     return;\n                 }\n \n@@ -93,7 +93,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                     ExprKind::Lit(ref cond_lit) => {\n                         // Check if the constant is zero\n                         if let LitKind::Int(0, _) = cond_lit.node {\n-                            if cx.tables().expr_ty(cond_left).is_signed() {\n+                            if cx.typeck_results().expr_ty(cond_left).is_signed() {\n                             } else {\n                                 print_lint_and_sugg(cx, &var_name, expr);\n                             };"}, {"sha": "a1f58e54ae38e97ec6d8c5e17b64e7227b61fd1e", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -88,7 +88,7 @@ declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]\n impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(ref array, ref index) = &expr.kind {\n-            let ty = cx.tables().expr_ty(array);\n+            let ty = cx.typeck_results().expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind {\n@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n                 // Catchall non-range index, i.e., [n] or [n << m]\n                 if let ty::Array(..) = ty.kind {\n                     // Index is a constant uint.\n-                    if let Some(..) = constant(cx, cx.tables(), index) {\n+                    if let Some(..) = constant(cx, cx.typeck_results(), index) {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays.\n                         return;\n                     }\n@@ -169,14 +169,18 @@ fn to_const_range<'tcx>(\n     range: higher::Range<'_>,\n     array_size: u128,\n ) -> (Option<u128>, Option<u128>) {\n-    let s = range.start.map(|expr| constant(cx, cx.tables(), expr).map(|(c, _)| c));\n+    let s = range\n+        .start\n+        .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));\n     let start = match s {\n         Some(Some(Constant::Int(x))) => Some(x),\n         Some(_) => None,\n         None => Some(0),\n     };\n \n-    let e = range.end.map(|expr| constant(cx, cx.tables(), expr).map(|(c, _)| c));\n+    let e = range\n+        .end\n+        .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));\n     let end = match e {\n         Some(Some(Constant::Int(x))) => {\n             if range.limits == RangeLimits::Closed {"}, {"sha": "e511d3ea330466b9b85dba31dcc59504904d6857", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -231,13 +231,13 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n             }\n             if method.ident.name == sym!(last) && args.len() == 1 {\n                 let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR).map_or(false, |id| {\n-                    !implements_trait(cx, cx.tables().expr_ty(&args[0]), id, &[])\n+                    !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n                 });\n                 if not_double_ended {\n                     return is_infinite(cx, &args[0]);\n                 }\n             } else if method.ident.name == sym!(collect) {\n-                let ty = cx.tables().expr_ty(expr);\n+                let ty = cx.typeck_results().expr_ty(expr);\n                 if INFINITE_COLLECTORS.iter().any(|path| match_type(cx, ty, path)) {\n                     return is_infinite(cx, &args[0]);\n                 }"}, {"sha": "31181c10d23dbed70a1927e5bba2d3b0ada51069", "filename": "src/tools/clippy/clippy_lints/src/integer_division.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -50,7 +50,7 @@ fn is_integer_division<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>)\n         if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n         if let hir::BinOpKind::Div = &binop.node;\n         then {\n-            let (left_ty, right_ty) = (cx.tables().expr_ty(left), cx.tables().expr_ty(right));\n+            let (left_ty, right_ty) = (cx.typeck_results().expr_ty(left), cx.typeck_results().expr_ty(right));\n             return left_ty.is_integral() && right_ty.is_integral();\n         }\n     }"}, {"sha": "a7c715879232b980b078c1e00399e0cb2ec8017b", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n-            if let ty::Array(element_type, cst) = cx.tables().expr_ty(expr).kind;\n+            if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind;\n             if let ConstKind::Value(val) = cst.val;\n             if let ConstValue::Scalar(element_count) = val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);"}, {"sha": "00d0b8b4e5b7f3c98303e03bd1819f025da3677c", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -300,7 +300,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         return false;\n     }\n \n-    let ty = &walk_ptrs_ty(cx.tables().expr_ty(expr));\n+    let ty = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr));\n     match ty.kind {\n         ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n             cx.tcx"}, {"sha": "8243b0a29bc68b3642828e3c7295b45f8627c614", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n-                    let has_interior_mutability = !cx.tables().node_type(canonical_id).is_freeze(\n+                    let has_interior_mutability = !cx.typeck_results().node_type(canonical_id).is_freeze(\n                         cx.tcx.at(span),\n                         cx.param_env,\n                     );"}, {"sha": "ae2f6131b5b8fb0bdf653081ca3c0f905c9c9886", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n             if let PatKind::Wild = local.pat.kind;\n             if let Some(ref init) = local.init;\n             then {\n-                let init_ty = cx.tables().expr_ty(init);\n+                let init_ty = cx.typeck_results().expr_ty(init);\n                 let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n                     GenericArgKind::Type(inner_ty) => {\n                         SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n@@ -94,7 +94,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"consider using an underscore-prefixed named \\\n                             binding or dropping explicitly with `std::mem::drop`\"\n                     )\n-                } else if is_must_use_ty(cx, cx.tables().expr_ty(init)) {\n+                } else if is_must_use_ty(cx, cx.typeck_results().expr_ty(init)) {\n                     span_lint_and_help(\n                         cx,\n                         LET_UNDERSCORE_MUST_USE,"}, {"sha": "7e3876ff49b462fcc71810ad11684343cf9a188f", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -535,7 +535,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n                 if_chain! {\n                     if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n                     if let Some(iter_def_id) = get_trait_def_id(cx, &paths::ITERATOR);\n-                    if implements_trait(cx, cx.tables().expr_ty(iter_expr), iter_def_id, &[]);\n+                    if implements_trait(cx, cx.typeck_results().expr_ty(iter_expr), iter_def_id, &[]);\n                     then {\n                         return;\n                     }\n@@ -981,8 +981,8 @@ fn detect_manual_memcpy<'tcx>(\n                         if_chain! {\n                             if let ExprKind::Index(seqexpr_left, idx_left) = lhs.kind;\n                             if let ExprKind::Index(seqexpr_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.tables().expr_ty(seqexpr_left))\n-                                && is_slice_like(cx, cx.tables().expr_ty(seqexpr_right));\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_left))\n+                                && is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_right));\n                             if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n                             if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n \n@@ -1250,8 +1250,8 @@ fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr:\n                     lint_iter_method(cx, args, arg, method_name);\n                 }\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                let receiver_ty = cx.tables().expr_ty(&args[0]);\n-                let receiver_ty_adjusted = cx.tables().expr_ty_adjusted(&args[0]);\n+                let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n                 if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n                     let mut applicability = Applicability::MachineApplicable;\n                     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n@@ -1296,7 +1296,7 @@ fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr:\n \n /// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n-    let ty = cx.tables().expr_ty(arg);\n+    let ty = cx.typeck_results().expr_ty(arg);\n     if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n         span_lint_and_help(\n             cx,\n@@ -1400,8 +1400,9 @@ fn check_for_loop_explicit_counter<'tcx>(\n /// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n /// actual `Iterator` that the loop uses.\n fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n-    let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR)\n-        .map_or(false, |id| implements_trait(cx, cx.tables().expr_ty(arg), id, &[]));\n+    let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR).map_or(false, |id| {\n+        implements_trait(cx, cx.typeck_results().expr_ty(arg), id, &[])\n+    });\n     if impls_iterator {\n         format!(\n             \"{}\",\n@@ -1412,7 +1413,7 @@ fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut\n         // (&mut x).into_iter() ==> x.iter_mut()\n         match &arg.kind {\n             ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n-                if has_iter_method(cx, cx.tables().expr_ty(&arg_inner)).is_some() =>\n+                if has_iter_method(cx, cx.typeck_results().expr_ty(&arg_inner)).is_some() =>\n             {\n                 let meth_name = match mutability {\n                     Mutability::Mut => \"iter_mut\",\n@@ -1445,7 +1446,7 @@ fn check_for_loop_over_map_kv<'tcx>(\n     if let PatKind::Tuple(ref pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match cx.tables().expr_ty(arg).kind {\n+            let (new_pat_span, kind, ty, mutbl) = match cx.typeck_results().expr_ty(arg).kind {\n                 ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n@@ -1590,7 +1591,14 @@ fn check_for_mutation<'tcx>(\n     };\n     let def_id = body.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(&mut delegate, &infcx, def_id.expect_local(), cx.param_env, cx.tables()).walk_expr(body);\n+        ExprUseVisitor::new(\n+            &mut delegate,\n+            &infcx,\n+            def_id.expect_local(),\n+            cx.param_env,\n+            cx.typeck_results(),\n+        )\n+        .walk_expr(body);\n     });\n     delegate.mutation_span()\n }\n@@ -1684,7 +1692,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                             if index_used_directly {\n                                 self.indexed_directly.insert(\n                                     seqvar.segments[0].ident.name,\n-                                    (Some(extent), self.cx.tables().node_type(seqexpr.hir_id)),\n+                                    (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                                 );\n                             }\n                             return false;  // no need to walk further *on the variable*\n@@ -1696,7 +1704,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                             if index_used_directly {\n                                 self.indexed_directly.insert(\n                                     seqvar.segments[0].ident.name,\n-                                    (None, self.cx.tables().node_type(seqexpr.hir_id)),\n+                                    (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                                 );\n                             }\n                             return false;  // no need to walk further *on the variable*\n@@ -1764,7 +1772,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             ExprKind::Call(ref f, args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n-                    let ty = self.cx.tables().expr_ty_adjusted(expr);\n+                    let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = ty.kind {\n                         if mutbl == Mutability::Mut {\n@@ -1775,7 +1783,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 }\n             },\n             ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n+                let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = ty.kind {\n@@ -1862,7 +1870,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n-    let ty = cx.tables().expr_ty(e);\n+    let ty = cx.typeck_results().expr_ty(e);\n     is_iterable_array(ty, cx) ||\n     is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n@@ -2221,7 +2229,7 @@ fn path_name(e: &Expr<'_>) -> Option<Name> {\n }\n \n fn check_infinite_loop<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n-    if constant(cx, cx.tables(), cond).is_some() {\n+    if constant(cx, cx.typeck_results(), cond).is_some() {\n         // A pure constant condition (e.g., `while false`) is not linted.\n         return;\n     }\n@@ -2357,7 +2365,7 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n         if let Some(ref generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         then {\n-            let ty = cx.tables().node_type(ty.hir_id);\n+            let ty = cx.typeck_results().node_type(ty.hir_id);\n             if is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n                 is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n                 match_type(cx, ty, &paths::BTREEMAP) ||"}, {"sha": "641e6a17043246937384a2ae7c946d44a91fc634", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n             if let hir::ExprKind::MethodCall(ref method, _, ref args, _) = e.kind;\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n-            let ty = cx.tables().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n             if is_type_diagnostic_item(cx, ty, sym!(option_type)) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                         match closure_expr.kind {\n                             hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => {\n                                 if ident_eq(name, inner) {\n-                                    if let ty::Ref(.., Mutability::Not) = cx.tables().expr_ty(inner).kind {\n+                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind {\n                                         lint(cx, e.span, args[0].span, true);\n                                     }\n                                 }\n@@ -79,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                 if ident_eq(name, &obj[0]) && method.ident.as_str() == \"clone\"\n                                     && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n \n-                                    let obj_ty = cx.tables().expr_ty(&obj[0]);\n+                                    let obj_ty = cx.typeck_results().expr_ty(&obj[0]);\n                                     if let ty::Ref(_, ty, _) = obj_ty.kind {\n                                         let copy = is_copy(cx, ty);\n                                         lint(cx, e.span, args[0].span, copy);"}, {"sha": "d4c2e66ff4b1e4a85dcc80a21feaf8c0e2ba4e3d", "filename": "src/tools/clippy/clippy_lints/src/map_identity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -63,7 +63,7 @@ fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n         if args.len() == 2 && method.ident.as_str() == \"map\";\n-        let caller_ty = cx.tables().expr_ty(&args[0]);\n+        let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n         if match_trait_method(cx, expr, &paths::ITERATOR)\n             || is_type_diagnostic_item(cx, caller_ty, sym!(result_type))\n             || is_type_diagnostic_item(cx, caller_ty, sym!(option_type));\n@@ -119,7 +119,7 @@ fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n /// Returns true iff an expression returns the same thing as a parameter's pattern\n fn match_expr_param(cx: &LateContext<'_>, expr: &Expr<'_>, pat: &Pat<'_>) -> bool {\n     if let PatKind::Binding(_, _, ident, _) = pat.kind {\n-        match_var(expr, ident.name) && !(cx.tables().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr))\n+        match_var(expr, ident.name) && !(cx.typeck_results().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr))\n     } else {\n         false\n     }"}, {"sha": "198251c58ddc50dde677ebcc7397924f1981b26f", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -101,7 +101,7 @@ fn is_unit_type(ty: Ty<'_>) -> bool {\n }\n \n fn is_unit_function(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n \n     if let ty::FnDef(id, _) = ty.kind {\n         if let Some(fn_type) = cx.tcx.fn_sig(id).no_bound_vars() {\n@@ -112,7 +112,7 @@ fn is_unit_function(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n }\n \n fn is_unit_expression(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n-    is_unit_type(cx.tables().expr_ty(expr))\n+    is_unit_type(cx.typeck_results().expr_ty(expr))\n }\n \n /// The expression inside a closure may or may not have surrounding braces and\n@@ -205,13 +205,14 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n     let var_arg = &map_args[0];\n \n-    let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.tables().expr_ty(var_arg), sym!(option_type)) {\n-        (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(var_arg), sym!(result_type)) {\n-        (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n-    } else {\n-        return;\n-    };\n+    let (map_type, variant, lint) =\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym!(option_type)) {\n+            (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n+        } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym!(result_type)) {\n+            (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n+        } else {\n+            return;\n+        };\n     let fn_arg = &map_args[1];\n \n     if is_unit_function(cx, fn_arg) {"}, {"sha": "4f8f2cb171d5bf2358c772e46e172176fa0f36fa", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -88,13 +88,13 @@ fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Opti\n }\n \n fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n     is_type_diagnostic_item(cx, ty, sym!(vec_type))\n }\n \n fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n     match_type(cx, ty, &utils::paths::RANGE_FULL)\n }"}, {"sha": "ea6fb9e902576ee17d43ffd250a6b5277fd4fbfe", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -620,7 +620,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             return; \n         };\n \n-        let ty = cx.tables().expr_ty(ex);\n+        let ty = cx.typeck_results().expr_ty(ex);\n         if ty.kind != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n@@ -712,7 +712,7 @@ fn check_single_match_opt_like(\n \n fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n-    if cx.tables().expr_ty(ex).kind == ty::Bool {\n+    if cx.typeck_results().expr_ty(ex).kind == ty::Bool {\n         span_lint_and_then(\n             cx,\n             MATCH_BOOL,\n@@ -775,8 +775,8 @@ fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n }\n \n fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n-    if arms.len() >= 2 && cx.tables().expr_ty(ex).is_integral() {\n-        let ranges = all_ranges(cx, arms, cx.tables().expr_ty(ex));\n+    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n+        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n         let type_ranges = type_ranges(&ranges);\n         if !type_ranges.is_empty() {\n             if let Some((start, end)) = overlapping(&type_ranges) {\n@@ -794,7 +794,7 @@ fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms\n }\n \n fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ex_ty = walk_ptrs_ty(cx.tables().expr_ty(ex));\n+    let ex_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(ex));\n     if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n@@ -835,7 +835,7 @@ fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n }\n \n fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ty = cx.tables().expr_ty(ex);\n+    let ty = cx.typeck_results().expr_ty(ex);\n     if !ty.is_enum() {\n         // If there isn't a nice closed set of possible values that can be conveniently enumerated,\n         // don't complain about not enumerating the mall.\n@@ -1010,8 +1010,8 @@ fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n                 \"as_mut\"\n             };\n \n-            let output_ty = cx.tables().expr_ty(expr);\n-            let input_ty = cx.tables().expr_ty(ex);\n+            let output_ty = cx.typeck_results().expr_ty(expr);\n+            let input_ty = cx.typeck_results().expr_ty(ex);\n \n             let cast = if_chain! {\n                 if let ty::Adt(_, substs) = input_ty.kind;\n@@ -1079,7 +1079,7 @@ fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) {\n     if_chain! {\n         if arms.len() == 2;\n-        if cx.tables().expr_ty(expr).is_bool();\n+        if cx.typeck_results().expr_ty(expr).is_bool();\n         if is_wild(&arms[1].pat);\n         if let Some(first) = find_bool_lit(&arms[0].body.kind, desugared);\n         if let Some(second) = find_bool_lit(&arms[1].body.kind, desugared);\n@@ -1154,13 +1154,13 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n     match match_body.kind {\n         ExprKind::Block(block, _) => {\n             // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.tables().expr_ty(&match_body).is_unit() {\n+            if block.span.from_expansion() && cx.typeck_results().expr_ty(&match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n         _ => {\n             // expr_ty(body) == ()\n-            if cx.tables().expr_ty(&match_body).is_unit() {\n+            if cx.typeck_results().expr_ty(&match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n@@ -1255,11 +1255,11 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n             {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs = match lhs {\n-                        Some(lhs) => constant(cx, cx.tables(), lhs)?.0,\n+                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n                         None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n                     };\n                     let rhs = match rhs {\n-                        Some(rhs) => constant(cx, cx.tables(), rhs)?.0,\n+                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n                     let rhs = match range_end {\n@@ -1273,7 +1273,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                 }\n \n                 if let PatKind::Lit(ref value) = pat.kind {\n-                    let value = constant(cx, cx.tables(), value)?.0;\n+                    let value = constant(cx, cx.typeck_results(), value)?.0;\n                     return Some(SpannedRange {\n                         span: pat.span,\n                         node: (value.clone(), Bound::Included(value)),"}, {"sha": "c71c2ee7d70afeaf8ab5e63718b781197ef49654", "filename": "src/tools/clippy/clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_DISCRIMINANT);\n             // type is non-enum\n-            let ty_param = cx.tables().node_substs(func.hir_id).type_at(0);\n+            let ty_param = cx.typeck_results().node_substs(func.hir_id).type_at(0);\n             if !ty_param.is_enum();\n \n             then {"}, {"sha": "8c6fd10f98a1e178c4fa6bbdb7b731592208f1f6", "filename": "src/tools/clippy/clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -31,7 +31,7 @@ impl<'tcx> LateLintPass<'tcx> for MemForget {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = qpath_res(cx, qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n-                        let forgot_ty = cx.tables().expr_ty(&args[0]);\n+                        let forgot_ty = cx.typeck_results().expr_ty(&args[0]);\n \n                         if forgot_ty.ty_adt_def().map_or(false, |def| def.has_dtor(cx.tcx)) {\n                             span_lint(cx, MEM_FORGET, e.span, \"usage of `mem::forget` on `Drop` type\");"}, {"sha": "bb0acecc5a92d1a7a5d8fefdfad4ada9372ef443", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -138,7 +138,7 @@ fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &E\n fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if_chain! {\n         // check if replacement is mem::MaybeUninit::uninit().assume_init()\n-        if let Some(method_def_id) = cx.tables().type_dependent_def_id(src.hir_id);\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(src.hir_id);\n         if cx.tcx.is_diagnostic_item(sym::assume_init, method_def_id);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n@@ -179,7 +179,7 @@ fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'\n                     applicability,\n                 );\n             } else if cx.tcx.is_diagnostic_item(sym::mem_zeroed, repl_def_id) &&\n-                    !cx.tables().expr_ty(src).is_primitive() {\n+                    !cx.typeck_results().expr_ty(src).is_primitive() {\n                 span_lint_and_help(\n                     cx,\n                     MEM_REPLACE_WITH_UNINIT,"}, {"sha": "498f12518f8a33745325056f1264dcdb5f6565d2", "filename": "src/tools/clippy/clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -157,7 +157,7 @@ pub(crate) trait BindInsteadOfMap {\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n     fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-        if !match_type(cx, cx.tables().expr_ty(&args[0]), Self::TYPE_QPATH) {\n+        if !match_type(cx, cx.typeck_results().expr_ty(&args[0]), Self::TYPE_QPATH) {\n             return;\n         }\n "}, {"sha": "e5f815772eba946fe32d5221d39c8620e83d553d", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -11,9 +11,9 @@ use rustc_middle::ty::{self, Ty};\n /// Checks for the `INEFFICIENT_TO_STRING` lint\n pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n     if_chain! {\n-        if let Some(to_string_meth_did) = cx.tables().type_dependent_def_id(expr.hir_id);\n+        if let Some(to_string_meth_did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);\n-        if let Some(substs) = cx.tables().node_substs_opt(expr.hir_id);\n+        if let Some(substs) = cx.typeck_results().node_substs_opt(expr.hir_id);\n         let self_ty = substs.type_at(0);\n         let (deref_self_ty, deref_count) = walk_ptrs_ty_depth(self_ty);\n         if deref_count >= 1;"}, {"sha": "40a625758616455c3d0e174c7a6fc747fca11cf7", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -11,7 +11,7 @@ pub fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]\n     let arith_lhs = &args[1][0];\n     let arith_rhs = &args[1][1];\n \n-    let ty = cx.tables().expr_ty(arith_lhs);\n+    let ty = cx.typeck_results().expr_ty(arith_lhs);\n     if !ty.is_integral() {\n         return;\n     }\n@@ -101,7 +101,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n         }\n     }\n \n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     let ty_str = ty.to_string();\n \n     // `std::T::MAX` `std::T::MIN` constants"}, {"sha": "4877556a49e37daaf59173ede295f148af2d4895", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1433,7 +1433,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n-                let self_ty = cx.tables().expr_ty_adjusted(&args[0]);\n+                let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && method_call.ident.name == sym!(clone) {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                     lint_clone_on_ref_ptr(cx, expr, &args[0]);\n@@ -1639,7 +1639,7 @@ fn lint_or_fun_call<'tcx>(\n             if let hir::ExprKind::Path(ref qpath) = fun.kind;\n             let path = &*last_path_segment(qpath).ident.as_str();\n             if [\"default\", \"new\"].contains(&path);\n-            let arg_ty = cx.tables().expr_ty(arg);\n+            let arg_ty = cx.typeck_results().expr_ty(arg);\n             if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n             if implements_trait(cx, arg_ty, default_trait_id, &[]);\n \n@@ -1679,7 +1679,7 @@ fn lint_or_fun_call<'tcx>(\n     ) {\n         if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n-                let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n \n                 match ty.kind {\n                     ty::Slice(_) | ty::Array(_, _) => return,\n@@ -1707,7 +1707,7 @@ fn lint_or_fun_call<'tcx>(\n             if { finder.visit_expr(&arg); finder.found };\n             if !contains_return(&arg);\n \n-            let self_ty = cx.tables().expr_ty(self_expr);\n+            let self_ty = cx.typeck_results().expr_ty(self_expr);\n \n             if let Some(&(_, fn_has_arguments, poss, suffix)) =\n                 know_types.iter().find(|&&i| match_type(cx, self_ty, i.0));\n@@ -1786,7 +1786,7 @@ fn lint_expect_fun_call(\n                     if call_args.len() == 1\n                         && (method_name.ident.name == sym!(as_str) || method_name.ident.name == sym!(as_ref))\n                         && {\n-                            let arg_type = cx.tables().expr_ty(&call_args[0]);\n+                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n                             let base_type = walk_ptrs_ty(arg_type);\n                             base_type.kind == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n                         }\n@@ -1805,7 +1805,7 @@ fn lint_expect_fun_call(\n     // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n     // converted to string.\n     fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n-        let arg_ty = cx.tables().expr_ty(arg);\n+        let arg_ty = cx.typeck_results().expr_ty(arg);\n         if is_type_diagnostic_item(cx, arg_ty, sym!(string_type)) {\n             return false;\n         }\n@@ -1835,15 +1835,16 @@ fn lint_expect_fun_call(\n                     false\n                 }\n             },\n-            hir::ExprKind::MethodCall(..) => cx\n-                .tables()\n-                .type_dependent_def_id(arg.hir_id)\n-                .map_or(false, |method_id| {\n-                    matches!(\n-                        cx.tcx.fn_sig(method_id).output().skip_binder().kind,\n-                        ty::Ref(ty::ReStatic, ..)\n-                    )\n-                }),\n+            hir::ExprKind::MethodCall(..) => {\n+                cx.typeck_results()\n+                    .type_dependent_def_id(arg.hir_id)\n+                    .map_or(false, |method_id| {\n+                        matches!(\n+                            cx.tcx.fn_sig(method_id).output().skip_binder().kind,\n+                            ty::Ref(ty::ReStatic, ..)\n+                        )\n+                    })\n+            },\n             hir::ExprKind::Path(ref p) => matches!(\n                 cx.qpath_res(p, arg.hir_id),\n                 hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n@@ -1891,7 +1892,7 @@ fn lint_expect_fun_call(\n         return;\n     }\n \n-    let receiver_type = cx.tables().expr_ty_adjusted(&args[0]);\n+    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n     let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym!(option_type)) {\n         \"||\"\n     } else if is_type_diagnostic_item(cx, receiver_type, sym!(result_type)) {\n@@ -1957,7 +1958,7 @@ fn lint_expect_fun_call(\n \n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     if let ty::Ref(_, inner, _) = arg_ty.kind {\n         if let ty::Ref(_, innermost, _) = inner.kind {\n             span_lint_and_then(\n@@ -2005,7 +2006,9 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                     // &*x is a nop, &x.clone() is not\n                     hir::ExprKind::AddrOf(..) => return,\n                     // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => return,\n+                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => {\n+                        return;\n+                    },\n \n                     _ => {},\n                 },\n@@ -2021,11 +2024,11 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n             }\n \n             // x.clone() might have dereferenced x, possibly through Deref impls\n-            if cx.tables().expr_ty(arg) == ty {\n+            if cx.typeck_results().expr_ty(arg) == ty {\n                 snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n             } else {\n                 let deref_count = cx\n-                    .tables()\n+                    .typeck_results()\n                     .expr_adjustments(arg)\n                     .iter()\n                     .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n@@ -2045,7 +2048,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n }\n \n fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n-    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(arg));\n+    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(arg));\n \n     if let ty::Adt(_, subst) = obj_ty.kind {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n@@ -2079,7 +2082,7 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n-        let self_ty = walk_ptrs_ty(cx.tables().expr_ty(target));\n+        let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(target));\n         let ref_str = if self_ty.kind == ty::Str {\n             \"\"\n         } else if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n@@ -2107,15 +2110,15 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n }\n \n fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n     if is_type_diagnostic_item(cx, obj_ty, sym!(string_type)) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n fn lint_cstring_as_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, source: &hir::Expr<'_>, unwrap: &hir::Expr<'_>) {\n     if_chain! {\n-        let source_type = cx.tables().expr_ty(source);\n+        let source_type = cx.typeck_results().expr_ty(source);\n         if let ty::Adt(def, substs) = source_type.kind;\n         if cx.tcx.is_diagnostic_item(sym!(result_type), def.did);\n         if match_type(cx, substs.type_at(0), &paths::CSTRING);\n@@ -2135,8 +2138,8 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, source: &hir:\n \n fn lint_iter_cloned_collect<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n-        if is_type_diagnostic_item(cx, cx.tables().expr_ty(expr), sym!(vec_type));\n-        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables().expr_ty(&iter_args[0]));\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym!(vec_type));\n+        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0]));\n         if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n \n         then {\n@@ -2243,7 +2246,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args:\n \n fn lint_step_by<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.tables(), &args[1]) {\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &args[1]) {\n             span_lint(\n                 cx,\n                 ITERATOR_STEP_BY_ZERO,\n@@ -2267,7 +2270,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n         parent_expr_opt = get_parent_expr(cx, parent_expr);\n     }\n \n-    if derefs_to_slice(cx, caller_expr, cx.tables().expr_ty(caller_expr)).is_some() {\n+    if derefs_to_slice(cx, caller_expr, cx.typeck_results().expr_ty(caller_expr)).is_some() {\n         // caller is a Slice\n         if_chain! {\n             if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n@@ -2288,8 +2291,11 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n                 );\n             }\n         }\n-    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(caller_expr), sym!(vec_type))\n-        || matches!(&walk_ptrs_ty(cx.tables().expr_ty(caller_expr)).kind, ty::Array(_, _))\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym!(vec_type))\n+        || matches!(\n+            &walk_ptrs_ty(cx.typeck_results().expr_ty(caller_expr)).kind,\n+            ty::Array(_, _)\n+        )\n     {\n         // caller is a Vec or an Array\n         let mut applicability = Applicability::MachineApplicable;\n@@ -2316,11 +2322,11 @@ fn lint_iter_nth<'tcx>(\n ) {\n     let iter_args = nth_and_iter_args[1];\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables().expr_ty(&iter_args[0])).is_some() {\n+    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(&iter_args[0]), sym!(vec_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vec_type)) {\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n         \"VecDeque\"\n     } else {\n         let nth_args = nth_and_iter_args[0];\n@@ -2341,7 +2347,7 @@ fn lint_iter_nth<'tcx>(\n fn lint_iter_nth_zero<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n         if match_trait_method(cx, expr, &paths::ITERATOR);\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.tables(), &nth_args[1]);\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &nth_args[1]);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n@@ -2361,7 +2367,7 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n-    let expr_ty = cx.tables().expr_ty(&get_args[0]);\n+    let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n     let get_args_str = if get_args.len() > 1 {\n         snippet_with_applicability(cx, get_args[1].span, \"_\", &mut applicability)\n     } else {\n@@ -2463,7 +2469,7 @@ fn derefs_to_slice<'tcx>(\n     }\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-        if path.ident.name == sym!(iter) && may_slice(cx, cx.tables().expr_ty(&args[0])) {\n+        if path.ident.name == sym!(iter) && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {\n             None\n@@ -2486,7 +2492,7 @@ fn derefs_to_slice<'tcx>(\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&unwrap_args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&unwrap_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((UNWRAP_USED, \"an Option\", \"None\"))\n@@ -2514,7 +2520,7 @@ fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::E\n \n /// lint use of `expect()` for `Option`s and `Result`s\n fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&expect_args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&expect_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((EXPECT_USED, \"an Option\", \"None\"))\n@@ -2540,8 +2546,8 @@ fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::E\n fn lint_ok_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if is_type_diagnostic_item(cx, cx.tables().expr_ty(&ok_args[0]), sym!(result_type));\n-        let result_type = cx.tables().expr_ty(&ok_args[0]);\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym!(result_type));\n+        let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n \n@@ -2579,7 +2585,7 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n         let msg = \"called `map(..).flatten()` on an `Option`. \\\n                     This is more succinctly expressed by calling `.and_then(..)`\";\n         let self_snippet = snippet(cx, map_args[0].span, \"..\");\n@@ -2605,8 +2611,8 @@ fn lint_map_unwrap_or_else<'tcx>(\n     unwrap_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(result_type));\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n@@ -2656,8 +2662,8 @@ fn lint_map_unwrap_or_else<'tcx>(\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n-    let is_option = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_or_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_or_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym!(result_type));\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -3014,7 +3020,7 @@ fn lint_chars_cmp(\n         if segment.ident.name == sym!(Some);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = walk_ptrs_ty(cx.tables().expr_ty_adjusted(&args[0][0]));\n+            let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty_adjusted(&args[0][0]));\n \n             if self_ty.kind != ty::Str {\n                 return false;\n@@ -3142,8 +3148,8 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n         let recvr = &as_ref_args[0];\n-        let rcv_ty = cx.tables().expr_ty(recvr);\n-        let res_ty = cx.tables().expr_ty(expr);\n+        let rcv_ty = cx.typeck_results().expr_ty(recvr);\n+        let res_ty = cx.typeck_results().expr_ty(expr);\n         let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n         let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n         if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n@@ -3212,7 +3218,7 @@ fn lint_maybe_uninit(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Ex\n         if args.is_empty();\n         if let hir::ExprKind::Path(ref path) = callee.kind;\n         if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n-        if !is_maybe_uninit_ty_valid(cx, cx.tables().expr_ty_adjusted(outer));\n+        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(outer));\n         then {\n             span_lint(\n                 cx,\n@@ -3254,7 +3260,7 @@ fn lint_option_as_ref_deref<'tcx>(\n ) {\n     let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n \n-    let option_ty = cx.tables().expr_ty(&as_ref_args[0]);\n+    let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n     if !is_type_diagnostic_item(cx, option_ty, sym!(option_type)) {\n         return;\n     }\n@@ -3284,10 +3290,10 @@ fn lint_option_as_ref_deref<'tcx>(\n                         if let hir::ExprKind::Path(qpath) = &args[0].kind;\n                         if let hir::def::Res::Local(local_id) = cx.qpath_res(qpath, args[0].hir_id);\n                         if closure_body.params[0].pat.hir_id == local_id;\n-                        let adj = cx.tables().expr_adjustments(&args[0]).iter().map(|x| &x.kind).collect::<Box<[_]>>();\n+                        let adj = cx.typeck_results().expr_adjustments(&args[0]).iter().map(|x| &x.kind).collect::<Box<[_]>>();\n                         if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n                         then {\n-                            let method_did = cx.tables().type_dependent_def_id(closure_expr.hir_id).unwrap();\n+                            let method_did = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id).unwrap();\n                             deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n                         } else {\n                             false\n@@ -3577,7 +3583,7 @@ fn contains_return(expr: &hir::Expr<'_>) -> bool {\n fn check_pointer_offset(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if_chain! {\n         if args.len() == 2;\n-        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.tables().expr_ty(&args[0]).kind;\n+        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind;\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         if layout.is_zst();\n         then {\n@@ -3587,7 +3593,7 @@ fn check_pointer_offset(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir:\n }\n \n fn lint_filetype_is_file(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let ty = cx.tables().expr_ty(&args[0]);\n+    let ty = cx.typeck_results().expr_ty(&args[0]);\n \n     if !match_type(cx, ty, &paths::FILE_TYPE) {\n         return;"}, {"sha": "95fa28e1c0f75507fb99feb648e68347458f5a2d", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -20,8 +20,8 @@ pub(super) fn lint<'tcx>(\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type)) {\n-        if !is_copy(cx, cx.tables().expr_ty(&unwrap_args[1])) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n+        if !is_copy(cx, cx.typeck_results().expr_ty(&unwrap_args[1])) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument\n "}, {"sha": "dae39aaf5e2165e6ffa9e31e5f8ffc5ffd0062c4", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for MinMaxPass {\n                 }\n                 match (\n                     outer_max,\n-                    Constant::partial_cmp(cx.tcx, cx.tables().expr_ty(ie), &outer_c, &inner_c),\n+                    Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(ie), &outer_c, &inner_c),\n                 ) {\n                     (_, None) | (MinMax::Max, Some(Ordering::Less)) | (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n@@ -62,7 +62,7 @@ enum MinMax {\n fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     if let ExprKind::Call(ref path, ref args) = expr.kind {\n         if let ExprKind::Path(ref qpath) = path.kind {\n-            cx.tables()\n+            cx.typeck_results()\n                 .qpath_res(qpath, path.hir_id)\n                 .opt_def_id()\n                 .and_then(|def_id| {\n@@ -86,10 +86,10 @@ fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Opt\n     if args.len() != 2 {\n         return None;\n     }\n-    constant_simple(cx, cx.tables(), &args[0]).map_or_else(\n-        || constant_simple(cx, cx.tables(), &args[1]).map(|c| (m, c, &args[0])),\n+    constant_simple(cx, cx.typeck_results(), &args[0]).map_or_else(\n+        || constant_simple(cx, cx.typeck_results(), &args[1]).map(|c| (m, c, &args[0])),\n         |c| {\n-            if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n+            if constant_simple(cx, cx.typeck_results(), &args[1]).is_none() {\n                 // otherwise ignore\n                 Some((m, c, &args[1]))\n             } else {"}, {"sha": "fc10e5077b8391c429a958d91fed858aab8f88f2", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -496,7 +496,7 @@ fn get_lint_and_message(\n fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n     if_chain! {\n         if !in_constant(cx, cmp_expr.hir_id);\n-        if let Some((value, _)) = constant(cx, cx.tables(), expr);\n+        if let Some((value, _)) = constant(cx, cx.typeck_results(), expr);\n         then {\n             let needs_lint = match value {\n                 Constant::F32(num) => num.is_nan(),\n@@ -517,15 +517,15 @@ fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n }\n \n fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some((_, res)) = constant(cx, cx.tables(), expr) {\n+    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n         res\n     } else {\n         false\n     }\n }\n \n fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match constant(cx, cx.tables(), expr) {\n+    match constant(cx, cx.typeck_results(), expr) {\n         Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n@@ -557,7 +557,7 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let value = &walk_ptrs_ty(cx.tables().expr_ty(expr)).kind;\n+    let value = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind;\n \n     if let ty::Array(arr_ty, _) = value {\n         return matches!(arr_ty.kind, ty::Float(_));\n@@ -567,7 +567,7 @@ fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(&walk_ptrs_ty(cx.tables().expr_ty(expr)).kind, ty::Array(_, _))\n+    matches!(&walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind, ty::Array(_, _))\n }\n \n fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n@@ -593,15 +593,15 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n-                (cx.tables().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.typeck_results().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.typeck_results().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -612,7 +612,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n         _ => return,\n     };\n \n-    let other_ty = cx.tables().expr_ty(other);\n+    let other_ty = cx.typeck_results().expr_ty(other);\n \n     let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n     let with_deref = arg_ty"}, {"sha": "5d4436bd206d2b48d61edcbbee93b20cd02b26bf", "filename": "src/tools/clippy/clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -37,8 +37,8 @@ struct OperandInfo {\n }\n \n fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n-    match constant(cx, cx.tables(), operand) {\n-        Some((Constant::Int(v), _)) => match cx.tables().expr_ty(expr).kind {\n+    match constant(cx, cx.typeck_results(), operand) {\n+        Some((Constant::Int(v), _)) => match cx.typeck_results().expr_ty(expr).kind {\n             ty::Int(ity) => {\n                 let value = sext(cx.tcx, v, ity);\n                 return Some(OperandInfo {\n@@ -106,7 +106,7 @@ fn check_const_operands<'tcx>(\n }\n \n fn check_non_const_operands<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, operand: &Expr<'_>) {\n-    let operand_type = cx.tables().expr_ty(operand);\n+    let operand_type = cx.typeck_results().expr_ty(operand);\n     if might_have_negative_value(operand_type) {\n         span_lint_and_then(\n             cx,"}, {"sha": "9f8f401cc0f67d4e869fb002e914d4bfa18f1d7d", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n         if let hir::PatKind::Wild = local.pat.kind {\n             return;\n         }\n-        check_ty(cx, local.span, cx.tables().pat_ty(&*local.pat));\n+        check_ty(cx, local.span, cx.typeck_results().pat_ty(&*local.pat));\n     }\n }\n "}, {"sha": "b02e86bca27195c2a39a7639176adee31fbf2368", "filename": "src/tools/clippy/clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.tables().expr_ty(e).kind {\n+            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,"}, {"sha": "b8dc5081632972827f9fc9203246dabc8649d096", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -37,14 +37,14 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                     check_arguments(\n                         cx,\n                         arguments,\n-                        cx.tables().expr_ty(fn_expr),\n+                        cx.typeck_results().expr_ty(fn_expr),\n                         &rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false)),\n                     );\n                 }\n             },\n             ExprKind::MethodCall(ref path, _, ref arguments, _) => {\n-                let def_id = cx.tables().type_dependent_def_id(e.hir_id).unwrap();\n-                let substs = cx.tables().node_substs(e.hir_id);\n+                let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n+                let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n                 check_arguments(cx, arguments, method_type, &path.ident.as_str())\n             },"}, {"sha": "7f529f0404c00af727db852f1725efe0e3647569", "filename": "src/tools/clippy/clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 return;\n             },\n             ExprKind::Path(_) => {\n-                if let Some(adj) = self.cx.tables().adjustments().get(expr.hir_id) {\n+                if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj\n                         .iter()\n                         .any(|a| matches!(a.target.kind, ty::Ref(_, _, Mutability::Mut)))"}, {"sha": "568898aa5c9b7773f4e0fb53679def984114065b", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -66,7 +66,7 @@ declare_lint_pass!(Mutex => [MUTEX_ATOMIC, MUTEX_INTEGER]);\n \n impl<'tcx> LateLintPass<'tcx> for Mutex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let ty = cx.tables().expr_ty(expr);\n+        let ty = cx.typeck_results().expr_ty(expr);\n         if let ty::Adt(_, subst) = ty.kind {\n             if is_type_diagnostic_item(cx, ty, sym!(mutex_type)) {\n                 let mutex_param = subst.type_at(0);"}, {"sha": "8e44f2ec2408c8807cc55d5889040346c3c65a76", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -229,7 +229,10 @@ fn check_comparison<'a, 'tcx>(\n     use self::Expression::{Bool, Other};\n \n     if let ExprKind::Binary(op, ref left_side, ref right_side) = e.kind {\n-        let (l_ty, r_ty) = (cx.tables().expr_ty(left_side), cx.tables().expr_ty(right_side));\n+        let (l_ty, r_ty) = (\n+            cx.typeck_results().expr_ty(left_side),\n+            cx.typeck_results().expr_ty(right_side),\n+        );\n         if l_ty.is_bool() && r_ty.is_bool() {\n             let mut applicability = Applicability::MachineApplicable;\n "}, {"sha": "415ab556c9fd4eb830e88f4a230fcc2296d59410", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -46,8 +46,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n-            if let ty::Ref(..) = cx.tables().expr_ty(inner).kind {\n-                for adj3 in cx.tables().expr_adjustments(e).windows(3) {\n+            if let ty::Ref(..) = cx.typeck_results().expr_ty(inner).kind {\n+                for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_), ..\n                     }, Adjustment {\n@@ -85,7 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n         }\n         if_chain! {\n             if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.kind;\n-            if let ty::Ref(_, tam, mutbl) = cx.tables().pat_ty(pat).kind;\n+            if let ty::Ref(_, tam, mutbl) = cx.typeck_results().pat_ty(pat).kind;\n             if mutbl == Mutability::Not;\n             if let ty::Ref(_, _, mutbl) = tam.kind;\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out"}, {"sha": "81774b617ac2e5c9bbd4e4ae0b507cfc10ff16b0", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -135,7 +135,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         } = {\n             let mut ctx = MovedVariablesCtxt::default();\n             cx.tcx.infer_ctxt().enter(|infcx| {\n-                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.tables()).consume_body(body);\n+                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n+                    .consume_body(body);\n             });\n             ctx\n         };"}, {"sha": "ce3f066eff5e7d5d6c8227563c818a826fc98ff1", "filename": "src/tools/clippy/clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -47,7 +47,7 @@ declare_lint_pass!(NeedlessUpdate => [NEEDLESS_UPDATE]);\n impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n-            let ty = cx.tables().expr_ty(expr);\n+            let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind {\n                 if fields.len() == def.non_enum_variant().fields.len() {\n                     span_lint("}, {"sha": "95613a1b82ef0f32101c061c696730dabea56ea7", "filename": "src/tools/clippy/clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n \n             then {\n \n-                let ty = cx.tables().expr_ty(left);\n+                let ty = cx.typeck_results().expr_ty(left);\n \n                 let implements_ord = {\n                     if let Some(id) = utils::get_trait_def_id(cx, &paths::ORD) {"}, {"sha": "6b6c950e0abee23231a72782d11db11e1771e9a7", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -44,8 +44,8 @@ impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.kind;\n-        if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.tables().expr_ty_opt(lit));\n-        if cx.tables().expr_ty(exp).is_integral();\n+        if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.typeck_results().expr_ty_opt(lit));\n+        if cx.typeck_results().expr_ty(exp).is_integral();\n         then {\n             span_lint(cx, NEG_MULTIPLY, span, \"Negation by multiplying with `-1`\");\n         }"}, {"sha": "b1b5b3439a0e384e6335d7c40665fdcc631d8d73", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -48,7 +48,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n     match expr.kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n-        ExprKind::Path(..) => !has_drop(cx, cx.tables().expr_ty(expr)),\n+        ExprKind::Path(..) => !has_drop(cx, cx.typeck_results().expr_ty(expr)),\n         ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n             has_no_effect(cx, a) && has_no_effect(cx, b)\n         },\n@@ -61,7 +61,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         | ExprKind::AddrOf(_, _, ref inner)\n         | ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n         ExprKind::Struct(_, ref fields, ref base) => {\n-            !has_drop(cx, cx.tables().expr_ty(expr))\n+            !has_drop(cx, cx.typeck_results().expr_ty(expr))\n                 && fields.iter().all(|field| has_no_effect(cx, &field.expr))\n                 && base.as_ref().map_or(true, |base| has_no_effect(cx, base))\n         },\n@@ -70,7 +70,8 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..) => {\n-                        !has_drop(cx, cx.tables().expr_ty(expr)) && args.iter().all(|arg| has_no_effect(cx, arg))\n+                        !has_drop(cx, cx.typeck_results().expr_ty(expr))\n+                            && args.iter().all(|arg| has_no_effect(cx, arg))\n                     },\n                     _ => false,\n                 }\n@@ -137,7 +138,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n         | ExprKind::AddrOf(_, _, ref inner)\n         | ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n         ExprKind::Struct(_, ref fields, ref base) => {\n-            if has_drop(cx, cx.tables().expr_ty(expr)) {\n+            if has_drop(cx, cx.typeck_results().expr_ty(expr)) {\n                 None\n             } else {\n                 Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n@@ -148,7 +149,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..)\n-                        if !has_drop(cx, cx.tables().expr_ty(expr)) =>\n+                        if !has_drop(cx, cx.typeck_results().expr_ty(expr)) =>\n                     {\n                         Some(args.iter().collect())\n                     },"}, {"sha": "031d69e86a13edb2c7c5406127dcf67f6d6bd65d", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -237,13 +237,13 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n             }\n \n             let ty = if needs_check_adjustment {\n-                let adjustments = cx.tables().expr_adjustments(dereferenced_expr);\n+                let adjustments = cx.typeck_results().expr_adjustments(dereferenced_expr);\n                 if let Some(i) = adjustments\n                     .iter()\n                     .position(|adj| matches!(adj.kind, Adjust::Borrow(_) | Adjust::Deref(_)))\n                 {\n                     if i == 0 {\n-                        cx.tables().expr_ty(dereferenced_expr)\n+                        cx.typeck_results().expr_ty(dereferenced_expr)\n                     } else {\n                         adjustments[i - 1].target\n                     }\n@@ -252,7 +252,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                     return;\n                 }\n             } else {\n-                cx.tables().expr_ty(dereferenced_expr)\n+                cx.typeck_results().expr_ty(dereferenced_expr)\n             };\n \n             verify_ty_bound(cx, ty, Source::Expr { expr: expr.span });"}, {"sha": "e99d0317ba2e8ca1b6e3bcf5744ec4071931c1da", "filename": "src/tools/clippy/clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -30,7 +30,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, ref arguments, _) = e.kind {\n-            let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&arguments[0]));\n+            let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&arguments[0]));\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n@@ -58,7 +58,7 @@ enum OpenOption {\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprKind::MethodCall(ref path, _, ref arguments, _) = argument.kind {\n-        let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&arguments[0]));\n+        let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {"}, {"sha": "065f863b8654e0dddac2cf299614c803b59f411a", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -72,7 +72,8 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n /// Returns true iff the given expression is the result of calling `Result::ok`\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n-        path.ident.name.to_ident_string() == \"ok\" && match_type(cx, &cx.tables().expr_ty(&receiver), &paths::RESULT)\n+        path.ident.name.to_ident_string() == \"ok\"\n+            && match_type(cx, &cx.typeck_results().expr_ty(&receiver), &paths::RESULT)\n     } else {\n         false\n     }"}, {"sha": "4d4a9676654826b36360539531c092a5b85de056", "filename": "src/tools/clippy/clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -36,8 +36,8 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n             if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n             if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n-            if cx.tables().expr_ty(ident1).is_integral();\n-            if cx.tables().expr_ty(ident2).is_integral();\n+            if cx.typeck_results().expr_ty(ident1).is_integral();\n+            if cx.typeck_results().expr_ty(ident2).is_integral();\n             then {\n                 if let BinOpKind::Lt = op.node {\n                     if let BinOpKind::Add = op2.node {\n@@ -61,8 +61,8 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n             if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n             if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n-            if cx.tables().expr_ty(ident1).is_integral();\n-            if cx.tables().expr_ty(ident2).is_integral();\n+            if cx.typeck_results().expr_ty(ident1).is_integral();\n+            if cx.typeck_results().expr_ty(ident2).is_integral();\n             then {\n                 if let BinOpKind::Gt = op.node {\n                     if let BinOpKind::Add = op2.node {"}, {"sha": "66a145a7f14b39b2cd81eec5c976033afd5bc3a3", "filename": "src/tools/clippy/clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n-            if match_type(cx, walk_ptrs_ty(cx.tables().expr_ty(&args[0])), &paths::PATH_BUF);\n+            if match_type(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0])), &paths::PATH_BUF);\n             if let Some(get_index_arg) = args.get(1);\n             if let ExprKind::Lit(ref lit) = get_index_arg.kind;\n             if let LitKind::Str(ref path_lit, _) = lit.node;"}, {"sha": "ef26fc667b22591f7b0cba87600407a8081b2848", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(ref local) = stmt.kind {\n             if let Some(init) = &local.init {\n-                if let Some(init_ty) = cx.tables().node_type_opt(init.hir_id) {\n+                if let Some(init_ty) = cx.typeck_results().node_type_opt(init.hir_id) {\n                     let pat = &local.pat;\n                     if in_external_macro(cx.sess(), pat.span) {\n                         return;\n@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n         if let ExprKind::Match(ref expr, arms, source) = expr.kind {\n             match source {\n                 MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n-                    if let Some(expr_ty) = cx.tables().node_type_opt(expr.hir_id) {\n+                    if let Some(expr_ty) = cx.typeck_results().node_type_opt(expr.hir_id) {\n                         'pattern_checks: for arm in arms {\n                             let pat = &arm.pat;\n                             if in_external_macro(cx.sess(), pat.span) {\n@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n         _: Span,\n         hir_id: HirId,\n     ) {\n-        if let Some(fn_sig) = cx.tables().liberated_fn_sigs().get(hir_id) {\n+        if let Some(fn_sig) = cx.typeck_results().liberated_fn_sigs().get(hir_id) {\n             for (param, ty) in body.params.iter().zip(fn_sig.inputs().iter()) {\n                 apply_lint(cx, &param.pat, ty, DerefPossible::Impossible);\n             }"}, {"sha": "0a2d1b5fbe6ac56b2fe0e1f27aecb0db8e5a71fa", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -105,12 +105,12 @@ fn expr_as_ptr_offset_call<'tcx>(\n \n // Is the type of the expression a usize?\n fn is_expr_ty_usize<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n-    cx.tables().expr_ty(expr) == cx.tcx.types.usize\n+    cx.typeck_results().expr_ty(expr) == cx.tcx.types.usize\n }\n \n // Is the type of the expression a raw pointer?\n fn is_expr_ty_raw_ptr<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n-    cx.tables().expr_ty(expr).is_unsafe_ptr()\n+    cx.typeck_results().expr_ty(expr).is_unsafe_ptr()\n }\n \n fn build_suggestion<'tcx>("}, {"sha": "fb12c565afd863048bbcbc895f1abb4fbf36b082", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -135,13 +135,13 @@ impl QuestionMark {\n     }\n \n     fn moves_by_default(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.tables().expr_ty(expression);\n+        let expr_ty = cx.typeck_results().expr_ty(expression);\n \n         !expr_ty.is_copy_modulo_regions(cx.tcx.at(expression.span), cx.param_env)\n     }\n \n     fn is_option(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.tables().expr_ty(expression);\n+        let expr_ty = cx.typeck_results().expr_ty(expression);\n \n         is_type_diagnostic_item(cx, expr_ty, sym!(option_type))\n     }"}, {"sha": "4c1f2e8e01a8c9b485399aa994a8a1ada33ff8aa", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -280,10 +280,10 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n     if_chain! {\n         if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(cx, expr);\n-        let ty = cx.tables().expr_ty(start);\n+        let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind;\n-        if let Some((start_idx, _)) = constant(cx, cx.tables(), start);\n-        if let Some((end_idx, _)) = constant(cx, cx.tables(), end);\n+        if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);\n+        if let Some((end_idx, _)) = constant(cx, cx.typeck_results(), end);\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);\n         if is_empty_range(limits, ordering);\n         then {"}, {"sha": "dfc158661cbf68cd0b6b2c9c1600077076d272f6", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -89,7 +89,7 @@ fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u16) -> Span {\n }\n \n fn const_str<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n-    constant(cx, cx.tables(), e).and_then(|(c, _)| match c {\n+    constant(cx, cx.typeck_results(), e).and_then(|(c, _)| match c {\n         Constant::Str(s) => Some(s),\n         _ => None,\n     })"}, {"sha": "77c206002ea790684217a3cc6404b69d7a14b7b3", "filename": "src/tools/clippy/clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -41,10 +41,10 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n         if_chain! {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(repeat);\n-            if let Some(Constant::Int(1)) = constant_context(cx, cx.tables()).expr(&args[1]);\n+            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&args[1]);\n             if !in_macro(args[0].span);\n             then {\n-                let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n                 if ty.is_str() {\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "901c0a65d7fef93b06cd208427787235ee4bc76c", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -164,7 +164,7 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n }\n \n fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n-    let var_ty = cx.tables().node_type_opt(pat_id);\n+    let var_ty = cx.typeck_results().node_type_opt(pat_id);\n     var_ty.map_or(false, |var_ty| !matches!(var_ty.kind, ty::Adt(..)))\n }\n "}, {"sha": "bada6fa7c522fca28060f7544026edd753a53746", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -134,7 +134,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    is_type_diagnostic_item(cx, walk_ptrs_ty(cx.tables().expr_ty(e)), sym!(string_type))\n+    is_type_diagnostic_item(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(e)), sym!(string_type))\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {"}, {"sha": "754f87e6b55e2585f9b79b4c7993e78b6049df21", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -194,7 +194,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n-                let ty = walk_ptrs_ty(cx.tables().expr_ty(lhs1));\n+                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n \n                 if matches!(ty.kind, ty::Slice(_))\n                     || matches!(ty.kind, ty::Array(_, _))"}, {"sha": "6750452941f28a1b15dc11cb02e4ad301ed3b2bd", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n                         if_chain! {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";\n-                            let char_arg_ty = cx.tables().expr_ty_adjusted(char_arg);\n+                            let char_arg_ty = cx.typeck_results().expr_ty_adjusted(char_arg);\n                             if char_arg_ty.kind == ty::Char;\n                             then {\n                                 Some((true, char_arg, radix_arg))"}, {"sha": "d55eb1a0c938702386e9b25e80447a0ffa4f10ed", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -302,8 +302,8 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n             if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::TRANSMUTE);\n             then {\n-                let from_ty = cx.tables().expr_ty(&args[0]);\n-                let to_ty = cx.tables().expr_ty(e);\n+                let from_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let to_ty = cx.typeck_results().expr_ty(e);\n \n                 match (&from_ty.kind, &to_ty.kind) {\n                     _ if from_ty == to_ty => span_lint("}, {"sha": "fbf7f0b2517ac19bea082525b49467bd2898add0", "filename": "src/tools/clippy/clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n             then {\n \n                 // Catching transmute over constants that resolve to `null`.\n-                let mut const_eval_context = constant_context(cx, cx.tables());\n+                let mut const_eval_context = constant_context(cx, cx.typeck_results());\n                 if_chain! {\n                     if let ExprKind::Path(ref _qpath) = args[0].kind;\n                     let x = const_eval_context.expr(&args[0]);"}, {"sha": "d3b351f30ef7c9c0b4f8211fd711f01e8221e972", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n             if let Some(return_type) = find_err_return_type(cx, &expr.kind);\n \n             then {\n-                let err_type = cx.tables().expr_ty(err_arg);\n+                let err_type = cx.typeck_results().expr_ty(err_arg);\n                 let origin_snippet = if err_arg.span.from_expansion() {\n                     snippet_with_macro_callsite(cx, err_arg.span, \"_\")\n                 } else {\n@@ -114,7 +114,7 @@ fn find_err_return_type_arm<'tcx>(cx: &LateContext<'tcx>, arm: &'tcx Arm<'_>) ->\n         if match_qpath(from_error_fn, &paths::TRY_FROM_ERROR);\n         if let Some(from_error_arg) = from_error_args.get(0);\n         then {\n-            Some(cx.tables().expr_ty(from_error_arg))\n+            Some(cx.typeck_results().expr_ty(from_error_arg))\n         } else {\n             None\n         }"}, {"sha": "c3dea44752133bf9d8a24fee5e402c427651ef76", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeckTables};\n+use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeckResults};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n@@ -595,7 +595,7 @@ declare_lint_pass!(LetUnitValue => [LET_UNIT_VALUE]);\n impl<'tcx> LateLintPass<'tcx> for LetUnitValue {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(ref local) = stmt.kind {\n-            if is_unit(cx.tables().pat_ty(&local.pat)) {\n+            if is_unit(cx.typeck_results().pat_ty(&local.pat)) {\n                 if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                     return;\n                 }\n@@ -680,7 +680,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitCmp {\n                 if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n                     if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n                         let op = cmp.node;\n-                        if op.is_comparison() && is_unit(cx.tables().expr_ty(left)) {\n+                        if op.is_comparison() && is_unit(cx.typeck_results().expr_ty(left)) {\n                             let result = match &*symbol.as_str() {\n                                 \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n                                 \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n@@ -704,7 +704,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitCmp {\n         }\n         if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n             let op = cmp.node;\n-            if op.is_comparison() && is_unit(cx.tables().expr_ty(left)) {\n+            if op.is_comparison() && is_unit(cx.typeck_results().expr_ty(left)) {\n                 let result = match op {\n                     BinOpKind::Eq | BinOpKind::Le | BinOpKind::Ge => \"true\",\n                     _ => \"false\",\n@@ -774,7 +774,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitArg {\n                 let args_to_recover = args\n                     .iter()\n                     .filter(|arg| {\n-                        if is_unit(cx.tables().expr_ty(arg)) && !is_unit_literal(arg) {\n+                        if is_unit(cx.typeck_results().expr_ty(arg)) && !is_unit_literal(arg) {\n                             !matches!(&arg.kind, ExprKind::Match(.., MatchSource::TryDesugar))\n                         } else {\n                             false\n@@ -1232,7 +1232,7 @@ fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     }\n \n     // don't lint for positive constants\n-    let const_val = constant(cx, &cx.tables(), op);\n+    let const_val = constant(cx, &cx.typeck_results(), op);\n     if_chain! {\n         if let Some((const_val, _)) = const_val;\n         if let Constant::Int(n) = const_val;\n@@ -1398,7 +1398,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             return;\n         }\n         if let ExprKind::Cast(ref ex, _) = expr.kind {\n-            let (cast_from, cast_to) = (cx.tables().expr_ty(ex), cx.tables().expr_ty(expr));\n+            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n             if let ExprKind::Lit(ref lit) = ex.kind {\n                 if_chain! {\n@@ -1786,7 +1786,7 @@ impl<'tcx> LateLintPass<'tcx> for CharLitAsU8 {\n             if let ExprKind::Cast(e, _) = &expr.kind;\n             if let ExprKind::Lit(l) = &e.kind;\n             if let LitKind::Char(c) = l.node;\n-            if ty::Uint(UintTy::U8) == cx.tables().expr_ty(expr).kind;\n+            if ty::Uint(UintTy::U8) == cx.typeck_results().expr_ty(expr).kind;\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n@@ -1862,8 +1862,8 @@ enum AbsurdComparisonResult {\n \n fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let precast_ty = cx.tables().expr_ty(cast_exp);\n-        let cast_ty = cx.tables().expr_ty(expr);\n+        let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n \n         return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n     }\n@@ -1883,7 +1883,7 @@ fn detect_absurd_comparison<'tcx>(\n \n     // absurd comparison only makes sense on primitive types\n     // primitive types don't implement comparison operators with each other\n-    if cx.tables().expr_ty(lhs) != cx.tables().expr_ty(rhs) {\n+    if cx.typeck_results().expr_ty(lhs) != cx.typeck_results().expr_ty(rhs) {\n         return None;\n     }\n \n@@ -1921,9 +1921,9 @@ fn detect_absurd_comparison<'tcx>(\n fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n     use crate::types::ExtremeType::{Maximum, Minimum};\n \n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n \n-    let cv = constant(cx, cx.tables(), expr)?.0;\n+    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n \n     let which = match (&ty.kind, cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n@@ -2053,8 +2053,8 @@ impl Ord for FullInt {\n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let pre_cast_ty = cx.tables().expr_ty(cast_exp);\n-        let cast_ty = cx.tables().expr_ty(expr);\n+        let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n         // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n         if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n             return None;\n@@ -2084,9 +2084,9 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) ->\n }\n \n fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n-    let val = constant(cx, cx.tables(), expr)?.0;\n+    let val = constant(cx, cx.typeck_results(), expr)?.0;\n     if let Constant::Int(const_int) = val {\n-        match cx.tables().expr_ty(expr).kind {\n+        match cx.typeck_results().expr_ty(expr).kind {\n             ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n             ty::Uint(_) => Some(FullInt::U(const_int)),\n             _ => None,\n@@ -2472,7 +2472,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n /// Looks for default-hasher-dependent constructors like `HashMap::new`.\n struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     target: &'b ImplicitHasherType<'tcx>,\n     suggestions: BTreeMap<Span, String>,\n }\n@@ -2481,7 +2481,7 @@ impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n     fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n         Self {\n             cx,\n-            maybe_typeck_tables: cx.maybe_typeck_tables(),\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n             target,\n             suggestions: BTreeMap::new(),\n         }\n@@ -2492,9 +2492,9 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n     type Map = Map<'tcx>;\n \n     fn visit_body(&mut self, body: &'tcx Body<'_>) {\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.cx.tcx.body_tables(body.id()));\n+        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body.id()));\n         walk_body(self, body);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n@@ -2503,7 +2503,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n             if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n             if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n             then {\n-                if !TyS::same_type(self.target.ty(), self.maybe_typeck_tables.unwrap().expr_ty(e)) {\n+                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n                     return;\n                 }\n \n@@ -2589,7 +2589,7 @@ impl<'tcx> LateLintPass<'tcx> for RefToMut {\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n-            if let ty::Ref(..) = cx.tables().node_type(e.hir_id).kind;\n+            if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind;\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "28b393b9f11f0b67a952af15e2909a6926e134df", "filename": "src/tools/clippy/clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -65,14 +65,14 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         fn is_trait_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            match cx.tables().expr_ty_adjusted(expr).kind {\n+            match cx.typeck_results().expr_ty_adjusted(expr).kind {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => ty.is_trait(),\n                 _ => false,\n             }\n         }\n \n         fn is_fn_def(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            matches!(cx.tables().expr_ty(expr).kind, ty::FnDef(..))\n+            matches!(cx.typeck_results().expr_ty(expr).kind, ty::FnDef(..))\n         }\n \n         if_chain! {\n@@ -98,7 +98,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n             if match_def_path(cx, def_id, &paths::PTR_EQ) ||\n                 match_def_path(cx, def_id, &paths::RC_PTR_EQ) ||\n                 match_def_path(cx, def_id, &paths::ARC_PTR_EQ);\n-            let ty_param = cx.tables().node_substs(func.hir_id).type_at(0);\n+            let ty_param = cx.typeck_results().node_substs(func.hir_id).type_at(0);\n             if ty_param.is_trait();\n             then {\n                 span_lint_and_help(\n@@ -115,8 +115,8 @@ impl LateLintPass<'_> for UnnamedAddress {\n         if_chain! {\n             if let ExprKind::Binary(binop, ref left, ref right) = expr.kind;\n             if is_comparison(binop.node);\n-            if cx.tables().expr_ty_adjusted(left).is_fn_ptr() &&\n-                cx.tables().expr_ty_adjusted(right).is_fn_ptr();\n+            if cx.typeck_results().expr_ty_adjusted(left).is_fn_ptr() &&\n+                cx.typeck_results().expr_ty_adjusted(right).is_fn_ptr();\n             if is_fn_def(cx, left) || is_fn_def(cx, right);\n             then {\n                 span_lint("}, {"sha": "59993d25bb4706b9b204729693ff0921cd0b5422", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -176,7 +176,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n         if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n-        if utils::match_type(cx, &cx.tables().expr_ty(vec), &paths::VEC);\n+        if utils::match_type(cx, &cx.typeck_results().expr_ty(vec), &paths::VEC);\n         if let closure_body = cx.tcx.hir().body(*closure_body_id);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},"}, {"sha": "f2bbde28c2abc81793b852069926c0a718e85342", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -114,7 +114,7 @@ fn collect_unwrap_info<'tcx>(\n         if_chain! {\n             if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n             if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n-            let ty = cx.tables().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, &name) || is_relevant_result_call(cx, ty, &name);\n             then {"}, {"sha": "a48ad3185e9c2f440de3f95fd5bb0b9eb40e6ae8", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -63,8 +63,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n \n             ExprKind::MethodCall(ref name, .., ref args, _) => {\n                 if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n-                    let a = cx.tables().expr_ty(e);\n-                    let b = cx.tables().expr_ty(&args[0]);\n+                    let a = cx.typeck_results().expr_ty(e);\n+                    let b = cx.typeck_results().expr_ty(&args[0]);\n                     if TyS::same_type(a, b) {\n                         let sugg = snippet_with_macro_callsite(cx, args[0].span, \"<expr>\").to_string();\n                         span_lint_and_sugg(\n@@ -79,8 +79,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     }\n                 }\n                 if match_trait_method(cx, e, &paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n-                    let a = cx.tables().expr_ty(e);\n-                    let b = cx.tables().expr_ty(&args[0]);\n+                    let a = cx.typeck_results().expr_ty(e);\n+                    let b = cx.typeck_results().expr_ty(&args[0]);\n                     if TyS::same_type(a, b) {\n                         let sugg = snippet(cx, args[0].span, \"<expr>\").into_owned();\n                         span_lint_and_sugg(\n@@ -96,8 +96,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 }\n                 if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\" {\n                     if_chain! {\n-                        let a = cx.tables().expr_ty(e);\n-                        let b = cx.tables().expr_ty(&args[0]);\n+                        let a = cx.typeck_results().expr_ty(e);\n+                        let b = cx.typeck_results().expr_ty(&args[0]);\n                         if is_type_diagnostic_item(cx, a, sym!(result_type));\n                         if let ty::Adt(_, substs) = a.kind;\n                         if let Some(a_type) = substs.types().next();\n@@ -122,8 +122,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     if args.len() == 1;\n                     if let ExprKind::Path(ref qpath) = path.kind;\n                     if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n-                    let a = cx.tables().expr_ty(e);\n-                    let b = cx.tables().expr_ty(&args[0]);\n+                    let a = cx.typeck_results().expr_ty(e);\n+                    let b = cx.typeck_results().expr_ty(&args[0]);\n \n                     then {\n                         if_chain! {"}, {"sha": "f81a132c7e7b4748d82dfab656c71170de8ec78d", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -56,7 +56,7 @@ pub fn range<'a, 'tcx>(cx: &LateContext<'tcx>, expr: &'a hir::Expr<'_>) -> Optio\n         Some(expr)\n     }\n \n-    let def_path = match cx.tables().expr_ty(expr).kind {\n+    let def_path = match cx.typeck_results().expr_ty(expr).kind {\n         ty::Adt(def, _) => cx.tcx.def_path(def.did),\n         _ => return None,\n     };"}, {"sha": "28fb6ed12a05ac90e0616be3af474a5b344b436d", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::{\n };\n use rustc_lint::LateContext;\n use rustc_middle::ich::StableHashingContextProvider;\n-use rustc_middle::ty::TypeckTables;\n+use rustc_middle::ty::TypeckResults;\n use rustc_span::Symbol;\n use std::hash::Hash;\n \n@@ -22,7 +22,7 @@ use std::hash::Hash;\n pub struct SpanlessEq<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     /// If is true, never consider as equal expressions containing function\n     /// calls.\n     ignore_fn: bool,\n@@ -32,7 +32,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n-            maybe_typeck_tables: cx.maybe_typeck_tables(),\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n             ignore_fn: false,\n         }\n     }\n@@ -71,10 +71,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             return false;\n         }\n \n-        if let Some(tables) = self.maybe_typeck_tables {\n+        if let Some(typeck_results) = self.maybe_typeck_results {\n             if let (Some(l), Some(r)) = (\n-                constant_simple(self.cx, tables, left),\n-                constant_simple(self.cx, tables, right),\n+                constant_simple(self.cx, typeck_results, left),\n+                constant_simple(self.cx, typeck_results, right),\n             ) {\n                 if l == r {\n                     return true;\n@@ -137,9 +137,9 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n                 let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n                 let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n@@ -272,18 +272,18 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         match (left, right) {\n             (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n-                let old_maybe_typeck_tables = self.maybe_typeck_tables;\n+                let old_maybe_typeck_results = self.maybe_typeck_results;\n \n-                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n-                self.maybe_typeck_tables = Some(self.cx.tcx.body_tables(ll_id.body));\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n+                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(ll_id.body));\n                 let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n \n-                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n-                self.maybe_typeck_tables = Some(self.cx.tcx.body_tables(rl_id.body));\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n+                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(rl_id.body));\n                 let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n \n                 let eq_ty = self.eq_ty(lt, rt);\n-                self.maybe_typeck_tables = old_maybe_typeck_tables;\n+                self.maybe_typeck_results = old_maybe_typeck_results;\n                 eq_ty && ll == rl\n             },\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n@@ -348,15 +348,15 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n pub struct SpanlessHash<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     s: StableHasher,\n }\n \n impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n-            maybe_typeck_tables: cx.maybe_typeck_tables(),\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n             s: StableHasher::new(),\n         }\n     }\n@@ -386,8 +386,8 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n     pub fn hash_expr(&mut self, e: &Expr<'_>) {\n         let simple_const = self\n-            .maybe_typeck_tables\n-            .and_then(|tables| constant_simple(self.cx, tables, e));\n+            .maybe_typeck_results\n+            .and_then(|typeck_results| constant_simple(self.cx, typeck_results, e));\n \n         // const hashing may result in the same hash as some unrelated node, so add a sort of\n         // discriminant depending on which path we're choosing next\n@@ -458,7 +458,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     CaptureBy::Ref => 1,\n                 }\n                 .hash(&mut self.s);\n-                // closures inherit TypeckTables\n+                // closures inherit TypeckResults\n                 self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n             ExprKind::Field(ref e, ref f) => {\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(path.ident.name);\n             },\n         }\n-        // self.maybe_typeck_tables.unwrap().qpath_res(p, id).hash(&mut self.s);\n+        // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n \n     pub fn hash_path(&mut self, p: &Path<'_>) {\n@@ -725,10 +725,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_body(&mut self, body_id: BodyId) {\n-        // swap out TypeckTables when hashing a body\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.cx.tcx.body_tables(body_id));\n+        // swap out TypeckResults when hashing a body\n+        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body_id));\n         self.hash_expr(&self.cx.tcx.hir().body(body_id).value);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn hash_generic_args(&mut self, arg_list: &[GenericArg<'_>]) {"}, {"sha": "d8fa1fa278e296b8cc9c18cbb6483a88f224d706", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n         }\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n-                println!(\"local variable of type {}\", cx.tables().node_type(local.hir_id));\n+                println!(\"local variable of type {}\", cx.typeck_results().node_type(local.hir_id));\n                 println!(\"pattern:\");\n                 print_pat(cx, &local.pat, 0);\n                 if let Some(ref e) = local.init {\n@@ -144,8 +144,12 @@ fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n-    println!(\"{}ty: {}\", ind, cx.tables().expr_ty(expr));\n-    println!(\"{}adjustments: {:?}\", ind, cx.tables().adjustments().get(expr.hir_id));\n+    println!(\"{}ty: {}\", ind, cx.typeck_results().expr_ty(expr));\n+    println!(\n+        \"{}adjustments: {:?}\",\n+        ind,\n+        cx.typeck_results().adjustments().get(expr.hir_id)\n+    );\n     match expr.kind {\n         hir::ExprKind::Box(ref e) => {\n             println!(\"{}Box\", ind);"}, {"sha": "6c2356799142db6b609fb6c2a77be4c00f8266a2", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -405,7 +405,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n-            let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+            let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n             if match_type(cx, ty, &paths::EARLY_CONTEXT)\n                 || match_type(cx, ty, &paths::LATE_CONTEXT);\n             then {\n@@ -438,7 +438,7 @@ impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n             let args = arg_lists[1];\n             if args.len() == 1;\n             let self_arg = &args[0];\n-            let self_ty = walk_ptrs_ty(cx.tables().expr_ty(self_arg));\n+            let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(self_arg));\n             if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n             then {\n                 span_lint_and_sugg("}, {"sha": "4b163fba52890a7aa341940f30d61198f732db94", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -144,7 +144,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n \n /// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n-    let def_id = cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n+    let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n     trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n }\n@@ -278,10 +278,8 @@ pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -\n     match qpath {\n         hir::QPath::Resolved(_, path) => path.res,\n         hir::QPath::TypeRelative(..) => {\n-            if cx.tcx.has_typeck_tables(id.owner.to_def_id()) {\n-                cx.tcx\n-                    .typeck_tables_of(id.owner.to_def_id().expect_local())\n-                    .qpath_res(qpath, id)\n+            if cx.tcx.has_typeck_results(id.owner.to_def_id()) {\n+                cx.tcx.typeck(id.owner.to_def_id().expect_local()).qpath_res(qpath, id)\n             } else {\n                 Res::Err\n             }\n@@ -772,7 +770,7 @@ pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool\n     let parent_item = map.get_parent_item(e.hir_id);\n     if let Some((Constant::Int(v), _)) = map\n         .maybe_body_owned_by(parent_item)\n-        .and_then(|body_id| constant(cx, cx.tcx.body_tables(body_id), e))\n+        .and_then(|body_id| constant(cx, cx.tcx.typeck_body(body_id), e))\n     {\n         value == v\n     } else {\n@@ -799,7 +797,7 @@ pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n /// See `rustc_middle::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n /// information on adjustments and coercions.\n pub fn is_adjusted(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    cx.tables().adjustments().get(e.hir_id).is_some()\n+    cx.typeck_results().adjustments().get(e.hir_id).is_some()\n }\n \n /// Returns the pre-expansion span if is this comes from an expansion of the\n@@ -916,7 +914,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n-            match &cx.tables().node_type(pat.hir_id).kind {\n+            match &cx.typeck_results().node_type(pat.hir_id).kind {\n                 ty::Slice(..) => {\n                     // [..] is the only irrefutable slice pattern.\n                     !head.is_empty() || middle.is_none() || !tail.is_empty()\n@@ -1299,7 +1297,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 None\n             }\n         },\n-        ExprKind::MethodCall(_, _, _, _) => cx.tables().type_dependent_def_id(expr.hir_id),\n+        ExprKind::MethodCall(_, _, _, _) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n         _ => None,\n     };\n \n@@ -1359,14 +1357,14 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n /// Returns the `DefId` of the callee if the given expression is a function or method call.\n pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n     match &expr.kind {\n-        ExprKind::MethodCall(..) => cx.tables().type_dependent_def_id(expr.hir_id),\n+        ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(qpath),\n                 ..\n             },\n             ..,\n-        ) => cx.tables().qpath_res(qpath, expr.hir_id).opt_def_id(),\n+        ) => cx.typeck_results().qpath_res(qpath, expr.hir_id).opt_def_id(),\n         _ => None,\n     }\n }"}, {"sha": "4a64b935ac9b4c4c4ef5ec09b9a89934e5c382e1", "filename": "src/tools/clippy/clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -18,7 +18,14 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n     };\n     let def_id = expr.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(&mut delegate, &infcx, def_id.expect_local(), cx.param_env, cx.tables()).walk_expr(expr);\n+        ExprUseVisitor::new(\n+            &mut delegate,\n+            &infcx,\n+            def_id.expect_local(),\n+            cx.param_env,\n+            cx.typeck_results(),\n+        )\n+        .walk_expr(expr);\n     });\n \n     if delegate.skip {"}, {"sha": "f2e76442a19bae5775d72f5343183bf10ac4066f", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.tables().expr_ty_adjusted(expr).kind;\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind;\n             if let ty::Slice(..) = ty.kind;\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n@@ -50,7 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n         if_chain! {\n             if let Some((_, arg, _)) = higher::for_loop(expr);\n             if let Some(vec_args) = higher::vec_macro(cx, arg);\n-            if is_copy(cx, vec_type(cx.tables().expr_ty_adjusted(arg)));\n+            if is_copy(cx, vec_type(cx.typeck_results().expr_ty_adjusted(arg)));\n             then {\n                 // report the error around the `vec!` not inside `<std macros>:`\n                 let span = arg.span\n@@ -70,7 +70,7 @@ fn check_vec_macro<'tcx>(cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx\n     let mut applicability = Applicability::MachineApplicable;\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n-            if constant(cx, cx.tables(), len).is_some() {\n+            if constant(cx, cx.typeck_results(), len).is_some() {\n                 format!(\n                     \"&[{}; {}]\",\n                     snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),"}, {"sha": "ad73a1ea1acdfeda18cc022307729c2fc16ad470", "filename": "src/tools/clippy/clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> LateLintPass<'tcx> for VecResizeToZero {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let hir::ExprKind::MethodCall(path_segment, _, ref args, _) = expr.kind;\n-            if let Some(method_def_id) = cx.tables().type_dependent_def_id(expr.hir_id);\n+            if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(..), .. }) = args[2].kind;"}, {"sha": "32574d9d6c9a821fcf0f5db89339ba81e4829908", "filename": "src/tools/clippy/clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -62,7 +62,7 @@ fn is_file_read_to_end<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) ->\n         if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_end\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n-        let ty = cx.tables().expr_ty(&exprs[0]);\n+        let ty = cx.typeck_results().expr_ty(&exprs[0]);\n         if match_type(cx, ty, &paths::FILE);\n         then {\n             return true\n@@ -76,7 +76,7 @@ fn is_file_read_to_string<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>)\n         if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_string\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n-        let ty = cx.tables().expr_ty(&exprs[0]);\n+        let ty = cx.typeck_results().expr_ty(&exprs[0]);\n         if match_type(cx, ty, &paths::FILE);\n         then {\n             return true"}, {"sha": "4b81a27632d8d03df056ef17a1a48b79b7f39bed", "filename": "src/tools/clippy/clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -36,8 +36,8 @@ impl<'tcx> LateLintPass<'tcx> for ZeroDiv {\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            if let Some(lhs_value) = constant_simple(cx, cx.tables(), left);\n-            if let Some(rhs_value) = constant_simple(cx, cx.tables(), right);\n+            if let Some(lhs_value) = constant_simple(cx, cx.typeck_results(), left);\n+            if let Some(rhs_value) = constant_simple(cx, cx.typeck_results(), right);\n             if Constant::F32(0.0) == lhs_value || Constant::F64(0.0) == lhs_value;\n             if Constant::F32(0.0) == rhs_value || Constant::F64(0.0) == rhs_value;\n             then {"}, {"sha": "9dd4c8a5f7a703b935629d733e7b1cfa0735b8e7", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -23,15 +23,15 @@ Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for ex\n - is it a primitive type?\n - does it implement a trait?\n \n-This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckTables`][TypeckTables] struct,\n+This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckResults`][TypeckResults] struct,\n that gives you access to the underlying structure [`TyS`][TyS].\n \n Example of use:\n ```rust\n impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         // Get type of `expr`\n-        let ty = cx.tables().expr_ty(expr);\n+        let ty = cx.typeck_results().expr_ty(expr);\n         // Match its kind to enter its type\n         match ty.kind {\n             ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n@@ -41,14 +41,14 @@ impl LateLintPass<'_> for MyStructLint {\n }\n ```\n \n-Similarly in [`TypeckTables`][TypeckTables] methods, you have the [`pat_ty()`][pat_ty] method\n+Similarly in [`TypeckResults`][TypeckResults] methods, you have the [`pat_ty()`][pat_ty] method\n to retrieve a type from a pattern.\n \n Two noticeable items here:\n - `cx` is the lint context [`LateContext`][LateContext].\n   The two most useful data structures in this context are `tcx` and `tables`,\n   allowing us to jump to type definitions and other compilation stages such as HIR.\n-- `tables` is [`TypeckTables`][TypeckTables] and is created by type checking step,\n+- `tables` is [`TypeckResults`][TypeckResults] and is created by type checking step,\n   it includes useful information such as types of expressions, ways to resolve methods and so on.\n \n # Checking if an expr is calling a specific method\n@@ -87,7 +87,7 @@ impl LateLintPass<'_> for MyStructLint {\n         }\n \n         // 2. Using type context `TyCtxt`\n-        let ty = cx.tables().expr_ty(expr);\n+        let ty = cx.typeck_results().expr_ty(expr);\n         if cx.tcx.lang_items()\n             // we are looking for the `DefId` of `Drop` trait in lang items\n             .drop_trait()\n@@ -192,9 +192,9 @@ assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n \n [TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html\n [TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n-[TypeckTables]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckTables.html\n-[expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckTables.html#method.expr_ty\n+[TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n+[expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty\n [LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n [TyCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html\n-[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckTables.html#method.pat_ty\n+[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n [paths]: ../clippy_lints/src/utils/paths.rs"}]}