{"sha": "e02ddff816f7d599f9a4b884fca25c1380d1aae6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMmRkZmY4MTZmN2Q1OTlmOWE0Yjg4NGZjYTI1YzEzODBkMWFhZTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-05T16:31:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-06T13:51:58Z"}, "message": "strip out the hair trait and use concrete types instead", "tree": {"sha": "1f061281c1c64bf479ca5c436902f49d039f3ccd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f061281c1c64bf479ca5c436902f49d039f3ccd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e02ddff816f7d599f9a4b884fca25c1380d1aae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e02ddff816f7d599f9a4b884fca25c1380d1aae6", "html_url": "https://github.com/rust-lang/rust/commit/e02ddff816f7d599f9a4b884fca25c1380d1aae6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e02ddff816f7d599f9a4b884fca25c1380d1aae6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f60768e840fd186ccd7812e95dd6e46a54bc432", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f60768e840fd186ccd7812e95dd6e46a54bc432", "html_url": "https://github.com/rust-lang/rust/commit/2f60768e840fd186ccd7812e95dd6e46a54bc432"}], "stats": {"total": 1294, "additions": 621, "deletions": 673}, "files": [{"sha": "21a77bbd232af528510bc35141ef5f00cc475ac8", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use build::{BlockAnd, Builder};\n use hair::*;\n use repr::*;\n-use build::{BlockAnd, Builder};\n+use rustc_front::hir;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn ast_block(&mut self,\n-                     destination: &Lvalue<H>,\n+                     destination: &Lvalue<'tcx>,\n                      mut block: BasicBlock,\n-                     ast_block: H::Block)\n+                     ast_block: &'tcx hir::Block)\n                      -> BlockAnd<()> {\n         let this = self;\n         let Block { extent, span: _, stmts, expr } = this.hir.mirror(ast_block);"}, {"sha": "09166a76f70e2961d6524c9fc570da68f7151415", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -14,15 +14,15 @@\n //! Routines for manipulating the control-flow graph.\n \n use build::CFG;\n-use hair::*;\n use repr::*;\n+use syntax::codemap::Span;\n \n-impl<H:Hair> CFG<H> {\n-    pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<H> {\n+impl<'tcx> CFG<'tcx> {\n+    pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n         &self.basic_blocks[blk.index()]\n     }\n \n-    pub fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<H> {\n+    pub fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n         &mut self.basic_blocks[blk.index()]\n     }\n \n@@ -39,21 +39,21 @@ impl<H:Hair> CFG<H> {\n         BasicBlock::new(node_index)\n     }\n \n-    pub fn push(&mut self, block: BasicBlock, statement: Statement<H>) {\n+    pub fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n         debug!(\"push({:?}, {:?})\", block, statement);\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n     pub fn push_assign_constant(&mut self,\n                                 block: BasicBlock,\n-                                span: H::Span,\n-                                temp: &Lvalue<H>,\n-                                constant: Constant<H>) {\n+                                span: Span,\n+                                temp: &Lvalue<'tcx>,\n+                                constant: Constant<'tcx>) {\n         self.push_assign(block, span, temp, Rvalue::Use(Operand::Constant(constant)));\n     }\n \n-    pub fn push_drop(&mut self, block: BasicBlock, span: H::Span,\n-                     kind: DropKind, lvalue: &Lvalue<H>) {\n+    pub fn push_drop(&mut self, block: BasicBlock, span: Span,\n+                     kind: DropKind, lvalue: &Lvalue<'tcx>) {\n         self.push(block, Statement {\n             span: span,\n             kind: StatementKind::Drop(kind, lvalue.clone())\n@@ -62,9 +62,9 @@ impl<H:Hair> CFG<H> {\n \n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n-                       span: H::Span,\n-                       lvalue: &Lvalue<H>,\n-                       rvalue: Rvalue<H>) {\n+                       span: Span,\n+                       lvalue: &Lvalue<'tcx>,\n+                       rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n             span: span,\n             kind: StatementKind::Assign(lvalue.clone(), rvalue)\n@@ -73,7 +73,7 @@ impl<H:Hair> CFG<H> {\n \n     pub fn terminate(&mut self,\n                      block: BasicBlock,\n-                     terminator: Terminator<H>) {\n+                     terminator: Terminator<'tcx>) {\n         // Check whether this block has already been terminated. For\n         // this, we rely on the fact that the initial state is to have\n         // a Diverge terminator and an empty list of targets (which"}, {"sha": "d6de68b18d8027dfcbb97c9e097406d8a1e511c3", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -14,17 +14,17 @@ use build::{Builder};\n use hair::*;\n use repr::*;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n-    pub fn as_constant<M>(&mut self, expr: M) -> Constant<H>\n-        where M: Mirror<H, Output=Expr<H>>\n+    pub fn as_constant<M>(&mut self, expr: M) -> Constant<'tcx>\n+        where M: Mirror<'tcx, Output=Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n         self.expr_as_constant(expr)\n     }\n \n-    fn expr_as_constant(&mut self, expr: Expr<H>) -> Constant<H> {\n+    fn expr_as_constant(&mut self, expr: Expr<'tcx>) -> Constant<'tcx> {\n         let this = self;\n         let Expr { ty, temp_lifetime: _, span, kind } = expr;\n         match kind {"}, {"sha": "c14c8649e306a80e9ffce80ab5f8c32732797312", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -15,22 +15,22 @@ use build::expr::category::Category;\n use hair::*;\n use repr::*;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr`, yielding an lvalue that we can move from etc.\n     pub fn as_lvalue<M>(&mut self,\n                         block: BasicBlock,\n                         expr: M)\n-                        -> BlockAnd<Lvalue<H>>\n-        where M: Mirror<H, Output=Expr<H>>\n+                        -> BlockAnd<Lvalue<'tcx>>\n+        where M: Mirror<'tcx, Output=Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n         self.expr_as_lvalue(block, expr)\n     }\n \n     fn expr_as_lvalue(&mut self,\n                       mut block: BasicBlock,\n-                      expr: Expr<H>)\n-                      -> BlockAnd<Lvalue<H>>\n+                      expr: Expr<'tcx>)\n+                      -> BlockAnd<Lvalue<'tcx>>\n     {\n         debug!(\"expr_as_lvalue(block={:?}, expr={:?})\",\n                block, expr);"}, {"sha": "7fcbf4f51441d97f2705831e6616cbc36625bcc7", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -15,25 +15,25 @@ use build::expr::category::Category;\n use hair::*;\n use repr::*;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr` into a value that can be used as an operand.\n     /// If `expr` is an lvalue like `x`, this will introduce a\n     /// temporary `tmp = x`, so that we capture the value of `x` at\n     /// this time.\n     pub fn as_operand<M>(&mut self,\n                          block: BasicBlock,\n                          expr: M)\n-                         -> BlockAnd<Operand<H>>\n-        where M: Mirror<H, Output=Expr<H>>\n+                         -> BlockAnd<Operand<'tcx>>\n+        where M: Mirror<'tcx, Output=Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n         self.expr_as_operand(block, expr)\n     }\n \n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n-                       expr: Expr<H>)\n-                       -> BlockAnd<Operand<H>>\n+                       expr: Expr<'tcx>)\n+                       -> BlockAnd<Operand<'tcx>>\n     {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\",\n                block, expr);"}, {"sha": "be29964f3b0c678e26d67db3643888f511de932a", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -17,22 +17,22 @@ use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use repr::*;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr`, yielding an rvalue.\n     pub fn as_rvalue<M>(&mut self,\n                         block: BasicBlock,\n                         expr: M)\n-                        -> BlockAnd<Rvalue<H>>\n-        where M: Mirror<H, Output=Expr<H>>\n+                        -> BlockAnd<Rvalue<'tcx>>\n+        where M: Mirror<'tcx, Output=Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n         self.expr_as_rvalue(block, expr)\n     }\n \n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n-                      expr: Expr<H>)\n-                      -> BlockAnd<Rvalue<H>>\n+                      expr: Expr<'tcx>)\n+                      -> BlockAnd<Rvalue<'tcx>>\n     {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\",\n                block, expr);"}, {"sha": "6f2814de8d6abc11151fe1ceb4411ce6c1b1dfd1", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -15,23 +15,23 @@ use build::expr::category::Category;\n use hair::*;\n use repr::*;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n     pub fn as_temp<M>(&mut self,\n                       block: BasicBlock,\n                       expr: M)\n-                      -> BlockAnd<Lvalue<H>>\n-        where M: Mirror<H, Output=Expr<H>>\n+                      -> BlockAnd<Lvalue<'tcx>>\n+        where M: Mirror<'tcx, Output=Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n         self.expr_as_temp(block, expr)\n     }\n \n     fn expr_as_temp(&mut self,\n                     mut block: BasicBlock,\n-                    expr: Expr<H>)\n-                    -> BlockAnd<Lvalue<H>>\n+                    expr: Expr<'tcx>)\n+                    -> BlockAnd<Lvalue<'tcx>>\n     {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\",\n                block, expr);"}, {"sha": "658b7779b44a947f1bf8b7be40a983bcc14cff6f", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -41,7 +41,7 @@ pub enum RvalueFunc {\n /// Determines the category for a given expression. Note that scope\n /// and paren expressions have no category.\n impl Category {\n-    pub fn of<H:Hair>(ek: &ExprKind<H>) -> Option<Category> {\n+    pub fn of<'tcx>(ek: &ExprKind<'tcx>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,\n "}, {"sha": "a2365c8beadac89c3b60f7efcfd027a5045a28ed", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -15,14 +15,16 @@ use build::expr::category::{Category, RvalueFunc};\n use build::scope::LoopScope;\n use hair::*;\n use repr::*;\n+use rustc::middle::region::CodeExtent;\n+use syntax::codemap::Span;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n     pub fn into_expr(&mut self,\n-                     destination: &Lvalue<H>,\n+                     destination: &Lvalue<'tcx>,\n                      mut block: BasicBlock,\n-                     expr: Expr<H>)\n+                     expr: Expr<'tcx>)\n                      -> BlockAnd<()>\n     {\n         debug!(\"into_expr(destination={:?}, block={:?}, expr={:?})\",\n@@ -266,12 +268,12 @@ impl<H:Hair> Builder<H> {\n     }\n \n     fn break_or_continue<F>(&mut self,\n-                            span: H::Span,\n-                            label: Option<H::CodeExtent>,\n+                            span: Span,\n+                            label: Option<CodeExtent>,\n                             block: BasicBlock,\n                             exit_selector: F)\n                             -> BlockAnd<()>\n-        where F: FnOnce(&LoopScope<H>) -> BasicBlock\n+        where F: FnOnce(&LoopScope) -> BasicBlock\n     {\n         let loop_scope = self.find_loop_scope(span, label);\n         let exit_block = exit_selector(&loop_scope);"}, {"sha": "ac8aae9ed0a4978f010c66e760558697b4c8ad36", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -18,50 +18,50 @@ use build::{BlockAnd, Builder};\n use hair::*;\n use repr::*;\n \n-pub trait EvalInto<H:Hair> {\n-    fn eval_into(self, builder: &mut Builder<H>, destination: &Lvalue<H>,\n-                 block: BasicBlock) -> BlockAnd<()>;\n+pub trait EvalInto<'tcx> {\n+    fn eval_into<'a>(self, builder: &mut Builder<'a,'tcx>, destination: &Lvalue<'tcx>,\n+                     block: BasicBlock) -> BlockAnd<()>;\n }\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn into<E>(&mut self,\n-                   destination: &Lvalue<H>,\n+                   destination: &Lvalue<'tcx>,\n                    block: BasicBlock,\n                    expr: E)\n                    -> BlockAnd<()>\n-        where E: EvalInto<H>\n+        where E: EvalInto<'tcx>\n     {\n         expr.eval_into(self, destination, block)\n     }\n }\n \n-impl<H:Hair> EvalInto<H> for ExprRef<H> {\n-    fn eval_into(self,\n-                 builder: &mut Builder<H>,\n-                 destination: &Lvalue<H>,\n-                 block: BasicBlock)\n-                 -> BlockAnd<()> {\n+impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n+    fn eval_into<'a>(self,\n+                     builder: &mut Builder<'a,'tcx>,\n+                     destination: &Lvalue<'tcx>,\n+                     block: BasicBlock)\n+                     -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n         builder.into_expr(destination, block, expr)\n     }\n }\n \n-impl<H:Hair> EvalInto<H> for Expr<H> {\n-    fn eval_into(self,\n-                 builder: &mut Builder<H>,\n-                 destination: &Lvalue<H>,\n-                 block: BasicBlock)\n-                 -> BlockAnd<()> {\n+impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n+    fn eval_into<'a>(self,\n+                     builder: &mut Builder<'a,'tcx>,\n+                     destination: &Lvalue<'tcx>,\n+                     block: BasicBlock)\n+                     -> BlockAnd<()> {\n         builder.into_expr(destination, block, self)\n     }\n }\n \n-impl<H:Hair> EvalInto<H> for Option<ExprRef<H>> {\n-    fn eval_into(self,\n-                 builder: &mut Builder<H>,\n-                 destination: &Lvalue<H>,\n-                 block: BasicBlock)\n-                 -> BlockAnd<()> {\n+impl<'tcx> EvalInto<'tcx> for Option<ExprRef<'tcx>> {\n+    fn eval_into<'a>(self,\n+                     builder: &mut Builder<'a,'tcx>,\n+                     destination: &Lvalue<'tcx>,\n+                     block: BasicBlock)\n+                     -> BlockAnd<()> {\n         match self {\n             Some(expr) => builder.into(destination, block, expr),\n             None => block.unit()"}, {"sha": "ad6a218b07c5ea13c3d95ab05a254a1fd16d161d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -15,20 +15,24 @@\n \n use build::{BlockAnd, Builder};\n use repr::*;\n+use rustc::middle::region::CodeExtent;\n+use rustc::middle::ty::{AdtDef, Ty};\n use hair::*;\n+use syntax::ast::{Name, NodeId};\n+use syntax::codemap::Span;\n \n // helper functions, broken out by category:\n mod simplify;\n mod test;\n mod util;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn match_expr(&mut self,\n-                      destination: &Lvalue<H>,\n-                      span: H::Span,\n+                      destination: &Lvalue<'tcx>,\n+                      span: Span,\n                       mut block: BasicBlock,\n-                      discriminant: ExprRef<H>,\n-                      arms: Vec<Arm<H>>)\n+                      discriminant: ExprRef<'tcx>,\n+                      arms: Vec<Arm<'tcx>>)\n                       -> BlockAnd<()>\n     {\n         let discriminant_lvalue =\n@@ -49,7 +53,7 @@ impl<H:Hair> Builder<H> {\n                         .collect(),\n         };\n \n-        let arm_bodies: Vec<ExprRef<H>> =\n+        let arm_bodies: Vec<ExprRef<'tcx>> =\n             arms.iter()\n                 .map(|arm| arm.body.clone())\n                 .collect();\n@@ -60,7 +64,7 @@ impl<H:Hair> Builder<H> {\n         // highest priority candidate comes last in the list. This the\n         // reverse of the order in which candidates are written in the\n         // source.\n-        let candidates: Vec<Candidate<H>> =\n+        let candidates: Vec<Candidate<'tcx>> =\n             arms.iter()\n                 .enumerate()\n                 .rev() // highest priority comes last\n@@ -97,9 +101,9 @@ impl<H:Hair> Builder<H> {\n \n     pub fn expr_into_pattern(&mut self,\n                              mut block: BasicBlock,\n-                             var_extent: H::CodeExtent,          // lifetime of vars\n-                             irrefutable_pat: PatternRef<H>,\n-                             initializer: ExprRef<H>)\n+                             var_extent: CodeExtent,          // lifetime of vars\n+                             irrefutable_pat: PatternRef<'tcx>,\n+                             initializer: ExprRef<'tcx>)\n                              -> BlockAnd<()>\n     {\n         // optimize the case of `let x = ...`\n@@ -125,16 +129,16 @@ impl<H:Hair> Builder<H> {\n \n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n-                               var_extent: H::CodeExtent,\n-                               irrefutable_pat: PatternRef<H>,\n-                               initializer: &Lvalue<H>)\n+                               var_extent: CodeExtent,\n+                               irrefutable_pat: PatternRef<'tcx>,\n+                               initializer: &Lvalue<'tcx>)\n                                -> BlockAnd<()>\n     {\n         // first, creating the bindings\n         self.declare_bindings(var_extent, irrefutable_pat.clone());\n \n         // create a dummy candidate\n-        let mut candidate = Candidate::<H> {\n+        let mut candidate = Candidate::<'tcx> {\n             match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat.clone())],\n             bindings: vec![],\n             guard: None,\n@@ -159,8 +163,8 @@ impl<H:Hair> Builder<H> {\n     }\n \n     pub fn declare_bindings(&mut self,\n-                            var_extent: H::CodeExtent,\n-                            pattern: PatternRef<H>)\n+                            var_extent: CodeExtent,\n+                            pattern: PatternRef<'tcx>)\n     {\n         let pattern = self.hir.mirror(pattern);\n         match pattern.kind {\n@@ -198,69 +202,69 @@ struct ArmBlocks {\n }\n \n #[derive(Clone, Debug)]\n-struct Candidate<H:Hair> {\n+struct Candidate<'tcx> {\n     // all of these must be satisfied...\n-    match_pairs: Vec<MatchPair<H>>,\n+    match_pairs: Vec<MatchPair<'tcx>>,\n \n     // ...these bindings established...\n-    bindings: Vec<Binding<H>>,\n+    bindings: Vec<Binding<'tcx>>,\n \n     // ...and the guard must be evaluated...\n-    guard: Option<ExprRef<H>>,\n+    guard: Option<ExprRef<'tcx>>,\n \n     // ...and then we branch to arm with this index.\n     arm_index: usize,\n }\n \n #[derive(Clone, Debug)]\n-struct Binding<H:Hair> {\n-    span: H::Span,\n-    source: Lvalue<H>,\n-    name: H::Name,\n-    var_id: H::VarId,\n-    var_ty: H::Ty,\n+struct Binding<'tcx> {\n+    span: Span,\n+    source: Lvalue<'tcx>,\n+    name: Name,\n+    var_id: NodeId,\n+    var_ty: Ty<'tcx>,\n     mutability: Mutability,\n-    binding_mode: BindingMode<H>,\n+    binding_mode: BindingMode,\n }\n \n #[derive(Clone, Debug)]\n-struct MatchPair<H:Hair> {\n+struct MatchPair<'tcx> {\n     // this lvalue...\n-    lvalue: Lvalue<H>,\n+    lvalue: Lvalue<'tcx>,\n \n     // ... must match this pattern.\n-    pattern: Pattern<H>,\n+    pattern: Pattern<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-enum TestKind<H:Hair> {\n+enum TestKind<'tcx> {\n     // test the branches of enum\n-    Switch { adt_def: H::AdtDef },\n+    Switch { adt_def: AdtDef<'tcx> },\n \n     // test for equality\n-    Eq { value: Literal<H>, ty: H::Ty },\n+    Eq { value: Literal<'tcx>, ty: Ty<'tcx> },\n \n     // test whether the value falls within an inclusive range\n-    Range { lo: Literal<H>, hi: Literal<H>, ty: H::Ty },\n+    Range { lo: Literal<'tcx>, hi: Literal<'tcx>, ty: Ty<'tcx> },\n \n     // test length of the slice is equal to len\n     Len { len: usize, op: BinOp },\n }\n \n #[derive(Debug)]\n-struct Test<H:Hair> {\n-    span: H::Span,\n-    kind: TestKind<H>,\n+struct Test<'tcx> {\n+    span: Span,\n+    kind: TestKind<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Main matching algorithm\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     fn match_candidates(&mut self,\n-                        span: H::Span,\n+                        span: Span,\n                         arm_blocks: &mut ArmBlocks,\n-                        mut candidates: Vec<Candidate<H>>,\n+                        mut candidates: Vec<Candidate<'tcx>>,\n                         mut block: BasicBlock)\n     {\n         debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n@@ -306,7 +310,7 @@ impl<H:Hair> Builder<H> {\n         let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n \n         for (outcome, mut target_block) in target_blocks.into_iter().enumerate() {\n-            let applicable_candidates: Vec<Candidate<H>> =\n+            let applicable_candidates: Vec<Candidate<'tcx>> =\n                 candidates.iter()\n                           .filter_map(|candidate| {\n                               unpack!(target_block =\n@@ -336,7 +340,7 @@ impl<H:Hair> Builder<H> {\n     fn bind_and_guard_matched_candidate(&mut self,\n                                         mut block: BasicBlock,\n                                         arm_blocks: &mut ArmBlocks,\n-                                        candidate: Candidate<H>)\n+                                        candidate: Candidate<'tcx>)\n                                         -> Option<BasicBlock> {\n         debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n                block, candidate);\n@@ -363,7 +367,7 @@ impl<H:Hair> Builder<H> {\n \n     fn bind_matched_candidate(&mut self,\n                               block: BasicBlock,\n-                              bindings: Vec<Binding<H>>) {\n+                              bindings: Vec<Binding<'tcx>>) {\n         debug!(\"bind_matched_candidate(block={:?}, bindings={:?})\",\n                block, bindings);\n \n@@ -386,19 +390,19 @@ impl<H:Hair> Builder<H> {\n     }\n \n     fn declare_binding(&mut self,\n-                       var_extent: H::CodeExtent,\n+                       var_extent: CodeExtent,\n                        mutability: Mutability,\n-                       name: H::Name,\n-                       var_id: H::VarId,\n-                       var_ty: H::Ty,\n-                       span: H::Span)\n+                       name: Name,\n+                       var_id: NodeId,\n+                       var_ty: Ty<'tcx>,\n+                       span: Span)\n                        -> u32\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, var_extent={:?}, span={:?})\",\n                var_id, name, var_ty, var_extent, span);\n \n         let index = self.var_decls.len();\n-        self.var_decls.push(VarDecl::<H> {\n+        self.var_decls.push(VarDecl::<'tcx> {\n             mutability: mutability,\n             name: name,\n             ty: var_ty.clone(),"}, {"sha": "9114463d61d2deef86f1ab016be0aaf6ebd92478", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -29,10 +29,10 @@ use repr::*;\n \n use std::mem;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn simplify_candidate(&mut self,\n                               mut block: BasicBlock,\n-                              candidate: &mut Candidate<H>)\n+                              candidate: &mut Candidate<'tcx>)\n                               -> BlockAnd<()>\n     {\n         // repeatedly simplify match pairs until fixed point is reached\n@@ -60,9 +60,9 @@ impl<H:Hair> Builder<H> {\n     /// returned), no changes are made to candidate.\n     fn simplify_match_pair(&mut self,\n                            mut block: BasicBlock,\n-                           match_pair: MatchPair<H>,\n-                           candidate: &mut Candidate<H>)\n-                           -> Result<BasicBlock, MatchPair<H>> // returns Err() if cannot simplify\n+                           match_pair: MatchPair<'tcx>,\n+                           candidate: &mut Candidate<'tcx>)\n+                           -> Result<BasicBlock, MatchPair<'tcx>> // returns Err() if cannot simplify\n     {\n         match match_pair.pattern.kind {\n             PatternKind::Wild(..) => {"}, {"sha": "a7ef97e12a0919c0f81291e39377df6ba6556567", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -19,12 +19,13 @@ use build::{BlockAnd, Builder};\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use repr::*;\n+use syntax::codemap::Span;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n     /// It is a bug to call this with a simplifyable pattern.\n-    pub fn test(&mut self, match_pair: &MatchPair<H>) -> Test<H> {\n+    pub fn test(&mut self, match_pair: &MatchPair<'tcx>) -> Test<'tcx> {\n         match match_pair.pattern.kind {\n             PatternKind::Variant { ref adt_def, variant_index: _, subpatterns: _ } => {\n                 Test {\n@@ -72,8 +73,8 @@ impl<H:Hair> Builder<H> {\n     /// Generates the code to perform a test.\n     pub fn perform_test(&mut self,\n                         block: BasicBlock,\n-                        lvalue: &Lvalue<H>,\n-                        test: &Test<H>)\n+                        lvalue: &Lvalue<'tcx>,\n+                        test: &Test<'tcx>)\n                         -> Vec<BasicBlock> {\n         match test.kind.clone() {\n             TestKind::Switch { adt_def } => {\n@@ -149,10 +150,10 @@ impl<H:Hair> Builder<H> {\n \n     fn call_comparison_fn(&mut self,\n                           block: BasicBlock,\n-                          span: H::Span,\n-                          item_ref: ItemRef<H>,\n-                          lvalue1: Lvalue<H>,\n-                          lvalue2: Lvalue<H>)\n+                          span: Span,\n+                          item_ref: ItemRef<'tcx>,\n+                          lvalue1: Lvalue<'tcx>,\n+                          lvalue2: Lvalue<'tcx>)\n                           -> Vec<BasicBlock> {\n         let target_blocks = vec![self.cfg.start_new_block(),\n                                  self.cfg.start_new_block()];\n@@ -194,11 +195,11 @@ impl<H:Hair> Builder<H> {\n     /// @ 22])`.\n     pub fn candidate_under_assumption(&mut self,\n                                       mut block: BasicBlock,\n-                                      test_lvalue: &Lvalue<H>,\n-                                      test_kind: &TestKind<H>,\n+                                      test_lvalue: &Lvalue<'tcx>,\n+                                      test_kind: &TestKind<'tcx>,\n                                       test_outcome: usize,\n-                                      candidate: &Candidate<H>)\n-                                      -> BlockAnd<Option<Candidate<H>>> {\n+                                      candidate: &Candidate<'tcx>)\n+                                      -> BlockAnd<Option<Candidate<'tcx>>> {\n         let candidate = candidate.clone();\n         let match_pairs = candidate.match_pairs;\n         let result = unpack!(block = self.match_pairs_under_assumption(block,\n@@ -216,11 +217,11 @@ impl<H:Hair> Builder<H> {\n     /// work of transforming the list of match pairs.\n     fn match_pairs_under_assumption(&mut self,\n                                     mut block: BasicBlock,\n-                                    test_lvalue: &Lvalue<H>,\n-                                    test_kind: &TestKind<H>,\n+                                    test_lvalue: &Lvalue<'tcx>,\n+                                    test_kind: &TestKind<'tcx>,\n                                     test_outcome: usize,\n-                                    match_pairs: Vec<MatchPair<H>>)\n-                                    -> BlockAnd<Option<Vec<MatchPair<H>>>> {\n+                                    match_pairs: Vec<MatchPair<'tcx>>)\n+                                    -> BlockAnd<Option<Vec<MatchPair<'tcx>>>> {\n         let mut result = vec![];\n \n         for match_pair in match_pairs {\n@@ -279,9 +280,9 @@ impl<H:Hair> Builder<H> {\n     /// It is a bug to call this with a simplifyable pattern.\n     pub fn consequent_match_pairs_under_assumption(&mut self,\n                                                    mut block: BasicBlock,\n-                                                   match_pair: MatchPair<H>,\n+                                                   match_pair: MatchPair<'tcx>,\n                                                    test_outcome: usize)\n-                                                   -> BlockAnd<Option<Vec<MatchPair<H>>>> {\n+                                                   -> BlockAnd<Option<Vec<MatchPair<'tcx>>>> {\n         match match_pair.pattern.kind {\n             PatternKind::Variant { adt_def, variant_index, subpatterns } => {\n                 if test_outcome != variant_index {\n@@ -339,7 +340,7 @@ impl<H:Hair> Builder<H> {\n         }\n     }\n \n-    fn error_simplifyable(&mut self, match_pair: &MatchPair<H>) -> ! {\n+    fn error_simplifyable(&mut self, match_pair: &MatchPair<'tcx>) -> ! {\n         self.hir.span_bug(\n             match_pair.pattern.span,\n             &format!(\"simplifyable pattern found: {:?}\", match_pair.pattern))"}, {"sha": "d6cc1d088f9e32a0e52b37bf895baee780414365", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -14,11 +14,11 @@ use hair::*;\n use repr::*;\n use std::u32;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn field_match_pairs(&mut self,\n-                             lvalue: Lvalue<H>,\n-                             subpatterns: Vec<FieldPatternRef<H>>)\n-                             -> Vec<MatchPair<H>> {\n+                             lvalue: Lvalue<'tcx>,\n+                             subpatterns: Vec<FieldPatternRef<'tcx>>)\n+                             -> Vec<MatchPair<'tcx>> {\n         subpatterns.into_iter()\n                    .map(|fieldpat| {\n                        let lvalue = lvalue.clone().field(fieldpat.field);\n@@ -27,7 +27,7 @@ impl<H:Hair> Builder<H> {\n                    .collect()\n     }\n \n-    pub fn match_pair(&mut self, lvalue: Lvalue<H>, pattern: PatternRef<H>) -> MatchPair<H> {\n+    pub fn match_pair(&mut self, lvalue: Lvalue<'tcx>, pattern: PatternRef<'tcx>) -> MatchPair<'tcx> {\n         let pattern = self.hir.mirror(pattern);\n         MatchPair::new(lvalue, pattern)\n     }\n@@ -47,12 +47,12 @@ impl<H:Hair> Builder<H> {\n     ///\n     /// and creates a match pair `tmp0 @ s`\n     pub fn prefix_suffix_slice(&mut self,\n-                               match_pairs: &mut Vec<MatchPair<H>>,\n+                               match_pairs: &mut Vec<MatchPair<'tcx>>,\n                                block: BasicBlock,\n-                               lvalue: Lvalue<H>,\n-                               prefix: Vec<PatternRef<H>>,\n-                               opt_slice: Option<PatternRef<H>>,\n-                               suffix: Vec<PatternRef<H>>)\n+                               lvalue: Lvalue<'tcx>,\n+                               prefix: Vec<PatternRef<'tcx>>,\n+                               opt_slice: Option<PatternRef<'tcx>>,\n+                               suffix: Vec<PatternRef<'tcx>>)\n                                -> BlockAnd<()>\n     {\n         // If there is a `..P` pattern, create a temporary `t0` for\n@@ -76,10 +76,10 @@ impl<H:Hair> Builder<H> {\n \n     /// Helper for `prefix_suffix_slice` which just processes the prefix and suffix.\n     fn prefix_suffix(&mut self,\n-                     match_pairs: &mut Vec<MatchPair<H>>,\n-                     lvalue: Lvalue<H>,\n-                     prefix: Vec<PatternRef<H>>,\n-                     suffix: Vec<PatternRef<H>>)\n+                     match_pairs: &mut Vec<MatchPair<'tcx>>,\n+                     lvalue: Lvalue<'tcx>,\n+                     prefix: Vec<PatternRef<'tcx>>,\n+                     suffix: Vec<PatternRef<'tcx>>)\n     {\n         let min_length = prefix.len() + suffix.len();\n         assert!(min_length < u32::MAX as usize);\n@@ -118,8 +118,8 @@ impl<H:Hair> Builder<H> {\n     }\n }\n \n-impl<H:Hair> MatchPair<H> {\n-    pub fn new(lvalue: Lvalue<H>, pattern: Pattern<H>) -> MatchPair<H> {\n+impl<'tcx> MatchPair<'tcx> {\n+    pub fn new(lvalue: Lvalue<'tcx>, pattern: Pattern<'tcx>) -> MatchPair<'tcx> {\n         MatchPair { lvalue: lvalue, pattern: pattern }\n     }\n }"}, {"sha": "8ebe0bc7154d2af333d2ee80de748e4c7cc99c5d", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -14,16 +14,17 @@\n use build::Builder;\n use hair::*;\n use repr::*;\n-\n+use rustc::middle::ty::Ty;\n use std::u32;\n+use syntax::codemap::Span;\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Add a new temporary value of type `ty` storing the result of\n     /// evaluating `expr`.\n     ///\n     /// NB: **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n-    pub fn temp(&mut self, ty: H::Ty) -> Lvalue<H> {\n+    pub fn temp(&mut self, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n         let index = self.temp_decls.len();\n         self.temp_decls.push(TempDecl { ty: ty });\n         assert!(index < (u32::MAX) as usize);\n@@ -35,10 +36,10 @@ impl<H:Hair> Builder<H> {\n \n     pub fn push_literal(&mut self,\n                         block: BasicBlock,\n-                        span: H::Span,\n-                        ty: H::Ty,\n-                        literal: Literal<H>)\n-                        -> Lvalue<H> {\n+                        span: Span,\n+                        ty: Ty<'tcx>,\n+                        literal: Literal<'tcx>)\n+                        -> Lvalue<'tcx> {\n         let temp = self.temp(ty.clone());\n         let constant = Constant { span: span, ty: ty, literal: literal };\n         self.cfg.push_assign_constant(block, span, &temp, constant);\n@@ -47,9 +48,9 @@ impl<H:Hair> Builder<H> {\n \n     pub fn push_usize(&mut self,\n                       block: BasicBlock,\n-                      span: H::Span,\n+                      span: Span,\n                       value: usize)\n-                      -> Lvalue<H> {\n+                      -> Lvalue<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n         let temp = self.temp(usize_ty);\n         self.cfg.push_assign_constant(\n@@ -64,9 +65,9 @@ impl<H:Hair> Builder<H> {\n \n     pub fn push_item_ref(&mut self,\n                          block: BasicBlock,\n-                         span: H::Span,\n-                         item_ref: ItemRef<H>)\n-                         -> Lvalue<H> {\n+                         span: Span,\n+                         item_ref: ItemRef<'tcx>)\n+                         -> Lvalue<'tcx> {\n         let literal = Literal::Item { def_id: item_ref.def_id, substs: item_ref.substs };\n         self.push_literal(block, span, item_ref.ty, literal)\n     }"}, {"sha": "cf4dc9227c43e1a899b459e42982cb0692a2a82e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -8,24 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hair::{self, Hair};\n+use hair;\n+use rustc::middle::region::CodeExtent;\n+use rustc::middle::ty::Ty;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_front::hir;\n use repr::*;\n-\n-struct Builder<H:Hair> {\n-    hir: H,\n-    extents: FnvHashMap<H::CodeExtent, Vec<GraphExtent>>,\n-    cfg: CFG<H>,\n-    scopes: Vec<scope::Scope<H>>,\n-    loop_scopes: Vec<scope::LoopScope<H>>,\n-    unit_temp: Lvalue<H>,\n-    var_decls: Vec<VarDecl<H>>,\n-    var_indices: FnvHashMap<H::VarId, u32>,\n-    temp_decls: Vec<TempDecl<H>>,\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use tcx::{Cx, PatNode};\n+\n+struct Builder<'a,'tcx:'a> {\n+    hir: Cx<'a, 'tcx>,\n+    extents: FnvHashMap<CodeExtent, Vec<GraphExtent>>,\n+    cfg: CFG<'tcx>,\n+    scopes: Vec<scope::Scope<'tcx>>,\n+    loop_scopes: Vec<scope::LoopScope>,\n+    unit_temp: Lvalue<'tcx>,\n+    var_decls: Vec<VarDecl<'tcx>>,\n+    var_indices: FnvHashMap<ast::NodeId, u32>,\n+    temp_decls: Vec<TempDecl<'tcx>>,\n }\n \n-struct CFG<H:Hair> {\n-    basic_blocks: Vec<BasicBlockData<H>>\n+struct CFG<'tcx> {\n+    basic_blocks: Vec<BasicBlockData<'tcx>>\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -69,18 +75,18 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n // construct() -- the main entry point for building MIR for a function\n \n-pub fn construct<H:Hair>(mut hir: H,\n-                        _span: H::Span,\n-                        implicit_arguments: Vec<H::Ty>,\n-                        explicit_arguments: Vec<(H::Ty, H::Pattern)>,\n-                        argument_extent: H::CodeExtent,\n-                        ast_block: H::Block)\n-                        -> Mir<H> {\n+pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n+                          _span: Span,\n+                          implicit_arguments: Vec<Ty<'tcx>>,\n+                          explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n+                          argument_extent: CodeExtent,\n+                          ast_block: &'tcx hir::Block)\n+                          -> Mir<'tcx> {\n     let cfg = CFG { basic_blocks: vec![] };\n \n     // it's handy to have a temporary of type `()` sometimes, so make\n     // one from the start and keep it available\n-    let temp_decls = vec![TempDecl::<H> { ty: hir.unit_ty() }];\n+    let temp_decls = vec![TempDecl::<'tcx> { ty: hir.unit_ty() }];\n     let unit_temp = Lvalue::Temp(0);\n \n     let mut builder = Builder {\n@@ -118,14 +124,14 @@ pub fn construct<H:Hair>(mut hir: H,\n     }\n }\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n-                     implicit_arguments: Vec<H::Ty>,\n-                     explicit_arguments: Vec<(H::Ty, H::Pattern)>,\n-                     argument_extent: H::CodeExtent,\n-                     ast_block: H::Block)\n-                     -> BlockAnd<Vec<ArgDecl<H>>>\n+                     implicit_arguments: Vec<Ty<'tcx>>,\n+                     explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n+                     argument_extent: CodeExtent,\n+                     ast_block: &'tcx hir::Block)\n+                     -> BlockAnd<Vec<ArgDecl<'tcx>>>\n     {\n         self.in_scope(argument_extent, block, |this| {\n             let arg_decls = {"}, {"sha": "4b76bc737fdb7906ce5d8840f07f2783ca9a0f74", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -12,7 +12,7 @@\n Managing the scope stack. The scopes are tied to lexical scopes, so as\n we descend the HAIR, we push a scope on the stack, translate ite\n contents, and then pop it off. Every scope is named by a\n-`H::CodeExtent`.\n+`CodeExtent`.\n \n ### SEME Regions\n \n@@ -23,7 +23,7 @@ via a `break` or `return` or just by fallthrough, that marks an exit\n from the scope. Each lexical scope thus corresponds to a single-entry,\n multiple-exit (SEME) region in the control-flow graph.\n \n-For now, we keep a mapping from each `H::CodeExtent` to its\n+For now, we keep a mapping from each `CodeExtent` to its\n corresponding SEME region for later reference (see caveat in next\n paragraph). This is because region scopes are tied to\n them. Eventually, when we shift to non-lexical lifetimes, three should\n@@ -87,37 +87,39 @@ should go to.\n */\n \n use build::{BlockAnd, Builder, CFG};\n-use hair::Hair;\n use repr::*;\n+use rustc::middle::region::CodeExtent;\n+use rustc::middle::ty::Ty;\n+use syntax::codemap::Span;\n \n-pub struct Scope<H:Hair> {\n-    extent: H::CodeExtent,\n+pub struct Scope<'tcx> {\n+    extent: CodeExtent,\n     exits: Vec<ExecutionPoint>,\n-    drops: Vec<(DropKind, H::Span, Lvalue<H>)>,\n+    drops: Vec<(DropKind, Span, Lvalue<'tcx>)>,\n     cached_block: Option<BasicBlock>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct LoopScope<H:Hair> {\n-    pub extent: H::CodeExtent,      // extent of the loop\n+pub struct LoopScope {\n+    pub extent: CodeExtent,      // extent of the loop\n     pub continue_block: BasicBlock, // where to go on a `loop`\n     pub break_block: BasicBlock,    // where to go on a `break\n }\n \n-impl<H:Hair> Builder<H> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Start a loop scope, which tracks where `continue` and `break`\n     /// should branch to. See module comment for more details.\n     pub fn in_loop_scope<F,R>(&mut self,\n                               loop_block: BasicBlock,\n                               break_block: BasicBlock,\n                               f: F)\n                               -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<H>) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a,'tcx>) -> BlockAnd<R>\n     {\n         let extent = self.extent_of_innermost_scope().unwrap();\n-        let loop_scope = LoopScope::<H> { extent: extent.clone(),\n-                                          continue_block: loop_block,\n-                                          break_block: break_block };\n+        let loop_scope = LoopScope { extent: extent.clone(),\n+                                     continue_block: loop_block,\n+                                     break_block: break_block };\n         self.loop_scopes.push(loop_scope);\n         let r = f(self);\n         assert!(self.loop_scopes.pop().unwrap().extent == extent);\n@@ -127,11 +129,11 @@ impl<H:Hair> Builder<H> {\n     /// Start a scope. The closure `f` should translate the contents\n     /// of the scope. See module comment for more details.\n     pub fn in_scope<F,R>(&mut self,\n-                         extent: H::CodeExtent,\n+                         extent: CodeExtent,\n                          block: BasicBlock,\n                          f: F)\n                          -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<H>) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a,'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n \n@@ -180,9 +182,9 @@ impl<H:Hair> Builder<H> {\n     /// Finds the loop scope for a given label. This is used for\n     /// resolving `break` and `continue`.\n     pub fn find_loop_scope(&mut self,\n-                           span: H::Span,\n-                           label: Option<H::CodeExtent>)\n-                           -> LoopScope<H> {\n+                           span: Span,\n+                           label: Option<CodeExtent>)\n+                           -> LoopScope {\n         let loop_scope =\n             match label {\n                 None => {\n@@ -211,8 +213,8 @@ impl<H:Hair> Builder<H> {\n     /// needed, as well as tracking this exit for the SEME region. See\n     /// module comment for details.\n     pub fn exit_scope(&mut self,\n-                      span: H::Span,\n-                      extent: H::CodeExtent,\n+                      span: Span,\n+                      extent: CodeExtent,\n                       block: BasicBlock,\n                       target: BasicBlock) {\n         let popped_scopes =\n@@ -249,11 +251,11 @@ impl<H:Hair> Builder<H> {\n     /// Indicates that `lvalue` should be dropped on exit from\n     /// `extent`.\n     pub fn schedule_drop(&mut self,\n-                         span: H::Span,\n-                         extent: H::CodeExtent,\n+                         span: Span,\n+                         extent: CodeExtent,\n                          kind: DropKind,\n-                         lvalue: &Lvalue<H>,\n-                         lvalue_ty: H::Ty)\n+                         lvalue: &Lvalue<'tcx>,\n+                         lvalue_ty: Ty<'tcx>)\n     {\n         if self.hir.needs_drop(lvalue_ty, span) {\n             match self.scopes.iter_mut().rev().find(|s| s.extent == extent) {\n@@ -267,18 +269,18 @@ impl<H:Hair> Builder<H> {\n         }\n     }\n \n-    pub fn extent_of_innermost_scope(&self) -> Option<H::CodeExtent> {\n+    pub fn extent_of_innermost_scope(&self) -> Option<CodeExtent> {\n         self.scopes.last().map(|scope| scope.extent)\n     }\n \n-    pub fn extent_of_outermost_scope(&self) -> Option<H::CodeExtent> {\n+    pub fn extent_of_outermost_scope(&self) -> Option<CodeExtent> {\n         self.scopes.first().map(|scope| scope.extent)\n     }\n }\n \n-fn diverge_cleanup_helper<H:Hair>(cfg: &mut CFG<H>,\n-                                 scopes: &mut [Scope<H>])\n-                                 -> BasicBlock {\n+fn diverge_cleanup_helper<'tcx>(cfg: &mut CFG<'tcx>,\n+                                scopes: &mut [Scope<'tcx>])\n+                                -> BasicBlock {\n     let len = scopes.len();\n \n     if len == 0 {"}, {"sha": "01fda2498f7121102ee32ee2f12a8b8e11c84c1d", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -12,15 +12,15 @@ use build::{BlockAnd, Builder};\n use hair::*;\n use repr::*;\n \n-impl<H:Hair> Builder<H> {\n-    pub fn stmts(&mut self, mut block: BasicBlock, stmts: Vec<StmtRef<H>>) -> BlockAnd<()> {\n+impl<'a,'tcx> Builder<'a,'tcx> {\n+    pub fn stmts(&mut self, mut block: BasicBlock, stmts: Vec<StmtRef<'tcx>>) -> BlockAnd<()> {\n         for stmt in stmts {\n             unpack!(block = self.stmt(block, stmt));\n         }\n         block.unit()\n     }\n \n-    pub fn stmt(&mut self, mut block: BasicBlock, stmt: StmtRef<H>) -> BlockAnd<()> {\n+    pub fn stmt(&mut self, mut block: BasicBlock, stmt: StmtRef<'tcx>) -> BlockAnd<()> {\n         let this = self;\n         let Stmt { span, kind } = this.hir.mirror(stmt);\n         match kind {"}, {"sha": "5e68e5cc9956ebf6ee783a6af8c83bd214f1a0f9", "filename": "src/librustc_mir/dump.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdump.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -169,18 +169,18 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n                          span: Span,\n                          decl: &'tcx hir::FnDecl,\n                          body: &'tcx hir::Block)\n-                         -> Result<Mir<Cx<'a,'tcx>>, ErrorReported> {\n+                         -> Result<Mir<'tcx>, ErrorReported> {\n     let arguments =\n         decl.inputs\n             .iter()\n             .map(|arg| {\n-                let ty = cx.tcx.node_id_to_type(arg.id);\n+                let ty = cx.tcx().node_id_to_type(arg.id);\n                 (ty, PatNode::irrefutable(&arg.pat))\n             })\n             .collect();\n \n     let parameter_scope =\n-        cx.tcx.region_maps.lookup_code_extent(\n+        cx.tcx().region_maps.lookup_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n     Ok(build::construct(cx,\n                         span,"}, {"sha": "0acf59bf357889cb1ba55967e787c2ed4aa74ea3", "filename": "src/librustc_mir/graphviz/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use dot;\n-use hair::Hair;\n use repr::*;\n use std::borrow::IntoCow;\n \n@@ -20,7 +19,7 @@ pub struct EdgeIndex {\n     index: usize,\n }\n \n-impl<'a,H:Hair> dot::Labeller<'a, BasicBlock, EdgeIndex> for Mir<H> {\n+impl<'a,'tcx> dot::Labeller<'a, BasicBlock, EdgeIndex> for Mir<'tcx> {\n     fn graph_id(&'a self) -> dot::Id<'a> {\n         dot::Id::new(\"Mir\").unwrap()\n     }\n@@ -62,7 +61,7 @@ impl<'a,H:Hair> dot::Labeller<'a, BasicBlock, EdgeIndex> for Mir<H> {\n     }\n }\n \n-impl<'a,H:Hair> dot::GraphWalk<'a, BasicBlock, EdgeIndex> for Mir<H> {\n+impl<'a,'tcx> dot::GraphWalk<'a, BasicBlock, EdgeIndex> for Mir<'tcx> {\n     fn nodes(&'a self) -> dot::Nodes<'a, BasicBlock> {\n         self.all_basic_blocks().into_cow()\n     }"}, {"sha": "ed776717d37874001a94056637afa7426dad8ff8", "filename": "src/librustc_mir/hair.rs", "status": "modified", "additions": 151, "deletions": 214, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fhair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Fhair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -15,144 +15,78 @@\n //! structures.\n \n use repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp};\n-use std::fmt::Debug;\n-use std::hash::Hash;\n-\n-pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n-\n-    // (*) the `Sized` and Debug` bounds are the only ones that really\n-    // make sense.  The rest are just there so that we can\n-    // `#[derive(Clone)]` on things that are parameterized over\n-    // `H:HAIR`. It's kind of lame.\n-\n-    type VarId: Copy+Debug+Eq+Hash;                              // e.g., NodeId for a variable\n-    type DefId: Copy+Debug+Eq+Hash;                              // e.g., DefId\n-    type AdtDef: Copy+Debug+Eq+Hash;                             // e.g., AdtDef<'tcx>\n-    type Name: Copy+Debug+Eq+Hash;                               // e.g., ast::Name\n-    type InternedString: Clone+Debug+Eq+Hash;                    // e.g., InternedString\n-    type Bytes: Clone+Debug+Eq+Hash;                             // e.g., Rc<Vec<u8>>\n-    type Span: Copy+Debug+Eq;                                    // e.g., syntax::codemap::Span\n-    type Projection: Clone+Debug+Eq;                             // e.g., ty::ProjectionTy<'tcx>\n-    type Substs: Clone+Debug+Eq;                                 // e.g., substs::Substs<'tcx>\n-    type ClosureSubsts: Clone+Debug+Eq;                          // e.g., ty::ClosureSubsts<'tcx>\n-    type Ty: Clone+Debug+Eq;                                     // e.g., ty::Ty<'tcx>\n-    type Region: Copy+Debug;                                     // e.g., ty::Region\n-    type CodeExtent: Copy+Debug+Hash+Eq;                         // e.g., region::CodeExtent\n-    type ConstVal: Clone+Debug+PartialEq;                        // e.g., ConstVal\n-    type Pattern: Clone+Debug+Mirror<Self,Output=Pattern<Self>>; // e.g., &P<ast::Pat>\n-    type Expr: Clone+Debug+Mirror<Self,Output=Expr<Self>>;       // e.g., &P<ast::Expr>\n-    type Stmt: Clone+Debug+Mirror<Self,Output=Stmt<Self>>;       // e.g., &P<ast::Stmt>\n-    type Block: Clone+Debug+Mirror<Self,Output=Block<Self>>;     // e.g., &P<ast::Block>\n-    type InlineAsm: Clone+Debug+Eq+Hash;                         // e.g., ast::InlineAsm\n-\n-    /// Normalizes `ast` into the appropriate `mirror` type.\n-    fn mirror<M:Mirror<Self>>(&mut self, ast: M) -> M::Output {\n-        ast.make_mirror(self)\n-    }\n-\n-    /// Returns the unit type `()`\n-    fn unit_ty(&mut self) -> Self::Ty;\n-\n-    /// Returns the type `usize`.\n-    fn usize_ty(&mut self) -> Self::Ty;\n-\n-    /// Returns the literal for `value` as a `usize`.\n-    fn usize_literal(&mut self, value: usize) -> Literal<Self>;\n-\n-    /// Returns the type `bool`.\n-    fn bool_ty(&mut self) -> Self::Ty;\n-\n-    /// Returns the literal for `true`\n-    fn true_literal(&mut self) -> Literal<Self>;\n-\n-    /// Returns the literal for `false`\n-    fn false_literal(&mut self) -> Literal<Self>;\n-\n-    /// Returns a reference to `PartialEq::<T,T>::eq`\n-    fn partial_eq(&mut self, ty: Self::Ty) -> ItemRef<Self>;\n-\n-    /// Returns a reference to `PartialOrd::<T,T>::le`\n-    fn partial_le(&mut self, ty: Self::Ty) -> ItemRef<Self>;\n-\n-    /// Returns the number of variants for the given enum\n-    fn num_variants(&mut self, adt: Self::AdtDef) -> usize;\n-\n-    fn fields(&mut self, adt: Self::AdtDef, variant_index: usize) -> Vec<Field<Self>>;\n-\n-    /// true if a value of type `ty` (may) need to be dropped; this\n-    /// may return false even for non-Copy types if there is no\n-    /// destructor to execute. If correct result is not known, may be\n-    /// approximated by returning `true`; this will result in more\n-    /// drops but not incorrect code.\n-    fn needs_drop(&mut self, ty: Self::Ty, span: Self::Span) -> bool;\n-\n-    /// Report an internal inconsistency.\n-    fn span_bug(&mut self, span: Self::Span, message: &str) -> !;\n-}\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::region::CodeExtent;\n+use rustc::middle::subst::Substs;\n+use rustc::middle::ty::{AdtDef, ClosureSubsts, Region, Ty};\n+use rustc_front::hir;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use tcx::{Cx, PatNode};\n \n #[derive(Clone, Debug)]\n-pub struct ItemRef<H:Hair> {\n-    pub ty: H::Ty,\n-    pub def_id: H::DefId,\n-    pub substs: H::Substs,\n+pub struct ItemRef<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Block<H:Hair> {\n-    pub extent: H::CodeExtent,\n-    pub span: H::Span,\n-    pub stmts: Vec<StmtRef<H>>,\n-    pub expr: Option<ExprRef<H>>,\n+pub struct Block<'tcx> {\n+    pub extent: CodeExtent,\n+    pub span: Span,\n+    pub stmts: Vec<StmtRef<'tcx>>,\n+    pub expr: Option<ExprRef<'tcx>>,\n }\n \n #[derive(Clone, Debug)]\n-pub enum StmtRef<H:Hair> {\n-    Hair(H::Stmt),\n-    Mirror(Box<Stmt<H>>),\n+pub enum StmtRef<'tcx> {\n+    Hair(&'tcx hir::Stmt),\n+    Mirror(Box<Stmt<'tcx>>),\n }\n \n #[derive(Clone, Debug)]\n-pub struct Stmt<H:Hair> {\n-    pub span: H::Span,\n-    pub kind: StmtKind<H>,\n+pub struct Stmt<'tcx> {\n+    pub span: Span,\n+    pub kind: StmtKind<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub enum StmtKind<H:Hair> {\n+pub enum StmtKind<'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n-        scope: H::CodeExtent,\n+        scope: CodeExtent,\n \n         /// expression being evaluated in this statement\n-        expr: ExprRef<H>\n+        expr: ExprRef<'tcx>\n     },\n \n     Let {\n         /// scope for variables bound in this let; covers this and\n         /// remaining statements in block\n-        remainder_scope: H::CodeExtent,\n+        remainder_scope: CodeExtent,\n \n         /// scope for the initialization itself; might be used as\n         /// lifetime of temporaries\n-        init_scope: H::CodeExtent,\n+        init_scope: CodeExtent,\n \n         /// let <PAT> = ...\n-        pattern: PatternRef<H>,\n+        pattern: PatternRef<'tcx>,\n \n         /// let pat = <INIT> ...\n-        initializer: Option<ExprRef<H>>,\n+        initializer: Option<ExprRef<'tcx>>,\n \n         /// let pat = init; <STMTS>\n-        stmts: Vec<StmtRef<H>>\n+        stmts: Vec<StmtRef<'tcx>>\n     },\n }\n \n-// The Hair trait implementor translates their expressions (`H::Expr`)\n+// The Hair trait implementor translates their expressions (`&'tcx H::Expr`)\n // into instances of this `Expr` enum. This translation can be done\n // basically as lazilly or as eagerly as desired: every recursive\n-// reference to an expression in this enum is an `ExprRef<H>`, which\n+// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n // may in turn be another instance of this enum (boxed), or else an\n-// untranslated `H::Expr`. Note that instances of `Expr` are very\n+// untranslated `&'tcx H::Expr`. Note that instances of `Expr` are very\n // shortlived. They are created by `Hair::to_expr`, analyzed and\n // converted into MIR, and then discarded.\n //\n@@ -162,87 +96,88 @@ pub enum StmtKind<H:Hair> {\n // example, method calls and overloaded operators are absent: they are\n // expected to be converted into `Expr::Call` instances.\n #[derive(Clone, Debug)]\n-pub struct Expr<H:Hair> {\n+pub struct Expr<'tcx> {\n     // type of this expression\n-    pub ty: H::Ty,\n+    pub ty: Ty<'tcx>,\n \n     // lifetime of this expression if it should be spilled into a\n     // temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<H::CodeExtent>,\n+    pub temp_lifetime: Option<CodeExtent>,\n \n     // span of the expression in the source\n-    pub span: H::Span,\n+    pub span: Span,\n \n     // kind of expression\n-    pub kind: ExprKind<H>,\n+    pub kind: ExprKind<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub enum ExprKind<H:Hair> {\n-    Scope { extent: H::CodeExtent, value: ExprRef<H> },\n-    Box { value: ExprRef<H> },\n-    Call { fun: ExprRef<H>, args: Vec<ExprRef<H>> },\n-    Deref { arg: ExprRef<H> }, // NOT overloaded!\n-    Binary { op: BinOp, lhs: ExprRef<H>, rhs: ExprRef<H> }, // NOT overloaded!\n-    LogicalOp { op: LogicalOp, lhs: ExprRef<H>, rhs: ExprRef<H> },\n-    Unary { op: UnOp, arg: ExprRef<H> }, // NOT overloaded!\n-    Cast { source: ExprRef<H> },\n-    ReifyFnPointer { source: ExprRef<H> },\n-    UnsafeFnPointer { source: ExprRef<H> },\n-    Unsize { source: ExprRef<H> },\n-    If { condition: ExprRef<H>, then: ExprRef<H>, otherwise: Option<ExprRef<H>> },\n-    Loop { condition: Option<ExprRef<H>>, body: ExprRef<H>, },\n-    Match { discriminant: ExprRef<H>, arms: Vec<Arm<H>> },\n-    Block { body: H::Block },\n-    Assign { lhs: ExprRef<H>, rhs: ExprRef<H> },\n-    AssignOp { op: BinOp, lhs: ExprRef<H>, rhs: ExprRef<H> },\n-    Field { lhs: ExprRef<H>, name: Field<H> },\n-    Index { lhs: ExprRef<H>, index: ExprRef<H> },\n-    VarRef { id: H::VarId },\n+pub enum ExprKind<'tcx> {\n+    Scope { extent: CodeExtent, value: ExprRef<'tcx> },\n+    Box { value: ExprRef<'tcx> },\n+    Call { fun: ExprRef<'tcx>, args: Vec<ExprRef<'tcx>> },\n+    Deref { arg: ExprRef<'tcx> }, // NOT overloaded!\n+    Binary { op: BinOp, lhs: ExprRef<'tcx>, rhs: ExprRef<'tcx> }, // NOT overloaded!\n+    LogicalOp { op: LogicalOp, lhs: ExprRef<'tcx>, rhs: ExprRef<'tcx> },\n+    Unary { op: UnOp, arg: ExprRef<'tcx> }, // NOT overloaded!\n+    Cast { source: ExprRef<'tcx> },\n+    ReifyFnPointer { source: ExprRef<'tcx> },\n+    UnsafeFnPointer { source: ExprRef<'tcx> },\n+    Unsize { source: ExprRef<'tcx> },\n+    If { condition: ExprRef<'tcx>, then: ExprRef<'tcx>, otherwise: Option<ExprRef<'tcx>> },\n+    Loop { condition: Option<ExprRef<'tcx>>, body: ExprRef<'tcx>, },\n+    Match { discriminant: ExprRef<'tcx>, arms: Vec<Arm<'tcx>> },\n+    Block { body: &'tcx hir::Block },\n+    Assign { lhs: ExprRef<'tcx>, rhs: ExprRef<'tcx> },\n+    AssignOp { op: BinOp, lhs: ExprRef<'tcx>, rhs: ExprRef<'tcx> },\n+    Field { lhs: ExprRef<'tcx>, name: Field },\n+    Index { lhs: ExprRef<'tcx>, index: ExprRef<'tcx> },\n+    VarRef { id: ast::NodeId },\n     SelfRef, // first argument, used for self in a closure\n-    StaticRef { id: H::DefId },\n-    Borrow { region: H::Region, borrow_kind: BorrowKind, arg: ExprRef<H> },\n-    Break { label: Option<H::CodeExtent> },\n-    Continue { label: Option<H::CodeExtent> },\n-    Return { value: Option<ExprRef<H>> },\n-    Repeat { value: ExprRef<H>, count: ExprRef<H> },\n-    Vec { fields: Vec<ExprRef<H>> },\n-    Tuple { fields: Vec<ExprRef<H>> },\n-    Adt { adt_def: H::AdtDef,\n+    StaticRef { id: DefId },\n+    Borrow { region: Region, borrow_kind: BorrowKind, arg: ExprRef<'tcx> },\n+    Break { label: Option<CodeExtent> },\n+    Continue { label: Option<CodeExtent> },\n+    Return { value: Option<ExprRef<'tcx>> },\n+    Repeat { value: ExprRef<'tcx>, count: ExprRef<'tcx> },\n+    Vec { fields: Vec<ExprRef<'tcx>> },\n+    Tuple { fields: Vec<ExprRef<'tcx>> },\n+    Adt { adt_def: AdtDef<'tcx>,\n           variant_index: usize,\n-          substs: H::Substs,\n-          fields: Vec<FieldExprRef<H>>,\n-          base: Option<ExprRef<H>> },\n-    Closure { closure_id: H::DefId, substs: H::ClosureSubsts,\n-              upvars: Vec<ExprRef<H>> },\n-    Literal { literal: Literal<H> },\n-    InlineAsm { asm: H::InlineAsm },\n+          substs: &'tcx Substs<'tcx>,\n+          fields: Vec<FieldExprRef<'tcx>>,\n+          base: Option<ExprRef<'tcx>> },\n+    Closure { closure_id: DefId,\n+              substs: &'tcx ClosureSubsts<'tcx>,\n+              upvars: Vec<ExprRef<'tcx>> },\n+    Literal { literal: Literal<'tcx> },\n+    InlineAsm { asm: &'tcx hir::InlineAsm },\n }\n \n #[derive(Clone, Debug)]\n-pub enum ExprRef<H:Hair> {\n-    Hair(H::Expr),\n-    Mirror(Box<Expr<H>>),\n+pub enum ExprRef<'tcx> {\n+    Hair(&'tcx hir::Expr),\n+    Mirror(Box<Expr<'tcx>>),\n }\n \n #[derive(Clone, Debug)]\n-pub struct FieldExprRef<H:Hair> {\n-    pub name: Field<H>,\n-    pub expr: ExprRef<H>,\n+pub struct FieldExprRef<'tcx> {\n+    pub name: Field,\n+    pub expr: ExprRef<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Arm<H:Hair> {\n-    pub patterns: Vec<PatternRef<H>>,\n-    pub guard: Option<ExprRef<H>>,\n-    pub body: ExprRef<H>,\n+pub struct Arm<'tcx> {\n+    pub patterns: Vec<PatternRef<'tcx>>,\n+    pub guard: Option<ExprRef<'tcx>>,\n+    pub body: ExprRef<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Pattern<H:Hair> {\n-    pub ty: H::Ty,\n-    pub span: H::Span,\n-    pub kind: PatternKind<H>,\n+pub struct Pattern<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub span: Span,\n+    pub kind: PatternKind<'tcx>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -252,138 +187,140 @@ pub enum LogicalOp {\n }\n \n #[derive(Clone, Debug)]\n-pub enum PatternKind<H:Hair> {\n+pub enum PatternKind<'tcx> {\n     Wild,\n \n     // x, ref x, x @ P, etc\n     Binding { mutability: Mutability,\n-              name: H::Name,\n-              mode: BindingMode<H>,\n-              var: H::VarId,\n-              ty: H::Ty,\n-              subpattern: Option<PatternRef<H>> },\n+              name: ast::Name,\n+              mode: BindingMode,\n+              var: ast::NodeId,\n+              ty: Ty<'tcx>,\n+              subpattern: Option<PatternRef<'tcx>> },\n \n     // Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n-    Variant { adt_def: H::AdtDef, variant_index: usize, subpatterns: Vec<FieldPatternRef<H>> },\n+    Variant { adt_def: AdtDef<'tcx>, variant_index: usize, subpatterns: Vec<FieldPatternRef<'tcx>> },\n \n     // (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n-    Leaf { subpatterns: Vec<FieldPatternRef<H>> },\n+    Leaf { subpatterns: Vec<FieldPatternRef<'tcx>> },\n \n-    Deref { subpattern: PatternRef<H> }, // box P, &P, &mut P, etc\n+    Deref { subpattern: PatternRef<'tcx> }, // box P, &P, &mut P, etc\n \n-    Constant { value: Literal<H> },\n+    Constant { value: Literal<'tcx> },\n \n-    Range { lo: Literal<H>, hi: Literal<H> },\n+    Range { lo: Literal<'tcx>, hi: Literal<'tcx> },\n \n     // matches against a slice, checking the length and extracting elements\n-    Slice { prefix: Vec<PatternRef<H>>,\n-            slice: Option<PatternRef<H>>,\n-            suffix: Vec<PatternRef<H>> },\n+    Slice { prefix: Vec<PatternRef<'tcx>>,\n+            slice: Option<PatternRef<'tcx>>,\n+            suffix: Vec<PatternRef<'tcx>> },\n \n     // fixed match against an array, irrefutable\n-    Array { prefix: Vec<PatternRef<H>>,\n-            slice: Option<PatternRef<H>>,\n-            suffix: Vec<PatternRef<H>> },\n+    Array { prefix: Vec<PatternRef<'tcx>>,\n+            slice: Option<PatternRef<'tcx>>,\n+            suffix: Vec<PatternRef<'tcx>> },\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum BindingMode<H:Hair> {\n+pub enum BindingMode {\n     ByValue,\n-    ByRef(H::Region, BorrowKind),\n+    ByRef(Region, BorrowKind),\n }\n \n #[derive(Clone, Debug)]\n-pub enum PatternRef<H:Hair> {\n-    Hair(H::Pattern),\n-    Mirror(Box<Pattern<H>>),\n+pub enum PatternRef<'tcx> {\n+    Hair(PatNode<'tcx>),\n+    Mirror(Box<Pattern<'tcx>>),\n }\n \n #[derive(Clone, Debug)]\n-pub struct FieldPatternRef<H:Hair> {\n-    pub field: Field<H>,\n-    pub pattern: PatternRef<H>,\n+pub struct FieldPatternRef<'tcx> {\n+    pub field: Field,\n+    pub pattern: PatternRef<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // The Mirror trait\n \n-/// \"Mirroring\" is the process of converting from a Hair type into one\n-/// of the types in this file. For example, the mirror of a `H::Expr`\n-/// is an `Expr<H>`. Mirroring is the point at which the actual IR is\n-/// converting into the more idealized representation described in\n-/// this file. Mirroring is gradual: when you mirror an outer\n-/// expression like `e1 + e2`, the references to the inner expressions\n-/// `e1` and `e2` are `ExprRef<H>` instances, and they may or may not\n-/// be eagerly mirrored.  This allows a single AST node from the\n-/// compiler to expand into one or more Hair nodes, which lets the Hair\n-/// nodes be simpler.\n-pub trait Mirror<H:Hair> {\n+/// \"Mirroring\" is the process of converting from a HIR type into one\n+/// of the HAIR types defined in this file. This is basically a \"on\n+/// the fly\" desugaring step that hides a lot of the messiness in the\n+/// tcx. For example, the mirror of a `&'tcx hir::Expr` is an\n+/// `Expr<'tcx>`.\n+///\n+/// Mirroring is gradual: when you mirror an outer expression like `e1\n+/// + e2`, the references to the inner expressions `e1` and `e2` are\n+/// `ExprRef<'tcx>` instances, and they may or may not be eagerly\n+/// mirrored.  This allows a single AST node from the compiler to\n+/// expand into one or more Hair nodes, which lets the Hair nodes be\n+/// simpler.\n+pub trait Mirror<'tcx> {\n     type Output;\n \n-    fn make_mirror(self, hir: &mut H) -> Self::Output;\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a,'tcx>) -> Self::Output;\n }\n \n-impl<H:Hair> Mirror<H> for Expr<H> {\n-    type Output = Expr<H>;\n+impl<'tcx> Mirror<'tcx> for Expr<'tcx> {\n+    type Output = Expr<'tcx>;\n \n-    fn make_mirror(self, _: &mut H) -> Expr<H> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Expr<'tcx> {\n         self\n     }\n }\n \n-impl<H:Hair> Mirror<H> for ExprRef<H> {\n-    type Output = Expr<H>;\n+impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n+    type Output = Expr<'tcx>;\n \n-    fn make_mirror(self, hir: &mut H) -> Expr<H> {\n+    fn make_mirror<'a>(self, hir: &mut Cx<'a,'tcx>) -> Expr<'tcx> {\n         match self {\n             ExprRef::Hair(h) => h.make_mirror(hir),\n             ExprRef::Mirror(m) => *m,\n         }\n     }\n }\n \n-impl<H:Hair> Mirror<H> for Stmt<H> {\n-    type Output = Stmt<H>;\n+impl<'tcx> Mirror<'tcx> for Stmt<'tcx> {\n+    type Output = Stmt<'tcx>;\n \n-    fn make_mirror(self, _: &mut H) -> Stmt<H> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n         self\n     }\n }\n \n-impl<H:Hair> Mirror<H> for StmtRef<H> {\n-    type Output = Stmt<H>;\n+impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n+    type Output = Stmt<'tcx>;\n \n-    fn make_mirror(self, hir: &mut H) -> Stmt<H> {\n+    fn make_mirror<'a>(self, hir: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n         match self {\n             StmtRef::Hair(h) => h.make_mirror(hir),\n             StmtRef::Mirror(m) => *m,\n         }\n     }\n }\n \n-impl<H:Hair> Mirror<H> for Pattern<H> {\n-    type Output = Pattern<H>;\n+impl<'tcx> Mirror<'tcx> for Pattern<'tcx> {\n+    type Output = Pattern<'tcx>;\n \n-    fn make_mirror(self, _: &mut H) -> Pattern<H> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Pattern<'tcx> {\n         self\n     }\n }\n \n-impl<H:Hair> Mirror<H> for PatternRef<H> {\n-    type Output = Pattern<H>;\n+impl<'tcx> Mirror<'tcx> for PatternRef<'tcx> {\n+    type Output = Pattern<'tcx>;\n \n-    fn make_mirror(self, hir: &mut H) -> Pattern<H> {\n+    fn make_mirror<'a>(self, hir: &mut Cx<'a,'tcx>) -> Pattern<'tcx> {\n         match self {\n             PatternRef::Hair(h) => h.make_mirror(hir),\n             PatternRef::Mirror(m) => *m,\n         }\n     }\n }\n \n-impl<H:Hair> Mirror<H> for Block<H> {\n-    type Output = Block<H>;\n+impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n+    type Output = Block<'tcx>;\n \n-    fn make_mirror(self, _: &mut H) -> Block<H> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Block<'tcx> {\n         self\n     }\n }"}, {"sha": "8dc5ba37e6e6a8117dcc6ae0a528ad886550f6dd", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -24,7 +24,10 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #[macro_use] extern crate log;\n extern crate graphviz as dot;\n+extern crate rustc;\n extern crate rustc_data_structures;\n+extern crate rustc_front;\n+extern crate syntax;\n \n pub mod build;\n pub mod dump;"}, {"sha": "bffc44bccbd45003a2f79133a41f1ca7c2dd5d45", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 93, "deletions": 86, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -8,22 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hair::Hair;\n+use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::region::CodeExtent;\n+use rustc::middle::subst::Substs;\n+use rustc::middle::ty::{AdtDef, ClosureSubsts, Region, Ty};\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_front::hir::InlineAsm;\n+use syntax::ast::Name;\n+use syntax::codemap::Span;\n use std::fmt::{Debug, Formatter, Error};\n use std::slice;\n use std::u32;\n \n /// Lowered representation of a single function.\n-pub struct Mir<H:Hair> {\n-    pub basic_blocks: Vec<BasicBlockData<H>>,\n+pub struct Mir<'tcx> {\n+    pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n \n     // for every node id\n-    pub extents: FnvHashMap<H::CodeExtent, Vec<GraphExtent>>,\n+    pub extents: FnvHashMap<CodeExtent, Vec<GraphExtent>>,\n \n-    pub var_decls: Vec<VarDecl<H>>,\n-    pub arg_decls: Vec<ArgDecl<H>>,\n-    pub temp_decls: Vec<TempDecl<H>>,\n+    pub var_decls: Vec<VarDecl<'tcx>>,\n+    pub arg_decls: Vec<ArgDecl<'tcx>>,\n+    pub temp_decls: Vec<TempDecl<'tcx>>,\n }\n \n /// where execution begins\n@@ -35,18 +42,18 @@ pub const END_BLOCK: BasicBlock = BasicBlock(1);\n /// where execution ends, on panic\n pub const DIVERGE_BLOCK: BasicBlock = BasicBlock(2);\n \n-impl<H:Hair> Mir<H> {\n+impl<'tcx> Mir<'tcx> {\n     pub fn all_basic_blocks(&self) -> Vec<BasicBlock> {\n         (0..self.basic_blocks.len())\n             .map(|i| BasicBlock::new(i))\n             .collect()\n     }\n \n-    pub fn basic_block_data(&self, bb: BasicBlock) -> &BasicBlockData<H> {\n+    pub fn basic_block_data(&self, bb: BasicBlock) -> &BasicBlockData<'tcx> {\n         &self.basic_blocks[bb.index()]\n     }\n \n-    pub fn basic_block_data_mut(&mut self, bb: BasicBlock) -> &mut BasicBlockData<H> {\n+    pub fn basic_block_data_mut(&mut self, bb: BasicBlock) -> &mut BasicBlockData<'tcx> {\n         &mut self.basic_blocks[bb.index()]\n     }\n }\n@@ -111,16 +118,16 @@ pub enum BorrowKind {\n \n // A \"variable\" is a binding declared by the user as part of the fn\n // decl, a let, etc.\n-pub struct VarDecl<H:Hair> {\n+pub struct VarDecl<'tcx> {\n     pub mutability: Mutability,\n-    pub name: H::Name,\n-    pub ty: H::Ty,\n+    pub name: Name,\n+    pub ty: Ty<'tcx>,\n }\n \n // A \"temp\" is a temporary that we place on the stack. They are\n // anonymous, always mutable, and have only a type.\n-pub struct TempDecl<H:Hair> {\n-    pub ty: H::Ty,\n+pub struct TempDecl<'tcx> {\n+    pub ty: Ty<'tcx>,\n }\n \n // A \"arg\" is one of the function's formal arguments. These are\n@@ -134,8 +141,8 @@ pub struct TempDecl<H:Hair> {\n //\n // there is only one argument, of type `(i32, u32)`, but two bindings\n // (`x` and `y`).\n-pub struct ArgDecl<H:Hair> {\n-    pub ty: H::Ty,\n+pub struct ArgDecl<'tcx> {\n+    pub ty: Ty<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -212,12 +219,12 @@ impl Debug for BasicBlock {\n // BasicBlock and Terminator\n \n #[derive(Debug)]\n-pub struct BasicBlockData<H:Hair> {\n-    pub statements: Vec<Statement<H>>,\n-    pub terminator: Terminator<H>,\n+pub struct BasicBlockData<'tcx> {\n+    pub statements: Vec<Statement<'tcx>>,\n+    pub terminator: Terminator<'tcx>,\n }\n \n-pub enum Terminator<H:Hair> {\n+pub enum Terminator<'tcx> {\n     /// block should have one successor in the graph; we jump there\n     Goto { target: BasicBlock },\n \n@@ -226,10 +233,10 @@ pub enum Terminator<H:Hair> {\n     Panic { target: BasicBlock },\n \n     /// jump to branch 0 if this lvalue evaluates to true\n-    If { cond: Operand<H>, targets: [BasicBlock; 2] },\n+    If { cond: Operand<'tcx>, targets: [BasicBlock; 2] },\n \n     /// lvalue evaluates to some enum; jump depending on the branch\n-    Switch { discr: Lvalue<H>, targets: Vec<BasicBlock> },\n+    Switch { discr: Lvalue<'tcx>, targets: Vec<BasicBlock> },\n \n     /// Indicates that the last statement in the block panics, aborts,\n     /// etc. No successors. This terminator appears on exactly one\n@@ -247,10 +254,10 @@ pub enum Terminator<H:Hair> {\n     /// block ends with a call; it should have two successors. The\n     /// first successor indicates normal return. The second indicates\n     /// unwinding.\n-    Call { data: CallData<H>, targets: [BasicBlock; 2] },\n+    Call { data: CallData<'tcx>, targets: [BasicBlock; 2] },\n }\n \n-impl<H:Hair> Terminator<H> {\n+impl<'tcx> Terminator<'tcx> {\n     pub fn successors(&self) -> &[BasicBlock] {\n         use self::Terminator::*;\n         match *self {\n@@ -266,27 +273,27 @@ impl<H:Hair> Terminator<H> {\n }\n \n #[derive(Debug)]\n-pub struct CallData<H:Hair> {\n+pub struct CallData<'tcx> {\n     /// where the return value is written to\n-    pub destination: Lvalue<H>,\n+    pub destination: Lvalue<'tcx>,\n \n     /// the fn being called\n-    pub func: Lvalue<H>,\n+    pub func: Lvalue<'tcx>,\n \n     /// the arguments\n-    pub args: Vec<Lvalue<H>>,\n+    pub args: Vec<Lvalue<'tcx>>,\n }\n \n-impl<H:Hair> BasicBlockData<H> {\n-    pub fn new(terminator: Terminator<H>) -> BasicBlockData<H> {\n+impl<'tcx> BasicBlockData<'tcx> {\n+    pub fn new(terminator: Terminator<'tcx>) -> BasicBlockData<'tcx> {\n         BasicBlockData {\n             statements: vec![],\n             terminator: terminator,\n         }\n     }\n }\n \n-impl<H:Hair> Debug for Terminator<H> {\n+impl<'tcx> Debug for Terminator<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n         use self::Terminator::*;\n         match *self {\n@@ -318,15 +325,15 @@ impl<H:Hair> Debug for Terminator<H> {\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n-pub struct Statement<H:Hair> {\n-    pub span: H::Span,\n-    pub kind: StatementKind<H>,\n+pub struct Statement<'tcx> {\n+    pub span: Span,\n+    pub kind: StatementKind<'tcx>,\n }\n \n #[derive(Debug)]\n-pub enum StatementKind<H:Hair> {\n-    Assign(Lvalue<H>, Rvalue<H>),\n-    Drop(DropKind, Lvalue<H>),\n+pub enum StatementKind<'tcx> {\n+    Assign(Lvalue<'tcx>, Rvalue<'tcx>),\n+    Drop(DropKind, Lvalue<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -335,7 +342,7 @@ pub enum DropKind {\n     Deep\n }\n \n-impl<H:Hair> Debug for Statement<H> {\n+impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n         use self::StatementKind::*;\n         match self.kind {\n@@ -351,7 +358,7 @@ impl<H:Hair> Debug for Statement<H> {\n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n #[derive(Clone, PartialEq)]\n-pub enum Lvalue<H:Hair> {\n+pub enum Lvalue<'tcx> {\n     /// local variable declared by the user\n     Var(u32),\n \n@@ -363,29 +370,29 @@ pub enum Lvalue<H:Hair> {\n     Arg(u32),\n \n     /// static or static mut variable\n-    Static(H::DefId),\n+    Static(DefId),\n \n     /// the return pointer of the fn\n     ReturnPointer,\n \n     /// projection out of an lvalue (access a field, deref a pointer, etc)\n-    Projection(Box<LvalueProjection<H>>)\n+    Projection(Box<LvalueProjection<'tcx>>)\n }\n \n /// The `Projection` data structure defines things of the form `B.x`\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases\n /// `LvalueProjection` etc below.\n #[derive(Clone, Debug, PartialEq)]\n-pub struct Projection<H:Hair,B,V> {\n+pub struct Projection<'tcx,B,V> {\n     pub base: B,\n-    pub elem: ProjectionElem<H,V>,\n+    pub elem: ProjectionElem<'tcx,V>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-pub enum ProjectionElem<H:Hair,V> {\n+pub enum ProjectionElem<'tcx,V> {\n     Deref,\n-    Field(Field<H>),\n+    Field(Field),\n     Index(V),\n \n     // These indices are generated by slice patterns. Easiest to explain\n@@ -406,44 +413,44 @@ pub enum ProjectionElem<H:Hair,V> {\n     // \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     // this for ADTs with more than one variant. It may be better to\n     // just introduce it always, or always for enums.\n-    Downcast(H::AdtDef, usize),\n+    Downcast(AdtDef<'tcx>, usize),\n }\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n /// and the index is an operand.\n-pub type LvalueProjection<H> =\n-    Projection<H,Lvalue<H>,Operand<H>>;\n+pub type LvalueProjection<'tcx> =\n+    Projection<'tcx,Lvalue<'tcx>,Operand<'tcx>>;\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n /// and the index is an operand.\n-pub type LvalueElem<H> =\n-    ProjectionElem<H,Operand<H>>;\n+pub type LvalueElem<'tcx> =\n+    ProjectionElem<'tcx,Operand<'tcx>>;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum Field<H:Hair> {\n-    Named(H::Name),\n+pub enum Field {\n+    Named(Name),\n     Indexed(usize),\n }\n \n-impl<H:Hair> Lvalue<H> {\n-    pub fn field(self, f: Field<H>) -> Lvalue<H> {\n+impl<'tcx> Lvalue<'tcx> {\n+    pub fn field(self, f: Field) -> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Field(f))\n     }\n \n-    pub fn deref(self) -> Lvalue<H> {\n+    pub fn deref(self) -> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Deref)\n     }\n \n-    pub fn index(self, index: Operand<H>) -> Lvalue<H> {\n+    pub fn index(self, index: Operand<'tcx>) -> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Index(index))\n     }\n \n-    pub fn elem(self, elem: LvalueElem<H>) -> Lvalue<H> {\n+    pub fn elem(self, elem: LvalueElem<'tcx>) -> Lvalue<'tcx> {\n         Lvalue::Projection(Box::new(LvalueProjection { base: self, elem: elem }))\n     }\n }\n \n-impl<H:Hair> Debug for Lvalue<H> {\n+impl<'tcx> Debug for Lvalue<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n         use self::Lvalue::*;\n \n@@ -487,12 +494,12 @@ impl<H:Hair> Debug for Lvalue<H> {\n // being nested in one another.\n \n #[derive(Clone, PartialEq)]\n-pub enum Operand<H:Hair> {\n-    Consume(Lvalue<H>),\n-    Constant(Constant<H>),\n+pub enum Operand<'tcx> {\n+    Consume(Lvalue<'tcx>),\n+    Constant(Constant<'tcx>),\n }\n \n-impl<H:Hair> Debug for Operand<H> {\n+impl<'tcx> Debug for Operand<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n         use self::Operand::*;\n         match *self {\n@@ -506,47 +513,47 @@ impl<H:Hair> Debug for Operand<H> {\n // Rvalues\n \n #[derive(Clone)]\n-pub enum Rvalue<H:Hair> {\n+pub enum Rvalue<'tcx> {\n     // x (either a move or copy, depending on type of x)\n-    Use(Operand<H>),\n+    Use(Operand<'tcx>),\n \n     // [x; 32]\n-    Repeat(Operand<H>, Operand<H>),\n+    Repeat(Operand<'tcx>, Operand<'tcx>),\n \n     // &x or &mut x\n-    Ref(H::Region, BorrowKind, Lvalue<H>),\n+    Ref(Region, BorrowKind, Lvalue<'tcx>),\n \n     // length of a [X] or [X;n] value\n-    Len(Lvalue<H>),\n+    Len(Lvalue<'tcx>),\n \n-    Cast(CastKind, Operand<H>, H::Ty),\n+    Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n \n-    BinaryOp(BinOp, Operand<H>, Operand<H>),\n+    BinaryOp(BinOp, Operand<'tcx>, Operand<'tcx>),\n \n-    UnaryOp(UnOp, Operand<H>),\n+    UnaryOp(UnOp, Operand<'tcx>),\n \n     // Creates an *uninitialized* Box\n-    Box(H::Ty),\n+    Box(Ty<'tcx>),\n \n     // Create an aggregate value, like a tuple or struct.  This is\n     // only needed because we want to distinguish `dest = Foo { x:\n     // ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n     // that `Foo` has a destructor. These rvalues can be optimized\n     // away after type-checking and before lowering.\n-    Aggregate(AggregateKind<H>, Vec<Operand<H>>),\n+    Aggregate(AggregateKind<'tcx>, Vec<Operand<'tcx>>),\n \n     // Generates a slice of the form `&input[from_start..L-from_end]`\n     // where `L` is the length of the slice. This is only created by\n     // slice pattern matching, so e.g. a pattern of the form `[x, y,\n     // .., z]` might create a slice with `from_start=2` and\n     // `from_end=1`.\n     Slice {\n-        input: Lvalue<H>,\n+        input: Lvalue<'tcx>,\n         from_start: usize,\n         from_end: usize,\n     },\n \n-    InlineAsm(H::InlineAsm),\n+    InlineAsm(&'tcx InlineAsm),\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -568,11 +575,11 @@ pub enum CastKind {\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub enum AggregateKind<H:Hair> {\n+pub enum AggregateKind<'tcx> {\n     Vec,\n     Tuple,\n-    Adt(H::AdtDef, usize, H::Substs),\n-    Closure(H::DefId, H::ClosureSubsts),\n+    Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>),\n+    Closure(DefId, &'tcx ClosureSubsts<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -619,7 +626,7 @@ pub enum UnOp {\n     Neg\n }\n \n-impl<H:Hair> Debug for Rvalue<H> {\n+impl<'tcx> Debug for Rvalue<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n         use self::Rvalue::*;\n \n@@ -648,15 +655,15 @@ impl<H:Hair> Debug for Rvalue<H> {\n // particular one must be wary of `NaN`!\n \n #[derive(Clone, Debug, PartialEq)]\n-pub struct Constant<H:Hair> {\n-    pub span: H::Span,\n-    pub ty: H::Ty,\n-    pub literal: Literal<H>\n+pub struct Constant<'tcx> {\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub literal: Literal<'tcx>\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-pub enum Literal<H:Hair> {\n-    Item { def_id: H::DefId, substs: H::Substs },\n-    Value { value: H::ConstVal },\n+pub enum Literal<'tcx> {\n+    Item { def_id: DefId, substs: &'tcx Substs<'tcx> },\n+    Value { value: ConstVal },\n }\n "}, {"sha": "69cbe4b67e503aa4bf69a443975e40b44a0482f2", "filename": "src/librustc_mir/tcx/block.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fblock.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -12,16 +12,16 @@ use hair::*;\n \n use tcx::Cx;\n use tcx::pattern::PatNode;\n-use tcx::rustc::middle::region::{BlockRemainder, CodeExtentData};\n-use tcx::rustc_front::hir;\n-use tcx::syntax::ast;\n-use tcx::syntax::ptr::P;\n use tcx::to_ref::ToRef;\n+use rustc::middle::region::{BlockRemainder, CodeExtentData};\n+use rustc_front::hir;\n+use syntax::ast;\n+use syntax::ptr::P;\n \n-impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Block {\n-    type Output = Block<Cx<'a,'tcx>>;\n+impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n+    type Output = Block<'tcx>;\n \n-    fn make_mirror(self, cx: &mut Cx<'a,'tcx>) -> Block<Cx<'a,'tcx>> {\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a,'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.id, self.stmts.iter().enumerate());\n@@ -34,10 +34,10 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Block {\n     }\n }\n \n-impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Stmt {\n-    type Output = Stmt<Cx<'a,'tcx>>;\n+impl<'tcx> Mirror<'tcx> for &'tcx hir::Stmt {\n+    type Output = Stmt<'tcx>;\n \n-    fn make_mirror(self, _cx: &mut Cx<'a,'tcx>) -> Stmt<Cx<'a,'tcx>> {\n+    fn make_mirror<'a>(self, _cx: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n         // In order to get the scoping correct, we eagerly mirror\n         // statements when we translate the enclosing block, so we\n         // should in fact never get to this point.\n@@ -48,7 +48,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Stmt {\n fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n                                   block_id: ast::NodeId,\n                                   mut stmts: STMTS)\n-                                  -> Vec<StmtRef<Cx<'a,'tcx>>>\n+                                  -> Vec<StmtRef<'tcx>>\n     where STMTS: Iterator<Item=(usize, &'tcx P<hir::Stmt>)>\n {\n     let mut result = vec![];\n@@ -101,7 +101,7 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n \n pub fn to_expr_ref<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                                block: &'tcx hir::Block)\n-                               -> ExprRef<Cx<'a, 'tcx>> {\n+                               -> ExprRef<'tcx> {\n     let block_ty = cx.tcx.node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {"}, {"sha": "c14b83c937044eae4cdbcd43dede353c6be294da", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -15,22 +15,22 @@ use std::rc::Rc;\n use tcx::Cx;\n use tcx::block;\n use tcx::pattern::PatNode;\n-use tcx::rustc::front::map;\n-use tcx::rustc::middle::const_eval;\n-use tcx::rustc::middle::def;\n-use tcx::rustc::middle::region::CodeExtent;\n-use tcx::rustc::middle::pat_util;\n-use tcx::rustc::middle::ty::{self, Ty};\n-use tcx::rustc_front::hir;\n-use tcx::rustc_front::util as hir_util;\n-use tcx::syntax::parse::token;\n-use tcx::syntax::ptr::P;\n use tcx::to_ref::ToRef;\n-\n-impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n-    type Output = Expr<Cx<'a,'tcx>>;\n-\n-    fn make_mirror(self, cx: &mut Cx<'a,'tcx>) -> Expr<Cx<'a,'tcx>> {\n+use rustc::front::map;\n+use rustc::middle::const_eval;\n+use rustc::middle::def;\n+use rustc::middle::region::CodeExtent;\n+use rustc::middle::pat_util;\n+use rustc::middle::ty::{self, Ty};\n+use rustc_front::hir;\n+use rustc_front::util as hir_util;\n+use syntax::parse::token;\n+use syntax::ptr::P;\n+\n+impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n+    type Output = Expr<'tcx>;\n+\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a,'tcx>) -> Expr<'tcx> {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let expr_ty = cx.tcx.expr_ty(self); // note: no adjustments (yet)!\n@@ -427,7 +427,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n fn method_callee<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                              expr: &hir::Expr,\n                              method_call: ty::MethodCall)\n-                             -> Expr<Cx<'a,'tcx>> {\n+                             -> Expr<'tcx> {\n     let tables = cx.tcx.tables.borrow();\n     let callee = &tables.method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n@@ -451,7 +451,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a,'tcx:'a>(cx: &Cx<'a,'tcx>, arm: &'tcx hir::Arm) -> Arm<Cx<'a,'tcx>> {\n+fn convert_arm<'a,'tcx:'a>(cx: &Cx<'a,'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     let map = if arm.pats.len() == 1 {\n         None\n     } else {\n@@ -469,7 +469,7 @@ fn convert_arm<'a,'tcx:'a>(cx: &Cx<'a,'tcx>, arm: &'tcx hir::Arm) -> Arm<Cx<'a,'\n \n fn convert_path_expr<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                                  expr: &'tcx hir::Expr)\n-                                 -> ExprKind<Cx<'a,'tcx>>\n+                                 -> ExprKind<'tcx>\n {\n     let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n     match cx.tcx.def_map.borrow()[&expr.id].full_def() {\n@@ -502,7 +502,7 @@ fn convert_path_expr<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                            expr: &'tcx hir::Expr,\n                            def: def::Def)\n-                           -> ExprKind<Cx<'a,'tcx>>\n+                           -> ExprKind<'tcx>\n {\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n@@ -665,9 +665,9 @@ fn overloaded_operator<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                                    expr: &'tcx hir::Expr,\n                                    method_call: ty::MethodCall,\n                                    pass_args: PassArgs,\n-                                   receiver: ExprRef<Cx<'a,'tcx>>,\n+                                   receiver: ExprRef<'tcx>,\n                                    args: Vec<&'tcx P<hir::Expr>>)\n-                                   -> ExprKind<Cx<'a,'tcx>>\n+                                   -> ExprKind<'tcx>\n {\n     // the receiver has all the adjustments that are needed, so we can\n     // just push a reference to it\n@@ -718,9 +718,9 @@ fn overloaded_lvalue<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                                  expr: &'tcx hir::Expr,\n                                  method_call: ty::MethodCall,\n                                  pass_args: PassArgs,\n-                                 receiver: ExprRef<Cx<'a,'tcx>>,\n+                                 receiver: ExprRef<'tcx>,\n                                  args: Vec<&'tcx P<hir::Expr>>)\n-                                 -> ExprKind<Cx<'a,'tcx>>\n+                                 -> ExprKind<'tcx>\n {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n@@ -754,7 +754,7 @@ fn capture_freevar<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                                closure_expr: &'tcx hir::Expr,\n                                freevar: &ty::Freevar,\n                                freevar_ty: Ty<'tcx>)\n-                               -> ExprRef<Cx<'a,'tcx>> {\n+                               -> ExprRef<'tcx> {\n     let id_var = freevar.def.var_id();\n     let upvar_id = ty::UpvarId { var_id: id_var, closure_expr_id: closure_expr.id };\n     let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();"}, {"sha": "32694bd509e81674aab5406ee1426ea1f1630575", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -8,31 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+ * This module contains the code to convert from the wacky tcx data\n+ * structures into the hair. The `builder` is generally ignorant of\n+ * the tcx etc, and instead goes through the `Cx` for most of its\n+ * work.\n+ */\n+\n use hair::*;\n use repr::*;\n use std::fmt::{Debug, Formatter, Error};\n use std::hash::{Hash, Hasher};\n-use std::rc::Rc;\n-\n-use self::rustc::middle::const_eval::ConstVal;\n-use self::rustc::middle::def_id::DefId;\n-use self::rustc::middle::infer::InferCtxt;\n-use self::rustc::middle::region::CodeExtent;\n-use self::rustc::middle::subst::{self, Subst, Substs};\n-use self::rustc::middle::ty::{self, Ty};\n-use self::rustc_front::hir;\n-use self::syntax::ast;\n-use self::syntax::codemap::Span;\n-use self::syntax::parse::token::{self, special_idents, InternedString};\n-\n-extern crate rustc;\n-extern crate rustc_front;\n-extern crate syntax;\n+\n+use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::infer::InferCtxt;\n+use rustc::middle::subst::{Subst, Substs};\n+use rustc::middle::ty::{self, Ty};\n+use syntax::codemap::Span;\n+use syntax::parse::token::{self, special_idents};\n \n #[derive(Copy, Clone)]\n pub struct Cx<'a,'tcx:'a> {\n-    pub tcx: &'a ty::ctxt<'tcx>,\n-    pub infcx: &'a InferCtxt<'a,'tcx>,\n+    tcx: &'a ty::ctxt<'tcx>,\n+    infcx: &'a InferCtxt<'a,'tcx>,\n }\n \n impl<'a,'tcx> Cx<'a,'tcx> {\n@@ -43,66 +42,51 @@ impl<'a,'tcx> Cx<'a,'tcx> {\n \n pub use self::pattern::PatNode;\n \n-impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n-    type VarId = ast::NodeId;\n-    type DefId = DefId;\n-    type AdtDef = ty::AdtDef<'tcx>;\n-    type Name = ast::Name;\n-    type InternedString = InternedString;\n-    type Bytes = Rc<Vec<u8>>;\n-    type Span = Span;\n-    type Projection = ty::ProjectionTy<'tcx>;\n-    type Substs = &'tcx subst::Substs<'tcx>;\n-    type ClosureSubsts = &'tcx ty::ClosureSubsts<'tcx>;\n-    type Ty = Ty<'tcx>;\n-    type Region = ty::Region;\n-    type CodeExtent = CodeExtent;\n-    type ConstVal = ConstVal;\n-    type Pattern = PatNode<'tcx>;\n-    type Expr = &'tcx hir::Expr;\n-    type Stmt = &'tcx hir::Stmt;\n-    type Block = &'tcx hir::Block;\n-    type InlineAsm = &'tcx hir::InlineAsm;\n-\n-    fn unit_ty(&mut self) -> Ty<'tcx> {\n+impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n+    /// Normalizes `ast` into the appropriate `mirror` type.\n+    pub fn mirror<M:Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n+        ast.make_mirror(self)\n+    }\n+\n+    pub fn unit_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.mk_nil()\n     }\n \n-    fn usize_ty(&mut self) -> Ty<'tcx> {\n+    pub fn usize_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.types.usize\n     }\n \n-    fn usize_literal(&mut self, value: usize) -> Literal<Self> {\n+    pub fn usize_literal(&mut self, value: usize) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Uint(value as u64) }\n     }\n \n-    fn bool_ty(&mut self) -> Ty<'tcx> {\n+    pub fn bool_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.types.bool\n     }\n \n-    fn true_literal(&mut self) -> Literal<Self> {\n+    pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Bool(true) }\n     }\n \n-    fn false_literal(&mut self) -> Literal<Self> {\n+    pub fn false_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Bool(false) }\n     }\n \n-    fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<Self> {\n+    pub fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<'tcx> {\n         let eq_def_id = self.tcx.lang_items.eq_trait().unwrap();\n         self.cmp_method_ref(eq_def_id, \"eq\", ty)\n     }\n \n-    fn partial_le(&mut self, ty: Ty<'tcx>) -> ItemRef<Self> {\n+    pub fn partial_le(&mut self, ty: Ty<'tcx>) -> ItemRef<'tcx> {\n         let ord_def_id = self.tcx.lang_items.ord_trait().unwrap();\n         self.cmp_method_ref(ord_def_id, \"le\", ty)\n     }\n \n-    fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n+    pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n         adt_def.variants.len()\n     }\n \n-    fn fields(&mut self, adt_def: ty::AdtDef<'tcx>, variant_index: usize) -> Vec<Field<Self>> {\n+    pub fn fields(&mut self, adt_def: ty::AdtDef<'tcx>, variant_index: usize) -> Vec<Field> {\n         adt_def.variants[variant_index]\n             .fields\n             .iter()\n@@ -117,7 +101,7 @@ impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn needs_drop(&mut self, ty: Ty<'tcx>, span: Self::Span) -> bool {\n+    pub fn needs_drop(&mut self, ty: Ty<'tcx>, span: Span) -> bool {\n         if self.infcx.type_moves_by_default(ty, span) {\n             // FIXME(#21859) we should do an add'l check here to determine if\n             // any dtor will execute, but the relevant fn\n@@ -130,17 +114,19 @@ impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n         }\n     }\n \n-    fn span_bug(&mut self, span: Self::Span, message: &str) -> ! {\n+    pub fn span_bug(&mut self, span: Span, message: &str) -> ! {\n         self.tcx.sess.span_bug(span, message)\n     }\n-}\n \n-impl<'a,'tcx:'a> Cx<'a,'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn cmp_method_ref(&mut self,\n                       trait_def_id: DefId,\n                       method_name: &str,\n                       arg_ty: Ty<'tcx>)\n-                      -> ItemRef<Cx<'a,'tcx>> {\n+                      -> ItemRef<'tcx> {\n         let method_name = token::intern(method_name);\n         let substs = Substs::new_trait(vec![arg_ty], vec![], arg_ty);\n         for trait_item in self.tcx.trait_items(trait_def_id).iter() {"}, {"sha": "9407f9e7600ac1647f2b8b790392bab78b2533e8", "filename": "src/librustc_mir/tcx/pattern.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -14,15 +14,15 @@ use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::rc::Rc;\n use tcx::Cx;\n-use tcx::rustc::middle::const_eval;\n-use tcx::rustc::middle::def;\n-use tcx::rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n-use tcx::rustc::middle::subst::Substs;\n-use tcx::rustc::middle::ty::{self, Ty};\n-use tcx::rustc_front::hir;\n-use tcx::syntax::ast;\n-use tcx::syntax::ptr::P;\n use tcx::to_ref::ToRef;\n+use rustc::middle::const_eval;\n+use rustc::middle::def;\n+use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n+use rustc::middle::subst::Substs;\n+use rustc::middle::ty::{self, Ty};\n+use rustc_front::hir;\n+use syntax::ast;\n+use syntax::ptr::P;\n \n /// When there are multiple patterns in a single arm, each one has its\n /// own node-ids for the bindings.  References to the variables always\n@@ -58,15 +58,15 @@ impl<'tcx> PatNode<'tcx> {\n         PatNode::new(pat, None)\n     }\n \n-    fn pat_ref<'a>(&self, pat: &'tcx hir::Pat) -> PatternRef<Cx<'a,'tcx>> {\n+    fn pat_ref<'a>(&self, pat: &'tcx hir::Pat) -> PatternRef<'tcx> {\n         PatNode::new(pat, self.binding_map.clone()).to_ref()\n     }\n \n-    fn pat_refs<'a>(&self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<PatternRef<Cx<'a,'tcx>>> {\n+    fn pat_refs<'a>(&self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<PatternRef<'tcx>> {\n         pats.iter().map(|p| self.pat_ref(p)).collect()\n     }\n \n-    fn opt_pat_ref<'a>(&self, pat: &'tcx Option<P<hir::Pat>>) -> Option<PatternRef<Cx<'a,'tcx>>> {\n+    fn opt_pat_ref<'a>(&self, pat: &'tcx Option<P<hir::Pat>>) -> Option<PatternRef<'tcx>> {\n         pat.as_ref().map(|p| self.pat_ref(p))\n     }\n \n@@ -76,7 +76,7 @@ impl<'tcx> PatNode<'tcx> {\n                                   prefix: &'tcx Vec<P<hir::Pat>>,\n                                   slice: &'tcx Option<P<hir::Pat>>,\n                                   suffix: &'tcx Vec<P<hir::Pat>>)\n-                                  -> PatternKind<Cx<'a,'tcx>>\n+                                  -> PatternKind<'tcx>\n     {\n         match ty.sty {\n             ty::TySlice(..) =>\n@@ -107,8 +107,8 @@ impl<'tcx> PatNode<'tcx> {\n \n     fn variant_or_leaf<'a>(&self,\n                            cx: &mut Cx<'a, 'tcx>,\n-                           subpatterns: Vec<FieldPatternRef<Cx<'a,'tcx>>>)\n-                           -> PatternKind<Cx<'a,'tcx>>\n+                           subpatterns: Vec<FieldPatternRef<'tcx>>)\n+                           -> PatternKind<'tcx>\n     {\n         let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n         match def {\n@@ -138,10 +138,10 @@ impl<'tcx> PatNode<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for PatNode<'tcx> {\n-    type Output = Pattern<Cx<'a,'tcx>>;\n+impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n+    type Output = Pattern<'tcx>;\n \n-    fn make_mirror(self, cx: &mut Cx<'a,'tcx>) -> Pattern<Cx<'a,'tcx>> {\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a,'tcx>) -> Pattern<'tcx> {\n         let kind = match self.pat.node {\n             hir::PatWild(..) =>\n                 PatternKind::Wild,"}, {"sha": "7da8d7deefd24d7836336bb6bc4a53e5643752a2", "filename": "src/librustc_mir/tcx/to_ref.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02ddff816f7d599f9a4b884fca25c1380d1aae6/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs?ref=e02ddff816f7d599f9a4b884fca25c1380d1aae6", "patch": "@@ -11,58 +11,57 @@\n use hair::*;\n use repr::*;\n \n-use tcx::Cx;\n use tcx::pattern::PatNode;\n-use tcx::rustc_front::hir;\n-use tcx::syntax::ptr::P;\n+use rustc_front::hir;\n+use syntax::ptr::P;\n \n-pub trait ToRef<H> {\n+pub trait ToRef {\n     type Output;\n     fn to_ref(self) -> Self::Output;\n }\n \n-impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for &'tcx hir::Expr {\n-    type Output = ExprRef<Cx<'a,'tcx>>;\n+impl<'a,'tcx:'a> ToRef for &'tcx hir::Expr {\n+    type Output = ExprRef<'tcx>;\n \n-    fn to_ref(self) -> ExprRef<Cx<'a,'tcx>> {\n+    fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for &'tcx P<hir::Expr> {\n-    type Output = ExprRef<Cx<'a,'tcx>>;\n+impl<'a,'tcx:'a> ToRef for &'tcx P<hir::Expr> {\n+    type Output = ExprRef<'tcx>;\n \n-    fn to_ref(self) -> ExprRef<Cx<'a,'tcx>> {\n+    fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(&**self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for Expr<Cx<'a,'tcx>> {\n-    type Output = ExprRef<Cx<'a,'tcx>>;\n+impl<'a,'tcx:'a> ToRef for Expr<'tcx> {\n+    type Output = ExprRef<'tcx>;\n \n-    fn to_ref(self) -> ExprRef<Cx<'a,'tcx>> {\n+    fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Mirror(Box::new(self))\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for PatNode<'tcx> {\n-    type Output = PatternRef<Cx<'a,'tcx>>;\n+impl<'a,'tcx:'a> ToRef for PatNode<'tcx> {\n+    type Output = PatternRef<'tcx>;\n \n-    fn to_ref(self) -> PatternRef<Cx<'a,'tcx>> {\n+    fn to_ref(self) -> PatternRef<'tcx> {\n         PatternRef::Hair(self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for Pattern<Cx<'a,'tcx>> {\n-    type Output = PatternRef<Cx<'a,'tcx>>;\n+impl<'a,'tcx:'a> ToRef for Pattern<'tcx> {\n+    type Output = PatternRef<'tcx>;\n \n-    fn to_ref(self) -> PatternRef<Cx<'a,'tcx>> {\n+    fn to_ref(self) -> PatternRef<'tcx> {\n         PatternRef::Mirror(Box::new(self))\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef<Cx<'a,'tcx>> for &'tcx Option<T>\n-    where &'tcx T: ToRef<Cx<'a,'tcx>, Output=U>\n+impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n+    where &'tcx T: ToRef<Output=U>\n {\n     type Output = Option<U>;\n \n@@ -71,8 +70,8 @@ impl<'a,'tcx:'a,T,U> ToRef<Cx<'a,'tcx>> for &'tcx Option<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef<Cx<'a,'tcx>> for &'tcx Vec<T>\n-    where &'tcx T: ToRef<Cx<'a,'tcx>, Output=U>\n+impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n+    where &'tcx T: ToRef<Output=U>\n {\n     type Output = Vec<U>;\n \n@@ -81,10 +80,10 @@ impl<'a,'tcx:'a,T,U> ToRef<Cx<'a,'tcx>> for &'tcx Vec<T>\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for &'tcx hir::Field {\n-    type Output = FieldExprRef<Cx<'a,'tcx>>;\n+impl<'a,'tcx:'a> ToRef for &'tcx hir::Field {\n+    type Output = FieldExprRef<'tcx>;\n \n-    fn to_ref(self) -> FieldExprRef<Cx<'a,'tcx>> {\n+    fn to_ref(self) -> FieldExprRef<'tcx> {\n         FieldExprRef {\n             name: Field::Named(self.name.node),\n             expr: self.expr.to_ref()"}]}