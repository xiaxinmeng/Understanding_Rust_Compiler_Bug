{"sha": "a33d1b8f1dd9898858bb65bd32c633e3cd63be9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzM2QxYjhmMWRkOTg5ODg1OGJiNjViZDMyYzYzM2UzY2Q2M2JlOWQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-10T16:35:38Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-19T05:57:38Z"}, "message": "debuginfo: Major code cleanup in debuginfo.rs", "tree": {"sha": "3817652d8a6c9b3bf8bfff0139074cd804402f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3817652d8a6c9b3bf8bfff0139074cd804402f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a33d1b8f1dd9898858bb65bd32c633e3cd63be9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a33d1b8f1dd9898858bb65bd32c633e3cd63be9d", "html_url": "https://github.com/rust-lang/rust/commit/a33d1b8f1dd9898858bb65bd32c633e3cd63be9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a33d1b8f1dd9898858bb65bd32c633e3cd63be9d/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12d87d39c1baebcce28ebff095bc811cd3d7402f", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d87d39c1baebcce28ebff095bc811cd3d7402f", "html_url": "https://github.com/rust-lang/rust/commit/12d87d39c1baebcce28ebff095bc811cd3d7402f"}], "stats": {"total": 523, "additions": 266, "deletions": 257}, "files": [{"sha": "f6b5cffae7cd42f59d5c382cd0ca7539dc34c6b8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a33d1b8f1dd9898858bb65bd32c633e3cd63be9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33d1b8f1dd9898858bb65bd32c633e3cd63be9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a33d1b8f1dd9898858bb65bd32c633e3cd63be9d", "patch": "@@ -1142,7 +1142,7 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n                     bcx = init_local(bcx, *local);\n                     if cx.sess().opts.extra_debuginfo\n                         && fcx_has_nonzero_span(bcx.fcx) {\n-                        debuginfo::create_local_var(bcx, *local);\n+                        debuginfo::create_local_var_metadata(bcx, *local);\n                     }\n                 }\n                 ast::decl_item(i) => trans_item(cx.fcx.ccx, i)\n@@ -1774,7 +1774,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n-            debuginfo::create_arg(bcx, &args[arg_n], args[arg_n].ty.span);\n+            debuginfo::create_argument_metadata(bcx, &args[arg_n], args[arg_n].ty.span);\n         }\n     }\n \n@@ -1948,7 +1948,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   |fcx| {\n                       if ccx.sess.opts.extra_debuginfo\n                           && fcx_has_nonzero_span(fcx) {\n-                          debuginfo::create_function(fcx);\n+                          debuginfo::create_function_metadata(fcx);\n                       }\n                   },\n                   |_bcx| { });"}, {"sha": "48ab05661781f1fc368472c10d89269dd772bd84", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 263, "deletions": 254, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/a33d1b8f1dd9898858bb65bd32c633e3cd63be9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33d1b8f1dd9898858bb65bd32c633e3cd63be9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a33d1b8f1dd9898858bb65bd32c633e3cd63be9d", "patch": "@@ -27,7 +27,7 @@ where possible. This will hopefully ease the adaption of this module to future L\n \n The public API of the module is a set of functions that will insert the correct metadata into the\n LLVM IR when called with the right parameters. The module is thus driven from an outside client with\n-functions like `debuginfo::create_local_var(bcx: block, local: @ast::local)`.\n+functions like `debuginfo::create_local_var_metadata(bcx: block, local: @ast::local)`.\n \n Internally the module will try to reuse already created metadata by utilizing a cache. All private\n state used by the module is stored within a DebugContext struct, which in turn is contained in the\n@@ -44,7 +44,7 @@ This file consists of three conceptual sections:\n \n use driver::session;\n use lib::llvm::llvm;\n-use lib::llvm::{ValueRef, ModuleRef, ContextRef};\n+use lib::llvm::{ModuleRef, ContextRef};\n use lib::llvm::debuginfo::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n@@ -58,7 +58,6 @@ use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::str::as_c_str;\n-use std::sys;\n use std::vec;\n use syntax::codemap::span;\n use syntax::{ast, codemap, ast_util, ast_map};\n@@ -116,7 +115,7 @@ impl DebugContext {\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: @mut CrateContext) {\n     debug!(\"finalize\");\n-    create_compile_unit(cx);\n+    create_compile_unit_metadata(cx);\n     unsafe {\n         llvm::LLVMDIBuilderFinalize(DIB(cx));\n         llvm::LLVMDIBuilderDispose(DIB(cx));\n@@ -127,7 +126,7 @@ pub fn finalize(cx: @mut CrateContext) {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n+pub fn create_local_var_metadata(bcx: block, local: @ast::local) -> DIVariable {\n     let cx = bcx.ccx();\n \n     let ident = match local.node.pat.node {\n@@ -138,23 +137,32 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n         return ptr::null();\n       }\n     };\n+\n     let name: &str = cx.sess.str_of(ident);\n-    debug!(\"create_local_var: %s\", name);\n+    debug!(\"create_local_var_metadata: %s\", name);\n \n     let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n-    let tymd = get_or_create_type(cx, ty, local.node.ty.span);\n-    let filemd = get_or_create_file(cx, loc.file.name);\n+    let type_metadata = get_or_create_type_metadata(cx, ty, local.node.ty.span);\n+    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+\n     let context = match bcx.parent {\n-        None => create_function(bcx.fcx),\n-        Some(_) => get_or_create_block(bcx)\n+        None => create_function_metadata(bcx.fcx),\n+        Some(_) => get_or_create_block_metadata(bcx)\n     };\n \n-    let var_md = do as_c_str(name) |name| { unsafe {\n+    let var_metadata = do as_c_str(name) |name| { unsafe {\n         llvm::LLVMDIBuilderCreateLocalVariable(\n-            DIB(cx), AutoVariableTag as u32,\n-            context, name, filemd,\n-            loc.line as c_uint, tymd, false, 0, 0)\n+            DIB(cx),\n+            AutoVariableTag as u32,\n+            context,\n+            name,\n+            file_metadata,\n+            loc.line as c_uint,\n+            type_metadata,\n+            false,\n+            0,\n+            0)\n         }};\n \n     // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n@@ -167,24 +175,25 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n         }\n     };\n \n-    set_debug_location(cx, get_or_create_block(bcx), loc.line, loc.col.to_uint());\n+    set_debug_location(cx, get_or_create_block_metadata(bcx), loc.line, loc.col.to_uint());\n     unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_metadata, bcx.llbb);\n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n     }\n \n-    return var_md;\n+    return var_metadata;\n }\n \n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n-    debug!(\"create_arg\");\n+pub fn create_argument_metadata(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n+    debug!(\"create_argument_metadata\");\n     if true {\n-        // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n-        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n+        // XXX create_argument_metadata disabled for now because \"node_id_type(bcx, arg.id)\" below\n+        // blows up:\n+        // \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n         return None;\n     }\n \n@@ -197,38 +206,38 @@ pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable>\n     }\n \n     let ty = node_id_type(bcx, arg.id);\n-    let tymd = get_or_create_type(cx, ty, arg.ty.span);\n-    let filemd = get_or_create_file(cx, loc.file.name);\n-    let context = create_function(fcx);\n+    let type_metadata = get_or_create_type_metadata(cx, ty, arg.ty.span);\n+    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+    let context = create_function_metadata(fcx);\n \n     match arg.pat.node {\n         ast::pat_ident(_, ref path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n-            let mdnode = do as_c_str(name) |name| { unsafe {\n+            let var_metadata = do as_c_str(name) |name| { unsafe {\n                 llvm::LLVMDIBuilderCreateLocalVariable(\n                     DIB(cx),\n                     ArgVariableTag as u32,\n                     context,\n                     name,\n-                    filemd,\n+                    file_metadata,\n                     loc.line as c_uint,\n-                    tymd,\n+                    type_metadata,\n                     false,\n                     0,\n                     0)\n                     // XXX need to pass in a real argument number\n             }};\n \n             let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, get_or_create_block(bcx), loc.line, loc.col.to_uint());\n+            set_debug_location(cx, get_or_create_block_metadata(bcx), loc.line, loc.col.to_uint());\n             unsafe {\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                        DIB(cx), llptr, mdnode, bcx.llbb);\n+                        DIB(cx), llptr, var_metadata, bcx.llbb);\n                 llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n             }\n-            return Some(mdnode);\n+            return Some(var_metadata);\n         }\n         _ => {\n             return None;\n@@ -245,14 +254,14 @@ pub fn update_source_pos(bcx: block, span: span) {\n     }\n     debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n     let loc = span_start(bcx.ccx(), span);\n-    set_debug_location(bcx.ccx(), get_or_create_block(bcx), loc.line, loc.col.to_uint())\n+    set_debug_location(bcx.ccx(), get_or_create_block_metadata(bcx), loc.line, loc.col.to_uint())\n }\n \n /// Creates debug information for the given function.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n+pub fn create_function_metadata(fcx: fn_ctxt) -> DISubprogram {\n     let cx = fcx.ccx;\n     let fcx = &mut *fcx;\n     let span = fcx.span.get();\n@@ -264,7 +273,8 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n           ast::item_fn(ast::fn_decl { output: ref ty, _}, _, _, _, _) => {\n             (item.ident, ty, item.id)\n           }\n-          _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n+          _ => fcx.ccx.sess.span_bug(item.span,\n+                                     \"create_function_metadata: item bound to non-function\")\n         }\n       }\n       ast_map::node_method(@ast::method { decl: ast::fn_decl { output: ref ty, _ },\n@@ -278,26 +288,28 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n             (name, &decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n-                  \"create_function: expected an expr_fn_block here\")\n+                  \"create_function_metadata: expected an expr_fn_block here\")\n         }\n       }\n-      _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n+      _ => fcx.ccx.sess.bug(\"create_function_metadata: unexpected sort of node\")\n     };\n \n     match dbg_cx(cx).created_functions.find(&id) {\n-        Some(fn_md) => return *fn_md,\n+        Some(fn_metadata) => return *fn_metadata,\n         None => ()\n     }\n \n-    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n+    debug!(\"create_function_metadata: %s, %s\",\n+           cx.sess.str_of(ident),\n+           cx.sess.codemap.span_to_str(span));\n \n     let loc = span_start(cx, span);\n-    let file_md = get_or_create_file(cx, loc.file.name);\n+    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n \n-    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n+    let return_type_metadata = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => ptr::null(),\n-          _ => get_or_create_type(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n+          _ => get_or_create_type_metadata(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n         }\n     } else {\n         ptr::null()\n@@ -306,19 +318,19 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let fn_ty = unsafe {\n         llvm::LLVMDIBuilderCreateSubroutineType(\n             DIB(cx),\n-            file_md,\n-            create_DIArray(DIB(cx), [ret_ty_md]))\n+            file_metadata,\n+            create_DIArray(DIB(cx), [return_type_metadata]))\n     };\n \n-    let fn_md =\n+    let fn_metadata =\n         do as_c_str(cx.sess.str_of(ident)) |name| {\n         do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n             llvm::LLVMDIBuilderCreateFunction(\n                 DIB(cx),\n-                file_md,\n+                file_metadata,\n                 name,\n                 linkage,\n-                file_md,\n+                file_metadata,\n                 loc.line as c_uint,\n                 fn_ty,\n                 false,\n@@ -331,8 +343,8 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n                 ptr::null())\n             }}};\n \n-    dbg_cx(cx).created_functions.insert(id, fn_md);\n-    return fn_md;\n+    dbg_cx(cx).created_functions.insert(id, fn_metadata);\n+    return fn_metadata;\n }\n \n \n@@ -348,11 +360,11 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-fn create_compile_unit(cx: @mut CrateContext) {\n+fn create_compile_unit_metadata(cx: @mut CrateContext) {\n     let dcx = dbg_cx(cx);\n     let crate_name: &str = dcx.crate_file;\n \n-    debug!(\"create_compile_unit: %?\", crate_name);\n+    debug!(\"create_compile_unit_metadata: %?\", crate_name);\n \n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n@@ -369,13 +381,13 @@ fn create_compile_unit(cx: @mut CrateContext) {\n     }}}}}};\n }\n \n-fn get_or_create_file(cx: &mut CrateContext, full_path: &str) -> DIFile {\n+fn get_or_create_file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n     match dbg_cx(cx).created_files.find_equiv(&full_path) {\n-        Some(file_md) => return *file_md,\n+        Some(file_metadata) => return *file_metadata,\n         None => ()\n     }\n \n-    debug!(\"get_or_create_file: %s\", full_path);\n+    debug!(\"get_or_create_file_metadata: %s\", full_path);\n \n     let work_dir = cx.sess.working_dir.to_str();\n     let file_name =\n@@ -385,19 +397,17 @@ fn get_or_create_file(cx: &mut CrateContext, full_path: &str) -> DIFile {\n             full_path\n         };\n \n-    let file_md =\n+    let file_metadata =\n         do as_c_str(file_name) |file_name| {\n         do as_c_str(work_dir) |work_dir| { unsafe {\n             llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n         }}};\n \n-    dbg_cx(cx).created_files.insert(full_path.to_owned(), file_md);\n-    return file_md;\n+    dbg_cx(cx).created_files.insert(full_path.to_owned(), file_metadata);\n+    return file_metadata;\n }\n \n-\n-\n-fn get_or_create_block(bcx: block) -> DILexicalBlock {\n+fn get_or_create_block_metadata(bcx: block) -> DILexicalBlock {\n     let mut bcx = bcx;\n     let cx = bcx.ccx();\n \n@@ -415,33 +425,31 @@ fn get_or_create_block(bcx: block) -> DILexicalBlock {\n         None => ()\n     }\n \n-    debug!(\"get_or_create_block: %s\", bcx.sess().codemap.span_to_str(span));\n+    debug!(\"get_or_create_block_metadata: %s\", bcx.sess().codemap.span_to_str(span));\n \n     let parent = match bcx.parent {\n-        None => create_function(bcx.fcx),\n-        Some(b) => get_or_create_block(b)\n+        None => create_function_metadata(bcx.fcx),\n+        Some(b) => get_or_create_block_metadata(b)\n     };\n     let cx = bcx.ccx();\n     let loc = span_start(cx, span);\n-    let file_md = get_or_create_file(cx, loc.file.name);\n+    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n \n-    let block_md = unsafe {\n+    let block_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n             DIB(cx),\n-            parent, file_md,\n+            parent, file_metadata,\n             loc.line as c_uint, loc.col.to_uint() as c_uint)\n     };\n \n-    dbg_cx(cx).created_blocks.insert(id, block_md);\n+    dbg_cx(cx).created_blocks.insert(id, block_metadata);\n \n-    return block_md;\n+    return block_metadata;\n }\n \n+fn create_basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n-\n-fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n-\n-    debug!(\"create_basic_type: %?\", ty::get(t));\n+    debug!(\"create_basic_type_metadata: %?\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n@@ -466,11 +474,12 @@ fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n             ast::ty_f32 => (~\"f32\", DW_ATE_float),\n             ast::ty_f64 => (~\"f64\", DW_ATE_float)\n         },\n-        _ => cx.sess.bug(\"debuginfo::create_basic_type - t is invalid type\")\n+        _ => cx.sess.bug(\"debuginfo::create_basic_type_metadata - t is invalid type\")\n     };\n \n-    let (size, align) = size_and_align_of(cx, t);\n-    let ty_md = do as_c_str(name) |name| { unsafe {\n+    let llvm_type = type_of::type_of(cx, t);\n+    let (size, align) = size_and_align_of(cx, llvm_type);\n+    let ty_metadata = do as_c_str(name) |name| { unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n                 name,\n@@ -479,38 +488,44 @@ fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n                 encoding as c_uint)\n         }};\n \n-    return ty_md;\n+    return ty_metadata;\n }\n \n-fn create_pointer_type(cx: &mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n-    let (size, align) = size_and_align_of(cx, t);\n-    let name = ty_to_str(cx.tcx, t);\n-    let ptr_md = do as_c_str(name) |name| { unsafe {\n+fn create_pointer_type_metadata(cx: &mut CrateContext,\n+                                pointer_type: ty::t,\n+                                pointee_type_metadata: DIType)\n+                             -> DIType {\n+    let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n+    let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n+    let name = ty_to_str(cx.tcx, pointer_type);\n+    let ptr_metadata = do as_c_str(name) |name| { unsafe {\n         llvm::LLVMDIBuilderCreatePointerType(\n             DIB(cx),\n-            pointee,\n-            bytes_to_bits(size),\n-            bytes_to_bits(align),\n+            pointee_type_metadata,\n+            bytes_to_bits(pointer_size),\n+            bytes_to_bits(pointer_align),\n             name)\n-    }};\n-    return ptr_md;\n+        }};\n+    return ptr_metadata;\n }\n \n-fn create_struct(cx: &mut CrateContext,\n-                 struct_type: ty::t,\n-                 fields: ~[ty::field],\n-                 span: span)\n-              -> DICompositeType {\n+fn create_struct_metadata(cx: &mut CrateContext,\n+                          struct_type: ty::t,\n+                          fields: ~[ty::field],\n+                          span: span)\n+                       -> DICompositeType {\n     let struct_name = ty_to_str(cx.tcx, struct_type);\n-    debug!(\"create_struct: %s\", struct_name);\n+    debug!(\"create_struct_metadata: %s\", struct_name);\n \n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n-    let field_llvm_types = fields.map(|field| type_of::type_of(cx, field.mt.ty));\n-    let field_names = fields.map(|field| cx.sess.str_of(field.ident).to_owned());\n-    let field_types_metadata = fields.map(|field| get_or_create_type(cx, field.mt.ty, span));\n+    let field_llvm_types = do fields.map |field| { type_of::type_of(cx, field.mt.ty) };\n+    let field_names = do fields.map |field| { cx.sess.str_of(field.ident).to_owned() };\n+    let field_types_metadata = do fields.map |field| {\n+        get_or_create_type_metadata(cx, field.mt.ty, span)\n+    };\n \n-    return create_composite_type(\n+    return create_composite_type_metadata(\n         cx,\n         struct_llvm_type,\n         struct_name,\n@@ -520,22 +535,22 @@ fn create_struct(cx: &mut CrateContext,\n         span);\n }\n \n-fn create_tuple(cx: &mut CrateContext,\n-                tuple_type: ty::t,\n-                component_types: &[ty::t],\n-                span: span)\n-             -> DICompositeType {\n+fn create_tuple_metadata(cx: &mut CrateContext,\n+                         tuple_type: ty::t,\n+                         component_types: &[ty::t],\n+                         span: span)\n+                      -> DICompositeType {\n \n     let tuple_name = ty_to_str(cx.tcx, tuple_type);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n-    // Create a vec of empty strings. A vec::build_n() function would be nice for this.\n-    let mut component_names : ~[~str] = vec::with_capacity(component_types.len());\n-    component_names.grow_fn(component_types.len(), |_| ~\"\");\n \n-    let component_llvm_types = component_types.map(|it| type_of::type_of(cx, *it));\n-    let component_types_metadata = component_types.map(|it| get_or_create_type(cx, *it, span));\n+    let component_names = do component_types.map |_| { ~\"\" };\n+    let component_llvm_types = do component_types.map |it| { type_of::type_of(cx, *it) };\n+    let component_types_metadata = do component_types.map |it| {\n+        get_or_create_type_metadata(cx, *it, span)\n+    };\n \n-    return create_composite_type(\n+    return create_composite_type_metadata(\n         cx,\n         tuple_llvm_type,\n         tuple_name,\n@@ -545,50 +560,50 @@ fn create_tuple(cx: &mut CrateContext,\n         span);\n }\n \n-fn create_enum_md(cx: &mut CrateContext,\n-                  enum_type: ty::t,\n-                  enum_def_id: ast::def_id,\n-                  substs: &ty::substs,\n-                  span: span)\n-               -> DIType {\n+fn create_enum_metadata(cx: &mut CrateContext,\n+                        enum_type: ty::t,\n+                        enum_def_id: ast::def_id,\n+                        substs: &ty::substs,\n+                        span: span)\n+                     -> DIType {\n \n     let enum_name = ty_to_str(cx.tcx, enum_type);\n \n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n-    // appropriate name\n+    // appropriate type name\n     if ty::type_is_empty(cx.tcx, enum_type) {\n-        return create_composite_type(cx, Type::nil(), enum_name, &[], &[], &[], span);\n+        return create_composite_type_metadata(cx, Type::nil(), enum_name, &[], &[], &[], span);\n     }\n \n     // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n     // needed in all of the following cases.\n     let discriminant_llvm_type = Type::enum_discrim(cx);\n-    let discriminant_size = machine::llsize_of_alloc(cx, discriminant_llvm_type);\n-    let discriminant_align = machine::llalign_of_min(cx, discriminant_llvm_type);\n+    let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n+\n     assert!(Type::enum_discrim(cx) == cx.int_type);\n-    let discriminant_type_md = get_or_create_type(cx, ty::mk_int(), span);\n+    let discriminant_type_metadata = get_or_create_type_metadata(cx, ty::mk_int(), span);\n \n-    let variants : &[ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+    let variants : &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n \n-    let enumerators : ~[(~str, int)] = variants\n+    let enumerators_metadata : ~[DIDescriptor] = variants\n         .iter()\n-        .transform(|v| (cx.sess.str_of(v.name).to_owned(), v.disr_val))\n-        .collect();\n+        .transform(|v| {\n+            let name : &str = cx.sess.str_of(v.name);\n+            let discriminant_value = v.disr_val as c_ulonglong;\n \n-    let enumerators_md : ~[DIDescriptor] =\n-        do enumerators.iter().transform |&(name,value)| {\n             do name.as_c_str |name| { unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name,\n-                    value as c_ulonglong)\n+                    discriminant_value)\n             }}\n-        }.collect();\n+        })\n+        .collect();\n \n     let loc = span_start(cx, span);\n-    let file_metadata = get_or_create_file(cx, loc.file.name);\n+    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n \n-    let discriminant_type_md = do enum_name.as_c_str |enum_name| { unsafe {\n+    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| { unsafe {\n         llvm::LLVMDIBuilderCreateEnumerationType(\n             DIB(cx),\n             file_metadata,\n@@ -597,17 +612,17 @@ fn create_enum_md(cx: &mut CrateContext,\n             loc.line as c_uint,\n             bytes_to_bits(discriminant_size),\n             bytes_to_bits(discriminant_align),\n-            create_DIArray(DIB(cx), enumerators_md),\n-            discriminant_type_md)\n+            create_DIArray(DIB(cx), enumerators_metadata),\n+            discriminant_type_metadata)\n     }};\n \n     if ty::type_is_c_like_enum(cx.tcx, enum_type) {\n-        return discriminant_type_md;\n+        return discriminant_type_metadata;\n     }\n \n     let is_univariant = variants.len() == 1;\n \n-    let variants_md = do variants.map |&vi| {\n+    let variants_metadata = do variants.map |&vi| {\n \n         let raw_types : &[ty::t] = vi.args;\n         let arg_types = do raw_types.map |&raw_type| { ty::subst(cx.tcx, substs, raw_type) };\n@@ -618,25 +633,24 @@ fn create_enum_md(cx: &mut CrateContext,\n             None => do arg_types.map |_| { ~\"\" }\n         };\n \n-        let mut arg_md = do arg_types.map |&ty| { get_or_create_type(cx, ty, span) };\n+        let mut arg_metadata = do arg_types.map |&ty| { get_or_create_type_metadata(cx, ty, span) };\n \n         if !is_univariant {\n             arg_llvm_types.insert(0, discriminant_llvm_type);\n             arg_names.insert(0, ~\"\");\n-            arg_md.insert(0, discriminant_type_md);\n+            arg_metadata.insert(0, discriminant_type_metadata);\n         }\n \n         let variant_llvm_type = Type::struct_(arg_llvm_types, false);\n-        let variant_type_size = machine::llsize_of_alloc(cx, variant_llvm_type);\n-        let variant_type_align = machine::llalign_of_min(cx, variant_llvm_type);\n+        let (variant_type_size, variant_type_align) = size_and_align_of(cx, variant_llvm_type);\n \n-        let variant_type_md = create_composite_type(\n+        let variant_type_metadata = create_composite_type_metadata(\n             cx,\n             variant_llvm_type,\n             &\"\",\n             arg_llvm_types,\n             arg_names,\n-            arg_md,\n+            arg_metadata,\n             span);\n \n         do \"\".as_c_str |name| { unsafe {\n@@ -650,13 +664,12 @@ fn create_enum_md(cx: &mut CrateContext,\n                 bytes_to_bits(variant_type_align),\n                 bytes_to_bits(0),\n                 0,\n-                variant_type_md)\n+                variant_type_metadata)\n         }}\n     };\n \n     let enum_llvm_type = type_of::type_of(cx, enum_type);\n-    let enum_type_size = machine::llsize_of_alloc(cx, enum_llvm_type);\n-    let enum_type_align = machine::llalign_of_min(cx, enum_llvm_type);\n+    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n     return do enum_name.as_c_str |enum_name| { unsafe { llvm::LLVMDIBuilderCreateUnionType(\n         DIB(cx),\n@@ -667,7 +680,7 @@ fn create_enum_md(cx: &mut CrateContext,\n         bytes_to_bits(enum_type_size),\n         bytes_to_bits(enum_type_align),\n         0, // Flags\n-        create_DIArray(DIB(cx), variants_md),\n+        create_DIArray(DIB(cx), variants_metadata),\n         0) // RuntimeLang\n     }};\n }\n@@ -676,27 +689,25 @@ fn create_enum_md(cx: &mut CrateContext,\n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn create_composite_type(cx: &mut CrateContext,\n-                         composite_llvm_type: Type,\n-                         composite_type_name: &str,\n-                         member_llvm_types: &[Type],\n-                         member_names: &[~str],\n-                         member_type_metadata: &[DIType],\n-                         span: span)\n-                      -> DICompositeType {\n+fn create_composite_type_metadata(cx: &mut CrateContext,\n+                                  composite_llvm_type: Type,\n+                                  composite_type_name: &str,\n+                                  member_llvm_types: &[Type],\n+                                  member_names: &[~str],\n+                                  member_type_metadata: &[DIType],\n+                                  span: span)\n+                               -> DICompositeType {\n \n     let loc = span_start(cx, span);\n-    let file_metadata = get_or_create_file(cx, loc.file.name);\n+    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n \n-    let composite_size = machine::llsize_of_alloc(cx, composite_llvm_type);\n-    let composite_align = machine::llalign_of_min(cx, composite_llvm_type);\n+    let (composite_size, composite_align) = size_and_align_of(cx, composite_llvm_type);\n \n     let member_metadata : ~[DIDescriptor] = member_llvm_types\n         .iter()\n         .enumerate()\n-        .transform(|(i, member_llvm_type)| {\n-            let member_size = machine::llsize_of_alloc(cx, *member_llvm_type);\n-            let member_align = machine::llalign_of_min(cx, *member_llvm_type);\n+        .transform(|(i, &member_llvm_type)| {\n+            let (member_size, member_align) = size_and_align_of(cx, member_llvm_type);\n             let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n             let member_name : &str = member_names[i];\n \n@@ -733,26 +744,11 @@ fn create_composite_type(cx: &mut CrateContext,\n     }};\n }\n \n-// returns (void* type as a ValueRef, size in bytes, align in bytes)\n-fn voidptr(cx: &mut CrateContext) -> (DIDerivedType, uint, uint) {\n-    let size = sys::size_of::<ValueRef>();\n-    let align = sys::min_align_of::<ValueRef>();\n-    let vp = do as_c_str(\"*void\") |name| { unsafe {\n-            llvm::LLVMDIBuilderCreatePointerType(\n-                DIB(cx),\n-                ptr::null(),\n-                bytes_to_bits(size),\n-                bytes_to_bits(align),\n-                name)\n-        }};\n-    return (vp, size, align);\n-}\n-\n-fn create_boxed_type(cx: &mut CrateContext,\n-                     content_llvm_type: Type,\n-                     content_type_metadata: DIType,\n-                     span: span)\n-                  -> DICompositeType {\n+fn create_boxed_type_metadata(cx: &mut CrateContext,\n+                              content_llvm_type: Type,\n+                              content_type_metadata: DIType,\n+                              span: span)\n+                           -> DICompositeType {\n \n     let box_llvm_type = Type::box(cx, &content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n@@ -764,14 +760,14 @@ fn create_boxed_type(cx: &mut CrateContext,\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n \n     let member_types_metadata = [\n-        get_or_create_type(cx, int_type, span),\n-        get_or_create_type(cx, nil_pointer_type, span),\n-        get_or_create_type(cx, nil_pointer_type, span),\n-        get_or_create_type(cx, nil_pointer_type, span),\n+        get_or_create_type_metadata(cx, int_type, span),\n+        get_or_create_type_metadata(cx, nil_pointer_type, span),\n+        get_or_create_type_metadata(cx, nil_pointer_type, span),\n+        get_or_create_type_metadata(cx, nil_pointer_type, span),\n         content_type_metadata\n     ];\n \n-    return create_composite_type(\n+    return create_composite_type_metadata(\n         cx,\n         box_llvm_type,\n         \"box name\",\n@@ -795,12 +791,14 @@ fn create_boxed_type(cx: &mut CrateContext,\n     }\n }\n \n-fn create_fixed_vec(cx: &mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n-                    len: uint, span: span) -> DIType {\n-    debug!(\"create_fixed_vec: %?\", ty::get(_vec_t));\n-\n-    let elem_ty_md = get_or_create_type(cx, elem_t, span);\n-    let (size, align) = size_and_align_of(cx, elem_t);\n+fn create_fixed_vec_metadata(cx: &mut CrateContext,\n+                             element_type: ty::t,\n+                             len: uint,\n+                             span: span)\n+                          -> DIType {\n+    let element_type_metadata = get_or_create_type_metadata(cx, element_type, span);\n+    let element_llvm_type = type_of::type_of(cx, element_type);\n+    let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n \n     let subrange = unsafe { llvm::LLVMDIBuilderGetOrCreateSubrange(\n         DIB(cx),\n@@ -811,39 +809,41 @@ fn create_fixed_vec(cx: &mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n     return unsafe { llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n-            bytes_to_bits(size * len),\n-            bytes_to_bits(align),\n-            elem_ty_md,\n+            bytes_to_bits(element_type_size * len),\n+            bytes_to_bits(element_type_align),\n+            element_type_metadata,\n             subscripts\n     )};\n }\n \n-fn create_boxed_vec(cx: &mut CrateContext,\n-                    element_type: ty::t,\n-                    span: span)\n-                 -> DICompositeType {\n+fn create_boxed_vec_metadata(cx: &mut CrateContext,\n+                             element_type: ty::t,\n+                             span: span)\n+                          -> DICompositeType {\n \n-    let element_type_metadata = get_or_create_type(cx, element_type, span);\n+    let element_type_metadata = get_or_create_type_metadata(cx, element_type, span);\n     let element_llvm_type = type_of::type_of(cx, element_type);\n+    let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n+\n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n     let vec_type_name = &\"vec\";\n \n     let member_llvm_types = vec_llvm_type.field_types();\n     let member_names = &[~\"fill\", ~\"alloc\", ~\"elements\"];\n \n-    let int_type_md = get_or_create_type(cx, ty::mk_int(), span);\n-    let array_type_md = unsafe { llvm::LLVMDIBuilderCreateArrayType(\n+    let int_type_metadata = get_or_create_type_metadata(cx, ty::mk_int(), span);\n+    let array_type_metadata = unsafe { llvm::LLVMDIBuilderCreateArrayType(\n         DIB(cx),\n-        bytes_to_bits(machine::llsize_of_alloc(cx, element_llvm_type)),\n-        bytes_to_bits(machine::llalign_of_min(cx, element_llvm_type)),\n+        bytes_to_bits(element_size),\n+        bytes_to_bits(element_align),\n         element_type_metadata,\n         create_DIArray(DIB(cx), [llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, 0)]))\n     };\n \n     //                           fill         alloc        elements\n-    let member_type_metadata = &[int_type_md, int_type_md, array_type_md];\n+    let member_type_metadata = &[int_type_metadata, int_type_metadata, array_type_metadata];\n \n-    let vec_md = create_composite_type(\n+    let vec_metadata = create_composite_type_metadata(\n         cx,\n         vec_llvm_type,\n         vec_type_name,\n@@ -852,16 +852,16 @@ fn create_boxed_vec(cx: &mut CrateContext,\n         member_type_metadata,\n         span);\n \n-    return create_boxed_type(cx, vec_llvm_type, vec_md, span);\n+    return create_boxed_type_metadata(cx, vec_llvm_type, vec_metadata, span);\n }\n \n-fn create_vec_slice(cx: &mut CrateContext,\n-                    vec_type: ty::t,\n-                    element_type: ty::t,\n-                    span: span)\n-                 -> DICompositeType {\n+fn create_vec_slice_metadata(cx: &mut CrateContext,\n+                             vec_type: ty::t,\n+                             element_type: ty::t,\n+                             span: span)\n+                          -> DICompositeType {\n \n-    debug!(\"create_vec_slice: %?\", ty::get(vec_type));\n+    debug!(\"create_vec_slice_metadata: %?\", ty::get(vec_type));\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n     let slice_type_name = ty_to_str(cx.tcx, vec_type);\n@@ -874,11 +874,11 @@ fn create_vec_slice(cx: &mut CrateContext,\n     let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::m_const });\n \n     let member_type_metadata = &[\n-        get_or_create_type(cx, data_ptr_type, span),\n-        get_or_create_type(cx, ty::mk_uint(), span)\n+        get_or_create_type_metadata(cx, data_ptr_type, span),\n+        get_or_create_type_metadata(cx, ty::mk_uint(), span)\n         ];\n \n-    return create_composite_type(\n+    return create_composite_type_metadata(\n         cx,\n         slice_llvm_type,\n         slice_type_name,\n@@ -897,136 +897,146 @@ fn create_vec_slice(cx: &mut CrateContext,\n     }\n }\n \n-fn create_fn_ty(cx: &mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n-                span: span) -> DICompositeType {\n-    debug!(\"create_fn_ty: %?\", ty::get(_fn_ty));\n+fn create_bare_fn_metadata(cx: &mut CrateContext,\n+                           _fn_ty: ty::t,\n+                           inputs: ~[ty::t],\n+                           output: ty::t,\n+                           span: span)\n+                        -> DICompositeType {\n+\n+    debug!(\"create_bare_fn_metadata: %?\", ty::get(_fn_ty));\n \n     let loc = span_start(cx, span);\n-    let file_md = get_or_create_file(cx, loc.file.name);\n-    let (vp, _, _) = voidptr(cx);\n-    let output_md = get_or_create_type(cx, output, span);\n-    let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n-    let inputs_vals = do inputs.map |arg| { get_or_create_type(cx, *arg, span) };\n-    let members = ~[output_ptr_md, vp] + inputs_vals;\n+    let file_metadata = get_or_create_file_metadata(cx, loc.file.name);\n+\n+    let nil_pointer_type_metadata = get_or_create_type_metadata(cx, ty::mk_nil_ptr(cx.tcx), span);\n+    let output_metadata = get_or_create_type_metadata(cx, output, span);\n+    let output_ptr_metadata = create_pointer_type_metadata(cx, output, output_metadata);\n+\n+    let inputs_vals = do inputs.map |arg| { get_or_create_type_metadata(cx, *arg, span) };\n+    let members = ~[output_ptr_metadata, nil_pointer_type_metadata] + inputs_vals;\n \n     return unsafe {\n         llvm::LLVMDIBuilderCreateSubroutineType(\n             DIB(cx),\n-            file_md,\n+            file_metadata,\n             create_DIArray(DIB(cx), members))\n     };\n }\n \n-fn create_unimpl_ty(cx: &mut CrateContext, t: ty::t) -> DIType {\n-    debug!(\"create_unimpl_ty: %?\", ty::get(t));\n+fn create_unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n+    debug!(\"create_unimplemented_type_metadata: %?\", ty::get(t));\n \n     let name = ty_to_str(cx.tcx, t);\n-    let md = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| { unsafe {\n+    let metadata = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| { unsafe {\n         llvm::LLVMDIBuilderCreateBasicType(\n             DIB(cx),\n             name,\n             0_u64,\n             8_u64,\n             DW_ATE_unsigned as c_uint)\n         }};\n-    return md;\n+    return metadata;\n }\n \n-fn get_or_create_type(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n-    let ty_id = ty::type_id(t);\n-    match dbg_cx(cx).created_types.find(&ty_id) {\n-        Some(ty_md) => return *ty_md,\n+fn get_or_create_type_metadata(cx: &mut CrateContext,\n+                               t: ty::t,\n+                               span: span)\n+                            -> DIType {\n+    let type_id = ty::type_id(t);\n+    match dbg_cx(cx).created_types.find(&type_id) {\n+        Some(type_metadata) => return *type_metadata,\n         None => ()\n     }\n \n-    debug!(\"get_or_create_type: %?\", ty::get(t));\n+    debug!(\"get_or_create_type_metadata: %?\", ty::get(t));\n \n     let sty = copy ty::get(t).sty;\n-    let ty_md = match sty {\n+    let type_metadata = match sty {\n         ty::ty_nil      |\n         ty::ty_bot      |\n         ty::ty_bool     |\n         ty::ty_int(_)   |\n         ty::ty_uint(_)  |\n         ty::ty_float(_) => {\n-            create_basic_type(cx, t, span)\n+            create_basic_type_metadata(cx, t)\n         },\n         ty::ty_estr(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, i8_t, len + 1, span)\n+                    create_fixed_vec_metadata(cx, i8_t, len + 1, span)\n                 },\n                 ty::vstore_uniq |\n                 ty::vstore_box => {\n-                    let box_md = create_boxed_vec(cx, i8_t, span);\n-                    create_pointer_type(cx, t, span, box_md)\n+                    let box_metadata = create_boxed_vec_metadata(cx, i8_t, span);\n+                    create_pointer_type_metadata(cx, t, box_metadata)\n                 }\n                 ty::vstore_slice(_region) => {\n-                    create_vec_slice(cx, t, i8_t, span)\n+                    create_vec_slice_metadata(cx, t, i8_t, span)\n                 }\n             }\n         },\n         ty::ty_enum(def_id, ref substs) => {\n-            create_enum_md(cx, t, def_id, substs, span)\n+            create_enum_metadata(cx, t, def_id, substs, span)\n         },\n         ty::ty_box(ref mt) => {\n             let content_llvm_type = type_of::type_of(cx, mt.ty);\n-            let content_type_metadata = get_or_create_type(cx, mt.ty, span);\n+            let content_type_metadata = get_or_create_type_metadata(cx, mt.ty, span);\n \n-            let box_metadata = create_boxed_type(cx,\n+            let box_metadata = create_boxed_type_metadata(cx,\n                                                  content_llvm_type,\n                                                  content_type_metadata,\n                                                  span);\n \n-            create_pointer_type(cx, t, span, box_metadata)\n+            create_pointer_type_metadata(cx, t, box_metadata)\n         },\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, mt.ty, len, span)\n+                    create_fixed_vec_metadata(cx, mt.ty, len, span)\n                 },\n                 ty::vstore_uniq |\n                 ty::vstore_box  => {\n-                    let box_md = create_boxed_vec(cx, mt.ty, span);\n-                    create_pointer_type(cx, t, span, box_md)\n+                    let box_metadata = create_boxed_vec_metadata(cx, mt.ty, span);\n+                    create_pointer_type_metadata(cx, t, box_metadata)\n                 },\n                 ty::vstore_slice(_) => {\n-                    create_vec_slice(cx, t, mt.ty, span)\n+                    create_vec_slice_metadata(cx, t, mt.ty, span)\n                 }\n             }\n         },\n         ty::ty_uniq(ref mt)    |\n         ty::ty_ptr(ref mt)     |\n         ty::ty_rptr(_, ref mt) => {\n-            let pointee = get_or_create_type(cx, mt.ty, span);\n-            create_pointer_type(cx, t, span, pointee)\n+            let pointee = get_or_create_type_metadata(cx, mt.ty, span);\n+            create_pointer_type_metadata(cx, t, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             let inputs = barefnty.sig.inputs.map(|a| *a);\n             let output = barefnty.sig.output;\n-            create_fn_ty(cx, t, inputs, output, span)\n+            create_bare_fn_metadata(cx, t, inputs, output, span)\n         },\n         ty::ty_closure(ref _closurety) => {\n             cx.sess.span_note(span, \"debuginfo for closure NYI\");\n-            create_unimpl_ty(cx, t)\n+            create_unimplemented_type_metadata(cx, t)\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n             cx.sess.span_note(span, \"debuginfo for trait NYI\");\n-            create_unimpl_ty(cx, t)\n+            create_unimplemented_type_metadata(cx, t)\n         },\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::struct_fields(cx.tcx, did, substs);\n-            create_struct(cx, t, fields, span)\n+            create_struct_metadata(cx, t, fields, span)\n         },\n         ty::ty_tup(ref elements) => {\n-            create_tuple(cx, t, *elements, span)\n+            create_tuple_metadata(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in get_or_create_type\")\n+        _ => cx.sess.bug(\"debuginfo: unexpected type in get_or_create_type_metadata\")\n     };\n \n-    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n-    return ty_md;\n+    dbg_cx(cx).created_types.insert(type_id, type_metadata);\n+    return type_metadata;\n }\n \n fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {\n@@ -1062,9 +1072,8 @@ fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)\n }\n \n-fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (uint, uint) {\n-    let llty = type_of::type_of(cx, t);\n-    (machine::llsize_of_alloc(cx, llty), machine::llalign_of_min(cx, llty))\n+fn size_and_align_of(cx: &mut CrateContext, llvm_type: Type) -> (uint, uint) {\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n }\n \n fn bytes_to_bits(bytes: uint) -> c_ulonglong {"}]}