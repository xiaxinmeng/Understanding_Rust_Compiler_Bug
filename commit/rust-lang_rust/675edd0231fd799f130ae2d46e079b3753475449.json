{"sha": "675edd0231fd799f130ae2d46e079b3753475449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NWVkZDAyMzFmZDc5OWYxMzBhZTJkNDZlMDc5YjM3NTM0NzU0NDk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-02-22T14:21:47Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-03-04T16:53:40Z"}, "message": "Remove RefCell around module_trait_cache", "tree": {"sha": "e0abe85770bb979041612fa466e60d305b580c98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0abe85770bb979041612fa466e60d305b580c98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/675edd0231fd799f130ae2d46e079b3753475449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/675edd0231fd799f130ae2d46e079b3753475449", "html_url": "https://github.com/rust-lang/rust/commit/675edd0231fd799f130ae2d46e079b3753475449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/675edd0231fd799f130ae2d46e079b3753475449/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3c4e25e1740da69686f940165dd3c9d563d54e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c4e25e1740da69686f940165dd3c9d563d54e5", "html_url": "https://github.com/rust-lang/rust/commit/b3c4e25e1740da69686f940165dd3c9d563d54e5"}], "stats": {"total": 54, "additions": 28, "deletions": 26}, "files": [{"sha": "bcbc6e557d0a908921df32948ef45e7e8664394a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/675edd0231fd799f130ae2d46e079b3753475449/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675edd0231fd799f130ae2d46e079b3753475449/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=675edd0231fd799f130ae2d46e079b3753475449", "patch": "@@ -76,7 +76,7 @@ crate struct DocContext<'tcx> {\n     ///\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     /// `map<module, set<trait>>`\n-    crate module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n+    crate module_trait_cache: FxHashMap<DefId, FxHashSet<DefId>>,\n     /// This same cache is used throughout rustdoc, including in [`crate::html::render`].\n     crate cache: Cache,\n     /// Used by [`clean::inline`] to tell if an item has already been inlined.\n@@ -450,7 +450,7 @@ crate fn run_global_ctxt(\n             .cloned()\n             .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n             .collect(),\n-        module_trait_cache: RefCell::new(FxHashMap::default()),\n+        module_trait_cache: FxHashMap::default(),\n         cache: Cache::new(access_levels, render_options.document_private),\n         inlined: FxHashSet::default(),\n         output_format,"}, {"sha": "ec5994b762b8a9e385344e4c264cc87f2d795bf4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/675edd0231fd799f130ae2d46e079b3753475449/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675edd0231fd799f130ae2d46e079b3753475449/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=675edd0231fd799f130ae2d46e079b3753475449", "patch": "@@ -484,21 +484,23 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// Resolves a string as a path within a particular namespace. Returns an\n     /// optional URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n-        &self,\n+        &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = &self.cx;\n+        let tcx = self.cx.tcx;\n \n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n                 // item a separate function.\n                 Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => assert_eq!(ns, ValueNS),\n                 Res::Def(DefKind::AssocTy, _) => assert_eq!(ns, TypeNS),\n-                Res::Def(DefKind::Variant, _) => return handle_variant(cx, res, extra_fragment),\n+                Res::Def(DefKind::Variant, _) => {\n+                    return handle_variant(self.cx, res, extra_fragment);\n+                }\n                 // Not a trait item; just return what we found.\n                 Res::Primitive(ty) => {\n                     if extra_fragment.is_some() {\n@@ -565,13 +567,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ) => {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                 // Checks if item_name belongs to `impl SomeItem`\n-                let assoc_item = cx\n-                    .tcx\n+                let assoc_item = tcx\n                     .inherent_impls(did)\n                     .iter()\n                     .flat_map(|&imp| {\n-                        cx.tcx.associated_items(imp).find_by_name_and_namespace(\n-                            cx.tcx,\n+                        tcx.associated_items(imp).find_by_name_and_namespace(\n+                            tcx,\n                             Ident::with_dummy_span(item_name),\n                             ns,\n                             imp,\n@@ -587,7 +588,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n                         let kind =\n-                            resolve_associated_trait_item(did, module_id, item_name, ns, &self.cx);\n+                            resolve_associated_trait_item(did, module_id, item_name, ns, self.cx);\n                         debug!(\"got associated item kind {:?}\", kind);\n                         kind\n                     });\n@@ -611,7 +612,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n                     // FIXME(jynelson): why is this different from\n                     // `variant_field`?\n-                    match cx.tcx.type_of(did).kind() {\n+                    match tcx.type_of(did).kind() {\n                         ty::Adt(def, _) => {\n                             let field = if def.is_enum() {\n                                 def.all_fields().find(|item| item.ident.name == item_name)\n@@ -652,10 +653,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     None\n                 }\n             }\n-            Res::Def(DefKind::Trait, did) => cx\n-                .tcx\n+            Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n-                .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n+                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n                     let kind = match item.kind {\n                         ty::AssocKind::Const => \"associatedconstant\",\n@@ -699,7 +699,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// This returns the `Res` even if it was erroneous for some reason\n     /// (such as having invalid URL fragments or being in the wrong namespace).\n     fn check_full_res(\n-        &self,\n+        &mut self,\n         ns: Namespace,\n         path_str: &str,\n         module_id: DefId,\n@@ -733,7 +733,7 @@ fn resolve_associated_trait_item(\n     module: DefId,\n     item_name: Symbol,\n     ns: Namespace,\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n ) -> Option<(ty::AssocKind, DefId)> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n@@ -758,10 +758,10 @@ fn resolve_associated_trait_item(\n ///\n /// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n /// So it is not stable to serialize cross-crate.\n-fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n-    let mut cache = cx.module_trait_cache.borrow_mut();\n-    let in_scope_traits = cache.entry(module).or_insert_with(|| {\n-        cx.enter_resolver(|resolver| {\n+fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n+    let mut resolver = cx.resolver.borrow_mut();\n+    let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n+        resolver.access(|resolver| {\n             let parent_scope = &ParentScope::module(resolver.get_module(module), resolver);\n             resolver\n                 .traits_in_scope(None, parent_scope, SyntaxContext::root(), None)\n@@ -771,13 +771,14 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n         })\n     });\n \n-    let ty = cx.tcx.type_of(type_);\n+    let tcx = cx.tcx;\n+    let ty = tcx.type_of(type_);\n     let iter = in_scope_traits.iter().flat_map(|&trait_| {\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n         // Look at each trait implementation to see if it's an impl for `did`\n-        cx.tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n-            let trait_ref = cx.tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n+        tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n+            let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.self_ty();\n             trace!(\n@@ -1308,7 +1309,7 @@ impl LinkCollector<'_, '_> {\n     /// After parsing the disambiguator, resolve the main part of the link.\n     // FIXME(jynelson): wow this is just so much\n     fn resolve_with_disambiguator(\n-        &self,\n+        &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n     ) -> Option<(Res, Option<String>)> {\n@@ -1732,7 +1733,7 @@ fn report_diagnostic(\n /// handled earlier. For example, if passed `Item::Crate(std)` and `path_str`\n /// `std::io::Error::x`, this will resolve `std::io::Error`.\n fn resolution_failure(\n-    collector: &LinkCollector<'_, '_>,\n+    collector: &mut LinkCollector<'_, '_>,\n     item: &Item,\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,"}, {"sha": "23364b6fec9d139de44c4ed212a0d4d2acaadceb", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/675edd0231fd799f130ae2d46e079b3753475449/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675edd0231fd799f130ae2d46e079b3753475449/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=675edd0231fd799f130ae2d46e079b3753475449", "patch": "@@ -178,7 +178,8 @@ impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n         if !dox.is_empty() {\n             let report_diag = |msg: &str, range: &Range<usize>| {\n-                let sp = match super::source_span_for_markdown_range(tcx, &dox, range, &item.attrs) {\n+                let sp = match super::source_span_for_markdown_range(tcx, &dox, range, &item.attrs)\n+                {\n                     Some(sp) => sp,\n                     None => span_of_attrs(&item.attrs).unwrap_or(item.source.span()),\n                 };"}]}