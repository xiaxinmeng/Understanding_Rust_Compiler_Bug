{"sha": "f093d374edb89aedc940468d3d789dd95cec6347", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwOTNkMzc0ZWRiODlhZWRjOTQwNDY4ZDNkNzg5ZGQ5NWNlYzYzNDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-05-22T17:54:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-03T01:30:12Z"}, "message": "rustc: Implement a new resolve pass behind a compile flag", "tree": {"sha": "8d9197ba35866b536c4a5ed8178f69387e4a69af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d9197ba35866b536c4a5ed8178f69387e4a69af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f093d374edb89aedc940468d3d789dd95cec6347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f093d374edb89aedc940468d3d789dd95cec6347", "html_url": "https://github.com/rust-lang/rust/commit/f093d374edb89aedc940468d3d789dd95cec6347", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f093d374edb89aedc940468d3d789dd95cec6347/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b1edb7f0e25cae2a1f519af17bfc76682af0e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b1edb7f0e25cae2a1f519af17bfc76682af0e14", "html_url": "https://github.com/rust-lang/rust/commit/0b1edb7f0e25cae2a1f519af17bfc76682af0e14"}], "stats": {"total": 4499, "additions": 4336, "deletions": 163}, "files": [{"sha": "75a21ad53587cc2c82fcb7ac44af1fa183723ea3", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -27,8 +27,8 @@ io::println(comm::recv(p));\n import either::either;\n import libc::size_t;\n \n-export port::{};\n-export chan::{};\n+export port;\n+export chan;\n export send;\n export recv;\n export peek;"}, {"sha": "f753fa739ae2c00ad11ab199585cc51d97a7dc43", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -200,6 +200,7 @@ impl extensions<A:copy> for dvec<A> {\n         }\n     }\n \n+    /*\n     #[doc = \"\n         Append all elements of an iterable.\n \n@@ -222,6 +223,7 @@ impl extensions<A:copy> for dvec<A> {\n            v\n         }\n     }\n+    */\n \n     #[doc = \"\n         Gets a copy of the current contents.\n@@ -267,7 +269,28 @@ impl extensions<A:copy> for dvec<A> {\n     }\n \n     #[doc = \"Returns the last element, failing if the vector is empty\"]\n+    #[inline(always)]\n     fn last() -> A {\n-        self.get_elt(self.len() - 1u)\n+        self.check_not_borrowed();\n+\n+        let length = self.len();\n+        if length == 0u {\n+            fail \"attempt to retrieve the last element of an empty vector\";\n+        }\n+\n+        ret self.data[length - 1u];\n+    }\n+\n+    #[doc=\"Iterates over the elements in reverse order\"]\n+    #[inline(always)]\n+    fn reach(f: fn(A) -> bool) {\n+        let length = self.len();\n+        let mut i = 0u;\n+        while i < length {\n+            if !f(self.get_elt(i)) {\n+                break;\n+            }\n+            i += 1u;\n+        }\n     }\n }"}, {"sha": "97c6babb89d06a14149e83b062df24e30589acb3", "filename": "src/libcore/future.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -14,7 +14,6 @@ io::println(#fmt(\\\"fib(5000) = %?\\\", delayed_fib.get()))\n import either::either;\n \n export future;\n-export future::{};\n export from_value;\n export from_port;\n export from_fn;"}, {"sha": "79ace3af1e597b9fbd3060dec8e68d05123a4293", "filename": "src/libcore/newcomm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Fnewcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Fnewcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnewcomm.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -6,6 +6,7 @@ avoid needing a single global lock.\"]\n import arc::methods;\n import dvec::dvec;\n import dvec::{extensions};\n+import sys::methods;\n \n export port;\n export chan;"}, {"sha": "884382eb9bd9553bab68895cb64e01d309f191d1", "filename": "src/libcore/task.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -24,14 +24,15 @@ spawn {||\n \n import result::result;\n import dvec::extensions;\n+import dvec_iter::extensions;\n \n export task;\n export task_result;\n export notification;\n export sched_mode;\n export sched_opts;\n export task_opts;\n-export builder::{};\n+export builder;\n \n export default_task_opts;\n export get_opts;"}, {"sha": "45983654eec8970fb5e3d24f3070f2e71e76c4a4", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -8,6 +8,7 @@ import io;\n import io::{reader_util, writer_util};\n import map;\n import map::hashmap;\n+import core::vec::extensions;\n \n export json;\n export error;"}, {"sha": "665b2d38f8f19ea4fb6465af9e714b543fb58fa4", "filename": "src/libstd/list.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -102,6 +102,11 @@ pure fn append<T: copy>(l: @list<T>, m: @list<T>) -> @list<T> {\n     }\n }\n \n+#[doc = \"Push an element to the front of a list\"]\n+fn push<T: copy>(&l: list<T>, v: T) {\n+    l = cons(v, @l);\n+}\n+\n #[doc = \"Iterate over a list\"]\n fn iter<T>(l: @list<T>, f: fn(T)) {\n     let mut cur = l;"}, {"sha": "75005c3bc35c7d08290f11093afd650040a6dd72", "filename": "src/libstd/par.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -4,6 +4,7 @@ import comm::send;\n import comm::recv;\n import future_spawn = future::spawn;\n import future::future;\n+import core::vec::extensions;\n \n export map, mapi, alli, any, mapi_factory;\n "}, {"sha": "11956ff8a259d36450bb32a7dbea514fd487e189", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -3,6 +3,7 @@\n import core::option;\n import option::{none, some};\n import rand;\n+import core::rand::extensions;\n \n fn mkdtemp(prefix: str, suffix: str) -> option<str> {\n     let r = rand::rng();"}, {"sha": "958a29d2f02382d9e3bbd0cd8b03492dbc074725", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -7,7 +7,7 @@ The I/O task runs in its own single-threaded scheduler.  By using the\n \n \"];\n \n-export iotask::{};\n+export iotask;\n export spawn_iotask;\n export interact;\n export exit;"}, {"sha": "c6fb9349ad5f45770561ec9c3b30b9833450600f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -572,6 +572,13 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n     }\n }\n \n+fn view_path_id(p: @view_path) -> node_id {\n+    alt p.node {\n+      view_path_simple(_, _, id) | view_path_glob(_, id) |\n+      view_path_list(_, _, id) { id }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "3daf9106b06a2a7e5b9b18608e489e1206bedf5c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -4,6 +4,9 @@ export filename;\n export filemap;\n export span;\n export file_substr;\n+export fss_none;\n+export fss_internal;\n+export fss_external;\n export codemap;\n export expn_info;\n export expn_info_;"}, {"sha": "7ddc763fac97146584a64e6c2bdcb4fce6307978", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -18,8 +18,8 @@ import common::parser_common;\n import ast::node_id;\n import util::interner;\n // FIXME (#1935): resolve badness\n-import lexer::*;//{string_reader_as_reader, tt_reader_as_reader,\n-               //reader, string_reader, tt_reader};\n+import lexer::{string_reader_as_reader, tt_reader_as_reader, reader,\n+               string_reader, tt_reader};\n import diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n \n type parse_sess = @{"}, {"sha": "9b36b77407e527be2ef9428d01218bd280750c6f", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,7 +1,8 @@\n /*\n   Predicates on exprs and stmts that the pretty-printer and parser use\n  */\n-import ast_util::*;\n+\n+import ast_util::operator_prec;\n \n fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     alt e.node {"}, {"sha": "d1f19c3d47e6f102288c4b80e9ffdba946c134d0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -5,18 +5,21 @@ import token::{can_begin_expr, is_ident, is_plain_ident};\n import codemap::{span,fss_none};\n import util::interner;\n import ast_util::{spanned, respan, mk_sp, ident_to_path, operator_prec};\n-import ast::*;\n import lexer::reader;\n import prec::{as_prec, token_to_binop};\n import attr::parser_attr;\n import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n-                seq_sep_none, token_to_str};\n-import common::*;//{parser_common};\n+                seq_sep_none, token_to_str, parser_common};\n import dvec::{dvec, extensions};\n import vec::{push};\n+import ast::*;\n \n export file_type;\n export parser;\n+export parse_expr;\n+export parse_pat;\n+export CRATE_FILE;\n+export SOURCE_FILE;\n \n // FIXME (#1893): #ast expects to find this here but it's actually\n // defined in `parse` Fixing this will be easier when we have export"}, {"sha": "5f2aada9fc68b0ebae15498caa1a14ca06d9a24c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,4 +1,3 @@\n-import parse::classify::*;\n import parse::comments;\n import parse::lexer;\n import codemap::codemap;\n@@ -8,6 +7,7 @@ import pp::{break_offset, word, printer,\n import diagnostic;\n import ast_util::operator_prec;\n import dvec::{dvec, extensions};\n+import parse::classify::*;\n \n // The ps is stored here to prevent recursive type.\n enum ann_node {"}, {"sha": "e5efbd1dc571f1fbc8a91dcb34f0b5ec2c201afa", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 75, "deletions": 83, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -13,6 +13,7 @@ import std::getopts;\n import io::{reader_util, writer_util};\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n+import std::map::hashmap;\n \n enum pp_mode {ppm_normal, ppm_expanded, ppm_typed, ppm_identified,\n               ppm_expanded_identified }\n@@ -107,7 +108,7 @@ fn parse_input(sess: session, cfg: ast::crate_cfg, input: input)\n     }\n }\n \n-fn time<T>(do_it: bool, what: str, thunk: fn@() -> T) -> T {\n+fn time<T>(do_it: bool, what: str, thunk: fn() -> T) -> T {\n     if !do_it { ret thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n@@ -137,105 +138,99 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     sess.building_library = session::building_library(\n         sess.opts.crate_type, crate, sess.opts.test);\n \n-    crate = time(time_passes, \"configuration\", |copy crate| {\n-        front::config::strip_unconfigured_items(crate)\n-    });\n+    crate = time(time_passes, \"configuration\", ||\n+        front::config::strip_unconfigured_items(crate));\n \n-    crate = time(time_passes, \"maybe building test harness\", |copy crate| {\n-        front::test::modify_for_testing(sess, crate)\n-    });\n+    crate = time(time_passes, \"maybe building test harness\", ||\n+        front::test::modify_for_testing(sess, crate));\n \n-    crate = time(time_passes, \"expansion\", |copy crate| {\n-        syntax::ext::expand::expand_crate(\n-            sess.parse_sess, sess.opts.cfg, crate)\n-    });\n+    crate = time(time_passes, \"expansion\", ||\n+        syntax::ext::expand::expand_crate(sess.parse_sess, sess.opts.cfg,\n+                                          crate));\n \n     if upto == cu_expand { ret {crate: crate, tcx: none}; }\n \n-    crate = time(time_passes, \"intrinsic injection\", |copy crate| {\n-        front::intrinsic_inject::inject_intrinsic(sess, crate)\n-    });\n+    crate = time(time_passes, \"intrinsic injection\", ||\n+        front::intrinsic_inject::inject_intrinsic(sess, crate));\n \n-    crate = time(time_passes, \"core injection\", |copy crate| {\n-        front::core_inject::maybe_inject_libcore_ref(sess, crate)\n-    });\n+    crate = time(time_passes, \"core injection\", ||\n+        front::core_inject::maybe_inject_libcore_ref(sess, crate));\n \n-    time(time_passes, \"building warning settings table\", |copy crate| {\n-        lint::build_settings_crate(sess, crate)\n-    });\n+    time(time_passes, \"building warning settings table\", ||\n+        lint::build_settings_crate(sess, crate));\n \n-    let ast_map = time(time_passes, \"ast indexing\", |copy crate| {\n-            syntax::ast_map::map_crate(sess.diagnostic(), *crate)\n-        });\n+    let ast_map = time(time_passes, \"ast indexing\", ||\n+            syntax::ast_map::map_crate(sess.diagnostic(), *crate));\n \n-    time(time_passes, \"external crate/lib resolution\", |copy crate| {\n-        creader::read_crates(\n-            sess.diagnostic(), *crate, sess.cstore,\n-            sess.filesearch,\n-            session::sess_os_to_meta_os(sess.targ_cfg.os),\n-            sess.opts.static)\n-    });\n+    time(time_passes, \"external crate/lib resolution\", ||\n+        creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n+                             sess.filesearch,\n+                             session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                             sess.opts.static));\n \n-    let { def_map, exp_map, impl_map\n-        } = time(time_passes, \"resolution\", |copy crate| {\n-        resolve::resolve_crate(sess, ast_map, crate)\n-    });\n+    let mut def_map;\n+    let mut impl_map;\n+    let mut exp_map;\n+    if sess.fast_resolve() {\n+        let { def_map: fast_dm, exp_map: fast_em, impl_map: fast_im } =\n+            time(time_passes, \"fast resolution\", ||\n+                 middle::resolve3::resolve_crate(sess, ast_map, crate));\n \n-    let freevars = time(time_passes, \"freevar finding\", |copy crate| {\n-        freevars::annotate_freevars(def_map, crate)\n-    });\n+        def_map = fast_dm;\n+        impl_map = fast_im;\n+        exp_map = fast_em;\n+    } else {\n+        let { def_map: normal_dm, exp_map: normal_em, impl_map: normal_im } =\n+            time(time_passes, \"resolution\", ||\n+                 resolve::resolve_crate(sess, ast_map, crate));\n+\n+        def_map = normal_dm;\n+        impl_map = normal_im;\n+        exp_map = normal_em;\n+    }\n+\n+    let freevars = time(time_passes, \"freevar finding\", ||\n+        freevars::annotate_freevars(def_map, crate));\n \n-    let region_map = time(time_passes, \"region resolution\", |copy crate| {\n-        middle::region::resolve_crate(sess, def_map, crate)\n-    });\n+    let region_map = time(time_passes, \"region resolution\", ||\n+        middle::region::resolve_crate(sess, def_map, crate));\n \n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars, region_map);\n \n-    let ( method_map, vtable_map\n-        ) = time(time_passes, \"typechecking\", |copy crate| {\n-        typeck::check_crate(ty_cx, impl_map, crate)\n-    });\n+    let (method_map, vtable_map) = time(time_passes, \"typechecking\", ||\n+                                        typeck::check_crate(ty_cx,\n+                                                            impl_map,\n+                                                            crate));\n \n-    time(time_passes, \"const checking\", |copy crate| {\n-        middle::check_const::check_crate(\n-            sess, crate, ast_map, def_map, method_map, ty_cx)\n-    });\n+    time(time_passes, \"const checking\", ||\n+        middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+                                         method_map, ty_cx));\n \n     if upto == cu_typeck { ret {crate: crate, tcx: some(ty_cx)}; }\n \n-    time(time_passes, \"block-use checking\", |copy crate| {\n-        middle::block_use::check_crate(ty_cx, crate)\n-    });\n+    time(time_passes, \"block-use checking\", ||\n+        middle::block_use::check_crate(ty_cx, crate));\n \n-    time(time_passes, \"loop checking\", |copy crate| {\n-        middle::check_loop::check_crate(ty_cx, crate)\n-    });\n+    time(time_passes, \"loop checking\", ||\n+        middle::check_loop::check_crate(ty_cx, crate));\n \n-    time(time_passes, \"alt checking\", |copy crate| {\n-        middle::check_alt::check_crate(ty_cx, crate)\n-    });\n+    time(time_passes, \"alt checking\", ||\n+        middle::check_alt::check_crate(ty_cx, crate));\n \n-    let last_use_map = time(time_passes, \"liveness checking\", |copy crate| {\n-        middle::liveness::check_crate(ty_cx, method_map, crate)\n-    });\n+    let last_use_map = time(time_passes, \"liveness checking\", ||\n+        middle::liveness::check_crate(ty_cx, method_map, crate));\n \n-    time(time_passes, \"typestate checking\", |copy crate| {\n-        middle::tstate::ck::check_crate(ty_cx, crate)\n-    });\n+    time(time_passes, \"typestate checking\", ||\n+         middle::tstate::ck::check_crate(ty_cx, crate));\n \n-    let ( root_map, mutbl_map\n-        ) = time(time_passes, \"borrow checking\", |copy crate| {\n+    let (root_map, mutbl_map) = time(time_passes, \"borrow checking\", ||\n         middle::borrowck::check_crate(ty_cx, method_map,\n-                                      last_use_map, crate)\n-    });\n+                                      last_use_map, crate));\n \n-    time(time_passes, \"kind checking\", |copy crate| {\n-        kind::check_crate(ty_cx, method_map, last_use_map, crate)\n-    });\n+    time(time_passes, \"kind checking\", ||\n+        kind::check_crate(ty_cx, method_map, last_use_map, crate));\n \n-    time(time_passes, \"lint checking\", |copy crate| {\n-        lint::check_crate(ty_cx, crate)\n-    });\n+    time(time_passes, \"lint checking\", || lint::check_crate(ty_cx, crate));\n \n     if upto == cu_no_trans { ret {crate: crate, tcx: some(ty_cx)}; }\n     let outputs = option::get(outputs);\n@@ -245,25 +240,22 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 impl_map: impl_map, method_map: method_map,\n                 vtable_map: vtable_map};\n \n-    let (llmod, link_meta) = time(time_passes, \"translation\", |copy crate| {\n+    let (llmod, link_meta) = time(time_passes, \"translation\", ||\n         trans::base::trans_crate(sess, crate, ty_cx, outputs.obj_filename,\n-                                 exp_map, maps)\n-    });\n+                                 exp_map, maps));\n \n-    time(time_passes, \"LLVM passes\", || {\n-        link::write::run_passes(sess, llmod, outputs.obj_filename)\n-    });\n+    time(time_passes, \"LLVM passes\", ||\n+        link::write::run_passes(sess, llmod, outputs.obj_filename));\n \n     let stop_after_codegen =\n         sess.opts.output_type != link::output_type_exe ||\n             sess.opts.static && sess.building_library;\n \n     if stop_after_codegen { ret {crate: crate, tcx: some(ty_cx)}; }\n \n-    time(time_passes, \"linking\", || {\n-        link::link_binary(sess, outputs.obj_filename,\n-                          outputs.out_filename, link_meta)\n-    });\n+    time(time_passes, \"linking\", ||\n+         link::link_binary(sess, outputs.obj_filename,\n+                           outputs.out_filename, link_meta));\n \n     ret {crate: crate, tcx: some(ty_cx)};\n }"}, {"sha": "634134ace33cf966cde3a3d75aee407f5a580389", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -35,6 +35,7 @@ const trace: uint = 128u;\n // FIXME (#2377): This exists to transition to a Rust crate runtime\n // It should be removed\n const no_rt: uint = 256u;\n+const fast_resolve: uint = 512u;\n \n fn debugging_opts_map() -> ~[(str, str, uint)] {\n     ~[(\"ppregions\", \"prettyprint regions with \\\n@@ -47,7 +48,8 @@ fn debugging_opts_map() -> ~[(str, str, uint)] {\n      (\"no-asm-comments\", \"omit comments when using -S\", no_asm_comments),\n      (\"no-verify\", \"skip LLVM verification\", no_verify),\n      (\"trace\", \"emit trace logs\", trace),\n-     (\"no-rt\", \"do not link to the runtime\", no_rt)\n+     (\"no-rt\", \"do not link to the runtime\", no_rt),\n+     (\"fast-resolve\", \"use fast name resolution\", fast_resolve)\n     ]\n }\n \n@@ -162,6 +164,7 @@ impl session for session {\n     fn no_asm_comments() -> bool { self.debugging_opt(no_asm_comments) }\n     fn no_verify() -> bool { self.debugging_opt(no_verify) }\n     fn trace() -> bool { self.debugging_opt(trace) }\n+    fn fast_resolve() -> bool { self.debugging_opt(fast_resolve) }\n }\n \n #[doc = \"Some reasonable defaults\"]"}, {"sha": "4943e3e3e6e8cb3a17b78149cbf213e3415eb066", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -22,6 +22,7 @@ export lookup_method_purity;\n export get_enum_variants;\n export get_impls_for_mod;\n export get_iface_methods;\n+export each_path;\n export get_type;\n export get_impl_iface;\n export get_impl_method;\n@@ -81,6 +82,13 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     ret result;\n }\n \n+#[doc=\"Iterates over all the paths in the given crate.\"]\n+fn each_path(cstore: cstore::cstore, cnum: ast::crate_num,\n+             f: fn(decoder::path_entry) -> bool) {\n+    let crate_data = cstore::get_crate_data(cstore, cnum);\n+    decoder::each_path(crate_data, f);\n+}\n+\n fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "21506a59f56a5720a4ee64a94852aca8b4b0277a", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -6,7 +6,7 @@ import std::map::hashmap;\n import syntax::{ast, attr};\n import syntax::ast_util::new_def_hash;\n \n-export cstore::{};\n+export cstore;\n export cnum_map;\n export crate_metadata;\n export mk_cstore;"}, {"sha": "1f8aae87b7c8a47a26d51f2bbc0797bf56c7c31d", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 135, "deletions": 20, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,7 +1,7 @@\n // Decoding metadata from a single crate's metadata\n \n import std::{ebml, map};\n-import std::map::hashmap;\n+import std::map::{hashmap, str_hash};\n import io::writer_util;\n import syntax::{ast, ast_util};\n import syntax::attr;\n@@ -37,6 +37,12 @@ export get_crate_vers;\n export get_impls_for_mod;\n export get_iface_methods;\n export get_crate_module_paths;\n+export def_like;\n+export dl_def;\n+export dl_impl;\n+export dl_field;\n+export path_entry;\n+export each_path;\n export get_item_path;\n export maybe_find_item; // sketchy\n export item_type; // sketchy\n@@ -116,6 +122,7 @@ fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n     found\n }\n \n+// XXX: This has nothing to do with classes.\n fn class_member_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n     let tagdoc = ebml::get_doc(d, tag_def_id);\n     ret translate_def_id(cdata, parse_def_id(ebml::doc_data(tagdoc)));\n@@ -257,31 +264,39 @@ fn lookup_item_name(data: @~[u8], id: ast::node_id) -> ast::ident {\n     item_name(lookup_item(id, data))\n }\n \n-fn lookup_def(cnum: ast::crate_num, data: @~[u8], did_: ast::def_id) ->\n-   ast::def {\n-    let item = lookup_item(did_.node, data);\n+fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n+        -> def_like {\n     let fam_ch = item_family(item);\n-    let did = {crate: cnum, node: did_.node};\n-    // We treat references to enums as references to types.\n-    alt check fam_ch {\n-      'c' { ast::def_const(did) }\n-      'C' { ast::def_class(did) }\n-      'u' { ast::def_fn(did, ast::unsafe_fn) }\n-      'f' { ast::def_fn(did, ast::impure_fn) }\n-      'p' { ast::def_fn(did, ast::pure_fn) }\n-      'y' { ast::def_ty(did) }\n-      't' { ast::def_ty(did) }\n-      'm' { ast::def_mod(did) }\n-      'n' { ast::def_foreign_mod(did) }\n+    alt fam_ch {\n+      'c' { dl_def(ast::def_const(did)) }\n+      'C' { dl_def(ast::def_class(did)) }\n+      'u' { dl_def(ast::def_fn(did, ast::unsafe_fn)) }\n+      'f' { dl_def(ast::def_fn(did, ast::impure_fn)) }\n+      'p' { dl_def(ast::def_fn(did, ast::pure_fn)) }\n+      'y' { dl_def(ast::def_ty(did)) }\n+      't' { dl_def(ast::def_ty(did)) }\n+      'm' { dl_def(ast::def_mod(did)) }\n+      'n' { dl_def(ast::def_foreign_mod(did)) }\n       'v' {\n         let mut tid = option::get(item_parent_item(item));\n         tid = {crate: cnum, node: tid.node};\n-        ast::def_variant(tid, did)\n+        dl_def(ast::def_variant(tid, did))\n       }\n-      'I' { ast::def_ty(did) }\n+      'I' { dl_def(ast::def_ty(did)) }\n+      'i' { dl_impl(did) }\n+      'g' | 'j' { dl_field }\n+      ch { fail #fmt(\"unexpected family code: '%c'\", ch) }\n     }\n }\n \n+fn lookup_def(cnum: ast::crate_num, data: @~[u8], did_: ast::def_id) ->\n+   ast::def {\n+    let item = lookup_item(did_.node, data);\n+    let did = {crate: cnum, node: did_.node};\n+    // We treat references to enums as references to types.\n+    ret def_like_to_def(item_to_def_like(item, did, cnum));\n+}\n+\n fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n@@ -356,6 +371,104 @@ fn get_symbol(data: @~[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n+// Something that a name can resolve to.\n+enum def_like {\n+    dl_def(ast::def),\n+    dl_impl(ast::def_id),\n+    dl_field\n+}\n+\n+fn def_like_to_def(def_like: def_like) -> ast::def {\n+    alt def_like {\n+        dl_def(def) { ret def; }\n+        dl_impl(*) { fail \"found impl in def_like_to_def\"; }\n+        dl_field { fail \"found field in def_like_to_def\"; }\n+    }\n+}\n+\n+// A path.\n+class path_entry {\n+    // The full path, separated by '::'.\n+    let path_string: str;\n+    // The definition, implementation, or field that this path corresponds to.\n+    let def_like: def_like;\n+\n+    new(path_string: str, def_like: def_like) {\n+        self.path_string = path_string;\n+        self.def_like = def_like;\n+    }\n+}\n+\n+#[doc=\"Iterates over all the paths in the given crate.\"]\n+fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n+    let root = ebml::doc(cdata.data);\n+    let items = ebml::get_doc(root, tag_items);\n+    let items_data = ebml::get_doc(items, tag_items_data);\n+\n+    let mut broken = false;\n+\n+    // First, go through all the explicit items.\n+    do ebml::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n+        if !broken {\n+            let name = ast_map::path_to_str_with_sep(item_path(item_doc),\n+                                                     \"::\");\n+            if name != \"\" {\n+                // Extract the def ID.\n+                let def_id = class_member_id(item_doc, cdata);\n+\n+                // Construct the def for this item.\n+                #debug(\"(each_path) yielding explicit item: %s\", name);\n+                let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n+\n+                // Hand the information off to the iteratee.\n+                let this_path_entry = path_entry(name, def_like);\n+                if !f(this_path_entry) {\n+                    broken = true;      // XXX: This is awful.\n+                }\n+            }\n+        }\n+    }\n+\n+    // If broken, stop here.\n+    if broken {\n+        ret;\n+    }\n+\n+    // Next, go through all the paths. We will find items that we didn't know\n+    // about before (reexports in particular).\n+    let outer_paths = ebml::get_doc(root, tag_paths);\n+    let inner_paths = ebml::get_doc(outer_paths, tag_paths);\n+    do ebml::tagged_docs(inner_paths, tag_paths_data_item) |path_doc| {\n+        if !broken {\n+            let path = item_name(path_doc);\n+\n+            // Extract the def ID.\n+            let def_id = class_member_id(path_doc, cdata);\n+\n+            // Get the item.\n+            alt maybe_find_item(def_id.node, items) {\n+                none {\n+                    #debug(\"(each_path) ignoring implicit item: %s\",\n+                            *path);\n+                }\n+                some(item_doc) {\n+                    // Construct the def for this item.\n+                    let def_like = item_to_def_like(item_doc, def_id,\n+                                                    cdata.cnum);\n+\n+                    // Hand the information off to the iteratee.\n+                    #debug(\"(each_path) yielding implicit item: %s\",\n+                            *path);\n+                    let this_path_entry = path_entry(*path, def_like);\n+                    if (!f(this_path_entry)) {\n+                        broken = true;      // XXX: This is awful.\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n@@ -441,10 +554,12 @@ fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n     rslt\n }\n \n-fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n+fn get_impls_for_mod(cdata: cmd,\n+                     m_id: ast::node_id,\n                      name: option<ast::ident>,\n                      get_cdata: fn(ast::crate_num) -> cmd)\n-    -> @~[@_impl] {\n+                  -> @~[@_impl] {\n+\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];"}, {"sha": "13ce52daae6defc2c9269f7d31536bb6f32b8fcb", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -385,9 +385,13 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ebml_w, name);\n+    #debug(\"(encoding info for module) encoding info for module ID %d\", id);\n     let impls = ecx.impl_map(id);\n     for impls.each |i| {\n         let (ident, did) = i;\n+        #debug(\"(encoding info for module) ... encoding impl %s (%?), \\\n+                exported? %?\",\n+               *ident, did, ast_util::is_exported(ident, md));\n         if ast_util::is_exported(ident, md) {\n             ebml_w.start_tag(tag_mod_impl);\n             alt ecx.tcx.items.find(did.node) {"}, {"sha": "b9d716ad2297c5d126c324c6252b96185e0d0990", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -8,7 +8,9 @@ import std::map::{map,hashmap,int_hash,hash_from_strs};\n import std::smallintmap::{map,smallintmap};\n import io::writer_util;\n import syntax::print::pprust::expr_to_str;\n-export lint, ctypes, unused_imports;\n+export lint, ctypes, unused_imports, while_true, path_statement, old_vecs;\n+export unrecognized_warning, non_implicitly_copyable_typarams;\n+export vecs_not_implicitly_copyable, implicit_copies;\n export level, ignore, warn, error;\n export lookup_lint, lint_dict, get_lint_dict;\n export get_warning_level, get_warning_settings_level;"}, {"sha": "fd6033c5b9d9fdc74d280b1380813b7953f96dab", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -283,7 +283,7 @@ class ir_maps {\n           some(var) {var}\n           none {\n             self.tcx.sess.span_bug(\n-                span, \"No variable registered for this id\");\n+                span, #fmt(\"No variable registered for id %d\", node_id));\n           }\n         }\n     }"}, {"sha": "3c9da7d525a7ffc4a4f5c674c06a15ab6a18b2f5", "filename": "src/rustc/middle/resolve3.rs", "status": "added", "additions": 3946, "deletions": 0, "changes": 3946, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347"}, {"sha": "a37077863637aadb044d28fdf64a1f0339b572c1", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -39,14 +39,16 @@ import link::{mangle_internal_name_by_type_only,\n               mangle_exported_name};\n import metadata::{csearch, cstore, encoder};\n import metadata::common::link_meta;\n+import util::ppaux;\n import util::ppaux::{ty_to_str, ty_to_short_str};\n import syntax::diagnostic::expect;\n \n-import common::*;\n import build::*;\n import shape::*;\n import type_of::*;\n+import common::*;\n import type_of::type_of; // Issue #1873\n+import common::result;\n import syntax::ast_map::{path, path_mod, path_name};\n \n import std::smallintmap;\n@@ -511,7 +513,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n           mut drop_glue: none,\n           mut free_glue: none,\n           mut visit_glue: none};\n-    log(debug, \"--- declare_tydesc \" + ty_to_str(ccx.tcx, t));\n+    log(debug, \"--- declare_tydesc \" + ppaux::ty_to_str(ccx.tcx, t));\n     ret inf;\n }\n \n@@ -1106,59 +1108,59 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n-                       ty_to_str(ccx.tcx, ti.ty));\n+                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n                 let glue_fn = declare_generic_glue\n                     (ccx, ti.ty, T_glue_fn(ccx), \"take\");\n                 ti.take_glue = some(glue_fn);\n                 make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_take_glue, \"take\");\n                 #debug(\"--- lazily_emit_tydesc_glue TAKE %s\",\n-                       ty_to_str(ccx.tcx, ti.ty));\n+                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n               }\n             }\n         } else if field == abi::tydesc_field_drop_glue {\n             alt ti.drop_glue {\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue DROP %s\",\n-                       ty_to_str(ccx.tcx, ti.ty));\n+                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n                 let glue_fn =\n                     declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"drop\");\n                 ti.drop_glue = some(glue_fn);\n                 make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_drop_glue, \"drop\");\n                 #debug(\"--- lazily_emit_tydesc_glue DROP %s\",\n-                       ty_to_str(ccx.tcx, ti.ty));\n+                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n               }\n             }\n         } else if field == abi::tydesc_field_free_glue {\n             alt ti.free_glue {\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue FREE %s\",\n-                       ty_to_str(ccx.tcx, ti.ty));\n+                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n                 let glue_fn =\n                     declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"free\");\n                 ti.free_glue = some(glue_fn);\n                 make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_free_glue, \"free\");\n                 #debug(\"--- lazily_emit_tydesc_glue FREE %s\",\n-                       ty_to_str(ccx.tcx, ti.ty));\n+                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n               }\n             }\n         } else if field == abi::tydesc_field_visit_glue {\n             alt ti.visit_glue {\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n-                       ty_to_str(ccx.tcx, ti.ty));\n+                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n                 let glue_fn =\n                     declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"visit\");\n                 ti.visit_glue = some(glue_fn);\n                 make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_visit_glue, \"visit\");\n                 #debug(\"--- lazily_emit_tydesc_glue VISIT %s\",\n-                       ty_to_str(ccx.tcx, ti.ty));\n+                       ppaux::ty_to_str(ccx.tcx, ti.ty));\n               }\n             }\n         }\n@@ -1383,7 +1385,7 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n         ret take_ty(bcx, dst, t);\n     }\n     ccx.sess.bug(\"unexpected type in trans::copy_val_no_check: \" +\n-                     ty_to_str(ccx.tcx, t));\n+                     ppaux::ty_to_str(ccx.tcx, t));\n }\n \n \n@@ -1422,7 +1424,7 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n         ret cx;\n     }\n     cx.sess().bug(\"unexpected type in trans::move_val: \" +\n-                  ty_to_str(tcx, t));\n+                  ppaux::ty_to_str(tcx, t));\n }\n \n fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n@@ -1810,7 +1812,7 @@ fn autoderef(cx: block, e_id: ast::node_id,\n     let mut derefs = 0u;\n     while derefs < max {\n         #debug[\"autoderef(e_id=%d, v1=%s, t1=%s, derefs=%u)\",\n-               e_id, val_str(ccx.tn, v1), ty_to_str(ccx.tcx, t1),\n+               e_id, val_str(ccx.tn, v1), ppaux::ty_to_str(ccx.tcx, t1),\n                derefs];\n \n         // root the autoderef'd value, if necessary:\n@@ -2140,7 +2142,6 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n \n     for real_substs.each() |s| { assert !ty::type_has_params(s); }\n     for substs.each() |s| { assert !ty::type_has_params(s); }\n-\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, some(param_uses));\n     if vec::any(hash_id.params,\n@@ -2156,6 +2157,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n \n     alt ccx.monomorphized.find(hash_id) {\n       some(val) {\n+        #debug[\"leaving monomorphic fn %s\",\n+               ty::item_path_str(ccx.tcx, fn_id)];\n         ret {val: val, must_cast: must_cast};\n       }\n       none {}\n@@ -2286,6 +2289,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n       }\n     };\n     ccx.monomorphizing.insert(fn_id, depth);\n+\n+    #debug[\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id)];\n     {val: lldecl, must_cast: must_cast}\n }\n \n@@ -3056,7 +3061,7 @@ fn adapt_borrowed_value(lv: lval_result,\n       _ {\n         bcx.tcx().sess.span_bug(\n             e.span, #fmt[\"cannot borrow a value of type %s\",\n-                         ty_to_str(bcx.tcx(), e_ty)]);\n+                         ppaux::ty_to_str(bcx.tcx(), e_ty)]);\n       }\n     }\n }\n@@ -3517,7 +3522,7 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n \n     #debug[\"add_root_cleanup(bcx=%s, scope_id=%d, root_loc=%s, ty=%s)\",\n            bcx.to_str(), scope_id, val_str(bcx.ccx().tn, root_loc),\n-           ty_to_str(bcx.ccx().tcx, ty)];\n+           ppaux::ty_to_str(bcx.ccx().tcx, ty)];\n \n     let bcx_scope = find_bcx_for_scope(bcx, scope_id);\n     add_clean_temp_mem(bcx_scope, root_loc, ty);\n@@ -3614,7 +3619,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             alt check ty::get(expr_ty(bcx, e)).struct {\n               ty::ty_fn({proto, _}) {\n                 #debug(\"translating fn_block %s with type %s\",\n-                       expr_to_str(e), ty_to_str(tcx, expr_ty(bcx, e)));\n+                       expr_to_str(e),\n+                       ppaux::ty_to_str(tcx, expr_ty(bcx, e)));\n                 ret closure::trans_expr_fn(bcx, proto, decl, body,\n                                            e.id, cap_clause, none, dest);\n               }\n@@ -3754,7 +3760,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             let ptr_ty = expr_ty(bcx, e);\n             let ptr_ptr_val = alloc_ty(bcx, ptr_ty);\n \n-            #debug[\"ptr_ty = %s\", ty_to_str(tcx, ptr_ty)];\n+            #debug[\"ptr_ty = %s\", ppaux::ty_to_str(tcx, ptr_ty)];\n             #debug[\"ptr_ptr_val = %s\", val_str(ccx.tn, ptr_ptr_val)];\n \n             let void_ty = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx),\n@@ -3947,7 +3953,7 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n         } else {\n             bcx.sess().span_bug(\n                 expr.span, \"fail called with unsupported type \" +\n-                ty_to_str(tcx, e_ty));\n+                ppaux::ty_to_str(tcx, e_ty));\n         }\n       }\n       _ { ret trans_fail(bcx, sp_opt, \"explicit failure\"); }\n@@ -4345,7 +4351,7 @@ fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let llty = type_of(ccx, t);\n-    if ty::type_has_params(t) { log(error, ty_to_str(ccx.tcx, t)); }\n+    if ty::type_has_params(t) { log(error, ppaux::ty_to_str(ccx.tcx, t)); }\n     assert !ty::type_has_params(t);\n     let val = alloca(bcx, llty);\n     ret val;"}, {"sha": "11dfb973391506bf9946c3221fc6bab8a4fb58a3", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -264,6 +264,9 @@ fn store_environment(bcx: block,\n             bcx = move_val(bcx, INIT, bound_data, src, ty);\n           }\n           env_ref(val, ty, owned) {\n+            #debug[\"> storing %s into %s\",\n+                   val_str(bcx.ccx().tn, val),\n+                   val_str(bcx.ccx().tn, bound_data)];\n             Store(bcx, val, bound_data);\n           }\n           env_ref(val, ty, owned_imm) {\n@@ -298,6 +301,8 @@ fn build_closure(bcx0: block,\n         #debug[\"Building closure: captured variable %?\", cap_var];\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n+        #debug[\"Node id is %s\",\n+               syntax::ast_map::node_id_to_str(bcx.ccx().tcx.items, nid)];\n         let mut ty = node_id_type(bcx, nid);\n         alt cap_var.mode {\n           capture::cap_ref {"}, {"sha": "240d739b722575af6ba924e3b617c70b6d52773c", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -9,8 +9,7 @@ import lib::llvm::{ llvm, TypeRef, ValueRef,\n                     ModuleRef, CallConv, Attribute,\n                     StructRetAttribute, ByValAttribute,\n                    SequentiallyConsistent, Acquire, Release,\n-                   Xchg, Add, Sub\n-                  };\n+                   Xchg };\n import syntax::{ast, ast_util};\n import back::{link, abi};\n import common::*;\n@@ -830,42 +829,42 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         Store(bcx, old, fcx.llretptr);\n       }\n       \"atomic_add\" {\n-        let old = AtomicRMW(bcx, Add,\n+        let old = AtomicRMW(bcx, lib::llvm::Add,\n                   get_param(decl, first_real_arg),\n                   get_param(decl, first_real_arg + 1u),\n                   SequentiallyConsistent);\n         Store(bcx, old, fcx.llretptr);\n       }\n       \"atomic_add_acq\" {\n-        let old = AtomicRMW(bcx, Add,\n+        let old = AtomicRMW(bcx, lib::llvm::Add,\n                   get_param(decl, first_real_arg),\n                   get_param(decl, first_real_arg + 1u),\n                   Acquire);\n         Store(bcx, old, fcx.llretptr);\n       }\n       \"atomic_add_rel\" {\n-        let old = AtomicRMW(bcx, Add,\n+        let old = AtomicRMW(bcx, lib::llvm::Add,\n                   get_param(decl, first_real_arg),\n                   get_param(decl, first_real_arg + 1u),\n                   Release);\n         Store(bcx, old, fcx.llretptr);\n       }\n       \"atomic_sub\" {\n-        let old = AtomicRMW(bcx, Sub,\n+        let old = AtomicRMW(bcx, lib::llvm::Sub,\n                   get_param(decl, first_real_arg),\n                   get_param(decl, first_real_arg + 1u),\n                   SequentiallyConsistent);\n         Store(bcx, old, fcx.llretptr);\n       }\n       \"atomic_sub_acq\" {\n-        let old = AtomicRMW(bcx, Sub,\n+        let old = AtomicRMW(bcx, lib::llvm::Sub,\n                   get_param(decl, first_real_arg),\n                   get_param(decl, first_real_arg + 1u),\n                   Acquire);\n         Store(bcx, old, fcx.llretptr);\n       }\n       \"atomic_sub_rel\" {\n-        let old = AtomicRMW(bcx, Sub,\n+        let old = AtomicRMW(bcx, lib::llvm::Sub,\n                   get_param(decl, first_real_arg),\n                   get_param(decl, first_real_arg + 1u),\n                   Release);"}, {"sha": "40db9c9c0db35bce5a4c49d8decac56e460eb0a7", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -81,6 +81,18 @@ fn traverse_public_mod(cx: ctx, m: _mod) {\n     if !traverse_exports(cx, m.view_items) {\n         // No exports, so every local item is exported\n         for vec::each(m.items) |item| { traverse_public_item(cx, item); }\n+    } else {\n+        // Make impls always reachable.\n+        for vec::each(m.items) |item| {\n+            alt item.node {\n+                item_impl(*) {\n+                    traverse_public_item(cx, item);\n+                }\n+                _ {\n+                    // Nothing to do.\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "52dd2675040ffaf097b643f690de29295df8aed8", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -5,8 +5,6 @@ import lib::llvm::llvm;\n import driver::session::session;\n import std::map::hashmap;\n \n-import ty::*;\n-\n export type_of;\n export type_of_dtor;\n export type_of_explicit_args;\n@@ -174,7 +172,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         alt ty::get(t).struct {\n           ty::ty_class(did, ts) {\n             // Only instance vars are record fields at runtime.\n-            let fields = lookup_class_fields(cx.tcx, did);\n+            let fields = ty::lookup_class_fields(cx.tcx, did);\n             let mut tys = do vec::map(fields) |f| {\n                 let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n                 type_of(cx, t)"}, {"sha": "c5ad6f9a00acc28da50daef03ec308806affa457", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -11,11 +11,11 @@ import syntax::codemap::span;\n import metadata::csearch;\n import util::ppaux::region_to_str;\n import util::ppaux::vstore_to_str;\n-import util::ppaux::{ty_to_str, tys_to_str, ty_constr_to_str};\n import middle::lint::{get_warning_level, vecs_not_implicitly_copyable,\n                       ignore};\n import syntax::ast::*;\n import syntax::print::pprust::*;\n+import util::ppaux::{ty_to_str, tys_to_str, ty_constr_to_str};\n \n export tv_vid, tvi_vid, region_vid, vid;\n export br_hashmap;\n@@ -105,7 +105,10 @@ export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n export ty_var, mk_var, type_is_var;\n export ty_var_integral, mk_var_integral, type_is_var_integral;\n export ty_self, mk_self, type_has_self;\n+export ty_class;\n export region, bound_region, encl_region;\n+export re_bound, re_free, re_scope, re_static, re_var;\n+export br_self, br_anon, br_named;\n export get, type_has_params, type_needs_infer, type_has_regions;\n export type_has_resources, type_id;\n export tbox_has_flag;\n@@ -2528,6 +2531,7 @@ fn iface_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n \n fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n     if id.crate == ast::local_crate {\n+        #debug(\"(impl_iface) searching for iface impl %?\", id);\n         alt cx.items.find(id.node) {\n            some(ast_map::node_item(@{node: ast::item_impl(\n               _, _, some(@{id: id, _}), _, _), _}, _)) {\n@@ -2537,11 +2541,16 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n                            _},_)) {\n              alt cx.def_map.find(id.node) {\n                some(def_ty(iface_id)) {\n-                   some(node_id_to_type(cx, id.node))\n+                   // XXX: Doesn't work cross-crate.\n+                   #debug(\"(impl_iface) found iface id %?\", iface_id);\n+                   some(node_id_to_type(cx, iface_id.node))\n+               }\n+               some(x) {\n+                 cx.sess.bug(#fmt(\"impl_iface: iface ref is in iface map \\\n+                                   but is bound to %?\", x));\n                }\n-               _ {\n-                 cx.sess.bug(\"impl_iface: iface ref isn't in iface map \\\n-                         and isn't bound to a def_ty\");\n+               none {\n+                 none\n                }\n              }\n            }"}, {"sha": "500c469bdaca379e9a86b1340328421bd2246fc8", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -53,15 +53,15 @@ import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n import middle::typeck::infer::methods;\n-import util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n-                     bound_region_to_str, vstore_to_str};\n import std::smallintmap;\n import std::smallintmap::map;\n import std::map;\n import std::map::{hashmap, int_hash};\n import std::serialization::{serialize_uint, deserialize_uint};\n import vec::each;\n import syntax::print::pprust::*;\n+import util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n+                     bound_region_to_str, vstore_to_str};\n import util::common::{indent, indenter};\n import std::list;\n import list::{list, nil, cons};"}, {"sha": "144953db2269db550ddb46c6c720b901fc192d7e", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -74,6 +74,8 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                 alt check ty::get(ity).struct {\n                   ty::ty_iface(idid, substs) {\n                     if iface_id == idid {\n+                        #debug(\"(checking vtable) @0 relating ty to iface ty\n+                                with did %?\", idid);\n                         relate_iface_tys(fcx, sp, iface_ty, ity);\n                         ret vtable_param(n, n_bound);\n                     }\n@@ -86,6 +88,9 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n       }\n \n       ty::ty_iface(did, substs) if iface_id == did {\n+        #debug(\"(checking vtable) @1 relating ty to iface ty with did %?\",\n+               did);\n+\n         relate_iface_tys(fcx, sp, iface_ty, ty);\n         if !allow_unsafe {\n             for vec::each(*ty::iface_methods(tcx, did)) |m| {\n@@ -134,6 +139,10 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                     }\n \n                     // check that desired iface type unifies\n+                    #debug(\"(checking vtable) @2 relating iface ty %s to \\\n+                            of_ty %s\",\n+                            fcx.infcx.ty_to_str(iface_ty),\n+                            fcx.infcx.ty_to_str(of_ty));\n                     let of_ty = ty::subst(tcx, substs, of_ty);\n                     relate_iface_tys(fcx, sp, iface_ty, of_ty);\n \n@@ -186,6 +195,8 @@ fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: ~[ty::t],\n     let tcx = fcx.ccx.tcx;\n     let ity = option::get(ty::impl_iface(tcx, impl_did));\n     let iface_ty = ty::subst_tps(tcx, impl_tys, ity);\n+    #debug(\"(connect iface tps) iface type is %?, impl did is %?\",\n+           ty::get(iface_ty).struct, impl_did);\n     alt check ty::get(iface_ty).struct {\n       ty::ty_iface(_, substs) {\n         vec::iter2(substs.tps, iface_tys,"}, {"sha": "7d305814c36c68b0f3e46a734e9711875859dc54", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -52,6 +52,7 @@ mod middle {\n     }\n     mod ty;\n     mod resolve;\n+    mod resolve3;\n     mod typeck {\n         mod check {\n             mod alt;"}, {"sha": "91522e50a326a34bca1e5a6cdf90c4109d711638", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -24,7 +24,7 @@ import rustc::middle::resolve;\n \n export ctxt;\n export ctxt_handler;\n-export srv::{};\n+export srv;\n export from_str;\n export from_file;\n export exec;"}, {"sha": "bf9a49471772094ccd7746998355826c7ba4b05d", "filename": "src/test/run-pass/class-cast-to-iface-cross-crate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n import to_str::*;\n import to_str::to_str;\n \n@@ -45,4 +47,4 @@ fn print_out<T: to_str>(thing: T, expected: str) {\n fn main() {\n   let nyan : to_str  = cat(0u, 2, \"nyan\") as to_str;\n   print_out(nyan, \"nyan\");\n-}\n\\ No newline at end of file\n+}"}, {"sha": "b6dad43b5561348d6f1053e9a97a9935dea65294", "filename": "src/test/run-pass/class-iface-bounded-param.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n use std;\n import std::map::{map, hashmap, int_hash};\n "}, {"sha": "3c44586282142ece50647407f9bcf2628f265fdf", "filename": "src/test/run-pass/class-impl-parameterized-iface.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,4 +1,6 @@\n+// xfail-test\n // xfail-fast\n+\n use std;\n import std::map::*;\n "}, {"sha": "306145640a1b41f3a79d4ca2e6bf80ae1d6b7fd9", "filename": "src/test/run-pass/class-implements-multiple-ifaces.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n use std;\n import std::map::*;\n import vec::*;\n@@ -116,4 +118,4 @@ fn main() {\n   assert(nyan.meow_count() == 10u);\n   assert(bite_everything(nyan as bitey));\n   assert(scratched_something(nyan as scratchy));\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c86289438041228659da0c00bb18eab02ef3feec", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,3 +1,6 @@\n+// xfail-test\n+// xfail-fast\n+// (Not sure why, though -- FIXME (tjc)\n import to_str::*;\n import to_str::to_str;\n "}, {"sha": "5ae34b4209f2403d47f1adfb327a0d2ef328587e", "filename": "src/test/run-pass/export-glob-imports-target.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fexport-glob-imports-target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fexport-glob-imports-target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-glob-imports-target.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,8 +1,10 @@\n // Test that a glob-export functions as an import\n // when referenced within its own local scope.\n \n+// Modified to not use export since it's going away. --pcw\n+\n mod foo {\n-    export bar::*;\n+    import bar::*;\n     mod bar {\n         const a : int = 10;\n     }"}, {"sha": "c14fb80f3f6d02b731ac01a77b65b3f004c016c9", "filename": "src/test/run-pass/export-glob.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fexport-glob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f093d374edb89aedc940468d3d789dd95cec6347/src%2Ftest%2Frun-pass%2Fexport-glob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-glob.rs?ref=f093d374edb89aedc940468d3d789dd95cec6347", "patch": "@@ -1,8 +1,11 @@\n // Test that a glob-export functions as an explicit\n // named export when referenced from outside its scope.\n \n+// Modified to not use export since it's going away. --pcw\n+\n mod foo {\n-    export bar::*;\n+    import bar::*;\n+    export a;\n     mod bar {\n         const a : int = 10;\n     }"}]}