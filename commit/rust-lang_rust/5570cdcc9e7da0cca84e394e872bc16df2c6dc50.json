{"sha": "5570cdcc9e7da0cca84e394e872bc16df2c6dc50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NzBjZGNjOWU3ZGEwY2NhODRlMzk0ZTg3MmJjMTZkZjJjNmRjNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-16T03:38:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-16T03:38:44Z"}, "message": "Auto merge of #46714 - leodasvacas:refactor-structurally-resolve-type, r=nikomatsakis\n\nRefactor diverging and numeric fallback.\n\nThis refactoring tries to make numeric fallback easier to reason about. Instead of applying all fallbacks at an arbitrary point in the middle of inference, we apply the fallback only when necessary and only for\nthe variable that requires it. The only place that requires early fallback is the target of numeric casts.\n\nThe  visible consequences is that some error messages that got `i32` now get `{integer}` because we are less eager about fallback.\n\nThe bigger goal is to make it easier to integrate user fallbacks into inference, if we ever figure that out.", "tree": {"sha": "9606a02e2e153b903a1d4c2c78d160af94e87a4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9606a02e2e153b903a1d4c2c78d160af94e87a4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5570cdcc9e7da0cca84e394e872bc16df2c6dc50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5570cdcc9e7da0cca84e394e872bc16df2c6dc50", "html_url": "https://github.com/rust-lang/rust/commit/5570cdcc9e7da0cca84e394e872bc16df2c6dc50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5570cdcc9e7da0cca84e394e872bc16df2c6dc50/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efda9bae8788fdc68ea1d05be3c5b66d3e291961", "url": "https://api.github.com/repos/rust-lang/rust/commits/efda9bae8788fdc68ea1d05be3c5b66d3e291961", "html_url": "https://github.com/rust-lang/rust/commit/efda9bae8788fdc68ea1d05be3c5b66d3e291961"}, {"sha": "d49d428f791b97c476c066deb9c2b3c20165199f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d49d428f791b97c476c066deb9c2b3c20165199f", "html_url": "https://github.com/rust-lang/rust/commit/d49d428f791b97c476c066deb9c2b3c20165199f"}], "stats": {"total": 167, "additions": 73, "deletions": 94}, "files": [{"sha": "961c2650afdefc995bc256deece40915defc071c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5570cdcc9e7da0cca84e394e872bc16df2c6dc50/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cdcc9e7da0cca84e394e872bc16df2c6dc50/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5570cdcc9e7da0cca84e394e872bc16df2c6dc50", "patch": "@@ -1297,6 +1297,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn is_ty_infer(&self) -> bool {\n+        match self.sty {\n+            TyInfer(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_phantom_data(&self) -> bool {\n         if let TyAdt(def, _) = self.sty {\n             def.is_phantom_data()"}, {"sha": "d21bfb674c7fc61c57f80fa1ec20fcbe7b99dfaa", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 46, "deletions": 94, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5570cdcc9e7da0cca84e394e872bc16df2c6dc50/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cdcc9e7da0cca84e394e872bc16df2c6dc50/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5570cdcc9e7da0cca84e394e872bc16df2c6dc50", "patch": "@@ -871,10 +871,21 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             fcx\n         };\n \n-        fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze(body);\n+        // All type checking constraints were added, try to fallback unsolved variables.\n+        fcx.select_obligations_where_possible();\n+        for ty in &fcx.unsolved_variables() {\n+            fcx.fallback_if_possible(ty);\n+        }\n         fcx.select_obligations_where_possible();\n+\n+        // Even though coercion casts provide type hints, we check casts after fallback for\n+        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n         fcx.check_casts();\n+\n+        // Closure and generater analysis may run after fallback\n+        // because they don't constrain other type variables.\n+        fcx.closure_analyze(body);\n+        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n         fcx.resolve_generator_interiors(def_id);\n         fcx.select_all_obligations_or_error();\n \n@@ -2143,74 +2154,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Apply \"fallbacks\" to some types\n-    /// unconstrained types get replaced with ! or  () (depending on whether\n-    /// feature(never_type) is enabled), unconstrained ints with i32, and\n-    /// unconstrained floats with f64.\n-    fn default_type_parameters(&self) {\n+    // Tries to apply a fallback to `ty` if it is an unsolved variable.\n+    // Non-numerics get replaced with ! or () (depending on whether\n+    // feature(never_type) is enabled), unconstrained ints with i32,\n+    // unconstrained floats with f64.\n+    // Fallback becomes very dubious if we have encountered type-checking errors.\n+    // In that case, fallback to TyError.\n+    fn fallback_if_possible(&self, ty: Ty<'tcx>) {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n-        // Defaulting inference variables becomes very dubious if we have\n-        // encountered type-checking errors. Therefore, if we think we saw\n-        // some errors in this function, just resolve all uninstanted type\n-        // varibles to TyError.\n-        if self.is_tainted_by_errors() {\n-            for ty in &self.unsolved_variables() {\n-                if let ty::TyInfer(_) = self.shallow_resolve(ty).sty {\n-                    debug!(\"default_type_parameters: defaulting `{:?}` to error\", ty);\n-                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx().types.err);\n-                }\n-            }\n-            return;\n-        }\n-\n-        for ty in &self.unsolved_variables() {\n-            let resolved = self.resolve_type_vars_if_possible(ty);\n-            if self.type_var_diverges(resolved) {\n-                debug!(\"default_type_parameters: defaulting `{:?}` to `!` because it diverges\",\n-                       resolved);\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n-                                   self.tcx.mk_diverging_default());\n-            } else {\n-                match self.type_is_unconstrained_numeric(resolved) {\n-                    UnconstrainedInt => {\n-                        debug!(\"default_type_parameters: defaulting `{:?}` to `i32`\",\n-                               resolved);\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n-                    },\n-                    UnconstrainedFloat => {\n-                        debug!(\"default_type_parameters: defaulting `{:?}` to `f32`\",\n-                               resolved);\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n-                    }\n-                    Neither => { }\n-                }\n-            }\n-        }\n-    }\n-\n-    // Implements type inference fallback algorithm\n-    fn select_all_obligations_and_apply_defaults(&self) {\n-        self.select_obligations_where_possible();\n-        self.default_type_parameters();\n-        self.select_obligations_where_possible();\n+        assert!(ty.is_ty_infer());\n+        let fallback = match self.type_is_unconstrained_numeric(ty) {\n+            _ if self.is_tainted_by_errors() => self.tcx().types.err,\n+            UnconstrainedInt => self.tcx.types.i32,\n+            UnconstrainedFloat => self.tcx.types.f64,\n+            Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n+            Neither => return\n+        };\n+        debug!(\"default_type_parameters: defaulting `{:?}` to `{:?}`\", ty, fallback);\n+        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, fallback);\n     }\n \n     fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n-\n-        // upvar inference should have ensured that all deferred call\n-        // resolutions are handled by now.\n-        assert!(self.deferred_call_resolutions.borrow().is_empty());\n-\n-        self.select_all_obligations_and_apply_defaults();\n-\n-        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n-\n-        match fulfillment_cx.select_all_or_error(self) {\n-            Ok(()) => { }\n-            Err(errors) => { self.report_fulfillment_errors(&errors, self.inh.body_id); }\n+        if let Err(errors) = self.fulfillment_cx.borrow_mut().select_all_or_error(&self) {\n+            self.report_fulfillment_errors(&errors, self.inh.body_id);\n         }\n     }\n \n@@ -5074,39 +5043,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    fn structurally_resolve_type_or_else<F>(&self, sp: Span, ty: Ty<'tcx>, f: F)\n-                                            -> Ty<'tcx>\n-        where F: Fn() -> Ty<'tcx>\n-    {\n-        let mut ty = self.resolve_type_vars_with_obligations(ty);\n-\n-        if ty.is_ty_var() {\n-            let alternative = f();\n-\n-            // If not, error.\n-            if alternative.is_ty_var() || alternative.references_error() {\n-                if !self.is_tainted_by_errors() {\n-                    type_error_struct!(self.tcx.sess, sp, ty, E0619,\n-                                       \"the type of this value must be known in this context\")\n-                        .emit();\n-                }\n-                self.demand_suptype(sp, self.tcx.types.err, ty);\n-                ty = self.tcx.types.err;\n-            } else {\n-                self.demand_suptype(sp, alternative, ty);\n-                ty = alternative;\n-            }\n-        }\n-\n-        ty\n-    }\n-\n-    // Resolves `typ` by a single level if `typ` is a type variable.  If no\n-    // resolution is possible, then an error is reported.\n+    // Resolves `typ` by a single level if `typ` is a type variable.\n+    // If no resolution is possible, then an error is reported.\n+    // Numeric inference variables may be left unresolved.\n     pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.structurally_resolve_type_or_else(sp, ty, || {\n+        let ty = self.resolve_type_vars_with_obligations(ty);\n+        if !ty.is_ty_var() {\n+            ty\n+        } else {\n+            if !self.is_tainted_by_errors() {\n+                type_error_struct!(self.tcx.sess, sp, ty, E0619,\n+                                    \"the type of this value must be known in this context\")\n+                .emit();\n+            }\n+            self.demand_suptype(sp, self.tcx.types.err, ty);\n             self.tcx.types.err\n-        })\n+        }\n     }\n \n     fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: ast::NodeId,"}, {"sha": "aa6752ffc35b077c1929d5490179584c5abf036d", "filename": "src/test/run-pass/cast-does-fallback.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5570cdcc9e7da0cca84e394e872bc16df2c6dc50/src%2Ftest%2Frun-pass%2Fcast-does-fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cdcc9e7da0cca84e394e872bc16df2c6dc50/src%2Ftest%2Frun-pass%2Fcast-does-fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-does-fallback.rs?ref=5570cdcc9e7da0cca84e394e872bc16df2c6dc50", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    // Test that these type check correctly.\n+    (&42u8 >> 4) as usize;\n+    (&42u8 << 4) as usize;\n+\n+    let cap = 512 * 512;\n+    cap as u8;\n+    // Assert `cap` did not get inferred to `u8` and overflowed.\n+    assert_ne!(cap, 0);\n+}"}]}