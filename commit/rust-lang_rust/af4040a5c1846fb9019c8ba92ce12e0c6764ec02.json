{"sha": "af4040a5c1846fb9019c8ba92ce12e0c6764ec02", "node_id": "C_kwDOAAsO6NoAKGFmNDA0MGE1YzE4NDZmYjkwMTljOGJhOTJjZTEyZTBjNjc2NGVjMDI", "commit": {"author": {"name": "Celina G. Val", "email": "celinval@amazon.com", "date": "2023-06-13T22:08:14Z"}, "committer": {"name": "Celina G. Val", "email": "celinval@amazon.com", "date": "2023-06-13T22:17:01Z"}, "message": "Use a Stable trait to translate mir -> smir\n\nI was wondering if this would be a bit cleaner.", "tree": {"sha": "239a4799fd5f614d4f349d9e7ea86c7e824b7f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/239a4799fd5f614d4f349d9e7ea86c7e824b7f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af4040a5c1846fb9019c8ba92ce12e0c6764ec02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af4040a5c1846fb9019c8ba92ce12e0c6764ec02", "html_url": "https://github.com/rust-lang/rust/commit/af4040a5c1846fb9019c8ba92ce12e0c6764ec02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af4040a5c1846fb9019c8ba92ce12e0c6764ec02/comments", "author": {"login": "celinval", "id": 35149715, "node_id": "MDQ6VXNlcjM1MTQ5NzE1", "avatar_url": "https://avatars.githubusercontent.com/u/35149715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/celinval", "html_url": "https://github.com/celinval", "followers_url": "https://api.github.com/users/celinval/followers", "following_url": "https://api.github.com/users/celinval/following{/other_user}", "gists_url": "https://api.github.com/users/celinval/gists{/gist_id}", "starred_url": "https://api.github.com/users/celinval/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/celinval/subscriptions", "organizations_url": "https://api.github.com/users/celinval/orgs", "repos_url": "https://api.github.com/users/celinval/repos", "events_url": "https://api.github.com/users/celinval/events{/privacy}", "received_events_url": "https://api.github.com/users/celinval/received_events", "type": "User", "site_admin": false}, "committer": {"login": "celinval", "id": 35149715, "node_id": "MDQ6VXNlcjM1MTQ5NzE1", "avatar_url": "https://avatars.githubusercontent.com/u/35149715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/celinval", "html_url": "https://github.com/celinval", "followers_url": "https://api.github.com/users/celinval/followers", "following_url": "https://api.github.com/users/celinval/following{/other_user}", "gists_url": "https://api.github.com/users/celinval/gists{/gist_id}", "starred_url": "https://api.github.com/users/celinval/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/celinval/subscriptions", "organizations_url": "https://api.github.com/users/celinval/orgs", "repos_url": "https://api.github.com/users/celinval/repos", "events_url": "https://api.github.com/users/celinval/events{/privacy}", "received_events_url": "https://api.github.com/users/celinval/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5683791ebb7bbc440366635c322ad82badc554ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/5683791ebb7bbc440366635c322ad82badc554ca", "html_url": "https://github.com/rust-lang/rust/commit/5683791ebb7bbc440366635c322ad82badc554ca"}], "stats": {"total": 397, "additions": 203, "deletions": 194}, "files": [{"sha": "6bd030b13d1ce861c7b8ec5ca6c4c1fc6f1ea0e8", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 203, "deletions": 194, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/af4040a5c1846fb9019c8ba92ce12e0c6764ec02/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af4040a5c1846fb9019c8ba92ce12e0c6764ec02/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=af4040a5c1846fb9019c8ba92ce12e0c6764ec02", "patch": "@@ -8,6 +8,7 @@\n //! For now, we are developing everything inside `rustc`, thus, we keep this module private.\n \n use crate::stable_mir::{self, ty::TyKind, Context};\n+use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use tracing::debug;\n@@ -42,8 +43,8 @@ impl<'tcx> Context for Tables<'tcx> {\n                 .basic_blocks\n                 .iter()\n                 .map(|block| stable_mir::mir::BasicBlock {\n-                    terminator: rustc_terminator_to_terminator(block.terminator()),\n-                    statements: block.statements.iter().map(rustc_statement_to_statement).collect(),\n+                    terminator: block.terminator().stable(),\n+                    statements: block.statements.iter().map(mir::Statement::stable).collect(),\n                 })\n                 .collect(),\n             locals: mir.local_decls.iter().map(|decl| self.intern_ty(decl.ty)).collect(),\n@@ -118,82 +119,95 @@ fn smir_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> stable_mir::Crate {\n     stable_mir::Crate { id: crate_num.into(), name: crate_name, is_local }\n }\n \n-fn rustc_statement_to_statement(\n-    s: &rustc_middle::mir::Statement<'_>,\n-) -> stable_mir::mir::Statement {\n-    use rustc_middle::mir::StatementKind::*;\n-    match &s.kind {\n-        Assign(assign) => stable_mir::mir::Statement::Assign(\n-            rustc_place_to_place(&assign.0),\n-            rustc_rvalue_to_rvalue(&assign.1),\n-        ),\n-        FakeRead(_) => todo!(),\n-        SetDiscriminant { .. } => todo!(),\n-        Deinit(_) => todo!(),\n-        StorageLive(_) => todo!(),\n-        StorageDead(_) => todo!(),\n-        Retag(_, _) => todo!(),\n-        PlaceMention(_) => todo!(),\n-        AscribeUserType(_, _) => todo!(),\n-        Coverage(_) => todo!(),\n-        Intrinsic(_) => todo!(),\n-        ConstEvalCounter => todo!(),\n-        Nop => stable_mir::mir::Statement::Nop,\n+pub trait Stable {\n+    type T;\n+    fn stable(&self) -> Self::T;\n+}\n+\n+impl<'tcx> Stable for mir::Statement<'tcx> {\n+    type T = stable_mir::mir::Statement;\n+    fn stable(&self) -> Self::T {\n+        use rustc_middle::mir::StatementKind::*;\n+        match &self.kind {\n+            Assign(assign) => {\n+                stable_mir::mir::Statement::Assign(assign.0.stable(), assign.1.stable())\n+            }\n+            FakeRead(_) => todo!(),\n+            SetDiscriminant { .. } => todo!(),\n+            Deinit(_) => todo!(),\n+            StorageLive(_) => todo!(),\n+            StorageDead(_) => todo!(),\n+            Retag(_, _) => todo!(),\n+            PlaceMention(_) => todo!(),\n+            AscribeUserType(_, _) => todo!(),\n+            Coverage(_) => todo!(),\n+            Intrinsic(_) => todo!(),\n+            ConstEvalCounter => todo!(),\n+            Nop => stable_mir::mir::Statement::Nop,\n+        }\n     }\n }\n \n-fn rustc_rvalue_to_rvalue(rvalue: &rustc_middle::mir::Rvalue<'_>) -> stable_mir::mir::Rvalue {\n-    use rustc_middle::mir::Rvalue::*;\n-    match rvalue {\n-        Use(op) => stable_mir::mir::Rvalue::Use(rustc_op_to_op(op)),\n-        Repeat(_, _) => todo!(),\n-        Ref(_, _, _) => todo!(),\n-        ThreadLocalRef(_) => todo!(),\n-        AddressOf(_, _) => todo!(),\n-        Len(_) => todo!(),\n-        Cast(_, _, _) => todo!(),\n-        BinaryOp(_, _) => todo!(),\n-        CheckedBinaryOp(bin_op, ops) => stable_mir::mir::Rvalue::CheckedBinaryOp(\n-            rustc_bin_op_to_bin_op(bin_op),\n-            rustc_op_to_op(&ops.0),\n-            rustc_op_to_op(&ops.1),\n-        ),\n-        NullaryOp(_, _) => todo!(),\n-        UnaryOp(un_op, op) => {\n-            stable_mir::mir::Rvalue::UnaryOp(rustc_un_op_to_un_op(un_op), rustc_op_to_op(op))\n+impl<'tcx> Stable for mir::Rvalue<'tcx> {\n+    type T = stable_mir::mir::Rvalue;\n+    fn stable(&self) -> Self::T {\n+        use mir::Rvalue::*;\n+        match self {\n+            Use(op) => stable_mir::mir::Rvalue::Use(op.stable()),\n+            Repeat(_, _) => todo!(),\n+            Ref(_, _, _) => todo!(),\n+            ThreadLocalRef(_) => todo!(),\n+            AddressOf(_, _) => todo!(),\n+            Len(_) => todo!(),\n+            Cast(_, _, _) => todo!(),\n+            BinaryOp(_, _) => todo!(),\n+            CheckedBinaryOp(bin_op, ops) => stable_mir::mir::Rvalue::CheckedBinaryOp(\n+                bin_op.stable(),\n+                ops.0.stable(),\n+                ops.1.stable(),\n+            ),\n+            NullaryOp(_, _) => todo!(),\n+            UnaryOp(un_op, op) => stable_mir::mir::Rvalue::UnaryOp(un_op.stable(), op.stable()),\n+            Discriminant(_) => todo!(),\n+            Aggregate(_, _) => todo!(),\n+            ShallowInitBox(_, _) => todo!(),\n+            CopyForDeref(_) => todo!(),\n         }\n-        Discriminant(_) => todo!(),\n-        Aggregate(_, _) => todo!(),\n-        ShallowInitBox(_, _) => todo!(),\n-        CopyForDeref(_) => todo!(),\n     }\n }\n \n-fn rustc_op_to_op(op: &rustc_middle::mir::Operand<'_>) -> stable_mir::mir::Operand {\n-    use rustc_middle::mir::Operand::*;\n-    match op {\n-        Copy(place) => stable_mir::mir::Operand::Copy(rustc_place_to_place(place)),\n-        Move(place) => stable_mir::mir::Operand::Move(rustc_place_to_place(place)),\n-        Constant(c) => stable_mir::mir::Operand::Constant(c.to_string()),\n+impl<'tcx> Stable for mir::Operand<'tcx> {\n+    type T = stable_mir::mir::Operand;\n+    fn stable(&self) -> Self::T {\n+        use mir::Operand::*;\n+        match self {\n+            Copy(place) => stable_mir::mir::Operand::Copy(place.stable()),\n+            Move(place) => stable_mir::mir::Operand::Move(place.stable()),\n+            Constant(c) => stable_mir::mir::Operand::Constant(c.to_string()),\n+        }\n     }\n }\n \n-fn rustc_place_to_place(place: &rustc_middle::mir::Place<'_>) -> stable_mir::mir::Place {\n-    stable_mir::mir::Place {\n-        local: place.local.as_usize(),\n-        projection: format!(\"{:?}\", place.projection),\n+impl<'tcx> Stable for mir::Place<'tcx> {\n+    type T = stable_mir::mir::Place;\n+    fn stable(&self) -> Self::T {\n+        stable_mir::mir::Place {\n+            local: self.local.as_usize(),\n+            projection: format!(\"{:?}\", self.projection),\n+        }\n     }\n }\n \n-fn rustc_unwind_to_unwind(\n-    unwind: &rustc_middle::mir::UnwindAction,\n-) -> stable_mir::mir::UnwindAction {\n-    use rustc_middle::mir::UnwindAction;\n-    match unwind {\n-        UnwindAction::Continue => stable_mir::mir::UnwindAction::Continue,\n-        UnwindAction::Unreachable => stable_mir::mir::UnwindAction::Unreachable,\n-        UnwindAction::Terminate => stable_mir::mir::UnwindAction::Terminate,\n-        UnwindAction::Cleanup(bb) => stable_mir::mir::UnwindAction::Cleanup(bb.as_usize()),\n+impl Stable for mir::UnwindAction {\n+    type T = stable_mir::mir::UnwindAction;\n+    fn stable(&self) -> Self::T {\n+        use rustc_middle::mir::UnwindAction;\n+        match self {\n+            UnwindAction::Continue => stable_mir::mir::UnwindAction::Continue,\n+            UnwindAction::Unreachable => stable_mir::mir::UnwindAction::Unreachable,\n+            UnwindAction::Terminate => stable_mir::mir::UnwindAction::Terminate,\n+            UnwindAction::Cleanup(bb) => stable_mir::mir::UnwindAction::Cleanup(bb.as_usize()),\n+        }\n     }\n }\n \n@@ -202,168 +216,163 @@ fn rustc_assert_msg_to_msg<'tcx>(\n ) -> stable_mir::mir::AssertMessage {\n     use rustc_middle::mir::AssertKind;\n     match assert_message {\n-        AssertKind::BoundsCheck { len, index } => stable_mir::mir::AssertMessage::BoundsCheck {\n-            len: rustc_op_to_op(len),\n-            index: rustc_op_to_op(index),\n-        },\n-        AssertKind::Overflow(bin_op, op1, op2) => stable_mir::mir::AssertMessage::Overflow(\n-            rustc_bin_op_to_bin_op(bin_op),\n-            rustc_op_to_op(op1),\n-            rustc_op_to_op(op2),\n-        ),\n-        AssertKind::OverflowNeg(op) => {\n-            stable_mir::mir::AssertMessage::OverflowNeg(rustc_op_to_op(op))\n+        AssertKind::BoundsCheck { len, index } => {\n+            stable_mir::mir::AssertMessage::BoundsCheck { len: len.stable(), index: index.stable() }\n+        }\n+        AssertKind::Overflow(bin_op, op1, op2) => {\n+            stable_mir::mir::AssertMessage::Overflow(bin_op.stable(), op1.stable(), op2.stable())\n         }\n+        AssertKind::OverflowNeg(op) => stable_mir::mir::AssertMessage::OverflowNeg(op.stable()),\n         AssertKind::DivisionByZero(op) => {\n-            stable_mir::mir::AssertMessage::DivisionByZero(rustc_op_to_op(op))\n+            stable_mir::mir::AssertMessage::DivisionByZero(op.stable())\n         }\n         AssertKind::RemainderByZero(op) => {\n-            stable_mir::mir::AssertMessage::RemainderByZero(rustc_op_to_op(op))\n+            stable_mir::mir::AssertMessage::RemainderByZero(op.stable())\n         }\n         AssertKind::ResumedAfterReturn(generator) => {\n-            stable_mir::mir::AssertMessage::ResumedAfterReturn(rustc_generator_to_generator(\n-                generator,\n-            ))\n+            stable_mir::mir::AssertMessage::ResumedAfterReturn(generator.stable())\n         }\n         AssertKind::ResumedAfterPanic(generator) => {\n-            stable_mir::mir::AssertMessage::ResumedAfterPanic(rustc_generator_to_generator(\n-                generator,\n-            ))\n+            stable_mir::mir::AssertMessage::ResumedAfterPanic(generator.stable())\n         }\n         AssertKind::MisalignedPointerDereference { required, found } => {\n             stable_mir::mir::AssertMessage::MisalignedPointerDereference {\n-                required: rustc_op_to_op(required),\n-                found: rustc_op_to_op(found),\n+                required: required.stable(),\n+                found: found.stable(),\n             }\n         }\n     }\n }\n \n-fn rustc_bin_op_to_bin_op(bin_op: &rustc_middle::mir::BinOp) -> stable_mir::mir::BinOp {\n-    use rustc_middle::mir::BinOp;\n-    match bin_op {\n-        BinOp::Add => stable_mir::mir::BinOp::Add,\n-        BinOp::Sub => stable_mir::mir::BinOp::Sub,\n-        BinOp::Mul => stable_mir::mir::BinOp::Mul,\n-        BinOp::Div => stable_mir::mir::BinOp::Div,\n-        BinOp::Rem => stable_mir::mir::BinOp::Rem,\n-        BinOp::BitXor => stable_mir::mir::BinOp::BitXor,\n-        BinOp::BitAnd => stable_mir::mir::BinOp::BitAnd,\n-        BinOp::BitOr => stable_mir::mir::BinOp::BitOr,\n-        BinOp::Shl => stable_mir::mir::BinOp::Shl,\n-        BinOp::Shr => stable_mir::mir::BinOp::Shr,\n-        BinOp::Eq => stable_mir::mir::BinOp::Eq,\n-        BinOp::Lt => stable_mir::mir::BinOp::Lt,\n-        BinOp::Le => stable_mir::mir::BinOp::Le,\n-        BinOp::Ne => stable_mir::mir::BinOp::Ne,\n-        BinOp::Ge => stable_mir::mir::BinOp::Ge,\n-        BinOp::Gt => stable_mir::mir::BinOp::Gt,\n-        BinOp::Offset => stable_mir::mir::BinOp::Offset,\n+impl Stable for mir::BinOp {\n+    type T = stable_mir::mir::BinOp;\n+    fn stable(&self) -> Self::T {\n+        use mir::BinOp;\n+        match self {\n+            BinOp::Add => stable_mir::mir::BinOp::Add,\n+            BinOp::Sub => stable_mir::mir::BinOp::Sub,\n+            BinOp::Mul => stable_mir::mir::BinOp::Mul,\n+            BinOp::Div => stable_mir::mir::BinOp::Div,\n+            BinOp::Rem => stable_mir::mir::BinOp::Rem,\n+            BinOp::BitXor => stable_mir::mir::BinOp::BitXor,\n+            BinOp::BitAnd => stable_mir::mir::BinOp::BitAnd,\n+            BinOp::BitOr => stable_mir::mir::BinOp::BitOr,\n+            BinOp::Shl => stable_mir::mir::BinOp::Shl,\n+            BinOp::Shr => stable_mir::mir::BinOp::Shr,\n+            BinOp::Eq => stable_mir::mir::BinOp::Eq,\n+            BinOp::Lt => stable_mir::mir::BinOp::Lt,\n+            BinOp::Le => stable_mir::mir::BinOp::Le,\n+            BinOp::Ne => stable_mir::mir::BinOp::Ne,\n+            BinOp::Ge => stable_mir::mir::BinOp::Ge,\n+            BinOp::Gt => stable_mir::mir::BinOp::Gt,\n+            BinOp::Offset => stable_mir::mir::BinOp::Offset,\n+        }\n     }\n }\n \n-fn rustc_un_op_to_un_op(unary_op: &rustc_middle::mir::UnOp) -> stable_mir::mir::UnOp {\n-    use rustc_middle::mir::UnOp;\n-    match unary_op {\n-        UnOp::Not => stable_mir::mir::UnOp::Not,\n-        UnOp::Neg => stable_mir::mir::UnOp::Neg,\n+impl Stable for mir::UnOp {\n+    type T = stable_mir::mir::UnOp;\n+    fn stable(&self) -> Self::T {\n+        use mir::UnOp;\n+        match self {\n+            UnOp::Not => stable_mir::mir::UnOp::Not,\n+            UnOp::Neg => stable_mir::mir::UnOp::Neg,\n+        }\n     }\n }\n \n-fn rustc_generator_to_generator(\n-    generator: &rustc_hir::GeneratorKind,\n-) -> stable_mir::mir::GeneratorKind {\n-    use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n-    match generator {\n-        GeneratorKind::Async(async_gen) => {\n-            let async_gen = match async_gen {\n-                AsyncGeneratorKind::Block => stable_mir::mir::AsyncGeneratorKind::Block,\n-                AsyncGeneratorKind::Closure => stable_mir::mir::AsyncGeneratorKind::Closure,\n-                AsyncGeneratorKind::Fn => stable_mir::mir::AsyncGeneratorKind::Fn,\n-            };\n-            stable_mir::mir::GeneratorKind::Async(async_gen)\n+impl Stable for rustc_hir::GeneratorKind {\n+    type T = stable_mir::mir::GeneratorKind;\n+    fn stable(&self) -> Self::T {\n+        use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n+        match self {\n+            GeneratorKind::Async(async_gen) => {\n+                let async_gen = match async_gen {\n+                    AsyncGeneratorKind::Block => stable_mir::mir::AsyncGeneratorKind::Block,\n+                    AsyncGeneratorKind::Closure => stable_mir::mir::AsyncGeneratorKind::Closure,\n+                    AsyncGeneratorKind::Fn => stable_mir::mir::AsyncGeneratorKind::Fn,\n+                };\n+                stable_mir::mir::GeneratorKind::Async(async_gen)\n+            }\n+            GeneratorKind::Gen => stable_mir::mir::GeneratorKind::Gen,\n         }\n-        GeneratorKind::Gen => stable_mir::mir::GeneratorKind::Gen,\n     }\n }\n \n-fn rustc_inline_asm_operand_to_inline_asm_operand(\n-    operand: &rustc_middle::mir::InlineAsmOperand<'_>,\n-) -> stable_mir::mir::InlineAsmOperand {\n-    use rustc_middle::mir::InlineAsmOperand;\n+impl<'tcx> Stable for mir::InlineAsmOperand<'tcx> {\n+    type T = stable_mir::mir::InlineAsmOperand;\n+    fn stable(&self) -> Self::T {\n+        use rustc_middle::mir::InlineAsmOperand;\n \n-    let (in_value, out_place) = match operand {\n-        InlineAsmOperand::In { value, .. } => (Some(rustc_op_to_op(value)), None),\n-        InlineAsmOperand::Out { place, .. } => {\n-            (None, place.map(|place| rustc_place_to_place(&place)))\n-        }\n-        InlineAsmOperand::InOut { in_value, out_place, .. } => {\n-            (Some(rustc_op_to_op(in_value)), out_place.map(|place| rustc_place_to_place(&place)))\n-        }\n-        InlineAsmOperand::Const { .. }\n-        | InlineAsmOperand::SymFn { .. }\n-        | InlineAsmOperand::SymStatic { .. } => (None, None),\n-    };\n+        let (in_value, out_place) = match self {\n+            InlineAsmOperand::In { value, .. } => (Some(value.stable()), None),\n+            InlineAsmOperand::Out { place, .. } => (None, place.map(|place| place.stable())),\n+            InlineAsmOperand::InOut { in_value, out_place, .. } => {\n+                (Some(in_value.stable()), out_place.map(|place| place.stable()))\n+            }\n+            InlineAsmOperand::Const { .. }\n+            | InlineAsmOperand::SymFn { .. }\n+            | InlineAsmOperand::SymStatic { .. } => (None, None),\n+        };\n \n-    stable_mir::mir::InlineAsmOperand { in_value, out_place, raw_rpr: format!(\"{:?}\", operand) }\n+        stable_mir::mir::InlineAsmOperand { in_value, out_place, raw_rpr: format!(\"{:?}\", self) }\n+    }\n }\n \n-fn rustc_terminator_to_terminator(\n-    terminator: &rustc_middle::mir::Terminator<'_>,\n-) -> stable_mir::mir::Terminator {\n-    use rustc_middle::mir::TerminatorKind::*;\n-    use stable_mir::mir::Terminator;\n-    match &terminator.kind {\n-        Goto { target } => Terminator::Goto { target: target.as_usize() },\n-        SwitchInt { discr, targets } => Terminator::SwitchInt {\n-            discr: rustc_op_to_op(discr),\n-            targets: targets\n-                .iter()\n-                .map(|(value, target)| stable_mir::mir::SwitchTarget {\n-                    value,\n-                    target: target.as_usize(),\n-                })\n-                .collect(),\n-            otherwise: targets.otherwise().as_usize(),\n-        },\n-        Resume => Terminator::Resume,\n-        Terminate => Terminator::Abort,\n-        Return => Terminator::Return,\n-        Unreachable => Terminator::Unreachable,\n-        Drop { place, target, unwind, replace: _ } => Terminator::Drop {\n-            place: rustc_place_to_place(place),\n-            target: target.as_usize(),\n-            unwind: rustc_unwind_to_unwind(unwind),\n-        },\n-        Call { func, args, destination, target, unwind, from_hir_call: _, fn_span: _ } => {\n-            Terminator::Call {\n-                func: rustc_op_to_op(func),\n-                args: args.iter().map(|arg| rustc_op_to_op(arg)).collect(),\n-                destination: rustc_place_to_place(destination),\n-                target: target.map(|t| t.as_usize()),\n-                unwind: rustc_unwind_to_unwind(unwind),\n-            }\n-        }\n-        Assert { cond, expected, msg, target, unwind } => Terminator::Assert {\n-            cond: rustc_op_to_op(cond),\n-            expected: *expected,\n-            msg: rustc_assert_msg_to_msg(msg),\n-            target: target.as_usize(),\n-            unwind: rustc_unwind_to_unwind(unwind),\n-        },\n-        InlineAsm { template, operands, options, line_spans, destination, unwind } => {\n-            Terminator::InlineAsm {\n-                template: format!(\"{:?}\", template),\n-                operands: operands\n+impl<'tcx> Stable for mir::Terminator<'tcx> {\n+    type T = stable_mir::mir::Terminator;\n+    fn stable(&self) -> Self::T {\n+        use rustc_middle::mir::TerminatorKind::*;\n+        use stable_mir::mir::Terminator;\n+        match &self.kind {\n+            Goto { target } => Terminator::Goto { target: target.as_usize() },\n+            SwitchInt { discr, targets } => Terminator::SwitchInt {\n+                discr: discr.stable(),\n+                targets: targets\n                     .iter()\n-                    .map(|operand| rustc_inline_asm_operand_to_inline_asm_operand(operand))\n+                    .map(|(value, target)| stable_mir::mir::SwitchTarget {\n+                        value,\n+                        target: target.as_usize(),\n+                    })\n                     .collect(),\n-                options: format!(\"{:?}\", options),\n-                line_spans: format!(\"{:?}\", line_spans),\n-                destination: destination.map(|d| d.as_usize()),\n-                unwind: rustc_unwind_to_unwind(unwind),\n+                otherwise: targets.otherwise().as_usize(),\n+            },\n+            Resume => Terminator::Resume,\n+            Terminate => Terminator::Abort,\n+            Return => Terminator::Return,\n+            Unreachable => Terminator::Unreachable,\n+            Drop { place, target, unwind, replace: _ } => Terminator::Drop {\n+                place: place.stable(),\n+                target: target.as_usize(),\n+                unwind: unwind.stable(),\n+            },\n+            Call { func, args, destination, target, unwind, from_hir_call: _, fn_span: _ } => {\n+                Terminator::Call {\n+                    func: func.stable(),\n+                    args: args.iter().map(|arg| arg.stable()).collect(),\n+                    destination: destination.stable(),\n+                    target: target.map(|t| t.as_usize()),\n+                    unwind: unwind.stable(),\n+                }\n+            }\n+            Assert { cond, expected, msg, target, unwind } => Terminator::Assert {\n+                cond: cond.stable(),\n+                expected: *expected,\n+                msg: rustc_assert_msg_to_msg(msg),\n+                target: target.as_usize(),\n+                unwind: unwind.stable(),\n+            },\n+            InlineAsm { template, operands, options, line_spans, destination, unwind } => {\n+                Terminator::InlineAsm {\n+                    template: format!(\"{:?}\", template),\n+                    operands: operands.iter().map(|operand| operand.stable()).collect(),\n+                    options: format!(\"{:?}\", options),\n+                    line_spans: format!(\"{:?}\", line_spans),\n+                    destination: destination.map(|d| d.as_usize()),\n+                    unwind: unwind.stable(),\n+                }\n             }\n+            Yield { .. } | GeneratorDrop | FalseEdge { .. } | FalseUnwind { .. } => unreachable!(),\n         }\n-        Yield { .. } | GeneratorDrop | FalseEdge { .. } | FalseUnwind { .. } => unreachable!(),\n     }\n }"}]}