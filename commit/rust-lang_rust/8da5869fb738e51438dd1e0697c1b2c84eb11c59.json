{"sha": "8da5869fb738e51438dd1e0697c1b2c84eb11c59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYTU4NjlmYjczOGU1MTQzOGRkMWUwNjk3YzFiMmM4NGViMTFjNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-06T07:03:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-06T07:03:31Z"}, "message": "Auto merge of #69464 - Marwes:detach_undo_log, r=nikomatsakis\n\nperf: Unify the undo log of all snapshot types\n\nExtracted from #69218 and extended to all the current snapshot types.\n\nSince snapshotting is such a frequent action in the compiler and many of the scopes execute so little work, the act of creating the snapshot and rolling back empty/small snapshots end up showing in perf. By unifying all the logs into one the creation of snapshots becomes significantly cheaper at the cost of some complexity when combining the log with the specific data structures that are being mutated.\n\nDepends on https://github.com/rust-lang-nursery/ena/pull/29", "tree": {"sha": "70df81cd5fc440c16bfb091a4f7826c7d0cfe6c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70df81cd5fc440c16bfb091a4f7826c7d0cfe6c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da5869fb738e51438dd1e0697c1b2c84eb11c59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da5869fb738e51438dd1e0697c1b2c84eb11c59", "html_url": "https://github.com/rust-lang/rust/commit/8da5869fb738e51438dd1e0697c1b2c84eb11c59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da5869fb738e51438dd1e0697c1b2c84eb11c59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43271a39adc26d29350d4830b594c6435472815e", "url": "https://api.github.com/repos/rust-lang/rust/commits/43271a39adc26d29350d4830b594c6435472815e", "html_url": "https://github.com/rust-lang/rust/commit/43271a39adc26d29350d4830b594c6435472815e"}, {"sha": "3f85338f3f2a8e03b90e65fafd0bbe998baae98e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f85338f3f2a8e03b90e65fafd0bbe998baae98e", "html_url": "https://github.com/rust-lang/rust/commit/3f85338f3f2a8e03b90e65fafd0bbe998baae98e"}], "stats": {"total": 1428, "additions": 893, "deletions": 535}, "files": [{"sha": "83d7df889f904ad6553fdb3947f13353f5ff609d", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -993,6 +993,15 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d7402b94a93c24e742487327a7cd839dc9d36fec9de9fb25b09f2dae459f36c3\"\n+dependencies = [\n+ \"log\",\n+]\n+\n [[package]]\n name = \"encoding_rs\"\n version = \"0.8.17\"\n@@ -3234,7 +3243,7 @@ dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n- \"ena\",\n+ \"ena 0.13.1\",\n  \"indexmap\",\n  \"jobserver\",\n  \"lazy_static 1.4.0\",\n@@ -3683,7 +3692,7 @@ dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n- \"ena\",\n+ \"ena 0.14.0\",\n  \"graphviz\",\n  \"indexmap\",\n  \"jobserver\","}, {"sha": "e257ada0629b22c39f01ecaa77c7eb01d1c0b5b7", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-ena = \"0.13.1\"\n+ena = \"0.14\"\n indexmap = \"1\"\n log = \"0.4\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }"}, {"sha": "a7bee8a067c29e9acfabf59b03dda443f3046722", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -84,6 +84,7 @@ pub mod sync;\n pub mod thin_vec;\n pub mod tiny_list;\n pub mod transitive_relation;\n+pub use ena::undo_log;\n pub use ena::unify;\n mod atomic_ref;\n pub mod fingerprint;"}, {"sha": "52865f55f786b590289259d43faf8c0cfe17e14a", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 70, "deletions": 91, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -1,161 +1,140 @@\n use crate::fx::FxHashMap;\n+use crate::undo_log::{Rollback, Snapshots, UndoLogs, VecLog};\n+use std::borrow::{Borrow, BorrowMut};\n use std::hash::Hash;\n-use std::mem;\n+use std::marker::PhantomData;\n use std::ops;\n \n+pub use crate::undo_log::Snapshot;\n+\n #[cfg(test)]\n mod tests;\n \n-pub struct SnapshotMap<K, V>\n-where\n-    K: Clone + Eq,\n-{\n-    map: FxHashMap<K, V>,\n-    undo_log: Vec<UndoLog<K, V>>,\n-    num_open_snapshots: usize,\n+pub type SnapshotMapStorage<K, V> = SnapshotMap<K, V, FxHashMap<K, V>, ()>;\n+pub type SnapshotMapRef<'a, K, V, L> = SnapshotMap<K, V, &'a mut FxHashMap<K, V>, &'a mut L>;\n+\n+pub struct SnapshotMap<K, V, M = FxHashMap<K, V>, L = VecLog<UndoLog<K, V>>> {\n+    map: M,\n+    undo_log: L,\n+    _marker: PhantomData<(K, V)>,\n }\n \n // HACK(eddyb) manual impl avoids `Default` bounds on `K` and `V`.\n-impl<K, V> Default for SnapshotMap<K, V>\n+impl<K, V, M, L> Default for SnapshotMap<K, V, M, L>\n where\n-    K: Hash + Clone + Eq,\n+    M: Default,\n+    L: Default,\n {\n     fn default() -> Self {\n-        SnapshotMap { map: Default::default(), undo_log: Default::default(), num_open_snapshots: 0 }\n+        SnapshotMap { map: Default::default(), undo_log: Default::default(), _marker: PhantomData }\n     }\n }\n \n-pub struct Snapshot {\n-    len: usize,\n-}\n-\n-enum UndoLog<K, V> {\n+pub enum UndoLog<K, V> {\n     Inserted(K),\n     Overwrite(K, V),\n     Purged,\n }\n \n-impl<K, V> SnapshotMap<K, V>\n+impl<K, V, M, L> SnapshotMap<K, V, M, L> {\n+    pub fn with_log<L2>(&mut self, undo_log: L2) -> SnapshotMap<K, V, &mut M, L2> {\n+        SnapshotMap { map: &mut self.map, undo_log, _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V, M, L> SnapshotMap<K, V, M, L>\n where\n     K: Hash + Clone + Eq,\n+    M: BorrowMut<FxHashMap<K, V>> + Borrow<FxHashMap<K, V>>,\n+    L: UndoLogs<UndoLog<K, V>>,\n {\n     pub fn clear(&mut self) {\n-        self.map.clear();\n+        self.map.borrow_mut().clear();\n         self.undo_log.clear();\n-        self.num_open_snapshots = 0;\n-    }\n-\n-    fn in_snapshot(&self) -> bool {\n-        self.num_open_snapshots > 0\n     }\n \n     pub fn insert(&mut self, key: K, value: V) -> bool {\n-        match self.map.insert(key.clone(), value) {\n+        match self.map.borrow_mut().insert(key.clone(), value) {\n             None => {\n-                if self.in_snapshot() {\n-                    self.undo_log.push(UndoLog::Inserted(key));\n-                }\n+                self.undo_log.push(UndoLog::Inserted(key));\n                 true\n             }\n             Some(old_value) => {\n-                if self.in_snapshot() {\n-                    self.undo_log.push(UndoLog::Overwrite(key, old_value));\n-                }\n+                self.undo_log.push(UndoLog::Overwrite(key, old_value));\n                 false\n             }\n         }\n     }\n \n     pub fn remove(&mut self, key: K) -> bool {\n-        match self.map.remove(&key) {\n+        match self.map.borrow_mut().remove(&key) {\n             Some(old_value) => {\n-                if self.in_snapshot() {\n-                    self.undo_log.push(UndoLog::Overwrite(key, old_value));\n-                }\n+                self.undo_log.push(UndoLog::Overwrite(key, old_value));\n                 true\n             }\n             None => false,\n         }\n     }\n \n     pub fn get(&self, key: &K) -> Option<&V> {\n-        self.map.get(key)\n+        self.map.borrow().get(key)\n     }\n+}\n \n+impl<K, V> SnapshotMap<K, V>\n+where\n+    K: Hash + Clone + Eq,\n+{\n     pub fn snapshot(&mut self) -> Snapshot {\n-        let len = self.undo_log.len();\n-        self.num_open_snapshots += 1;\n-        Snapshot { len }\n-    }\n-\n-    fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n-        assert!(self.undo_log.len() >= snapshot.len);\n-        assert!(self.num_open_snapshots > 0);\n+        self.undo_log.start_snapshot()\n     }\n \n     pub fn commit(&mut self, snapshot: Snapshot) {\n-        self.assert_open_snapshot(&snapshot);\n-        if self.num_open_snapshots == 1 {\n-            // The root snapshot. It's safe to clear the undo log because\n-            // there's no snapshot further out that we might need to roll back\n-            // to.\n-            assert!(snapshot.len == 0);\n-            self.undo_log.clear();\n-        }\n-\n-        self.num_open_snapshots -= 1;\n+        self.undo_log.commit(snapshot)\n     }\n \n-    pub fn partial_rollback<F>(&mut self, snapshot: &Snapshot, should_revert_key: &F)\n-    where\n-        F: Fn(&K) -> bool,\n-    {\n-        self.assert_open_snapshot(snapshot);\n-        for i in (snapshot.len..self.undo_log.len()).rev() {\n-            let reverse = match self.undo_log[i] {\n-                UndoLog::Purged => false,\n-                UndoLog::Inserted(ref k) => should_revert_key(k),\n-                UndoLog::Overwrite(ref k, _) => should_revert_key(k),\n-            };\n-\n-            if reverse {\n-                let entry = mem::replace(&mut self.undo_log[i], UndoLog::Purged);\n-                self.reverse(entry);\n-            }\n-        }\n+    pub fn rollback_to(&mut self, snapshot: Snapshot) {\n+        let map = &mut self.map;\n+        self.undo_log.rollback_to(|| map, snapshot)\n     }\n+}\n \n-    pub fn rollback_to(&mut self, snapshot: Snapshot) {\n-        self.assert_open_snapshot(&snapshot);\n-        while self.undo_log.len() > snapshot.len {\n-            let entry = self.undo_log.pop().unwrap();\n-            self.reverse(entry);\n-        }\n+impl<'k, K, V, M, L> ops::Index<&'k K> for SnapshotMap<K, V, M, L>\n+where\n+    K: Hash + Clone + Eq,\n+    M: Borrow<FxHashMap<K, V>>,\n+{\n+    type Output = V;\n+    fn index(&self, key: &'k K) -> &V {\n+        &self.map.borrow()[key]\n+    }\n+}\n \n-        self.num_open_snapshots -= 1;\n+impl<K, V, M, L> Rollback<UndoLog<K, V>> for SnapshotMap<K, V, M, L>\n+where\n+    K: Eq + Hash,\n+    M: Rollback<UndoLog<K, V>>,\n+{\n+    fn reverse(&mut self, undo: UndoLog<K, V>) {\n+        self.map.reverse(undo)\n     }\n+}\n \n-    fn reverse(&mut self, entry: UndoLog<K, V>) {\n-        match entry {\n+impl<K, V> Rollback<UndoLog<K, V>> for FxHashMap<K, V>\n+where\n+    K: Eq + Hash,\n+{\n+    fn reverse(&mut self, undo: UndoLog<K, V>) {\n+        match undo {\n             UndoLog::Inserted(key) => {\n-                self.map.remove(&key);\n+                self.remove(&key);\n             }\n \n             UndoLog::Overwrite(key, old_value) => {\n-                self.map.insert(key, old_value);\n+                self.insert(key, old_value);\n             }\n \n             UndoLog::Purged => {}\n         }\n     }\n }\n-\n-impl<'k, K, V> ops::Index<&'k K> for SnapshotMap<K, V>\n-where\n-    K: Hash + Clone + Eq,\n-{\n-    type Output = V;\n-    fn index(&self, key: &'k K) -> &V {\n-        &self.map[key]\n-    }\n-}"}, {"sha": "d4af470499670423307089a4771808979a13022e", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -76,7 +76,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n                 self.inner\n                     .borrow_mut()\n-                    .int_unification_table\n+                    .int_unification_table()\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| int_unification_error(a_is_expected, e))?;\n                 Ok(a)\n@@ -98,7 +98,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             (&ty::Infer(ty::FloatVar(a_id)), &ty::Infer(ty::FloatVar(b_id))) => {\n                 self.inner\n                     .borrow_mut()\n-                    .float_unification_table\n+                    .float_unification_table()\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n                 Ok(a)\n@@ -133,8 +133,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             return Ok(a);\n         }\n \n-        let a = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, a);\n-        let b = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, b);\n+        let a = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table(), a);\n+        let b = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table(), b);\n \n         let a_is_expected = relation.a_is_expected();\n \n@@ -145,7 +145,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             ) => {\n                 self.inner\n                     .borrow_mut()\n-                    .const_unification_table\n+                    .const_unification_table()\n                     .unify_var_var(a_vid, b_vid)\n                     .map_err(|e| const_unification_error(a_is_expected, e))?;\n                 return Ok(a);\n@@ -179,7 +179,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         self.inner\n             .borrow_mut()\n-            .const_unification_table\n+            .const_unification_table()\n             .unify_var_value(\n                 vid,\n                 ConstVarValue {\n@@ -202,7 +202,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n         self.inner\n             .borrow_mut()\n-            .int_unification_table\n+            .int_unification_table()\n             .unify_var_value(vid, Some(val))\n             .map_err(|e| int_unification_error(vid_is_expected, e))?;\n         match val {\n@@ -219,7 +219,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n         self.inner\n             .borrow_mut()\n-            .float_unification_table\n+            .float_unification_table()\n             .unify_var_value(vid, Some(ty::FloatVarValue(val)))\n             .map_err(|e| float_unification_error(vid_is_expected, e))?;\n         Ok(self.tcx.mk_mach_float(val))\n@@ -266,7 +266,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         use self::RelationDir::*;\n \n         // Get the actual variable that b_vid has been inferred to\n-        debug_assert!(self.infcx.inner.borrow_mut().type_variables.probe(b_vid).is_unknown());\n+        debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n         debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n \n@@ -286,7 +286,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n             a_ty, dir, b_vid, b_ty\n         );\n-        self.infcx.inner.borrow_mut().type_variables.instantiate(b_vid, b_ty);\n+        self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n         if needs_wf {\n             self.obligations.push(Obligation::new(\n@@ -344,7 +344,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n \n         debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n \n-        let for_universe = match self.infcx.inner.borrow_mut().type_variables.probe(for_vid) {\n+        let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n                 panic!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n             }\n@@ -356,7 +356,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n-            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n             for_universe,\n             ambient_variance,\n             needs_wf: false,\n@@ -508,14 +508,14 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         // us from creating infinitely sized types.\n         match t.kind {\n             ty::Infer(ty::TyVar(vid)) => {\n-                let vid = self.infcx.inner.borrow_mut().type_variables.root_var(vid);\n-                let sub_vid = self.infcx.inner.borrow_mut().type_variables.sub_root_var(vid);\n+                let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n+                let sub_vid = self.infcx.inner.borrow_mut().type_variables().sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n                     Err(TypeError::CyclicTy(self.root_ty))\n                 } else {\n-                    let probe = self.infcx.inner.borrow_mut().type_variables.probe(vid);\n+                    let probe = self.infcx.inner.borrow_mut().type_variables().probe(vid);\n                     match probe {\n                         TypeVariableValue::Known { value: u } => {\n                             debug!(\"generalize: known value {:?}\", u);\n@@ -542,12 +542,13 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                             }\n \n                             let origin =\n-                                *self.infcx.inner.borrow_mut().type_variables.var_origin(vid);\n-                            let new_var_id = self.infcx.inner.borrow_mut().type_variables.new_var(\n-                                self.for_universe,\n-                                false,\n-                                origin,\n-                            );\n+                                *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n+                            let new_var_id = self\n+                                .infcx\n+                                .inner\n+                                .borrow_mut()\n+                                .type_variables()\n+                                .new_var(self.for_universe, false, origin);\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n                             Ok(u)\n@@ -618,7 +619,8 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n         match c.val {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n                     ConstVariableValue::Known { value: u } => self.relate(&u, &u),"}, {"sha": "d054070e292fa2ec7c09d118529c3ebe770b5d56", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -72,14 +72,14 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n-        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n \n         debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n \n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n-                infcx.inner.borrow_mut().type_variables.equate(a_id, b_id);\n+                infcx.inner.borrow_mut().type_variables().equate(a_id, b_id);\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {"}, {"sha": "d8133c58df7eb4d37d4d1a5d79cd309e208e3399", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n                                         .infcx\n                                         .inner\n                                         .borrow_mut()\n-                                        .type_variables\n+                                        .type_variables()\n                                         .sub_unified(a_vid, b_vid),\n                                     _ => false,\n                                 }\n@@ -194,7 +194,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         highlight: Option<ty::print::RegionHighlightMode>,\n     ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n-            let ty_vars = &self.inner.borrow().type_variables;\n+            let mut inner = self.inner.borrow_mut();\n+            let ty_vars = &inner.type_variables();\n             let var_origin = ty_vars.var_origin(ty_vid);\n             if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n                 let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n@@ -248,7 +249,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-            let ty_vars = &self.inner.borrow().type_variables;\n+            let mut inner = self.inner.borrow_mut();\n+            let ty_vars = inner.type_variables();\n             let getter = move |ty_vid| {\n                 let var_origin = ty_vars.var_origin(ty_vid);\n                 if let TypeVariableOriginKind::TypeParameterDefinition(name, _) = var_origin.kind {"}, {"sha": "47346c3a85665e438bf0135de3944db62d11407e", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -147,15 +147,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n         match t.kind {\n             ty::Infer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n+                let opt_ty = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n                 self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n-                    .int_unification_table\n+                    .int_unification_table()\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::IntVar(v),\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n-                    .float_unification_table\n+                    .float_unification_table()\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::FloatVar(v),\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .infcx\n                     .inner\n                     .borrow_mut()\n-                    .const_unification_table\n+                    .const_unification_table()\n                     .probe_value(v)\n                     .val\n                     .known();"}, {"sha": "c6651108df53d9403793d606fc79e990b3fffef5", "filename": "src/librustc_infer/infer/fudge.rs", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffudge.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -3,18 +3,30 @@ use rustc_middle::ty::{self, ConstVid, FloatVid, IntVid, RegionVid, Ty, TyCtxt,\n \n use super::type_variable::TypeVariableOrigin;\n use super::InferCtxt;\n-use super::{ConstVariableOrigin, RegionVariableOrigin};\n+use super::{ConstVariableOrigin, RegionVariableOrigin, UnificationTable};\n \n+use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n use ut::UnifyKey;\n \n use std::ops::Range;\n \n+fn vars_since_snapshot<'tcx, T>(\n+    table: &mut UnificationTable<'_, 'tcx, T>,\n+    snapshot_var_len: usize,\n+) -> Range<T>\n+where\n+    T: UnifyKey,\n+    super::UndoLog<'tcx>: From<sv::UndoLog<ut::Delegate<T>>>,\n+{\n+    T::from_index(snapshot_var_len as u32)..T::from_index(table.len() as u32)\n+}\n+\n fn const_vars_since_snapshot<'tcx>(\n-    table: &mut ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>,\n-    snapshot: &ut::Snapshot<ut::InPlace<ConstVid<'tcx>>>,\n+    table: &mut UnificationTable<'_, 'tcx, ConstVid<'tcx>>,\n+    snapshot_var_len: usize,\n ) -> (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>) {\n-    let range = table.vars_since_snapshot(snapshot);\n+    let range = vars_since_snapshot(table, snapshot_var_len);\n     (\n         range.start..range.end,\n         (range.start.index..range.end.index)\n@@ -23,7 +35,26 @@ fn const_vars_since_snapshot<'tcx>(\n     )\n }\n \n+struct VariableLengths {\n+    type_var_len: usize,\n+    const_var_len: usize,\n+    int_var_len: usize,\n+    float_var_len: usize,\n+    region_constraints_len: usize,\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn variable_lengths(&self) -> VariableLengths {\n+        let mut inner = self.inner.borrow_mut();\n+        VariableLengths {\n+            type_var_len: inner.type_variables().num_vars(),\n+            const_var_len: inner.const_unification_table().len(),\n+            int_var_len: inner.int_unification_table().len(),\n+            float_var_len: inner.float_unification_table().len(),\n+            region_constraints_len: inner.unwrap_region_constraints().num_region_vars(),\n+        }\n+    }\n+\n     /// This rather funky routine is used while processing expected\n     /// types. What happens here is that we want to propagate a\n     /// coercion through the return type of a fn to its\n@@ -70,7 +101,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         debug!(\"fudge_inference_if_ok()\");\n \n-        let (mut fudger, value) = self.probe(|snapshot| {\n+        let variable_lengths = self.variable_lengths();\n+        let (mut fudger, value) = self.probe(|_| {\n             match f() {\n                 Ok(value) => {\n                     let value = self.resolve_vars_if_possible(&value);\n@@ -83,17 +115,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     let mut inner = self.inner.borrow_mut();\n                     let type_vars =\n-                        inner.type_variables.vars_since_snapshot(&snapshot.type_snapshot);\n-                    let int_vars =\n-                        inner.int_unification_table.vars_since_snapshot(&snapshot.int_snapshot);\n-                    let float_vars =\n-                        inner.float_unification_table.vars_since_snapshot(&snapshot.float_snapshot);\n+                        inner.type_variables().vars_since_snapshot(variable_lengths.type_var_len);\n+                    let int_vars = vars_since_snapshot(\n+                        &mut inner.int_unification_table(),\n+                        variable_lengths.int_var_len,\n+                    );\n+                    let float_vars = vars_since_snapshot(\n+                        &mut inner.float_unification_table(),\n+                        variable_lengths.float_var_len,\n+                    );\n                     let region_vars = inner\n                         .unwrap_region_constraints()\n-                        .vars_since_snapshot(&snapshot.region_constraints_snapshot);\n+                        .vars_since_snapshot(variable_lengths.region_constraints_len);\n                     let const_vars = const_vars_since_snapshot(\n-                        &mut inner.const_unification_table,\n-                        &snapshot.const_snapshot,\n+                        &mut inner.const_unification_table(),\n+                        variable_lengths.const_var_len,\n                     );\n \n                     let fudger = InferenceFudger {\n@@ -161,7 +197,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                     // that it is unbound, so we can just return\n                     // it.\n                     debug_assert!(\n-                        self.infcx.inner.borrow_mut().type_variables.probe(vid).is_unknown()\n+                        self.infcx.inner.borrow_mut().type_variables().probe(vid).is_unknown()\n                     );\n                     ty\n                 }"}, {"sha": "1bf43e74dcd840202ff13ebc01be285145d7dd53", "filename": "src/librustc_infer/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flattice.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -56,8 +56,8 @@ where\n     }\n \n     let infcx = this.infcx();\n-    let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n-    let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n+    let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n+    let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n     match (&a.kind, &b.kind) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to"}, {"sha": "2cf9dd882e4bbd2eccf3a666bb4b841896b8c69f", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 141, "deletions": 106, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -6,11 +6,14 @@ pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n \n+pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n+\n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::undo_log::Rollback;\n use rustc_data_structures::unify as ut;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n@@ -42,7 +45,9 @@ use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n-use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n+use self::region_constraints::{\n+    RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n+};\n use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n \n pub mod at;\n@@ -64,6 +69,7 @@ pub mod region_constraints;\n pub mod resolve;\n mod sub;\n pub mod type_variable;\n+mod undo_log;\n \n use crate::infer::canonical::OriginalQueryValues;\n pub use rustc_middle::infer::unify_key;\n@@ -80,6 +86,10 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n \n+pub(crate) type UnificationTable<'a, 'tcx, T> = ut::UnificationTable<\n+    ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut InferCtxtUndoLogs<'tcx>>,\n+>;\n+\n /// How we should handle region solving.\n ///\n /// This is used so that the region values inferred by HIR region solving are\n@@ -136,28 +146,28 @@ pub struct InferCtxtInner<'tcx> {\n     /// Cache for projections. This cache is snapshotted along with the infcx.\n     ///\n     /// Public so that `traits::project` can use it.\n-    pub projection_cache: traits::ProjectionCache<'tcx>,\n+    pub projection_cache: traits::ProjectionCacheStorage<'tcx>,\n \n     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n     /// that might instantiate a general type variable have an order,\n     /// represented by its upper and lower bounds.\n-    type_variables: type_variable::TypeVariableTable<'tcx>,\n+    type_variable_storage: type_variable::TypeVariableStorage<'tcx>,\n \n     /// Map from const parameter variable to the kind of const it represents.\n-    const_unification_table: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n+    const_unification_storage: ut::UnificationTableStorage<ty::ConstVid<'tcx>>,\n \n     /// Map from integral variable to the kind of integer it represents.\n-    int_unification_table: ut::UnificationTable<ut::InPlace<ty::IntVid>>,\n+    int_unification_storage: ut::UnificationTableStorage<ty::IntVid>,\n \n     /// Map from floating variable to the kind of float it represents.\n-    float_unification_table: ut::UnificationTable<ut::InPlace<ty::FloatVid>>,\n+    float_unification_storage: ut::UnificationTableStorage<ty::FloatVid>,\n \n     /// Tracks the set of region variables and the constraints between them.\n     /// This is initially `Some(_)` but when\n     /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n     /// -- further attempts to perform unification, etc., may fail if new\n     /// region constraints would've been added.\n-    region_constraints: Option<RegionConstraintCollector<'tcx>>,\n+    region_constraint_storage: Option<RegionConstraintStorage<'tcx>>,\n \n     /// A set of constraints that regionck must validate. Each\n     /// constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -190,24 +200,78 @@ pub struct InferCtxtInner<'tcx> {\n     /// for each body-id in this map, which will process the\n     /// obligations within. This is expected to be done 'late enough'\n     /// that all type inference variables have been bound and so forth.\n-    pub region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n+    region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n+\n+    undo_log: InferCtxtUndoLogs<'tcx>,\n }\n \n impl<'tcx> InferCtxtInner<'tcx> {\n     fn new() -> InferCtxtInner<'tcx> {\n         InferCtxtInner {\n             projection_cache: Default::default(),\n-            type_variables: type_variable::TypeVariableTable::new(),\n-            const_unification_table: ut::UnificationTable::new(),\n-            int_unification_table: ut::UnificationTable::new(),\n-            float_unification_table: ut::UnificationTable::new(),\n-            region_constraints: Some(RegionConstraintCollector::new()),\n+            type_variable_storage: type_variable::TypeVariableStorage::new(),\n+            undo_log: InferCtxtUndoLogs::default(),\n+            const_unification_storage: ut::UnificationTableStorage::new(),\n+            int_unification_storage: ut::UnificationTableStorage::new(),\n+            float_unification_storage: ut::UnificationTableStorage::new(),\n+            region_constraint_storage: Some(RegionConstraintStorage::new()),\n             region_obligations: vec![],\n         }\n     }\n \n-    pub fn unwrap_region_constraints(&mut self) -> &mut RegionConstraintCollector<'tcx> {\n-        self.region_constraints.as_mut().expect(\"region constraints already solved\")\n+    pub fn region_obligations(&self) -> &[(hir::HirId, RegionObligation<'tcx>)] {\n+        &self.region_obligations\n+    }\n+\n+    pub fn projection_cache(&mut self) -> traits::ProjectionCache<'_, 'tcx> {\n+        self.projection_cache.with_log(&mut self.undo_log)\n+    }\n+\n+    fn type_variables(&mut self) -> type_variable::TypeVariableTable<'_, 'tcx> {\n+        self.type_variable_storage.with_log(&mut self.undo_log)\n+    }\n+\n+    fn int_unification_table(\n+        &mut self,\n+    ) -> ut::UnificationTable<\n+        ut::InPlace<\n+            ty::IntVid,\n+            &mut ut::UnificationStorage<ty::IntVid>,\n+            &mut InferCtxtUndoLogs<'tcx>,\n+        >,\n+    > {\n+        self.int_unification_storage.with_log(&mut self.undo_log)\n+    }\n+\n+    fn float_unification_table(\n+        &mut self,\n+    ) -> ut::UnificationTable<\n+        ut::InPlace<\n+            ty::FloatVid,\n+            &mut ut::UnificationStorage<ty::FloatVid>,\n+            &mut InferCtxtUndoLogs<'tcx>,\n+        >,\n+    > {\n+        self.float_unification_storage.with_log(&mut self.undo_log)\n+    }\n+\n+    fn const_unification_table(\n+        &mut self,\n+    ) -> ut::UnificationTable<\n+        ut::InPlace<\n+            ty::ConstVid<'tcx>,\n+            &mut ut::UnificationStorage<ty::ConstVid<'tcx>>,\n+            &mut InferCtxtUndoLogs<'tcx>,\n+        >,\n+    > {\n+        self.const_unification_storage.with_log(&mut self.undo_log)\n+    }\n+\n+    pub fn unwrap_region_constraints(&mut self) -> RegionConstraintCollector<'_, 'tcx> {\n+        self.region_constraint_storage\n+            .as_mut()\n+            .expect(\"region constraints already solved\")\n+            .with_log(&mut self.undo_log)\n     }\n }\n \n@@ -643,16 +707,10 @@ impl<'tcx> InferOk<'tcx, ()> {\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx> {\n-    projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n-    type_snapshot: type_variable::Snapshot<'tcx>,\n-    const_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n-    int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n-    float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n+    undo_snapshot: Snapshot<'tcx>,\n     region_constraints_snapshot: RegionSnapshot,\n-    region_obligations_snapshot: usize,\n     universe: ty::UniverseIndex,\n     was_in_snapshot: bool,\n-    was_skip_leak_check: bool,\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n@@ -667,7 +725,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n         match ty.kind {\n-            ty::Infer(ty::TyVar(vid)) => self.inner.borrow().type_variables.var_diverges(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n             _ => false,\n         }\n     }\n@@ -681,14 +739,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.kind {\n             ty::Infer(ty::IntVar(vid)) => {\n-                if self.inner.borrow_mut().int_unification_table.probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().int_unification_table().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             }\n             ty::Infer(ty::FloatVar(vid)) => {\n-                if self.inner.borrow_mut().float_unification_table.probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().float_unification_table().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n@@ -703,21 +761,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // FIXME(const_generics): should there be an equivalent function for const variables?\n \n         let mut vars: Vec<Ty<'_>> = inner\n-            .type_variables\n+            .type_variables()\n             .unsolved_variables()\n             .into_iter()\n             .map(|t| self.tcx.mk_ty_var(t))\n             .collect();\n         vars.extend(\n-            (0..inner.int_unification_table.len())\n+            (0..inner.int_unification_table().len())\n                 .map(|i| ty::IntVid { index: i as u32 })\n-                .filter(|&vid| inner.int_unification_table.probe_value(vid).is_none())\n+                .filter(|&vid| inner.int_unification_table().probe_value(vid).is_none())\n                 .map(|v| self.tcx.mk_int_var(v)),\n         );\n         vars.extend(\n-            (0..inner.float_unification_table.len())\n+            (0..inner.float_unification_table().len())\n                 .map(|i| ty::FloatVid { index: i as u32 })\n-                .filter(|&vid| inner.float_unification_table.probe_value(vid).is_none())\n+                .filter(|&vid| inner.float_unification_table().probe_value(vid).is_none())\n                 .map(|v| self.tcx.mk_float_var(v)),\n         );\n         vars\n@@ -769,17 +827,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let in_snapshot = self.in_snapshot.replace(true);\n \n         let mut inner = self.inner.borrow_mut();\n+\n         CombinedSnapshot {\n-            projection_cache_snapshot: inner.projection_cache.snapshot(),\n-            type_snapshot: inner.type_variables.snapshot(),\n-            const_snapshot: inner.const_unification_table.snapshot(),\n-            int_snapshot: inner.int_unification_table.snapshot(),\n-            float_snapshot: inner.float_unification_table.snapshot(),\n+            undo_snapshot: inner.undo_log.start_snapshot(),\n             region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n-            region_obligations_snapshot: inner.region_obligations.len(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n-            was_skip_leak_check: self.skip_leak_check.get(),\n             // Borrow tables \"in progress\" (i.e., during typeck)\n             // to ban writes from within a snapshot to them.\n             _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n@@ -789,59 +842,34 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot {\n-            projection_cache_snapshot,\n-            type_snapshot,\n-            const_snapshot,\n-            int_snapshot,\n-            float_snapshot,\n+            undo_snapshot,\n             region_constraints_snapshot,\n-            region_obligations_snapshot,\n             universe,\n             was_in_snapshot,\n-            was_skip_leak_check,\n             _in_progress_tables,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n-        self.skip_leak_check.set(was_skip_leak_check);\n \n         let mut inner = self.inner.borrow_mut();\n-        inner.projection_cache.rollback_to(projection_cache_snapshot);\n-        inner.type_variables.rollback_to(type_snapshot);\n-        inner.const_unification_table.rollback_to(const_snapshot);\n-        inner.int_unification_table.rollback_to(int_snapshot);\n-        inner.float_unification_table.rollback_to(float_snapshot);\n+        inner.rollback_to(undo_snapshot);\n         inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n-        inner.region_obligations.truncate(region_obligations_snapshot);\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n         let CombinedSnapshot {\n-            projection_cache_snapshot,\n-            type_snapshot,\n-            const_snapshot,\n-            int_snapshot,\n-            float_snapshot,\n-            region_constraints_snapshot,\n-            region_obligations_snapshot: _,\n+            undo_snapshot,\n+            region_constraints_snapshot: _,\n             universe: _,\n             was_in_snapshot,\n-            was_skip_leak_check,\n             _in_progress_tables,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n-        self.skip_leak_check.set(was_skip_leak_check);\n \n-        let mut inner = self.inner.borrow_mut();\n-        inner.projection_cache.commit(projection_cache_snapshot);\n-        inner.type_variables.commit(type_snapshot);\n-        inner.const_unification_table.commit(const_snapshot);\n-        inner.int_unification_table.commit(int_snapshot);\n-        inner.float_unification_table.commit(float_snapshot);\n-        inner.unwrap_region_constraints().commit(region_constraints_snapshot);\n+        self.inner.borrow_mut().commit(undo_snapshot);\n     }\n \n     /// Executes `f` and commit the bindings.\n@@ -895,10 +923,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n-        let skip_leak_check = should_skip || self.skip_leak_check.get();\n-        self.skip_leak_check.set(skip_leak_check);\n+        let was_skip_leak_check = self.skip_leak_check.get();\n+        if should_skip {\n+            self.skip_leak_check.set(true);\n+        }\n         let r = f(&snapshot);\n         self.rollback_to(\"probe\", snapshot);\n+        self.skip_leak_check.set(was_skip_leak_check);\n         r\n     }\n \n@@ -914,7 +945,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.inner\n             .borrow_mut()\n             .unwrap_region_constraints()\n-            .region_constraints_added_in_snapshot(&snapshot.region_constraints_snapshot)\n+            .region_constraints_added_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n     pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n@@ -1032,7 +1063,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n-        self.inner.borrow_mut().type_variables.new_var(self.universe(), diverging, origin)\n+        self.inner.borrow_mut().type_variables().new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n@@ -1044,7 +1075,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables.new_var(universe, false, origin);\n+        let vid = self.inner.borrow_mut().type_variables().new_var(universe, false, origin);\n         self.tcx.mk_ty_var(vid)\n     }\n \n@@ -1069,28 +1100,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let vid = self\n             .inner\n             .borrow_mut()\n-            .const_unification_table\n+            .const_unification_table()\n             .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n         self.tcx.mk_const_var(vid, ty)\n     }\n \n     pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n-        self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n+        self.inner.borrow_mut().const_unification_table().new_key(ConstVarValue {\n             origin,\n             val: ConstVariableValue::Unknown { universe: self.universe() },\n         })\n     }\n \n     fn next_int_var_id(&self) -> IntVid {\n-        self.inner.borrow_mut().int_unification_table.new_key(None)\n+        self.inner.borrow_mut().int_unification_table().new_key(None)\n     }\n \n     pub fn next_int_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_int_var(self.next_int_var_id())\n     }\n \n     fn next_float_var_id(&self) -> FloatVid {\n-        self.inner.borrow_mut().float_unification_table.new_key(None)\n+        self.inner.borrow_mut().float_unification_table().new_key(None)\n     }\n \n     pub fn next_float_var(&self) -> Ty<'tcx> {\n@@ -1161,7 +1192,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id = self.inner.borrow_mut().type_variables.new_var(\n+                let ty_var_id = self.inner.borrow_mut().type_variables().new_var(\n                     self.universe(),\n                     false,\n                     TypeVariableOrigin {\n@@ -1181,7 +1212,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     span,\n                 };\n                 let const_var_id =\n-                    self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n+                    self.inner.borrow_mut().const_unification_table().new_key(ConstVarValue {\n                         origin,\n                         val: ConstVariableValue::Unknown { universe: self.universe() },\n                     });\n@@ -1234,18 +1265,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         mode: RegionckMode,\n     ) {\n-        assert!(\n-            self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.inner.borrow().region_obligations\n-        );\n-        let (var_infos, data) = self\n-            .inner\n-            .borrow_mut()\n-            .region_constraints\n-            .take()\n-            .expect(\"regions already resolved\")\n-            .into_infos_and_data();\n+        let (var_infos, data) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let inner = &mut *inner;\n+            assert!(\n+                self.is_tainted_by_errors() || inner.region_obligations.is_empty(),\n+                \"region_obligations not empty: {:#?}\",\n+                inner.region_obligations\n+            );\n+            inner\n+                .region_constraint_storage\n+                .take()\n+                .expect(\"regions already resolved\")\n+                .with_log(&mut inner.undo_log)\n+                .into_infos_and_data()\n+        };\n \n         let region_rels = &RegionRelations::new(\n             self.tcx,\n@@ -1306,12 +1340,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region variables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n-        let (var_infos, data) = self\n-            .inner\n-            .borrow_mut()\n-            .region_constraints\n+        let mut inner = self.inner.borrow_mut();\n+        let (var_infos, data) = inner\n+            .region_constraint_storage\n             .take()\n             .expect(\"regions already resolved\")\n+            .with_log(&mut inner.undo_log)\n             .into_infos_and_data();\n         assert!(data.is_empty());\n         var_infos\n@@ -1335,7 +1369,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n         use self::type_variable::TypeVariableValue;\n \n-        match self.inner.borrow_mut().type_variables.probe(vid) {\n+        match self.inner.borrow_mut().type_variables().probe(vid) {\n             TypeVariableValue::Known { value } => Ok(value),\n             TypeVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1357,7 +1391,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n-        self.inner.borrow_mut().type_variables.root_var(var)\n+        self.inner.borrow_mut().type_variables().root_var(var)\n     }\n \n     /// Where possible, replaces type/const variables in\n@@ -1395,7 +1429,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         vid: ty::ConstVid<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n-        match self.inner.borrow_mut().const_unification_table.probe_value(vid).val {\n+        match self.inner.borrow_mut().const_unification_table().probe_value(vid).val {\n             ConstVariableValue::Known { value } => Ok(value),\n             ConstVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1513,7 +1547,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();\n         self.evaluation_cache.clear();\n-        self.inner.borrow_mut().projection_cache.clear();\n+        self.inner.borrow_mut().projection_cache().clear();\n     }\n \n     fn universe(&self) -> ty::UniverseIndex {\n@@ -1576,22 +1610,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 //\n                 // Note: if these two lines are combined into one we get\n                 // dynamic borrow errors on `self.inner`.\n-                let known = self.inner.borrow_mut().type_variables.probe(v).known();\n+                let known = self.inner.borrow_mut().type_variables().probe(v).known();\n                 known.map(|t| self.shallow_resolve_ty(t)).unwrap_or(typ)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self\n                 .inner\n                 .borrow_mut()\n-                .int_unification_table\n+                .int_unification_table()\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n \n             ty::Infer(ty::FloatVar(v)) => self\n                 .inner\n                 .borrow_mut()\n-                .float_unification_table\n+                .float_unification_table()\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n@@ -1611,13 +1645,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// having to resort to storing full `GenericArg`s in `stalled_on`.\n     #[inline(always)]\n     pub fn ty_or_const_infer_var_changed(&self, infer_var: TyOrConstInferVar<'tcx>) -> bool {\n+        let mut inner = self.inner.borrow_mut();\n         match infer_var {\n             TyOrConstInferVar::Ty(v) => {\n                 use self::type_variable::TypeVariableValue;\n \n                 // If `inlined_probe` returns a `Known` value, it never equals\n                 // `ty::Infer(ty::TyVar(v))`.\n-                match self.inner.borrow_mut().type_variables.inlined_probe(v) {\n+                match inner.type_variables().inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n@@ -1627,23 +1662,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which never matches a\n                 // `ty::Infer(_)`.\n-                self.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n+                inner.int_unification_table().inlined_probe_value(v).is_some()\n             }\n \n             TyOrConstInferVar::TyFloat(v) => {\n                 // If `probe_value` returns a value it's always a\n                 // `ty::Float(_)`, which never matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n+                inner.float_unification_table().probe_value(v).is_some()\n             }\n \n             TyOrConstInferVar::Const(v) => {\n                 // If `probe_value` returns a `Known` value, it never equals\n                 // `ty::ConstKind::Infer(ty::InferConst::Var(v))`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                match self.inner.borrow_mut().const_unification_table.probe_value(v).val {\n+                match inner.const_unification_table().probe_value(v).val {\n                     ConstVariableValue::Unknown { .. } => false,\n                     ConstVariableValue::Known { .. } => true,\n                 }\n@@ -1718,7 +1753,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n             self.infcx\n                 .inner\n                 .borrow_mut()\n-                .const_unification_table\n+                .const_unification_table()\n                 .probe_value(*vid)\n                 .val\n                 .known()"}, {"sha": "7aea26987a29f237d89b5bd093f99de5d4d8c9db", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -311,7 +311,7 @@ where\n         match value_ty.kind {\n             ty::Infer(ty::TyVar(value_vid)) => {\n                 // Two type variables: just equate them.\n-                self.infcx.inner.borrow_mut().type_variables.equate(vid, value_vid);\n+                self.infcx.inner.borrow_mut().type_variables().equate(vid, value_vid);\n                 return Ok(value_ty);\n             }\n \n@@ -332,7 +332,7 @@ where\n             assert!(!generalized_ty.has_infer_types_or_consts());\n         }\n \n-        self.infcx.inner.borrow_mut().type_variables.instantiate(vid, generalized_ty);\n+        self.infcx.inner.borrow_mut().type_variables().instantiate(vid, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n@@ -362,7 +362,7 @@ where\n             delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n-            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n             universe,\n         };\n \n@@ -859,7 +859,8 @@ where\n             }\n \n             ty::Infer(ty::TyVar(vid)) => {\n-                let variables = &mut self.infcx.inner.borrow_mut().type_variables;\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variables = &mut inner.type_variables();\n                 let vid = variables.root_var(vid);\n                 let sub_vid = variables.sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n@@ -961,7 +962,8 @@ where\n                 bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n             }\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val.known() {\n                     Some(u) => self.relate(&u, &u),"}, {"sha": "48f6d937f2f7abe50bbbbc596d2e171308218cef", "filename": "src/librustc_infer/infer/outlives/obligations.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -61,13 +61,16 @@\n \n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n-use crate::infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n+use crate::infer::{\n+    self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, UndoLog, VerifyBound,\n+};\n use crate::traits::ObligationCause;\n use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::undo_log::UndoLogs;\n use rustc_hir as hir;\n use smallvec::smallvec;\n \n@@ -84,7 +87,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"register_region_obligation(body_id={:?}, obligation={:?})\", body_id, obligation);\n \n-        self.inner.borrow_mut().region_obligations.push((body_id, obligation));\n+        let mut inner = self.inner.borrow_mut();\n+        inner.undo_log.push(UndoLog::PushRegionObligation);\n+        inner.region_obligations.push((body_id, obligation));\n     }\n \n     pub fn register_region_obligation_with_cause("}, {"sha": "473550d5433df3c14e8a4ad95c9ec75cde957ede", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -1,9 +1,10 @@\n use super::*;\n use crate::infer::{CombinedSnapshot, PlaceholderMap};\n+use rustc_data_structures::undo_log::UndoLogs;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::RelateResult;\n \n-impl<'tcx> RegionConstraintCollector<'tcx> {\n+impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     /// Searches region constraints created since `snapshot` that\n     /// affect one of the placeholders in `placeholder_map`, returning\n     /// an error if any of the placeholders are related to another\n@@ -31,7 +32,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     ) -> RelateResult<'tcx, ()> {\n         debug!(\"leak_check(placeholders={:?})\", placeholder_map);\n \n-        assert!(self.in_snapshot());\n+        assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n \n         // Go through each placeholder that we created.\n         for &placeholder_region in placeholder_map.values() {\n@@ -45,7 +46,11 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             // in some way. This means any region that either outlives\n             // or is outlived by a placeholder.\n             let mut taint_set = TaintSet::new(TaintDirections::both(), placeholder_region);\n-            taint_set.fixed_point(tcx, &self.undo_log, &self.data.verifys);\n+            taint_set.fixed_point(\n+                tcx,\n+                self.undo_log.region_constraints(),\n+                &self.storage.data.verifys,\n+            );\n             let tainted_regions = taint_set.into_set();\n \n             // Report an error if two placeholders in the same universe\n@@ -88,19 +93,21 @@ impl<'tcx> TaintSet<'tcx> {\n         TaintSet { directions, regions }\n     }\n \n-    fn fixed_point(\n+    fn fixed_point<'a>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        undo_log: &[UndoLog<'tcx>],\n+        undo_log: impl IntoIterator<Item = &'a UndoLog<'tcx>> + Clone,\n         verifys: &[Verify<'tcx>],\n-    ) {\n+    ) where\n+        'tcx: 'a,\n+    {\n         let mut prev_len = 0;\n         while prev_len < self.len() {\n             debug!(\"tainted: prev_len = {:?} new_len = {:?}\", prev_len, self.len());\n \n             prev_len = self.len();\n \n-            for undo_entry in undo_log {\n+            for undo_entry in undo_log.clone() {\n                 match undo_entry {\n                     &AddConstraint(Constraint::VarSubVar(a, b)) => {\n                         self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));"}, {"sha": "0c9f002a2a21dc7861cd91ea918d403f8284b3bb", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 119, "deletions": 135, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -4,11 +4,15 @@ use self::CombineMapType::*;\n use self::UndoLog::*;\n \n use super::unify_key;\n-use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n+use super::{\n+    InferCtxtUndoLogs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin,\n+};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify as ut;\n+use rustc_data_structures::unify::UnifyKey;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::ReStatic;\n@@ -26,7 +30,7 @@ mod leak_check;\n pub use rustc_middle::infer::MemberConstraint;\n \n #[derive(Default)]\n-pub struct RegionConstraintCollector<'tcx> {\n+pub struct RegionConstraintStorage<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n     var_infos: IndexVec<RegionVid, RegionVariableInfo>,\n \n@@ -42,20 +46,6 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// exist). This prevents us from making many such regions.\n     glbs: CombineMap<'tcx>,\n \n-    /// The undo log records actions that might later be undone.\n-    ///\n-    /// Note: `num_open_snapshots` is used to track if we are actively\n-    /// snapshotting. When the `start_snapshot()` method is called, we\n-    /// increment `num_open_snapshots` to indicate that we are now actively\n-    /// snapshotting. The reason for this is that otherwise we end up adding\n-    /// entries for things like the lower bound on a variable and so forth,\n-    /// which can never be rolled back.\n-    undo_log: Vec<UndoLog<'tcx>>,\n-\n-    /// The number of open snapshots, i.e., those that haven't been committed or\n-    /// rolled back.\n-    num_open_snapshots: usize,\n-\n     /// When we add a R1 == R2 constriant, we currently add (a) edges\n     /// R1 <= R2 and R2 <= R1 and (b) we unify the two regions in this\n     /// table. You can then call `opportunistic_resolve_var` early\n@@ -64,13 +54,31 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// is iterating to a fixed point, because otherwise we sometimes\n     /// would wind up with a fresh stream of region variables that\n     /// have been equated but appear distinct.\n-    unification_table: ut::UnificationTable<ut::InPlace<ty::RegionVid>>,\n+    pub(super) unification_table: ut::UnificationTableStorage<ty::RegionVid>,\n \n     /// a flag set to true when we perform any unifications; this is used\n     /// to micro-optimize `take_and_reset_data`\n     any_unifications: bool,\n }\n \n+pub struct RegionConstraintCollector<'a, 'tcx> {\n+    storage: &'a mut RegionConstraintStorage<'tcx>,\n+    undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+}\n+\n+impl std::ops::Deref for RegionConstraintCollector<'_, 'tcx> {\n+    type Target = RegionConstraintStorage<'tcx>;\n+    fn deref(&self) -> &RegionConstraintStorage<'tcx> {\n+        self.storage\n+    }\n+}\n+\n+impl std::ops::DerefMut for RegionConstraintCollector<'_, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut RegionConstraintStorage<'tcx> {\n+        self.storage\n+    }\n+}\n+\n pub type VarInfos = IndexVec<RegionVid, RegionVariableInfo>;\n \n /// The full set of region constraints gathered up by the collector.\n@@ -258,13 +266,13 @@ pub enum VerifyBound<'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-struct TwoRegions<'tcx> {\n+pub(crate) struct TwoRegions<'tcx> {\n     a: Region<'tcx>,\n     b: Region<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum UndoLog<'tcx> {\n+pub(crate) enum UndoLog<'tcx> {\n     /// We added `RegionVid`.\n     AddVar(RegionVid),\n \n@@ -290,7 +298,7 @@ enum UndoLog<'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum CombineMapType {\n+pub(crate) enum CombineMapType {\n     Lub,\n     Glb,\n }\n@@ -304,8 +312,6 @@ pub struct RegionVariableInfo {\n }\n \n pub struct RegionSnapshot {\n-    length: usize,\n-    region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n     any_unifications: bool,\n }\n \n@@ -334,11 +340,48 @@ impl TaintDirections {\n     }\n }\n \n-impl<'tcx> RegionConstraintCollector<'tcx> {\n+impl<'tcx> RegionConstraintStorage<'tcx> {\n     pub fn new() -> Self {\n         Self::default()\n     }\n \n+    pub(crate) fn with_log<'a>(\n+        &'a mut self,\n+        undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+    ) -> RegionConstraintCollector<'a, 'tcx> {\n+        RegionConstraintCollector { storage: self, undo_log }\n+    }\n+\n+    fn rollback_undo_entry(&mut self, undo_entry: UndoLog<'tcx>) {\n+        match undo_entry {\n+            Purged => {\n+                // nothing to do here\n+            }\n+            AddVar(vid) => {\n+                self.var_infos.pop().unwrap();\n+                assert_eq!(self.var_infos.len(), vid.index() as usize);\n+            }\n+            AddConstraint(ref constraint) => {\n+                self.data.constraints.remove(constraint);\n+            }\n+            AddVerify(index) => {\n+                self.data.verifys.pop();\n+                assert_eq!(self.data.verifys.len(), index);\n+            }\n+            AddGiven(sub, sup) => {\n+                self.data.givens.remove(&(sub, sup));\n+            }\n+            AddCombination(Glb, ref regions) => {\n+                self.glbs.remove(regions);\n+            }\n+            AddCombination(Lub, ref regions) => {\n+                self.lubs.remove(regions);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     pub fn num_region_vars(&self) -> usize {\n         self.var_infos.len()\n     }\n@@ -351,8 +394,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     ///\n     /// Not legal during a snapshot.\n     pub fn into_infos_and_data(self) -> (VarInfos, RegionConstraintData<'tcx>) {\n-        assert!(!self.in_snapshot());\n-        (self.var_infos, self.data)\n+        assert!(!UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n+        (mem::take(&mut self.storage.var_infos), mem::take(&mut self.storage.data))\n     }\n \n     /// Takes (and clears) the current set of constraints. Note that\n@@ -368,21 +411,19 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     ///\n     /// Not legal during a snapshot.\n     pub fn take_and_reset_data(&mut self) -> RegionConstraintData<'tcx> {\n-        assert!(!self.in_snapshot());\n+        assert!(!UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n \n         // If you add a new field to `RegionConstraintCollector`, you\n         // should think carefully about whether it needs to be cleared\n         // or updated in some way.\n-        let RegionConstraintCollector {\n+        let RegionConstraintStorage {\n             var_infos: _,\n             data,\n             lubs,\n             glbs,\n-            undo_log: _,\n-            num_open_snapshots: _,\n-            unification_table,\n+            unification_table: _,\n             any_unifications,\n-        } = self;\n+        } = self.storage;\n \n         // Clear the tables of (lubs, glbs), so that we will create\n         // fresh regions if we do a LUB operation. As it happens,\n@@ -391,114 +432,45 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         lubs.clear();\n         glbs.clear();\n \n+        let data = mem::take(data);\n+\n         // Clear all unifications and recreate the variables a \"now\n         // un-unified\" state. Note that when we unify `a` and `b`, we\n         // also insert `a <= b` and a `b <= a` edges, so the\n         // `RegionConstraintData` contains the relationship here.\n         if *any_unifications {\n-            unification_table.reset_unifications(|vid| unify_key::RegionVidKey { min_vid: vid });\n             *any_unifications = false;\n+            self.unification_table()\n+                .reset_unifications(|vid| unify_key::RegionVidKey { min_vid: vid });\n         }\n \n-        mem::take(data)\n+        data\n     }\n \n     pub fn data(&self) -> &RegionConstraintData<'tcx> {\n         &self.data\n     }\n \n-    fn in_snapshot(&self) -> bool {\n-        self.num_open_snapshots > 0\n-    }\n-\n     pub fn start_snapshot(&mut self) -> RegionSnapshot {\n-        let length = self.undo_log.len();\n-        debug!(\"RegionConstraintCollector: start_snapshot({})\", length);\n-        self.num_open_snapshots += 1;\n-        RegionSnapshot {\n-            length,\n-            region_snapshot: self.unification_table.snapshot(),\n-            any_unifications: self.any_unifications,\n-        }\n-    }\n-\n-    fn assert_open_snapshot(&self, snapshot: &RegionSnapshot) {\n-        assert!(self.undo_log.len() >= snapshot.length);\n-        assert!(self.num_open_snapshots > 0);\n-    }\n-\n-    pub fn commit(&mut self, snapshot: RegionSnapshot) {\n-        debug!(\"RegionConstraintCollector: commit({})\", snapshot.length);\n-        self.assert_open_snapshot(&snapshot);\n-\n-        if self.num_open_snapshots == 1 {\n-            // The root snapshot. It's safe to clear the undo log because\n-            // there's no snapshot further out that we might need to roll back\n-            // to.\n-            assert!(snapshot.length == 0);\n-            self.undo_log.clear();\n-        }\n-\n-        self.num_open_snapshots -= 1;\n-\n-        self.unification_table.commit(snapshot.region_snapshot);\n+        debug!(\"RegionConstraintCollector: start_snapshot\");\n+        RegionSnapshot { any_unifications: self.any_unifications }\n     }\n \n     pub fn rollback_to(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionConstraintCollector: rollback_to({:?})\", snapshot);\n-        self.assert_open_snapshot(&snapshot);\n-\n-        while self.undo_log.len() > snapshot.length {\n-            let undo_entry = self.undo_log.pop().unwrap();\n-            self.rollback_undo_entry(undo_entry);\n-        }\n-\n-        self.num_open_snapshots -= 1;\n-\n-        self.unification_table.rollback_to(snapshot.region_snapshot);\n         self.any_unifications = snapshot.any_unifications;\n     }\n \n-    fn rollback_undo_entry(&mut self, undo_entry: UndoLog<'tcx>) {\n-        match undo_entry {\n-            Purged => {\n-                // nothing to do here\n-            }\n-            AddVar(vid) => {\n-                self.var_infos.pop().unwrap();\n-                assert_eq!(self.var_infos.len(), vid.index() as usize);\n-            }\n-            AddConstraint(ref constraint) => {\n-                self.data.constraints.remove(constraint);\n-            }\n-            AddVerify(index) => {\n-                self.data.verifys.pop();\n-                assert_eq!(self.data.verifys.len(), index);\n-            }\n-            AddGiven(sub, sup) => {\n-                self.data.givens.remove(&(sub, sup));\n-            }\n-            AddCombination(Glb, ref regions) => {\n-                self.glbs.remove(regions);\n-            }\n-            AddCombination(Lub, ref regions) => {\n-                self.lubs.remove(regions);\n-            }\n-        }\n-    }\n-\n     pub fn new_region_var(\n         &mut self,\n         universe: ty::UniverseIndex,\n         origin: RegionVariableOrigin,\n     ) -> RegionVid {\n         let vid = self.var_infos.push(RegionVariableInfo { origin, universe });\n \n-        let u_vid = self.unification_table.new_key(unify_key::RegionVidKey { min_vid: vid });\n+        let u_vid = self.unification_table().new_key(unify_key::RegionVidKey { min_vid: vid });\n         assert_eq!(vid, u_vid);\n-        if self.in_snapshot() {\n-            self.undo_log.push(AddVar(vid));\n-        }\n+        self.undo_log.push(AddVar(vid));\n         debug!(\"created new region variable {:?} in {:?} with origin {:?}\", vid, universe, origin);\n         vid\n     }\n@@ -520,19 +492,29 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn pop_placeholders(&mut self, placeholders: &FxHashSet<ty::Region<'tcx>>) {\n         debug!(\"pop_placeholders(placeholders={:?})\", placeholders);\n \n-        assert!(self.in_snapshot());\n+        assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n \n         let constraints_to_kill: Vec<usize> = self\n             .undo_log\n             .iter()\n             .enumerate()\n             .rev()\n-            .filter(|&(_, undo_entry)| kill_constraint(placeholders, undo_entry))\n+            .filter(|&(_, undo_entry)| match undo_entry {\n+                super::UndoLog::RegionConstraintCollector(undo_entry) => {\n+                    kill_constraint(placeholders, undo_entry)\n+                }\n+                _ => false,\n+            })\n             .map(|(index, _)| index)\n             .collect();\n \n         for index in constraints_to_kill {\n-            let undo_entry = mem::replace(&mut self.undo_log[index], Purged);\n+            let undo_entry = match &mut self.undo_log[index] {\n+                super::UndoLog::RegionConstraintCollector(undo_entry) => {\n+                    mem::replace(undo_entry, Purged)\n+                }\n+                _ => unreachable!(),\n+            };\n             self.rollback_undo_entry(undo_entry);\n         }\n \n@@ -566,12 +548,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // never overwrite an existing (constraint, origin) - only insert one if it isn't\n         // present in the map yet. This prevents origins from outside the snapshot being\n         // replaced with \"less informative\" origins e.g., during calls to `can_eq`\n-        let in_snapshot = self.in_snapshot();\n         let undo_log = &mut self.undo_log;\n-        self.data.constraints.entry(constraint).or_insert_with(|| {\n-            if in_snapshot {\n-                undo_log.push(AddConstraint(constraint));\n-            }\n+        self.storage.data.constraints.entry(constraint).or_insert_with(|| {\n+            undo_log.push(AddConstraint(constraint));\n             origin\n         });\n     }\n@@ -589,19 +568,15 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         let index = self.data.verifys.len();\n         self.data.verifys.push(verify);\n-        if self.in_snapshot() {\n-            self.undo_log.push(AddVerify(index));\n-        }\n+        self.undo_log.push(AddVerify(index));\n     }\n \n     pub fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         if self.data.givens.insert((sub, sup)) {\n             debug!(\"add_given({:?} <= {:?})\", sub, sup);\n \n-            if self.in_snapshot() {\n-                self.undo_log.push(AddGiven(sub, sup));\n-            }\n+            self.undo_log.push(AddGiven(sub, sup));\n         }\n     }\n \n@@ -619,7 +594,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n             if let (ty::ReVar(sub), ty::ReVar(sup)) = (*sub, *sup) {\n                 debug!(\"make_eqregion: uniying {:?} with {:?}\", sub, sup);\n-                self.unification_table.union(sub, sup);\n+                self.unification_table().union(sub, sup);\n                 self.any_unifications = true;\n             }\n         }\n@@ -741,7 +716,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         rid: RegionVid,\n     ) -> ty::Region<'tcx> {\n-        let vid = self.unification_table.probe_value(rid).min_vid;\n+        let vid = self.unification_table().probe_value(rid).min_vid;\n         tcx.mk_region(ty::ReVar(vid))\n     }\n \n@@ -769,9 +744,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         let c_universe = cmp::max(a_universe, b_universe);\n         let c = self.new_region_var(c_universe, MiscVariable(origin.span()));\n         self.combine_map(t).insert(vars, c);\n-        if self.in_snapshot() {\n-            self.undo_log.push(AddCombination(t, vars));\n-        }\n+        self.undo_log.push(AddCombination(t, vars));\n         let new_r = tcx.mk_region(ReVar(c));\n         for &old_r in &[a, b] {\n             match t {\n@@ -799,9 +772,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn vars_since_snapshot(\n         &self,\n-        mark: &RegionSnapshot,\n+        value_count: usize,\n     ) -> (Range<RegionVid>, Vec<RegionVariableOrigin>) {\n-        let range = self.unification_table.vars_since_snapshot(&mark.region_snapshot);\n+        let range = RegionVid::from_index(value_count as u32)\n+            ..RegionVid::from_index(self.unification_table.len() as u32);\n         (\n             range.clone(),\n             (range.start.index()..range.end.index())\n@@ -810,22 +784,26 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         )\n     }\n \n-    /// See `InferCtxt::region_constraints_added_in_snapshot`.\n-    pub fn region_constraints_added_in_snapshot(&self, mark: &RegionSnapshot) -> Option<bool> {\n-        self.undo_log[mark.length..]\n-            .iter()\n+    /// See [`RegionInference::region_constraints_added_in_snapshot`].\n+    pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'tcx>) -> Option<bool> {\n+        self.undo_log\n+            .region_constraints_in_snapshot(mark)\n             .map(|&elt| match elt {\n                 AddConstraint(constraint) => Some(constraint.involves_placeholders()),\n                 _ => None,\n             })\n             .max()\n             .unwrap_or(None)\n     }\n+\n+    fn unification_table(&mut self) -> super::UnificationTable<'_, 'tcx, ty::RegionVid> {\n+        ut::UnificationTable::with_log(&mut self.storage.unification_table, self.undo_log)\n+    }\n }\n \n impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"RegionSnapshot(length={})\", self.length)\n+        write!(f, \"RegionSnapshot\")\n     }\n }\n \n@@ -910,3 +888,9 @@ impl<'tcx> RegionConstraintData<'tcx> {\n             && givens.is_empty()\n     }\n }\n+\n+impl<'tcx> Rollback<UndoLog<'tcx>> for RegionConstraintStorage<'tcx> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        self.rollback_undo_entry(undo)\n+    }\n+}"}, {"sha": "e28cf49c7f2538f2facd4caad8c2670ae27d0b10", "filename": "src/librustc_infer/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -123,7 +123,8 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n                 let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n-                    let ty_vars = &self.infcx.inner.borrow().type_variables;\n+                    let mut inner = self.infcx.inner.borrow_mut();\n+                    let ty_vars = &inner.type_variables();\n                     if let TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n                         span,"}, {"sha": "0abcc15d6fcd8b7f633a6f5fb5fbe0535b4bf746", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -80,8 +80,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n-        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n@@ -95,7 +95,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 // have to record in the `type_variables` tracker that\n                 // the two variables are equal modulo subtyping, which\n                 // is important to the occurs check later on.\n-                infcx.inner.borrow_mut().type_variables.sub(a_vid, b_vid);\n+                infcx.inner.borrow_mut().type_variables().sub(a_vid, b_vid);\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,"}, {"sha": "f68692391a2889069beadb58650e0e35e444d557", "filename": "src/librustc_infer/infer/type_variable.rs", "status": "modified", "additions": 122, "deletions": 79, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -3,19 +3,68 @@ use rustc_middle::ty::{self, Ty, TyVid};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n+use crate::infer::InferCtxtUndoLogs;\n+\n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n use std::cmp;\n use std::marker::PhantomData;\n use std::ops::Range;\n \n-pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<Delegate>,\n+use rustc_data_structures::undo_log::{Rollback, UndoLogs};\n+\n+/// Represents a single undo-able action that affects a type inference variable.\n+pub(crate) enum UndoLog<'tcx> {\n+    EqRelation(sv::UndoLog<ut::Delegate<TyVidEqKey<'tcx>>>),\n+    SubRelation(sv::UndoLog<ut::Delegate<ty::TyVid>>),\n+    Values(sv::UndoLog<Delegate>),\n+}\n+\n+/// Convert from a specific kind of undo to the more general UndoLog\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<TyVidEqKey<'tcx>>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<TyVidEqKey<'tcx>>>) -> Self {\n+        UndoLog::EqRelation(l)\n+    }\n+}\n+\n+/// Convert from a specific kind of undo to the more general UndoLog\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::TyVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::TyVid>>) -> Self {\n+        UndoLog::SubRelation(l)\n+    }\n+}\n+\n+/// Convert from a specific kind of undo to the more general UndoLog\n+impl<'tcx> From<sv::UndoLog<Delegate>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<Delegate>) -> Self {\n+        UndoLog::Values(l)\n+    }\n+}\n+\n+/// Convert from a specific kind of undo to the more general UndoLog\n+impl<'tcx> From<Instantiate> for UndoLog<'tcx> {\n+    fn from(l: Instantiate) -> Self {\n+        UndoLog::Values(sv::UndoLog::Other(l))\n+    }\n+}\n+\n+impl<'tcx> Rollback<UndoLog<'tcx>> for TypeVariableStorage<'tcx> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        match undo {\n+            UndoLog::EqRelation(undo) => self.eq_relations.reverse(undo),\n+            UndoLog::SubRelation(undo) => self.sub_relations.reverse(undo),\n+            UndoLog::Values(undo) => self.values.reverse(undo),\n+        }\n+    }\n+}\n+\n+pub struct TypeVariableStorage<'tcx> {\n+    values: sv::SnapshotVecStorage<Delegate>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n     /// constraint `?X == ?Y`. This table also stores, for each key,\n     /// the known value.\n-    eq_relations: ut::UnificationTable<ut::InPlace<TyVidEqKey<'tcx>>>,\n+    eq_relations: ut::UnificationTableStorage<TyVidEqKey<'tcx>>,\n \n     /// Two variables are unified in `sub_relations` when we have a\n     /// constraint `?X <: ?Y` *or* a constraint `?Y <: ?X`. This second\n@@ -34,7 +83,17 @@ pub struct TypeVariableTable<'tcx> {\n     /// This is reasonable because, in Rust, subtypes have the same\n     /// \"skeleton\" and hence there is no possible type such that\n     /// (e.g.)  `Box<?3> <: ?3` for any `?3`.\n-    sub_relations: ut::UnificationTable<ut::InPlace<ty::TyVid>>,\n+    sub_relations: ut::UnificationTableStorage<ty::TyVid>,\n+}\n+\n+pub struct TypeVariableTable<'a, 'tcx> {\n+    values: &'a mut sv::SnapshotVecStorage<Delegate>,\n+\n+    eq_relations: &'a mut ut::UnificationTableStorage<TyVidEqKey<'tcx>>,\n+\n+    sub_relations: &'a mut ut::UnificationTableStorage<ty::TyVid>,\n+\n+    undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -62,7 +121,7 @@ pub enum TypeVariableOriginKind {\n     LatticeVariable,\n }\n \n-struct TypeVariableData {\n+pub(crate) struct TypeVariableData {\n     origin: TypeVariableOrigin,\n     diverging: bool,\n }\n@@ -91,27 +150,31 @@ impl<'tcx> TypeVariableValue<'tcx> {\n     }\n }\n \n-pub struct Snapshot<'tcx> {\n-    snapshot: sv::Snapshot,\n-    eq_snapshot: ut::Snapshot<ut::InPlace<TyVidEqKey<'tcx>>>,\n-    sub_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n-}\n-\n-struct Instantiate {\n+pub(crate) struct Instantiate {\n     vid: ty::TyVid,\n }\n \n-struct Delegate;\n+pub(crate) struct Delegate;\n \n-impl<'tcx> TypeVariableTable<'tcx> {\n-    pub fn new() -> TypeVariableTable<'tcx> {\n-        TypeVariableTable {\n-            values: sv::SnapshotVec::new(),\n-            eq_relations: ut::UnificationTable::new(),\n-            sub_relations: ut::UnificationTable::new(),\n+impl<'tcx> TypeVariableStorage<'tcx> {\n+    pub fn new() -> TypeVariableStorage<'tcx> {\n+        TypeVariableStorage {\n+            values: sv::SnapshotVecStorage::new(),\n+            eq_relations: ut::UnificationTableStorage::new(),\n+            sub_relations: ut::UnificationTableStorage::new(),\n         }\n     }\n \n+    pub(crate) fn with_log<'a>(\n+        &'a mut self,\n+        undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+    ) -> TypeVariableTable<'a, 'tcx> {\n+        let TypeVariableStorage { values, eq_relations, sub_relations } = self;\n+        TypeVariableTable { values, eq_relations, sub_relations, undo_log }\n+    }\n+}\n+\n+impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     /// Returns the diverges flag given when `vid` was created.\n     ///\n     /// Note that this function does not return care whether\n@@ -134,8 +197,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn equate(&mut self, a: ty::TyVid, b: ty::TyVid) {\n         debug_assert!(self.probe(a).is_unknown());\n         debug_assert!(self.probe(b).is_unknown());\n-        self.eq_relations.union(a, b);\n-        self.sub_relations.union(a, b);\n+        self.eq_relations().union(a, b);\n+        self.sub_relations().union(a, b);\n     }\n \n     /// Records that `a <: b`, depending on `dir`.\n@@ -144,7 +207,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn sub(&mut self, a: ty::TyVid, b: ty::TyVid) {\n         debug_assert!(self.probe(a).is_unknown());\n         debug_assert!(self.probe(b).is_unknown());\n-        self.sub_relations.union(a, b);\n+        self.sub_relations().union(a, b);\n     }\n \n     /// Instantiates `vid` with the type `ty`.\n@@ -154,18 +217,18 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         let vid = self.root_var(vid);\n         debug_assert!(self.probe(vid).is_unknown());\n         debug_assert!(\n-            self.eq_relations.probe_value(vid).is_unknown(),\n+            self.eq_relations().probe_value(vid).is_unknown(),\n             \"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n             vid,\n             ty,\n-            self.eq_relations.probe_value(vid)\n+            self.eq_relations().probe_value(vid)\n         );\n-        self.eq_relations.union_value(vid, TypeVariableValue::Known { value: ty });\n+        self.eq_relations().union_value(vid, TypeVariableValue::Known { value: ty });\n \n         // Hack: we only need this so that `types_escaping_snapshot`\n         // can see what has been unified; see the Delegate impl for\n         // more details.\n-        self.values.record(Instantiate { vid });\n+        self.undo_log.push(Instantiate { vid });\n     }\n \n     /// Creates a new type variable.\n@@ -184,12 +247,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         diverging: bool,\n         origin: TypeVariableOrigin,\n     ) -> ty::TyVid {\n-        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n+        let eq_key = self.eq_relations().new_key(TypeVariableValue::Unknown { universe });\n \n-        let sub_key = self.sub_relations.new_key(());\n+        let sub_key = self.sub_relations().new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n \n-        let index = self.values.push(TypeVariableData { origin, diverging });\n+        let index = self.values().push(TypeVariableData { origin, diverging });\n         assert_eq!(eq_key.vid.index, index as u32);\n \n         debug!(\n@@ -211,7 +274,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// algorithm), so `root_var(a) == root_var(b)` implies that `a ==\n     /// b` (transitively).\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n-        self.eq_relations.find(vid).vid\n+        self.eq_relations().find(vid).vid\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `sub_relations`\n@@ -222,7 +285,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     ///     exists X. (a <: X || X <: a) && (b <: X || X <: b)\n     pub fn sub_root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n-        self.sub_relations.find(vid)\n+        self.sub_relations().find(vid)\n     }\n \n     /// Returns `true` if `a` and `b` have same \"sub-root\" (i.e., exists some\n@@ -240,7 +303,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// An always-inlined variant of `probe`, for very hot call sites.\n     #[inline(always)]\n     pub fn inlined_probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {\n-        self.eq_relations.inlined_probe_value(vid)\n+        self.eq_relations().inlined_probe_value(vid)\n     }\n \n     /// If `t` is a type-inference variable, and it has been\n@@ -256,56 +319,29 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         }\n     }\n \n-    /// Creates a snapshot of the type variable state. This snapshot\n-    /// must later be committed (`commit()`) or rolled back\n-    /// (`rollback_to()`). Nested snapshots are permitted, but must\n-    /// be processed in a stack-like fashion.\n-    pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n-        Snapshot {\n-            snapshot: self.values.start_snapshot(),\n-            eq_snapshot: self.eq_relations.snapshot(),\n-            sub_snapshot: self.sub_relations.snapshot(),\n-        }\n+    fn values(\n+        &mut self,\n+    ) -> sv::SnapshotVec<Delegate, &mut Vec<TypeVariableData>, &mut InferCtxtUndoLogs<'tcx>> {\n+        self.values.with_log(self.undo_log)\n     }\n \n-    /// Undoes all changes since the snapshot was created. Any\n-    /// snapshots created since that point must already have been\n-    /// committed or rolled back.\n-    pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n-        debug!(\"rollback_to{:?}\", {\n-            for action in self.values.actions_since_snapshot(&s.snapshot) {\n-                if let sv::UndoLog::NewElem(index) = *action {\n-                    debug!(\"inference variable _#{}t popped\", index)\n-                }\n-            }\n-        });\n-\n-        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n-        self.values.rollback_to(snapshot);\n-        self.eq_relations.rollback_to(eq_snapshot);\n-        self.sub_relations.rollback_to(sub_snapshot);\n+    fn eq_relations(&mut self) -> super::UnificationTable<'_, 'tcx, TyVidEqKey<'tcx>> {\n+        self.eq_relations.with_log(self.undo_log)\n     }\n \n-    /// Commits all changes since the snapshot was created, making\n-    /// them permanent (unless this snapshot was created within\n-    /// another snapshot). Any snapshots created since that point\n-    /// must already have been committed or rolled back.\n-    pub fn commit(&mut self, s: Snapshot<'tcx>) {\n-        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n-        self.values.commit(snapshot);\n-        self.eq_relations.commit(eq_snapshot);\n-        self.sub_relations.commit(sub_snapshot);\n+    fn sub_relations(&mut self) -> super::UnificationTable<'_, 'tcx, ty::TyVid> {\n+        self.sub_relations.with_log(self.undo_log)\n     }\n \n     /// Returns a range of the type variables created during the snapshot.\n     pub fn vars_since_snapshot(\n         &mut self,\n-        s: &Snapshot<'tcx>,\n+        value_count: usize,\n     ) -> (Range<TyVid>, Vec<TypeVariableOrigin>) {\n-        let range = self.eq_relations.vars_since_snapshot(&s.eq_snapshot);\n+        let range = TyVid { index: value_count as u32 }..TyVid { index: self.num_vars() as u32 };\n         (\n-            range.start.vid..range.end.vid,\n-            (range.start.vid.index..range.end.vid.index)\n+            range.start..range.end,\n+            (range.start.index..range.end.index)\n                 .map(|index| self.values.get(index as usize).origin)\n                 .collect(),\n         )\n@@ -317,14 +353,15 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// a type variable `V0`, then we started the snapshot, then we\n     /// created a type variable `V1`, unified `V0` with `T0`, and\n     /// unified `V1` with `T1`, this function would return `{T0}`.\n-    pub fn types_escaping_snapshot(&mut self, s: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n+    pub fn types_escaping_snapshot(&mut self, s: &super::Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n         let mut new_elem_threshold = u32::MAX;\n         let mut escaping_types = Vec::new();\n-        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n+        let actions_since_snapshot = self.undo_log.actions_since_snapshot(s);\n         debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n-        for action in actions_since_snapshot {\n-            match *action {\n-                sv::UndoLog::NewElem(index) => {\n+        for i in 0..actions_since_snapshot.len() {\n+            let actions_since_snapshot = self.undo_log.actions_since_snapshot(s);\n+            match actions_since_snapshot[i] {\n+                super::UndoLog::TypeVariables(UndoLog::Values(sv::UndoLog::NewElem(index))) => {\n                     // if any new variables were created during the\n                     // snapshot, remember the lower index (which will\n                     // always be the first one we see). Note that this\n@@ -334,11 +371,17 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n-                sv::UndoLog::Other(Instantiate { vid, .. }) => {\n+                super::UndoLog::TypeVariables(UndoLog::Values(sv::UndoLog::Other(\n+                    Instantiate { vid, .. },\n+                ))) => {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n-                        let escaping_type = match self.eq_relations.probe_value(vid) {\n+                        let mut eq_relations = ut::UnificationTable::with_log(\n+                            &mut *self.eq_relations,\n+                            &mut *self.undo_log,\n+                        );\n+                        let escaping_type = match eq_relations.probe_value(vid) {\n                             TypeVariableValue::Unknown { .. } => bug!(),\n                             TypeVariableValue::Known { value } => value,\n                         };\n@@ -395,7 +438,7 @@ impl sv::SnapshotVecDelegate for Delegate {\n /// for the `eq_relations`; they carry a `TypeVariableValue` along\n /// with them.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-struct TyVidEqKey<'tcx> {\n+pub(crate) struct TyVidEqKey<'tcx> {\n     vid: ty::TyVid,\n \n     // in the table, we map each ty-vid to one of these:"}, {"sha": "56cb182dbf0f96bfa1d287f013e6058518d6d27c", "filename": "src/librustc_infer/infer/undo_log.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -0,0 +1,217 @@\n+use std::marker::PhantomData;\n+\n+use rustc_data_structures::snapshot_vec as sv;\n+use rustc_data_structures::undo_log::{Rollback, UndoLogs};\n+use rustc_data_structures::unify as ut;\n+use rustc_middle::ty;\n+\n+use crate::{\n+    infer::{region_constraints, type_variable, InferCtxtInner},\n+    traits,\n+};\n+\n+pub struct Snapshot<'tcx> {\n+    pub(crate) undo_len: usize,\n+    _marker: PhantomData<&'tcx ()>,\n+}\n+\n+/// Records the 'undo' data fora single operation that affects some form of inference variable.\n+pub(crate) enum UndoLog<'tcx> {\n+    TypeVariables(type_variable::UndoLog<'tcx>),\n+    ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n+    IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n+    FloatUnificationTable(sv::UndoLog<ut::Delegate<ty::FloatVid>>),\n+    RegionConstraintCollector(region_constraints::UndoLog<'tcx>),\n+    RegionUnificationTable(sv::UndoLog<ut::Delegate<ty::RegionVid>>),\n+    ProjectionCache(traits::UndoLog<'tcx>),\n+    PushRegionObligation,\n+}\n+\n+macro_rules! impl_from {\n+    ($($ctor: ident ($ty: ty),)*) => {\n+        $(\n+        impl<'tcx> From<$ty> for UndoLog<'tcx> {\n+            fn from(x: $ty) -> Self {\n+                UndoLog::$ctor(x.into())\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+// Upcast from a single kind of \"undoable action\" to the general enum\n+impl_from! {\n+    RegionConstraintCollector(region_constraints::UndoLog<'tcx>),\n+    TypeVariables(type_variable::UndoLog<'tcx>),\n+\n+    TypeVariables(sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'tcx>>>),\n+    TypeVariables(sv::UndoLog<ut::Delegate<ty::TyVid>>),\n+    TypeVariables(sv::UndoLog<type_variable::Delegate>),\n+    TypeVariables(type_variable::Instantiate),\n+\n+    IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n+\n+    FloatUnificationTable(sv::UndoLog<ut::Delegate<ty::FloatVid>>),\n+\n+    ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n+\n+    RegionUnificationTable(sv::UndoLog<ut::Delegate<ty::RegionVid>>),\n+    ProjectionCache(traits::UndoLog<'tcx>),\n+}\n+\n+/// The Rollback trait defines how to rollback a particular action.\n+impl<'tcx> Rollback<UndoLog<'tcx>> for InferCtxtInner<'tcx> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        match undo {\n+            UndoLog::TypeVariables(undo) => self.type_variable_storage.reverse(undo),\n+            UndoLog::ConstUnificationTable(undo) => self.const_unification_storage.reverse(undo),\n+            UndoLog::IntUnificationTable(undo) => self.int_unification_storage.reverse(undo),\n+            UndoLog::FloatUnificationTable(undo) => self.float_unification_storage.reverse(undo),\n+            UndoLog::RegionConstraintCollector(undo) => {\n+                self.region_constraint_storage.as_mut().unwrap().reverse(undo)\n+            }\n+            UndoLog::RegionUnificationTable(undo) => {\n+                self.region_constraint_storage.as_mut().unwrap().unification_table.reverse(undo)\n+            }\n+            UndoLog::ProjectionCache(undo) => self.projection_cache.reverse(undo),\n+            UndoLog::PushRegionObligation => {\n+                self.region_obligations.pop();\n+            }\n+        }\n+    }\n+}\n+\n+/// The combined undo log for all the various unification tables. For each change to the storage\n+/// for any kind of inference variable, we record an UndoLog entry in the vector here.\n+pub(crate) struct InferCtxtUndoLogs<'tcx> {\n+    logs: Vec<UndoLog<'tcx>>,\n+    num_open_snapshots: usize,\n+}\n+\n+impl Default for InferCtxtUndoLogs<'_> {\n+    fn default() -> Self {\n+        Self { logs: Default::default(), num_open_snapshots: Default::default() }\n+    }\n+}\n+\n+/// The UndoLogs trait defines how we undo a particular kind of action (of type T). We can undo any\n+/// action that is convertable into a UndoLog (per the From impls above).\n+impl<'tcx, T> UndoLogs<T> for InferCtxtUndoLogs<'tcx>\n+where\n+    UndoLog<'tcx>: From<T>,\n+{\n+    fn num_open_snapshots(&self) -> usize {\n+        self.num_open_snapshots\n+    }\n+\n+    fn push(&mut self, undo: T) {\n+        if self.in_snapshot() {\n+            self.logs.push(undo.into())\n+        }\n+    }\n+\n+    fn clear(&mut self) {\n+        self.logs.clear();\n+        self.num_open_snapshots = 0;\n+    }\n+\n+    fn extend<J>(&mut self, undos: J)\n+    where\n+        Self: Sized,\n+        J: IntoIterator<Item = T>,\n+    {\n+        if self.in_snapshot() {\n+            self.logs.extend(undos.into_iter().map(UndoLog::from))\n+        }\n+    }\n+}\n+\n+impl<'tcx> InferCtxtInner<'tcx> {\n+    pub fn rollback_to(&mut self, snapshot: Snapshot<'tcx>) {\n+        debug!(\"rollback_to({})\", snapshot.undo_len);\n+        self.undo_log.assert_open_snapshot(&snapshot);\n+\n+        while self.undo_log.logs.len() > snapshot.undo_len {\n+            let undo = self.undo_log.logs.pop().unwrap();\n+            self.reverse(undo);\n+        }\n+\n+        if self.undo_log.num_open_snapshots == 1 {\n+            // The root snapshot. It's safe to clear the undo log because\n+            // there's no snapshot further out that we might need to roll back\n+            // to.\n+            assert!(snapshot.undo_len == 0);\n+            self.undo_log.logs.clear();\n+        }\n+\n+        self.undo_log.num_open_snapshots -= 1;\n+    }\n+\n+    pub fn commit(&mut self, snapshot: Snapshot<'tcx>) {\n+        debug!(\"commit({})\", snapshot.undo_len);\n+\n+        if self.undo_log.num_open_snapshots == 1 {\n+            // The root snapshot. It's safe to clear the undo log because\n+            // there's no snapshot further out that we might need to roll back\n+            // to.\n+            assert!(snapshot.undo_len == 0);\n+            self.undo_log.logs.clear();\n+        }\n+\n+        self.undo_log.num_open_snapshots -= 1;\n+    }\n+}\n+\n+impl<'tcx> InferCtxtUndoLogs<'tcx> {\n+    pub fn actions_since_snapshot(&self, snapshot: &Snapshot<'tcx>) -> &[UndoLog<'tcx>] {\n+        &self.logs[snapshot.undo_len..]\n+    }\n+\n+    pub fn start_snapshot(&mut self) -> Snapshot<'tcx> {\n+        self.num_open_snapshots += 1;\n+        Snapshot { undo_len: self.logs.len(), _marker: PhantomData }\n+    }\n+\n+    pub(crate) fn region_constraints_in_snapshot(\n+        &self,\n+        s: &Snapshot<'tcx>,\n+    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {\n+        self.logs[s.undo_len..].iter().filter_map(|log| match log {\n+            UndoLog::RegionConstraintCollector(log) => Some(log),\n+            _ => None,\n+        })\n+    }\n+\n+    pub(crate) fn region_constraints(\n+        &self,\n+    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {\n+        self.logs.iter().filter_map(|log| match log {\n+            UndoLog::RegionConstraintCollector(log) => Some(log),\n+            _ => None,\n+        })\n+    }\n+\n+    fn assert_open_snapshot(&self, snapshot: &Snapshot<'tcx>) {\n+        // Failures here may indicate a failure to follow a stack discipline.\n+        assert!(self.logs.len() >= snapshot.undo_len);\n+        assert!(self.num_open_snapshots > 0);\n+    }\n+\n+    pub(crate) fn iter(&self) -> std::slice::Iter<'_, UndoLog<'tcx>> {\n+        self.logs.iter()\n+    }\n+}\n+\n+impl<'tcx> std::ops::Index<usize> for InferCtxtUndoLogs<'tcx> {\n+    type Output = UndoLog<'tcx>;\n+\n+    fn index(&self, key: usize) -> &Self::Output {\n+        &self.logs[key]\n+    }\n+}\n+\n+impl<'tcx> std::ops::IndexMut<usize> for InferCtxtUndoLogs<'tcx> {\n+    fn index_mut(&mut self, key: usize) -> &mut Self::Output {\n+        &mut self.logs[key]\n+    }\n+}"}, {"sha": "a8585fd293518dacbd25b8cf06cef873f91e753e", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -20,9 +20,10 @@ pub use self::Vtable::*;\n \n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::project::MismatchedProjectionTypes;\n+pub(crate) use self::project::UndoLog;\n pub use self::project::{\n     Normalized, NormalizedTy, ProjectionCache, ProjectionCacheEntry, ProjectionCacheKey,\n-    ProjectionCacheSnapshot, Reveal,\n+    ProjectionCacheStorage, Reveal,\n };\n crate use self::util::elaborate_predicates;\n "}, {"sha": "f0d21a7d022daf80dcb64f002a3e64ca2d804b13", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -2,12 +2,19 @@\n \n use super::PredicateObligation;\n \n-use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n-use rustc_middle::ty::fold::TypeFoldable;\n+use crate::infer::InferCtxtUndoLogs;\n+\n+use rustc_data_structures::{\n+    snapshot_map::{self, SnapshotMapRef, SnapshotMapStorage},\n+    undo_log::Rollback,\n+};\n use rustc_middle::ty::{self, Ty};\n \n pub use rustc_middle::traits::Reveal;\n \n+pub(crate) type UndoLog<'tcx> =\n+    snapshot_map::UndoLog<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>;\n+\n #[derive(Clone)]\n pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::error::TypeError<'tcx>,\n@@ -58,9 +65,14 @@ impl<'tcx, T> Normalized<'tcx, T> {\n //\n // FIXME: we probably also want some sort of cross-infcx cache here to\n // reduce the amount of duplication. Let's see what we get with the Chalk reforms.\n+pub struct ProjectionCache<'a, 'tcx> {\n+    map: &'a mut SnapshotMapStorage<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n+    undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+}\n+\n #[derive(Default)]\n-pub struct ProjectionCache<'tcx> {\n-    map: SnapshotMap<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n+pub struct ProjectionCacheStorage<'tcx> {\n+    map: SnapshotMapStorage<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -82,30 +94,29 @@ pub enum ProjectionCacheEntry<'tcx> {\n     NormalizedTy(NormalizedTy<'tcx>),\n }\n \n-// N.B., intentionally not Clone\n-pub struct ProjectionCacheSnapshot {\n-    snapshot: Snapshot,\n-}\n-\n-impl<'tcx> ProjectionCache<'tcx> {\n-    pub fn clear(&mut self) {\n-        self.map.clear();\n-    }\n-\n-    pub fn snapshot(&mut self) -> ProjectionCacheSnapshot {\n-        ProjectionCacheSnapshot { snapshot: self.map.snapshot() }\n-    }\n-\n-    pub fn rollback_to(&mut self, snapshot: ProjectionCacheSnapshot) {\n-        self.map.rollback_to(snapshot.snapshot);\n+impl<'tcx> ProjectionCacheStorage<'tcx> {\n+    pub(crate) fn with_log<'a>(\n+        &'a mut self,\n+        undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+    ) -> ProjectionCache<'a, 'tcx> {\n+        ProjectionCache { map: &mut self.map, undo_log }\n     }\n+}\n \n-    pub fn rollback_placeholder(&mut self, snapshot: &ProjectionCacheSnapshot) {\n-        self.map.partial_rollback(&snapshot.snapshot, &|k| k.ty.has_re_placeholders());\n+impl<'tcx> ProjectionCache<'_, 'tcx> {\n+    fn map(\n+        &mut self,\n+    ) -> SnapshotMapRef<\n+        '_,\n+        ProjectionCacheKey<'tcx>,\n+        ProjectionCacheEntry<'tcx>,\n+        InferCtxtUndoLogs<'tcx>,\n+    > {\n+        self.map.with_log(self.undo_log)\n     }\n \n-    pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n-        self.map.commit(snapshot.snapshot);\n+    pub fn clear(&mut self) {\n+        self.map().clear();\n     }\n \n     /// Try to start normalize `key`; returns an error if\n@@ -115,11 +126,12 @@ impl<'tcx> ProjectionCache<'tcx> {\n         &mut self,\n         key: ProjectionCacheKey<'tcx>,\n     ) -> Result<(), ProjectionCacheEntry<'tcx>> {\n-        if let Some(entry) = self.map.get(&key) {\n+        let mut map = self.map();\n+        if let Some(entry) = map.get(&key) {\n             return Err(entry.clone());\n         }\n \n-        self.map.insert(key, ProjectionCacheEntry::InProgress);\n+        map.insert(key, ProjectionCacheEntry::InProgress);\n         Ok(())\n     }\n \n@@ -129,7 +141,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n             \"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n             key, value\n         );\n-        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n+        let fresh_key = self.map().insert(key, ProjectionCacheEntry::NormalizedTy(value));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n \n@@ -138,7 +150,8 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// snapshot - if the snapshot is rolled back, the obligations will be\n     /// marked as incomplete again).\n     pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let ty = match self.map.get(&key) {\n+        let mut map = self.map();\n+        let ty = match map.get(&key) {\n             Some(&ProjectionCacheEntry::NormalizedTy(ref ty)) => {\n                 debug!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n                 ty.value\n@@ -151,7 +164,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n             }\n         };\n \n-        self.map.insert(\n+        map.insert(\n             key,\n             ProjectionCacheEntry::NormalizedTy(Normalized { value: ty, obligations: vec![] }),\n         );\n@@ -163,7 +176,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n         // We want to insert `ty` with no obligations. If the existing value\n         // already has no obligations (as is common) we don't insert anything.\n         if !ty.obligations.is_empty() {\n-            self.map.insert(\n+            self.map().insert(\n                 key,\n                 ProjectionCacheEntry::NormalizedTy(Normalized {\n                     value: ty.value,\n@@ -178,14 +191,20 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// type information (in which case, the \"fully resolved\" key will\n     /// be different).\n     pub fn ambiguous(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let fresh = self.map.insert(key, ProjectionCacheEntry::Ambiguous);\n+        let fresh = self.map().insert(key, ProjectionCacheEntry::Ambiguous);\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }\n \n     /// Indicates that trying to normalize `key` resulted in\n     /// error.\n     pub fn error(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let fresh = self.map.insert(key, ProjectionCacheEntry::Error);\n+        let fresh = self.map().insert(key, ProjectionCacheEntry::Error);\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }\n }\n+\n+impl<'tcx> Rollback<UndoLog<'tcx>> for ProjectionCacheStorage<'tcx> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        self.map.reverse(undo);\n+    }\n+}"}, {"sha": "2580ac6bebd86cbfa437c0671aaf433c9b6b46ba", "filename": "src/librustc_middle/infer/unify_key.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_middle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_middle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Finfer%2Funify_key.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -1,6 +1,9 @@\n use crate::ty::{self, FloatVarValue, InferConst, IntVarValue, Ty, TyCtxt};\n-use rustc_data_structures::unify::InPlace;\n-use rustc_data_structures::unify::{EqUnifyValue, NoError, UnificationTable, UnifyKey, UnifyValue};\n+use rustc_data_structures::snapshot_vec;\n+use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_data_structures::unify::{\n+    self, EqUnifyValue, InPlace, NoError, UnificationTable, UnifyKey, UnifyValue,\n+};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -212,10 +215,14 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n \n impl<'tcx> EqUnifyValue for &'tcx ty::Const<'tcx> {}\n \n-pub fn replace_if_possible(\n-    table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>>>,\n+pub fn replace_if_possible<V, L>(\n+    table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>, V, L>>,\n     c: &'tcx ty::Const<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n+) -> &'tcx ty::Const<'tcx>\n+where\n+    V: snapshot_vec::VecLike<unify::Delegate<ty::ConstVid<'tcx>>>,\n+    L: UndoLogs<snapshot_vec::UndoLog<unify::Delegate<ty::ConstVid<'tcx>>>>,\n+{\n     if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = c {\n         match table.probe_value(*vid).val.known() {\n             Some(c) => c,"}, {"sha": "e19ddcd9e5e9885a6fe862439413aa66c371c510", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -195,7 +195,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             let body_id_map: FxHashMap<_, _> = infcx\n                 .inner\n                 .borrow()\n-                .region_obligations\n+                .region_obligations()\n                 .iter()\n                 .map(|&(id, _)| (id, vec![]))\n                 .collect();"}, {"sha": "1e056c96acd383fd264f454927c9921064977253", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -240,9 +240,15 @@ struct FulfillProcessor<'a, 'b, 'tcx> {\n     register_region_obligations: bool,\n }\n \n-fn mk_pending(os: Vec<PredicateObligation<'tcx>>) -> Vec<PendingPredicateObligation<'tcx>> {\n+fn mk_pending(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    os: Vec<PredicateObligation<'tcx>>,\n+) -> Vec<PendingPredicateObligation<'tcx>> {\n     os.into_iter()\n-        .map(|o| PendingPredicateObligation { obligation: o, stalled_on: vec![] })\n+        .map(|mut o| {\n+            o.predicate = infcx.resolve_vars_if_possible(&o.predicate);\n+            PendingPredicateObligation { obligation: o, stalled_on: vec![] }\n+        })\n         .collect()\n }\n \n@@ -312,14 +318,16 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n+        let infcx = self.selcx.infcx();\n+\n         match obligation.predicate {\n             ty::Predicate::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(*data);\n \n                 if data.is_global() {\n                     // no type variables present, can use evaluation for better caching.\n                     // FIXME: consider caching errors too.\n-                    if self.selcx.infcx().predicate_must_hold_considering_regions(&obligation) {\n+                    if infcx.predicate_must_hold_considering_regions(&obligation) {\n                         debug!(\n                             \"selecting trait `{:?}` at depth {} evaluated to holds\",\n                             data, obligation.recursion_depth\n@@ -334,7 +342,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                             \"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n                             data, obligation.recursion_depth\n                         );\n-                        ProcessResult::Changed(mk_pending(vtable.nested_obligations()))\n+                        ProcessResult::Changed(mk_pending(infcx, vtable.nested_obligations()))\n                     }\n                     Ok(None) => {\n                         debug!(\n@@ -351,7 +359,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n                         debug!(\n                             \"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                            self.selcx.infcx().resolve_vars_if_possible(obligation),\n+                            infcx.resolve_vars_if_possible(obligation),\n                             pending_obligation.stalled_on\n                         );\n \n@@ -369,7 +377,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::RegionOutlives(ref binder) => {\n-                match self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n+                match infcx.region_outlives_predicate(&obligation.cause, binder) {\n                     Ok(()) => ProcessResult::Changed(vec![]),\n                     Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                 }\n@@ -428,7 +436,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                             trait_ref_type_vars(self.selcx, data.to_poly_trait_ref(tcx));\n                         ProcessResult::Unchanged\n                     }\n-                    Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n+                    Ok(Some(os)) => ProcessResult::Changed(mk_pending(infcx, os)),\n                     Err(e) => ProcessResult::Error(CodeProjectionError(e)),\n                 }\n             }\n@@ -467,7 +475,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                             vec![TyOrConstInferVar::maybe_from_ty(ty).unwrap()];\n                         ProcessResult::Unchanged\n                     }\n-                    Some(os) => ProcessResult::Changed(mk_pending(os)),\n+                    Some(os) => ProcessResult::Changed(mk_pending(infcx, os)),\n                 }\n             }\n \n@@ -485,7 +493,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                         ];\n                         ProcessResult::Unchanged\n                     }\n-                    Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n+                    Some(Ok(ok)) => ProcessResult::Changed(mk_pending(infcx, ok.obligations)),\n                     Some(Err(err)) => {\n                         let expected_found = ExpectedFound::new(\n                             subtype.skip_binder().a_is_expected,"}, {"sha": "7536b444351f2a3faf327b6e265730240b53c4c5", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -471,7 +471,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    let cache_result = infcx.inner.borrow_mut().projection_cache.try_start(cache_key);\n+    let cache_result = infcx.inner.borrow_mut().projection_cache().try_start(cache_key);\n     match cache_result {\n         Ok(()) => {}\n         Err(ProjectionCacheEntry::Ambiguous) => {\n@@ -537,7 +537,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n             if infcx.unresolved_type_vars(&ty.value).is_none() {\n-                infcx.inner.borrow_mut().projection_cache.complete_normalized(cache_key, &ty);\n+                infcx.inner.borrow_mut().projection_cache().complete_normalized(cache_key, &ty);\n             // No need to extend `obligations`.\n             } else {\n                 obligations.extend(ty.obligations);\n@@ -604,7 +604,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             };\n \n             let cache_value = prune_cache_value_obligations(infcx, &result);\n-            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, cache_value);\n+            infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, cache_value);\n             obligations.extend(result.obligations);\n             Some(result.value)\n         }\n@@ -615,7 +615,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 projected_ty\n             );\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n-            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, result.clone());\n+            infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n             // No need to extend `obligations`.\n             Some(result.value)\n         }\n@@ -624,7 +624,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 \"opt_normalize_projection_type: \\\n                  too many candidates\"\n             );\n-            infcx.inner.borrow_mut().projection_cache.ambiguous(cache_key);\n+            infcx.inner.borrow_mut().projection_cache().ambiguous(cache_key);\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n@@ -634,7 +634,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Trait`, which when processed will cause the error to be\n             // reported later\n \n-            infcx.inner.borrow_mut().projection_cache.error(cache_key);\n+            infcx.inner.borrow_mut().projection_cache().error(cache_key);\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n             Some(result.value)"}, {"sha": "38590abf1f706d521bcce582026cb5a6770b7d67", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da5869fb738e51438dd1e0697c1b2c84eb11c59/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=8da5869fb738e51438dd1e0697c1b2c84eb11c59", "patch": "@@ -471,7 +471,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let Some(key) =\n                             ProjectionCacheKey::from_poly_projection_predicate(self, data)\n                         {\n-                            self.infcx.inner.borrow_mut().projection_cache.complete(key);\n+                            self.infcx.inner.borrow_mut().projection_cache().complete(key);\n                         }\n                         result\n                     }"}]}