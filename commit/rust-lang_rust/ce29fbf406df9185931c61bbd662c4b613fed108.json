{"sha": "ce29fbf406df9185931c61bbd662c4b613fed108", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMjlmYmY0MDZkZjkxODU5MzFjNjFiYmQ2NjJjNGI2MTNmZWQxMDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-17T16:52:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-17T16:52:23Z"}, "message": "Auto merge of #1540 - RalfJung:cargo-miri-redone, r=oli-obk\n\nRedo cargo-miri logic\n\nThis rewrite the cargo-miri logic for running the requested crate(s) following what we outlined in https://github.com/rust-lang/miri/issues/739: `cargo miri run/test $FLAGS` (almost) literally invokes `cargo run/test $FLAGS` but with some environment variables set so that we can control what happens:\n* `RUSTC_WRAPPER` is set so that we get invoked instead of `rustc`. We use that power to mess with the flags being used for the build (things to be interpreted by Miri use a different sysroot), and when we are detecting a binary crate meant to be run by Miri, we grab the info we care about and put it into a JSON file for later use.\n* `CARGO_TARGET_$TARGET_RUNNER` is set so what we get invoked when cargo wants to run a binary. At that point we take that JSON info from before and use it to invoke Miri.\n\nOverall this works great! We get all sorts of cargo magic for free, and do not even need `cargo-metadata` any more. There's one annoying point though, which I have not managed to entirely work around yet: this means we are doing a full build, not just a check-build. Given that our sysroot is MIR-only, I was surprised that this even worked, but still -- this means we are doing more work than we should. So I also added some patching of arguments to make sure `--emit` does not contain `link`, and then more patching was required of the `--extern` flags for the binary because those referenced the `.rlib` files but now only `.rmeta` exists, and that is still not fully working because cargo seems to expect those `.rmeta` files and now triggers a rebuild each time as those files are still missing. My current plan is to make our wrapper create some empty dummy files with the right names, but the amount of hacks we are stacking on top of each other here is getting worrysome.^^ `@ehuss` your input would be welcome on this issue.\n\nDue to re-using cargo more literally, this also changes flag parsing to match `cargo`. So `-Zmiri` flags now have to be passed via an environment variable (Cc https://github.com/rust-lang/miri/issues/1416).\n\nThis PR is not ready yet, but the parts that are there I think can be reviewed already. TODO:\n* [x] [Fix Windows](https://github.com/rust-lang/miri/pull/1540#issuecomment-688733741).\n* [x] Figure out how we can do check-only builds without the rebuild problem above. ~~I am also worried about cases where `build.rs` script might detect check-only builds and then do less work; I think some crates in rustc are doing that and if this is a thing in the wider ecosystem we need to find a way to support this as well.~~ (postponed that until we have a concrete example)\n* [x] Currently cargo runs doctests as well, and they are not run in Miri. We should at least figure out a way to not run them at all (resolving https://github.com/rust-lang/miri/issues/584 is left for a future PR).\n* [x] For some time, detect the old way of passing `-Zmiri` flags and warn that this will need updating. For some simple situations we can probably make it still support the old way, but I plan to remove those hacks after a bit. This is just to give people and me time to go around and send PRs to all projects that use Miri on CI, and update their use of the flags.\n* [x] Add a test for stdin handling (https://github.com/rust-lang/miri/issues/1505). This should work now but we should be sure.\n* [x] Add a test for cargo env vars (https://github.com/rust-lang/miri/issues/1515).\n* [x] Check if https://github.com/rust-lang/miri/issues/1516 is resolved.\n* [x] Check if https://github.com/rust-lang/miri/issues/1001 and https://github.com/rust-lang/miri/issues/1514 are resolved.\n* [x] Check if https://github.com/rust-lang/miri/issues/1312 is resolved (not sure if it is wort adding a test).\n* [x] Check if https://github.com/rust-lang/miri/issues/1512 is resolved (not sure if it is wort adding a test).\n\nFixes https://github.com/rust-lang/miri/issues/700.\nFixes https://github.com/rust-lang/miri/issues/739.\nFixes https://github.com/rust-lang/miri/issues/1001.\nFixes https://github.com/rust-lang/miri/issues/1312 (without a test, as we run without cargo's stdin/stdout wrapping now, as the test for stdin confirms).\nFixes https://github.com/rust-lang/miri/issues/1416.\nFixes https://github.com/rust-lang/miri/issues/1505.\nFixes https://github.com/rust-lang/miri/issues/1512 (without a test, as cargo now does all that handling anyway, which various other tests confirm).\nFixes https://github.com/rust-lang/miri/issues/1514.\nFixes https://github.com/rust-lang/miri/issues/1516.\n\nCc `@alecmocatta` who reported many of the bugs above; would be great if you could help with the tests e.g. by providing some small examples I could try.\nr? `@oli-obk`", "tree": {"sha": "dcfdde5795a27d0990245e14a19ab313cf68ee9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcfdde5795a27d0990245e14a19ab313cf68ee9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce29fbf406df9185931c61bbd662c4b613fed108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce29fbf406df9185931c61bbd662c4b613fed108", "html_url": "https://github.com/rust-lang/rust/commit/ce29fbf406df9185931c61bbd662c4b613fed108", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce29fbf406df9185931c61bbd662c4b613fed108/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79f023eeb1e107e7345fda9cc632d67732a33df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/79f023eeb1e107e7345fda9cc632d67732a33df9", "html_url": "https://github.com/rust-lang/rust/commit/79f023eeb1e107e7345fda9cc632d67732a33df9"}, {"sha": "ae859c3f7be2fe63ebb96dc5cba3c635b81da65b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae859c3f7be2fe63ebb96dc5cba3c635b81da65b", "html_url": "https://github.com/rust-lang/rust/commit/ae859c3f7be2fe63ebb96dc5cba3c635b81da65b"}], "stats": {"total": 1014, "additions": 598, "deletions": 416}, "files": [{"sha": "6654de10abffffa33fff3b49b298c1e288d98b28", "filename": "README.md", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -83,11 +83,10 @@ Now you can run your project in Miri:\n The first time you run Miri, it will perform some extra setup and install some\n dependencies.  It will ask you for confirmation before installing anything.\n \n-You can pass arguments to Miri after the first `--`, and pass arguments to the\n-interpreted program or test suite after the second `--`.  For example, `cargo\n-miri run -- -Zmiri-disable-stacked-borrows` runs the program without checking\n-the aliasing of references.  To filter the tests being run, use `cargo miri test\n--- -- filter`.\n+`cargo miri run/test` supports the exact same flags as `cargo run/test`.  You\n+can pass arguments to Miri via `MIRIFLAGS`. For example,\n+`MIRIFLAGS=\"-Zmiri-disable-stacked-borrows\" cargo miri run` runs the program\n+without checking the aliasing of references.\n \n Miri supports cross-execution: if you want to run the program as if it was a\n Linux program, you can do `cargo miri run --target x86_64-unknown-linux-gnu`.\n@@ -163,7 +162,8 @@ up the sysroot.  If you are using `miri` (the Miri driver) directly, see the\n ## Miri `-Z` flags and environment variables\n [miri-flags]: #miri--z-flags-and-environment-variables\n \n-Miri adds its own set of `-Z` flags:\n+Miri adds its own set of `-Z` flags, which are usually set via the `MIRIFLAGS`\n+environment variable:\n \n * `-Zmiri-disable-alignment-check` disables checking pointer alignment, so you\n   can focus on other failures, but it means Miri can miss bugs in your program.\n@@ -229,21 +229,25 @@ Moreover, Miri recognizes some environment variables:\n \n * `MIRI_LOG`, `MIRI_BACKTRACE` control logging and backtrace printing during\n   Miri executions, also [see above][testing-miri].\n+* `MIRIFLAGS` (recognized by `cargo miri` and the test suite) defines extra\n+  flags to be passed to Miri.\n * `MIRI_SYSROOT` (recognized by `cargo miri` and the test suite)\n   indicates the sysroot to use.  To do the same thing with `miri`\n   directly, use the `--sysroot` flag.\n * `MIRI_TEST_TARGET` (recognized by the test suite) indicates which target\n   architecture to test against.  `miri` and `cargo miri` accept the `--target`\n   flag for the same purpose.\n-* `MIRI_TEST_FLAGS` (recognized by the test suite) defines extra flags to be\n-  passed to Miri.\n \n The following environment variables are internal, but used to communicate between\n different Miri binaries, and as such worth documenting:\n \n * `MIRI_BE_RUSTC` when set to any value tells the Miri driver to actually not\n   interpret the code but compile it like rustc would. This is useful to be sure\n   that the compiled `rlib`s are compatible with Miri.\n+* `MIRI_CWD` when set to any value tells the Miri driver to change to the given\n+  directory after loading all the source files, but before commencing\n+  interpretation. This is useful if the interpreted program wants a different\n+  working directory at run-time than at build-time.\n \n ## Miri `extern` functions\n "}, {"sha": "bb3b05db03a41d6a0d01b3be6f9b8bab774a047c", "filename": "cargo-miri/Cargo.lock", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/cargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/cargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2FCargo.lock?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -45,7 +45,6 @@ dependencies = [\n name = \"cargo-miri\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo_metadata\",\n  \"directories\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n@@ -54,17 +53,6 @@ dependencies = [\n  \"vergen\",\n ]\n \n-[[package]]\n-name = \"cargo_metadata\"\n-version = \"0.11.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"89fec17b16f1ac67908af82e47d0a90a7afd0e1827b181cd77504323d3263d35\"\n-dependencies = [\n- \"semver 0.10.0\",\n- \"serde\",\n- \"serde_json\",\n-]\n-\n [[package]]\n name = \"cfg-if\"\n version = \"0.1.10\"\n@@ -228,7 +216,7 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n dependencies = [\n- \"semver 0.9.0\",\n+ \"semver\",\n ]\n \n [[package]]\n@@ -246,16 +234,6 @@ dependencies = [\n  \"semver-parser\",\n ]\n \n-[[package]]\n-name = \"semver\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"394cec28fa623e00903caf7ba4fa6fb9a0e260280bb8cdbbba029611108a0190\"\n-dependencies = [\n- \"semver-parser\",\n- \"serde\",\n-]\n-\n [[package]]\n name = \"semver-parser\"\n version = \"0.7.0\""}, {"sha": "2de581c1c2e260abd7068c83df443b69cd4e5698", "filename": "cargo-miri/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2FCargo.toml?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -14,7 +14,6 @@ test = false # we have no unit tests\n doctest = false # and no doc tests\n \n [dependencies]\n-cargo_metadata = \"0.11\"\n directories = \"2.0\"\n rustc_version = \"0.2.3\"\n serde_json = \"1.0.40\""}, {"sha": "522570626d09426842b35f710952ca6b44055a5a", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 345, "deletions": 263, "changes": 608, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -1,37 +1,32 @@\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n-use std::io::{self, BufRead, Write};\n+use std::io::{self, BufRead, BufReader, BufWriter, Write};\n use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use serde::{Deserialize, Serialize};\n+\n use rustc_version::VersionMeta;\n \n const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 22);\n \n-const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and tests in Miri\n+const CARGO_MIRI_HELP: &str = r#\"Runs binary crates and tests in Miri\n \n Usage:\n-    cargo miri [subcommand] [<cargo options>...] [--] [<miri options>...] [--] [<program/test suite options>...]\n+    cargo miri [subcommand] [<cargo options>...] [--] [<program/test suite options>...]\n \n Subcommands:\n-    run                      Run binaries (default)\n+    run                      Run binaries\n     test                     Run tests\n     setup                    Only perform automatic setup, but without asking questions (for getting a proper libstd)\n \n-Common options:\n-    -h, --help               Print this message\n-    --features               Features to compile for the package\n-    -V, --version            Print version info and exit\n-\n-Other [options] are the same as `cargo check`.  Everything after the first \"--\" is\n-passed verbatim to Miri, which will pass everything after the second \"--\" verbatim\n-to the interpreted program.\n+The cargo options are exactly the same as for `cargo run` and `cargo test`, respectively.\n \n Examples:\n-    cargo miri run -- -Zmiri-disable-stacked-borrows\n-    cargo miri test -- -- test-suite-filter\n+    cargo miri run\n+    cargo miri test -- test-suite-filter\n \"#;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -41,6 +36,35 @@ enum MiriCommand {\n     Setup,\n }\n \n+/// The inforamtion Miri needs to run a crate. Stored as JSON when the crate is \"compiled\".\n+#[derive(Serialize, Deserialize)]\n+struct CrateRunInfo {\n+    /// The command-line arguments.\n+    args: Vec<String>,\n+    /// The environment.\n+    env: Vec<(OsString, OsString)>,\n+    /// The current working directory.\n+    current_dir: OsString,\n+}\n+\n+impl CrateRunInfo {\n+    /// Gather all the information we need.\n+    fn collect(args: env::Args) -> Self {\n+        let args = args.collect();\n+        let env = env::vars_os().collect();\n+        let current_dir = env::current_dir().unwrap().into_os_string();\n+        CrateRunInfo { args, env, current_dir }\n+    }\n+\n+    fn store(&self, filename: &Path) {\n+        let file = File::create(filename)\n+            .unwrap_or_else(|_| show_error(format!(\"cannot create `{}`\", filename.display())));\n+        let file = BufWriter::new(file);\n+        serde_json::ser::to_writer(file, self)\n+            .unwrap_or_else(|_| show_error(format!(\"cannot write to `{}`\", filename.display())));\n+    }\n+}\n+\n fn show_help() {\n     println!(\"{}\", CARGO_MIRI_HELP);\n }\n@@ -116,48 +140,13 @@ fn xargo_check() -> Command {\n     Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n }\n \n-fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n-    // We need to get the manifest, and then the metadata, to enumerate targets.\n-    let manifest_path =\n-        get_arg_flag_value(\"--manifest-path\").map(|m| Path::new(&m).canonicalize().unwrap());\n-\n-    let mut cmd = cargo_metadata::MetadataCommand::new();\n-    if let Some(manifest_path) = &manifest_path {\n-        cmd.manifest_path(manifest_path);\n+/// Execute the command. If it fails, fail this process with the same exit code.\n+/// Otherwise, continue.\n+fn exec(mut cmd: Command) {\n+    let exit_status = cmd.status().expect(\"failed to run command\");\n+    if exit_status.success().not() {\n+        std::process::exit(exit_status.code().unwrap_or(-1))\n     }\n-    let mut metadata = if let Ok(metadata) = cmd.exec() {\n-        metadata\n-    } else {\n-        show_error(format!(\"Could not obtain Cargo metadata; likely an ill-formed manifest\"));\n-    };\n-\n-    let current_dir = std::env::current_dir();\n-\n-    let package_index = metadata\n-        .packages\n-        .iter()\n-        .position(|package| {\n-            let package_manifest_path = Path::new(&package.manifest_path);\n-            if let Some(manifest_path) = &manifest_path {\n-                package_manifest_path == manifest_path\n-            } else {\n-                let current_dir = current_dir.as_ref().expect(\"could not read current directory\");\n-                let package_manifest_directory = package_manifest_path\n-                    .parent()\n-                    .expect(\"could not find parent directory of package manifest\");\n-                package_manifest_directory == current_dir\n-            }\n-        })\n-        .unwrap_or_else(|| {\n-            show_error(format!(\n-                \"this seems to be a workspace, which is not supported by `cargo miri`.\\n\\\n-                 Try to `cd` into the crate you want to test, and re-run `cargo miri` there.\"\n-            ))\n-        });\n-    let package = metadata.packages.remove(package_index);\n-\n-    // Finally we got the list of targets to build\n-    package.targets.into_iter()\n }\n \n fn xargo_version() -> Option<(u32, u32, u32)> {\n@@ -218,15 +207,15 @@ fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n         match buf.trim().to_lowercase().as_ref() {\n             // Proceed.\n             \"\" | \"y\" | \"yes\" => {}\n-            \"n\" | \"no\" => show_error(format!(\"Aborting as per your request\")),\n-            a => show_error(format!(\"I do not understand `{}`\", a)),\n+            \"n\" | \"no\" => show_error(format!(\"aborting as per your request\")),\n+            a => show_error(format!(\"invalid answer `{}`\", a)),\n         };\n     } else {\n         println!(\"Running `{:?}` to {}.\", cmd, text);\n     }\n \n     if cmd.status().expect(&format!(\"failed to execute {:?}\", cmd)).success().not() {\n-        show_error(format!(\"Failed to {}\", text));\n+        show_error(format!(\"failed to {}\", text));\n     }\n }\n \n@@ -249,7 +238,7 @@ fn setup(subcommand: MiriCommand) {\n     if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n         if std::env::var_os(\"XARGO_CHECK\").is_some() {\n             // The user manually gave us a xargo binary; don't do anything automatically.\n-            show_error(format!(\"Your xargo is too old; please upgrade to the latest version\"))\n+            show_error(format!(\"xargo is too old; please upgrade to the latest version\"))\n         }\n         let mut cmd = cargo();\n         cmd.args(&[\"install\", \"xargo\", \"-f\"]);\n@@ -289,7 +278,7 @@ fn setup(subcommand: MiriCommand) {\n         }\n     };\n     if !rust_src.exists() {\n-        show_error(format!(\"Given Rust source directory `{}` does not exist.\", rust_src.display()));\n+        show_error(format!(\"given Rust source directory `{}` does not exist.\", rust_src.display()));\n     }\n \n     // Next, we need our own libstd. Prepare a xargo project for that purpose.\n@@ -363,7 +352,7 @@ path = \"lib.rs\"\n     command.env_remove(\"RUSTFLAGS\");\n     // Finally run it!\n     if command.status().expect(\"failed to run xargo\").success().not() {\n-        show_error(format!(\"Failed to run xargo\"));\n+        show_error(format!(\"failed to run xargo\"));\n     }\n \n     // That should be it! But we need to figure out where xargo built stuff.\n@@ -381,173 +370,127 @@ path = \"lib.rs\"\n     }\n }\n \n-enum CargoTargets {\n-    All,\n-    Filtered { lib: bool, bin: Vec<String>, test: Vec<String> },\n-}\n-\n-impl CargoTargets {\n-    fn matches(&self, kind: &str, name: &str) -> bool {\n-        match self {\n-            CargoTargets::All => true,\n-            CargoTargets::Filtered { lib, bin, test } => match kind {\n-                \"lib\" => *lib,\n-                \"bin\" => bin.iter().any(|n| n == name),\n-                \"test\" => test.iter().any(|n| n == name),\n-                _ => false,\n-            },\n-        }\n+fn phase_cargo_miri(mut args: env::Args) {\n+    // Check for version and help flags even when invoked as `cargo-miri`.\n+    if has_arg_flag(\"--help\") || has_arg_flag(\"-h\") {\n+        show_help();\n+        return;\n     }\n-}\n-\n-fn parse_cargo_miri_args(\n-    mut args: impl Iterator<Item = String>,\n-) -> (CargoTargets, Vec<String>, Vec<String>) {\n-    let mut lib_present = false;\n-    let mut bin_targets = Vec::new();\n-    let mut test_targets = Vec::new();\n-    let mut additional_args = Vec::new();\n-    while let Some(arg) = args.next() {\n-        match arg {\n-            arg if arg == \"--\" => {\n-                // Miri arguments begin after the first \"--\".\n-                break;\n-            }\n-            arg if arg == \"--lib\" => lib_present = true,\n-            arg if arg == \"--bin\" => {\n-                if let Some(binary) = args.next() {\n-                    if binary == \"--\" {\n-                        show_error(format!(\"\\\"--bin\\\" takes one argument.\"));\n-                    } else {\n-                        bin_targets.push(binary)\n-                    }\n-                } else {\n-                    show_error(format!(\"\\\"--bin\\\" takes one argument.\"));\n-                }\n-            }\n-            arg if arg.starts_with(\"--bin=\") => bin_targets.push((&arg[\"--bin=\".len()..]).to_string()),\n-            arg if arg == \"--test\" => {\n-                if let Some(test) = args.next() {\n-                    if test == \"--\" {\n-                        show_error(format!(\"\\\"--test\\\" takes one argument.\"));\n-                    } else {\n-                        test_targets.push(test)\n-                    }\n-                } else {\n-                    show_error(format!(\"\\\"--test\\\" takes one argument.\"));\n-                }\n-            }\n-            arg if arg.starts_with(\"--test=\") => test_targets.push((&arg[\"--test=\".len()..]).to_string()),\n-            other => additional_args.push(other),\n-        }\n+    if has_arg_flag(\"--version\") || has_arg_flag(\"-V\") {\n+        show_version();\n+        return;\n     }\n-    let targets = if !lib_present && bin_targets.len() == 0 && test_targets.len() == 0 {\n-        CargoTargets::All\n-    } else {\n-        CargoTargets::Filtered { lib: lib_present, bin: bin_targets, test: test_targets }\n-    };\n-    (targets, additional_args, args.collect())\n-}\n \n-fn in_cargo_miri() {\n-    let (subcommand, skip) = match std::env::args().nth(2).as_deref() {\n-        Some(\"test\") => (MiriCommand::Test, 3),\n-        Some(\"run\") => (MiriCommand::Run, 3),\n-        Some(\"setup\") => (MiriCommand::Setup, 3),\n-        // Default command, if there is an option or nothing.\n-        Some(s) if s.starts_with(\"-\") => (MiriCommand::Run, 2),\n-        None => (MiriCommand::Run, 2),\n+    // Require a subcommand before any flags.\n+    // We cannot know which of those flags take arguments and which do not,\n+    // so we cannot detect subcommands later.\n+    let subcommand = match args.next().as_deref() {\n+        Some(\"test\") => MiriCommand::Test,\n+        Some(\"run\") => MiriCommand::Run,\n+        Some(\"setup\") => MiriCommand::Setup,\n         // Invalid command.\n-        Some(s) => show_error(format!(\"Unknown command `{}`\", s)),\n+        _ => show_error(format!(\"`cargo miri` supports the following subcommands: `run`, `test`, and `setup`.\")),\n     };\n     let verbose = has_arg_flag(\"-v\");\n \n     // We always setup.\n     setup(subcommand);\n-    if subcommand == MiriCommand::Setup {\n-        // Stop here.\n-        return;\n-    }\n \n-    // FIXME: this accepts --test, --lib, and multiple --bin for `cargo miri run`.\n-    let (target_filters, cargo_args, miri_args) =\n-        parse_cargo_miri_args(std::env::args().skip(skip));\n+    // Invoke actual cargo for the job, but with different flags.\n+    // We re-use `cargo test` and `cargo run`, which makes target and binary handling very easy but\n+    // requires some extra work to make the build check-only (see all the `--emit` hacks below).\n+    // <https://github.com/rust-lang/miri/pull/1540#issuecomment-693553191> describes an alternative\n+    // approach that uses `cargo check`, making that part easier but target and binary handling\n+    // harder.\n+    let miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    let cargo_cmd = match subcommand {\n+        MiriCommand::Test => \"test\",\n+        MiriCommand::Run => \"run\",\n+        MiriCommand::Setup => return, // `cargo miri setup` stops here.\n+    };\n+    let mut cmd = cargo();\n+    cmd.arg(cargo_cmd);\n+\n+    // Make sure we know the build target, and cargo does, too.\n+    // This is needed to make the `CARGO_TARGET_*_RUNNER` env var do something,\n+    // and it later helps us detect which crates are proc-macro/build-script\n+    // (host crates) and which crates are needed for the program itself.\n+    let target = if let Some(target) = get_arg_flag_value(\"--target\") {\n+        target\n+    } else {\n+        // No target given. Pick default and tell cargo about it.\n+        let host = version_info().host;\n+        cmd.arg(\"--target\");\n+        cmd.arg(&host);\n+        host\n+    };\n \n-    // Now run the command.\n-    for target in list_targets() {\n-        let kind = target\n-            .kind\n-            .get(0)\n-            .expect(\"badly formatted cargo metadata: target::kind is an empty array\");\n-        if !target_filters.matches(kind, &target.name) {\n-            continue;\n-        }\n-        // Now we run `cargo check $FLAGS $ARGS`, giving the user the\n-        // change to add additional arguments. `FLAGS` is set to identify\n-        // this target.  The user gets to control what gets actually passed to Miri.\n-        let mut cmd = cargo();\n-        cmd.arg(\"check\");\n-        match (subcommand, kind.as_str()) {\n-            (MiriCommand::Run, \"bin\") => {\n-                // FIXME: we default to running all binaries here.\n-                cmd.arg(\"--bin\").arg(target.name);\n-            }\n-            (MiriCommand::Test, \"test\") => {\n-                cmd.arg(\"--test\").arg(target.name);\n-            }\n-            (MiriCommand::Test, \"lib\") => {\n-                // There can be only one lib.\n-                cmd.arg(\"--lib\").arg(\"--profile\").arg(\"test\");\n-            }\n-            (MiriCommand::Test, \"bin\") => {\n-                cmd.arg(\"--bin\").arg(target.name).arg(\"--profile\").arg(\"test\");\n+    // Forward all further arguments. We do some processing here because we want to\n+    // detect people still using the old way of passing flags to Miri\n+    // (`cargo miri -- -Zmiri-foo`).\n+    while let Some(arg) = args.next() {\n+        cmd.arg(&arg);\n+        if arg == \"--\" {\n+            // Check if the next argument starts with `-Zmiri`. If yes, we assume\n+            // this is an old-style invocation.\n+            if let Some(next_arg) = args.next() {\n+                if next_arg.starts_with(\"-Zmiri\") {\n+                    eprintln!(\n+                        \"WARNING: it seems like you are setting Miri's flags in `cargo miri` the old way,\\n\\\n+                        i.e., by passing them after the first `--`. This style is deprecated; please set\\n\\\n+                        the MIRIFLAGS environment variable instead. `cargo miri run/test` now interprets\\n\\\n+                        arguments the exact same way as `cargo run/test`.\"\n+                    );\n+                    // Old-style invocation. Turn these into MIRIFLAGS.\n+                    let mut miriflags = env::var(\"MIRIFLAGS\").unwrap_or_default();\n+                    miriflags.push(' ');\n+                    miriflags.push_str(&next_arg);\n+                    while let Some(further_arg) = args.next() {\n+                        if further_arg == \"--\" {\n+                            // End of the Miri flags!\n+                            break;\n+                        }\n+                        miriflags.push(' ');\n+                        miriflags.push_str(&further_arg);\n+                    }\n+                    env::set_var(\"MIRIFLAGS\", miriflags);\n+                    // Pass the remaining flags to cargo.\n+                    cmd.args(args);\n+                    break;\n+                }\n+                // Not a Miri argument after all, make sure we pass it to cargo.\n+                cmd.arg(next_arg);\n             }\n-            // The remaining targets we do not even want to build.\n-            _ => continue,\n-        }\n-        // Forward further `cargo` args.\n-        for arg in cargo_args.iter() {\n-            cmd.arg(arg);\n-        }\n-        // We want to always run `cargo` with `--target`. This later helps us detect\n-        // which crates are proc-macro/build-script (host crates) and which crates are\n-        // needed for the program itself.\n-        if get_arg_flag_value(\"--target\").is_none() {\n-            // When no `--target` is given, default to the host.\n-            cmd.arg(\"--target\");\n-            cmd.arg(version_info().host);\n         }\n+    }\n \n-        // Serialize the remaining args into a special environemt variable.\n-        // This will be read by `inside_cargo_rustc` when we go to invoke\n-        // our actual target crate (the binary or the test we are running).\n-        // Since we're using \"cargo check\", we have no other way of passing\n-        // these arguments.\n-        cmd.env(\"MIRI_ARGS\", serde_json::to_string(&miri_args).expect(\"failed to serialize args\"));\n-\n-        // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n-        // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n-        // the two codepaths. (That extra argument is why we prefer this over setting `RUSTC`.)\n-        if env::var_os(\"RUSTC_WRAPPER\").is_some() {\n-            println!(\"WARNING: Ignoring existing `RUSTC_WRAPPER` environment variable, Miri does not support wrapping.\");\n-        }\n-        let path = std::env::current_exe().expect(\"current executable path invalid\");\n-        cmd.env(\"RUSTC_WRAPPER\", path);\n-        if verbose {\n-            cmd.env(\"MIRI_VERBOSE\", \"\"); // this makes `inside_cargo_rustc` verbose.\n-            eprintln!(\"+ {:?}\", cmd);\n-        }\n+    // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n+    // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n+    // the two codepaths. (That extra argument is why we prefer this over setting `RUSTC`.)\n+    if env::var_os(\"RUSTC_WRAPPER\").is_some() {\n+        println!(\"WARNING: Ignoring `RUSTC_WRAPPER` environment variable, Miri does not support wrapping.\");\n+    }\n+    cmd.env(\"RUSTC_WRAPPER\", &miri_path);\n+    if verbose {\n+        eprintln!(\"+ RUSTC_WRAPPER={:?}\", miri_path);\n+    }\n \n-        let exit_status =\n-            cmd.spawn().expect(\"could not run cargo\").wait().expect(\"failed to wait for cargo?\");\n+    // Set the runner for the current target to us as well, so we can interpret the binaries.\n+    let runner_env_name = format!(\"CARGO_TARGET_{}_RUNNER\", target.to_uppercase().replace('-', \"_\"));\n+    cmd.env(runner_env_name, &miri_path);\n \n-        if !exit_status.success() {\n-            std::process::exit(exit_status.code().unwrap_or(-1))\n-        }\n+    // Set rustdoc to us as well, so we can make it do nothing (see issue #584).\n+    cmd.env(\"RUSTDOC\", &miri_path);\n+\n+    // Run cargo.\n+    if verbose {\n+        cmd.env(\"MIRI_VERBOSE\", \"\"); // This makes the other phases verbose.\n+        eprintln!(\"[cargo-miri miri] {:?}\", cmd);\n     }\n+    exec(cmd)\n }\n \n-fn inside_cargo_rustc() {\n+fn phase_cargo_rustc(args: env::Args) {\n     /// Determines if we are being invoked (as rustc) to build a crate for\n     /// the \"target\" architecture, in contrast to the \"host\" architecture.\n     /// Host crates are for build scripts and proc macros and still need to\n@@ -567,82 +510,221 @@ fn inside_cargo_rustc() {\n     /// Cargo does not give us this information directly, so we need to check\n     /// various command-line flags.\n     fn is_runnable_crate() -> bool {\n-        let is_bin = get_arg_flag_value(\"--crate-type\").as_deref() == Some(\"bin\");\n+        let is_bin = get_arg_flag_value(\"--crate-type\").as_deref().unwrap_or(\"bin\") == \"bin\";\n         let is_test = has_arg_flag(\"--test\");\n-        is_bin || is_test\n+        let print = get_arg_flag_value(\"--print\").is_some();\n+        (is_bin || is_test) && !print\n+    }\n+\n+    fn out_filename(prefix: &str, suffix: &str) -> PathBuf {\n+        let mut path = PathBuf::from(get_arg_flag_value(\"--out-dir\").unwrap());\n+        path.push(format!(\n+            \"{}{}{}{}\",\n+            prefix,\n+            get_arg_flag_value(\"--crate-name\").unwrap(),\n+            // This is technically a `-C` flag but the prefix seems unique enough...\n+            // (and cargo passes this before the filename so it should be unique)\n+            get_arg_flag_value(\"extra-filename\").unwrap_or(String::new()),\n+            suffix,\n+        ));\n+        path\n     }\n \n     let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n     let target_crate = is_target_crate();\n \n-    let mut cmd = miri();\n-    // Forward arguments.\n-    cmd.args(std::env::args().skip(2)); // skip `cargo-miri rustc`\n+    if target_crate && is_runnable_crate() {\n+        // This is the binary or test crate that we want to interpret under Miri.\n+        // But we cannot run it here, as cargo invoked us as a compiler -- our stdin and stdout are not\n+        // like we want them.\n+        // Instead of compiling, we write JSON into the output file with all the relevant command-line flags\n+        // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n+        let info = CrateRunInfo::collect(args);\n+        let filename = out_filename(\"\", \"\");\n+        if verbose {\n+            eprintln!(\"[cargo-miri rustc] writing run info to `{}`\", filename.display());\n+        }\n+\n+        info.store(&filename);\n+        // For Windows, do the same thing again with `.exe` appended to the filename.\n+        // (Need to do this here as cargo moves that \"binary\" to a different place before running it.)\n+        info.store(&out_filename(\"\", \".exe\"));\n \n-    // We make sure to only specify our custom Xargo sysroot for target crates - that is,\n-    // crates which are needed for interpretation by Miri. proc-macros and build scripts\n-    // should use the default sysroot.\n+        return;\n+    }\n+\n+    let mut cmd = miri();\n+    let mut emit_link_hack = false;\n+    // Arguments are treated very differently depending on whether this crate is\n+    // for interpretation by Miri, or for use by a build script / proc macro.\n     if target_crate {\n+        // Forward arguments, but remove \"link\" from \"--emit\" to make this a check-only build.\n+        let emit_flag = \"--emit\";\n+        for arg in args {\n+            if arg.starts_with(emit_flag) {\n+                // Patch this argument. First, extract its value.\n+                let val = &arg[emit_flag.len()..];\n+                assert!(val.starts_with(\"=\"), \"`cargo` should pass `--emit=X` as one argument\");\n+                let val = &val[1..];\n+                let mut val: Vec<_> = val.split(',').collect();\n+                // Now make sure \"link\" is not in there, but \"metadata\" is.\n+                if let Some(i) = val.iter().position(|&s| s == \"link\") {\n+                    emit_link_hack = true;\n+                    val.remove(i);\n+                    if !val.iter().any(|&s| s == \"metadata\") {\n+                        val.push(\"metadata\");\n+                    }\n+                }\n+                cmd.arg(format!(\"{}={}\", emit_flag, val.join(\",\")));\n+            } else {\n+                cmd.arg(arg);\n+            }\n+        }\n+\n+        // Use our custom sysroot.\n         let sysroot =\n-            env::var_os(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n+            env::var_os(\"MIRI_SYSROOT\").expect(\"the wrapper should have set MIRI_SYSROOT\");\n         cmd.arg(\"--sysroot\");\n         cmd.arg(sysroot);\n+    } else {\n+        // For host crates, just forward everything.\n+        cmd.args(args);\n     }\n \n-    // If this is a runnable target crate, we want Miri to start interpretation;\n-    // otherwise we want Miri to behave like rustc and build the crate as usual.\n-    if target_crate && is_runnable_crate() {\n-        // This is the binary or test crate that we want to interpret under Miri.\n-        // (Testing `target_crate` is needed to exclude build scripts.)\n-        // We deserialize the arguments that are meant for Miri from the special environment\n-        // variable \"MIRI_ARGS\", and feed them to the 'miri' binary.\n-        //\n-        // `env::var` is okay here, well-formed JSON is always UTF-8.\n-        let magic = std::env::var(\"MIRI_ARGS\").expect(\"missing MIRI_ARGS\");\n-        let miri_args: Vec<String> =\n-            serde_json::from_str(&magic).expect(\"failed to deserialize MIRI_ARGS\");\n-        cmd.args(miri_args);\n-    } else {\n-        // We want to compile, not interpret.\n-        cmd.env(\"MIRI_BE_RUSTC\", \"1\");\n-    };\n+    // We want to compile, not interpret. We still use Miri to make sure the compiler version etc\n+    // are the exact same as what is used for interpretation.\n+    cmd.env(\"MIRI_BE_RUSTC\", \"1\");\n \n     // Run it.\n     if verbose {\n-        eprintln!(\"+ {:?}\", cmd);\n+        eprintln!(\"[cargo-miri rustc] {:?}\", cmd);\n     }\n-    match cmd.status() {\n-        Ok(exit) =>\n-            if !exit.success() {\n-                std::process::exit(exit.code().unwrap_or(42));\n-            },\n-        Err(e) => panic!(\"error running {:?}:\\n{:?}\", cmd, e),\n+    exec(cmd);\n+\n+    // Create a stub .rlib file if \"link\" was requested by cargo.\n+    if emit_link_hack {\n+        // Some platforms prepend \"lib\", some do not... let's just create both files.\n+        let filename = out_filename(\"lib\", \".rlib\");\n+        File::create(filename).expect(\"failed to create rlib file\");\n+        let filename = out_filename(\"\", \".rlib\");\n+        File::create(filename).expect(\"failed to create rlib file\");\n     }\n }\n \n-fn main() {\n-    // Check for version and help flags even when invoked as `cargo-miri`.\n-    if has_arg_flag(\"--help\") || has_arg_flag(\"-h\") {\n-        show_help();\n-        return;\n+fn phase_cargo_runner(binary: &Path, binary_args: env::Args) {\n+    let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n+\n+    let file = File::open(&binary)\n+        .unwrap_or_else(|_| show_error(format!(\"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary)));\n+    let file = BufReader::new(file);\n+    let info: CrateRunInfo = serde_json::from_reader(file)\n+        .unwrap_or_else(|_| show_error(format!(\"file {:?} contains outdated or invalid JSON; try `cargo clean`\", binary)));\n+\n+    // Set missing env vars. Looks like `build.rs` vars are still set at run-time, but\n+    // `CARGO_BIN_EXE_*` are not. This means we can give the run-time environment precedence,\n+    // to rather do too little than too much.\n+    for (name, val) in info.env {\n+        if env::var_os(&name).is_none() {\n+            env::set_var(name, val);\n+        }\n     }\n-    if has_arg_flag(\"--version\") || has_arg_flag(\"-V\") {\n-        show_version();\n-        return;\n+\n+    let mut cmd = miri();\n+    // Forward rustc arguments.\n+    // We need to patch \"--extern\" filenames because we forced a check-only\n+    // build without cargo knowing about that: replace `.rlib` suffix by\n+    // `.rmeta`.\n+    // We also need to remove `--error-format` as cargo specifies that to be JSON,\n+    // but when we run here, cargo does not interpret the JSON any more. `--json`\n+    // then also nees to be dropped.\n+    let mut args = info.args.into_iter();\n+    let extern_flag = \"--extern\";\n+    let error_format_flag = \"--error-format\";\n+    let json_flag = \"--json\";\n+    while let Some(arg) = args.next() {\n+        if arg == extern_flag {\n+            // `--extern` is always passed as a separate argument by cargo.\n+            let next_arg = args.next().expect(\"`--extern` should be followed by a filename\");\n+            let next_arg = next_arg.strip_suffix(\".rlib\").expect(\"all extern filenames should end in `.rlib`\");\n+            cmd.arg(extern_flag);\n+            cmd.arg(format!(\"{}.rmeta\", next_arg));\n+        } else if arg.starts_with(error_format_flag) {\n+            let suffix = &arg[error_format_flag.len()..];\n+            assert!(suffix.starts_with('='));\n+            // Drop this argument.\n+        } else if arg.starts_with(json_flag) {\n+            let suffix = &arg[json_flag.len()..];\n+            assert!(suffix.starts_with('='));\n+            // Drop this argument.\n+        } else {\n+            cmd.arg(arg);\n+        }\n+    }\n+    // Set sysroot.\n+    let sysroot =\n+        env::var_os(\"MIRI_SYSROOT\").expect(\"the wrapper should have set MIRI_SYSROOT\");\n+    cmd.arg(\"--sysroot\");\n+    cmd.arg(sysroot);\n+    // Respect `MIRIFLAGS`.\n+    if let Ok(a) = env::var(\"MIRIFLAGS\") {\n+        // This code is taken from `RUSTFLAGS` handling in cargo.\n+        let args = a\n+            .split(' ')\n+            .map(str::trim)\n+            .filter(|s| !s.is_empty())\n+            .map(str::to_string);\n+        cmd.args(args);\n     }\n \n-    if let Some(\"miri\") = std::env::args().nth(1).as_deref() {\n-        // This arm is for when `cargo miri` is called. We call `cargo check` for each applicable target,\n-        // but with the `RUSTC` env var set to the `cargo-miri` binary so that we come back in the other branch,\n-        // and dispatch the invocations to `rustc` and `miri`, respectively.\n-        in_cargo_miri();\n-    } else if let Some(\"rustc\") = std::env::args().nth(1).as_deref() {\n-        // This arm is executed when `cargo-miri` runs `cargo check` with the `RUSTC_WRAPPER` env var set to itself:\n-        // dependencies get dispatched to `rustc`, the final test/binary to `miri`.\n-        inside_cargo_rustc();\n-    } else {\n-        show_error(format!(\n-            \"`cargo-miri` must be called with either `miri` or `rustc` as first argument.\"\n-        ))\n+    // Then pass binary arguments.\n+    cmd.arg(\"--\");\n+    cmd.args(binary_args);\n+\n+    // Make sure we use the build-time working directory for interpreting Miri/rustc arguments.\n+    // But then we need to switch to the run-time one, which we instruct Miri do do by setting `MIRI_CWD`.\n+    cmd.current_dir(info.current_dir);\n+    cmd.env(\"MIRI_CWD\", env::current_dir().unwrap());\n+\n+    // Run it.\n+    if verbose {\n+        eprintln!(\"[cargo-miri runner] {:?}\", cmd);\n+    }\n+    exec(cmd)\n+}\n+\n+fn main() {\n+    // Rustc does not support non-UTF-8 arguments so we make no attempt either.\n+    // (We do support non-UTF-8 environment variables though.)\n+    let mut args = std::env::args();\n+    // Skip binary name.\n+    args.next().unwrap();\n+\n+    // Dispatch to `cargo-miri` phase. There are three phases:\n+    // - When we are called via `cargo miri`, we run as the frontend and invoke the underlying\n+    //   cargo. We set RUSTC_WRAPPER and CARGO_TARGET_RUNNER to ourselves.\n+    // - When we are executed due to RUSTC_WRAPPER, we build crates or store the flags of\n+    //   binary crates for later interpretation.\n+    // - When we are executed due to CARGO_TARGET_RUNNER, we start interpretation based on the\n+    //   flags that were stored earlier.\n+    // On top of that, we are also called as RUSTDOC, but that is just a stub currently.\n+    match args.next().as_deref() {\n+        Some(\"miri\") => phase_cargo_miri(args),\n+        Some(\"rustc\") => phase_cargo_rustc(args),\n+        Some(arg) => {\n+            // We have to distinguish the \"runner\" and \"rustfmt\" cases.\n+            // As runner, the first argument is the binary (a file that should exist, with an absolute path);\n+            // as rustfmt, the first argument is a flag (`--something`).\n+            let binary = Path::new(arg);\n+            if binary.exists() {\n+                assert!(!arg.starts_with(\"--\")); // not a flag\n+                phase_cargo_runner(binary, args);\n+            } else if arg.starts_with(\"--\") {\n+                // We are rustdoc.\n+                eprintln!(\"Running doctests is not currently supported by Miri.\")\n+            } else {\n+                show_error(format!(\"`cargo-miri` called with unexpected first argument `{}`; please only invoke this binary through `cargo miri`\", arg));\n+            }\n+        }\n+        _ => show_error(format!(\"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\")),\n     }\n }"}, {"sha": "12683a2fccbec7c5bb9f2515ef7142789da24bc4", "filename": "ci.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/ci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/ci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci.sh?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -26,7 +26,7 @@ function run_tests {\n   if ! [ -n \"${MIRI_TEST_TARGET+exists}\" ]; then\n     # Only for host architecture: tests with MIR optimizations\n     # FIXME: only testing level 2 because of <https://github.com/rust-lang/rust/issues/76432>.\n-    MIRI_TEST_FLAGS=\"-Z mir-opt-level=2\" ./miri test --locked\n+    MIRIFLAGS=\"-Z mir-opt-level=2\" ./miri test --locked\n   fi\n   # \"miri test\" has built the sysroot for us, now this should pass without\n   # any interactive questions."}, {"sha": "aef61b6dd68d3096ea037ae4968f6433020566a7", "filename": "miri", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/miri", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -39,6 +39,11 @@ EOF\n TARGET=$(rustc --version --verbose | grep \"^host:\" | cut -d ' ' -f 2)\n SYSROOT=$(rustc --print sysroot)\n LIBDIR=$SYSROOT/lib/rustlib/$TARGET/lib\n+MIRIDIR=$(dirname \"$0\")\n+if readlink -e . >/dev/null; then\n+    # This platform supports `readlink -e`.\n+    MIRIDIR=$(readlink -e \"$MIRIDIR\")\n+fi\n if ! test -d \"$LIBDIR\"; then\n     echo \"Something went wrong determining the library dir.\"\n     echo \"I got $LIBDIR but that does not exist.\"\n@@ -51,7 +56,7 @@ if [ -z \"$CARGO_INCREMENTAL\" ]; then\n fi\n if [ -z \"$CARGO_TARGET_DIR\" ]; then\n     # Share target dir between `miri` and `cargo-miri`.\n-    export CARGO_TARGET_DIR=\"$(dirname \"$0\")\"/target\n+    export CARGO_TARGET_DIR=\"$MIRIDIR/target\"\n fi\n # We set the rpath so that Miri finds the private rustc libraries it needs.\n # We enable debug-assertions to get tracing.\n@@ -63,9 +68,9 @@ export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$LIBDIR -C debug-assertions -C debugin\n # Build a sysroot and set MIRI_SYSROOT to use it.  Arguments are passed to `cargo miri setup`.\n build_sysroot() {\n     # Build once, for the user to see.\n-    cargo run $CARGO_BUILD_FLAGS --manifest-path \"$(dirname \"$0\")\"/cargo-miri/Cargo.toml -- miri setup \"$@\"\n+    cargo run $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -- miri setup \"$@\"\n     # Call again, to just set env var.\n-    export MIRI_SYSROOT=\"$(cargo run $CARGO_BUILD_FLAGS --manifest-path \"$(dirname \"$0\")\"/cargo-miri/Cargo.toml -q -- miri setup --print-sysroot \"$@\")\"\n+    export MIRI_SYSROOT=\"$(cargo run $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -q -- miri setup --print-sysroot \"$@\")\"\n }\n \n # Prepare and set MIRI_SYSROOT.  Respects `MIRI_TEST_TARGET` and takes into account\n@@ -108,18 +113,18 @@ case \"$COMMAND\" in\n install|install-debug)\n     # \"--locked\" to respect the Cargo.lock file if it exists,\n     # \"--offline\" to avoid querying the registry (for yanked packages).\n-    cargo install $CARGO_INSTALL_FLAGS --path \"$(dirname \"$0\")\" --force --locked --offline \"$@\"\n-    cargo install $CARGO_INSTALL_FLAGS --path \"$(dirname \"$0\")\"/cargo-miri --force --locked --offline \"$@\"\n+    cargo install $CARGO_INSTALL_FLAGS --path \"$MIRIDIR\" --force --locked --offline \"$@\"\n+    cargo install $CARGO_INSTALL_FLAGS --path \"$MIRIDIR\"/cargo-miri --force --locked --offline \"$@\"\n     ;;\n check|check-debug)\n     # Check, and let caller control flags.\n-    cargo check $CARGO_BUILD_FLAGS --manifest-path \"$(dirname \"$0\")\"/Cargo.toml \"$@\"\n-    cargo check $CARGO_BUILD_FLAGS --manifest-path \"$(dirname \"$0\")\"/cargo-miri/Cargo.toml \"$@\"\n+    cargo check $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml \"$@\"\n+    cargo check $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml \"$@\"\n     ;;\n build|build-debug)\n     # Build, and let caller control flags.\n-    cargo build $CARGO_BUILD_FLAGS --manifest-path \"$(dirname \"$0\")\"/Cargo.toml \"$@\"\n-    cargo build $CARGO_BUILD_FLAGS --manifest-path \"$(dirname \"$0\")\"/cargo-miri/Cargo.toml \"$@\"\n+    cargo build $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml \"$@\"\n+    cargo build $CARGO_BUILD_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml \"$@\"\n     ;;\n test|test-debug)\n     # First build and get a sysroot."}, {"sha": "4363f9a150a78a9867aafa1f3a8f0404e463e841", "filename": "src/bin/miri.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -45,6 +45,11 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n             // Add filename to `miri` arguments.\n             config.args.insert(0, compiler.input().filestem().to_string());\n \n+            // Adjust working directory for interpretation.\n+            if let Some(cwd) = env::var_os(\"MIRI_CWD\") {\n+                env::set_current_dir(cwd).unwrap();\n+            }\n+\n             if let Some(return_code) = miri::eval_main(tcx, entry_def_id.to_def_id(), config) {\n                 std::process::exit(\n                     i32::try_from(return_code).expect(\"Return value was too large!\"),"}, {"sha": "6bc70135a898a3226e9b8c85957fef2acadb4fb6", "filename": "test-cargo-miri/Cargo.lock", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.lock?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -4,120 +4,122 @@\n name = \"byteorder\"\n version = \"1.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de\"\n \n [[package]]\n name = \"cargo-miri-test\"\n version = \"0.1.0\"\n dependencies = [\n- \"byteorder 1.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"byteorder\",\n+ \"num_cpus\",\n+ \"rand\",\n ]\n \n [[package]]\n name = \"cfg-if\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n \n [[package]]\n name = \"getrandom\"\n version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7abc8dd8451921606d809ba32e95b6111925cd2906060d2dcc29c070220503eb\"\n dependencies = [\n- \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"wasi 0.9.0+wasi-snapshot-preview1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n ]\n \n [[package]]\n name = \"hermit-abi\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"725cf19794cf90aa94e65050cb4191ff5d8fa87a498383774c47b332e3af952e\"\n dependencies = [\n- \"libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc\",\n ]\n \n [[package]]\n name = \"libc\"\n version = \"0.2.68\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dea0c0405123bba743ee3f91f49b1c7cfb684eef0da0a50110f758ccf24cdff0\"\n \n [[package]]\n name = \"num_cpus\"\n version = \"1.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"46203554f085ff89c235cd12f7075f3233af9b11ed7c9e16dfe2560d03313ce6\"\n dependencies = [\n- \"hermit-abi 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hermit-abi\",\n+ \"libc\",\n ]\n \n [[package]]\n name = \"ppv-lite86\"\n version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"74490b50b9fbe561ac330df47c08f3f33073d2d00c150f719147d7c54522fa1b\"\n \n [[package]]\n name = \"rand\"\n version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n- \"getrandom 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand_chacha 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand_core 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand_hc 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand_pcg 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getrandom\",\n+ \"libc\",\n+ \"rand_chacha\",\n+ \"rand_core\",\n+ \"rand_hc\",\n+ \"rand_pcg\",\n ]\n \n [[package]]\n name = \"rand_chacha\"\n version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402\"\n dependencies = [\n- \"ppv-lite86 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand_core 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ppv-lite86\",\n+ \"rand_core\",\n ]\n \n [[package]]\n name = \"rand_core\"\n version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n dependencies = [\n- \"getrandom 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getrandom\",\n ]\n \n [[package]]\n name = \"rand_hc\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\"\n dependencies = [\n- \"rand_core 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core\",\n ]\n \n [[package]]\n name = \"rand_pcg\"\n version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429\"\n dependencies = [\n- \"rand_core 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core\",\n ]\n \n+[[package]]\n+name = \"subcrate\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"wasi\"\n version = \"0.9.0+wasi-snapshot-preview1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[metadata]\n-\"checksum byteorder 1.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de\"\n-\"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum getrandom 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7abc8dd8451921606d809ba32e95b6111925cd2906060d2dcc29c070220503eb\"\n-\"checksum hermit-abi 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"725cf19794cf90aa94e65050cb4191ff5d8fa87a498383774c47b332e3af952e\"\n-\"checksum libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dea0c0405123bba743ee3f91f49b1c7cfb684eef0da0a50110f758ccf24cdff0\"\n-\"checksum num_cpus 1.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"46203554f085ff89c235cd12f7075f3233af9b11ed7c9e16dfe2560d03313ce6\"\n-\"checksum ppv-lite86 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74490b50b9fbe561ac330df47c08f3f33073d2d00c150f719147d7c54522fa1b\"\n-\"checksum rand 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n-\"checksum rand_chacha 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402\"\n-\"checksum rand_core 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n-\"checksum rand_hc 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\"\n-\"checksum rand_pcg 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429\"\n-\"checksum wasi 0.9.0+wasi-snapshot-preview1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\"\n+checksum = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\""}, {"sha": "4900ce9675d6fdc278c3c12a8bf18e3320400c35", "filename": "test-cargo-miri/Cargo.toml", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.toml?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -1,7 +1,10 @@\n+[workspace]\n+members = [\"subcrate\"]\n+\n [package]\n name = \"cargo-miri-test\"\n version = \"0.1.0\"\n-authors = [\"Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\"]\n+authors = [\"Miri Team\"]\n edition = \"2018\"\n \n [dependencies]\n@@ -10,3 +13,6 @@ byteorder = \"1.0\"\n [dev-dependencies]\n rand = { version = \"0.7\", features = [\"small_rng\"] }\n num_cpus = \"1.10.1\"\n+\n+[lib]\n+test = false # test that this is respected (will show in the output)"}, {"sha": "9851ccf39f3ff3354ae188db2b616c8e15493436", "filename": "test-cargo-miri/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fbuild.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -12,4 +12,6 @@ fn not_in_miri() -> i32 {\n fn main() {\n     not_in_miri();\n     println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=MIRITESTVAR\");\n+    println!(\"cargo:rustc-env=MIRITESTVAR=testval\");\n }"}, {"sha": "e7c341a1f0408bdb4dc3e55aa1da204a447f24dc", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -21,67 +21,88 @@ def cargo_miri(cmd):\n         args += [\"--target\", os.environ['MIRI_TEST_TARGET']]\n     return args\n \n-def test(name, cmd, stdout_ref, stderr_ref):\n-    print(\"==> Testing `{}` <==\".format(name))\n+def test(name, cmd, stdout_ref, stderr_ref, stdin=b'', env={}):\n+    print(\"Testing {}...\".format(name))\n     ## Call `cargo miri`, capture all output\n+    p_env = os.environ.copy()\n+    p_env.update(env)\n     p = subprocess.Popen(\n         cmd,\n+        stdin=subprocess.PIPE,\n         stdout=subprocess.PIPE,\n-        stderr=subprocess.PIPE\n+        stderr=subprocess.PIPE,\n+        env=p_env,\n     )\n-    (stdout, stderr) = p.communicate()\n+    (stdout, stderr) = p.communicate(input=stdin)\n     stdout = stdout.decode(\"UTF-8\")\n     stderr = stderr.decode(\"UTF-8\")\n+    if p.returncode == 0 and stdout == open(stdout_ref).read() and stderr == open(stderr_ref).read():\n+        # All good!\n+        return\n     # Show output\n-    print(\"=> captured stdout <=\")\n+    print(\"--- BEGIN stdout ---\")\n     print(stdout, end=\"\")\n-    print(\"=> captured stderr <=\")\n+    print(\"--- END stdout ---\")\n+    print(\"--- BEGIN stderr ---\")\n     print(stderr, end=\"\")\n-    # Test for failures\n-    if p.returncode != 0:\n-        fail(\"Non-zero exit status\")\n-    if stdout != open(stdout_ref).read():\n-        fail(\"stdout does not match reference\")\n-    if stderr != open(stderr_ref).read():\n-        fail(\"stderr does not match reference\")\n+    print(\"--- END stderr ---\")\n+    fail(\"exit code was {}\".format(p.returncode))\n \n def test_cargo_miri_run():\n-    test(\"cargo miri run\",\n+    test(\"`cargo miri run` (no isolation)\",\n         cargo_miri(\"run\"),\n-        \"stdout.ref\", \"stderr.ref\"\n+        \"stdout.ref1\", \"stderr.ref1\",\n+        stdin=b'12\\n21\\n',\n+        env={\n+            'MIRIFLAGS': \"-Zmiri-disable-isolation\",\n+            'MIRITESTVAR': \"wrongval\", # make sure the build.rs value takes precedence\n+        },\n     )\n-    test(\"cargo miri run (with target)\",\n-        cargo_miri(\"run\") + [\"--bin\", \"cargo-miri-test\"],\n-        \"stdout.ref\", \"stderr.ref\"\n+    test(\"`cargo miri run` (with arguments and target)\",\n+        cargo_miri(\"run\") + [\"--bin\", \"cargo-miri-test\", \"--\", \"hello world\", '\"hello world\"'],\n+        \"stdout.ref2\", \"stderr.ref2\",\n     )\n-    test(\"cargo miri run (with arguments)\",\n-        cargo_miri(\"run\") + [\"--\", \"--\", \"hello world\", '\"hello world\"'],\n-        \"stdout.ref\", \"stderr.ref2\"\n+    test(\"`cargo miri run` (subcrate, no ioslation)\",\n+        cargo_miri(\"run\") + [\"-p\", \"subcrate\"],\n+        \"stdout.ref3\", \"stderr.ref3\",\n+        env={'MIRIFLAGS': \"-Zmiri-disable-isolation\"},\n     )\n \n def test_cargo_miri_test():\n-    test(\"cargo miri test\",\n-        cargo_miri(\"test\") + [\"--\", \"-Zmiri-seed=feed\"],\n-        \"test.stdout.ref\", \"test.stderr.ref\"\n+    # rustdoc is not run on foreign targets\n+    is_foreign = 'MIRI_TEST_TARGET' in os.environ\n+    rustdoc_ref = \"test.stderr.ref2\" if is_foreign else \"test.stderr.ref1\"\n+\n+    test(\"`cargo miri test`\",\n+        cargo_miri(\"test\"),\n+        \"test.stdout.ref1\", rustdoc_ref,\n+        env={'MIRIFLAGS': \"-Zmiri-seed=feed\"},\n+    )\n+    test(\"`cargo miri test` (no isolation)\",\n+        cargo_miri(\"test\"),\n+        \"test.stdout.ref1\", rustdoc_ref,\n+        env={'MIRIFLAGS': \"-Zmiri-disable-isolation\"},\n     )\n-    test(\"cargo miri test (with filter)\",\n-        cargo_miri(\"test\") + [\"--\", \"--\", \"le1\"],\n-        \"test.stdout.ref2\", \"test.stderr.ref\"\n+    test(\"`cargo miri test` (with filter)\",\n+        cargo_miri(\"test\") + [\"--\", \"--format=pretty\", \"le1\"],\n+        \"test.stdout.ref2\", rustdoc_ref,\n     )\n-    test(\"cargo miri test (without isolation)\",\n-        cargo_miri(\"test\") + [\"--\", \"-Zmiri-disable-isolation\", \"--\", \"num_cpus\"],\n-        \"test.stdout.ref3\", \"test.stderr.ref\"\n+    test(\"`cargo miri test` (test target)\",\n+        cargo_miri(\"test\") + [\"--test\", \"test\", \"--\", \"--format=pretty\"],\n+        \"test.stdout.ref3\", \"test.stderr.ref2\",\n     )\n-    test(\"cargo miri test (test target)\",\n-        cargo_miri(\"test\") + [\"--test\", \"test\"],\n-        \"test.stdout.ref4\", \"test.stderr.ref\"\n+    test(\"`cargo miri test` (bin target)\",\n+        cargo_miri(\"test\") + [\"--bin\", \"cargo-miri-test\", \"--\", \"--format=pretty\"],\n+        \"test.stdout.ref4\", \"test.stderr.ref2\",\n     )\n-    test(\"cargo miri test (bin target)\",\n-        cargo_miri(\"test\") + [\"--bin\", \"cargo-miri-test\"],\n-        \"test.stdout.ref5\", \"test.stderr.ref\"\n+    test(\"`cargo miri test` (subcrate, no isolation)\",\n+        cargo_miri(\"test\") + [\"-p\", \"subcrate\"],\n+        \"test.stdout.ref5\", \"test.stderr.ref2\",\n+        env={'MIRIFLAGS': \"-Zmiri-disable-isolation\"},\n     )\n \n os.chdir(os.path.dirname(os.path.realpath(__file__)))\n+os.environ[\"RUST_TEST_NOCAPTURE\"] = \"0\" # this affects test output, so make sure it is not set\n \n target_str = \" for target {}\".format(os.environ['MIRI_TEST_TARGET']) if 'MIRI_TEST_TARGET' in os.environ else \"\"\n print(CGREEN + CBOLD + \"## Running `cargo miri` tests{}\".format(target_str) + CEND)"}, {"sha": "4e2c8b572c777a886afa9b0017428b5cfd9f545b", "filename": "test-cargo-miri/src/lib.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsrc%2Flib.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -0,0 +1,7 @@\n+/// Doc-test test\n+/// ```rust\n+/// assert!(cargo_miri_test::make_true());\n+/// ```\n+pub fn make_true() -> bool {\n+    true\n+}"}, {"sha": "43b507e9c9aa5763a20bbf959ea1964dbdcd8418", "filename": "test-cargo-miri/src/main.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsrc%2Fmain.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -1,6 +1,12 @@\n use byteorder::{BigEndian, ByteOrder};\n+use std::env;\n+#[cfg(unix)]\n+use std::io::{self, BufRead};\n \n fn main() {\n+    // Check env var set by `build.rs`.\n+    assert_eq!(env!(\"MIRITESTVAR\"), \"testval\");\n+\n     // Exercise external crate, printing to stdout.\n     let buf = &[1,2,3,4];\n     let n = <BigEndian as ByteOrder>::read_u32(buf);\n@@ -11,6 +17,29 @@ fn main() {\n     for arg in std::env::args() {\n         eprintln!(\"{}\", arg);\n     }\n+\n+    // If there were no arguments, access stdin and test working dir.\n+    if std::env::args().len() <= 1 {\n+        // CWD should be crate root.\n+        // We have to normalize slashes, as the env var might be set for a different target's conventions.\n+        let env_dir = env::current_dir().unwrap();\n+        let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+        let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n+        let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+        assert_eq!(env_dir, crate_dir);\n+\n+        #[cfg(unix)]\n+        for line in io::stdin().lock().lines() {\n+            let num: i32 = line.unwrap().parse().unwrap();\n+            println!(\"{}\", 2*num);\n+        }\n+        // On non-Unix, reading from stdin is not support. So we hard-code the right answer.\n+        #[cfg(not(unix))]\n+        {\n+            println!(\"24\");\n+            println!(\"42\");\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "ba2906d0666cf726c7eaadd2cd3db615dedfdf3a", "filename": "test-cargo-miri/stderr.ref1", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstderr.ref1", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstderr.ref1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstderr.ref1?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "previous_filename": "test-cargo-miri/stderr.ref"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "test-cargo-miri/stderr.ref3", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstderr.ref3", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstderr.ref3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstderr.ref3?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "previous_filename": "test-cargo-miri/test.stderr.ref"}, {"sha": "2eab8df967d5fc613a3085920c1a0cc81971da78", "filename": "test-cargo-miri/stdout.ref1", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstdout.ref1", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstdout.ref1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstdout.ref1?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -0,0 +1,3 @@\n+0x01020304\n+24\n+42"}, {"sha": "6710f307cb26daf260543237456b7d44fa2998ab", "filename": "test-cargo-miri/stdout.ref2", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstdout.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstdout.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstdout.ref2?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "previous_filename": "test-cargo-miri/stdout.ref"}, {"sha": "53340a502381d5a595671540cadf40e1a8ed2514", "filename": "test-cargo-miri/stdout.ref3", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstdout.ref3", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fstdout.ref3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstdout.ref3?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -0,0 +1 @@\n+subcrate running"}, {"sha": "78552e6aedf07315395e1dd69d8a56e6d307f042", "filename": "test-cargo-miri/subcrate/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsubcrate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsubcrate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsubcrate%2FCargo.toml?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"subcrate\"\n+version = \"0.1.0\"\n+authors = [\"Miri Team\"]\n+edition = \"2018\"\n+\n+[[bin]]\n+name = \"subcrate\"\n+path = \"main.rs\"\n+\n+[[test]]\n+name = \"subtest\"\n+path = \"test.rs\"\n+harness = false"}, {"sha": "4ce80b370722670c7b67246cf8e82744c19b34f3", "filename": "test-cargo-miri/subcrate/main.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsubcrate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsubcrate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsubcrate%2Fmain.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -0,0 +1,16 @@\n+use std::env;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    println!(\"subcrate running\");\n+\n+    // CWD should be workspace root, i.e., one level up from crate root.\n+    // We have to normalize slashes, as the env var might be set for a different target's conventions.\n+    let env_dir = env::current_dir().unwrap();\n+    let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+    let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n+    let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+    let crate_dir = PathBuf::from(crate_dir);\n+    let crate_dir = crate_dir.parent().unwrap().to_string_lossy();\n+    assert_eq!(env_dir, crate_dir);\n+}"}, {"sha": "0fd26059a1d37cedcaf10fe0af8089ba9c53568a", "filename": "test-cargo-miri/subcrate/test.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsubcrate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Fsubcrate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsubcrate%2Ftest.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -0,0 +1,13 @@\n+use std::env;\n+\n+fn main() {\n+    println!(\"subcrate testing\");\n+\n+    // CWD should be crate root.\n+    // We have to normalize slashes, as the env var might be set for a different target's conventions.\n+    let env_dir = env::current_dir().unwrap();\n+    let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+    let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n+    let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+    assert_eq!(env_dir, crate_dir);\n+}"}, {"sha": "a310169e305ee1828c2d5ae38ae37987cdb308fd", "filename": "test-cargo-miri/test.stderr.ref1", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stderr.ref1", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stderr.ref1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stderr.ref1?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -0,0 +1 @@\n+Running doctests is not currently supported by Miri."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "test-cargo-miri/test.stderr.ref2", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stderr.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stderr.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stderr.ref2?ref=ce29fbf406df9185931c61bbd662c4b613fed108"}, {"sha": "4260f5b3cb7850b8bdf76720484e5170500ebb28", "filename": "test-cargo-miri/test.stdout.ref", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/79f023eeb1e107e7345fda9cc632d67732a33df9/test-cargo-miri%2Ftest.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/79f023eeb1e107e7345fda9cc632d67732a33df9/test-cargo-miri%2Ftest.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref?ref=79f023eeb1e107e7345fda9cc632d67732a33df9", "patch": "@@ -1,18 +0,0 @@\n-\n-running 1 test\n-test test::rng ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n-\n-\n-running 7 tests\n-test do_panic ... ok\n-test does_not_work_on_miri ... ignored\n-test entropy_rng ... ok\n-test fail_index_check ... ok\n-test num_cpus ... ok\n-test simple1 ... ok\n-test simple2 ... ok\n-\n-test result: ok. 6 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n-"}, {"sha": "1eb18fe88768a258571ebd9d284a3ee1fac29c1d", "filename": "test-cargo-miri/test.stdout.ref1", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref1", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref1?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -0,0 +1,10 @@\n+\n+running 1 test\n+.\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+\n+\n+running 8 tests\n+..i.....\n+test result: ok. 7 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "d426bdf6db63254f06e1183777a466460e3749c1", "filename": "test-cargo-miri/test.stdout.ref2", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref2?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -7,5 +7,5 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n running 1 test\n test simple1 ... ok\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 6 filtered out\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 7 filtered out\n "}, {"sha": "32bbcf9bf275b8cefc82b27b4a4fab0c96827aa2", "filename": "test-cargo-miri/test.stdout.ref3", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref3", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref3?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -1,11 +1,13 @@\n \n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n-\n-\n-running 1 test\n+running 8 tests\n+test cargo_env ... ok\n+test do_panic ... ok\n+test does_not_work_on_miri ... ignored\n+test entropy_rng ... ok\n+test fail_index_check ... ok\n test num_cpus ... ok\n+test simple1 ... ok\n+test simple2 ... ok\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 6 filtered out\n+test result: ok. 7 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n "}, {"sha": "4caa30a7f0e50418166470f1e4cd074dc76c1eea", "filename": "test-cargo-miri/test.stdout.ref4", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref4", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref4?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -1,12 +1,6 @@\n \n-running 7 tests\n-test do_panic ... ok\n-test does_not_work_on_miri ... ignored\n-test entropy_rng ... ok\n-test fail_index_check ... ok\n-test num_cpus ... ok\n-test simple1 ... ok\n-test simple2 ... ok\n+running 1 test\n+test test::rng ... ok\n \n-test result: ok. 6 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "67e5c7f8e920cec3e214cc178b9652806d0b64bb", "filename": "test-cargo-miri/test.stdout.ref5", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref5", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftest.stdout.ref5", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref5?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -1,6 +1,6 @@\n \n-running 1 test\n-test test::rng ... ok\n+running 0 tests\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n \n+subcrate testing"}, {"sha": "35e05368803a6e5002809c1e9bbf6b389ef6312e", "filename": "test-cargo-miri/tests/test.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/test-cargo-miri%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftests%2Ftest.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -42,6 +42,12 @@ fn num_cpus() {\n     assert_eq!(num_cpus::get(), 1);\n }\n \n+#[test]\n+fn cargo_env() {\n+    assert_eq!(env!(\"CARGO_PKG_NAME\"), \"cargo-miri-test\");\n+    env!(\"CARGO_BIN_EXE_cargo-miri-test\"); // Asserts that this exists.\n+}\n+\n #[test]\n #[should_panic(expected=\"Explicit panic\")]\n fn do_panic() { // In large, friendly letters :)"}, {"sha": "35c1de3399c02ef51ca8a691fe3bc5a9de622cfe", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce29fbf406df9185931c61bbd662c4b613fed108/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce29fbf406df9185931c61bbd662c4b613fed108/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=ce29fbf406df9185931c61bbd662c4b613fed108", "patch": "@@ -27,7 +27,7 @@ fn run_tests(mode: &str, path: &str, target: &str) {\n     if let Ok(sysroot) = std::env::var(\"MIRI_SYSROOT\") {\n         flags.push(format!(\"--sysroot {}\", sysroot));\n     }\n-    if let Ok(extra_flags) = std::env::var(\"MIRI_TEST_FLAGS\") {\n+    if let Ok(extra_flags) = std::env::var(\"MIRIFLAGS\") {\n         flags.push(extra_flags);\n     }\n "}]}