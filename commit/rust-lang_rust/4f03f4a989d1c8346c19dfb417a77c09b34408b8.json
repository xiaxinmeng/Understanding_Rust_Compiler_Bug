{"sha": "4f03f4a989d1c8346c19dfb417a77c09b34408b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMDNmNGE5ODlkMWM4MzQ2YzE5ZGZiNDE3YTc3YzA5YjM0NDA4Yjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-12T18:02:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-12T18:02:54Z"}, "message": "Auto merge of #65608 - matthewjasper:mir-eval-order, r=pnkfelix\n\nFix MIR lowering evaluation order and soundness bug\n\n* Fixes a soundness issue with built-in index operations\n* Ensures correct evaluation order of assignment expressions where the RHS is a FRU or is a use of a local of reference type.\n* Removes an unnecessary symbol to string conversion\n\ncloses #65909\ncloses #65910", "tree": {"sha": "4481536e10d2e646822cb89f6c20b71c981129ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4481536e10d2e646822cb89f6c20b71c981129ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f03f4a989d1c8346c19dfb417a77c09b34408b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f03f4a989d1c8346c19dfb417a77c09b34408b8", "html_url": "https://github.com/rust-lang/rust/commit/4f03f4a989d1c8346c19dfb417a77c09b34408b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f03f4a989d1c8346c19dfb417a77c09b34408b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dda3ee9314cfee9c4e30a7b17dcd5ebdec081a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dda3ee9314cfee9c4e30a7b17dcd5ebdec081a7", "html_url": "https://github.com/rust-lang/rust/commit/5dda3ee9314cfee9c4e30a7b17dcd5ebdec081a7"}, {"sha": "4bf0685cca167e684340152809be20a16ad65a76", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bf0685cca167e684340152809be20a16ad65a76", "html_url": "https://github.com/rust-lang/rust/commit/4bf0685cca167e684340152809be20a16ad65a76"}], "stats": {"total": 910, "additions": 687, "deletions": 223}, "files": [{"sha": "fd2063e2da984c329d62a71ba59a86af7e17f50a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -1665,6 +1665,15 @@ pub enum FakeReadCause {\n     /// Therefore, we insert a \"fake read\" here to ensure that we get\n     /// appropriate errors.\n     ForLet,\n+\n+    /// If we have an index expression like\n+    ///\n+    /// (*x)[1][{ x = y; 4}]\n+    ///\n+    /// then the first bounds check is invalidated when we evaluate the second\n+    /// index expression. Thus we create a fake borrow of `x` across the second\n+    /// indexer, which will cause a borrow check error.\n+    ForIndex,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -1764,9 +1773,8 @@ impl_stable_hash_for!(struct Static<'tcx> {\n     def_id\n });\n \n-#[derive(\n-    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n-)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),"}, {"sha": "ebc25138a06191d452469d24d13bf59e38eb3493", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 101, "deletions": 53, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -2,9 +2,9 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc::mir::{\n-    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue,\n-    Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n+    FakeReadCause, Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef,\n+    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -380,42 +380,38 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let first_borrow_desc;\n         let mut err = match (\n             gen_borrow_kind,\n-            \"immutable\",\n-            \"mutable\",\n             issued_borrow.kind,\n-            \"immutable\",\n-            \"mutable\",\n         ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) => {\n+            (BorrowKind::Shared, BorrowKind::Mut { .. }) => {\n                 first_borrow_desc = \"mutable \";\n                 self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n-                    lft,\n+                    \"immutable\",\n                     issued_span,\n                     \"it\",\n-                    rgt,\n+                    \"mutable\",\n                     &msg_borrow,\n                     None,\n                 )\n             }\n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Shared) => {\n                 first_borrow_desc = \"immutable \";\n                 self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n-                    lft,\n+                    \"mutable\",\n                     issued_span,\n                     \"it\",\n-                    rgt,\n+                    \"immutable\",\n                     &msg_borrow,\n                     None,\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Mut { .. }) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_mutably_borrow_multiply(\n                     span,\n@@ -427,7 +423,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             }\n \n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Unique, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_uniquely_borrow_by_two_closures(\n                     span,\n@@ -437,25 +433,45 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n-            | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n-                let mut err = self.cannot_mutate_in_match_guard(\n-                    span,\n-                    issued_span,\n-                    &desc_place,\n-                    \"mutably borrow\",\n-                );\n-                borrow_spans.var_span_label(\n-                    &mut err,\n-                    format!(\n-                        \"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe()\n-                    ),\n-                );\n+            (BorrowKind::Mut { .. }, BorrowKind::Shallow)\n+            | (BorrowKind::Unique, BorrowKind::Shallow) => {\n+                if let Some(immutable_section_description) = self.classify_immutable_section(\n+                    &issued_borrow.assigned_place,\n+                ) {\n+                    let mut err = self.cannot_mutate_in_immutable_section(\n+                        span,\n+                        issued_span,\n+                        &desc_place,\n+                        immutable_section_description,\n+                        \"mutably borrow\",\n+                    );\n+                    borrow_spans.var_span_label(\n+                        &mut err,\n+                        format!(\n+                            \"borrow occurs due to use of `{}`{}\",\n+                            desc_place,\n+                            borrow_spans.describe(),\n+                        ),\n+                    );\n \n-                return err;\n+                    return err;\n+                } else {\n+                    first_borrow_desc = \"immutable \";\n+                    self.cannot_reborrow_already_borrowed(\n+                        span,\n+                        &desc_place,\n+                        &msg_place,\n+                        \"mutable\",\n+                        issued_span,\n+                        \"it\",\n+                        \"immutable\",\n+                        &msg_borrow,\n+                        None,\n+                    )\n+                }\n             }\n \n-            (BorrowKind::Unique, _, _, _, _, _) => {\n+            (BorrowKind::Unique, _) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_uniquely_borrow_by_one_closure(\n                     span,\n@@ -469,42 +485,42 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )\n             },\n \n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Shared, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     container_name,\n                     &desc_place,\n                     \"\",\n-                    lft,\n+                    \"immutable\",\n                     issued_span,\n                     \"\",\n                     None,\n                     second_borrow_desc,\n                 )\n             }\n \n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n+            (BorrowKind::Mut { .. }, BorrowKind::Unique) => {\n                 first_borrow_desc = \"first \";\n                 self.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     container_name,\n                     &desc_place,\n                     \"\",\n-                    lft,\n+                    \"mutable\",\n                     issued_span,\n                     \"\",\n                     None,\n                     second_borrow_desc,\n                 )\n             }\n \n-            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n-            | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Shared, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Shallow, _, _) => unreachable!(),\n+            (BorrowKind::Shared, BorrowKind::Shared)\n+            | (BorrowKind::Shared, BorrowKind::Shallow)\n+            | (BorrowKind::Shallow, BorrowKind::Mut { .. })\n+            | (BorrowKind::Shallow, BorrowKind::Unique)\n+            | (BorrowKind::Shallow, BorrowKind::Shared)\n+            | (BorrowKind::Shallow, BorrowKind::Shallow) => unreachable!(),\n         };\n \n         if issued_spans == borrow_spans {\n@@ -1429,20 +1445,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let loan_span = loan_spans.args_or_use();\n \n         if loan.kind == BorrowKind::Shallow {\n-            let mut err = self.cannot_mutate_in_match_guard(\n-                span,\n-                loan_span,\n-                &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n-                \"assign\",\n-            );\n-            loan_spans.var_span_label(\n-                &mut err,\n-                format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-            );\n+            if let Some(section) = self.classify_immutable_section(&loan.assigned_place) {\n+                let mut err = self.cannot_mutate_in_immutable_section(\n+                    span,\n+                    loan_span,\n+                    &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+                    section,\n+                    \"assign\",\n+                );\n+                loan_spans.var_span_label(\n+                    &mut err,\n+                    format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n+                );\n \n-            err.buffer(&mut self.errors_buffer);\n+                err.buffer(&mut self.errors_buffer);\n \n-            return;\n+                return;\n+            }\n         }\n \n         let mut err = self.cannot_assign_to_borrowed(\n@@ -1593,6 +1612,35 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    /// Describe the reason for the fake borrow that was assigned to `place`.\n+    fn classify_immutable_section(&self, place: &Place<'tcx>) -> Option<&'static str> {\n+        use rustc::mir::visit::Visitor;\n+        struct FakeReadCauseFinder<'a, 'tcx> {\n+            place: &'a Place<'tcx>,\n+            cause: Option<FakeReadCause>,\n+        }\n+        impl<'tcx> Visitor<'tcx> for FakeReadCauseFinder<'_, 'tcx> {\n+            fn visit_statement(&mut self, statement: &Statement<'tcx>, _: Location) {\n+                match statement {\n+                    Statement {\n+                        kind: StatementKind::FakeRead(cause, box ref place),\n+                        ..\n+                    } if *place == *self.place => {\n+                        self.cause = Some(*cause);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+        let mut visitor = FakeReadCauseFinder { place, cause: None };\n+        visitor.visit_body(&self.body);\n+        match visitor.cause {\n+            Some(FakeReadCause::ForMatchGuard) => Some(\"match guard\"),\n+            Some(FakeReadCause::ForIndex) => Some(\"indexing expression\"),\n+            _ => None,\n+        }\n+    }\n+\n     /// Annotate argument and return type of function and closure with (synthesized) lifetime for\n     /// borrow of local value that does not live long enough.\n     fn annotate_argument_and_return_for_borrow("}, {"sha": "d3e013acc9e3a8ed17fee81e8beb06aa97b0f4cc", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 252, "deletions": 51, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -4,9 +4,11 @@ use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n+use rustc::middle::region;\n use rustc::mir::interpret::{PanicInfo::BoundsCheck};\n use rustc::mir::*;\n-use rustc::ty::{CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n+use syntax_pos::Span;\n \n use rustc_index::vec::Idx;\n \n@@ -68,6 +70,17 @@ impl From<PlaceBase<'tcx>> for PlaceBuilder<'tcx> {\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a place that we can move from etc.\n+    ///\n+    /// WARNING: Any user code might:\n+    /// * Invalidate any slice bounds checks performed.\n+    /// * Change the address that this `Place` refers to.\n+    /// * Modify the memory that this place refers to.\n+    /// * Invalidate the memory that this place refers to, this will be caught\n+    ///   by borrow checking.\n+    ///\n+    /// Extra care is needed if any user code is allowed to run between calling\n+    /// this method and using it, as is the case for `match` and index\n+    /// expressions.\n     pub fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n@@ -83,7 +96,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_place(block, expr, Mutability::Mut)\n+        self.expr_as_place(block, expr, Mutability::Mut, None)\n     }\n \n     /// Compile `expr`, yielding a place that we can move from etc.\n@@ -114,14 +127,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_place(block, expr, Mutability::Not)\n+        self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n         mutability: Mutability,\n+        fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         debug!(\n             \"expr_as_place(block={:?}, expr={:?}, mutability={:?})\",\n@@ -137,63 +151,40 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 lint_level,\n                 value,\n             } => this.in_scope((region_scope, source_info), lint_level, |this| {\n-                if mutability == Mutability::Not {\n-                    this.as_read_only_place_builder(block, value)\n-                } else {\n-                    this.as_place_builder(block, value)\n-                }\n+                let value = this.hir.mirror(value);\n+                this.expr_as_place(block, value, mutability, fake_borrow_temps)\n             }),\n             ExprKind::Field { lhs, name } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n+                let lhs = this.hir.mirror(lhs);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    lhs,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 block.and(place_builder.field(name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, arg));\n+                let arg = this.hir.mirror(arg);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    arg,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 block.and(place_builder.deref())\n             }\n             ExprKind::Index { lhs, index } => {\n-                let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n-\n-                let place_builder = unpack!(block = this.as_place_builder(block, lhs));\n-                // Making this a *fresh* temporary also means we do not have to worry about\n-                // the index changing later: Nothing will ever change this temporary.\n-                // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n-                let idx = unpack!(block = this.as_temp(\n+                this.lower_index_expression(\n                     block,\n-                    expr.temp_lifetime,\n+                    lhs,\n                     index,\n-                    Mutability::Not,\n-                ));\n-\n-                let slice = place_builder.clone().into_place(this.hir.tcx());\n-                // bounds check:\n-                let (len, lt) = (\n-                    this.temp(usize_ty.clone(), expr_span),\n-                    this.temp(bool_ty, expr_span),\n-                );\n-                this.cfg.push_assign(\n-                    block,\n-                    source_info, // len = len(slice)\n-                    &len,\n-                    Rvalue::Len(slice),\n-                );\n-                this.cfg.push_assign(\n-                    block,\n-                    source_info, // lt = idx < len\n-                    &lt,\n-                    Rvalue::BinaryOp(\n-                        BinOp::Lt,\n-                        Operand::Copy(Place::from(idx)),\n-                        Operand::Copy(len.clone()),\n-                    ),\n-                );\n-\n-                let msg = BoundsCheck {\n-                    len: Operand::Move(len),\n-                    index: Operand::Copy(Place::from(idx)),\n-                };\n-                let success = this.assert(block, Operand::Move(lt), true, msg, expr_span);\n-                success.and(place_builder.index(idx))\n+                    mutability,\n+                    fake_borrow_temps,\n+                    expr.temp_lifetime,\n+                    expr_span,\n+                    source_info,\n+                )\n             }\n             ExprKind::SelfRef => block.and(PlaceBuilder::from(Local::new(1))),\n             ExprKind::VarRef { id } => {\n@@ -215,7 +206,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             )),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n-                let place_builder = unpack!(block = this.as_place_builder(block, source));\n+                let source = this.hir.mirror(source);\n+                let place_builder = unpack!(block = this.expr_as_place(\n+                    block,\n+                    source,\n+                    mutability,\n+                    fake_borrow_temps,\n+                ));\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index = this.canonical_user_type_annotations.push(\n                         CanonicalUserTypeAnnotation {\n@@ -309,4 +306,208 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    /// Lower an index expression\n+    ///\n+    /// This has two complications;\n+    ///\n+    /// * We need to do a bounds check.\n+    /// * We need to ensure that the bounds check can't be invalidated using an\n+    ///   expression like `x[1][{x = y; 2}]`. We use fake borrows here to ensure\n+    ///   that this is the case.\n+    fn lower_index_expression(\n+        &mut self,\n+        mut block: BasicBlock,\n+        base: ExprRef<'tcx>,\n+        index: ExprRef<'tcx>,\n+        mutability: Mutability,\n+        fake_borrow_temps: Option<&mut Vec<Local>>,\n+        temp_lifetime: Option<region::Scope>,\n+        expr_span: Span,\n+        source_info: SourceInfo\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n+        let lhs = self.hir.mirror(base);\n+\n+        let base_fake_borrow_temps = &mut Vec::new();\n+        let is_outermost_index = fake_borrow_temps.is_none();\n+        let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n+\n+        let base_place = unpack!(block = self.expr_as_place(\n+            block,\n+            lhs,\n+            mutability,\n+            Some(fake_borrow_temps),\n+        ));\n+\n+        // Making this a *fresh* temporary means we do not have to worry about\n+        // the index changing later: Nothing will ever change this temporary.\n+        // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n+        let idx = unpack!(block = self.as_temp(\n+            block,\n+            temp_lifetime,\n+            index,\n+            Mutability::Not,\n+        ));\n+\n+        block = self.bounds_check(\n+            block,\n+            base_place.clone().into_place(self.hir.tcx()),\n+            idx,\n+            expr_span,\n+            source_info,\n+        );\n+\n+        if is_outermost_index {\n+            self.read_fake_borrows(block, fake_borrow_temps, source_info)\n+        } else {\n+            self.add_fake_borrows_of_base(\n+                &base_place,\n+                block,\n+                fake_borrow_temps,\n+                expr_span,\n+                source_info,\n+            );\n+        }\n+\n+        block.and(base_place.index(idx))\n+    }\n+\n+    fn bounds_check(\n+        &mut self,\n+        block: BasicBlock,\n+        slice: Place<'tcx>,\n+        index: Local,\n+        expr_span: Span,\n+        source_info: SourceInfo,\n+    ) -> BasicBlock {\n+        let usize_ty = self.hir.usize_ty();\n+        let bool_ty = self.hir.bool_ty();\n+        // bounds check:\n+        let len = self.temp(usize_ty, expr_span);\n+        let lt = self.temp(bool_ty, expr_span);\n+\n+        // len = len(slice)\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            &len,\n+            Rvalue::Len(slice),\n+        );\n+        // lt = idx < len\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            &lt,\n+            Rvalue::BinaryOp(\n+                BinOp::Lt,\n+                Operand::Copy(Place::from(index)),\n+                Operand::Copy(len.clone()),\n+            ),\n+        );\n+        let msg = BoundsCheck {\n+            len: Operand::Move(len),\n+            index: Operand::Copy(Place::from(index)),\n+        };\n+        // assert!(lt, \"...\")\n+        self.assert(block, Operand::Move(lt), true, msg, expr_span)\n+    }\n+\n+    fn add_fake_borrows_of_base(\n+        &mut self,\n+        base_place: &PlaceBuilder<'tcx>,\n+        block: BasicBlock,\n+        fake_borrow_temps: &mut Vec<Local>,\n+        expr_span: Span,\n+        source_info: SourceInfo,\n+    ) {\n+        let tcx = self.hir.tcx();\n+        let place_ty = Place::ty_from(\n+            &base_place.base,\n+            &base_place.projection,\n+            &self.local_decls,\n+            tcx,\n+        );\n+        if let ty::Slice(_) = place_ty.ty.kind {\n+            // We need to create fake borrows to ensure that the bounds\n+            // check that we just did stays valid. Since we can't assign to\n+            // unsized values, we only need to ensure that none of the\n+            // pointers in the base place are modified.\n+            for (idx, elem) in base_place.projection.iter().enumerate().rev() {\n+                match elem {\n+                    ProjectionElem::Deref => {\n+                        let fake_borrow_deref_ty = Place::ty_from(\n+                            &base_place.base,\n+                            &base_place.projection[..idx],\n+                            &self.local_decls,\n+                            tcx,\n+                        ).ty;\n+                        let fake_borrow_ty = tcx.mk_imm_ref(\n+                            tcx.lifetimes.re_erased,\n+                            fake_borrow_deref_ty,\n+                        );\n+                        let fake_borrow_temp = self.local_decls.push(\n+                            LocalDecl::new_temp(fake_borrow_ty, expr_span)\n+                        );\n+                        let projection = tcx.intern_place_elems(&base_place.projection[..idx]);\n+                        self.cfg.push_assign(\n+                            block,\n+                            source_info,\n+                            &fake_borrow_temp.into(),\n+                            Rvalue::Ref(\n+                                tcx.lifetimes.re_erased,\n+                                BorrowKind::Shallow,\n+                                Place {\n+                                    base: base_place.base.clone(),\n+                                    projection,\n+                                }\n+                            ),\n+                        );\n+                        fake_borrow_temps.push(fake_borrow_temp);\n+                    }\n+                    ProjectionElem::Index(_) => {\n+                        let index_ty = Place::ty_from(\n+                            &base_place.base,\n+                            &base_place.projection[..idx],\n+                            &self.local_decls,\n+                            tcx,\n+                        );\n+                        match index_ty.ty.kind {\n+                            // The previous index expression has already\n+                            // done any index expressions needed here.\n+                            ty::Slice(_) => break,\n+                            ty::Array(..) => (),\n+                            _ => bug!(\"unexpected index base\"),\n+                        }\n+                    }\n+                    ProjectionElem::Field(..)\n+                    | ProjectionElem::Downcast(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. } => (),\n+                }\n+            }\n+        }\n+    }\n+\n+    fn read_fake_borrows(\n+        &mut self,\n+        block: BasicBlock,\n+        fake_borrow_temps: &mut Vec<Local>,\n+        source_info: SourceInfo,\n+    ) {\n+        // All indexes have been evaluated now, read all of the\n+        // fake borrows so that they are live across those index\n+        // expressions.\n+        for temp in fake_borrow_temps {\n+            self.cfg.push(\n+                block,\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::FakeRead(\n+                        FakeReadCause::ForIndex,\n+                        Box::new(Place::from(*temp)),\n+                    )\n+                }\n+            );\n+        }\n+    }\n }"}, {"sha": "f9b77a4b5dd2adcc52320aa57841ed895d013084", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 10, "deletions": 85, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -1,6 +1,5 @@\n //! See docs in `build/expr/mod.rs`.\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n \n use crate::build::expr::category::{Category, RvalueFunc};\n@@ -9,11 +8,16 @@ use crate::hair::*;\n use rustc::middle::region;\n use rustc::mir::interpret::PanicInfo;\n use rustc::mir::*;\n-use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, UpvarSubsts};\n+use rustc::ty::{self, Ty, UpvarSubsts};\n use syntax_pos::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    /// See comment on `as_local_operand`\n+    /// Returns an rvalue suitable for use until the end of the current\n+    /// scope expression.\n+    ///\n+    /// The operand returned from this function will *not be valid* after\n+    /// an ExprKind::Scope is passed, so please do *not* return it from\n+    /// functions to avoid bad miscompiles.\n     pub fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n@@ -23,7 +27,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(\n+    fn as_rvalue<M>(\n         &mut self,\n         block: BasicBlock,\n         scope: Option<region::Scope>,\n@@ -66,16 +70,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let value_operand = unpack!(block = this.as_operand(block, scope, value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n-            ExprKind::Borrow {\n-                borrow_kind,\n-                arg,\n-            } => {\n-                let arg_place = match borrow_kind {\n-                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n-                    _ => unpack!(block = this.as_place(block, arg)),\n-                };\n-                block.and(Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place))\n-            }\n             ExprKind::Binary { op, lhs, rhs } => {\n                 let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n                 let rhs = unpack!(block = this.as_operand(block, scope, rhs));\n@@ -256,77 +250,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n                 block.and(Rvalue::Aggregate(result, operands))\n             }\n-            ExprKind::Adt {\n-                adt_def,\n-                variant_index,\n-                substs,\n-                user_ty,\n-                fields,\n-                base,\n-            } => {\n-                // see (*) above\n-                let is_union = adt_def.is_union();\n-                let active_field_index = if is_union {\n-                    Some(fields[0].name.index())\n-                } else {\n-                    None\n-                };\n-\n-                // first process the set of fields that were provided\n-                // (evaluating them in order given by user)\n-                let fields_map: FxHashMap<_, _> = fields\n-                    .into_iter()\n-                    .map(|f| {\n-                        (\n-                            f.name,\n-                            unpack!(block = this.as_operand(block, scope, f.expr)),\n-                        )\n-                    }).collect();\n-\n-                let field_names = this.hir.all_fields(adt_def, variant_index);\n-\n-                let fields = if let Some(FruInfo { base, field_types }) = base {\n-                    let base = unpack!(block = this.as_place(block, base));\n-\n-                    // MIR does not natively support FRU, so for each\n-                    // base-supplied field, generate an operand that\n-                    // reads it from the base.\n-                    field_names\n-                        .into_iter()\n-                        .zip(field_types.into_iter())\n-                        .map(|(n, ty)| match fields_map.get(&n) {\n-                            Some(v) => v.clone(),\n-                            None => this.consume_by_copy_or_move(this.hir.tcx().mk_place_field(\n-                                base.clone(),\n-                                n,\n-                                ty,\n-                            )),\n-                        })\n-                        .collect()\n-                } else {\n-                    field_names\n-                        .iter()\n-                        .filter_map(|n| fields_map.get(n).cloned())\n-                        .collect()\n-                };\n-\n-                let inferred_ty = expr.ty;\n-                let user_ty = user_ty.map(|ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span: source_info.span,\n-                        user_ty: ty,\n-                        inferred_ty,\n-                    })\n-                });\n-                let adt = box AggregateKind::Adt(\n-                    adt_def,\n-                    variant_index,\n-                    substs,\n-                    user_ty,\n-                    active_field_index,\n-                );\n-                block.and(Rvalue::Aggregate(adt, fields))\n-            }\n             ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n                 block = unpack!(this.stmt_expr(block, expr, None));\n                 block.and(this.unit_rvalue())\n@@ -351,6 +274,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n+            | ExprKind::Borrow { .. }\n+            | ExprKind::Adt { .. }\n             | ExprKind::Loop { .. }\n             | ExprKind::LogicalOp { .. }\n             | ExprKind::Call { .. }"}, {"sha": "ae5289986e77cc537ccdef36cbca6e615950a892", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -48,19 +48,19 @@ impl Category {\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n+            | ExprKind::Adt { .. }\n+            | ExprKind::Borrow { .. }\n             | ExprKind::Call { .. } => Some(Category::Rvalue(RvalueFunc::Into)),\n \n             ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }\n-            | ExprKind::Adt { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Unary { .. }\n             | ExprKind::Binary { .. }\n             | ExprKind::Box { .. }\n             | ExprKind::Cast { .. }\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n-            | ExprKind::Borrow { .. }\n             | ExprKind::Assign { .. }\n             | ExprKind::AssignOp { .. }\n             | ExprKind::Yield { .. }"}, {"sha": "404ca3204e6c0038ade679a506ecea8215c1ea78", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 101, "deletions": 6, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -4,7 +4,9 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::hair::*;\n use rustc::mir::*;\n-use rustc::ty;\n+use rustc::ty::{self, CanonicalUserTypeAnnotation};\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax_pos::symbol::sym;\n \n use rustc_target::spec::abi::Abi;\n \n@@ -200,16 +202,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     ty::FnDef(def_id, _) => {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n-                            Some(this.hir.tcx().item_name(def_id).as_str())\n+                            Some(this.hir.tcx().item_name(def_id))\n                         } else {\n                             None\n                         }\n                     }\n                     _ => None,\n                 };\n-                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n                 let fun = unpack!(block = this.as_local_operand(block, fun));\n-                if intrinsic == Some(\"move_val_init\") {\n+                if let Some(sym::move_val_init) = intrinsic {\n                     // `move_val_init` has \"magic\" semantics - the second argument is\n                     // always evaluated \"directly\" into the first one.\n \n@@ -271,6 +272,102 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Use { source } => {\n                 this.into(destination, block, source)\n             }\n+            ExprKind::Borrow { arg, borrow_kind } => {\n+                // We don't do this in `as_rvalue` because we use `as_place`\n+                // for borrow expressions, so we cannot create an `RValue` that\n+                // remains valid across user code. `as_rvalue` is usually called\n+                // by this method anyway, so this shouldn't cause too many\n+                // unnecessary temporaries.\n+                let arg_place = match borrow_kind {\n+                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n+                    _ => unpack!(block = this.as_place(block, arg)),\n+                };\n+                let borrow = Rvalue::Ref(\n+                    this.hir.tcx().lifetimes.re_erased,\n+                    borrow_kind,\n+                    arg_place,\n+                );\n+                this.cfg.push_assign(block, source_info, destination, borrow);\n+                block.unit()\n+            }\n+            ExprKind::Adt {\n+                adt_def,\n+                variant_index,\n+                substs,\n+                user_ty,\n+                fields,\n+                base,\n+            } => {\n+                // See the notes for `ExprKind::Array` in `as_rvalue` and for\n+                // `ExprKind::Borrow` above.\n+                let is_union = adt_def.is_union();\n+                let active_field_index = if is_union {\n+                    Some(fields[0].name.index())\n+                } else {\n+                    None\n+                };\n+\n+                let scope =  this.local_scope();\n+\n+                // first process the set of fields that were provided\n+                // (evaluating them in order given by user)\n+                let fields_map: FxHashMap<_, _> = fields\n+                    .into_iter()\n+                    .map(|f| {\n+                        (\n+                            f.name,\n+                            unpack!(block = this.as_operand(block, scope, f.expr)),\n+                        )\n+                    }).collect();\n+\n+                let field_names = this.hir.all_fields(adt_def, variant_index);\n+\n+                let fields = if let Some(FruInfo { base, field_types }) = base {\n+                    let base = unpack!(block = this.as_place(block, base));\n+\n+                    // MIR does not natively support FRU, so for each\n+                    // base-supplied field, generate an operand that\n+                    // reads it from the base.\n+                    field_names\n+                        .into_iter()\n+                        .zip(field_types.into_iter())\n+                        .map(|(n, ty)| match fields_map.get(&n) {\n+                            Some(v) => v.clone(),\n+                            None => this.consume_by_copy_or_move(\n+                                this.hir.tcx().mk_place_field(base.clone(), n, ty),\n+                            ),\n+                        }).collect()\n+                } else {\n+                    field_names\n+                        .iter()\n+                        .filter_map(|n| fields_map.get(n).cloned())\n+                        .collect()\n+                };\n+\n+                let inferred_ty = expr.ty;\n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+                        span: source_info.span,\n+                        user_ty: ty,\n+                        inferred_ty,\n+                    })\n+                });\n+                let adt = box AggregateKind::Adt(\n+                    adt_def,\n+                    variant_index,\n+                    substs,\n+                    user_ty,\n+                    active_field_index,\n+                );\n+                this.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    destination,\n+                    Rvalue::Aggregate(adt, fields)\n+                );\n+                block.unit()\n+            }\n+\n \n             // These cases don't actually need a destination\n             ExprKind::Assign { .. }\n@@ -325,10 +422,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Cast { .. }\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n-            | ExprKind::Borrow { .. }\n             | ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }\n-            | ExprKind::Adt { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Literal { .. }\n             | ExprKind::Yield { .. } => {"}, {"sha": "bf01ad1a0236f917ba9d04d96f9c3b3b8f5a4ec4", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -395,23 +395,25 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn cannot_mutate_in_match_guard(\n+    crate fn cannot_mutate_in_immutable_section(\n         &self,\n         mutate_span: Span,\n-        match_span: Span,\n-        match_place: &str,\n+        immutable_span: Span,\n+        immutable_place: &str,\n+        immutable_section: &str,\n         action: &str,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             mutate_span,\n             E0510,\n-            \"cannot {} `{}` in match guard\",\n+            \"cannot {} `{}` in {}\",\n             action,\n-            match_place,\n+            immutable_place,\n+            immutable_section,\n         );\n         err.span_label(mutate_span, format!(\"cannot {}\", action));\n-        err.span_label(match_span, String::from(\"value is immutable in match guard\"));\n+        err.span_label(immutable_span, format!(\"value is immutable in {}\", immutable_section));\n         err\n     }\n "}, {"sha": "b3e9576f43f59f9de2ef7e46677302b76571e921", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -432,6 +432,7 @@ symbols! {\n         module,\n         module_path,\n         more_struct_aliases,\n+        move_val_init,\n         movbe_target_feature,\n         must_use,\n         naked,"}, {"sha": "5dc15286bab50625cfab315cb5e3b696ae93878c", "filename": "src/test/mir-opt/storage_live_dead_in_statics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -36,11 +36,11 @@ fn main() {\n // END RUST SOURCE\n // START rustc.XXX.mir_map.0.mir\n //    let mut _0: &'static Foo;\n-//    let mut _1: &'static Foo;\n+//    let _1: &'static Foo;\n //    let _2: Foo;\n //    let mut _3: &'static [(u32, u32)];\n //    let mut _4: &'static [(u32, u32); 42];\n-//    let mut _5: &'static [(u32, u32); 42];\n+//    let _5: &'static [(u32, u32); 42];\n //    let _6: [(u32, u32); 42];\n //    let mut _7: (u32, u32);\n //    let mut _8: (u32, u32);"}, {"sha": "aa56918a9b8c12c7c49d8bbac1c5c878e7b0e981", "filename": "src/test/mir-opt/uninhabited_enum_branching.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -34,12 +34,12 @@ fn main() {\n // let _1: &str;\n // let mut _2: Test1;\n // let mut _3: isize;\n-// let mut _4: &str;\n-// let mut _5: &str;\n+// let _4: &str;\n+// let _5: &str;\n // let _6: &str;\n // let mut _7: Test2;\n // let mut _8: isize;\n-// let mut _9: &str;\n+// let _9: &str;\n // bb0: {\n //   StorageLive(_1);\n //   StorageLive(_2);\n@@ -103,12 +103,12 @@ fn main() {\n // let _1: &str;\n // let mut _2: Test1;\n // let mut _3: isize;\n-// let mut _4: &str;\n-// let mut _5: &str;\n+// let _4: &str;\n+// let _5: &str;\n // let _6: &str;\n // let mut _7: Test2;\n // let mut _8: isize;\n-// let mut _9: &str;\n+// let _9: &str;\n // bb0: {\n //   StorageLive(_1);\n //   StorageLive(_2);\n@@ -172,12 +172,12 @@ fn main() {\n // let _1: &str;\n // let mut _2: Test1;\n // let mut _3: isize;\n-// let mut _4: &str;\n-// let mut _5: &str;\n+// let _4: &str;\n+// let _5: &str;\n // let _6: &str;\n // let mut _7: Test2;\n // let mut _8: isize;\n-// let mut _9: &str;\n+// let _9: &str;\n // bb0: {\n //   StorageLive(_1);\n //   StorageLive(_2);"}, {"sha": "f01afe1466aef7564c2e971c7e592b6044757b81", "filename": "src/test/ui/borrowck/borrowck-init-in-fru.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.stderr?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -1,8 +1,8 @@\n error[E0381]: use of possibly-uninitialized variable: `origin`\n-  --> $DIR/borrowck-init-in-fru.rs:9:5\n+  --> $DIR/borrowck-init-in-fru.rs:9:14\n    |\n LL |     origin = Point { x: 10, ..origin };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ use of possibly-uninitialized `origin.y`\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ use of possibly-uninitialized `origin.y`\n \n error: aborting due to previous error\n "}, {"sha": "0e0e3cda6e2edbf6580ac7fc3a3a8a71a187660f", "filename": "src/test/ui/borrowck/slice-index-bounds-check-invalidation.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -0,0 +1,82 @@\n+// Test that we error if a slice is modified after it has been bounds checked\n+// and before we actually index it.\n+\n+fn modify_before_assert_slice_slice(x: &[&[i32]]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32] = &[1, 2, 3];\n+    let y: &[&[i32]] = &[z];\n+    x[{ x = y; 0 }][2]              // OK we haven't checked any bounds before we index `x`.\n+}\n+\n+fn modify_before_assert_array_slice(x: &[&[i32]; 3]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32] = &[1, 2, 3];\n+    let y: &[&[i32]; 3] = &[z, z, z];\n+    x[{ x = y; 0 }][2]              // OK we haven't checked any bounds before we index `x`.\n+}\n+\n+fn modify_before_assert_slice_array(x: &[&[i32; 3]]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32; 3] = &[1, 2, 3];\n+    let y: &[&[i32; 3]] = &[z];\n+    x[{ x = y; 0 }][2]              // OK we haven't checked any bounds before we index `x`.\n+}\n+\n+fn modify_before_assert_array_array(x: &[&[i32; 3]; 3]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32; 3] = &[1, 2, 3];\n+    let y: &[&[i32; 3]; 3] = &[z, z, z];\n+    x[{ x = y; 0 }][2]              // OK we haven't checked any bounds before we index `x`.\n+}\n+\n+fn modify_after_assert_slice_slice(x: &[&[i32]]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32] = &[1, 2, 3];\n+    let y: &[&[i32]] = &[&z];\n+    x[1][{ x = y; 2}]               //~ ERROR cannot assign `x` in indexing expression\n+}\n+\n+fn modify_after_assert_array_slice(x: &[&[i32]; 1]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32] = &[1, 2, 3];\n+    let y: &[&[i32]; 1] = &[&z];\n+    x[0][{ x = y; 2}]               // OK cannot invalidate a fixed-size array bounds check\n+}\n+\n+fn modify_after_assert_slice_array(x: &[&[i32; 3]]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32; 3] = &[1, 2, 3];\n+    let y: &[&[i32; 3]] = &[&z];\n+    x[1][{ x = y; 2}]               //~ ERROR cannot assign `x` in indexing expression\n+}\n+\n+fn modify_after_assert_array_array(x: &[&[i32; 3]; 1]) -> i32 {\n+    let mut x = x;\n+    let z: &[i32; 3] = &[1, 2, 3];\n+    let y: &[&[i32; 3]; 1] = &[&z];\n+    x[0][{ x = y; 2}]               // OK cannot invalidate a fixed-size array bounds check\n+}\n+\n+fn modify_after_assert_slice_slice_array(x: &[&[[i32; 1]]]) -> i32 {\n+    let mut x = x;\n+    let z: &[[i32; 1]] = &[[1], [2], [3]];\n+    let y: &[&[[i32; 1]]] = &[&z];\n+    x[1][{ x = y; 2}][0]            //~ ERROR cannot assign `x` in indexing expression\n+}\n+\n+fn modify_after_assert_slice_slice_slice(x: &[&[&[i32]]]) -> i32 {\n+    let mut x = x;\n+    let z: &[&[i32]] = &[&[1], &[2], &[3]];\n+    let y: &[&[&[i32]]] = &[z];\n+    x[1][{ x = y; 2}][0]            //~ ERROR cannot assign `x` in indexing expression\n+}\n+\n+\n+fn main() {\n+    println!(\"{}\", modify_after_assert_slice_array(&[&[4, 5, 6], &[9, 10, 11]]));\n+    println!(\"{}\", modify_after_assert_slice_slice(&[&[4, 5, 6], &[9, 10, 11]]));\n+    println!(\"{}\", modify_after_assert_slice_slice_array(&[&[[4], [5], [6]], &[[9], [10], [11]]]));\n+    println!(\"{}\", modify_after_assert_slice_slice_slice(\n+        &[&[&[4], &[5], &[6]], &[&[9], &[10], &[11]]]),\n+    );\n+}"}, {"sha": "f9ed16f19cd69f4723a36c373ab0df698d04cef6", "filename": "src/test/ui/borrowck/slice-index-bounds-check-invalidation.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fslice-index-bounds-check-invalidation.stderr?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -0,0 +1,35 @@\n+error[E0510]: cannot assign `x` in indexing expression\n+  --> $DIR/slice-index-bounds-check-invalidation.rs:36:12\n+   |\n+LL |     x[1][{ x = y; 2}]\n+   |     ----   ^^^^^ cannot assign\n+   |     |\n+   |     value is immutable in indexing expression\n+\n+error[E0510]: cannot assign `x` in indexing expression\n+  --> $DIR/slice-index-bounds-check-invalidation.rs:50:12\n+   |\n+LL |     x[1][{ x = y; 2}]\n+   |     ----   ^^^^^ cannot assign\n+   |     |\n+   |     value is immutable in indexing expression\n+\n+error[E0510]: cannot assign `x` in indexing expression\n+  --> $DIR/slice-index-bounds-check-invalidation.rs:64:12\n+   |\n+LL |     x[1][{ x = y; 2}][0]\n+   |     ----   ^^^^^ cannot assign\n+   |     |\n+   |     value is immutable in indexing expression\n+\n+error[E0510]: cannot assign `x` in indexing expression\n+  --> $DIR/slice-index-bounds-check-invalidation.rs:71:12\n+   |\n+LL |     x[1][{ x = y; 2}][0]\n+   |     ----   ^^^^^ cannot assign\n+   |     |\n+   |     value is immutable in indexing expression\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0510`."}, {"sha": "1594421b0b13b01a12757f387a833c3f4e557ab9", "filename": "src/test/ui/mir/mir_assign_eval_order.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fmir%2Fmir_assign_eval_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fmir%2Fmir_assign_eval_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_assign_eval_order.rs?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -0,0 +1,67 @@\n+// Test evaluation order of assignment expressions is right to left.\n+\n+// run-pass\n+\n+// We would previously not finish evaluating borrow and FRU expressions before\n+// starting on the LHS\n+\n+struct S(i32);\n+\n+fn evaluate_reborrow_before_assign() {\n+    let mut x = &1;\n+    let y = &mut &2;\n+    let z = &3;\n+    // There's an implicit reborrow of `x` on the right-hand side of the\n+    // assignement. Note that writing an explicit reborrow would not show this\n+    // bug, as now there would be two reborrows on the right-hand side and at\n+    // least one of them would happen before the left-hand side is evaluated.\n+    *{ x = z; &mut *y } = x;\n+    assert_eq!(*x, 3);\n+    assert_eq!(**y, 1);             // y should be assigned the original value of `x`.\n+}\n+\n+fn evaluate_mut_reborrow_before_assign() {\n+    let mut x = &mut 1;\n+    let y = &mut &mut 2;\n+    let z = &mut 3;\n+    *{ x = z; &mut *y } = x;\n+    assert_eq!(*x, 3);\n+    assert_eq!(**y, 1);            // y should be assigned the original value of `x`.\n+}\n+\n+// We should evaluate `x[2]` and borrow the value out *before* evaluating the\n+// LHS and changing its value.\n+fn evaluate_ref_to_temp_before_assign_slice() {\n+    let mut x = &[S(0), S(1), S(2)][..];\n+    let y = &mut &S(7);\n+    *{ x = &[S(3), S(4), S(5)]; &mut *y } = &x[2];\n+    assert_eq!(2, y.0);\n+    assert_eq!(5, x[2].0);\n+}\n+\n+// We should evaluate `x[2]` and copy the value out *before* evaluating the LHS\n+// and changing its value.\n+fn evaluate_fru_to_temp_before_assign_slice() {\n+    let mut x = &[S(0), S(1), S(2)][..];\n+    let y = &mut S(7);\n+    *{ x = &[S(3), S(4), S(5)]; &mut *y } = S { ..x[2] };\n+    assert_eq!(2, y.0);\n+    assert_eq!(5, x[2].0);\n+}\n+\n+// We should evaluate `*x` and copy the value out *before* evaluating the LHS\n+// and dropping `x`.\n+fn evaluate_fru_to_temp_before_assign_box() {\n+    let x = Box::new(S(0));\n+    let y = &mut S(1);\n+    *{ drop(x); &mut *y } = S { ..*x };\n+    assert_eq!(0, y.0);\n+}\n+\n+fn main() {\n+    evaluate_reborrow_before_assign();\n+    evaluate_mut_reborrow_before_assign();\n+    evaluate_ref_to_temp_before_assign_slice();\n+    evaluate_fru_to_temp_before_assign_slice();\n+    evaluate_fru_to_temp_before_assign_box();\n+}"}, {"sha": "cef4aba02403717020e7e7b8e8d8db55196a3640", "filename": "src/test/ui/nll/issue-52534-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -1,8 +1,8 @@\n error[E0597]: `x` does not live long enough\n-  --> $DIR/issue-52534-2.rs:6:9\n+  --> $DIR/issue-52534-2.rs:6:13\n    |\n LL |         y = &x\n-   |         ^^^^^^ borrowed value does not live long enough\n+   |             ^^ borrowed value does not live long enough\n LL |\n LL |     }\n    |     - `x` dropped here while still borrowed"}, {"sha": "0939584380af9c8ece730f97336edc5f502ae178", "filename": "src/test/ui/span/issue-36537.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fspan%2Fissue-36537.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f4a989d1c8346c19dfb417a77c09b34408b8/src%2Ftest%2Fui%2Fspan%2Fissue-36537.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36537.stderr?ref=4f03f4a989d1c8346c19dfb417a77c09b34408b8", "patch": "@@ -1,8 +1,8 @@\n error[E0597]: `a` does not live long enough\n-  --> $DIR/issue-36537.rs:5:9\n+  --> $DIR/issue-36537.rs:5:13\n    |\n LL |         p = &a;\n-   |         ^^^^^^ borrowed value does not live long enough\n+   |             ^^ borrowed value does not live long enough\n ...\n LL |     }\n    |     - `a` dropped here while still borrowed"}]}