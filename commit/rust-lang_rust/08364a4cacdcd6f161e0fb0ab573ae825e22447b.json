{"sha": "08364a4cacdcd6f161e0fb0ab573ae825e22447b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MzY0YTRjYWNkY2Q2ZjE2MWUwZmIwYWI1NzNhZTgyNWUyMjQ0N2I=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-26T00:35:25Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-26T04:07:33Z"}, "message": "Optimise a particularly clown shoes example of DST codegen", "tree": {"sha": "3c0a9708e980dc2384a51d7397a5b2d3865c5cdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c0a9708e980dc2384a51d7397a5b2d3865c5cdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08364a4cacdcd6f161e0fb0ab573ae825e22447b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08364a4cacdcd6f161e0fb0ab573ae825e22447b", "html_url": "https://github.com/rust-lang/rust/commit/08364a4cacdcd6f161e0fb0ab573ae825e22447b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08364a4cacdcd6f161e0fb0ab573ae825e22447b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52ef46251ede1ff51e5d5621d5fe2614e950f963", "url": "https://api.github.com/repos/rust-lang/rust/commits/52ef46251ede1ff51e5d5621d5fe2614e950f963", "html_url": "https://github.com/rust-lang/rust/commit/52ef46251ede1ff51e5d5621d5fe2614e950f963"}], "stats": {"total": 46, "additions": 34, "deletions": 12}, "files": [{"sha": "c49bb7f4e6b9d0197f9a9a3fcd7b9f7c5be07c9a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/08364a4cacdcd6f161e0fb0ab573ae825e22447b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08364a4cacdcd6f161e0fb0ab573ae825e22447b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=08364a4cacdcd6f161e0fb0ab573ae825e22447b", "patch": "@@ -193,24 +193,46 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n         }\n         AutoDerefRef(ref adj) => {\n-            // Extracting a value from a box counts as a deref, but if we are\n-            // just converting Box<[T, ..n]> to Box<[T]> we aren't really doing\n-            // a deref (and wouldn't if we could treat Box like a normal struct).\n-            let autoderefs = match adj.autoref {\n-                Some(ty::AutoUnsizeUniq(..)) => adj.autoderefs - 1,\n-                _ => adj.autoderefs\n+            let (autoderefs, use_autoref) = match adj.autoref {\n+                // Extracting a value from a box counts as a deref, but if we are\n+                // just converting Box<[T, ..n]> to Box<[T]> we aren't really doing\n+                // a deref (and wouldn't if we could treat Box like a normal struct).\n+                Some(ty::AutoUnsizeUniq(..)) => (adj.autoderefs - 1, true),\n+                // We are a bit paranoid about adjustments and thus might have a re-\n+                // borrow here which merely derefs and then refs again (it might have\n+                // a different region or mutability, but we don't care here. It might\n+                // also be just in case we need to unsize. But if there are no nested\n+                // adjustments then it should be a no-op).\n+                Some(ty::AutoPtr(_, _, None)) if adj.autoderefs == 1 => {\n+                    match ty::get(datum.ty).sty {\n+                        // Don't skip a conversion from Box<T> to &T, etc.\n+                        ty::ty_rptr(..) => {\n+                            let method_call = MethodCall::autoderef(expr.id, adj.autoderefs-1);\n+                            let method = bcx.tcx().method_map.borrow().find(&method_call).is_some();\n+                            if method {\n+                                // Don't skip an overloaded deref.\n+                                (adj.autoderefs, true)\n+                            } else {\n+                                (adj.autoderefs - 1, false)\n+                            }\n+                        }\n+                        _ => (adj.autoderefs, true),\n+                    }\n+                }\n+                _ => (adj.autoderefs, true)\n             };\n \n             if autoderefs > 0 {\n-                let lval = unpack_datum!(bcx,\n-                                         datum.to_lvalue_datum(bcx, \"auto_deref\", expr.id));\n-\n+                // Schedule cleanup.\n+                let lval = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"auto_deref\", expr.id));\n                 datum = unpack_datum!(\n                     bcx, deref_multiple(bcx, expr, lval.to_expr_datum(), autoderefs));\n             }\n \n-            match adj.autoref {\n-                Some(ref a) => {\n+            // (You might think there is a more elegant way to do this than a\n+            // use_autoref bool, but then you remember that the borrow checker exists).\n+            match (use_autoref, &adj.autoref) {\n+                (true, &Some(ref a)) => {\n                     datum = unpack_datum!(bcx, apply_autoref(a,\n                                                              bcx,\n                                                              expr,\n@@ -221,7 +243,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         }\n     }\n     debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n-    return DatumBlock {bcx: bcx, datum: datum};\n+    return DatumBlock::new(bcx, datum);\n \n     fn apply_autoref<'a>(autoref: &ty::AutoRef,\n                          bcx: &'a Block<'a>,"}]}