{"sha": "2c6e0e445ed3b040495034f1b426f7d76697f72f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNmUwZTQ0NWVkM2IwNDA0OTUwMzRmMWI0MjZmN2Q3NjY5N2Y3MmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-03T03:15:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-03T03:15:52Z"}, "message": "Auto merge of #40152 - eddyb:order-in-rustbuild, r=alexcrichton\n\nrustbuild: use deterministic step ordering and respect path order on the command-line.\n\nRestores similar behavior to `make` rules, where:\n* the step order was always the same, e.g. the testsuite order in `make check`\n* `make check-stage1-{cfail,rpass}` would *always* run `cfail` before `rpass`\n  * `./x.py test--stage 1 src/test/{compile-fail,run-pass}` is now equivalent\n\nr? @alexcrichton", "tree": {"sha": "65403d6d1b75c04ca34e8a1b2dceca3a92c59875", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65403d6d1b75c04ca34e8a1b2dceca3a92c59875"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c6e0e445ed3b040495034f1b426f7d76697f72f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6e0e445ed3b040495034f1b426f7d76697f72f", "html_url": "https://github.com/rust-lang/rust/commit/2c6e0e445ed3b040495034f1b426f7d76697f72f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c6e0e445ed3b040495034f1b426f7d76697f72f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "url": "https://api.github.com/repos/rust-lang/rust/commits/06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "html_url": "https://github.com/rust-lang/rust/commit/06c63f6e9e01542d8c0179d9498e4ecc3b287b66"}, {"sha": "4c8b39d97346751552c2916e60823942ceae0228", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c8b39d97346751552c2916e60823942ceae0228", "html_url": "https://github.com/rust-lang/rust/commit/4c8b39d97346751552c2916e60823942ceae0228"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "af99eea3ffb37973a0827abf68a76038656f4735", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e0e445ed3b040495034f1b426f7d76697f72f/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e0e445ed3b040495034f1b426f7d76697f72f/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=2c6e0e445ed3b040495034f1b426f7d76697f72f", "patch": "@@ -26,7 +26,7 @@\n //! along with the actual implementation elsewhere. You can find more comments\n //! about how to define rules themselves below.\n \n-use std::collections::{HashMap, HashSet};\n+use std::collections::{BTreeMap, HashSet};\n use std::mem;\n \n use check::{self, TestKind};\n@@ -866,7 +866,7 @@ impl<'a, 'b> Drop for RuleBuilder<'a, 'b> {\n pub struct Rules<'a> {\n     build: &'a Build,\n     sbuild: Step<'a>,\n-    rules: HashMap<&'a str, Rule<'a>>,\n+    rules: BTreeMap<&'a str, Rule<'a>>,\n }\n \n impl<'a> Rules<'a> {\n@@ -879,7 +879,7 @@ impl<'a> Rules<'a> {\n                 host: &build.config.build,\n                 name: \"\",\n             },\n-            rules: HashMap::new(),\n+            rules: BTreeMap::new(),\n         }\n     }\n \n@@ -985,6 +985,8 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         // 2. Next, we determine which rules we're actually executing. If a\n         //    number of path filters were specified on the command line we look\n         //    for those, otherwise we look for anything tagged `default`.\n+        //    Here we also compute the priority of each rule based on how early\n+        //    in the command line the matching path filter showed up.\n         //\n         // 3. Finally, we generate some steps with host and target information.\n         //\n@@ -1015,11 +1017,22 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             Subcommand::Clean => panic!(),\n         };\n \n-        self.rules.values().filter(|rule| rule.kind == kind).filter(|rule| {\n-            (paths.len() == 0 && rule.default) || paths.iter().any(|path| {\n-                path.ends_with(rule.path)\n-            })\n-        }).flat_map(|rule| {\n+        let mut rules: Vec<_> = self.rules.values().filter_map(|rule| {\n+            if rule.kind != kind {\n+                return None;\n+            }\n+\n+            if paths.len() == 0 && rule.default {\n+                Some((rule, 0))\n+            } else {\n+                paths.iter().position(|path| path.ends_with(rule.path))\n+                     .map(|priority| (rule, priority))\n+            }\n+        }).collect();\n+\n+        rules.sort_by_key(|&(_, priority)| priority);\n+\n+        rules.into_iter().flat_map(|(rule, _)| {\n             let hosts = if rule.only_host_build || rule.only_build {\n                 &self.build.config.host[..1]\n             } else if self.build.flags.host.len() > 0 {"}]}