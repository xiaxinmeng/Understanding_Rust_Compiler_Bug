{"sha": "fa63b8c8138ca826a6fee7673a170ab0615cb678", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNjNiOGM4MTM4Y2E4MjZhNmZlZTc2NzNhMTcwYWIwNjE1Y2I2Nzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-26T14:32:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-26T14:32:30Z"}, "message": "auto merge of #15192 : mrec/rust/json-nan, r=alexcrichton\n\nThe JSON spec requires that these special values be serialized as \"null\"; the current serialization breaks any conformant JSON parser. So encoding needs to output \"null\",  `to_json` on floating-point types can return `Null` as well as `Number` values, and reading a `Null` value when specifically expecting a number should be interpreted as NaN. There's no way to round-trip Infinity through JSON.\r\n\r\nThis is my first attempt at both writing Rust and opening pull requests, so please dial your derp detector up to eleven when reviewing. A `rustc --test lib.rs` in `libserialize` passes all tests; a `make check` of the whole tree fails with the error below, but it doesn't look obviously related and the docs say that `make check` is known to be flaky on Windows.\r\n\r\n    ---- [compile-fail] compile-fail/svh-change-significant-cfg.rs stdout ----\r\n            task '[compile-fail] compile-fail/svh-change-significant-cfg.rs' failed at 'called `Result::\r\n    unwrap()` on an `Err` value: couldn't create file (end of file (unknown error); path=i686-pc-mingw32\r\n    \\test\\compile-fail\\svh-a-base.err; mode=truncate; access=write)', C:\\msys\\home\\Mike\\rust\\src\\libcore\r\n    \\result.rs:545\r\n\r\nIncidentally, it may just be my lack of familiarity with the language and its idioms, but the duplication between `Encoder`/`PrettyEncoder` had a distinct code smell to it. The size of the file (~3500 lines) also made it a bit hard to navigate. Has there been any discussion of refactoring and/or breaking it up? I couldn't find anything in Issues except the ancient #9028.", "tree": {"sha": "eb344bce173253518adb892bc80dc98c389b36f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb344bce173253518adb892bc80dc98c389b36f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa63b8c8138ca826a6fee7673a170ab0615cb678", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa63b8c8138ca826a6fee7673a170ab0615cb678", "html_url": "https://github.com/rust-lang/rust/commit/fa63b8c8138ca826a6fee7673a170ab0615cb678", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa63b8c8138ca826a6fee7673a170ab0615cb678/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc502e23458c695b008e3470ec5ef40421b8aaa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc502e23458c695b008e3470ec5ef40421b8aaa2", "html_url": "https://github.com/rust-lang/rust/commit/fc502e23458c695b008e3470ec5ef40421b8aaa2"}, {"sha": "e1a9899a3a12f9f5fde6d5757c13bc248e89617d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a9899a3a12f9f5fde6d5757c13bc248e89617d", "html_url": "https://github.com/rust-lang/rust/commit/e1a9899a3a12f9f5fde6d5757c13bc248e89617d"}], "stats": {"total": 57, "additions": 51, "deletions": 6}, "files": [{"sha": "9c91bd4b7e1a7e3a50cf7222a6decc7d44f4bb4b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fa63b8c8138ca826a6fee7673a170ab0615cb678/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa63b8c8138ca826a6fee7673a170ab0615cb678/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=fa63b8c8138ca826a6fee7673a170ab0615cb678", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -234,6 +234,7 @@ use std::fmt;\n use std::io::MemWriter;\n use std::io;\n use std::mem::{swap,transmute};\n+use std::num::{FPNaN, FPInfinite};\n use std::num;\n use std::str::ScalarValue;\n use std::str;\n@@ -349,6 +350,13 @@ fn escape_str(s: &str) -> String {\n     escaped\n }\n \n+fn fmt_number_or_null(v: f64) -> String {\n+    match v.classify() {\n+        FPNaN | FPInfinite => String::from_str(\"null\"),\n+        _ => f64::to_str_digits(v, 6u)\n+    }\n+}\n+\n fn spaces(n: uint) -> String {\n     String::from_char(n, ' ')\n }\n@@ -412,7 +420,7 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+        write!(self.wr, \"{}\", fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n \n@@ -608,7 +616,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+        write!(self.wr, \"{}\", fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n         self.emit_f64(v as f64)\n@@ -1270,7 +1278,7 @@ impl<T: Iterator<char>> Parser<T> {\n             '0' => {\n                 self.bump();\n \n-                // There can be only one leading '0'.\n+                // A leading '0' must be the only digit before the decimal point.\n                 match self.ch_or_null() {\n                     '0' .. '9' => return self.error(InvalidNumber),\n                     _ => ()\n@@ -1864,6 +1872,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 // is going to have a string here, as per JSON spec..\n                 Ok(FromStr::from_str(s.as_slice()).unwrap())\n             },\n+            Null => Ok(f64::NAN),\n             value => {\n                 Err(ExpectedError(\"Number\".to_string(),\n                                   format!(\"{}\", value)))\n@@ -2185,11 +2194,16 @@ impl ToJson for u64 {\n }\n \n impl ToJson for f32 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n+    fn to_json(&self) -> Json { (*self as f64).to_json() }\n }\n \n impl ToJson for f64 {\n-    fn to_json(&self) -> Json { Number(*self) }\n+    fn to_json(&self) -> Json {\n+        match self.classify() {\n+            FPNaN | FPInfinite => Null,\n+            _ => Number(*self)\n+        }\n+    }\n }\n \n impl ToJson for () {\n@@ -2282,6 +2296,8 @@ mod tests {\n                 InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n                 EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n                 TrailingCharacters};\n+    use std::f32;\n+    use std::f64;\n     use std::io;\n     use std::collections::TreeMap;\n \n@@ -2335,6 +2351,15 @@ mod tests {\n \n         assert_eq!(Number(0.5).to_str().into_string(), \"0.5\".to_string());\n         assert_eq!(Number(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n+\n+        assert_eq!(Number(f64::NAN).to_str().into_string(), \"null\".to_string());\n+        assert_eq!(Number(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n+\n+        assert_eq!(Number(f64::INFINITY).to_str().into_string(), \"null\".to_string());\n+        assert_eq!(Number(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+\n+        assert_eq!(Number(f64::NEG_INFINITY).to_str().into_string(), \"null\".to_string());\n+        assert_eq!(Number(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n     #[test]\n@@ -2583,6 +2608,7 @@ mod tests {\n     fn test_read_number() {\n         assert_eq!(from_str(\"+\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n         assert_eq!(from_str(\".\"),   Err(SyntaxError(InvalidSyntax, 1, 1)));\n+        assert_eq!(from_str(\"NaN\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n         assert_eq!(from_str(\"-\"),   Err(SyntaxError(InvalidNumber, 1, 2)));\n         assert_eq!(from_str(\"00\"),  Err(SyntaxError(InvalidNumber, 1, 2)));\n         assert_eq!(from_str(\"1.\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n@@ -2792,6 +2818,22 @@ mod tests {\n         );\n     }\n \n+    #[deriving(Decodable)]\n+    struct FloatStruct {\n+        f: f64,\n+        a: Vec<f64>\n+    }\n+    #[test]\n+    fn test_decode_struct_with_nan() {\n+        let encoded_str = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n+        let json_object = from_str(encoded_str.as_slice());\n+        let mut decoder = Decoder::new(json_object.unwrap());\n+        let after: FloatStruct = Decodable::decode(&mut decoder).unwrap();\n+        assert!(after.f.is_nan());\n+        assert!(after.a.get(0).is_nan());\n+        assert_eq!(after.a.get(1), &123f64);\n+    }\n+\n     #[test]\n     fn test_decode_option() {\n         let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n@@ -2833,6 +2875,7 @@ mod tests {\n     }\n \n     #[deriving(Decodable)]\n+    #[allow(dead_code)]\n     struct DecodeStruct {\n         x: f64,\n         y: bool,\n@@ -3362,6 +3405,8 @@ mod tests {\n         assert_eq!(13.0_f32.to_json(), Number(13.0_f64));\n         assert_eq!(14.0_f64.to_json(), Number(14.0_f64));\n         assert_eq!(().to_json(), Null);\n+        assert_eq!(f32::INFINITY.to_json(), Null);\n+        assert_eq!(f64::NAN.to_json(), Null);\n         assert_eq!(true.to_json(), Boolean(true));\n         assert_eq!(false.to_json(), Boolean(false));\n         assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));"}]}