{"sha": "73f7e426be348e9d479c8685843399b9cbbff064", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZjdlNDI2YmUzNDhlOWQ0NzljODY4NTg0MzM5OWI5Y2JiZmYwNjQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-11T17:01:50Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-28T20:34:42Z"}, "message": "Relate identical parameters in array lengths", "tree": {"sha": "0d3b12a3b7c23c8c8da8e8bd4e213529ffd2ea20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d3b12a3b7c23c8c8da8e8bd4e213529ffd2ea20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73f7e426be348e9d479c8685843399b9cbbff064", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73f7e426be348e9d479c8685843399b9cbbff064", "html_url": "https://github.com/rust-lang/rust/commit/73f7e426be348e9d479c8685843399b9cbbff064", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73f7e426be348e9d479c8685843399b9cbbff064/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "721268583759224d0f6476e0b8b196cc8afbdea0", "url": "https://api.github.com/repos/rust-lang/rust/commits/721268583759224d0f6476e0b8b196cc8afbdea0", "html_url": "https://github.com/rust-lang/rust/commit/721268583759224d0f6476e0b8b196cc8afbdea0"}], "stats": {"total": 38, "additions": 17, "deletions": 21}, "files": [{"sha": "70c47a6ca3426e52ed110dd0566e6902484d7aaa", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/73f7e426be348e9d479c8685843399b9cbbff064/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f7e426be348e9d479c8685843399b9cbbff064/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=73f7e426be348e9d479c8685843399b9cbbff064", "patch": "@@ -9,7 +9,6 @@ use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::mir::interpret::{GlobalId, ConstValue, Scalar};\n-use crate::util::common::ErrorReported;\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n use std::iter;\n@@ -474,8 +473,9 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n-            let to_u64 = |x: ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n-                match x.val {\n+\n+            let to_u64 = |ct: &'tcx ty::Const<'tcx>| -> Option<u64> {\n+                match ct.val {\n                     // FIXME(const_generics): this doesn't work right now,\n                     // because it tries to relate an `Infer` to a `Param`.\n                     ConstValue::Unevaluated(def_id, substs) => {\n@@ -493,36 +493,32 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                     instance,\n                                     promoted: None,\n                                 };\n-                                if let Some(s) = tcx.const_eval(param_env.and(cid))\n-                                                    .ok()\n-                                                    .map(|c| c.unwrap_usize(tcx)) {\n-                                    return Ok(s)\n-                                }\n+                                return tcx.const_eval(param_env.and(cid))\n+                                    .ok()\n+                                    .map(|c| c.unwrap_usize(tcx));\n                             }\n                         }\n-                        tcx.sess.delay_span_bug(tcx.def_span(def_id),\n-                            \"array length could not be evaluated\");\n-                        Err(ErrorReported)\n+                        None\n                     }\n-                    _ => x.assert_usize(tcx).ok_or_else(|| {\n-                        tcx.sess.delay_span_bug(DUMMY_SP,\n-                            \"array length could not be evaluated\");\n-                        ErrorReported\n-                    })\n+                    _ => ct.assert_usize(tcx),\n                 }\n             };\n-            match (to_u64(*sz_a), to_u64(*sz_b)) {\n-                (Ok(sz_a_u64), Ok(sz_b_u64)) => {\n+            match (to_u64(sz_a), to_u64(sz_b)) {\n+                (Some(sz_a_u64), Some(sz_b_u64)) => {\n                     if sz_a_u64 == sz_b_u64 {\n                         Ok(tcx.mk_ty(ty::Array(t, sz_a)))\n                     } else {\n                         Err(TypeError::FixedArraySize(\n                             expected_found(relation, &sz_a_u64, &sz_b_u64)))\n                     }\n                 }\n-                // We reported an error or will ICE, so we can return Error.\n-                (Err(ErrorReported), _) | (_, Err(ErrorReported)) => {\n-                    Ok(tcx.types.err)\n+                _ => {\n+                    if let Ok(sz) = relation.relate(&sz_a, &sz_b) {\n+                        Ok(tcx.mk_ty(ty::Array(t, sz)))\n+                    } else {\n+                        tcx.sess.delay_span_bug(DUMMY_SP, \"array length could not be evaluated\");\n+                        Ok(tcx.types.err)\n+                    }\n                 }\n             }\n         }"}]}