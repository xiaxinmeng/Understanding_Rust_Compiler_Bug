{"sha": "0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMWI5ZjQ2MTRhMDg2ZTkyYTgxZjQ1YjQ2YzczZDVlNGI2YWQ5NGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-13T12:28:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-13T12:28:14Z"}, "message": "Auto merge of #38309 - sfackler:rfc-1725, r=alexcrichton\n\nImplement RFC #1725 (read_unaligned, write_unaligned)\n\ncc #37955\n\nr? @alexcrichton", "tree": {"sha": "6514fc4f9f8589b8ca54cd0833e18fb1656aad2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6514fc4f9f8589b8ca54cd0833e18fb1656aad2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d", "html_url": "https://github.com/rust-lang/rust/commit/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ace092f569230a00350e56412ac1804ffb806c32", "url": "https://api.github.com/repos/rust-lang/rust/commits/ace092f569230a00350e56412ac1804ffb806c32", "html_url": "https://github.com/rust-lang/rust/commit/ace092f569230a00350e56412ac1804ffb806c32"}, {"sha": "75fe727b785b43c5f31601adc19233d2efb186f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/75fe727b785b43c5f31601adc19233d2efb186f0", "html_url": "https://github.com/rust-lang/rust/commit/75fe727b785b43c5f31601adc19233d2efb186f0"}], "stats": {"total": 107, "additions": 107, "deletions": 0}, "files": [{"sha": "e3ca8eca76c570979eaa607bb4f422368985863d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d", "patch": "@@ -117,6 +117,8 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n+/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -137,6 +139,44 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n+/// Reads the value from `src` without moving it. This leaves the\n+/// memory in `src` unchanged.\n+///\n+/// Unlike `read`, the pointer may be unaligned.\n+///\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(ptr_unaligned)]\n+///\n+/// let x = 12;\n+/// let y = &x as *const i32;\n+///\n+/// unsafe {\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// }\n+/// ```\n+#[inline(always)]\n+#[unstable(feature = \"ptr_unaligned\", issue = \"37955\")]\n+pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n+    let mut tmp: T = mem::uninitialized();\n+    copy_nonoverlapping(src as *const u8,\n+                        &mut tmp as *mut T as *mut u8,\n+                        mem::size_of::<T>());\n+    tmp\n+}\n+\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n@@ -151,6 +191,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n ///\n+/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -171,6 +213,47 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n+/// Overwrites a memory location with the given value without reading or\n+/// dropping the old value.\n+///\n+/// Unlike `write`, the pointer may be unaligned.\n+///\n+/// # Safety\n+///\n+/// This operation is marked unsafe because it accepts a raw pointer.\n+///\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care must be taken not to overwrite an object\n+/// that should be dropped.\n+///\n+/// This is appropriate for initializing uninitialized memory, or overwriting\n+/// memory that has previously been `read` from.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(ptr_unaligned)]\n+///\n+/// let mut x = 0;\n+/// let y = &mut x as *mut i32;\n+/// let z = 12;\n+///\n+/// unsafe {\n+///     std::ptr::write_unaligned(y, z);\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// }\n+/// ```\n+#[inline]\n+#[unstable(feature = \"ptr_unaligned\", issue = \"37955\")]\n+pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n+    copy_nonoverlapping(&src as *const T as *const u8,\n+                        dst as *mut u8,\n+                        mem::size_of::<T>());\n+    mem::forget(src);\n+}\n+\n /// Performs a volatile read of the value from `src` without moving it. This\n /// leaves the memory in `src` unchanged.\n ///"}, {"sha": "05d98d4a2128d5657c3d00b5c8e7b55499117943", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d", "patch": "@@ -36,6 +36,7 @@\n #![feature(iter_min_by)]\n #![feature(ordering_chaining)]\n #![feature(result_unwrap_or_default)]\n+#![feature(ptr_unaligned)]\n \n extern crate core;\n extern crate test;"}, {"sha": "7f6f472bfbb78ea5588f7a770a61792f95bc6f1a", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=0d1b9f4614a086e92a81f45b46c73d5e4b6ad94d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::ptr::*;\n+use core::cell::RefCell;\n \n #[test]\n fn test() {\n@@ -189,3 +190,25 @@ pub fn test_variadic_fnptr() {\n     let mut s = SipHasher::new();\n     assert_eq!(p.hash(&mut s), q.hash(&mut s));\n }\n+\n+#[test]\n+fn write_unaligned_drop() {\n+    thread_local! {\n+        static DROPS: RefCell<Vec<u32>> = RefCell::new(Vec::new());\n+    }\n+\n+    struct Dropper(u32);\n+\n+    impl Drop for Dropper {\n+        fn drop(&mut self) {\n+            DROPS.with(|d| d.borrow_mut().push(self.0));\n+        }\n+    }\n+\n+    {\n+        let c = Dropper(0);\n+        let mut t = Dropper(1);\n+        unsafe { write_unaligned(&mut t, c); }\n+    }\n+    DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n+}"}]}