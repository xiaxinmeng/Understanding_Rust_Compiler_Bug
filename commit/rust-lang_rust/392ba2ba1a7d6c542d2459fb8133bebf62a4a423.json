{"sha": "392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MmJhMmJhMWE3ZDZjNTQyZDI0NTlmYjgxMzNiZWJmNjJhNGE0MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-17T20:41:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-17T20:41:37Z"}, "message": "Auto merge of #84279 - Dylan-DPC:rollup-k7otd7e, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #83237 (rustdoc: use more precise relative URLs)\n - #84150 (rustdoc: move some search code into search.js)\n - #84203 (rustdoc: Give a more accurate span for anchor failures)\n - #84257 (Add documentation to help people find `Ipv4Addr::UNSPECIFIED`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4b21d63dfc13864287cf392c901a998ecb33a386", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b21d63dfc13864287cf392c901a998ecb33a386"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "html_url": "https://github.com/rust-lang/rust/commit/392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd9949b8e6577631f8e2757a4a007098e6a88b7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd9949b8e6577631f8e2757a4a007098e6a88b7d", "html_url": "https://github.com/rust-lang/rust/commit/bd9949b8e6577631f8e2757a4a007098e6a88b7d"}, {"sha": "a3277e2a0a2ccd165f5ea7dd485828051d31e030", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3277e2a0a2ccd165f5ea7dd485828051d31e030", "html_url": "https://github.com/rust-lang/rust/commit/a3277e2a0a2ccd165f5ea7dd485828051d31e030"}], "stats": {"total": 4549, "additions": 2295, "deletions": 2254}, "files": [{"sha": "9b629e19be53d2ed01600560cd32cf7caaba63e2", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -334,6 +334,8 @@ impl Ipv4Addr {\n \n     /// An IPv4 address representing an unspecified address: 0.0.0.0\n     ///\n+    /// This corresponds to the constant `INADDR_ANY` in other languages.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -342,6 +344,7 @@ impl Ipv4Addr {\n     /// let addr = Ipv4Addr::UNSPECIFIED;\n     /// assert_eq!(addr, Ipv4Addr::new(0, 0, 0, 0));\n     /// ```\n+    #[doc(alias = \"INADDR_ANY\")]\n     #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n     pub const UNSPECIFIED: Self = Ipv4Addr::new(0, 0, 0, 0);\n "}, {"sha": "2b25c6a26bcc4c8e18ec8fea81c0332874066336", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -41,6 +41,7 @@ use crate::core::DocContext;\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n+use crate::html::render::Context;\n \n use self::FnRetTy::*;\n use self::ItemKind::*;\n@@ -193,19 +194,18 @@ impl Item {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    crate fn links(&self, cache: &Cache) -> Vec<RenderedLink> {\n+    crate fn links(&self, cx: &Context<'_>) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n-        use crate::html::render::CURRENT_DEPTH;\n \n-        cache\n+        cx.cache()\n             .intra_doc_links\n             .get(&self.def_id)\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n-            .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n+            .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n                 match *did {\n                     Some(did) => {\n-                        if let Some((mut href, ..)) = href(did, cache) {\n+                        if let Some((mut href, ..)) = href(did, cx) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push('#');\n                                 href.push_str(fragment);\n@@ -219,16 +219,26 @@ impl Item {\n                             None\n                         }\n                     }\n+                    // FIXME(83083): using fragments as a side-channel for\n+                    // primitive names is very unfortunate\n                     None => {\n+                        let relative_to = &cx.current;\n                         if let Some(ref fragment) = *fragment {\n-                            let url = match cache.extern_locations.get(&self.def_id.krate) {\n+                            let url = match cx.cache().extern_locations.get(&self.def_id.krate) {\n                                 Some(&(_, _, ExternalLocation::Local)) => {\n-                                    let depth = CURRENT_DEPTH.with(|l| l.get());\n-                                    \"../\".repeat(depth)\n+                                    if relative_to[0] == \"std\" {\n+                                        let depth = relative_to.len() - 1;\n+                                        \"../\".repeat(depth)\n+                                    } else {\n+                                        let depth = relative_to.len();\n+                                        format!(\"{}std/\", \"../\".repeat(depth))\n+                                    }\n+                                }\n+                                Some(&(_, _, ExternalLocation::Remote(ref s))) => {\n+                                    format!(\"{}/std/\", s.trim_end_matches('/'))\n                                 }\n-                                Some(&(_, _, ExternalLocation::Remote(ref s))) => s.to_string(),\n                                 Some(&(_, _, ExternalLocation::Unknown)) | None => format!(\n-                                    \"https://doc.rust-lang.org/{}\",\n+                                    \"https://doc.rust-lang.org/{}/std/\",\n                                     crate::doc_rust_lang_org_channel(),\n                                 ),\n                             };\n@@ -238,9 +248,8 @@ impl Item {\n                                 original_text: s.clone(),\n                                 new_text: link_text.clone(),\n                                 href: format!(\n-                                    \"{}{}std/primitive.{}.html{}\",\n+                                    \"{}primitive.{}.html{}\",\n                                     url,\n-                                    if !url.ends_with('/') { \"/\" } else { \"\" },\n                                     &fragment[..tail],\n                                     &fragment[tail..]\n                                 ),"}, {"sha": "ca364b9f103658609dc10090b9318bb60fec1d06", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 223, "deletions": 234, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -20,6 +20,7 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n+use crate::html::render::Context;\n use crate::html::render::CURRENT_DEPTH;\n \n crate trait Print {\n@@ -125,19 +126,18 @@ fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Displ\n \n crate fn print_generic_bounds<'a, 'tcx: 'a>(\n     bounds: &'a [clean::GenericBound],\n-    cache: &'a Cache,\n-    tcx: TyCtxt<'tcx>,\n+    cx: &'a Context<'tcx>,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n     display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n \n         for (i, bound) in\n-            bounds.iter().filter(|b| bounds_dup.insert(b.print(cache, tcx).to_string())).enumerate()\n+            bounds.iter().filter(|b| bounds_dup.insert(b.print(cx).to_string())).enumerate()\n         {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            fmt::Display::fmt(&bound.print(cache, tcx), f)?;\n+            fmt::Display::fmt(&bound.print(cx), f)?;\n         }\n         Ok(())\n     })\n@@ -146,8 +146,7 @@ crate fn print_generic_bounds<'a, 'tcx: 'a>(\n impl clean::GenericParamDef {\n     crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self.kind {\n             clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n@@ -156,27 +155,27 @@ impl clean::GenericParamDef {\n \n                 if !bounds.is_empty() {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", print_generic_bounds(bounds, cache, tcx))?;\n+                        write!(f, \": {:#}\", print_generic_bounds(bounds, cx))?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache, tcx))?;\n+                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cx))?;\n                     }\n                 }\n \n                 if let Some(ref ty) = default {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print(cache, tcx))?;\n+                        write!(f, \" = {:#}\", ty.print(cx))?;\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print(cache, tcx))?;\n+                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print(cx))?;\n                     }\n                 }\n \n                 Ok(())\n             }\n             clean::GenericParamDefKind::Const { ref ty, .. } => {\n                 if f.alternate() {\n-                    write!(f, \"const {}: {:#}\", self.name, ty.print(cache, tcx))\n+                    write!(f, \"const {}: {:#}\", self.name, ty.print(cx))\n                 } else {\n-                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print(cache, tcx))\n+                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print(cx))\n                 }\n             }\n         })\n@@ -186,8 +185,7 @@ impl clean::GenericParamDef {\n impl clean::Generics {\n     crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             let real_params =\n@@ -196,9 +194,9 @@ impl clean::Generics {\n                 return Ok(());\n             }\n             if f.alternate() {\n-                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print(cache, tcx))))\n+                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print(cx))))\n             } else {\n-                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print(cache, tcx))))\n+                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print(cx))))\n             }\n         })\n     }\n@@ -209,8 +207,7 @@ impl clean::Generics {\n /// * Whether the where-clause needs to add a comma and newline after the last bound.\n crate fn print_where_clause<'a, 'tcx: 'a>(\n     gens: &'a clean::Generics,\n-    cache: &'a Cache,\n-    tcx: TyCtxt<'tcx>,\n+    cx: &'a Context<'tcx>,\n     indent: usize,\n     end_newline: bool,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -241,14 +238,14 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n                     if f.alternate() {\n                         clause.push_str(&format!(\n                             \"{:#}: {:#}\",\n-                            ty.print(cache, tcx),\n-                            print_generic_bounds(bounds, cache, tcx)\n+                            ty.print(cx),\n+                            print_generic_bounds(bounds, cx)\n                         ));\n                     } else {\n                         clause.push_str(&format!(\n                             \"{}: {}\",\n-                            ty.print(cache, tcx),\n-                            print_generic_bounds(bounds, cache, tcx)\n+                            ty.print(cx),\n+                            print_generic_bounds(bounds, cx)\n                         ));\n                     }\n                 }\n@@ -258,24 +255,16 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n                         lifetime.print(),\n                         bounds\n                             .iter()\n-                            .map(|b| b.print(cache, tcx).to_string())\n+                            .map(|b| b.print(cx).to_string())\n                             .collect::<Vec<_>>()\n                             .join(\" + \")\n                     ));\n                 }\n                 clean::WherePredicate::EqPredicate { lhs, rhs } => {\n                     if f.alternate() {\n-                        clause.push_str(&format!(\n-                            \"{:#} == {:#}\",\n-                            lhs.print(cache, tcx),\n-                            rhs.print(cache, tcx),\n-                        ));\n+                        clause.push_str(&format!(\"{:#} == {:#}\", lhs.print(cx), rhs.print(cx),));\n                     } else {\n-                        clause.push_str(&format!(\n-                            \"{} == {}\",\n-                            lhs.print(cache, tcx),\n-                            rhs.print(cache, tcx),\n-                        ));\n+                        clause.push_str(&format!(\"{} == {}\", lhs.print(cx), rhs.print(cx),));\n                     }\n                 }\n             }\n@@ -327,29 +316,28 @@ impl clean::Constant {\n impl clean::PolyTrait {\n     fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n                 if f.alternate() {\n                     write!(\n                         f,\n                         \"for<{:#}> \",\n-                        comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n+                        comma_sep(self.generic_params.iter().map(|g| g.print(cx)))\n                     )?;\n                 } else {\n                     write!(\n                         f,\n                         \"for&lt;{}&gt; \",\n-                        comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n+                        comma_sep(self.generic_params.iter().map(|g| g.print(cx)))\n                     )?;\n                 }\n             }\n             if f.alternate() {\n-                write!(f, \"{:#}\", self.trait_.print(cache, tcx))\n+                write!(f, \"{:#}\", self.trait_.print(cx))\n             } else {\n-                write!(f, \"{}\", self.trait_.print(cache, tcx))\n+                write!(f, \"{}\", self.trait_.print(cx))\n             }\n         })\n     }\n@@ -358,8 +346,7 @@ impl clean::PolyTrait {\n impl clean::GenericBound {\n     crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::GenericBound::Outlives(lt) => write!(f, \"{}\", lt.print()),\n@@ -370,9 +357,9 @@ impl clean::GenericBound {\n                     hir::TraitBoundModifier::MaybeConst => \"?const\",\n                 };\n                 if f.alternate() {\n-                    write!(f, \"{}{:#}\", modifier_str, ty.print(cache, tcx))\n+                    write!(f, \"{}{:#}\", modifier_str, ty.print(cx))\n                 } else {\n-                    write!(f, \"{}{}\", modifier_str, ty.print(cache, tcx))\n+                    write!(f, \"{}{}\", modifier_str, ty.print(cx))\n                 }\n             }\n         })\n@@ -382,8 +369,7 @@ impl clean::GenericBound {\n impl clean::GenericArgs {\n     fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             match self {\n@@ -401,9 +387,9 @@ impl clean::GenericArgs {\n                             }\n                             comma = true;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", arg.print(cache, tcx))?;\n+                                write!(f, \"{:#}\", arg.print(cx))?;\n                             } else {\n-                                write!(f, \"{}\", arg.print(cache, tcx))?;\n+                                write!(f, \"{}\", arg.print(cx))?;\n                             }\n                         }\n                         for binding in bindings {\n@@ -412,9 +398,9 @@ impl clean::GenericArgs {\n                             }\n                             comma = true;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", binding.print(cache, tcx))?;\n+                                write!(f, \"{:#}\", binding.print(cx))?;\n                             } else {\n-                                write!(f, \"{}\", binding.print(cache, tcx))?;\n+                                write!(f, \"{}\", binding.print(cx))?;\n                             }\n                         }\n                         if f.alternate() {\n@@ -433,17 +419,17 @@ impl clean::GenericArgs {\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", ty.print(cache, tcx))?;\n+                            write!(f, \"{:#}\", ty.print(cx))?;\n                         } else {\n-                            write!(f, \"{}\", ty.print(cache, tcx))?;\n+                            write!(f, \"{}\", ty.print(cx))?;\n                         }\n                     }\n                     f.write_str(\")\")?;\n                     if let Some(ref ty) = *output {\n                         if f.alternate() {\n-                            write!(f, \" -> {:#}\", ty.print(cache, tcx))?;\n+                            write!(f, \" -> {:#}\", ty.print(cx))?;\n                         } else {\n-                            write!(f, \" -&gt; {}\", ty.print(cache, tcx))?;\n+                            write!(f, \" -&gt; {}\", ty.print(cx))?;\n                         }\n                     }\n                 }\n@@ -453,56 +439,89 @@ impl clean::GenericArgs {\n     }\n }\n \n-crate fn href(did: DefId, cache: &Cache) -> Option<(String, ItemType, Vec<String>)> {\n+crate fn href(did: DefId, cx: &Context<'_>) -> Option<(String, ItemType, Vec<String>)> {\n+    let cache = &cx.cache();\n+    let relative_to = &cx.current;\n+    fn to_module_fqp(shortty: ItemType, fqp: &[String]) -> &[String] {\n+        if shortty == ItemType::Module { &fqp[..] } else { &fqp[..fqp.len() - 1] }\n+    }\n+\n     if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n         return None;\n     }\n \n-    let depth = CURRENT_DEPTH.with(|l| l.get());\n-    let (fqp, shortty, mut url) = match cache.paths.get(&did) {\n-        Some(&(ref fqp, shortty)) => (fqp, shortty, \"../\".repeat(depth)),\n+    let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n+        Some(&(ref fqp, shortty)) => (fqp, shortty, {\n+            let module_fqp = to_module_fqp(shortty, fqp);\n+            href_relative_parts(module_fqp, relative_to)\n+        }),\n         None => {\n             let &(ref fqp, shortty) = cache.external_paths.get(&did)?;\n+            let module_fqp = to_module_fqp(shortty, fqp);\n             (\n                 fqp,\n                 shortty,\n                 match cache.extern_locations[&did.krate] {\n-                    (.., ExternalLocation::Remote(ref s)) => s.to_string(),\n-                    (.., ExternalLocation::Local) => \"../\".repeat(depth),\n+                    (.., ExternalLocation::Remote(ref s)) => {\n+                        let s = s.trim_end_matches('/');\n+                        let mut s = vec![&s[..]];\n+                        s.extend(module_fqp[..].iter().map(String::as_str));\n+                        s\n+                    }\n+                    (.., ExternalLocation::Local) => href_relative_parts(module_fqp, relative_to),\n                     (.., ExternalLocation::Unknown) => return None,\n                 },\n             )\n         }\n     };\n-    for component in &fqp[..fqp.len() - 1] {\n-        url.push_str(component);\n-        url.push('/');\n-    }\n+    let last = &fqp.last().unwrap()[..];\n+    let filename;\n     match shortty {\n         ItemType::Module => {\n-            url.push_str(fqp.last().unwrap());\n-            url.push_str(\"/index.html\");\n+            url_parts.push(\"index.html\");\n         }\n         _ => {\n-            url.push_str(shortty.as_str());\n-            url.push('.');\n-            url.push_str(fqp.last().unwrap());\n-            url.push_str(\".html\");\n+            filename = format!(\"{}.{}.html\", shortty.as_str(), last);\n+            url_parts.push(&filename);\n         }\n     }\n-    Some((url, shortty, fqp.to_vec()))\n+    Some((url_parts.join(\"/\"), shortty, fqp.to_vec()))\n+}\n+\n+/// Both paths should only be modules.\n+/// This is because modules get their own directories; that is, `std::vec` and `std::vec::Vec` will\n+/// both need `../iter/trait.Iterator.html` to get at the iterator trait.\n+crate fn href_relative_parts<'a>(fqp: &'a [String], relative_to_fqp: &'a [String]) -> Vec<&'a str> {\n+    for (i, (f, r)) in fqp.iter().zip(relative_to_fqp.iter()).enumerate() {\n+        // e.g. linking to std::iter from std::vec (`dissimilar_part_count` will be 1)\n+        if f != r {\n+            let dissimilar_part_count = relative_to_fqp.len() - i;\n+            let fqp_module = fqp[i..fqp.len()].iter().map(String::as_str);\n+            return std::iter::repeat(\"..\").take(dissimilar_part_count).chain(fqp_module).collect();\n+        }\n+    }\n+    // e.g. linking to std::sync::atomic from std::sync\n+    if relative_to_fqp.len() < fqp.len() {\n+        fqp[relative_to_fqp.len()..fqp.len()].iter().map(String::as_str).collect()\n+    // e.g. linking to std::sync from std::sync::atomic\n+    } else if fqp.len() < relative_to_fqp.len() {\n+        let dissimilar_part_count = relative_to_fqp.len() - fqp.len();\n+        std::iter::repeat(\"..\").take(dissimilar_part_count).collect()\n+    // linking to the same module\n+    } else {\n+        Vec::new()\n+    }\n }\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path<'a, 'tcx: 'a>(\n+fn resolved_path<'a, 'cx: 'a>(\n     w: &mut fmt::Formatter<'_>,\n     did: DefId,\n     path: &clean::Path,\n     print_all: bool,\n     use_absolute: bool,\n-    cache: &Cache,\n-    tcx: TyCtxt<'tcx>,\n+    cx: &'cx Context<'_>,\n ) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n \n@@ -512,22 +531,22 @@ fn resolved_path<'a, 'tcx: 'a>(\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{}{:#}\", &last.name, last.args.print(cache, tcx))?;\n+        write!(w, \"{}{:#}\", &last.name, last.args.print(cx))?;\n     } else {\n         let path = if use_absolute {\n-            if let Some((_, _, fqp)) = href(did, cache) {\n+            if let Some((_, _, fqp)) = href(did, cx) {\n                 format!(\n                     \"{}::{}\",\n                     fqp[..fqp.len() - 1].join(\"::\"),\n-                    anchor(did, fqp.last().unwrap(), cache)\n+                    anchor(did, fqp.last().unwrap(), cx)\n                 )\n             } else {\n                 last.name.to_string()\n             }\n         } else {\n-            anchor(did, &*last.name.as_str(), cache).to_string()\n+            anchor(did, &*last.name.as_str(), cx).to_string()\n         };\n-        write!(w, \"{}{}\", path, last.args.print(cache, tcx))?;\n+        write!(w, \"{}{}\", path, last.args.print(cx))?;\n     }\n     Ok(())\n }\n@@ -585,24 +604,28 @@ fn primitive_link(\n /// Helper to render type parameters\n fn tybounds<'a, 'tcx: 'a>(\n     param_names: &'a Option<Vec<clean::GenericBound>>,\n-    cache: &'a Cache,\n-    tcx: TyCtxt<'tcx>,\n+    cx: &'a Context<'tcx>,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n     display_fn(move |f| match *param_names {\n         Some(ref params) => {\n             for param in params {\n                 write!(f, \" + \")?;\n-                fmt::Display::fmt(&param.print(cache, tcx), f)?;\n+                fmt::Display::fmt(&param.print(cx), f)?;\n             }\n             Ok(())\n         }\n         None => Ok(()),\n     })\n }\n \n-crate fn anchor<'a>(did: DefId, text: &'a str, cache: &'a Cache) -> impl fmt::Display + 'a {\n+crate fn anchor<'a, 'cx: 'a>(\n+    did: DefId,\n+    text: &'a str,\n+    cx: &'cx Context<'_>,\n+) -> impl fmt::Display + 'a {\n+    let parts = href(did, cx);\n     display_fn(move |f| {\n-        if let Some((url, short_ty, fqp)) = href(did, cache) {\n+        if let Some((url, short_ty, fqp)) = parts {\n             write!(\n                 f,\n                 r#\"<a class=\"{}\" href=\"{}\" title=\"{} {}\">{}</a>\"#,\n@@ -618,12 +641,11 @@ crate fn anchor<'a>(did: DefId, text: &'a str, cache: &'a Cache) -> impl fmt::Di\n     })\n }\n \n-fn fmt_type(\n+fn fmt_type<'cx>(\n     t: &clean::Type,\n     f: &mut fmt::Formatter<'_>,\n     use_absolute: bool,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n+    cx: &'cx Context<'_>,\n ) -> fmt::Result {\n     debug!(\"fmt_type(t = {:?})\", t);\n \n@@ -634,69 +656,69 @@ fn fmt_type(\n                 f.write_str(\"dyn \")?;\n             }\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n-            resolved_path(f, did, path, is_generic, use_absolute, cache, tcx)?;\n-            fmt::Display::fmt(&tybounds(param_names, cache, tcx), f)\n+            resolved_path(f, did, path, is_generic, use_absolute, cx)?;\n+            fmt::Display::fmt(&tybounds(param_names, cx), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n-        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str(), cache),\n+        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str(), &cx.cache()),\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(\n                     f,\n                     \"{:#}{}{:#}fn{:#}\",\n-                    decl.print_hrtb_with_space(cache, tcx),\n+                    decl.print_hrtb_with_space(cx),\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi),\n-                    decl.decl.print(cache, tcx),\n+                    decl.decl.print(cx),\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"{}{}{}\",\n-                    decl.print_hrtb_with_space(cache, tcx),\n+                    decl.print_hrtb_with_space(cx),\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi)\n                 )?;\n-                primitive_link(f, PrimitiveType::Fn, \"fn\", cache)?;\n-                write!(f, \"{}\", decl.decl.print(cache, tcx))\n+                primitive_link(f, PrimitiveType::Fn, \"fn\", &cx.cache())?;\n+                write!(f, \"{}\", decl.decl.print(cx))\n             }\n         }\n         clean::Tuple(ref typs) => {\n             match &typs[..] {\n-                &[] => primitive_link(f, PrimitiveType::Unit, \"()\", cache),\n+                &[] => primitive_link(f, PrimitiveType::Unit, \"()\", &cx.cache()),\n                 &[ref one] => {\n-                    primitive_link(f, PrimitiveType::Tuple, \"(\", cache)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\", &cx.cache())?;\n                     // Carry `f.alternate()` into this display w/o branching manually.\n-                    fmt::Display::fmt(&one.print(cache, tcx), f)?;\n-                    primitive_link(f, PrimitiveType::Tuple, \",)\", cache)\n+                    fmt::Display::fmt(&one.print(cx), f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \",)\", &cx.cache())\n                 }\n                 many => {\n-                    primitive_link(f, PrimitiveType::Tuple, \"(\", cache)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\", &cx.cache())?;\n                     for (i, item) in many.iter().enumerate() {\n                         if i != 0 {\n                             write!(f, \", \")?;\n                         }\n-                        fmt::Display::fmt(&item.print(cache, tcx), f)?;\n+                        fmt::Display::fmt(&item.print(cx), f)?;\n                     }\n-                    primitive_link(f, PrimitiveType::Tuple, \")\", cache)\n+                    primitive_link(f, PrimitiveType::Tuple, \")\", &cx.cache())\n                 }\n             }\n         }\n         clean::Slice(ref t) => {\n-            primitive_link(f, PrimitiveType::Slice, \"[\", cache)?;\n-            fmt::Display::fmt(&t.print(cache, tcx), f)?;\n-            primitive_link(f, PrimitiveType::Slice, \"]\", cache)\n+            primitive_link(f, PrimitiveType::Slice, \"[\", &cx.cache())?;\n+            fmt::Display::fmt(&t.print(cx), f)?;\n+            primitive_link(f, PrimitiveType::Slice, \"]\", &cx.cache())\n         }\n         clean::Array(ref t, ref n) => {\n-            primitive_link(f, PrimitiveType::Array, \"[\", cache)?;\n-            fmt::Display::fmt(&t.print(cache, tcx), f)?;\n+            primitive_link(f, PrimitiveType::Array, \"[\", &cx.cache())?;\n+            fmt::Display::fmt(&t.print(cx), f)?;\n             if f.alternate() {\n-                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n), cache)\n+                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n), &cx.cache())\n             } else {\n-                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", Escape(n)), cache)\n+                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", Escape(n)), &cx.cache())\n             }\n         }\n-        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\", cache),\n+        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\", &cx.cache()),\n         clean::RawPointer(m, ref t) => {\n             let m = match m {\n                 hir::Mutability::Mut => \"mut\",\n@@ -708,15 +730,15 @@ fn fmt_type(\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n-                            &format!(\"*{} {:#}\", m, t.print(cache, tcx)),\n-                            cache,\n+                            &format!(\"*{} {:#}\", m, t.print(cx)),\n+                            &cx.cache(),\n                         )\n                     } else {\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n-                            &format!(\"*{} {}\", m, t.print(cache, tcx)),\n-                            cache,\n+                            &format!(\"*{} {}\", m, t.print(cx)),\n+                            &cx.cache(),\n                         )\n                     }\n                 }\n@@ -725,9 +747,9 @@ fn fmt_type(\n                         f,\n                         clean::PrimitiveType::RawPointer,\n                         &format!(\"*{} \", m),\n-                        cache,\n+                        &cx.cache(),\n                     )?;\n-                    fmt::Display::fmt(&t.print(cache, tcx), f)\n+                    fmt::Display::fmt(&t.print(cx), f)\n                 }\n             }\n         }\n@@ -747,15 +769,15 @@ fn fmt_type(\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print(cache, tcx)),\n-                                    cache,\n+                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print(cx)),\n+                                    &cx.cache(),\n                                 )\n                             } else {\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print(cache, tcx)),\n-                                    cache,\n+                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print(cx)),\n+                                    &cx.cache(),\n                                 )\n                             }\n                         }\n@@ -764,42 +786,42 @@ fn fmt_type(\n                                 f,\n                                 PrimitiveType::Slice,\n                                 &format!(\"{}{}{}[\", amp, lt, m),\n-                                cache,\n+                                &cx.cache(),\n                             )?;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", bt.print(cache, tcx))?;\n+                                write!(f, \"{:#}\", bt.print(cx))?;\n                             } else {\n-                                write!(f, \"{}\", bt.print(cache, tcx))?;\n+                                write!(f, \"{}\", bt.print(cx))?;\n                             }\n-                            primitive_link(f, PrimitiveType::Slice, \"]\", cache)\n+                            primitive_link(f, PrimitiveType::Slice, \"]\", &cx.cache())\n                         }\n                     }\n                 }\n                 clean::ResolvedPath { param_names: Some(ref v), .. } if !v.is_empty() => {\n                     write!(f, \"{}{}{}(\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute, cache, tcx)?;\n+                    fmt_type(&ty, f, use_absolute, cx)?;\n                     write!(f, \")\")\n                 }\n                 clean::Generic(..) => {\n                     primitive_link(\n                         f,\n                         PrimitiveType::Reference,\n                         &format!(\"{}{}{}\", amp, lt, m),\n-                        cache,\n+                        &cx.cache(),\n                     )?;\n-                    fmt_type(&ty, f, use_absolute, cache, tcx)\n+                    fmt_type(&ty, f, use_absolute, cx)\n                 }\n                 _ => {\n                     write!(f, \"{}{}{}\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute, cache, tcx)\n+                    fmt_type(&ty, f, use_absolute, cx)\n                 }\n             }\n         }\n         clean::ImplTrait(ref bounds) => {\n             if f.alternate() {\n-                write!(f, \"impl {:#}\", print_generic_bounds(bounds, cache, tcx))\n+                write!(f, \"impl {:#}\", print_generic_bounds(bounds, cx))\n             } else {\n-                write!(f, \"impl {}\", print_generic_bounds(bounds, cache, tcx))\n+                write!(f, \"impl {}\", print_generic_bounds(bounds, cx))\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n@@ -811,25 +833,15 @@ fn fmt_type(\n             };\n             if f.alternate() {\n                 if should_show_cast {\n-                    write!(\n-                        f,\n-                        \"<{:#} as {:#}>::\",\n-                        self_type.print(cache, tcx),\n-                        trait_.print(cache, tcx)\n-                    )?\n+                    write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n-                    write!(f, \"{:#}::\", self_type.print(cache, tcx))?\n+                    write!(f, \"{:#}::\", self_type.print(cx))?\n                 }\n             } else {\n                 if should_show_cast {\n-                    write!(\n-                        f,\n-                        \"&lt;{} as {}&gt;::\",\n-                        self_type.print(cache, tcx),\n-                        trait_.print(cache, tcx)\n-                    )?\n+                    write!(f, \"&lt;{} as {}&gt;::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n-                    write!(f, \"{}::\", self_type.print(cache, tcx))?\n+                    write!(f, \"{}::\", self_type.print(cx))?\n                 }\n             };\n             match *trait_ {\n@@ -844,7 +856,7 @@ fn fmt_type(\n                 //        everything comes in as a fully resolved QPath (hard to\n                 //        look at).\n                 box clean::ResolvedPath { did, ref param_names, .. } => {\n-                    match href(did, cache) {\n+                    match href(did, cx) {\n                         Some((ref url, _, ref path)) if !f.alternate() => {\n                             write!(\n                                 f,\n@@ -872,42 +884,40 @@ fn fmt_type(\n impl clean::Type {\n     crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'b + Captures<'tcx> {\n-        display_fn(move |f| fmt_type(self, f, false, cache, tcx))\n+        display_fn(move |f| fmt_type(self, f, false, cx))\n     }\n }\n \n impl clean::Impl {\n     crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n         use_absolute: bool,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if f.alternate() {\n-                write!(f, \"impl{:#} \", self.generics.print(cache, tcx))?;\n+                write!(f, \"impl{:#} \", self.generics.print(cx))?;\n             } else {\n-                write!(f, \"impl{} \", self.generics.print(cache, tcx))?;\n+                write!(f, \"impl{} \", self.generics.print(cx))?;\n             }\n \n             if let Some(ref ty) = self.trait_ {\n                 if self.negative_polarity {\n                     write!(f, \"!\")?;\n                 }\n-                fmt::Display::fmt(&ty.print(cache, tcx), f)?;\n+                fmt::Display::fmt(&ty.print(cx), f)?;\n                 write!(f, \" for \")?;\n             }\n \n             if let Some(ref ty) = self.blanket_impl {\n-                fmt_type(ty, f, use_absolute, cache, tcx)?;\n+                fmt_type(ty, f, use_absolute, cx)?;\n             } else {\n-                fmt_type(&self.for_, f, use_absolute, cache, tcx)?;\n+                fmt_type(&self.for_, f, use_absolute, cx)?;\n             }\n \n-            fmt::Display::fmt(&print_where_clause(&self.generics, cache, tcx, 0, true), f)?;\n+            fmt::Display::fmt(&print_where_clause(&self.generics, cx, 0, true), f)?;\n             Ok(())\n         })\n     }\n@@ -916,18 +926,17 @@ impl clean::Impl {\n impl clean::Arguments {\n     crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             for (i, input) in self.values.iter().enumerate() {\n                 if !input.name.is_empty() {\n                     write!(f, \"{}: \", input.name)?;\n                 }\n                 if f.alternate() {\n-                    write!(f, \"{:#}\", input.type_.print(cache, tcx))?;\n+                    write!(f, \"{:#}\", input.type_.print(cx))?;\n                 } else {\n-                    write!(f, \"{}\", input.type_.print(cache, tcx))?;\n+                    write!(f, \"{}\", input.type_.print(cx))?;\n                 }\n                 if i + 1 < self.values.len() {\n                     write!(f, \", \")?;\n@@ -941,13 +950,14 @@ impl clean::Arguments {\n impl clean::FnRetTy {\n     crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print(cache, tcx)),\n-            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cache, tcx)),\n+            clean::Return(ty) if f.alternate() => {\n+                write!(f, \" -> {:#}\", ty.print(cx))\n+            }\n+            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cx)),\n             clean::DefaultReturn => Ok(()),\n         })\n     }\n@@ -956,16 +966,11 @@ impl clean::FnRetTy {\n impl clean::BareFunctionDecl {\n     fn print_hrtb_with_space<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n-                write!(\n-                    f,\n-                    \"for<{}> \",\n-                    comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n-                )\n+                write!(f, \"for<{}> \", comma_sep(self.generic_params.iter().map(|g| g.print(cx))))\n             } else {\n                 Ok(())\n             }\n@@ -976,26 +981,25 @@ impl clean::BareFunctionDecl {\n impl clean::FnDecl {\n     crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'b + Captures<'tcx> {\n         display_fn(move |f| {\n             let ellipsis = if self.c_variadic { \", ...\" } else { \"\" };\n             if f.alternate() {\n                 write!(\n                     f,\n                     \"({args:#}{ellipsis}){arrow:#}\",\n-                    args = self.inputs.print(cache, tcx),\n+                    args = self.inputs.print(cx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cache, tcx)\n+                    arrow = self.output.print(cx)\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"({args}{ellipsis}){arrow}\",\n-                    args = self.inputs.print(cache, tcx),\n+                    args = self.inputs.print(cx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cache, tcx)\n+                    arrow = self.output.print(cx)\n                 )\n             }\n         })\n@@ -1007,25 +1011,23 @@ impl clean::FnDecl {\n     /// * `indent`: The number of spaces to indent each successive line with, if line-wrapping is\n     ///   necessary.\n     /// * `asyncness`: Whether the function is async or not.\n-    crate fn full_print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn full_print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n         header_len: usize,\n         indent: usize,\n         asyncness: hir::IsAsync,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n-        display_fn(move |f| self.inner_full_print(cache, tcx, header_len, indent, asyncness, f))\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        display_fn(move |f| self.inner_full_print(header_len, indent, asyncness, f, cx))\n     }\n \n     fn inner_full_print(\n         &self,\n-        cache: &Cache,\n-        tcx: TyCtxt<'_>,\n         header_len: usize,\n         indent: usize,\n         asyncness: hir::IsAsync,\n         f: &mut fmt::Formatter<'_>,\n+        cx: &Context<'_>,\n     ) -> fmt::Result {\n         let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n         let mut args = String::new();\n@@ -1060,11 +1062,11 @@ impl clean::FnDecl {\n                     }\n                     clean::SelfExplicit(ref typ) => {\n                         if f.alternate() {\n-                            args.push_str(&format!(\"self: {:#}\", typ.print(cache, tcx)));\n+                            args.push_str(&format!(\"self: {:#}\", typ.print(cx)));\n                         } else {\n-                            args.push_str(&format!(\"self: {}\", typ.print(cache, tcx)));\n+                            args.push_str(&format!(\"self: {}\", typ.print(cx)));\n                         }\n-                        args_plain.push_str(&format!(\"self: {:#}\", typ.print(cache, tcx)));\n+                        args_plain.push_str(&format!(\"self: {:#}\", typ.print(cx)));\n                     }\n                 }\n             } else {\n@@ -1078,11 +1080,11 @@ impl clean::FnDecl {\n                 }\n \n                 if f.alternate() {\n-                    args.push_str(&format!(\"{:#}\", input.type_.print(cache, tcx)));\n+                    args.push_str(&format!(\"{:#}\", input.type_.print(cx)));\n                 } else {\n-                    args.push_str(&input.type_.print(cache, tcx).to_string());\n+                    args.push_str(&input.type_.print(cx).to_string());\n                 }\n-                args_plain.push_str(&format!(\"{:#}\", input.type_.print(cache, tcx)));\n+                args_plain.push_str(&format!(\"{:#}\", input.type_.print(cx)));\n             }\n             if i + 1 < self.inputs.values.len() {\n                 args.push(',');\n@@ -1100,19 +1102,11 @@ impl clean::FnDecl {\n         let arrow_plain;\n         let arrow = if let hir::IsAsync::Async = asyncness {\n             let output = self.sugared_async_return_type();\n-            arrow_plain = format!(\"{:#}\", output.print(cache, tcx));\n-            if f.alternate() {\n-                arrow_plain.clone()\n-            } else {\n-                format!(\"{}\", output.print(cache, tcx))\n-            }\n+            arrow_plain = format!(\"{:#}\", output.print(cx));\n+            if f.alternate() { arrow_plain.clone() } else { format!(\"{}\", output.print(cx)) }\n         } else {\n-            arrow_plain = format!(\"{:#}\", self.output.print(cache, tcx));\n-            if f.alternate() {\n-                arrow_plain.clone()\n-            } else {\n-                format!(\"{}\", self.output.print(cache, tcx))\n-            }\n+            arrow_plain = format!(\"{:#}\", self.output.print(cx));\n+            if f.alternate() { arrow_plain.clone() } else { format!(\"{}\", self.output.print(cx)) }\n         };\n \n         let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n@@ -1140,9 +1134,8 @@ impl clean::FnDecl {\n impl clean::Visibility {\n     crate fn print_with_space<'a, 'tcx: 'a>(\n         self,\n-        tcx: TyCtxt<'tcx>,\n         item_did: DefId,\n-        cache: &'a Cache,\n+        cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         let to_print = match self {\n             clean::Public => \"pub \".to_owned(),\n@@ -1151,7 +1144,7 @@ impl clean::Visibility {\n                 // FIXME(camelid): This may not work correctly if `item_did` is a module.\n                 //                 However, rustdoc currently never displays a module's\n                 //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(tcx, item_did);\n+                let parent_module = find_nearest_parent_module(cx.tcx(), item_did);\n \n                 if vis_did.index == CRATE_DEF_INDEX {\n                     \"pub(crate) \".to_owned()\n@@ -1160,17 +1153,17 @@ impl clean::Visibility {\n                     // is the same as no visibility modifier\n                     String::new()\n                 } else if parent_module\n-                    .map(|parent| find_nearest_parent_module(tcx, parent))\n+                    .map(|parent| find_nearest_parent_module(cx.tcx(), parent))\n                     .flatten()\n                     == Some(vis_did)\n                 {\n                     \"pub(super) \".to_owned()\n                 } else {\n-                    let path = tcx.def_path(vis_did);\n+                    let path = cx.tcx().def_path(vis_did);\n                     debug!(\"path={:?}\", path);\n                     // modified from `resolved_path()` to work with `DefPathData`\n                     let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                    let anchor = anchor(vis_did, &last_name.as_str(), cache).to_string();\n+                    let anchor = anchor(vis_did, &last_name.as_str(), cx).to_string();\n \n                     let mut s = \"pub(in \".to_owned();\n                     for seg in &path.data[..path.data.len() - 1] {\n@@ -1263,45 +1256,43 @@ impl PrintWithSpace for hir::Mutability {\n }\n \n impl clean::Import {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self.kind {\n             clean::ImportKind::Simple(name) => {\n                 if name == self.source.path.last() {\n-                    write!(f, \"use {};\", self.source.print(cache, tcx))\n+                    write!(f, \"use {};\", self.source.print(cx))\n                 } else {\n-                    write!(f, \"use {} as {};\", self.source.print(cache, tcx), name)\n+                    write!(f, \"use {} as {};\", self.source.print(cx), name)\n                 }\n             }\n             clean::ImportKind::Glob => {\n                 if self.source.path.segments.is_empty() {\n                     write!(f, \"use *;\")\n                 } else {\n-                    write!(f, \"use {}::*;\", self.source.print(cache, tcx))\n+                    write!(f, \"use {}::*;\", self.source.print(cx))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::ImportSource {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false, cache, tcx),\n+            Some(did) => resolved_path(f, did, &self.path, true, false, cx),\n             _ => {\n                 for seg in &self.path.segments[..self.path.segments.len() - 1] {\n                     write!(f, \"{}::\", seg.name)?;\n                 }\n                 let name = self.path.last_name();\n                 if let hir::def::Res::PrimTy(p) = self.path.res {\n-                    primitive_link(f, PrimitiveType::from(p), &*name, cache)?;\n+                    primitive_link(f, PrimitiveType::from(p), &*name, &cx.cache())?;\n                 } else {\n                     write!(f, \"{}\", name)?;\n                 }\n@@ -1312,27 +1303,26 @@ impl clean::ImportSource {\n }\n \n impl clean::TypeBinding {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             f.write_str(&*self.name.as_str())?;\n             match self.kind {\n                 clean::TypeBindingKind::Equality { ref ty } => {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print(cache, tcx))?;\n+                        write!(f, \" = {:#}\", ty.print(cx))?;\n                     } else {\n-                        write!(f, \" = {}\", ty.print(cache, tcx))?;\n+                        write!(f, \" = {}\", ty.print(cx))?;\n                     }\n                 }\n                 clean::TypeBindingKind::Constraint { ref bounds } => {\n                     if !bounds.is_empty() {\n                         if f.alternate() {\n-                            write!(f, \": {:#}\", print_generic_bounds(bounds, cache, tcx))?;\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds, cx))?;\n                         } else {\n-                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache, tcx))?;\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cx))?;\n                         }\n                     }\n                 }\n@@ -1357,15 +1347,14 @@ crate fn print_default_space<'a>(v: bool) -> &'a str {\n }\n \n impl clean::GenericArg {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::GenericArg::Lifetime(lt) => fmt::Display::fmt(&lt.print(), f),\n-            clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(cache, tcx), f),\n-            clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(tcx), f),\n+            clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(cx), f),\n+            clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(cx.tcx()), f),\n         })\n     }\n }"}, {"sha": "dc67a63d333991643b6b815f0ebc70f3c91a8703", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -113,7 +113,8 @@ crate fn render<T: Print, S: Print>(\n     <section class=\\\"footer\\\"></section>\\\n     {after_content}\\\n     <div id=\\\"rustdoc-vars\\\" data-root-path=\\\"{root_path}\\\" data-current-crate=\\\"{krate}\\\" \\\n-       data-search-js=\\\"{root_path}search-index{suffix}.js\\\"></div>\n+       data-search-index-js=\\\"{root_path}search-index{suffix}.js\\\" \\\n+       data-search-js=\\\"{static_root_path}search{suffix}.js\\\"></div>\n     <script src=\\\"{static_root_path}main{suffix}.js\\\"></script>\\\n     {extra_scripts}\\\n </body>\\"}, {"sha": "60ebdf5690d0d2aa9fffa476f38826a454767545", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -8,3 +8,6 @@ crate mod render;\n crate mod sources;\n crate mod static_files;\n crate mod toc;\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "d866cf4f4cf046dc9c7255fb2187aa89569e56da", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -40,7 +40,7 @@ use crate::html::{layout, sources};\n crate struct Context<'tcx> {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub(super) current: Vec<String>,\n+    pub(crate) current: Vec<String>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub(super) dst: PathBuf,\n@@ -144,10 +144,14 @@ impl SharedContext<'_> {\n }\n \n impl<'tcx> Context<'tcx> {\n-    pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n+    pub(crate) fn tcx(&self) -> TyCtxt<'tcx> {\n         self.shared.tcx\n     }\n \n+    pub(crate) fn cache(&self) -> &Cache {\n+        &self.cache\n+    }\n+\n     fn sess(&self) -> &'tcx Session {\n         &self.shared.tcx.sess\n     }"}, {"sha": "d10b612a7379992234fcd7bffa2569499002ad25", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 58, "deletions": 87, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -51,7 +51,6 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{kw, sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n@@ -61,7 +60,7 @@ use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n-use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n+use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n     href, print_abi_with_space, print_default_space, print_generic_bounds, print_where_clause,\n@@ -560,11 +559,10 @@ fn document_short(\n         return;\n     }\n     if let Some(s) = item.doc_value() {\n-        let mut summary_html = MarkdownSummaryLine(&s, &item.links(&cx.cache)).into_string();\n+        let mut summary_html = MarkdownSummaryLine(&s, &item.links(cx)).into_string();\n \n         if s.contains('\\n') {\n-            let link =\n-                format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link, cx.cache()));\n+            let link = format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link, cx));\n \n             if let Some(idx) = summary_html.rfind(\"</p>\") {\n                 summary_html.insert_str(idx, &link);\n@@ -599,7 +597,7 @@ fn document_full(\n ) {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        render_markdown(w, cx, &*s, item.links(&cx.cache), prefix, is_hidden);\n+        render_markdown(w, cx, &*s, item.links(cx), prefix, is_hidden);\n     } else if !prefix.is_empty() {\n         if is_hidden {\n             w.write_str(\"<div class=\\\"docblock hidden\\\">\");\n@@ -785,7 +783,7 @@ fn render_impls(\n     w.write_str(&impls.join(\"\"));\n }\n \n-fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cache: &Cache) -> String {\n+fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>) -> String {\n     use crate::formats::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n@@ -799,7 +797,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cache: &Cache) ->\n         AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n         AssocItemLink::Anchor(None) => anchor,\n         AssocItemLink::GotoSource(did, _) => {\n-            href(did, cache).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            href(did, cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n         }\n     }\n }\n@@ -813,16 +811,14 @@ fn assoc_const(\n     extra: &str,\n     cx: &Context<'_>,\n ) {\n-    let cache = cx.cache();\n-    let tcx = cx.tcx();\n     write!(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(tcx, it.def_id, cache),\n-        naive_assoc_href(it, link, cache),\n+        it.visibility.print_with_space(it.def_id, cx),\n+        naive_assoc_href(it, link, cx),\n         it.name.as_ref().unwrap(),\n-        ty.print(cache, tcx)\n+        ty.print(cx)\n     );\n }\n \n@@ -833,21 +829,20 @@ fn assoc_type(\n     default: Option<&clean::Type>,\n     link: AssocItemLink<'_>,\n     extra: &str,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n+    cx: &Context<'_>,\n ) {\n     write!(\n         w,\n         \"{}type <a href=\\\"{}\\\" class=\\\"type\\\">{}</a>\",\n         extra,\n-        naive_assoc_href(it, link, cache),\n+        naive_assoc_href(it, link, cx),\n         it.name.as_ref().unwrap()\n     );\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", print_generic_bounds(bounds, cache, tcx))\n+        write!(w, \": {}\", print_generic_bounds(bounds, cx))\n     }\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default.print(cache, tcx))\n+        write!(w, \" = {}\", default.print(cx))\n     }\n }\n \n@@ -897,8 +892,6 @@ fn render_assoc_item(\n         parent: ItemType,\n         cx: &Context<'_>,\n     ) {\n-        let cache = cx.cache();\n-        let tcx = cx.tcx();\n         let name = meth.name.as_ref().unwrap();\n         let href = match link {\n             AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n@@ -912,19 +905,19 @@ fn render_assoc_item(\n                     ItemType::TyMethod\n                 };\n \n-                href(did, cache)\n+                href(did, cx)\n                     .map(|p| format!(\"{}#{}.{}\", p.0, ty, name))\n                     .unwrap_or_else(|| format!(\"#{}.{}\", ty, name))\n             }\n         };\n-        let vis = meth.visibility.print_with_space(tcx, meth.def_id, cache).to_string();\n+        let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n         let constness = header.constness.print_with_space();\n         let asyncness = header.asyncness.print_with_space();\n         let unsafety = header.unsafety.print_with_space();\n         let defaultness = print_default_space(meth.is_default());\n         let abi = print_abi_with_space(header.abi).to_string();\n         // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n-        let generics_len = format!(\"{:#}\", g.print(cache, tcx)).len();\n+        let generics_len = format!(\"{:#}\", g.print(cx)).len();\n         let mut header_len = \"fn \".len()\n             + vis.len()\n             + constness.len()\n@@ -958,10 +951,10 @@ fn render_assoc_item(\n             abi,\n             href = href,\n             name = name,\n-            generics = g.print(cache, tcx),\n-            decl = d.full_print(cache, tcx, header_len, indent, header.asyncness),\n-            notable_traits = notable_traits_decl(&d, cache, tcx),\n-            where_clause = print_where_clause(g, cache, tcx, indent, end_newline),\n+            generics = g.print(cx),\n+            decl = d.full_print(header_len, indent, header.asyncness, cx),\n+            notable_traits = notable_traits_decl(&d, cx),\n+            where_clause = print_where_clause(g, cx, indent, end_newline),\n         )\n     }\n     match *item.kind {\n@@ -988,8 +981,7 @@ fn render_assoc_item(\n             default.as_ref(),\n             link,\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n-            cx.cache(),\n-            cx.tcx(),\n+            cx,\n         ),\n         _ => panic!(\"render_assoc_item called on non-associated-item\"),\n     }\n@@ -1076,11 +1068,9 @@ fn render_assoc_items(\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n-                let id = cx.derive_id(small_url_encode(format!(\n-                    \"deref-methods-{:#}\",\n-                    type_.print(cache, tcx)\n-                )));\n-                debug!(\"Adding {} to deref id map\", type_.print(cache, tcx));\n+                let id =\n+                    cx.derive_id(small_url_encode(format!(\"deref-methods-{:#}\", type_.print(cx))));\n+                debug!(\"Adding {} to deref id map\", type_.print(cx));\n                 cx.deref_id_map.borrow_mut().insert(type_.def_id_full(cache).unwrap(), id.clone());\n                 write!(\n                     w,\n@@ -1089,8 +1079,8 @@ fn render_assoc_items(\n                          <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n                     id = id,\n-                    trait_ = trait_.print(cache, tcx),\n-                    type_ = type_.print(cache, tcx),\n+                    trait_ = trait_.print(cx),\n+                    type_ = type_.print(cx),\n                 );\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n@@ -1242,36 +1232,34 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bo\n     }\n }\n \n-fn notable_traits_decl(decl: &clean::FnDecl, cache: &Cache, tcx: TyCtxt<'_>) -> String {\n+fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n     let mut out = Buffer::html();\n     let mut trait_ = String::new();\n \n-    if let Some(did) = decl.output.def_id_full(cache) {\n-        if let Some(impls) = cache.impls.get(&did) {\n+    if let Some(did) = decl.output.def_id_full(cx.cache()) {\n+        if let Some(impls) = cx.cache().impls.get(&did) {\n             for i in impls {\n                 let impl_ = i.inner_impl();\n-                if impl_\n-                    .trait_\n-                    .def_id()\n-                    .map_or(false, |d| cache.traits.get(&d).map(|t| t.is_notable).unwrap_or(false))\n-                {\n+                if impl_.trait_.def_id().map_or(false, |d| {\n+                    cx.cache().traits.get(&d).map(|t| t.is_notable).unwrap_or(false)\n+                }) {\n                     if out.is_empty() {\n                         write!(\n                             &mut out,\n                             \"<h3 class=\\\"notable\\\">Notable traits for {}</h3>\\\n                              <code class=\\\"content\\\">\",\n-                            impl_.for_.print(cache, tcx)\n+                            impl_.for_.print(cx)\n                         );\n-                        trait_.push_str(&impl_.for_.print(cache, tcx).to_string());\n+                        trait_.push_str(&impl_.for_.print(cx).to_string());\n                     }\n \n                     //use the \"where\" class here to make it small\n                     write!(\n                         &mut out,\n                         \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                        impl_.print(cache, false, tcx)\n+                        impl_.print(false, cx)\n                     );\n-                    let t_did = impl_.trait_.def_id_full(cache).unwrap();\n+                    let t_did = impl_.trait_.def_id_full(cx.cache()).unwrap();\n                     for it in &impl_.items {\n                         if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                             out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n@@ -1282,8 +1270,7 @@ fn notable_traits_decl(decl: &clean::FnDecl, cache: &Cache, tcx: TyCtxt<'_>) ->\n                                 Some(&tydef.type_),\n                                 AssocItemLink::GotoSource(t_did, &FxHashSet::default()),\n                                 \"\",\n-                                cache,\n-                                tcx,\n+                                cx,\n                             );\n                             out.push_str(\";</span>\");\n                         }\n@@ -1322,18 +1309,18 @@ fn render_impl(\n     // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n     aliases: &[String],\n ) {\n-    let traits = &cx.cache.traits;\n     let tcx = cx.tcx();\n     let cache = cx.cache();\n+    let traits = &cache.traits;\n     let trait_ = i.trait_did_full(cache).map(|did| &traits[&did]);\n \n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => {\n                 if is_on_foreign_type {\n-                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cache, tcx)\n+                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx)\n                 } else {\n-                    format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cache, tcx))))\n+                    format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cx))))\n                 }\n             }\n             None => \"impl\".to_string(),\n@@ -1345,7 +1332,7 @@ fn render_impl(\n         };\n         if let Some(use_absolute) = use_absolute {\n             write!(w, \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">\", id, aliases);\n-            write!(w, \"{}\", i.inner_impl().print(cache, use_absolute, tcx));\n+            write!(w, \"{}\", i.inner_impl().print(use_absolute, cx));\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n                     if let clean::TypedefItem(ref tydef, _) = *it.kind {\n@@ -1357,8 +1344,7 @@ fn render_impl(\n                             Some(&tydef.type_),\n                             AssocItemLink::Anchor(None),\n                             \"\",\n-                            cache,\n-                            tcx,\n+                            cx,\n                         );\n                         w.write_str(\";</span>\");\n                     }\n@@ -1371,7 +1357,7 @@ fn render_impl(\n                 \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">{}</code>\",\n                 id,\n                 aliases,\n-                i.inner_impl().print(cache, false, tcx)\n+                i.inner_impl().print(false, cx)\n             );\n         }\n         write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n@@ -1398,7 +1384,7 @@ fn render_impl(\n                 \"<div class=\\\"docblock\\\">{}</div>\",\n                 Markdown(\n                     &*dox,\n-                    &i.impl_item.links(&cx.cache),\n+                    &i.impl_item.links(cx),\n                     &mut ids,\n                     cx.shared.codes,\n                     cx.shared.edition,\n@@ -1495,8 +1481,7 @@ fn render_impl(\n                     Some(&tydef.type_),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n                     \"\",\n-                    cx.cache(),\n-                    tcx,\n+                    cx,\n                 );\n                 w.write_str(\"</code>\");\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n@@ -1546,8 +1531,7 @@ fn render_impl(\n                     default.as_ref(),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n                     \"\",\n-                    cx.cache(),\n-                    tcx,\n+                    cx,\n                 );\n                 w.write_str(\"</code>\");\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n@@ -1853,7 +1837,6 @@ fn small_url_encode(s: String) -> String {\n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     if let Some(v) = cx.cache.impls.get(&it.def_id) {\n         let mut used_links = FxHashSet::default();\n-        let tcx = cx.tcx();\n         let cache = cx.cache();\n \n         {\n@@ -1888,9 +1871,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                     .iter()\n                     .filter_map(|it| {\n                         if let Some(ref i) = it.inner_impl().trait_ {\n-                            let i_display = format!(\"{:#}\", i.print(cache, tcx));\n+                            let i_display = format!(\"{:#}\", i.print(cx));\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(format!(\"{:#}\", i.print(cache, tcx)));\n+                            let encoded = small_url_encode(format!(\"{:#}\", i.print(cx)));\n                             let generated = format!(\n                                 \"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                 encoded,\n@@ -1962,7 +1945,6 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n \n fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &Vec<Impl>) {\n     let c = cx.cache();\n-    let tcx = cx.tcx();\n \n     debug!(\"found Deref: {:?}\", impl_);\n     if let Some((target, real_target)) =\n@@ -2011,11 +1993,8 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                     out,\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a>\",\n                     id,\n-                    Escape(&format!(\n-                        \"{:#}\",\n-                        impl_.inner_impl().trait_.as_ref().unwrap().print(c, tcx)\n-                    )),\n-                    Escape(&format!(\"{:#}\", real_target.print(c, tcx))),\n+                    Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(cx))),\n+                    Escape(&format!(\"{:#}\", real_target.print(cx))),\n                 );\n                 // We want links' order to be reproducible so we don't use unstable sort.\n                 ret.sort();\n@@ -2071,27 +2050,20 @@ fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clea\n fn get_id_for_impl_on_foreign_type(\n     for_: &clean::Type,\n     trait_: &clean::Type,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n+    cx: &Context<'_>,\n ) -> String {\n-    small_url_encode(format!(\n-        \"impl-{:#}-for-{:#}\",\n-        trait_.print(cache, tcx),\n-        for_.print(cache, tcx)\n-    ))\n+    small_url_encode(format!(\"impl-{:#}-for-{:#}\", trait_.print(cx), for_.print(cx),))\n }\n \n-fn extract_for_impl_name(\n-    item: &clean::Item,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n-) -> Option<(String, String)> {\n+fn extract_for_impl_name(item: &clean::Item, cx: &Context<'_>) -> Option<(String, String)> {\n     match *item.kind {\n         clean::ItemKind::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n+                // Alternative format produces no URLs,\n+                // so this parameter does nothing.\n                 Some((\n-                    format!(\"{:#}\", i.for_.print(cache, tcx)),\n-                    get_id_for_impl_on_foreign_type(&i.for_, trait_, cache, tcx),\n+                    format!(\"{:#}\", i.for_.print(cx)),\n+                    get_id_for_impl_on_foreign_type(&i.for_, trait_, cx),\n                 ))\n             } else {\n                 None\n@@ -2172,7 +2144,6 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n \n     if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         let cache = cx.cache();\n-        let tcx = cx.tcx();\n         let mut res = implementors\n             .iter()\n             .filter(|i| {\n@@ -2181,7 +2152,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n                     .def_id_full(cache)\n                     .map_or(false, |d| !cx.cache.paths.contains_key(&d))\n             })\n-            .filter_map(|i| extract_for_impl_name(&i.impl_item, cache, tcx))\n+            .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n             .collect::<Vec<_>>();\n \n         if !res.is_empty() {"}, {"sha": "42b795030171bef143f38bbf187ad2a97452947d", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 63, "deletions": 74, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -15,9 +15,8 @@ use super::{\n     render_impl, render_stability_since_raw, write_srclink, AssocItemLink, Context,\n };\n use crate::clean::{self, GetDefId};\n-use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n-use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n+use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{print_abi_with_space, print_where_clause, Buffer, PrintWithSpace};\n use crate::html::highlight;\n@@ -268,15 +267,15 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                        anchor(myitem.def_id, &*src.as_str(), cx.cache()),\n+                        myitem.visibility.print_with_space(myitem.def_id, cx),\n+                        anchor(myitem.def_id, &*src.as_str(), cx),\n                         myitem.name.as_ref().unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                        anchor(myitem.def_id, &*myitem.name.as_ref().unwrap().as_str(), cx.cache()),\n+                        myitem.visibility.print_with_space(myitem.def_id, cx),\n+                        anchor(myitem.def_id, &*myitem.name.as_ref().unwrap().as_str(), cx),\n                     ),\n                 }\n                 w.write_str(\"</code></td></tr>\");\n@@ -286,8 +285,8 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 write!(\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                    import.print(cx.cache(), cx.tcx()),\n+                    myitem.visibility.print_with_space(myitem.def_id, cx),\n+                    import.print(cx),\n                 );\n             }\n \n@@ -318,7 +317,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                      </tr>\",\n                     name = *myitem.name.as_ref().unwrap(),\n                     stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n-                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(&cx.cache)).into_string(),\n+                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(cx)).into_string(),\n                     class = myitem.type_(),\n                     add = add,\n                     stab = stab.unwrap_or_else(String::new),\n@@ -387,13 +386,13 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.visibility.print_with_space(it.def_id, cx),\n         f.header.constness.print_with_space(),\n         f.header.asyncness.print_with_space(),\n         f.header.unsafety.print_with_space(),\n         print_abi_with_space(f.header.abi),\n         it.name.as_ref().unwrap(),\n-        f.generics.print(cx.cache(), cx.tcx())\n+        f.generics.print(cx),\n     )\n     .len();\n     w.write_str(\"<pre class=\\\"rust fn\\\">\");\n@@ -402,22 +401,22 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         w,\n         \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n          {name}{generics}{decl}{notable_traits}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        vis = it.visibility.print_with_space(it.def_id, cx),\n         constness = f.header.constness.print_with_space(),\n         asyncness = f.header.asyncness.print_with_space(),\n         unsafety = f.header.unsafety.print_with_space(),\n         abi = print_abi_with_space(f.header.abi),\n         name = it.name.as_ref().unwrap(),\n-        generics = f.generics.print(cx.cache(), cx.tcx()),\n-        where_clause = print_where_clause(&f.generics, cx.cache(), cx.tcx(), 0, true),\n-        decl = f.decl.full_print(cx.cache(), cx.tcx(), header_len, 0, f.header.asyncness),\n-        notable_traits = notable_traits_decl(&f.decl, cx.cache(), cx.tcx()),\n+        generics = f.generics.print(cx),\n+        where_clause = print_where_clause(&f.generics, cx, 0, true),\n+        decl = f.decl.full_print(header_len, 0, f.header.asyncness, cx),\n+        notable_traits = notable_traits_decl(&f.decl, cx),\n     );\n     document(w, cx, it, None)\n }\n \n fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n-    let bounds = bounds(&t.bounds, false, cx.cache(), cx.tcx());\n+    let bounds = bounds(&t.bounds, false, cx);\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n     let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n@@ -430,16 +429,16 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            it.visibility.print_with_space(it.def_id, cx),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n-            t.generics.print(cx.cache(), cx.tcx()),\n+            t.generics.print(cx),\n             bounds\n         );\n \n         if !t.generics.where_predicates.is_empty() {\n-            write!(w, \"{}\", print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true));\n+            write!(w, \"{}\", print_where_clause(&t.generics, cx, 0, true));\n         } else {\n             w.write_str(\" \");\n         }\n@@ -634,8 +633,8 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             local.iter().partition(|i| i.inner_impl().synthetic);\n \n-        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache(), cx.tcx()));\n-        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache(), cx.tcx()));\n+        synthetic.sort_by(|a, b| compare_impl(a, b, cx));\n+        concrete.sort_by(|a, b| compare_impl(a, b, cx));\n \n         if !foreign.is_empty() {\n             write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n@@ -740,9 +739,9 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n         w,\n         \"trait {}{}{} = {};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache(), cx.tcx()),\n-        print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n-        bounds(&t.bounds, true, cx.cache(), cx.tcx())\n+        t.generics.print(cx),\n+        print_where_clause(&t.generics, cx, 0, true),\n+        bounds(&t.bounds, true, cx)\n     );\n \n     document(w, cx, it, None);\n@@ -761,9 +760,9 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n         w,\n         \"type {}{}{where_clause} = impl {bounds};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache(), cx.tcx()),\n-        where_clause = print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n-        bounds = bounds(&t.bounds, false, cx.cache(), cx.tcx()),\n+        t.generics.print(cx),\n+        where_clause = print_where_clause(&t.generics, cx, 0, true),\n+        bounds = bounds(&t.bounds, false, cx),\n     );\n \n     document(w, cx, it, None);\n@@ -782,9 +781,9 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n         w,\n         \"type {}{}{where_clause} = {type_};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache(), cx.tcx()),\n-        where_clause = print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n-        type_ = t.type_.print(cx.cache(), cx.tcx()),\n+        t.generics.print(cx),\n+        where_clause = print_where_clause(&t.generics, cx, 0, true),\n+        type_ = t.type_.print(cx),\n     );\n \n     document(w, cx, it, None);\n@@ -831,7 +830,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n                 id = id,\n                 name = name,\n                 shortty = ItemType::StructField,\n-                ty = ty.print(cx.cache(), cx.tcx()),\n+                ty = ty.print(cx),\n             );\n             if let Some(stability_class) = field.stability_class(cx.tcx()) {\n                 write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n@@ -849,10 +848,10 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            it.visibility.print_with_space(it.def_id, cx),\n             it.name.as_ref().unwrap(),\n-            e.generics.print(cx.cache(), cx.tcx()),\n-            print_where_clause(&e.generics, cx.cache(), cx.tcx(), 0, true),\n+            e.generics.print(cx),\n+            print_where_clause(&e.generics, cx, 0, true),\n         );\n         if e.variants.is_empty() && !e.variants_stripped {\n             w.write_str(\" {}\");\n@@ -874,7 +873,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                                 if i > 0 {\n                                     w.write_str(\",&nbsp;\")\n                                 }\n-                                write!(w, \"{}\", ty.print(cx.cache(), cx.tcx()));\n+                                write!(w, \"{}\", ty.print(cx));\n                             }\n                             w.write_str(\")\");\n                         }\n@@ -924,7 +923,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                     if i > 0 {\n                         w.write_str(\",&nbsp;\");\n                     }\n-                    write!(w, \"{}\", ty.print(cx.cache(), cx.tcx()));\n+                    write!(w, \"{}\", ty.print(cx));\n                 }\n                 w.write_str(\")\");\n             }\n@@ -961,7 +960,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                              </span>\",\n                             id = id,\n                             f = field.name.as_ref().unwrap(),\n-                            t = ty.print(cx.cache(), cx.tcx())\n+                            t = ty.print(cx)\n                         );\n                         document(w, cx, field, Some(variant));\n                     }\n@@ -1030,9 +1029,9 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        vis = it.visibility.print_with_space(it.def_id, cx),\n         name = it.name.as_ref().unwrap(),\n-        typ = c.type_.print(cx.cache(), cx.tcx()),\n+        typ = c.type_.print(cx),\n     );\n \n     let value = c.value(cx.tcx());\n@@ -1102,7 +1101,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n                     item_type = ItemType::StructField,\n                     id = id,\n                     name = field.name.as_ref().unwrap(),\n-                    ty = ty.print(cx.cache(), cx.tcx())\n+                    ty = ty.print(cx)\n                 );\n                 document(w, cx, field, Some(it));\n             }\n@@ -1117,10 +1116,10 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        vis = it.visibility.print_with_space(it.def_id, cx),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n-        typ = s.type_.print(cx.cache(), cx.tcx())\n+        typ = s.type_.print(cx)\n     );\n     document(w, cx, it, None)\n }\n@@ -1131,7 +1130,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.visibility.print_with_space(it.def_id, cx),\n         it.name.as_ref().unwrap(),\n     );\n \n@@ -1195,12 +1194,7 @@ pub(super) fn item_path(ty: ItemType, name: &str) -> String {\n     }\n }\n \n-fn bounds(\n-    t_bounds: &[clean::GenericBound],\n-    trait_alias: bool,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n-) -> String {\n+fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cx: &Context<'_>) -> String {\n     let mut bounds = String::new();\n     if !t_bounds.is_empty() {\n         if !trait_alias {\n@@ -1210,7 +1204,7 @@ fn bounds(\n             if i > 0 {\n                 bounds.push_str(\" + \");\n             }\n-            bounds.push_str(&p.print(cache, tcx).to_string());\n+            bounds.push_str(&p.print(cx).to_string());\n         }\n     }\n     bounds\n@@ -1240,17 +1234,12 @@ fn render_stability_since(\n     )\n }\n \n-fn compare_impl<'a, 'b>(\n-    lhs: &'a &&Impl,\n-    rhs: &'b &&Impl,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n-) -> Ordering {\n-    let lhs = format!(\"{}\", lhs.inner_impl().print(cache, false, tcx));\n-    let rhs = format!(\"{}\", rhs.inner_impl().print(cache, false, tcx));\n+fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cx: &Context<'_>) -> Ordering {\n+    let lhss = format!(\"{}\", lhs.inner_impl().print(false, cx));\n+    let rhss = format!(\"{}\", rhs.inner_impl().print(false, cx));\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n-    compare_names(&lhs, &rhs)\n+    compare_names(&lhss, &rhss)\n }\n \n fn render_implementor(\n@@ -1300,13 +1289,13 @@ fn render_union(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.visibility.print_with_space(it.def_id, cx),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n     if let Some(g) = g {\n-        write!(w, \"{}\", g.print(cx.cache(), cx.tcx()));\n-        write!(w, \"{}\", print_where_clause(&g, cx.cache(), cx.tcx(), 0, true));\n+        write!(w, \"{}\", g.print(cx));\n+        write!(w, \"{}\", print_where_clause(&g, cx, 0, true));\n     }\n \n     write!(w, \" {{\\n{}\", tab);\n@@ -1322,9 +1311,9 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                field.visibility.print_with_space(field.def_id, cx),\n                 field.name.as_ref().unwrap(),\n-                ty.print(cx.cache(), cx.tcx()),\n+                ty.print(cx),\n                 tab\n             );\n         }\n@@ -1352,17 +1341,17 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.visibility.print_with_space(it.def_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n     if let Some(g) = g {\n-        write!(w, \"{}\", g.print(cx.cache(), cx.tcx()))\n+        write!(w, \"{}\", g.print(cx))\n     }\n     match ty {\n         CtorKind::Fictive => {\n             if let Some(g) = g {\n-                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, true),)\n+                write!(w, \"{}\", print_where_clause(g, cx, 0, true),)\n             }\n             w.write_str(\" {\");\n             let count_fields =\n@@ -1378,9 +1367,9 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                        field.visibility.print_with_space(field.def_id, cx),\n                         field.name.as_ref().unwrap(),\n-                        ty.print(cx.cache(), cx.tcx()),\n+                        ty.print(cx),\n                     );\n                 }\n             }\n@@ -1412,23 +1401,23 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n-                            ty.print(cx.cache(), cx.tcx()),\n+                            field.visibility.print_with_space(field.def_id, cx),\n+                            ty.print(cx),\n                         )\n                     }\n                     _ => unreachable!(),\n                 }\n             }\n             w.write_str(\")\");\n             if let Some(g) = g {\n-                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, false),)\n+                write!(w, \"{}\", print_where_clause(g, cx, 0, false),)\n             }\n             w.write_str(\";\");\n         }\n         CtorKind::Const => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, false),)\n+                write!(w, \"{}\", print_where_clause(g, cx, 0, false),)\n             }\n             w.write_str(\";\");\n         }"}, {"sha": "78bcd40af7538070e94dbbc2db9916d9e5066608", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -16,7 +16,6 @@ use crate::clean::Crate;\n use crate::config::{EmitType, RenderOptions};\n use crate::docfs::PathError;\n use crate::error::Error;\n-use crate::formats::FormatRenderer;\n use crate::html::{layout, static_files};\n \n crate static FILES_UNVERSIONED: Lazy<FxHashMap<&str, &[u8]>> = Lazy::new(|| {\n@@ -223,6 +222,7 @@ pub(super) fn write_shared(\n             &format!(\" = {}\", serde_json::to_string(&themes).unwrap()),\n         ),\n     )?;\n+    write_minify(\"search.js\", static_files::SEARCH_JS)?;\n     write_minify(\"settings.js\", static_files::SETTINGS_JS)?;\n     if cx.shared.include_sources {\n         write_minify(\"source-script.js\", static_files::sidebar::SOURCE_SCRIPT)?;\n@@ -410,7 +410,7 @@ pub(super) fn write_shared(\n     write_crate(\"search-index.js\", &|| {\n         let mut v = String::from(\"var searchIndex = JSON.parse('{\\\\\\n\");\n         v.push_str(&all_indexes.join(\",\\\\\\n\"));\n-        v.push_str(\"\\\\\\n}');\\ninitSearch(searchIndex);\");\n+        v.push_str(\"\\\\\\n}');\\nif (window.initSearch) {window.initSearch(searchIndex)};\");\n         Ok(v.into_bytes())\n     })?;\n \n@@ -500,7 +500,7 @@ pub(super) fn write_shared(\n                     None\n                 } else {\n                     Some(Implementor {\n-                        text: imp.inner_impl().print(cx.cache(), false, cx.tcx()).to_string(),\n+                        text: imp.inner_impl().print(false, cx).to_string(),\n                         synthetic: imp.inner_impl().synthetic,\n                         types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n                     })"}, {"sha": "f017fd846b1db69b7c263dec7321072a9b1046ad", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 157, "deletions": 1685, "changes": 1842, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n // Local js definitions:\n /* global addClass, getSettingValue, hasClass */\n /* global onEach, onEachLazy, hasOwnProperty, removeClass, updateLocalStorage */\n@@ -44,6 +43,7 @@ if (!DOMTokenList.prototype.remove) {\n         window.rootPath = rustdocVars.attributes[\"data-root-path\"].value;\n         window.currentCrate = rustdocVars.attributes[\"data-current-crate\"].value;\n         window.searchJS = rustdocVars.attributes[\"data-search-js\"].value;\n+        window.searchIndexJS = rustdocVars.attributes[\"data-search-index-js\"].value;\n     }\n     var sidebarVars = document.getElementById(\"sidebar-vars\");\n     if (sidebarVars) {\n@@ -77,14 +77,6 @@ function getVirtualKey(ev) {\n     return String.fromCharCode(c);\n }\n \n-function getSearchInput() {\n-    return document.getElementsByClassName(\"search-input\")[0];\n-}\n-\n-function getSearchElement() {\n-    return document.getElementById(\"search\");\n-}\n-\n var THEME_PICKER_ELEMENT_ID = \"theme-picker\";\n var THEMES_ELEMENT_ID = \"theme-choices\";\n \n@@ -101,16 +93,6 @@ function getNakedUrl() {\n     return window.location.href.split(\"?\")[0].split(\"#\")[0];\n }\n \n-// Sets the focus on the search bar at the top of the page\n-function focusSearchBar() {\n-    getSearchInput().focus();\n-}\n-\n-// Removes the focus from the search bar.\n-function defocusSearchBar() {\n-    getSearchInput().blur();\n-}\n-\n function showThemeButtonState() {\n     var themePicker = getThemePickerElement();\n     var themeChoices = getThemesElement();\n@@ -173,67 +155,154 @@ function hideThemeButtonState() {\n (function() {\n     \"use strict\";\n \n-    // This mapping table should match the discriminants of\n-    // `rustdoc::html::item_type::ItemType` type in Rust.\n-    var itemTypes = [\"mod\",\n-                     \"externcrate\",\n-                     \"import\",\n-                     \"struct\",\n-                     \"enum\",\n-                     \"fn\",\n-                     \"type\",\n-                     \"static\",\n-                     \"trait\",\n-                     \"impl\",\n-                     \"tymethod\",\n-                     \"method\",\n-                     \"structfield\",\n-                     \"variant\",\n-                     \"macro\",\n-                     \"primitive\",\n-                     \"associatedtype\",\n-                     \"constant\",\n-                     \"associatedconstant\",\n-                     \"union\",\n-                     \"foreigntype\",\n-                     \"keyword\",\n-                     \"existential\",\n-                     \"attr\",\n-                     \"derive\",\n-                     \"traitalias\"];\n+    window.searchState = {\n+      loadingText: \"Loading search results...\",\n+      input: document.getElementsByClassName(\"search-input\")[0],\n+      outputElement: function() {\n+        return document.getElementById(\"search\");\n+      },\n+      title: null,\n+      titleBeforeSearch: document.title,\n+      timeout: null,\n+      // On the search screen, so you remain on the last tab you opened.\n+      //\n+      // 0 for \"In Names\"\n+      // 1 for \"In Parameters\"\n+      // 2 for \"In Return Types\"\n+      currentTab: 0,\n+      mouseMovedAfterSearch: true,\n+      clearInputTimeout: function() {\n+        if (searchState.timeout !== null) {\n+            clearTimeout(searchState.timeout);\n+            searchState.timeout = null;\n+        }\n+      },\n+      // Sets the focus on the search bar at the top of the page\n+      focus: function() {\n+          searchState.input.focus();\n+      },\n+      // Removes the focus from the search bar.\n+      defocus: function() {\n+          searchState.input.blur();\n+      },\n+      showResults: function(search) {\n+        if (search === null || typeof search === 'undefined') {\n+            search = searchState.outputElement();\n+        }\n+        addClass(main, \"hidden\");\n+        removeClass(search, \"hidden\");\n+        searchState.mouseMovedAfterSearch = false;\n+        document.title = searchState.title;\n+      },\n+      hideResults: function(search) {\n+        if (search === null || typeof search === 'undefined') {\n+            search = searchState.outputElement();\n+        }\n+        addClass(search, \"hidden\");\n+        removeClass(main, \"hidden\");\n+        document.title = searchState.titleBeforeSearch;\n+        // We also remove the query parameter from the URL.\n+        if (searchState.browserSupportsHistoryApi()) {\n+            history.replaceState(\"\", window.currentCrate + \" - Rust\",\n+                getNakedUrl() + window.location.hash);\n+        }\n+      },\n+      getQueryStringParams: function() {\n+        var params = {};\n+        window.location.search.substring(1).split(\"&\").\n+            map(function(s) {\n+                var pair = s.split(\"=\");\n+                params[decodeURIComponent(pair[0])] =\n+                    typeof pair[1] === \"undefined\" ? null : decodeURIComponent(pair[1]);\n+            });\n+        return params;\n+      },\n+      putBackSearch: function(search_input) {\n+        var search = searchState.outputElement();\n+        if (search_input.value !== \"\" && hasClass(search, \"hidden\")) {\n+            searchState.showResults(search);\n+            if (searchState.browserSupportsHistoryApi()) {\n+                var extra = \"?search=\" + encodeURIComponent(search_input.value);\n+                history.replaceState(search_input.value, \"\",\n+                    getNakedUrl() + extra + window.location.hash);\n+            }\n+            document.title = searchState.title;\n+        }\n+      },\n+      browserSupportsHistoryApi: function() {\n+          return window.history && typeof window.history.pushState === \"function\";\n+      },\n+      setup: function() {\n+        var search_input = searchState.input;\n+        if (!searchState.input) {\n+            return;\n+        }\n+        function loadScript(url) {\n+            var script = document.createElement('script');\n+            script.src = url;\n+            document.head.append(script);\n+        }\n \n-    var disableShortcuts = getSettingValue(\"disable-shortcuts\") === \"true\";\n-    var search_input = getSearchInput();\n-    var searchTimeout = null;\n-    var toggleAllDocsId = \"toggle-all-docs\";\n+        var searchLoaded = false;\n+        function loadSearch() {\n+            if (!searchLoaded) {\n+                searchLoaded = true;\n+                loadScript(window.searchJS);\n+                loadScript(window.searchIndexJS);\n+            }\n+        }\n \n-    // On the search screen, so you remain on the last tab you opened.\n-    //\n-    // 0 for \"In Names\"\n-    // 1 for \"In Parameters\"\n-    // 2 for \"In Return Types\"\n-    var currentTab = 0;\n+        search_input.addEventListener(\"focus\", function() {\n+            searchState.putBackSearch(this);\n+            search_input.origPlaceholder = searchState.input.placeholder;\n+            search_input.placeholder = \"Type your search here.\";\n+            loadSearch();\n+        });\n+        search_input.addEventListener(\"blur\", function() {\n+            search_input.placeholder = searchState.input.origPlaceholder;\n+        });\n \n-    var mouseMovedAfterSearch = true;\n+        document.addEventListener(\"mousemove\", function() {\n+          searchState.mouseMovedAfterSearch = true;\n+        });\n \n-    var titleBeforeSearch = document.title;\n-    var searchTitle = null;\n+        search_input.removeAttribute('disabled');\n \n-    function removeEmptyStringsFromArray(x) {\n-        for (var i = 0, len = x.length; i < len; ++i) {\n-            if (x[i] === \"\") {\n-                x.splice(i, 1);\n-                i -= 1;\n-            }\n+        // `crates{version}.js` should always be loaded before this script, so we can use it safely.\n+        searchState.addCrateDropdown(window.ALL_CRATES);\n+        var params = searchState.getQueryStringParams();\n+        if (params.search !== undefined) {\n+            var search = searchState.outputElement();\n+            search.innerHTML = \"<h3 style=\\\"text-align: center;\\\">\" +\n+               searchState.loadingText + \"</h3>\";\n+            searchState.showResults(search);\n+            loadSearch();\n         }\n-    }\n+      },\n+      addCrateDropdown: function(crates) {\n+        var elem = document.getElementById(\"crate-search\");\n \n-    function clearInputTimeout() {\n-        if (searchTimeout !== null) {\n-            clearTimeout(searchTimeout);\n-            searchTimeout = null;\n+        if (!elem) {\n+            return;\n         }\n-    }\n+        var savedCrate = getSettingValue(\"saved-filter-crate\");\n+        for (var i = 0, len = crates.length; i < len; ++i) {\n+            var option = document.createElement(\"option\");\n+            option.value = crates[i];\n+            option.innerText = crates[i];\n+            elem.appendChild(option);\n+            // Set the crate filter from saved storage, if the current page has the saved crate\n+            // filter.\n+            //\n+            // If not, ignore the crate filter -- we want to support filtering for crates on sites\n+            // like doc.rust-lang.org where the crates may differ from page to page while on the\n+            // same domain.\n+            if (crates[i] === savedCrate) {\n+                elem.value = savedCrate;\n+            }\n+        }\n+      },\n+    };\n \n     function getPageId() {\n         if (window.location.hash) {\n@@ -276,65 +345,23 @@ function hideThemeButtonState() {\n         document.getElementsByTagName(\"body\")[0].style.marginTop = \"\";\n     }\n \n-    function showSearchResults(search) {\n-        if (search === null || typeof search === 'undefined') {\n-            search = getSearchElement();\n-        }\n-        addClass(main, \"hidden\");\n-        removeClass(search, \"hidden\");\n-        mouseMovedAfterSearch = false;\n-        document.title = searchTitle;\n-    }\n-\n-    function hideSearchResults(search) {\n-        if (search === null || typeof search === 'undefined') {\n-            search = getSearchElement();\n-        }\n-        addClass(search, \"hidden\");\n-        removeClass(main, \"hidden\");\n-        document.title = titleBeforeSearch;\n-        // We also remove the query parameter from the URL.\n-        if (browserSupportsHistoryApi()) {\n-            history.replaceState(\"\", window.currentCrate + \" - Rust\",\n-                getNakedUrl() + window.location.hash);\n-        }\n-    }\n-\n-    // used for special search precedence\n-    var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n-    var TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n-\n-    function getQueryStringParams() {\n-        var params = {};\n-        window.location.search.substring(1).split(\"&\").\n-            map(function(s) {\n-                var pair = s.split(\"=\");\n-                params[decodeURIComponent(pair[0])] =\n-                    typeof pair[1] === \"undefined\" ? null : decodeURIComponent(pair[1]);\n-            });\n-        return params;\n-    }\n-\n-    function browserSupportsHistoryApi() {\n-        return window.history && typeof window.history.pushState === \"function\";\n-    }\n-\n     function isHidden(elem) {\n         return elem.offsetHeight === 0;\n     }\n \n+    var toggleAllDocsId = \"toggle-all-docs\";\n     var main = document.getElementById(\"main\");\n     var savedHash = \"\";\n \n     function handleHashes(ev) {\n         var elem;\n-        var search = getSearchElement();\n+        var search = searchState.outputElement();\n         if (ev !== null && search && !hasClass(search, \"hidden\") && ev.newURL) {\n             // This block occurs when clicking on an element in the navbar while\n             // in a search.\n-            hideSearchResults(search);\n+            searchState.hideResults(search);\n             var hash = ev.newURL.slice(ev.newURL.indexOf(\"#\") + 1);\n-            if (browserSupportsHistoryApi()) {\n+            if (searchState.browserSupportsHistoryApi()) {\n                 // `window.location.search`` contains all the query parameters, not just `search`.\n                 history.replaceState(hash, \"\",\n                     getNakedUrl() + window.location.search + \"#\" + hash);\n@@ -475,18 +502,19 @@ function hideThemeButtonState() {\n \n     function handleEscape(ev) {\n         var help = getHelpElement(false);\n-        var search = getSearchElement();\n+        var search = searchState.outputElement();\n         if (hasClass(help, \"hidden\") === false) {\n             displayHelp(false, ev, help);\n         } else if (hasClass(search, \"hidden\") === false) {\n-            clearInputTimeout();\n+            searchState.clearInputTimeout();\n             ev.preventDefault();\n-            hideSearchResults(search);\n+            searchState.hideResults(search);\n         }\n-        defocusSearchBar();\n+        searchState.defocus();\n         hideThemeButtonState();\n     }\n \n+    var disableShortcuts = getSettingValue(\"disable-shortcuts\") === \"true\";\n     function handleShortcut(ev) {\n         // Don't interfere with browser shortcuts\n         if (ev.ctrlKey || ev.altKey || ev.metaKey || disableShortcuts === true) {\n@@ -509,7 +537,7 @@ function hideThemeButtonState() {\n             case \"S\":\n                 displayHelp(false, ev);\n                 ev.preventDefault();\n-                focusSearchBar();\n+                searchState.focus();\n                 break;\n \n             case \"+\":\n@@ -596,15 +624,13 @@ function hideThemeButtonState() {\n     document.addEventListener(\"keypress\", handleShortcut);\n     document.addEventListener(\"keydown\", handleShortcut);\n \n-    document.addEventListener(\"mousemove\", function() { mouseMovedAfterSearch = true; });\n-\n     var handleSourceHighlight = (function() {\n         var prev_line_id = 0;\n \n         var set_fragment = function(name) {\n             var x = window.scrollX,\n                 y = window.scrollY;\n-            if (browserSupportsHistoryApi()) {\n+            if (searchState.browserSupportsHistoryApi()) {\n                 history.replaceState(null, null, \"#\" + name);\n                 highlightSourceLines();\n             } else {\n@@ -686,1444 +712,6 @@ function hideThemeButtonState() {\n         }\n     }());\n \n-    /**\n-     * A function to compute the Levenshtein distance between two strings\n-     * Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported\n-     * Full License can be found at http://creativecommons.org/licenses/by-sa/3.0/legalcode\n-     * This code is an unmodified version of the code written by Marco de Wit\n-     * and was found at http://stackoverflow.com/a/18514751/745719\n-     */\n-    var levenshtein_row2 = [];\n-    function levenshtein(s1, s2) {\n-        if (s1 === s2) {\n-            return 0;\n-        }\n-        var s1_len = s1.length, s2_len = s2.length;\n-        if (s1_len && s2_len) {\n-            var i1 = 0, i2 = 0, a, b, c, c2, row = levenshtein_row2;\n-            while (i1 < s1_len) {\n-                row[i1] = ++i1;\n-            }\n-            while (i2 < s2_len) {\n-                c2 = s2.charCodeAt(i2);\n-                a = i2;\n-                ++i2;\n-                b = i2;\n-                for (i1 = 0; i1 < s1_len; ++i1) {\n-                    c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n-                    a = row[i1];\n-                    b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n-                    row[i1] = b;\n-                }\n-            }\n-            return b;\n-        }\n-        return s1_len + s2_len;\n-    }\n-\n-    window.initSearch = function(rawSearchIndex) {\n-        var MAX_LEV_DISTANCE = 3;\n-        var MAX_RESULTS = 200;\n-        var GENERICS_DATA = 1;\n-        var NAME = 0;\n-        var INPUTS_DATA = 0;\n-        var OUTPUT_DATA = 1;\n-        var NO_TYPE_FILTER = -1;\n-        var currentResults, index, searchIndex;\n-        var ALIASES = {};\n-        var params = getQueryStringParams();\n-\n-        // Populate search bar with query string search term when provided,\n-        // but only if the input bar is empty. This avoid the obnoxious issue\n-        // where you start trying to do a search, and the index loads, and\n-        // suddenly your search is gone!\n-        if (search_input.value === \"\") {\n-            search_input.value = params.search || \"\";\n-        }\n-\n-        /**\n-         * Executes the query and builds an index of results\n-         * @param  {[Object]} query      [The user query]\n-         * @param  {[type]} searchWords  [The list of search words to query\n-         *                                against]\n-         * @param  {[type]} filterCrates [Crate to search in if defined]\n-         * @return {[type]}              [A search index of results]\n-         */\n-        function execQuery(query, searchWords, filterCrates) {\n-            function itemTypeFromName(typename) {\n-                for (var i = 0, len = itemTypes.length; i < len; ++i) {\n-                    if (itemTypes[i] === typename) {\n-                        return i;\n-                    }\n-                }\n-                return NO_TYPE_FILTER;\n-            }\n-\n-            var valLower = query.query.toLowerCase(),\n-                val = valLower,\n-                typeFilter = itemTypeFromName(query.type),\n-                results = {}, results_in_args = {}, results_returned = {},\n-                split = valLower.split(\"::\");\n-\n-            removeEmptyStringsFromArray(split);\n-\n-            function transformResults(results, isType) {\n-                var out = [];\n-                for (var i = 0, len = results.length; i < len; ++i) {\n-                    if (results[i].id > -1) {\n-                        var obj = searchIndex[results[i].id];\n-                        obj.lev = results[i].lev;\n-                        if (isType !== true || obj.type) {\n-                            var res = buildHrefAndPath(obj);\n-                            obj.displayPath = pathSplitter(res[0]);\n-                            obj.fullPath = obj.displayPath + obj.name;\n-                            // To be sure than it some items aren't considered as duplicate.\n-                            obj.fullPath += \"|\" + obj.ty;\n-                            obj.href = res[1];\n-                            out.push(obj);\n-                            if (out.length >= MAX_RESULTS) {\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-                return out;\n-            }\n-\n-            function sortResults(results, isType) {\n-                var ar = [];\n-                for (var entry in results) {\n-                    if (hasOwnProperty(results, entry)) {\n-                        ar.push(results[entry]);\n-                    }\n-                }\n-                results = ar;\n-                var i, len, result;\n-                for (i = 0, len = results.length; i < len; ++i) {\n-                    result = results[i];\n-                    result.word = searchWords[result.id];\n-                    result.item = searchIndex[result.id] || {};\n-                }\n-                // if there are no results then return to default and fail\n-                if (results.length === 0) {\n-                    return [];\n-                }\n-\n-                results.sort(function(aaa, bbb) {\n-                    var a, b;\n-\n-                    // sort by exact match with regard to the last word (mismatch goes later)\n-                    a = (aaa.word !== val);\n-                    b = (bbb.word !== val);\n-                    if (a !== b) { return a - b; }\n-\n-                    // Sort by non levenshtein results and then levenshtein results by the distance\n-                    // (less changes required to match means higher rankings)\n-                    a = (aaa.lev);\n-                    b = (bbb.lev);\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by crate (non-current crate goes later)\n-                    a = (aaa.item.crate !== window.currentCrate);\n-                    b = (bbb.item.crate !== window.currentCrate);\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by item name length (longer goes later)\n-                    a = aaa.word.length;\n-                    b = bbb.word.length;\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by item name (lexicographically larger goes later)\n-                    a = aaa.word;\n-                    b = bbb.word;\n-                    if (a !== b) { return (a > b ? +1 : -1); }\n-\n-                    // sort by index of keyword in item name (no literal occurrence goes later)\n-                    a = (aaa.index < 0);\n-                    b = (bbb.index < 0);\n-                    if (a !== b) { return a - b; }\n-                    // (later literal occurrence, if any, goes later)\n-                    a = aaa.index;\n-                    b = bbb.index;\n-                    if (a !== b) { return a - b; }\n-\n-                    // special precedence for primitive and keyword pages\n-                    if ((aaa.item.ty === TY_PRIMITIVE && bbb.item.ty !== TY_KEYWORD) ||\n-                        (aaa.item.ty === TY_KEYWORD && bbb.item.ty !== TY_PRIMITIVE)) {\n-                        return -1;\n-                    }\n-                    if ((bbb.item.ty === TY_PRIMITIVE && aaa.item.ty !== TY_PRIMITIVE) ||\n-                        (bbb.item.ty === TY_KEYWORD && aaa.item.ty !== TY_KEYWORD)) {\n-                        return 1;\n-                    }\n-\n-                    // sort by description (no description goes later)\n-                    a = (aaa.item.desc === \"\");\n-                    b = (bbb.item.desc === \"\");\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by type (later occurrence in `itemTypes` goes later)\n-                    a = aaa.item.ty;\n-                    b = bbb.item.ty;\n-                    if (a !== b) { return a - b; }\n-\n-                    // sort by path (lexicographically larger goes later)\n-                    a = aaa.item.path;\n-                    b = bbb.item.path;\n-                    if (a !== b) { return (a > b ? +1 : -1); }\n-\n-                    // que sera, sera\n-                    return 0;\n-                });\n-\n-                for (i = 0, len = results.length; i < len; ++i) {\n-                    var result = results[i];\n-\n-                    // this validation does not make sense when searching by types\n-                    if (result.dontValidate) {\n-                        continue;\n-                    }\n-                    var name = result.item.name.toLowerCase(),\n-                        path = result.item.path.toLowerCase(),\n-                        parent = result.item.parent;\n-\n-                    if (isType !== true &&\n-                        validateResult(name, path, split, parent) === false)\n-                    {\n-                        result.id = -1;\n-                    }\n-                }\n-                return transformResults(results);\n-            }\n-\n-            function extractGenerics(val) {\n-                val = val.toLowerCase();\n-                if (val.indexOf(\"<\") !== -1) {\n-                    var values = val.substring(val.indexOf(\"<\") + 1, val.lastIndexOf(\">\"));\n-                    return {\n-                        name: val.substring(0, val.indexOf(\"<\")),\n-                        generics: values.split(/\\s*,\\s*/),\n-                    };\n-                }\n-                return {\n-                    name: val,\n-                    generics: [],\n-                };\n-            }\n-\n-            function getObjectNameFromId(id) {\n-                if (typeof id === \"number\") {\n-                    return searchIndex[id].name;\n-                }\n-                return id;\n-            }\n-\n-            function checkGenerics(obj, val) {\n-                // The names match, but we need to be sure that all generics kinda\n-                // match as well.\n-                var tmp_lev, elem_name;\n-                if (val.generics.length > 0) {\n-                    if (obj.length > GENERICS_DATA &&\n-                          obj[GENERICS_DATA].length >= val.generics.length) {\n-                        var elems = Object.create(null);\n-                        var elength = object[GENERICS_DATA].length;\n-                        for (var x = 0; x < elength; ++x) {\n-                            elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n-                        }\n-                        var total = 0;\n-                        var done = 0;\n-                        // We need to find the type that matches the most to remove it in order\n-                        // to move forward.\n-                        var vlength = val.generics.length;\n-                        for (x = 0; x < vlength; ++x) {\n-                            var lev = MAX_LEV_DISTANCE + 1;\n-                            var firstGeneric = getObjectNameFromId(val.generics[x]);\n-                            var match = null;\n-                            if (elems[firstGeneric]) {\n-                                match = firstGeneric;\n-                                lev = 0;\n-                            } else {\n-                                for (elem_name in elems) {\n-                                    tmp_lev = levenshtein(elem_name, firstGeneric);\n-                                    if (tmp_lev < lev) {\n-                                        lev = tmp_lev;\n-                                        match = elem_name;\n-                                    }\n-                                }\n-                            }\n-                            if (match !== null) {\n-                                elems[match] -= 1;\n-                                if (elems[match] == 0) {\n-                                    delete elems[match];\n-                                }\n-                                total += lev;\n-                                done += 1;\n-                            } else {\n-                                return MAX_LEV_DISTANCE + 1;\n-                            }\n-                        }\n-                        return Math.ceil(total / done);\n-                    }\n-                }\n-                return MAX_LEV_DISTANCE + 1;\n-            }\n-\n-            // Check for type name and type generics (if any).\n-            function checkType(obj, val, literalSearch) {\n-                var lev_distance = MAX_LEV_DISTANCE + 1;\n-                var len, x, firstGeneric;\n-                if (obj[NAME] === val.name) {\n-                    if (literalSearch === true) {\n-                        if (val.generics && val.generics.length !== 0) {\n-                            if (obj.length > GENERICS_DATA &&\n-                                  obj[GENERICS_DATA].length >= val.generics.length) {\n-                                var elems = Object.create(null);\n-                                len = obj[GENERICS_DATA].length;\n-                                for (x = 0; x < len; ++x) {\n-                                    elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n-                                }\n-\n-                                var allFound = true;\n-                                len = val.generics.length;\n-                                for (x = 0; x < len; ++x) {\n-                                    firstGeneric = getObjectNameFromId(val.generics[x]);\n-                                    if (elems[firstGeneric]) {\n-                                        elems[firstGeneric] -= 1;\n-                                    } else {\n-                                        allFound = false;\n-                                        break;\n-                                    }\n-                                }\n-                                if (allFound === true) {\n-                                    return true;\n-                                }\n-                            } else {\n-                                return false;\n-                            }\n-                        }\n-                        return true;\n-                    }\n-                    // If the type has generics but don't match, then it won't return at this point.\n-                    // Otherwise, `checkGenerics` will return 0 and it'll return.\n-                    if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length !== 0) {\n-                        var tmp_lev = checkGenerics(obj, val);\n-                        if (tmp_lev <= MAX_LEV_DISTANCE) {\n-                            return tmp_lev;\n-                        }\n-                    } else {\n-                        return 0;\n-                    }\n-                }\n-                // Names didn't match so let's check if one of the generic types could.\n-                if (literalSearch === true) {\n-                     if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                        return obj[GENERICS_DATA].some(\n-                            function(name) {\n-                                return name === val.name;\n-                            });\n-                    }\n-                    return false;\n-                }\n-                lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n-                if (lev_distance <= MAX_LEV_DISTANCE) {\n-                    // The generics didn't match but the name kinda did so we give it\n-                    // a levenshtein distance value that isn't *this* good so it goes\n-                    // into the search results but not too high.\n-                    lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n-                } else if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                    // We can check if the type we're looking for is inside the generics!\n-                    var olength = obj[GENERICS_DATA].length;\n-                    for (x = 0; x < olength; ++x) {\n-                        lev_distance = Math.min(levenshtein(obj[GENERICS_DATA][x], val.name),\n-                                                lev_distance);\n-                    }\n-                }\n-                // Now whatever happens, the returned distance is \"less good\" so we should mark it\n-                // as such, and so we add 1 to the distance to make it \"less good\".\n-                return lev_distance + 1;\n-            }\n-\n-            function findArg(obj, val, literalSearch, typeFilter) {\n-                var lev_distance = MAX_LEV_DISTANCE + 1;\n-\n-                if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n-                    var length = obj.type[INPUTS_DATA].length;\n-                    for (var i = 0; i < length; i++) {\n-                        var tmp = obj.type[INPUTS_DATA][i];\n-                        if (typePassesFilter(typeFilter, tmp[1]) === false) {\n-                            continue;\n-                        }\n-                        tmp = checkType(tmp, val, literalSearch);\n-                        if (literalSearch === true) {\n-                            if (tmp === true) {\n-                                return true;\n-                            }\n-                            continue;\n-                        }\n-                        lev_distance = Math.min(tmp, lev_distance);\n-                        if (lev_distance === 0) {\n-                            return 0;\n-                        }\n-                    }\n-                }\n-                return literalSearch === true ? false : lev_distance;\n-            }\n-\n-            function checkReturned(obj, val, literalSearch, typeFilter) {\n-                var lev_distance = MAX_LEV_DISTANCE + 1;\n-\n-                if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n-                    var ret = obj.type[OUTPUT_DATA];\n-                    if (typeof ret[0] === \"string\") {\n-                        ret = [ret];\n-                    }\n-                    for (var x = 0, len = ret.length; x < len; ++x) {\n-                        var tmp = ret[x];\n-                        if (typePassesFilter(typeFilter, tmp[1]) === false) {\n-                            continue;\n-                        }\n-                        tmp = checkType(tmp, val, literalSearch);\n-                        if (literalSearch === true) {\n-                            if (tmp === true) {\n-                                return true;\n-                            }\n-                            continue;\n-                        }\n-                        lev_distance = Math.min(tmp, lev_distance);\n-                        if (lev_distance === 0) {\n-                            return 0;\n-                        }\n-                    }\n-                }\n-                return literalSearch === true ? false : lev_distance;\n-            }\n-\n-            function checkPath(contains, lastElem, ty) {\n-                if (contains.length === 0) {\n-                    return 0;\n-                }\n-                var ret_lev = MAX_LEV_DISTANCE + 1;\n-                var path = ty.path.split(\"::\");\n-\n-                if (ty.parent && ty.parent.name) {\n-                    path.push(ty.parent.name.toLowerCase());\n-                }\n-\n-                var length = path.length;\n-                var clength = contains.length;\n-                if (clength > length) {\n-                    return MAX_LEV_DISTANCE + 1;\n-                }\n-                for (var i = 0; i < length; ++i) {\n-                    if (i + clength > length) {\n-                        break;\n-                    }\n-                    var lev_total = 0;\n-                    var aborted = false;\n-                    for (var x = 0; x < clength; ++x) {\n-                        var lev = levenshtein(path[i + x], contains[x]);\n-                        if (lev > MAX_LEV_DISTANCE) {\n-                            aborted = true;\n-                            break;\n-                        }\n-                        lev_total += lev;\n-                    }\n-                    if (aborted === false) {\n-                        ret_lev = Math.min(ret_lev, Math.round(lev_total / clength));\n-                    }\n-                }\n-                return ret_lev;\n-            }\n-\n-            function typePassesFilter(filter, type) {\n-                // No filter\n-                if (filter <= NO_TYPE_FILTER) return true;\n-\n-                // Exact match\n-                if (filter === type) return true;\n-\n-                // Match related items\n-                var name = itemTypes[type];\n-                switch (itemTypes[filter]) {\n-                    case \"constant\":\n-                        return name === \"associatedconstant\";\n-                    case \"fn\":\n-                        return name === \"method\" || name === \"tymethod\";\n-                    case \"type\":\n-                        return name === \"primitive\" || name === \"associatedtype\";\n-                    case \"trait\":\n-                        return name === \"traitalias\";\n-                }\n-\n-                // No match\n-                return false;\n-            }\n-\n-            function createAliasFromItem(item) {\n-                return {\n-                    crate: item.crate,\n-                    name: item.name,\n-                    path: item.path,\n-                    desc: item.desc,\n-                    ty: item.ty,\n-                    parent: item.parent,\n-                    type: item.type,\n-                    is_alias: true,\n-                };\n-            }\n-\n-            function handleAliases(ret, query, filterCrates) {\n-                // We separate aliases and crate aliases because we want to have current crate\n-                // aliases to be before the others in the displayed results.\n-                var aliases = [];\n-                var crateAliases = [];\n-                if (filterCrates !== undefined) {\n-                    if (ALIASES[filterCrates] && ALIASES[filterCrates][query.search]) {\n-                        var query_aliases = ALIASES[filterCrates][query.search];\n-                        var len = query_aliases.length;\n-                        for (var i = 0; i < len; ++i) {\n-                            aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n-                        }\n-                    }\n-                } else {\n-                    Object.keys(ALIASES).forEach(function(crate) {\n-                        if (ALIASES[crate][query.search]) {\n-                            var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n-                            var query_aliases = ALIASES[crate][query.search];\n-                            var len = query_aliases.length;\n-                            for (var i = 0; i < len; ++i) {\n-                                pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n-                            }\n-                        }\n-                    });\n-                }\n-\n-                var sortFunc = function(aaa, bbb) {\n-                    if (aaa.path < bbb.path) {\n-                        return 1;\n-                    } else if (aaa.path === bbb.path) {\n-                        return 0;\n-                    }\n-                    return -1;\n-                };\n-                crateAliases.sort(sortFunc);\n-                aliases.sort(sortFunc);\n-\n-                var pushFunc = function(alias) {\n-                    alias.alias = query.raw;\n-                    var res = buildHrefAndPath(alias);\n-                    alias.displayPath = pathSplitter(res[0]);\n-                    alias.fullPath = alias.displayPath + alias.name;\n-                    alias.href = res[1];\n-\n-                    ret.others.unshift(alias);\n-                    if (ret.others.length > MAX_RESULTS) {\n-                        ret.others.pop();\n-                    }\n-                };\n-                onEach(aliases, pushFunc);\n-                onEach(crateAliases, pushFunc);\n-            }\n-\n-            // quoted values mean literal search\n-            var nSearchWords = searchWords.length;\n-            var i, it;\n-            var ty;\n-            var fullId;\n-            var returned;\n-            var in_args;\n-            var len;\n-            if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n-                val.charAt(val.length - 1) === val.charAt(0))\n-            {\n-                val = extractGenerics(val.substr(1, val.length - 2));\n-                for (i = 0; i < nSearchWords; ++i) {\n-                    if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n-                        continue;\n-                    }\n-                    in_args = findArg(searchIndex[i], val, true, typeFilter);\n-                    returned = checkReturned(searchIndex[i], val, true, typeFilter);\n-                    ty = searchIndex[i];\n-                    fullId = ty.id;\n-\n-                    if (searchWords[i] === val.name\n-                        && typePassesFilter(typeFilter, searchIndex[i].ty)\n-                        && results[fullId] === undefined) {\n-                        results[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n-                    }\n-                    if (in_args === true && results_in_args[fullId] === undefined) {\n-                        results_in_args[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n-                    }\n-                    if (returned === true && results_returned[fullId] === undefined) {\n-                        results_returned[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n-                    }\n-                }\n-                query.inputs = [val];\n-                query.output = val;\n-                query.search = val;\n-            // searching by type\n-            } else if (val.search(\"->\") > -1) {\n-                var trimmer = function(s) { return s.trim(); };\n-                var parts = val.split(\"->\").map(trimmer);\n-                var input = parts[0];\n-                // sort inputs so that order does not matter\n-                var inputs = input.split(\",\").map(trimmer).sort();\n-                for (i = 0, len = inputs.length; i < len; ++i) {\n-                    inputs[i] = extractGenerics(inputs[i]);\n-                }\n-                var output = extractGenerics(parts[1]);\n-\n-                for (i = 0; i < nSearchWords; ++i) {\n-                    if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n-                        continue;\n-                    }\n-                    var type = searchIndex[i].type;\n-                    ty = searchIndex[i];\n-                    if (!type) {\n-                        continue;\n-                    }\n-                    fullId = ty.id;\n-\n-                    returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n-                    if (output.name === \"*\" || returned === true) {\n-                        in_args = false;\n-                        var is_module = false;\n-\n-                        if (input === \"*\") {\n-                            is_module = true;\n-                        } else {\n-                            var allFound = true;\n-                            for (it = 0, len = inputs.length; allFound === true && it < len; it++) {\n-                                allFound = checkType(type, inputs[it], true);\n-                            }\n-                            in_args = allFound;\n-                        }\n-                        if (in_args === true) {\n-                            results_in_args[fullId] = {\n-                                id: i,\n-                                index: -1,\n-                                dontValidate: true,\n-                            };\n-                        }\n-                        if (returned === true) {\n-                            results_returned[fullId] = {\n-                                id: i,\n-                                index: -1,\n-                                dontValidate: true,\n-                            };\n-                        }\n-                        if (is_module === true) {\n-                            results[fullId] = {\n-                                id: i,\n-                                index: -1,\n-                                dontValidate: true,\n-                            };\n-                        }\n-                    }\n-                }\n-                query.inputs = inputs.map(function(input) {\n-                    return input.name;\n-                });\n-                query.output = output.name;\n-            } else {\n-                query.inputs = [val];\n-                query.output = val;\n-                query.search = val;\n-                // gather matching search results up to a certain maximum\n-                val = val.replace(/\\_/g, \"\");\n-\n-                var valGenerics = extractGenerics(val);\n-\n-                var paths = valLower.split(\"::\");\n-                removeEmptyStringsFromArray(paths);\n-                val = paths[paths.length - 1];\n-                var contains = paths.slice(0, paths.length > 1 ? paths.length - 1 : 1);\n-\n-                var lev, j;\n-                for (j = 0; j < nSearchWords; ++j) {\n-                    ty = searchIndex[j];\n-                    if (!ty || (filterCrates !== undefined && ty.crate !== filterCrates)) {\n-                        continue;\n-                    }\n-                    var lev_add = 0;\n-                    if (paths.length > 1) {\n-                        lev = checkPath(contains, paths[paths.length - 1], ty);\n-                        if (lev > MAX_LEV_DISTANCE) {\n-                            continue;\n-                        } else if (lev > 0) {\n-                            lev_add = lev / 10;\n-                        }\n-                    }\n-\n-                    returned = MAX_LEV_DISTANCE + 1;\n-                    in_args = MAX_LEV_DISTANCE + 1;\n-                    var index = -1;\n-                    // we want lev results to go lower than others\n-                    lev = MAX_LEV_DISTANCE + 1;\n-                    fullId = ty.id;\n-\n-                    if (searchWords[j].indexOf(split[i]) > -1 ||\n-                        searchWords[j].indexOf(val) > -1 ||\n-                        ty.normalizedName.indexOf(val) > -1)\n-                    {\n-                        // filter type: ... queries\n-                        if (typePassesFilter(typeFilter, ty.ty) && results[fullId] === undefined) {\n-                            index = ty.normalizedName.indexOf(val);\n-                        }\n-                    }\n-                    if ((lev = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n-                        if (typePassesFilter(typeFilter, ty.ty) === false) {\n-                            lev = MAX_LEV_DISTANCE + 1;\n-                        } else {\n-                            lev += 1;\n-                        }\n-                    }\n-                    in_args = findArg(ty, valGenerics, false, typeFilter);\n-                    returned = checkReturned(ty, valGenerics, false, typeFilter);\n-\n-                    lev += lev_add;\n-                    if (lev > 0 && val.length > 3 && searchWords[j].indexOf(val) > -1) {\n-                        if (val.length < 6) {\n-                            lev -= 1;\n-                        } else {\n-                            lev = 0;\n-                        }\n-                    }\n-                    if (in_args <= MAX_LEV_DISTANCE) {\n-                        if (results_in_args[fullId] === undefined) {\n-                            results_in_args[fullId] = {\n-                                id: j,\n-                                index: index,\n-                                lev: in_args,\n-                            };\n-                        }\n-                        results_in_args[fullId].lev =\n-                            Math.min(results_in_args[fullId].lev, in_args);\n-                    }\n-                    if (returned <= MAX_LEV_DISTANCE) {\n-                        if (results_returned[fullId] === undefined) {\n-                            results_returned[fullId] = {\n-                                id: j,\n-                                index: index,\n-                                lev: returned,\n-                            };\n-                        }\n-                        results_returned[fullId].lev =\n-                            Math.min(results_returned[fullId].lev, returned);\n-                    }\n-                    if (index !== -1 || lev <= MAX_LEV_DISTANCE) {\n-                        if (index !== -1 && paths.length < 2) {\n-                            lev = 0;\n-                        }\n-                        if (results[fullId] === undefined) {\n-                            results[fullId] = {\n-                                id: j,\n-                                index: index,\n-                                lev: lev,\n-                            };\n-                        }\n-                        results[fullId].lev = Math.min(results[fullId].lev, lev);\n-                    }\n-                }\n-            }\n-\n-            var ret = {\n-                \"in_args\": sortResults(results_in_args, true),\n-                \"returned\": sortResults(results_returned, true),\n-                \"others\": sortResults(results),\n-            };\n-            handleAliases(ret, query, filterCrates);\n-            return ret;\n-        }\n-\n-        /**\n-         * Validate performs the following boolean logic. For example:\n-         * \"File::open\" will give IF A PARENT EXISTS => (\"file\" && \"open\")\n-         * exists in (name || path || parent) OR => (\"file\" && \"open\") exists in\n-         * (name || path )\n-         *\n-         * This could be written functionally, but I wanted to minimise\n-         * functions on stack.\n-         *\n-         * @param  {[string]} name   [The name of the result]\n-         * @param  {[string]} path   [The path of the result]\n-         * @param  {[string]} keys   [The keys to be used ([\"file\", \"open\"])]\n-         * @param  {[object]} parent [The parent of the result]\n-         * @return {[boolean]}       [Whether the result is valid or not]\n-         */\n-        function validateResult(name, path, keys, parent) {\n-            for (var i = 0, len = keys.length; i < len; ++i) {\n-                // each check is for validation so we negate the conditions and invalidate\n-                if (!(\n-                    // check for an exact name match\n-                    name.indexOf(keys[i]) > -1 ||\n-                    // then an exact path match\n-                    path.indexOf(keys[i]) > -1 ||\n-                    // next if there is a parent, check for exact parent match\n-                    (parent !== undefined && parent.name !== undefined &&\n-                        parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n-                    // lastly check to see if the name was a levenshtein match\n-                    levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-\n-        function getQuery(raw) {\n-            var matches, type, query;\n-            query = raw;\n-\n-            matches = query.match(/^(fn|mod|struct|enum|trait|type|const|macro)\\s*:\\s*/i);\n-            if (matches) {\n-                type = matches[1].replace(/^const$/, \"constant\");\n-                query = query.substring(matches[0].length);\n-            }\n-\n-            return {\n-                raw: raw,\n-                query: query,\n-                type: type,\n-                id: query + type\n-            };\n-        }\n-\n-        function initSearchNav() {\n-            var hoverTimeout;\n-\n-            var click_func = function(e) {\n-                var el = e.target;\n-                // to retrieve the real \"owner\" of the event.\n-                while (el.tagName !== \"TR\") {\n-                    el = el.parentNode;\n-                }\n-                var dst = e.target.getElementsByTagName(\"a\");\n-                if (dst.length < 1) {\n-                    return;\n-                }\n-                dst = dst[0];\n-                if (window.location.pathname === dst.pathname) {\n-                    hideSearchResults();\n-                    document.location.href = dst.href;\n-                }\n-            };\n-            var mouseover_func = function(e) {\n-                if (mouseMovedAfterSearch) {\n-                    var el = e.target;\n-                    // to retrieve the real \"owner\" of the event.\n-                    while (el.tagName !== \"TR\") {\n-                        el = el.parentNode;\n-                    }\n-                    clearTimeout(hoverTimeout);\n-                    hoverTimeout = setTimeout(function() {\n-                        onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n-                            onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n-                                removeClass(i_e, \"highlighted\");\n-                            });\n-                        });\n-                        addClass(el, \"highlighted\");\n-                    }, 20);\n-                }\n-            };\n-            onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n-                onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n-                    i_e.onclick = click_func;\n-                    i_e.onmouseover = mouseover_func;\n-                });\n-            });\n-\n-            search_input.onkeydown = function(e) {\n-                // \"actives\" references the currently highlighted item in each search tab.\n-                // Each array in \"actives\" represents a tab.\n-                var actives = [[], [], []];\n-                // \"current\" is used to know which tab we're looking into.\n-                var current = 0;\n-                onEachLazy(document.getElementById(\"results\").childNodes, function(e) {\n-                    onEachLazy(e.getElementsByClassName(\"highlighted\"), function(h_e) {\n-                        actives[current].push(h_e);\n-                    });\n-                    current += 1;\n-                });\n-\n-                if (e.which === 38) { // up\n-                    if (e.ctrlKey) { // Going through result tabs.\n-                        printTab(currentTab > 0 ? currentTab - 1 : 2);\n-                    } else {\n-                        if (!actives[currentTab].length ||\n-                            !actives[currentTab][0].previousElementSibling) {\n-                            return;\n-                        }\n-                        addClass(actives[currentTab][0].previousElementSibling, \"highlighted\");\n-                        removeClass(actives[currentTab][0], \"highlighted\");\n-                    }\n-                    e.preventDefault();\n-                } else if (e.which === 40) { // down\n-                    if (e.ctrlKey) { // Going through result tabs.\n-                        printTab(currentTab > 1 ? 0 : currentTab + 1);\n-                    } else if (!actives[currentTab].length) {\n-                        var results = document.getElementById(\"results\").childNodes;\n-                        if (results.length > 0) {\n-                            var res = results[currentTab].getElementsByClassName(\"result\");\n-                            if (res.length > 0) {\n-                                addClass(res[0], \"highlighted\");\n-                            }\n-                        }\n-                    } else if (actives[currentTab][0].nextElementSibling) {\n-                        addClass(actives[currentTab][0].nextElementSibling, \"highlighted\");\n-                        removeClass(actives[currentTab][0], \"highlighted\");\n-                    }\n-                    e.preventDefault();\n-                } else if (e.which === 13) { // return\n-                    if (actives[currentTab].length) {\n-                        document.location.href =\n-                            actives[currentTab][0].getElementsByTagName(\"a\")[0].href;\n-                    }\n-                } else if (e.which === 16) { // shift\n-                    // Does nothing, it's just to avoid losing \"focus\" on the highlighted element.\n-                } else if (actives[currentTab].length > 0) {\n-                    removeClass(actives[currentTab][0], \"highlighted\");\n-                }\n-            };\n-        }\n-\n-        function buildHrefAndPath(item) {\n-            var displayPath;\n-            var href;\n-            var type = itemTypes[item.ty];\n-            var name = item.name;\n-            var path = item.path;\n-\n-            if (type === \"mod\") {\n-                displayPath = path + \"::\";\n-                href = window.rootPath + path.replace(/::/g, \"/\") + \"/\" +\n-                       name + \"/index.html\";\n-            } else if (type === \"primitive\" || type === \"keyword\") {\n-                displayPath = \"\";\n-                href = window.rootPath + path.replace(/::/g, \"/\") +\n-                       \"/\" + type + \".\" + name + \".html\";\n-            } else if (type === \"externcrate\") {\n-                displayPath = \"\";\n-                href = window.rootPath + name + \"/index.html\";\n-            } else if (item.parent !== undefined) {\n-                var myparent = item.parent;\n-                var anchor = \"#\" + type + \".\" + name;\n-                var parentType = itemTypes[myparent.ty];\n-                var pageType = parentType;\n-                var pageName = myparent.name;\n-\n-                if (parentType === \"primitive\") {\n-                    displayPath = myparent.name + \"::\";\n-                } else if (type === \"structfield\" && parentType === \"variant\") {\n-                    // Structfields belonging to variants are special: the\n-                    // final path element is the enum name.\n-                    var enumNameIdx = item.path.lastIndexOf(\"::\");\n-                    var enumName = item.path.substr(enumNameIdx + 2);\n-                    path = item.path.substr(0, enumNameIdx);\n-                    displayPath = path + \"::\" + enumName + \"::\" + myparent.name + \"::\";\n-                    anchor = \"#variant.\" + myparent.name + \".field.\" + name;\n-                    pageType = \"enum\";\n-                    pageName = enumName;\n-                } else {\n-                    displayPath = path + \"::\" + myparent.name + \"::\";\n-                }\n-                href = window.rootPath + path.replace(/::/g, \"/\") +\n-                       \"/\" + pageType +\n-                       \".\" + pageName +\n-                       \".html\" + anchor;\n-            } else {\n-                displayPath = item.path + \"::\";\n-                href = window.rootPath + item.path.replace(/::/g, \"/\") +\n-                       \"/\" + type + \".\" + name + \".html\";\n-            }\n-            return [displayPath, href];\n-        }\n-\n-        function escape(content) {\n-            var h1 = document.createElement(\"h1\");\n-            h1.textContent = content;\n-            return h1.innerHTML;\n-        }\n-\n-        function pathSplitter(path) {\n-            var tmp = \"<span>\" + path.replace(/::/g, \"::</span><span>\");\n-            if (tmp.endsWith(\"<span>\")) {\n-                return tmp.slice(0, tmp.length - 6);\n-            }\n-            return tmp;\n-        }\n-\n-        function addTab(array, query, display) {\n-            var extraStyle = \"\";\n-            if (display === false) {\n-                extraStyle = \" style=\\\"display: none;\\\"\";\n-            }\n-\n-            var output = \"\";\n-            var duplicates = {};\n-            var length = 0;\n-            if (array.length > 0) {\n-                output = \"<table class=\\\"search-results\\\"\" + extraStyle + \">\";\n-\n-                array.forEach(function(item) {\n-                    var name, type;\n-\n-                    name = item.name;\n-                    type = itemTypes[item.ty];\n-\n-                    if (item.is_alias !== true) {\n-                        if (duplicates[item.fullPath]) {\n-                            return;\n-                        }\n-                        duplicates[item.fullPath] = true;\n-                    }\n-                    length += 1;\n-\n-                    output += \"<tr class=\\\"\" + type + \" result\\\"><td>\" +\n-                              \"<a href=\\\"\" + item.href + \"\\\">\" +\n-                              (item.is_alias === true ?\n-                               (\"<span class=\\\"alias\\\"><b>\" + item.alias + \" </b></span><span \" +\n-                                  \"class=\\\"grey\\\"><i>&nbsp;- see&nbsp;</i></span>\") : \"\") +\n-                              item.displayPath + \"<span class=\\\"\" + type + \"\\\">\" +\n-                              name + \"</span></a></td><td>\" +\n-                              \"<a href=\\\"\" + item.href + \"\\\">\" +\n-                              \"<span class=\\\"desc\\\">\" + item.desc +\n-                              \"&nbsp;</span></a></td></tr>\";\n-                });\n-                output += \"</table>\";\n-            } else {\n-                output = \"<div class=\\\"search-failed\\\"\" + extraStyle + \">No results :(<br/>\" +\n-                    \"Try on <a href=\\\"https://duckduckgo.com/?q=\" +\n-                    encodeURIComponent(\"rust \" + query.query) +\n-                    \"\\\">DuckDuckGo</a>?<br/><br/>\" +\n-                    \"Or try looking in one of these:<ul><li>The <a \" +\n-                    \"href=\\\"https://doc.rust-lang.org/reference/index.html\\\">Rust Reference</a> \" +\n-                    \" for technical details about the language.</li><li><a \" +\n-                    \"href=\\\"https://doc.rust-lang.org/rust-by-example/index.html\\\">Rust By \" +\n-                    \"Example</a> for expository code examples.</a></li><li>The <a \" +\n-                    \"href=\\\"https://doc.rust-lang.org/book/index.html\\\">Rust Book</a> for \" +\n-                    \"introductions to language features and the language itself.</li><li><a \" +\n-                    \"href=\\\"https://docs.rs\\\">Docs.rs</a> for documentation of crates released on\" +\n-                    \" <a href=\\\"https://crates.io/\\\">crates.io</a>.</li></ul></div>\";\n-            }\n-            return [output, length];\n-        }\n-\n-        function makeTabHeader(tabNb, text, nbElems) {\n-            if (currentTab === tabNb) {\n-                return \"<button class=\\\"selected\\\">\" + text +\n-                       \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n-            }\n-            return \"<button>\" + text + \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n-        }\n-\n-        function showResults(results) {\n-            var search = getSearchElement();\n-            if (results.others.length === 1\n-                && getSettingValue(\"go-to-only-result\") === \"true\"\n-                // By default, the search DOM element is \"empty\" (meaning it has no children not\n-                // text content). Once a search has been run, it won't be empty, even if you press\n-                // ESC or empty the search input (which also \"cancels\" the search).\n-                && (!search.firstChild || search.firstChild.innerText !== getSearchLoadingText()))\n-            {\n-                var elem = document.createElement(\"a\");\n-                elem.href = results.others[0].href;\n-                elem.style.display = \"none\";\n-                // For firefox, we need the element to be in the DOM so it can be clicked.\n-                document.body.appendChild(elem);\n-                elem.click();\n-                return;\n-            }\n-            var query = getQuery(search_input.value);\n-\n-            currentResults = query.id;\n-\n-            var ret_others = addTab(results.others, query);\n-            var ret_in_args = addTab(results.in_args, query, false);\n-            var ret_returned = addTab(results.returned, query, false);\n-\n-            // Navigate to the relevant tab if the current tab is empty, like in case users search\n-            // for \"-> String\". If they had selected another tab previously, they have to click on\n-            // it again.\n-            if ((currentTab === 0 && ret_others[1] === 0) ||\n-                    (currentTab === 1 && ret_in_args[1] === 0) ||\n-                    (currentTab === 2 && ret_returned[1] === 0)) {\n-                if (ret_others[1] !== 0) {\n-                    currentTab = 0;\n-                } else if (ret_in_args[1] !== 0) {\n-                    currentTab = 1;\n-                } else if (ret_returned[1] !== 0) {\n-                    currentTab = 2;\n-                }\n-            }\n-\n-            var output = \"<h1>Results for \" + escape(query.query) +\n-                (query.type ? \" (type: \" + escape(query.type) + \")\" : \"\") + \"</h1>\" +\n-                \"<div id=\\\"titles\\\">\" +\n-                makeTabHeader(0, \"In Names\", ret_others[1]) +\n-                makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n-                makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n-                \"</div><div id=\\\"results\\\">\" +\n-                ret_others[0] + ret_in_args[0] + ret_returned[0] + \"</div>\";\n-\n-            search.innerHTML = output;\n-            showSearchResults(search);\n-            initSearchNav();\n-            var elems = document.getElementById(\"titles\").childNodes;\n-            elems[0].onclick = function() { printTab(0); };\n-            elems[1].onclick = function() { printTab(1); };\n-            elems[2].onclick = function() { printTab(2); };\n-            printTab(currentTab);\n-        }\n-\n-        function execSearch(query, searchWords, filterCrates) {\n-            function getSmallest(arrays, positions, notDuplicates) {\n-                var start = null;\n-\n-                for (var it = 0, len = positions.length; it < len; ++it) {\n-                    if (arrays[it].length > positions[it] &&\n-                        (start === null || start > arrays[it][positions[it]].lev) &&\n-                        !notDuplicates[arrays[it][positions[it]].fullPath]) {\n-                        start = arrays[it][positions[it]].lev;\n-                    }\n-                }\n-                return start;\n-            }\n-\n-            function mergeArrays(arrays) {\n-                var ret = [];\n-                var positions = [];\n-                var notDuplicates = {};\n-\n-                for (var x = 0, arrays_len = arrays.length; x < arrays_len; ++x) {\n-                    positions.push(0);\n-                }\n-                while (ret.length < MAX_RESULTS) {\n-                    var smallest = getSmallest(arrays, positions, notDuplicates);\n-\n-                    if (smallest === null) {\n-                        break;\n-                    }\n-                    for (x = 0; x < arrays_len && ret.length < MAX_RESULTS; ++x) {\n-                        if (arrays[x].length > positions[x] &&\n-                                arrays[x][positions[x]].lev === smallest &&\n-                                !notDuplicates[arrays[x][positions[x]].fullPath]) {\n-                            ret.push(arrays[x][positions[x]]);\n-                            notDuplicates[arrays[x][positions[x]].fullPath] = true;\n-                            positions[x] += 1;\n-                        }\n-                    }\n-                }\n-                return ret;\n-            }\n-\n-            var queries = query.raw.split(\",\");\n-            var results = {\n-                \"in_args\": [],\n-                \"returned\": [],\n-                \"others\": [],\n-            };\n-\n-            for (var i = 0, len = queries.length; i < len; ++i) {\n-                query = queries[i].trim();\n-                if (query.length !== 0) {\n-                    var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n-\n-                    results.in_args.push(tmp.in_args);\n-                    results.returned.push(tmp.returned);\n-                    results.others.push(tmp.others);\n-                }\n-            }\n-            if (queries.length > 1) {\n-                return {\n-                    \"in_args\": mergeArrays(results.in_args),\n-                    \"returned\": mergeArrays(results.returned),\n-                    \"others\": mergeArrays(results.others),\n-                };\n-            }\n-            return {\n-                \"in_args\": results.in_args[0],\n-                \"returned\": results.returned[0],\n-                \"others\": results.others[0],\n-            };\n-        }\n-\n-        function getFilterCrates() {\n-            var elem = document.getElementById(\"crate-search\");\n-\n-            if (elem && elem.value !== \"All crates\" && hasOwnProperty(rawSearchIndex, elem.value)) {\n-                return elem.value;\n-            }\n-            return undefined;\n-        }\n-\n-        function search(e, forced) {\n-            var params = getQueryStringParams();\n-            var query = getQuery(search_input.value.trim());\n-\n-            if (e) {\n-                e.preventDefault();\n-            }\n-\n-            if (query.query.length === 0) {\n-                return;\n-            }\n-            if (forced !== true && query.id === currentResults) {\n-                if (query.query.length > 0) {\n-                    putBackSearch(search_input);\n-                }\n-                return;\n-            }\n-\n-            // Update document title to maintain a meaningful browser history\n-            searchTitle = \"Results for \" + query.query + \" - Rust\";\n-\n-            // Because searching is incremental by character, only the most\n-            // recent search query is added to the browser history.\n-            if (browserSupportsHistoryApi()) {\n-                var newURL = getNakedUrl() + \"?search=\" + encodeURIComponent(query.raw) +\n-                    window.location.hash;\n-                if (!history.state && !params.search) {\n-                    history.pushState(query, \"\", newURL);\n-                } else {\n-                    history.replaceState(query, \"\", newURL);\n-                }\n-            }\n-\n-            var filterCrates = getFilterCrates();\n-            showResults(execSearch(query, index, filterCrates));\n-        }\n-\n-        function buildIndex(rawSearchIndex) {\n-            searchIndex = [];\n-            var searchWords = [];\n-            var i, word;\n-            var currentIndex = 0;\n-            var id = 0;\n-\n-            for (var crate in rawSearchIndex) {\n-                if (!hasOwnProperty(rawSearchIndex, crate)) { continue; }\n-\n-                var crateSize = 0;\n-\n-                searchWords.push(crate);\n-                var normalizedName = crate.indexOf(\"_\") === -1\n-                    ? crate\n-                    : crate.replace(/_/g, \"\");\n-                // This object should have exactly the same set of fields as the \"row\"\n-                // object defined below. Your JavaScript runtime will thank you.\n-                // https://mathiasbynens.be/notes/shapes-ics\n-                var crateRow = {\n-                    crate: crate,\n-                    ty: 1, // == ExternCrate\n-                    name: crate,\n-                    path: \"\",\n-                    desc: rawSearchIndex[crate].doc,\n-                    parent: undefined,\n-                    type: null,\n-                    id: id,\n-                    normalizedName: normalizedName,\n-                };\n-                id += 1;\n-                searchIndex.push(crateRow);\n-                currentIndex += 1;\n-\n-                // an array of (Number) item types\n-                var itemTypes = rawSearchIndex[crate].t;\n-                // an array of (String) item names\n-                var itemNames = rawSearchIndex[crate].n;\n-                // an array of (String) full paths (or empty string for previous path)\n-                var itemPaths = rawSearchIndex[crate].q;\n-                // an array of (String) descriptions\n-                var itemDescs = rawSearchIndex[crate].d;\n-                // an array of (Number) the parent path index + 1 to `paths`, or 0 if none\n-                var itemParentIdxs = rawSearchIndex[crate].i;\n-                // an array of (Object | null) the type of the function, if any\n-                var itemFunctionSearchTypes = rawSearchIndex[crate].f;\n-                // an array of [(Number) item type,\n-                //              (String) name]\n-                var paths = rawSearchIndex[crate].p;\n-                // a array of [(String) alias name\n-                //             [Number] index to items]\n-                var aliases = rawSearchIndex[crate].a;\n-\n-                // convert `rawPaths` entries into object form\n-                var len = paths.length;\n-                for (i = 0; i < len; ++i) {\n-                    paths[i] = {ty: paths[i][0], name: paths[i][1]};\n-                }\n-\n-                // convert `item*` into an object form, and construct word indices.\n-                //\n-                // before any analysis is performed lets gather the search terms to\n-                // search against apart from the rest of the data.  This is a quick\n-                // operation that is cached for the life of the page state so that\n-                // all other search operations have access to this cached data for\n-                // faster analysis operations\n-                len = itemTypes.length;\n-                var lastPath = \"\";\n-                for (i = 0; i < len; ++i) {\n-                    // This object should have exactly the same set of fields as the \"crateRow\"\n-                    // object defined above.\n-                    if (typeof itemNames[i] === \"string\") {\n-                        word = itemNames[i].toLowerCase();\n-                        searchWords.push(word);\n-                    } else {\n-                        word = \"\";\n-                        searchWords.push(\"\");\n-                    }\n-                    var normalizedName = word.indexOf(\"_\") === -1\n-                        ? word\n-                        : word.replace(/_/g, \"\");\n-                    var row = {\n-                        crate: crate,\n-                        ty: itemTypes[i],\n-                        name: itemNames[i],\n-                        path: itemPaths[i] ? itemPaths[i] : lastPath,\n-                        desc: itemDescs[i],\n-                        parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n-                        type: itemFunctionSearchTypes[i],\n-                        id: id,\n-                        normalizedName: normalizedName,\n-                    };\n-                    id += 1;\n-                    searchIndex.push(row);\n-                    lastPath = row.path;\n-                    crateSize += 1;\n-                }\n-\n-                if (aliases) {\n-                    ALIASES[crate] = {};\n-                    var j, local_aliases;\n-                    for (var alias_name in aliases) {\n-                        if (!aliases.hasOwnProperty(alias_name)) { continue; }\n-\n-                        if (!ALIASES[crate].hasOwnProperty(alias_name)) {\n-                            ALIASES[crate][alias_name] = [];\n-                        }\n-                        local_aliases = aliases[alias_name];\n-                        for (j = 0, len = local_aliases.length; j < len; ++j) {\n-                            ALIASES[crate][alias_name].push(local_aliases[j] + currentIndex);\n-                        }\n-                    }\n-                }\n-                currentIndex += crateSize;\n-            }\n-            return searchWords;\n-        }\n-\n-        function registerSearchEvents() {\n-            var searchAfter500ms = function() {\n-                clearInputTimeout();\n-                if (search_input.value.length === 0) {\n-                    if (browserSupportsHistoryApi()) {\n-                        history.replaceState(\"\", window.currentCrate + \" - Rust\",\n-                            getNakedUrl() + window.location.hash);\n-                    }\n-                    hideSearchResults();\n-                } else {\n-                    searchTimeout = setTimeout(search, 500);\n-                }\n-            };\n-            search_input.onkeyup = searchAfter500ms;\n-            search_input.oninput = searchAfter500ms;\n-            document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e) {\n-                e.preventDefault();\n-                clearInputTimeout();\n-                search();\n-            };\n-            search_input.onchange = function(e) {\n-                if (e.target !== document.activeElement) {\n-                    // To prevent doing anything when it's from a blur event.\n-                    return;\n-                }\n-                // Do NOT e.preventDefault() here. It will prevent pasting.\n-                clearInputTimeout();\n-                // zero-timeout necessary here because at the time of event handler execution the\n-                // pasted content is not in the input field yet. Shouldn\u2019t make any difference for\n-                // change, though.\n-                setTimeout(search, 0);\n-            };\n-            search_input.onpaste = search_input.onchange;\n-\n-            var selectCrate = document.getElementById(\"crate-search\");\n-            if (selectCrate) {\n-                selectCrate.onchange = function() {\n-                    updateLocalStorage(\"rustdoc-saved-filter-crate\", selectCrate.value);\n-                    search(undefined, true);\n-                };\n-            }\n-\n-            // Push and pop states are used to add search results to the browser\n-            // history.\n-            if (browserSupportsHistoryApi()) {\n-                // Store the previous <title> so we can revert back to it later.\n-                var previousTitle = document.title;\n-\n-                window.addEventListener(\"popstate\", function(e) {\n-                    var params = getQueryStringParams();\n-                    // Revert to the previous title manually since the History\n-                    // API ignores the title parameter.\n-                    document.title = previousTitle;\n-                    // When browsing forward to search results the previous\n-                    // search will be repeated, so the currentResults are\n-                    // cleared to ensure the search is successful.\n-                    currentResults = null;\n-                    // Synchronize search bar with query string state and\n-                    // perform the search. This will empty the bar if there's\n-                    // nothing there, which lets you really go back to a\n-                    // previous state with nothing in the bar.\n-                    if (params.search && params.search.length > 0) {\n-                        search_input.value = params.search;\n-                        // Some browsers fire \"onpopstate\" for every page load\n-                        // (Chrome), while others fire the event only when actually\n-                        // popping a state (Firefox), which is why search() is\n-                        // called both here and at the end of the startSearch()\n-                        // function.\n-                        search(e);\n-                    } else {\n-                        search_input.value = \"\";\n-                        // When browsing back from search results the main page\n-                        // visibility must be reset.\n-                        hideSearchResults();\n-                    }\n-                });\n-            }\n-\n-            // This is required in firefox to avoid this problem: Navigating to a search result\n-            // with the keyboard, hitting enter, and then hitting back would take you back to\n-            // the doc page, rather than the search that should overlay it.\n-            // This was an interaction between the back-forward cache and our handlers\n-            // that try to sync state between the URL and the search input. To work around it,\n-            // do a small amount of re-init on page show.\n-            window.onpageshow = function(){\n-                var qSearch = getQueryStringParams().search;\n-                if (search_input.value === \"\" && qSearch) {\n-                    search_input.value = qSearch;\n-                }\n-                search();\n-            };\n-        }\n-\n-        index = buildIndex(rawSearchIndex);\n-        registerSearchEvents();\n-        // If there's a search term in the URL, execute the search now.\n-        if (getQueryStringParams().search) {\n-            search();\n-        }\n-    };\n-\n     function addSidebarCrates(crates) {\n         // Draw a convenient sidebar of known crates if we have a listing\n         if (window.rootPath === \"../\" || window.rootPath === \"./\") {\n@@ -2216,6 +804,9 @@ function hideThemeButtonState() {\n         block(\"foreigntype\", \"Foreign Types\");\n         block(\"keyword\", \"Keywords\");\n         block(\"traitalias\", \"Trait Aliases\");\n+\n+        // `crates{version}.js` should always be loaded before this script, so we can use it safely.\n+        addSidebarCrates(window.ALL_CRATES);\n     };\n \n     window.register_implementors = function(imp) {\n@@ -2813,60 +1404,6 @@ function hideThemeButtonState() {\n         };\n     });\n \n-    // In the search display, allows to switch between tabs.\n-    function printTab(nb) {\n-        if (nb === 0 || nb === 1 || nb === 2) {\n-            currentTab = nb;\n-        }\n-        var nb_copy = nb;\n-        onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n-            if (nb_copy === 0) {\n-                addClass(elem, \"selected\");\n-            } else {\n-                removeClass(elem, \"selected\");\n-            }\n-            nb_copy -= 1;\n-        });\n-        onEachLazy(document.getElementById(\"results\").childNodes, function(elem) {\n-            if (nb === 0) {\n-                elem.style.display = \"\";\n-            } else {\n-                elem.style.display = \"none\";\n-            }\n-            nb -= 1;\n-        });\n-    }\n-\n-    function putBackSearch(search_input) {\n-        var search = getSearchElement();\n-        if (search_input.value !== \"\" && hasClass(search, \"hidden\")) {\n-            showSearchResults(search);\n-            if (browserSupportsHistoryApi()) {\n-                var extra = \"?search=\" + encodeURIComponent(search_input.value);\n-                history.replaceState(search_input.value, \"\",\n-                    getNakedUrl() + extra + window.location.hash);\n-            }\n-            document.title = searchTitle;\n-        }\n-    }\n-\n-    function getSearchLoadingText() {\n-        return \"Loading search results...\";\n-    }\n-\n-    if (search_input) {\n-        search_input.onfocus = function() {\n-            putBackSearch(this);\n-        };\n-    }\n-\n-    var params = getQueryStringParams();\n-    if (params && params.search) {\n-        var search = getSearchElement();\n-        search.innerHTML = \"<h3 style=\\\"text-align: center;\\\">\" + getSearchLoadingText() + \"</h3>\";\n-        showSearchResults(search);\n-    }\n-\n     var sidebar_menu = document.getElementsByClassName(\"sidebar-menu\")[0];\n     if (sidebar_menu) {\n         sidebar_menu.onclick = function() {\n@@ -2899,30 +1436,6 @@ function hideThemeButtonState() {\n         });\n     }\n \n-    function addSearchOptions(crates) {\n-        var elem = document.getElementById(\"crate-search\");\n-\n-        if (!elem) {\n-            return;\n-        }\n-        var savedCrate = getSettingValue(\"saved-filter-crate\");\n-        for (var i = 0, len = crates.length; i < len; ++i) {\n-            var option = document.createElement(\"option\");\n-            option.value = crates[i];\n-            option.innerText = crates[i];\n-            elem.appendChild(option);\n-            // Set the crate filter from saved storage, if the current page has the saved crate\n-            // filter.\n-            //\n-            // If not, ignore the crate filter -- we want to support filtering for crates on sites\n-            // like doc.rust-lang.org where the crates may differ from page to page while on the\n-            // same domain.\n-            if (crates[i] === savedCrate) {\n-                elem.value = savedCrate;\n-            }\n-        }\n-    };\n-\n     function buildHelperPopup() {\n         var popup = document.createElement(\"aside\");\n         addClass(popup, \"hidden\");\n@@ -2980,55 +1493,14 @@ function hideThemeButtonState() {\n         container.appendChild(div_infos);\n \n         popup.appendChild(container);\n-        insertAfter(popup, getSearchElement());\n+        insertAfter(popup, searchState.outputElement());\n         // So that it's only built once and then it'll do nothing when called!\n         buildHelperPopup = function() {};\n     }\n \n-    function loadScript(url) {\n-        var script = document.createElement('script');\n-        script.src = url;\n-        document.head.append(script);\n-    }\n-\n-    function setupSearchLoader() {\n-        var searchLoaded = false;\n-        function loadSearch() {\n-            if (!searchLoaded) {\n-                searchLoaded = true;\n-                loadScript(window.searchJS);\n-            }\n-        }\n-\n-        // `crates{version}.js` should always be loaded before this script, so we can use it safely.\n-        addSearchOptions(window.ALL_CRATES);\n-        addSidebarCrates(window.ALL_CRATES);\n-\n-        search_input.addEventListener(\"focus\", function() {\n-            search_input.origPlaceholder = search_input.placeholder;\n-            search_input.placeholder = \"Type your search here.\";\n-            loadSearch();\n-        });\n-        search_input.addEventListener(\"blur\", function() {\n-            search_input.placeholder = search_input.origPlaceholder;\n-        });\n-        search_input.removeAttribute('disabled');\n-\n-        var crateSearchDropDown = document.getElementById(\"crate-search\");\n-        // `crateSearchDropDown` can be null in case there is only crate because in that case, the\n-        // crate filter dropdown is removed.\n-        if (crateSearchDropDown) {\n-            crateSearchDropDown.addEventListener(\"focus\", loadSearch);\n-        }\n-        var params = getQueryStringParams();\n-        if (params.search !== undefined) {\n-            loadSearch();\n-        }\n-    }\n-\n     onHashChange(null);\n     window.onhashchange = onHashChange;\n-    setupSearchLoader();\n+    searchState.setup();\n }());\n \n function copy_path(but) {"}, {"sha": "538c811c710971b2d840a631ba06a36026d41ace", "filename": "src/librustdoc/html/static/search.js", "status": "added", "additions": 1512, "deletions": 0, "changes": 1512, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsearch.js?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -0,0 +1,1512 @@\n+(function() {\n+// This mapping table should match the discriminants of\n+// `rustdoc::html::item_type::ItemType` type in Rust.\n+var itemTypes = [\"mod\",\n+                    \"externcrate\",\n+                    \"import\",\n+                    \"struct\",\n+                    \"enum\",\n+                    \"fn\",\n+                    \"type\",\n+                    \"static\",\n+                    \"trait\",\n+                    \"impl\",\n+                    \"tymethod\",\n+                    \"method\",\n+                    \"structfield\",\n+                    \"variant\",\n+                    \"macro\",\n+                    \"primitive\",\n+                    \"associatedtype\",\n+                    \"constant\",\n+                    \"associatedconstant\",\n+                    \"union\",\n+                    \"foreigntype\",\n+                    \"keyword\",\n+                    \"existential\",\n+                    \"attr\",\n+                    \"derive\",\n+                    \"traitalias\"];\n+\n+// used for special search precedence\n+var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n+var TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n+\n+// In the search display, allows to switch between tabs.\n+function printTab(nb) {\n+    if (nb === 0 || nb === 1 || nb === 2) {\n+        searchState.currentTab = nb;\n+    }\n+    var nb_copy = nb;\n+    onEachLazy(document.getElementById(\"titles\").childNodes, function(elem) {\n+        if (nb_copy === 0) {\n+            addClass(elem, \"selected\");\n+        } else {\n+            removeClass(elem, \"selected\");\n+        }\n+        nb_copy -= 1;\n+    });\n+    onEachLazy(document.getElementById(\"results\").childNodes, function(elem) {\n+        if (nb === 0) {\n+            elem.style.display = \"\";\n+        } else {\n+            elem.style.display = \"none\";\n+        }\n+        nb -= 1;\n+    });\n+}\n+\n+function removeEmptyStringsFromArray(x) {\n+    for (var i = 0, len = x.length; i < len; ++i) {\n+        if (x[i] === \"\") {\n+            x.splice(i, 1);\n+            i -= 1;\n+        }\n+    }\n+}\n+\n+/**\n+ * A function to compute the Levenshtein distance between two strings\n+ * Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported\n+ * Full License can be found at http://creativecommons.org/licenses/by-sa/3.0/legalcode\n+ * This code is an unmodified version of the code written by Marco de Wit\n+ * and was found at http://stackoverflow.com/a/18514751/745719\n+ */\n+var levenshtein_row2 = [];\n+function levenshtein(s1, s2) {\n+    if (s1 === s2) {\n+        return 0;\n+    }\n+    var s1_len = s1.length, s2_len = s2.length;\n+    if (s1_len && s2_len) {\n+        var i1 = 0, i2 = 0, a, b, c, c2, row = levenshtein_row2;\n+        while (i1 < s1_len) {\n+            row[i1] = ++i1;\n+        }\n+        while (i2 < s2_len) {\n+            c2 = s2.charCodeAt(i2);\n+            a = i2;\n+            ++i2;\n+            b = i2;\n+            for (i1 = 0; i1 < s1_len; ++i1) {\n+                c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n+                a = row[i1];\n+                b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n+                row[i1] = b;\n+            }\n+        }\n+        return b;\n+    }\n+    return s1_len + s2_len;\n+}\n+\n+window.initSearch = function(rawSearchIndex) {\n+    var MAX_LEV_DISTANCE = 3;\n+    var MAX_RESULTS = 200;\n+    var GENERICS_DATA = 1;\n+    var NAME = 0;\n+    var INPUTS_DATA = 0;\n+    var OUTPUT_DATA = 1;\n+    var NO_TYPE_FILTER = -1;\n+    var currentResults, index, searchIndex;\n+    var ALIASES = {};\n+    var params = searchState.getQueryStringParams();\n+\n+    // Populate search bar with query string search term when provided,\n+    // but only if the input bar is empty. This avoid the obnoxious issue\n+    // where you start trying to do a search, and the index loads, and\n+    // suddenly your search is gone!\n+    if (searchState.input.value === \"\") {\n+        searchState.input.value = params.search || \"\";\n+    }\n+\n+    /**\n+     * Executes the query and builds an index of results\n+     * @param  {[Object]} query      [The user query]\n+     * @param  {[type]} searchWords  [The list of search words to query\n+     *                                against]\n+     * @param  {[type]} filterCrates [Crate to search in if defined]\n+     * @return {[type]}              [A search index of results]\n+     */\n+    function execQuery(query, searchWords, filterCrates) {\n+        function itemTypeFromName(typename) {\n+            for (var i = 0, len = itemTypes.length; i < len; ++i) {\n+                if (itemTypes[i] === typename) {\n+                    return i;\n+                }\n+            }\n+            return NO_TYPE_FILTER;\n+        }\n+\n+        var valLower = query.query.toLowerCase(),\n+            val = valLower,\n+            typeFilter = itemTypeFromName(query.type),\n+            results = {}, results_in_args = {}, results_returned = {},\n+            split = valLower.split(\"::\");\n+\n+        removeEmptyStringsFromArray(split);\n+\n+        function transformResults(results, isType) {\n+            var out = [];\n+            for (var i = 0, len = results.length; i < len; ++i) {\n+                if (results[i].id > -1) {\n+                    var obj = searchIndex[results[i].id];\n+                    obj.lev = results[i].lev;\n+                    if (isType !== true || obj.type) {\n+                        var res = buildHrefAndPath(obj);\n+                        obj.displayPath = pathSplitter(res[0]);\n+                        obj.fullPath = obj.displayPath + obj.name;\n+                        // To be sure than it some items aren't considered as duplicate.\n+                        obj.fullPath += \"|\" + obj.ty;\n+                        obj.href = res[1];\n+                        out.push(obj);\n+                        if (out.length >= MAX_RESULTS) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            return out;\n+        }\n+\n+        function sortResults(results, isType) {\n+            var ar = [];\n+            for (var entry in results) {\n+                if (hasOwnProperty(results, entry)) {\n+                    ar.push(results[entry]);\n+                }\n+            }\n+            results = ar;\n+            var i, len, result;\n+            for (i = 0, len = results.length; i < len; ++i) {\n+                result = results[i];\n+                result.word = searchWords[result.id];\n+                result.item = searchIndex[result.id] || {};\n+            }\n+            // if there are no results then return to default and fail\n+            if (results.length === 0) {\n+                return [];\n+            }\n+\n+            results.sort(function(aaa, bbb) {\n+                var a, b;\n+\n+                // sort by exact match with regard to the last word (mismatch goes later)\n+                a = (aaa.word !== val);\n+                b = (bbb.word !== val);\n+                if (a !== b) { return a - b; }\n+\n+                // Sort by non levenshtein results and then levenshtein results by the distance\n+                // (less changes required to match means higher rankings)\n+                a = (aaa.lev);\n+                b = (bbb.lev);\n+                if (a !== b) { return a - b; }\n+\n+                // sort by crate (non-current crate goes later)\n+                a = (aaa.item.crate !== window.currentCrate);\n+                b = (bbb.item.crate !== window.currentCrate);\n+                if (a !== b) { return a - b; }\n+\n+                // sort by item name length (longer goes later)\n+                a = aaa.word.length;\n+                b = bbb.word.length;\n+                if (a !== b) { return a - b; }\n+\n+                // sort by item name (lexicographically larger goes later)\n+                a = aaa.word;\n+                b = bbb.word;\n+                if (a !== b) { return (a > b ? +1 : -1); }\n+\n+                // sort by index of keyword in item name (no literal occurrence goes later)\n+                a = (aaa.index < 0);\n+                b = (bbb.index < 0);\n+                if (a !== b) { return a - b; }\n+                // (later literal occurrence, if any, goes later)\n+                a = aaa.index;\n+                b = bbb.index;\n+                if (a !== b) { return a - b; }\n+\n+                // special precedence for primitive and keyword pages\n+                if ((aaa.item.ty === TY_PRIMITIVE && bbb.item.ty !== TY_KEYWORD) ||\n+                    (aaa.item.ty === TY_KEYWORD && bbb.item.ty !== TY_PRIMITIVE)) {\n+                    return -1;\n+                }\n+                if ((bbb.item.ty === TY_PRIMITIVE && aaa.item.ty !== TY_PRIMITIVE) ||\n+                    (bbb.item.ty === TY_KEYWORD && aaa.item.ty !== TY_KEYWORD)) {\n+                    return 1;\n+                }\n+\n+                // sort by description (no description goes later)\n+                a = (aaa.item.desc === \"\");\n+                b = (bbb.item.desc === \"\");\n+                if (a !== b) { return a - b; }\n+\n+                // sort by type (later occurrence in `itemTypes` goes later)\n+                a = aaa.item.ty;\n+                b = bbb.item.ty;\n+                if (a !== b) { return a - b; }\n+\n+                // sort by path (lexicographically larger goes later)\n+                a = aaa.item.path;\n+                b = bbb.item.path;\n+                if (a !== b) { return (a > b ? +1 : -1); }\n+\n+                // que sera, sera\n+                return 0;\n+            });\n+\n+            for (i = 0, len = results.length; i < len; ++i) {\n+                var result = results[i];\n+\n+                // this validation does not make sense when searching by types\n+                if (result.dontValidate) {\n+                    continue;\n+                }\n+                var name = result.item.name.toLowerCase(),\n+                    path = result.item.path.toLowerCase(),\n+                    parent = result.item.parent;\n+\n+                if (isType !== true &&\n+                    validateResult(name, path, split, parent) === false)\n+                {\n+                    result.id = -1;\n+                }\n+            }\n+            return transformResults(results);\n+        }\n+\n+        function extractGenerics(val) {\n+            val = val.toLowerCase();\n+            if (val.indexOf(\"<\") !== -1) {\n+                var values = val.substring(val.indexOf(\"<\") + 1, val.lastIndexOf(\">\"));\n+                return {\n+                    name: val.substring(0, val.indexOf(\"<\")),\n+                    generics: values.split(/\\s*,\\s*/),\n+                };\n+            }\n+            return {\n+                name: val,\n+                generics: [],\n+            };\n+        }\n+\n+        function getObjectNameFromId(id) {\n+            if (typeof id === \"number\") {\n+                return searchIndex[id].name;\n+            }\n+            return id;\n+        }\n+\n+        function checkGenerics(obj, val) {\n+            // The names match, but we need to be sure that all generics kinda\n+            // match as well.\n+            var tmp_lev, elem_name;\n+            if (val.generics.length > 0) {\n+                if (obj.length > GENERICS_DATA &&\n+                      obj[GENERICS_DATA].length >= val.generics.length) {\n+                    var elems = Object.create(null);\n+                    var elength = object[GENERICS_DATA].length;\n+                    for (var x = 0; x < elength; ++x) {\n+                        elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n+                    }\n+                    var total = 0;\n+                    var done = 0;\n+                    // We need to find the type that matches the most to remove it in order\n+                    // to move forward.\n+                    var vlength = val.generics.length;\n+                    for (x = 0; x < vlength; ++x) {\n+                        var lev = MAX_LEV_DISTANCE + 1;\n+                        var firstGeneric = getObjectNameFromId(val.generics[x]);\n+                        var match = null;\n+                        if (elems[firstGeneric]) {\n+                            match = firstGeneric;\n+                            lev = 0;\n+                        } else {\n+                            for (elem_name in elems) {\n+                                tmp_lev = levenshtein(elem_name, firstGeneric);\n+                                if (tmp_lev < lev) {\n+                                    lev = tmp_lev;\n+                                    match = elem_name;\n+                                }\n+                            }\n+                        }\n+                        if (match !== null) {\n+                            elems[match] -= 1;\n+                            if (elems[match] == 0) {\n+                                delete elems[match];\n+                            }\n+                            total += lev;\n+                            done += 1;\n+                        } else {\n+                            return MAX_LEV_DISTANCE + 1;\n+                        }\n+                    }\n+                    return Math.ceil(total / done);\n+                }\n+            }\n+            return MAX_LEV_DISTANCE + 1;\n+        }\n+\n+        // Check for type name and type generics (if any).\n+        function checkType(obj, val, literalSearch) {\n+            var lev_distance = MAX_LEV_DISTANCE + 1;\n+            var len, x, firstGeneric;\n+            if (obj[NAME] === val.name) {\n+                if (literalSearch === true) {\n+                    if (val.generics && val.generics.length !== 0) {\n+                        if (obj.length > GENERICS_DATA &&\n+                              obj[GENERICS_DATA].length >= val.generics.length) {\n+                            var elems = Object.create(null);\n+                            len = obj[GENERICS_DATA].length;\n+                            for (x = 0; x < len; ++x) {\n+                                elems[getObjectNameFromId(obj[GENERICS_DATA][x])] += 1;\n+                            }\n+\n+                            var allFound = true;\n+                            len = val.generics.length;\n+                            for (x = 0; x < len; ++x) {\n+                                firstGeneric = getObjectNameFromId(val.generics[x]);\n+                                if (elems[firstGeneric]) {\n+                                    elems[firstGeneric] -= 1;\n+                                } else {\n+                                    allFound = false;\n+                                    break;\n+                                }\n+                            }\n+                            if (allFound === true) {\n+                                return true;\n+                            }\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                    return true;\n+                }\n+                // If the type has generics but don't match, then it won't return at this point.\n+                // Otherwise, `checkGenerics` will return 0 and it'll return.\n+                if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length !== 0) {\n+                    var tmp_lev = checkGenerics(obj, val);\n+                    if (tmp_lev <= MAX_LEV_DISTANCE) {\n+                        return tmp_lev;\n+                    }\n+                } else {\n+                    return 0;\n+                }\n+            }\n+            // Names didn't match so let's check if one of the generic types could.\n+            if (literalSearch === true) {\n+                 if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n+                    return obj[GENERICS_DATA].some(\n+                        function(name) {\n+                            return name === val.name;\n+                        });\n+                }\n+                return false;\n+            }\n+            lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n+            if (lev_distance <= MAX_LEV_DISTANCE) {\n+                // The generics didn't match but the name kinda did so we give it\n+                // a levenshtein distance value that isn't *this* good so it goes\n+                // into the search results but not too high.\n+                lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n+            } else if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n+                // We can check if the type we're looking for is inside the generics!\n+                var olength = obj[GENERICS_DATA].length;\n+                for (x = 0; x < olength; ++x) {\n+                    lev_distance = Math.min(levenshtein(obj[GENERICS_DATA][x], val.name),\n+                                            lev_distance);\n+                }\n+            }\n+            // Now whatever happens, the returned distance is \"less good\" so we should mark it\n+            // as such, and so we add 1 to the distance to make it \"less good\".\n+            return lev_distance + 1;\n+        }\n+\n+        function findArg(obj, val, literalSearch, typeFilter) {\n+            var lev_distance = MAX_LEV_DISTANCE + 1;\n+\n+            if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n+                var length = obj.type[INPUTS_DATA].length;\n+                for (var i = 0; i < length; i++) {\n+                    var tmp = obj.type[INPUTS_DATA][i];\n+                    if (typePassesFilter(typeFilter, tmp[1]) === false) {\n+                        continue;\n+                    }\n+                    tmp = checkType(tmp, val, literalSearch);\n+                    if (literalSearch === true) {\n+                        if (tmp === true) {\n+                            return true;\n+                        }\n+                        continue;\n+                    }\n+                    lev_distance = Math.min(tmp, lev_distance);\n+                    if (lev_distance === 0) {\n+                        return 0;\n+                    }\n+                }\n+            }\n+            return literalSearch === true ? false : lev_distance;\n+        }\n+\n+        function checkReturned(obj, val, literalSearch, typeFilter) {\n+            var lev_distance = MAX_LEV_DISTANCE + 1;\n+\n+            if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n+                var ret = obj.type[OUTPUT_DATA];\n+                if (typeof ret[0] === \"string\") {\n+                    ret = [ret];\n+                }\n+                for (var x = 0, len = ret.length; x < len; ++x) {\n+                    var tmp = ret[x];\n+                    if (typePassesFilter(typeFilter, tmp[1]) === false) {\n+                        continue;\n+                    }\n+                    tmp = checkType(tmp, val, literalSearch);\n+                    if (literalSearch === true) {\n+                        if (tmp === true) {\n+                            return true;\n+                        }\n+                        continue;\n+                    }\n+                    lev_distance = Math.min(tmp, lev_distance);\n+                    if (lev_distance === 0) {\n+                        return 0;\n+                    }\n+                }\n+            }\n+            return literalSearch === true ? false : lev_distance;\n+        }\n+\n+        function checkPath(contains, lastElem, ty) {\n+            if (contains.length === 0) {\n+                return 0;\n+            }\n+            var ret_lev = MAX_LEV_DISTANCE + 1;\n+            var path = ty.path.split(\"::\");\n+\n+            if (ty.parent && ty.parent.name) {\n+                path.push(ty.parent.name.toLowerCase());\n+            }\n+\n+            var length = path.length;\n+            var clength = contains.length;\n+            if (clength > length) {\n+                return MAX_LEV_DISTANCE + 1;\n+            }\n+            for (var i = 0; i < length; ++i) {\n+                if (i + clength > length) {\n+                    break;\n+                }\n+                var lev_total = 0;\n+                var aborted = false;\n+                for (var x = 0; x < clength; ++x) {\n+                    var lev = levenshtein(path[i + x], contains[x]);\n+                    if (lev > MAX_LEV_DISTANCE) {\n+                        aborted = true;\n+                        break;\n+                    }\n+                    lev_total += lev;\n+                }\n+                if (aborted === false) {\n+                    ret_lev = Math.min(ret_lev, Math.round(lev_total / clength));\n+                }\n+            }\n+            return ret_lev;\n+        }\n+\n+        function typePassesFilter(filter, type) {\n+            // No filter\n+            if (filter <= NO_TYPE_FILTER) return true;\n+\n+            // Exact match\n+            if (filter === type) return true;\n+\n+            // Match related items\n+            var name = itemTypes[type];\n+            switch (itemTypes[filter]) {\n+                case \"constant\":\n+                    return name === \"associatedconstant\";\n+                case \"fn\":\n+                    return name === \"method\" || name === \"tymethod\";\n+                case \"type\":\n+                    return name === \"primitive\" || name === \"associatedtype\";\n+                case \"trait\":\n+                    return name === \"traitalias\";\n+            }\n+\n+            // No match\n+            return false;\n+        }\n+\n+        function createAliasFromItem(item) {\n+            return {\n+                crate: item.crate,\n+                name: item.name,\n+                path: item.path,\n+                desc: item.desc,\n+                ty: item.ty,\n+                parent: item.parent,\n+                type: item.type,\n+                is_alias: true,\n+            };\n+        }\n+\n+        function handleAliases(ret, query, filterCrates) {\n+            // We separate aliases and crate aliases because we want to have current crate\n+            // aliases to be before the others in the displayed results.\n+            var aliases = [];\n+            var crateAliases = [];\n+            if (filterCrates !== undefined) {\n+                if (ALIASES[filterCrates] && ALIASES[filterCrates][query.search]) {\n+                    var query_aliases = ALIASES[filterCrates][query.search];\n+                    var len = query_aliases.length;\n+                    for (var i = 0; i < len; ++i) {\n+                        aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n+                    }\n+                }\n+            } else {\n+                Object.keys(ALIASES).forEach(function(crate) {\n+                    if (ALIASES[crate][query.search]) {\n+                        var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n+                        var query_aliases = ALIASES[crate][query.search];\n+                        var len = query_aliases.length;\n+                        for (var i = 0; i < len; ++i) {\n+                            pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n+                        }\n+                    }\n+                });\n+            }\n+\n+            var sortFunc = function(aaa, bbb) {\n+                if (aaa.path < bbb.path) {\n+                    return 1;\n+                } else if (aaa.path === bbb.path) {\n+                    return 0;\n+                }\n+                return -1;\n+            };\n+            crateAliases.sort(sortFunc);\n+            aliases.sort(sortFunc);\n+\n+            var pushFunc = function(alias) {\n+                alias.alias = query.raw;\n+                var res = buildHrefAndPath(alias);\n+                alias.displayPath = pathSplitter(res[0]);\n+                alias.fullPath = alias.displayPath + alias.name;\n+                alias.href = res[1];\n+\n+                ret.others.unshift(alias);\n+                if (ret.others.length > MAX_RESULTS) {\n+                    ret.others.pop();\n+                }\n+            };\n+            onEach(aliases, pushFunc);\n+            onEach(crateAliases, pushFunc);\n+        }\n+\n+        // quoted values mean literal search\n+        var nSearchWords = searchWords.length;\n+        var i, it;\n+        var ty;\n+        var fullId;\n+        var returned;\n+        var in_args;\n+        var len;\n+        if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n+            val.charAt(val.length - 1) === val.charAt(0))\n+        {\n+            val = extractGenerics(val.substr(1, val.length - 2));\n+            for (i = 0; i < nSearchWords; ++i) {\n+                if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n+                    continue;\n+                }\n+                in_args = findArg(searchIndex[i], val, true, typeFilter);\n+                returned = checkReturned(searchIndex[i], val, true, typeFilter);\n+                ty = searchIndex[i];\n+                fullId = ty.id;\n+\n+                if (searchWords[i] === val.name\n+                    && typePassesFilter(typeFilter, searchIndex[i].ty)\n+                    && results[fullId] === undefined) {\n+                    results[fullId] = {\n+                        id: i,\n+                        index: -1,\n+                        dontValidate: true,\n+                    };\n+                }\n+                if (in_args === true && results_in_args[fullId] === undefined) {\n+                    results_in_args[fullId] = {\n+                        id: i,\n+                        index: -1,\n+                        dontValidate: true,\n+                    };\n+                }\n+                if (returned === true && results_returned[fullId] === undefined) {\n+                    results_returned[fullId] = {\n+                        id: i,\n+                        index: -1,\n+                        dontValidate: true,\n+                    };\n+                }\n+            }\n+            query.inputs = [val];\n+            query.output = val;\n+            query.search = val;\n+        // searching by type\n+        } else if (val.search(\"->\") > -1) {\n+            var trimmer = function(s) { return s.trim(); };\n+            var parts = val.split(\"->\").map(trimmer);\n+            var input = parts[0];\n+            // sort inputs so that order does not matter\n+            var inputs = input.split(\",\").map(trimmer).sort();\n+            for (i = 0, len = inputs.length; i < len; ++i) {\n+                inputs[i] = extractGenerics(inputs[i]);\n+            }\n+            var output = extractGenerics(parts[1]);\n+\n+            for (i = 0; i < nSearchWords; ++i) {\n+                if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n+                    continue;\n+                }\n+                var type = searchIndex[i].type;\n+                ty = searchIndex[i];\n+                if (!type) {\n+                    continue;\n+                }\n+                fullId = ty.id;\n+\n+                returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n+                if (output.name === \"*\" || returned === true) {\n+                    in_args = false;\n+                    var is_module = false;\n+\n+                    if (input === \"*\") {\n+                        is_module = true;\n+                    } else {\n+                        var allFound = true;\n+                        for (it = 0, len = inputs.length; allFound === true && it < len; it++) {\n+                            allFound = checkType(type, inputs[it], true);\n+                        }\n+                        in_args = allFound;\n+                    }\n+                    if (in_args === true) {\n+                        results_in_args[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                    if (returned === true) {\n+                        results_returned[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                    if (is_module === true) {\n+                        results[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                }\n+            }\n+            query.inputs = inputs.map(function(input) {\n+                return input.name;\n+            });\n+            query.output = output.name;\n+        } else {\n+            query.inputs = [val];\n+            query.output = val;\n+            query.search = val;\n+            // gather matching search results up to a certain maximum\n+            val = val.replace(/\\_/g, \"\");\n+\n+            var valGenerics = extractGenerics(val);\n+\n+            var paths = valLower.split(\"::\");\n+            removeEmptyStringsFromArray(paths);\n+            val = paths[paths.length - 1];\n+            var contains = paths.slice(0, paths.length > 1 ? paths.length - 1 : 1);\n+\n+            var lev, j;\n+            for (j = 0; j < nSearchWords; ++j) {\n+                ty = searchIndex[j];\n+                if (!ty || (filterCrates !== undefined && ty.crate !== filterCrates)) {\n+                    continue;\n+                }\n+                var lev_add = 0;\n+                if (paths.length > 1) {\n+                    lev = checkPath(contains, paths[paths.length - 1], ty);\n+                    if (lev > MAX_LEV_DISTANCE) {\n+                        continue;\n+                    } else if (lev > 0) {\n+                        lev_add = lev / 10;\n+                    }\n+                }\n+\n+                returned = MAX_LEV_DISTANCE + 1;\n+                in_args = MAX_LEV_DISTANCE + 1;\n+                var index = -1;\n+                // we want lev results to go lower than others\n+                lev = MAX_LEV_DISTANCE + 1;\n+                fullId = ty.id;\n+\n+                if (searchWords[j].indexOf(split[i]) > -1 ||\n+                    searchWords[j].indexOf(val) > -1 ||\n+                    ty.normalizedName.indexOf(val) > -1)\n+                {\n+                    // filter type: ... queries\n+                    if (typePassesFilter(typeFilter, ty.ty) && results[fullId] === undefined) {\n+                        index = ty.normalizedName.indexOf(val);\n+                    }\n+                }\n+                if ((lev = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n+                    if (typePassesFilter(typeFilter, ty.ty) === false) {\n+                        lev = MAX_LEV_DISTANCE + 1;\n+                    } else {\n+                        lev += 1;\n+                    }\n+                }\n+                in_args = findArg(ty, valGenerics, false, typeFilter);\n+                returned = checkReturned(ty, valGenerics, false, typeFilter);\n+\n+                lev += lev_add;\n+                if (lev > 0 && val.length > 3 && searchWords[j].indexOf(val) > -1) {\n+                    if (val.length < 6) {\n+                        lev -= 1;\n+                    } else {\n+                        lev = 0;\n+                    }\n+                }\n+                if (in_args <= MAX_LEV_DISTANCE) {\n+                    if (results_in_args[fullId] === undefined) {\n+                        results_in_args[fullId] = {\n+                            id: j,\n+                            index: index,\n+                            lev: in_args,\n+                        };\n+                    }\n+                    results_in_args[fullId].lev =\n+                        Math.min(results_in_args[fullId].lev, in_args);\n+                }\n+                if (returned <= MAX_LEV_DISTANCE) {\n+                    if (results_returned[fullId] === undefined) {\n+                        results_returned[fullId] = {\n+                            id: j,\n+                            index: index,\n+                            lev: returned,\n+                        };\n+                    }\n+                    results_returned[fullId].lev =\n+                        Math.min(results_returned[fullId].lev, returned);\n+                }\n+                if (index !== -1 || lev <= MAX_LEV_DISTANCE) {\n+                    if (index !== -1 && paths.length < 2) {\n+                        lev = 0;\n+                    }\n+                    if (results[fullId] === undefined) {\n+                        results[fullId] = {\n+                            id: j,\n+                            index: index,\n+                            lev: lev,\n+                        };\n+                    }\n+                    results[fullId].lev = Math.min(results[fullId].lev, lev);\n+                }\n+            }\n+        }\n+\n+        var ret = {\n+            \"in_args\": sortResults(results_in_args, true),\n+            \"returned\": sortResults(results_returned, true),\n+            \"others\": sortResults(results),\n+        };\n+        handleAliases(ret, query, filterCrates);\n+        return ret;\n+    }\n+\n+    /**\n+     * Validate performs the following boolean logic. For example:\n+     * \"File::open\" will give IF A PARENT EXISTS => (\"file\" && \"open\")\n+     * exists in (name || path || parent) OR => (\"file\" && \"open\") exists in\n+     * (name || path )\n+     *\n+     * This could be written functionally, but I wanted to minimise\n+     * functions on stack.\n+     *\n+     * @param  {[string]} name   [The name of the result]\n+     * @param  {[string]} path   [The path of the result]\n+     * @param  {[string]} keys   [The keys to be used ([\"file\", \"open\"])]\n+     * @param  {[object]} parent [The parent of the result]\n+     * @return {[boolean]}       [Whether the result is valid or not]\n+     */\n+    function validateResult(name, path, keys, parent) {\n+        for (var i = 0, len = keys.length; i < len; ++i) {\n+            // each check is for validation so we negate the conditions and invalidate\n+            if (!(\n+                // check for an exact name match\n+                name.indexOf(keys[i]) > -1 ||\n+                // then an exact path match\n+                path.indexOf(keys[i]) > -1 ||\n+                // next if there is a parent, check for exact parent match\n+                (parent !== undefined && parent.name !== undefined &&\n+                    parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n+                // lastly check to see if the name was a levenshtein match\n+                levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    function getQuery(raw) {\n+        var matches, type, query;\n+        query = raw;\n+\n+        matches = query.match(/^(fn|mod|struct|enum|trait|type|const|macro)\\s*:\\s*/i);\n+        if (matches) {\n+            type = matches[1].replace(/^const$/, \"constant\");\n+            query = query.substring(matches[0].length);\n+        }\n+\n+        return {\n+            raw: raw,\n+            query: query,\n+            type: type,\n+            id: query + type\n+        };\n+    }\n+\n+    function initSearchNav() {\n+        var hoverTimeout;\n+\n+        var click_func = function(e) {\n+            var el = e.target;\n+            // to retrieve the real \"owner\" of the event.\n+            while (el.tagName !== \"TR\") {\n+                el = el.parentNode;\n+            }\n+            var dst = e.target.getElementsByTagName(\"a\");\n+            if (dst.length < 1) {\n+                return;\n+            }\n+            dst = dst[0];\n+            if (window.location.pathname === dst.pathname) {\n+                searchState.hideResults();\n+                document.location.href = dst.href;\n+            }\n+        };\n+        var mouseover_func = function(e) {\n+            if (searchState.mouseMovedAfterSearch) {\n+                var el = e.target;\n+                // to retrieve the real \"owner\" of the event.\n+                while (el.tagName !== \"TR\") {\n+                    el = el.parentNode;\n+                }\n+                clearTimeout(hoverTimeout);\n+                hoverTimeout = setTimeout(function() {\n+                    onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n+                        onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n+                            removeClass(i_e, \"highlighted\");\n+                        });\n+                    });\n+                    addClass(el, \"highlighted\");\n+                }, 20);\n+            }\n+        };\n+        onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n+            onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n+                i_e.onclick = click_func;\n+                i_e.onmouseover = mouseover_func;\n+            });\n+        });\n+\n+        searchState.input.onkeydown = function(e) {\n+            // \"actives\" references the currently highlighted item in each search tab.\n+            // Each array in \"actives\" represents a tab.\n+            var actives = [[], [], []];\n+            // \"current\" is used to know which tab we're looking into.\n+            var current = 0;\n+            onEachLazy(document.getElementById(\"results\").childNodes, function(e) {\n+                onEachLazy(e.getElementsByClassName(\"highlighted\"), function(h_e) {\n+                    actives[current].push(h_e);\n+                });\n+                current += 1;\n+            });\n+\n+            var currentTab = searchState.currentTab;\n+            if (e.which === 38) { // up\n+                if (e.ctrlKey) { // Going through result tabs.\n+                    printTab(currentTab > 0 ? currentTab - 1 : 2);\n+                } else {\n+                    if (!actives[currentTab].length ||\n+                        !actives[currentTab][0].previousElementSibling) {\n+                        return;\n+                    }\n+                    addClass(actives[currentTab][0].previousElementSibling, \"highlighted\");\n+                    removeClass(actives[currentTab][0], \"highlighted\");\n+                }\n+                e.preventDefault();\n+            } else if (e.which === 40) { // down\n+                if (e.ctrlKey) { // Going through result tabs.\n+                    printTab(currentTab > 1 ? 0 : currentTab + 1);\n+                } else if (!actives[currentTab].length) {\n+                    var results = document.getElementById(\"results\").childNodes;\n+                    if (results.length > 0) {\n+                        var res = results[currentTab].getElementsByClassName(\"result\");\n+                        if (res.length > 0) {\n+                            addClass(res[0], \"highlighted\");\n+                        }\n+                    }\n+                } else if (actives[currentTab][0].nextElementSibling) {\n+                    addClass(actives[currentTab][0].nextElementSibling, \"highlighted\");\n+                    removeClass(actives[currentTab][0], \"highlighted\");\n+                }\n+                e.preventDefault();\n+            } else if (e.which === 13) { // return\n+                if (actives[currentTab].length) {\n+                    document.location.href =\n+                        actives[currentTab][0].getElementsByTagName(\"a\")[0].href;\n+                }\n+            } else if (e.which === 16) { // shift\n+                // Does nothing, it's just to avoid losing \"focus\" on the highlighted element.\n+            } else if (actives[currentTab].length > 0) {\n+                removeClass(actives[currentTab][0], \"highlighted\");\n+            }\n+        };\n+    }\n+\n+    function buildHrefAndPath(item) {\n+        var displayPath;\n+        var href;\n+        var type = itemTypes[item.ty];\n+        var name = item.name;\n+        var path = item.path;\n+\n+        if (type === \"mod\") {\n+            displayPath = path + \"::\";\n+            href = window.rootPath + path.replace(/::/g, \"/\") + \"/\" +\n+                   name + \"/index.html\";\n+        } else if (type === \"primitive\" || type === \"keyword\") {\n+            displayPath = \"\";\n+            href = window.rootPath + path.replace(/::/g, \"/\") +\n+                   \"/\" + type + \".\" + name + \".html\";\n+        } else if (type === \"externcrate\") {\n+            displayPath = \"\";\n+            href = window.rootPath + name + \"/index.html\";\n+        } else if (item.parent !== undefined) {\n+            var myparent = item.parent;\n+            var anchor = \"#\" + type + \".\" + name;\n+            var parentType = itemTypes[myparent.ty];\n+            var pageType = parentType;\n+            var pageName = myparent.name;\n+\n+            if (parentType === \"primitive\") {\n+                displayPath = myparent.name + \"::\";\n+            } else if (type === \"structfield\" && parentType === \"variant\") {\n+                // Structfields belonging to variants are special: the\n+                // final path element is the enum name.\n+                var enumNameIdx = item.path.lastIndexOf(\"::\");\n+                var enumName = item.path.substr(enumNameIdx + 2);\n+                path = item.path.substr(0, enumNameIdx);\n+                displayPath = path + \"::\" + enumName + \"::\" + myparent.name + \"::\";\n+                anchor = \"#variant.\" + myparent.name + \".field.\" + name;\n+                pageType = \"enum\";\n+                pageName = enumName;\n+            } else {\n+                displayPath = path + \"::\" + myparent.name + \"::\";\n+            }\n+            href = window.rootPath + path.replace(/::/g, \"/\") +\n+                   \"/\" + pageType +\n+                   \".\" + pageName +\n+                   \".html\" + anchor;\n+        } else {\n+            displayPath = item.path + \"::\";\n+            href = window.rootPath + item.path.replace(/::/g, \"/\") +\n+                   \"/\" + type + \".\" + name + \".html\";\n+        }\n+        return [displayPath, href];\n+    }\n+\n+    function escape(content) {\n+        var h1 = document.createElement(\"h1\");\n+        h1.textContent = content;\n+        return h1.innerHTML;\n+    }\n+\n+    function pathSplitter(path) {\n+        var tmp = \"<span>\" + path.replace(/::/g, \"::</span><span>\");\n+        if (tmp.endsWith(\"<span>\")) {\n+            return tmp.slice(0, tmp.length - 6);\n+        }\n+        return tmp;\n+    }\n+\n+    function addTab(array, query, display) {\n+        var extraStyle = \"\";\n+        if (display === false) {\n+            extraStyle = \" style=\\\"display: none;\\\"\";\n+        }\n+\n+        var output = \"\";\n+        var duplicates = {};\n+        var length = 0;\n+        if (array.length > 0) {\n+            output = \"<table class=\\\"search-results\\\"\" + extraStyle + \">\";\n+\n+            array.forEach(function(item) {\n+                var name, type;\n+\n+                name = item.name;\n+                type = itemTypes[item.ty];\n+\n+                if (item.is_alias !== true) {\n+                    if (duplicates[item.fullPath]) {\n+                        return;\n+                    }\n+                    duplicates[item.fullPath] = true;\n+                }\n+                length += 1;\n+\n+                output += \"<tr class=\\\"\" + type + \" result\\\"><td>\" +\n+                          \"<a href=\\\"\" + item.href + \"\\\">\" +\n+                          (item.is_alias === true ?\n+                           (\"<span class=\\\"alias\\\"><b>\" + item.alias + \" </b></span><span \" +\n+                              \"class=\\\"grey\\\"><i>&nbsp;- see&nbsp;</i></span>\") : \"\") +\n+                          item.displayPath + \"<span class=\\\"\" + type + \"\\\">\" +\n+                          name + \"</span></a></td><td>\" +\n+                          \"<a href=\\\"\" + item.href + \"\\\">\" +\n+                          \"<span class=\\\"desc\\\">\" + item.desc +\n+                          \"&nbsp;</span></a></td></tr>\";\n+            });\n+            output += \"</table>\";\n+        } else {\n+            output = \"<div class=\\\"search-failed\\\"\" + extraStyle + \">No results :(<br/>\" +\n+                \"Try on <a href=\\\"https://duckduckgo.com/?q=\" +\n+                encodeURIComponent(\"rust \" + query.query) +\n+                \"\\\">DuckDuckGo</a>?<br/><br/>\" +\n+                \"Or try looking in one of these:<ul><li>The <a \" +\n+                \"href=\\\"https://doc.rust-lang.org/reference/index.html\\\">Rust Reference</a> \" +\n+                \" for technical details about the language.</li><li><a \" +\n+                \"href=\\\"https://doc.rust-lang.org/rust-by-example/index.html\\\">Rust By \" +\n+                \"Example</a> for expository code examples.</a></li><li>The <a \" +\n+                \"href=\\\"https://doc.rust-lang.org/book/index.html\\\">Rust Book</a> for \" +\n+                \"introductions to language features and the language itself.</li><li><a \" +\n+                \"href=\\\"https://docs.rs\\\">Docs.rs</a> for documentation of crates released on\" +\n+                \" <a href=\\\"https://crates.io/\\\">crates.io</a>.</li></ul></div>\";\n+        }\n+        return [output, length];\n+    }\n+\n+    function makeTabHeader(tabNb, text, nbElems) {\n+        if (searchState.currentTab === tabNb) {\n+            return \"<button class=\\\"selected\\\">\" + text +\n+                   \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n+        }\n+        return \"<button>\" + text + \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n+    }\n+\n+    function showResults(results) {\n+        var search = searchState.outputElement();\n+        if (results.others.length === 1\n+            && getSettingValue(\"go-to-only-result\") === \"true\"\n+            // By default, the search DOM element is \"empty\" (meaning it has no children not\n+            // text content). Once a search has been run, it won't be empty, even if you press\n+            // ESC or empty the search input (which also \"cancels\" the search).\n+            && (!search.firstChild || search.firstChild.innerText !== searchState.loadingText))\n+        {\n+            var elem = document.createElement(\"a\");\n+            elem.href = results.others[0].href;\n+            elem.style.display = \"none\";\n+            // For firefox, we need the element to be in the DOM so it can be clicked.\n+            document.body.appendChild(elem);\n+            elem.click();\n+            return;\n+        }\n+        var query = getQuery(searchState.input.value);\n+\n+        currentResults = query.id;\n+\n+        var ret_others = addTab(results.others, query);\n+        var ret_in_args = addTab(results.in_args, query, false);\n+        var ret_returned = addTab(results.returned, query, false);\n+\n+        // Navigate to the relevant tab if the current tab is empty, like in case users search\n+        // for \"-> String\". If they had selected another tab previously, they have to click on\n+        // it again.\n+        var currentTab = searchState.currentTab;\n+        if ((currentTab === 0 && ret_others[1] === 0) ||\n+                (currentTab === 1 && ret_in_args[1] === 0) ||\n+                (currentTab === 2 && ret_returned[1] === 0)) {\n+            if (ret_others[1] !== 0) {\n+                currentTab = 0;\n+            } else if (ret_in_args[1] !== 0) {\n+                currentTab = 1;\n+            } else if (ret_returned[1] !== 0) {\n+                currentTab = 2;\n+            }\n+        }\n+\n+        var output = \"<h1>Results for \" + escape(query.query) +\n+            (query.type ? \" (type: \" + escape(query.type) + \")\" : \"\") + \"</h1>\" +\n+            \"<div id=\\\"titles\\\">\" +\n+            makeTabHeader(0, \"In Names\", ret_others[1]) +\n+            makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n+            makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n+            \"</div><div id=\\\"results\\\">\" +\n+            ret_others[0] + ret_in_args[0] + ret_returned[0] + \"</div>\";\n+\n+        search.innerHTML = output;\n+        searchState.showResults(search);\n+        initSearchNav();\n+        var elems = document.getElementById(\"titles\").childNodes;\n+        elems[0].onclick = function() { printTab(0); };\n+        elems[1].onclick = function() { printTab(1); };\n+        elems[2].onclick = function() { printTab(2); };\n+        printTab(currentTab);\n+    }\n+\n+    function execSearch(query, searchWords, filterCrates) {\n+        function getSmallest(arrays, positions, notDuplicates) {\n+            var start = null;\n+\n+            for (var it = 0, len = positions.length; it < len; ++it) {\n+                if (arrays[it].length > positions[it] &&\n+                    (start === null || start > arrays[it][positions[it]].lev) &&\n+                    !notDuplicates[arrays[it][positions[it]].fullPath]) {\n+                    start = arrays[it][positions[it]].lev;\n+                }\n+            }\n+            return start;\n+        }\n+\n+        function mergeArrays(arrays) {\n+            var ret = [];\n+            var positions = [];\n+            var notDuplicates = {};\n+\n+            for (var x = 0, arrays_len = arrays.length; x < arrays_len; ++x) {\n+                positions.push(0);\n+            }\n+            while (ret.length < MAX_RESULTS) {\n+                var smallest = getSmallest(arrays, positions, notDuplicates);\n+\n+                if (smallest === null) {\n+                    break;\n+                }\n+                for (x = 0; x < arrays_len && ret.length < MAX_RESULTS; ++x) {\n+                    if (arrays[x].length > positions[x] &&\n+                            arrays[x][positions[x]].lev === smallest &&\n+                            !notDuplicates[arrays[x][positions[x]].fullPath]) {\n+                        ret.push(arrays[x][positions[x]]);\n+                        notDuplicates[arrays[x][positions[x]].fullPath] = true;\n+                        positions[x] += 1;\n+                    }\n+                }\n+            }\n+            return ret;\n+        }\n+\n+        var queries = query.raw.split(\",\");\n+        var results = {\n+            \"in_args\": [],\n+            \"returned\": [],\n+            \"others\": [],\n+        };\n+\n+        for (var i = 0, len = queries.length; i < len; ++i) {\n+            query = queries[i].trim();\n+            if (query.length !== 0) {\n+                var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n+\n+                results.in_args.push(tmp.in_args);\n+                results.returned.push(tmp.returned);\n+                results.others.push(tmp.others);\n+            }\n+        }\n+        if (queries.length > 1) {\n+            return {\n+                \"in_args\": mergeArrays(results.in_args),\n+                \"returned\": mergeArrays(results.returned),\n+                \"others\": mergeArrays(results.others),\n+            };\n+        }\n+        return {\n+            \"in_args\": results.in_args[0],\n+            \"returned\": results.returned[0],\n+            \"others\": results.others[0],\n+        };\n+    }\n+\n+    function getFilterCrates() {\n+        var elem = document.getElementById(\"crate-search\");\n+\n+        if (elem && elem.value !== \"All crates\" && hasOwnProperty(rawSearchIndex, elem.value)) {\n+            return elem.value;\n+        }\n+        return undefined;\n+    }\n+\n+    function search(e, forced) {\n+        var params = searchState.getQueryStringParams();\n+        var query = getQuery(searchState.input.value.trim());\n+\n+        if (e) {\n+            e.preventDefault();\n+        }\n+\n+        if (query.query.length === 0) {\n+            return;\n+        }\n+        if (forced !== true && query.id === currentResults) {\n+            if (query.query.length > 0) {\n+                searchState.putBackSearch(searchState.input);\n+            }\n+            return;\n+        }\n+\n+        // Update document title to maintain a meaningful browser history\n+        searchState.title = \"Results for \" + query.query + \" - Rust\";\n+\n+        // Because searching is incremental by character, only the most\n+        // recent search query is added to the browser history.\n+        if (searchState.browserSupportsHistoryApi()) {\n+            var newURL = getNakedUrl() + \"?search=\" + encodeURIComponent(query.raw) +\n+                window.location.hash;\n+            if (!history.state && !params.search) {\n+                history.pushState(query, \"\", newURL);\n+            } else {\n+                history.replaceState(query, \"\", newURL);\n+            }\n+        }\n+\n+        var filterCrates = getFilterCrates();\n+        showResults(execSearch(query, index, filterCrates));\n+    }\n+\n+    function buildIndex(rawSearchIndex) {\n+        searchIndex = [];\n+        var searchWords = [];\n+        var i, word;\n+        var currentIndex = 0;\n+        var id = 0;\n+\n+        for (var crate in rawSearchIndex) {\n+            if (!hasOwnProperty(rawSearchIndex, crate)) { continue; }\n+\n+            var crateSize = 0;\n+\n+            searchWords.push(crate);\n+            var normalizedName = crate.indexOf(\"_\") === -1\n+                ? crate\n+                : crate.replace(/_/g, \"\");\n+            // This object should have exactly the same set of fields as the \"row\"\n+            // object defined below. Your JavaScript runtime will thank you.\n+            // https://mathiasbynens.be/notes/shapes-ics\n+            var crateRow = {\n+                crate: crate,\n+                ty: 1, // == ExternCrate\n+                name: crate,\n+                path: \"\",\n+                desc: rawSearchIndex[crate].doc,\n+                parent: undefined,\n+                type: null,\n+                id: id,\n+                normalizedName: normalizedName,\n+            };\n+            id += 1;\n+            searchIndex.push(crateRow);\n+            currentIndex += 1;\n+\n+            // an array of (Number) item types\n+            var itemTypes = rawSearchIndex[crate].t;\n+            // an array of (String) item names\n+            var itemNames = rawSearchIndex[crate].n;\n+            // an array of (String) full paths (or empty string for previous path)\n+            var itemPaths = rawSearchIndex[crate].q;\n+            // an array of (String) descriptions\n+            var itemDescs = rawSearchIndex[crate].d;\n+            // an array of (Number) the parent path index + 1 to `paths`, or 0 if none\n+            var itemParentIdxs = rawSearchIndex[crate].i;\n+            // an array of (Object | null) the type of the function, if any\n+            var itemFunctionSearchTypes = rawSearchIndex[crate].f;\n+            // an array of [(Number) item type,\n+            //              (String) name]\n+            var paths = rawSearchIndex[crate].p;\n+            // a array of [(String) alias name\n+            //             [Number] index to items]\n+            var aliases = rawSearchIndex[crate].a;\n+\n+            // convert `rawPaths` entries into object form\n+            var len = paths.length;\n+            for (i = 0; i < len; ++i) {\n+                paths[i] = {ty: paths[i][0], name: paths[i][1]};\n+            }\n+\n+            // convert `item*` into an object form, and construct word indices.\n+            //\n+            // before any analysis is performed lets gather the search terms to\n+            // search against apart from the rest of the data.  This is a quick\n+            // operation that is cached for the life of the page state so that\n+            // all other search operations have access to this cached data for\n+            // faster analysis operations\n+            len = itemTypes.length;\n+            var lastPath = \"\";\n+            for (i = 0; i < len; ++i) {\n+                // This object should have exactly the same set of fields as the \"crateRow\"\n+                // object defined above.\n+                if (typeof itemNames[i] === \"string\") {\n+                    word = itemNames[i].toLowerCase();\n+                    searchWords.push(word);\n+                } else {\n+                    word = \"\";\n+                    searchWords.push(\"\");\n+                }\n+                var normalizedName = word.indexOf(\"_\") === -1\n+                    ? word\n+                    : word.replace(/_/g, \"\");\n+                var row = {\n+                    crate: crate,\n+                    ty: itemTypes[i],\n+                    name: itemNames[i],\n+                    path: itemPaths[i] ? itemPaths[i] : lastPath,\n+                    desc: itemDescs[i],\n+                    parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n+                    type: itemFunctionSearchTypes[i],\n+                    id: id,\n+                    normalizedName: normalizedName,\n+                };\n+                id += 1;\n+                searchIndex.push(row);\n+                lastPath = row.path;\n+                crateSize += 1;\n+            }\n+\n+            if (aliases) {\n+                ALIASES[crate] = {};\n+                var j, local_aliases;\n+                for (var alias_name in aliases) {\n+                    if (!aliases.hasOwnProperty(alias_name)) { continue; }\n+\n+                    if (!ALIASES[crate].hasOwnProperty(alias_name)) {\n+                        ALIASES[crate][alias_name] = [];\n+                    }\n+                    local_aliases = aliases[alias_name];\n+                    for (j = 0, len = local_aliases.length; j < len; ++j) {\n+                        ALIASES[crate][alias_name].push(local_aliases[j] + currentIndex);\n+                    }\n+                }\n+            }\n+            currentIndex += crateSize;\n+        }\n+        return searchWords;\n+    }\n+\n+    function registerSearchEvents() {\n+        var searchAfter500ms = function() {\n+            searchState.clearInputTimeout();\n+            if (searchState.input.value.length === 0) {\n+                if (searchState.browserSupportsHistoryApi()) {\n+                    history.replaceState(\"\", window.currentCrate + \" - Rust\",\n+                        getNakedUrl() + window.location.hash);\n+                }\n+                searchState.hideResults();\n+            } else {\n+                searchState.timeout = setTimeout(search, 500);\n+            }\n+        };\n+        searchState.input.onkeyup = searchAfter500ms;\n+        searchState.input.oninput = searchAfter500ms;\n+        document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e) {\n+            e.preventDefault();\n+            searchState.clearInputTimeout();\n+            search();\n+        };\n+        searchState.input.onchange = function(e) {\n+            if (e.target !== document.activeElement) {\n+                // To prevent doing anything when it's from a blur event.\n+                return;\n+            }\n+            // Do NOT e.preventDefault() here. It will prevent pasting.\n+            searchState.clearInputTimeout();\n+            // zero-timeout necessary here because at the time of event handler execution the\n+            // pasted content is not in the input field yet. Shouldn\u2019t make any difference for\n+            // change, though.\n+            setTimeout(search, 0);\n+        };\n+        searchState.input.onpaste = searchState.input.onchange;\n+\n+        var selectCrate = document.getElementById(\"crate-search\");\n+        if (selectCrate) {\n+            selectCrate.onchange = function() {\n+                updateLocalStorage(\"rustdoc-saved-filter-crate\", selectCrate.value);\n+                search(undefined, true);\n+            };\n+        }\n+\n+        // Push and pop states are used to add search results to the browser\n+        // history.\n+        if (searchState.browserSupportsHistoryApi()) {\n+            // Store the previous <title> so we can revert back to it later.\n+            var previousTitle = document.title;\n+\n+            window.addEventListener(\"popstate\", function(e) {\n+                var params = searchState.getQueryStringParams();\n+                // Revert to the previous title manually since the History\n+                // API ignores the title parameter.\n+                document.title = previousTitle;\n+                // When browsing forward to search results the previous\n+                // search will be repeated, so the currentResults are\n+                // cleared to ensure the search is successful.\n+                currentResults = null;\n+                // Synchronize search bar with query string state and\n+                // perform the search. This will empty the bar if there's\n+                // nothing there, which lets you really go back to a\n+                // previous state with nothing in the bar.\n+                if (params.search && params.search.length > 0) {\n+                    searchState.input.value = params.search;\n+                    // Some browsers fire \"onpopstate\" for every page load\n+                    // (Chrome), while others fire the event only when actually\n+                    // popping a state (Firefox), which is why search() is\n+                    // called both here and at the end of the startSearch()\n+                    // function.\n+                    search(e);\n+                } else {\n+                    searchState.input.value = \"\";\n+                    // When browsing back from search results the main page\n+                    // visibility must be reset.\n+                    searchState.hideResults();\n+                }\n+            });\n+        }\n+\n+        // This is required in firefox to avoid this problem: Navigating to a search result\n+        // with the keyboard, hitting enter, and then hitting back would take you back to\n+        // the doc page, rather than the search that should overlay it.\n+        // This was an interaction between the back-forward cache and our handlers\n+        // that try to sync state between the URL and the search input. To work around it,\n+        // do a small amount of re-init on page show.\n+        window.onpageshow = function(){\n+            var qSearch = searchState.getQueryStringParams().search;\n+            if (searchState.input.value === \"\" && qSearch) {\n+                searchState.input.value = qSearch;\n+            }\n+            search();\n+        };\n+    }\n+\n+    index = buildIndex(rawSearchIndex);\n+    registerSearchEvents();\n+    // If there's a search term in the URL, execute the search now.\n+    if (searchState.getQueryStringParams().search) {\n+        search();\n+    }\n+};\n+\n+if (window.searchIndex !== undefined) {\n+  initSearch(window.searchIndex);\n+}\n+\n+})();"}, {"sha": "2b73bd5d52ee614988b79b14eea08600ed5f2f5d", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -24,6 +24,9 @@ crate static NORMALIZE_CSS: &str = include_str!(\"static/normalize.css\");\n /// including search behavior and docblock folding, among others.\n crate static MAIN_JS: &str = include_str!(\"static/main.js\");\n \n+/// The file contents of `search.js`, which contains the search behavior.\n+crate static SEARCH_JS: &str = include_str!(\"static/search.js\");\n+\n /// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n /// page.\n crate static SETTINGS_JS: &str = include_str!(\"static/settings.js\");"}, {"sha": "5d537dabd0c076c4bd75dd54aa6a9a4e38c4289b", "filename": "src/librustdoc/html/tests.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftests.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -0,0 +1,44 @@\n+use crate::html::format::href_relative_parts;\n+\n+fn assert_relative_path(expected: &[&str], relative_to_fqp: &[&str], fqp: &[&str]) {\n+    let relative_to_fqp: Vec<String> = relative_to_fqp.iter().copied().map(String::from).collect();\n+    let fqp: Vec<String> = fqp.iter().copied().map(String::from).collect();\n+    assert_eq!(expected, href_relative_parts(&fqp, &relative_to_fqp));\n+}\n+\n+#[test]\n+fn href_relative_parts_basic() {\n+    let relative_to_fqp = &[\"std\", \"vec\"];\n+    let fqp = &[\"std\", \"iter\"];\n+    assert_relative_path(&[\"..\", \"iter\"], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_parent_module() {\n+    let relative_to_fqp = &[\"std\", \"vec\"];\n+    let fqp = &[\"std\"];\n+    assert_relative_path(&[\"..\"], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_different_crate() {\n+    let relative_to_fqp = &[\"std\", \"vec\"];\n+    let fqp = &[\"core\", \"iter\"];\n+    assert_relative_path(&[\"..\", \"..\", \"core\", \"iter\"], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_same_module() {\n+    let relative_to_fqp = &[\"std\", \"vec\"];\n+    let fqp = &[\"std\", \"vec\"];\n+    assert_relative_path(&[], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_child_module() {\n+    let relative_to_fqp = &[\"std\"];\n+    let fqp = &[\"std\", \"vec\"];\n+    assert_relative_path(&[\"vec\"], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_root() {\n+    let relative_to_fqp = &[];\n+    let fqp = &[\"std\"];\n+    assert_relative_path(&[\"std\"], relative_to_fqp, fqp);\n+}"}, {"sha": "2a51d78f64a390e4466d2870dcde1bcd89b8f0de", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -289,7 +289,13 @@ fn opts() -> Vec<RustcOptGroup> {\n         stable(\"cfg\", |o| o.optmulti(\"\", \"cfg\", \"pass a --cfg to rustc\", \"\")),\n         stable(\"extern\", |o| o.optmulti(\"\", \"extern\", \"pass an --extern to rustc\", \"NAME[=PATH]\")),\n         unstable(\"extern-html-root-url\", |o| {\n-            o.optmulti(\"\", \"extern-html-root-url\", \"base URL to use for dependencies\", \"NAME=URL\")\n+            o.optmulti(\n+                \"\",\n+                \"extern-html-root-url\",\n+                \"base URL to use for dependencies; for example, \\\n+                 \\\"std=/doc\\\" links std::vec::Vec to /doc/std/vec/struct.Vec.html\",\n+                \"NAME=URL\",\n+            )\n         }),\n         stable(\"plugin-path\", |o| o.optmulti(\"\", \"plugin-path\", \"removed\", \"DIR\")),\n         stable(\"C\", |o| {"}, {"sha": "837cd034b655c834e61ba0af592079c3453c39bc", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1957,20 +1957,28 @@ fn resolution_failure(\n \n /// Report an anchor failure.\n fn anchor_failure(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>, failure: AnchorFailure) {\n-    let msg = match failure {\n+    let (msg, anchor_idx) = match failure {\n         AnchorFailure::MultipleAnchors => {\n-            format!(\"`{}` contains multiple anchors\", diag_info.ori_link)\n+            (format!(\"`{}` contains multiple anchors\", diag_info.ori_link), 1)\n         }\n-        AnchorFailure::RustdocAnchorConflict(res) => format!(\n-            \"`{}` contains an anchor, but links to {kind}s are already anchored\",\n-            diag_info.ori_link,\n-            kind = res.descr(),\n+        AnchorFailure::RustdocAnchorConflict(res) => (\n+            format!(\n+                \"`{}` contains an anchor, but links to {kind}s are already anchored\",\n+                diag_info.ori_link,\n+                kind = res.descr(),\n+            ),\n+            0,\n         ),\n     };\n \n     report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, |diag, sp| {\n-        if let Some(sp) = sp {\n-            diag.span_label(sp, \"contains invalid anchor\");\n+        if let Some(mut sp) = sp {\n+            if let Some((fragment_offset, _)) =\n+                diag_info.ori_link.char_indices().filter(|(_, x)| *x == '#').nth(anchor_idx)\n+            {\n+                sp = sp.with_lo(sp.lo() + rustc_span::BytePos(fragment_offset as _));\n+            }\n+            diag.span_label(sp, \"invalid anchor\");\n         }\n         if let AnchorFailure::RustdocAnchorConflict(Res::Primitive(_)) = failure {\n             diag.note(\"this restriction may be lifted in a future release\");"}, {"sha": "d63e1ee60b3c5754db791ac38ed27345a59ee1bc", "filename": "src/test/rustdoc-ui/intra-doc/anchors.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fanchors.stderr?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -2,7 +2,9 @@ error: `prim@usize#x` contains an anchor, but links to builtin types are already\n   --> $DIR/anchors.rs:47:6\n    |\n LL | /// [prim@usize#x]\n-   |      ^^^^^^^^^^^^ contains invalid anchor\n+   |      ^^^^^^^^^^--\n+   |                |\n+   |                invalid anchor\n    |\n note: the lint level is defined here\n   --> $DIR/anchors.rs:1:9\n@@ -16,25 +18,33 @@ error: `Foo::f#hola` contains an anchor, but links to fields are already anchore\n   --> $DIR/anchors.rs:25:15\n    |\n LL | /// Or maybe [Foo::f#hola].\n-   |               ^^^^^^^^^^^ contains invalid anchor\n+   |               ^^^^^^-----\n+   |                     |\n+   |                     invalid anchor\n \n error: `hello#people#!` contains multiple anchors\n   --> $DIR/anchors.rs:31:28\n    |\n LL | /// Another anchor error: [hello#people#!].\n-   |                            ^^^^^^^^^^^^^^ contains invalid anchor\n+   |                            ^^^^^^^^^^^^--\n+   |                                        |\n+   |                                        invalid anchor\n \n error: `Enum::A#whatever` contains an anchor, but links to variants are already anchored\n   --> $DIR/anchors.rs:37:28\n    |\n LL | /// Damn enum's variants: [Enum::A#whatever].\n-   |                            ^^^^^^^^^^^^^^^^ contains invalid anchor\n+   |                            ^^^^^^^---------\n+   |                                   |\n+   |                                   invalid anchor\n \n error: `u32#hello` contains an anchor, but links to builtin types are already anchored\n   --> $DIR/anchors.rs:43:6\n    |\n LL | /// [u32#hello]\n-   |      ^^^^^^^^^ contains invalid anchor\n+   |      ^^^------\n+   |         |\n+   |         invalid anchor\n    |\n    = note: this restriction may be lifted in a future release\n    = note: see https://github.com/rust-lang/rust/issues/83083 for more information"}, {"sha": "6addb010e078f21a9d8825767c11a2d6a84828ff", "filename": "src/test/rustdoc-ui/intra-doc/double-anchor.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdouble-anchor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdouble-anchor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fdouble-anchor.stderr?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -2,7 +2,9 @@ warning: `with#anchor#error` contains multiple anchors\n   --> $DIR/double-anchor.rs:5:18\n    |\n LL | /// docs [label][with#anchor#error]\n-   |                  ^^^^^^^^^^^^^^^^^ contains invalid anchor\n+   |                  ^^^^^^^^^^^------\n+   |                             |\n+   |                             invalid anchor\n    |\n    = note: `#[warn(rustdoc::broken_intra_doc_links)]` on by default\n "}, {"sha": "8fda171002ba045f1166a80b5a652df20473ff27", "filename": "src/test/rustdoc/assoc-types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fassoc-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fassoc-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-types.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -6,14 +6,14 @@ pub trait Index<I: ?Sized> {\n     type Output: ?Sized;\n     // @has - '//*[@id=\"tymethod.index\"]//code' \\\n     //      \"fn index<'a>(&'a self, index: I) -> &'a Self::Output\"\n-    // @has - '//*[@id=\"tymethod.index\"]//code//a[@href=\"../assoc_types/trait.Index.html#associatedtype.Output\"]' \\\n+    // @has - '//*[@id=\"tymethod.index\"]//code//a[@href=\"trait.Index.html#associatedtype.Output\"]' \\\n     //      \"Output\"\n     fn index<'a>(&'a self, index: I) -> &'a Self::Output;\n }\n \n // @has assoc_types/fn.use_output.html\n // @has - '//*[@class=\"rust fn\"]' '-> &T::Output'\n-// @has - '//*[@class=\"rust fn\"]//a[@href=\"../assoc_types/trait.Index.html#associatedtype.Output\"]' 'Output'\n+// @has - '//*[@class=\"rust fn\"]//a[@href=\"trait.Index.html#associatedtype.Output\"]' 'Output'\n pub fn use_output<T: Index<usize>>(obj: &T, index: usize) -> &T::Output {\n     obj.index(index)\n }\n@@ -24,12 +24,12 @@ pub trait Feed {\n \n // @has assoc_types/fn.use_input.html\n // @has - '//*[@class=\"rust fn\"]' 'T::Input'\n-// @has - '//*[@class=\"rust fn\"]//a[@href=\"../assoc_types/trait.Feed.html#associatedtype.Input\"]' 'Input'\n+// @has - '//*[@class=\"rust fn\"]//a[@href=\"trait.Feed.html#associatedtype.Input\"]' 'Input'\n pub fn use_input<T: Feed>(_feed: &T, _element: T::Input) { }\n \n // @has assoc_types/fn.cmp_input.html\n // @has - '//*[@class=\"rust fn\"]' 'where T::Input: PartialEq<U::Input>'\n-// @has - '//*[@class=\"rust fn\"]//a[@href=\"../assoc_types/trait.Feed.html#associatedtype.Input\"]' 'Input'\n+// @has - '//*[@class=\"rust fn\"]//a[@href=\"trait.Feed.html#associatedtype.Input\"]' 'Input'\n pub fn cmp_input<T: Feed, U: Feed>(a: &T::Input, b: &U::Input) -> bool\n     where T::Input: PartialEq<U::Input>\n {"}, {"sha": "a5b69740dd447c9e99944eafb0d4ad278f4e5de8", "filename": "src/test/rustdoc/auxiliary/primitive-doc.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -0,0 +1,6 @@\n+// compile-flags: --crate-type lib --edition 2018\n+\n+#[doc(primitive = \"usize\")]\n+/// This is the built-in type `usize`.\n+mod usize {\n+}"}, {"sha": "ed4a5ea21374b7b19e1c1b22e149f9e4e4380aeb", "filename": "src/test/rustdoc/check-styled-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -2,7 +2,7 @@\n \n pub struct Foo;\n \n-// @has foo/struct.Bar.html '//a[@href=\"../foo/struct.Foo.html\"]' 'Foo'\n+// @has foo/struct.Bar.html '//a[@href=\"struct.Foo.html\"]' 'Foo'\n \n /// Code-styled reference to [`Foo`].\n pub struct Bar;"}, {"sha": "05376e4680ec4d5477ba8667835a3ce4baa1f213", "filename": "src/test/rustdoc/cross-crate-primitive-doc.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -0,0 +1,9 @@\n+// aux-build:primitive-doc.rs\n+// compile-flags: --extern-html-root-url=primitive_doc=../ -Z unstable-options\n+\n+#![no_std]\n+\n+extern crate primitive_doc;\n+\n+// @has 'cross_crate_primitive_doc/fn.foo.html' '//a[@href=\"../primitive_doc/primitive.usize.html\"]' 'usize'\n+pub fn foo() -> usize { 0 }"}, {"sha": "7bcd2a3c149e9a7a81d0bbc947311fc4827f39ae", "filename": "src/test/rustdoc/default-trait-method-link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fdefault-trait-method-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fdefault-trait-method-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdefault-trait-method-link.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1,7 +1,7 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/trait.Foo.html '//a[@href=\"../foo/trait.Foo.html#tymethod.req\"]' 'req'\n-// @has foo/trait.Foo.html '//a[@href=\"../foo/trait.Foo.html#method.prov\"]' 'prov'\n+// @has foo/trait.Foo.html '//a[@href=\"trait.Foo.html#tymethod.req\"]' 'req'\n+// @has foo/trait.Foo.html '//a[@href=\"trait.Foo.html#method.prov\"]' 'prov'\n \n /// Always make sure to implement [`req`], but you don't have to implement [`prov`].\n ///"}, {"sha": "8c36a7fa002d856badd5b14c9954854dc78b8ee9", "filename": "src/test/rustdoc/intra-doc-crate/self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -3,7 +3,7 @@\n \n extern crate cross_crate_self;\n \n-// @has self/struct.S.html '//a[@href=\"../self/struct.S.html#method.f\"]' \"Self::f\"\n-// @has self/struct.S.html '//a[@href=\"../self/struct.S.html\"]' \"Self\"\n+// @has self/struct.S.html '//a[@href=\"struct.S.html#method.f\"]' \"Self::f\"\n+// @has self/struct.S.html '//a[@href=\"struct.S.html\"]' \"Self\"\n // @has self/struct.S.html '//a[@href=\"../cross_crate_self/index.html\"]' \"crate\"\n pub use cross_crate_self::S;"}, {"sha": "8ec1a7b4f9056381784dda314f1537252061b2bd", "filename": "src/test/rustdoc/intra-doc/anchors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -4,7 +4,7 @@\n pub struct Something;\n \n // @has anchors/struct.SomeOtherType.html\n-// @has - '//a/@href' '../anchors/struct.Something.html#Anchor!'\n+// @has - '//a/@href' 'struct.Something.html#Anchor!'\n \n /// I want...\n ///"}, {"sha": "68647127fe880317b22fedae82dc95035c8d0c3a", "filename": "src/test/rustdoc/intra-doc/associated-defaults.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-defaults.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -9,14 +9,14 @@ pub trait TraitWithDefault {\n }\n \n /// Link to [UsesDefaults::T] and [UsesDefaults::f]\n-// @has 'associated_defaults/struct.UsesDefaults.html' '//a[@href=\"../associated_defaults/struct.UsesDefaults.html#associatedtype.T\"]' 'UsesDefaults::T'\n-// @has 'associated_defaults/struct.UsesDefaults.html' '//a[@href=\"../associated_defaults/struct.UsesDefaults.html#method.f\"]' 'UsesDefaults::f'\n+// @has 'associated_defaults/struct.UsesDefaults.html' '//a[@href=\"struct.UsesDefaults.html#associatedtype.T\"]' 'UsesDefaults::T'\n+// @has 'associated_defaults/struct.UsesDefaults.html' '//a[@href=\"struct.UsesDefaults.html#method.f\"]' 'UsesDefaults::f'\n pub struct UsesDefaults;\n impl TraitWithDefault for UsesDefaults {}\n \n /// Link to [OverridesDefaults::T] and [OverridesDefaults::f]\n-// @has 'associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"../associated_defaults/struct.OverridesDefaults.html#associatedtype.T\"]' 'OverridesDefaults::T'\n-// @has 'associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"../associated_defaults/struct.OverridesDefaults.html#method.f\"]' 'OverridesDefaults::f'\n+// @has 'associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"struct.OverridesDefaults.html#associatedtype.T\"]' 'OverridesDefaults::T'\n+// @has 'associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"struct.OverridesDefaults.html#method.f\"]' 'OverridesDefaults::f'\n pub struct OverridesDefaults;\n impl TraitWithDefault for OverridesDefaults {\n     type T = bool;"}, {"sha": "2757418bc64e5c4990885be015c95b3813c8771a", "filename": "src/test/rustdoc/intra-doc/associated-items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -9,10 +9,10 @@\n pub fn foo() {}\n \n /// Link to [MyStruct], [link from struct][MyStruct::method], [MyStruct::clone], [MyStruct::Input]\n-// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html\"]' 'MyStruct'\n-// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html#method.method\"]' 'link from struct'\n-// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html#method.clone\"]' 'MyStruct::clone'\n-// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html#associatedtype.Input\"]' 'MyStruct::Input'\n+// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html\"]' 'MyStruct'\n+// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html#method.method\"]' 'link from struct'\n+// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html#method.clone\"]' 'MyStruct::clone'\n+// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html#associatedtype.Input\"]' 'MyStruct::Input'\n pub struct MyStruct { foo: () }\n \n impl Clone for MyStruct {\n@@ -30,7 +30,7 @@ impl T for MyStruct {\n     type Input = usize;\n \n     /// [link from method][MyStruct::method] on method\n-    // @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html#method.method\"]' 'link from method'\n+    // @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html#method.method\"]' 'link from method'\n     fn method(i: usize) {\n     }\n }"}, {"sha": "39f5c298bc4a1ac30164bb4c904c3aad9a037c4f", "filename": "src/test/rustdoc/intra-doc/basic.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fbasic.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1,21 +1,21 @@\n // @has basic/index.html\n-// @has - '//a/@href' '../basic/struct.ThisType.html'\n-// @has - '//a/@href' '../basic/struct.ThisType.html#method.this_method'\n-// @has - '//a/@href' '../basic/enum.ThisEnum.html'\n-// @has - '//a/@href' '../basic/enum.ThisEnum.html#variant.ThisVariant'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html#tymethod.this_associated_method'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html#associatedtype.ThisAssociatedType'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html#associatedconstant.THIS_ASSOCIATED_CONST'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html'\n-// @has - '//a/@href' '../basic/type.ThisAlias.html'\n-// @has - '//a/@href' '../basic/union.ThisUnion.html'\n-// @has - '//a/@href' '../basic/fn.this_function.html'\n-// @has - '//a/@href' '../basic/constant.THIS_CONST.html'\n-// @has - '//a/@href' '../basic/static.THIS_STATIC.html'\n-// @has - '//a/@href' '../basic/macro.this_macro.html'\n-// @has - '//a/@href' '../basic/trait.SoAmbiguous.html'\n-// @has - '//a/@href' '../basic/fn.SoAmbiguous.html'\n+// @has - '//a/@href' 'struct.ThisType.html'\n+// @has - '//a/@href' 'struct.ThisType.html#method.this_method'\n+// @has - '//a/@href' 'enum.ThisEnum.html'\n+// @has - '//a/@href' 'enum.ThisEnum.html#variant.ThisVariant'\n+// @has - '//a/@href' 'trait.ThisTrait.html'\n+// @has - '//a/@href' 'trait.ThisTrait.html#tymethod.this_associated_method'\n+// @has - '//a/@href' 'trait.ThisTrait.html#associatedtype.ThisAssociatedType'\n+// @has - '//a/@href' 'trait.ThisTrait.html#associatedconstant.THIS_ASSOCIATED_CONST'\n+// @has - '//a/@href' 'trait.ThisTrait.html'\n+// @has - '//a/@href' 'type.ThisAlias.html'\n+// @has - '//a/@href' 'union.ThisUnion.html'\n+// @has - '//a/@href' 'fn.this_function.html'\n+// @has - '//a/@href' 'constant.THIS_CONST.html'\n+// @has - '//a/@href' 'static.THIS_STATIC.html'\n+// @has - '//a/@href' 'macro.this_macro.html'\n+// @has - '//a/@href' 'trait.SoAmbiguous.html'\n+// @has - '//a/@href' 'fn.SoAmbiguous.html'\n //! In this crate we would like to link to:\n //!\n //! * [`ThisType`](ThisType)\n@@ -46,7 +46,7 @@ macro_rules! this_macro {\n     () => {};\n }\n \n-// @has basic/struct.ThisType.html '//a/@href' '../basic/macro.this_macro.html'\n+// @has basic/struct.ThisType.html '//a/@href' 'macro.this_macro.html'\n /// another link to [`this_macro!()`]\n pub struct ThisType;\n \n@@ -72,10 +72,10 @@ pub trait SoAmbiguous {}\n pub fn SoAmbiguous() {}\n \n \n-// @has basic/struct.SomeOtherType.html '//a/@href' '../basic/struct.ThisType.html'\n-// @has - '//a/@href' '../basic/struct.ThisType.html#method.this_method'\n-// @has - '//a/@href' '../basic/enum.ThisEnum.html'\n-// @has - '//a/@href' '../basic/enum.ThisEnum.html#variant.ThisVariant'\n+// @has basic/struct.SomeOtherType.html '//a/@href' 'struct.ThisType.html'\n+// @has - '//a/@href' 'struct.ThisType.html#method.this_method'\n+// @has - '//a/@href' 'enum.ThisEnum.html'\n+// @has - '//a/@href' 'enum.ThisEnum.html#variant.ThisVariant'\n /// Shortcut links for:\n /// * [`ThisType`]\n /// * [`ThisType::this_method`]"}, {"sha": "85c5866ca7ecfbc1b8ad0d56d01f3cc1d84e538e", "filename": "src/test/rustdoc/intra-doc/cross-crate/additional_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fadditional_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fadditional_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fadditional_doc.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -4,7 +4,7 @@\n \n extern crate my_rand;\n \n-// @has 'additional_doc/trait.Rng.html' '//a[@href=\"../additional_doc/trait.Rng.html\"]' 'Rng'\n+// @has 'additional_doc/trait.Rng.html' '//a[@href=\"trait.Rng.html\"]' 'Rng'\n // @has 'additional_doc/trait.Rng.html' '//a[@href=\"../my_rand/trait.RngCore.html\"]' 'RngCore'\n /// This is an [`Rng`].\n pub use my_rand::Rng;"}, {"sha": "31337f20f18dc91e1336f26378bbcf2a9c59ae07", "filename": "src/test/rustdoc/intra-doc/cross-crate/hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fhidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fhidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fhidden.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -6,5 +6,5 @@\n \n extern crate hidden_dep;\n \n-// @has 'hidden/struct.Ready.html' '//a/@href' '../hidden/fn.ready.html'\n+// @has 'hidden/struct.Ready.html' '//a/@href' 'fn.ready.html'\n pub use hidden_dep::future::{ready, Ready};"}, {"sha": "db7952b5aced0699f2408995dda1d8db8f1cd48d", "filename": "src/test/rustdoc/intra-doc/cross-crate/submodule-outer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fsubmodule-outer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fsubmodule-outer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fsubmodule-outer.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -11,6 +11,6 @@ pub mod bar {\n \n // NOTE: we re-exported both `Foo` and `Bar` here,\n // NOTE: so they are inlined and therefore we link to the current module.\n-// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"../submodule_outer/bar/trait.Bar.html\"]' 'Bar'\n-// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"../submodule_outer/trait.Baz.html\"]' 'Baz'\n+// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"bar/trait.Bar.html\"]' 'Bar'\n+// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"trait.Baz.html\"]' 'Baz'\n pub use ::bar_::{Foo, Baz};"}, {"sha": "d782c5cf5dc84ade7959ce68d05c429dbeb81127", "filename": "src/test/rustdoc/intra-doc/disambiguators-removed.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fdisambiguators-removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fdisambiguators-removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fdisambiguators-removed.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -2,49 +2,49 @@\n // first try backticks\n /// Trait: [`trait@Name`], fn: [`fn@Name`], [`Name`][`macro@Name`]\n // @has disambiguators_removed/struct.AtDisambiguator.html\n-// @has - '//a[@href=\"../disambiguators_removed/trait.Name.html\"][code]' \"Name\"\n-// @has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n-// @has - '//a[@href=\"../disambiguators_removed/macro.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"trait.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"fn.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"macro.Name.html\"][code]' \"Name\"\n pub struct AtDisambiguator;\n \n /// fn: [`Name()`], macro: [`Name!`]\n // @has disambiguators_removed/struct.SymbolDisambiguator.html\n-// @has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"][code]' \"Name()\"\n-// @has - '//a[@href=\"../disambiguators_removed/macro.Name.html\"][code]' \"Name!\"\n+// @has - '//a[@href=\"fn.Name.html\"][code]' \"Name()\"\n+// @has - '//a[@href=\"macro.Name.html\"][code]' \"Name!\"\n pub struct SymbolDisambiguator;\n \n // Now make sure that backticks aren't added if they weren't already there\n /// [fn@Name]\n // @has disambiguators_removed/trait.Name.html\n-// @has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"]' \"Name\"\n-// @!has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"fn.Name.html\"]' \"Name\"\n+// @!has - '//a[@href=\"fn.Name.html\"][code]' \"Name\"\n \n // FIXME: this will turn !() into ! alone\n /// [Name!()]\n-// @has - '//a[@href=\"../disambiguators_removed/macro.Name.html\"]' \"Name!\"\n+// @has - '//a[@href=\"macro.Name.html\"]' \"Name!\"\n pub trait Name {}\n \n #[allow(non_snake_case)]\n \n // Try collapsed reference links\n /// [macro@Name][]\n // @has disambiguators_removed/fn.Name.html\n-// @has - '//a[@href=\"../disambiguators_removed/macro.Name.html\"]' \"Name\"\n+// @has - '//a[@href=\"macro.Name.html\"]' \"Name\"\n \n // Try links that have the same text as a generated URL\n-/// Weird URL aligned [../disambiguators_removed/macro.Name.html][trait@Name]\n-// @has - '//a[@href=\"../disambiguators_removed/trait.Name.html\"]' \"../disambiguators_removed/macro.Name.html\"\n+/// Weird URL aligned [macro.Name.html][trait@Name]\n+// @has - '//a[@href=\"trait.Name.html\"]' \"macro.Name.html\"\n pub fn Name() {}\n \n #[macro_export]\n // Rustdoc doesn't currently handle links that have weird interspersing of inline code blocks.\n /// [fn@Na`m`e]\n // @has disambiguators_removed/macro.Name.html\n-// @has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"]' \"fn@Name\"\n+// @has - '//a[@href=\"fn.Name.html\"]' \"fn@Name\"\n \n // It also doesn't handle any case where the code block isn't the whole link text:\n /// [trait@`Name`]\n-// @has - '//a[@href=\"../disambiguators_removed/trait.Name.html\"]' \"trait@Name\"\n+// @has - '//a[@href=\"trait.Name.html\"]' \"trait@Name\"\n macro_rules! Name {\n     () => ()\n }"}, {"sha": "2270a1fafa1cb8dd75d3a971a89aa5d45ba39849", "filename": "src/test/rustdoc/intra-doc/enum-struct-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fenum-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fenum-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fenum-struct-field.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -11,4 +11,4 @@ pub enum Foo {\n /// I want [Foo::X::y].\n pub fn foo() {}\n \n-// @has foo/fn.foo.html '//a/@href' '../foo/enum.Foo.html#variant.X.field.y'\n+// @has foo/fn.foo.html '//a/@href' 'enum.Foo.html#variant.X.field.y'"}, {"sha": "f37ae62dde1aa45076563fe149bdbb9fc323dc06", "filename": "src/test/rustdoc/intra-doc/extern-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-type.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -12,6 +12,6 @@ impl ExternType {\n \n // @has 'extern_type/foreigntype.ExternType.html'\n // @has 'extern_type/fn.links_to_extern_type.html' \\\n-// 'href=\"../extern_type/foreigntype.ExternType.html#method.f\"'\n+// 'href=\"foreigntype.ExternType.html#method.f\"'\n /// See also [ExternType::f]\n pub fn links_to_extern_type() {}"}, {"sha": "68a5672a8d2091e6ca3c3a7c53fbef0cf59a1e1e", "filename": "src/test/rustdoc/intra-doc/issue-82209.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fissue-82209.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fissue-82209.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fissue-82209.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -8,4 +8,4 @@ pub enum Foo {\n     },\n }\n \n-// @has foo/enum.Foo.html '//a/@href' '../foo/enum.Foo.html#variant.Bar.field.abc'\n+// @has foo/enum.Foo.html '//a/@href' 'enum.Foo.html#variant.Bar.field.abc'"}, {"sha": "24b9dc30a9e496cd50123c6522e829f8540f085a", "filename": "src/test/rustdoc/intra-doc/mod-ambiguity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fmod-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fmod-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fmod-ambiguity.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -6,11 +6,11 @@ pub fn foo() {\n }\n \n pub mod foo {}\n-// @has mod_ambiguity/struct.A.html '//a/@href' '../mod_ambiguity/foo/index.html'\n+// @has mod_ambiguity/struct.A.html '//a/@href' 'foo/index.html'\n /// Module is [`module@foo`]\n pub struct A;\n \n \n-// @has mod_ambiguity/struct.B.html '//a/@href' '../mod_ambiguity/fn.foo.html'\n+// @has mod_ambiguity/struct.B.html '//a/@href' 'fn.foo.html'\n /// Function is [`fn@foo`]\n pub struct B;"}, {"sha": "478b40b0b516fb9c3b19bfbbb78312019f16eed1", "filename": "src/test/rustdoc/intra-doc/prim-precedence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -11,6 +11,6 @@ pub mod char {\n pub struct MyString;\n \n /// See also [crate::char] and [mod@char]\n-// @has prim_precedence/struct.MyString2.html '//*[@href=\"../prim_precedence/char/index.html\"]' 'crate::char'\n-// @has - '//*[@href=\"../prim_precedence/char/index.html\"]' 'mod@char'\n+// @has prim_precedence/struct.MyString2.html '//*[@href=\"char/index.html\"]' 'crate::char'\n+// @has - '//*[@href=\"char/index.html\"]' 'mod@char'\n pub struct MyString2;"}, {"sha": "2756a7998e8ea42cdb580578b8b0cc17a6e26b4e", "filename": "src/test/rustdoc/intra-doc/private.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -4,9 +4,9 @@\n // make sure to update `rustdoc-ui/intra-doc/private.rs` if you update this file\n \n /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n-// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html\"]' 'DontDocMe'\n-// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#method.f\"]' 'DontDocMe::f'\n-// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#structfield.x\"]' 'DontDocMe::x'\n+// @has private/struct.DocMe.html '//*a[@href=\"struct.DontDocMe.html\"]' 'DontDocMe'\n+// @has private/struct.DocMe.html '//*a[@href=\"struct.DontDocMe.html#method.f\"]' 'DontDocMe::f'\n+// @has private/struct.DocMe.html '//*a[@href=\"struct.DontDocMe.html#structfield.x\"]' 'DontDocMe::x'\n pub struct DocMe;\n struct DontDocMe {\n     x: usize,"}, {"sha": "fce10a130be655a70684bf0809caae5fdc20b94b", "filename": "src/test/rustdoc/intra-doc/proc-macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fproc-macro.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -9,17 +9,17 @@ pub use proc_macro_macro::{DeriveA, attr_a};\n use proc_macro_macro::{DeriveB, attr_b};\n \n // @has proc_macro/struct.Foo.html\n-// @has - '//a/@href' '../proc_macro/derive.DeriveA.html'\n-// @has - '//a/@href' '../proc_macro/attr.attr_a.html'\n-// @has - '//a/@href' '../proc_macro/trait.DeriveTrait.html'\n+// @has - '//a/@href' 'derive.DeriveA.html'\n+// @has - '//a/@href' 'attr.attr_a.html'\n+// @has - '//a/@href' 'trait.DeriveTrait.html'\n // @has - '//a/@href' '../proc_macro_macro/derive.DeriveB.html'\n // @has - '//a/@href' '../proc_macro_macro/attr.attr_b.html'\n /// Link to [DeriveA], [attr_a], [DeriveB], [attr_b], [DeriveTrait]\n pub struct Foo;\n \n // @has proc_macro/struct.Bar.html\n-// @has - '//a/@href' '../proc_macro/derive.DeriveA.html'\n-// @has - '//a/@href' '../proc_macro/attr.attr_a.html'\n+// @has - '//a/@href' 'derive.DeriveA.html'\n+// @has - '//a/@href' 'attr.attr_a.html'\n /// Link to [deriveA](derive@DeriveA) [attr](macro@attr_a)\n pub struct Bar;\n "}, {"sha": "579fa68cee8be37d1ff4e5b2a5516e77e4f0a682", "filename": "src/test/rustdoc/intra-doc/pub-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fpub-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fpub-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fpub-use.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -13,7 +13,7 @@ extern crate inner;\n \n // @has outer/index.html\n // @ has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/env/fn.var.html\"]' \"std::env\"\n-// @ has - '//a[@href=\"../outer/fn.f.html\"]' \"g\"\n+// @ has - '//a[@href=\"fn.f.html\"]' \"g\"\n pub use f as g;\n \n // FIXME: same as above"}, {"sha": "177c3016fb1515728f54073540a3a0bda841d4e8", "filename": "src/test/rustdoc/intra-doc/raw-ident-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fraw-ident-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fraw-ident-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fraw-ident-self.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -5,7 +5,7 @@ pub mod r#impl {\n     impl S {\n         /// See [Self::b].\n         // @has raw_ident_self/impl/struct.S.html\n-        // @has - '//a[@href=\"../../raw_ident_self/impl/struct.S.html#method.b\"]' 'Self::b'\n+        // @has - '//a[@href=\"struct.S.html#method.b\"]' 'Self::b'\n         pub fn a() {}\n \n         pub fn b() {}"}, {"sha": "64683bacd6513838fdc3a001f1fb3e61aebb08bd", "filename": "src/test/rustdoc/intra-doc/reexport-additional-docs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Freexport-additional-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Freexport-additional-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Freexport-additional-docs.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -3,13 +3,13 @@\n #![crate_name = \"foo\"]\n extern crate inner;\n \n-// @has foo/struct.Inner.html '//a[@href=\"../foo/fn.with_code.html\"]' 'crate::with_code'\n+// @has foo/struct.Inner.html '//a[@href=\"fn.with_code.html\"]' 'crate::with_code'\n /// [crate::with_code]\n-// @has - '//a[@href=\"../foo/fn.with_code.html\"]' 'different text'\n+// @has - '//a[@href=\"fn.with_code.html\"]' 'different text'\n /// [different text][with_code]\n-// @has - '//a[@href=\"../foo/fn.me_too.html\"]' 'me_too'\n+// @has - '//a[@href=\"fn.me_too.html\"]' 'me_too'\n #[doc = \"[me_too]\"]\n-// @has - '//a[@href=\"../foo/fn.me_three.html\"]' 'reference link'\n+// @has - '//a[@href=\"fn.me_three.html\"]' 'reference link'\n /// This [reference link]\n #[doc = \"has an attr in the way\"]\n ///"}, {"sha": "0ba7df8a78ad75a57016a09e88f1c676a9f615c9", "filename": "src/test/rustdoc/intra-doc/self.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1,8 +1,8 @@\n #![crate_name = \"foo\"]\n \n \n-// @has foo/index.html '//a/@href' '../foo/struct.Foo.html#method.new'\n-// @has foo/struct.Foo.html '//a/@href' '../foo/struct.Foo.html#method.new'\n+// @has foo/index.html '//a/@href' 'struct.Foo.html#method.new'\n+// @has foo/struct.Foo.html '//a/@href' 'struct.Foo.html#method.new'\n \n /// Use [`new`] to create a new instance.\n ///\n@@ -15,8 +15,8 @@ impl Foo {\n     }\n }\n \n-// @has foo/index.html '//a/@href' '../foo/struct.Bar.html#method.new2'\n-// @has foo/struct.Bar.html '//a/@href' '../foo/struct.Bar.html#method.new2'\n+// @has foo/index.html '//a/@href' 'struct.Bar.html#method.new2'\n+// @has foo/struct.Bar.html '//a/@href' 'struct.Bar.html#method.new2'\n \n /// Use [`new2`] to create a new instance.\n ///\n@@ -30,7 +30,7 @@ impl Bar {\n }\n \n pub struct MyStruct {\n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#structfield.struct_field'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#structfield.struct_field'\n \n     /// [`struct_field`]\n     ///\n@@ -39,7 +39,7 @@ pub struct MyStruct {\n }\n \n pub enum MyEnum {\n-    // @has foo/enum.MyEnum.html '//a/@href' '../foo/enum.MyEnum.html#variant.EnumVariant'\n+    // @has foo/enum.MyEnum.html '//a/@href' 'enum.MyEnum.html#variant.EnumVariant'\n \n     /// [`EnumVariant`]\n     ///\n@@ -48,7 +48,7 @@ pub enum MyEnum {\n }\n \n pub union MyUnion {\n-    // @has foo/union.MyUnion.html '//a/@href' '../foo/union.MyUnion.html#structfield.union_field'\n+    // @has foo/union.MyUnion.html '//a/@href' 'union.MyUnion.html#structfield.union_field'\n \n     /// [`union_field`]\n     ///\n@@ -57,21 +57,21 @@ pub union MyUnion {\n }\n \n pub trait MyTrait {\n-    // @has foo/trait.MyTrait.html '//a/@href' '../foo/trait.MyTrait.html#associatedtype.AssoType'\n+    // @has foo/trait.MyTrait.html '//a/@href' 'trait.MyTrait.html#associatedtype.AssoType'\n \n     /// [`AssoType`]\n     ///\n     /// [`AssoType`]: Self::AssoType\n     type AssoType;\n \n-    // @has foo/trait.MyTrait.html '//a/@href' '../foo/trait.MyTrait.html#associatedconstant.ASSO_CONST'\n+    // @has foo/trait.MyTrait.html '//a/@href' 'trait.MyTrait.html#associatedconstant.ASSO_CONST'\n \n     /// [`ASSO_CONST`]\n     ///\n     /// [`ASSO_CONST`]: Self::ASSO_CONST\n     const ASSO_CONST: i32 = 1;\n \n-    // @has foo/trait.MyTrait.html '//a/@href' '../foo/trait.MyTrait.html#method.asso_fn'\n+    // @has foo/trait.MyTrait.html '//a/@href' 'trait.MyTrait.html#method.asso_fn'\n \n     /// [`asso_fn`]\n     ///\n@@ -80,7 +80,7 @@ pub trait MyTrait {\n }\n \n impl MyStruct {\n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#method.for_impl'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#method.for_impl'\n \n     /// [`for_impl`]\n     ///\n@@ -91,21 +91,21 @@ impl MyStruct {\n }\n \n impl MyTrait for MyStruct {\n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedtype.AssoType'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#associatedtype.AssoType'\n \n     /// [`AssoType`]\n     ///\n     /// [`AssoType`]: Self::AssoType\n     type AssoType = u32;\n \n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedconstant.ASSO_CONST'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#associatedconstant.ASSO_CONST'\n \n     /// [`ASSO_CONST`]\n     ///\n     /// [`ASSO_CONST`]: Self::ASSO_CONST\n     const ASSO_CONST: i32 = 10;\n \n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#method.asso_fn'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#method.asso_fn'\n \n     /// [`asso_fn`]\n     ///"}, {"sha": "cf60dc1dbd50ec11c6e9a5802f1e48c2885c318e", "filename": "src/test/rustdoc/intra-doc/trait-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-impl.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -5,21 +5,21 @@ pub struct MyStruct;\n \n impl MyTrait for MyStruct {\n \n-// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedtype.AssoType'\n+// @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#associatedtype.AssoType'\n \n     /// [`AssoType`]\n     ///\n     /// [`AssoType`]: MyStruct::AssoType\n     type AssoType = u32;\n \n-// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedconstant.ASSO_CONST'\n+// @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#associatedconstant.ASSO_CONST'\n \n     /// [`ASSO_CONST`]\n     ///\n     /// [`ASSO_CONST`]: MyStruct::ASSO_CONST\n     const ASSO_CONST: i32 = 10;\n \n-// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#method.trait_fn'\n+// @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#method.trait_fn'\n \n     /// [`trait_fn`]\n     ///"}, {"sha": "7602aced56416ba9a002a87b3ac142238c28edaf", "filename": "src/test/rustdoc/intra-doc/trait-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-item.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -2,7 +2,7 @@\n \n /// Link to [S::assoc_fn()]\n /// Link to [Default::default()]\n-// @has trait_item/struct.S.html '//*[@href=\"../trait_item/struct.S.html#method.assoc_fn\"]' 'S::assoc_fn()'\n+// @has trait_item/struct.S.html '//*[@href=\"struct.S.html#method.assoc_fn\"]' 'S::assoc_fn()'\n // @has - '//*[@href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default\"]' 'Default::default()'\n pub struct S;\n "}, {"sha": "63bf7fa5768a718992c85318e13a0dc197481b75", "filename": "src/test/rustdoc/intra-link-self-cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1,12 +1,12 @@\n #![crate_name = \"foo\"]\n-// @has foo/enum.E1.html '//a/@href' '../foo/enum.E1.html#variant.A'\n+// @has foo/enum.E1.html '//a/@href' 'enum.E1.html#variant.A'\n \n /// [Self::A::b]\n pub enum E1 {\n     A { b: usize }\n }\n \n-// @has foo/enum.E2.html '//a/@href' '../foo/enum.E2.html#variant.A'\n+// @has foo/enum.E2.html '//a/@href' 'enum.E2.html#variant.A'\n \n /// [Self::A::b]\n pub enum E2 {"}, {"sha": "497276e6826a1acc1556ae1b22bfeddef74a47b9", "filename": "src/test/rustdoc/issue-28478.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-28478.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -23,9 +23,9 @@ impl Foo {\n }\n \n impl Bar for Foo {\n-    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#associatedtype.Bar\"]' 'Bar'\n-    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#associatedconstant.Baz\"]' 'Baz'\n-    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#tymethod.bar\"]' 'bar'\n+    // @has - '//*[@href=\"trait.Bar.html#associatedtype.Bar\"]' 'Bar'\n+    // @has - '//*[@href=\"trait.Bar.html#associatedconstant.Baz\"]' 'Baz'\n+    // @has - '//*[@href=\"trait.Bar.html#tymethod.bar\"]' 'bar'\n     fn bar() {}\n-    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#method.baz\"]' 'baz'\n+    // @has - '//*[@href=\"trait.Bar.html#method.baz\"]' 'baz'\n }"}, {"sha": "f156d225bd79b5ee9c3846522f6d9781fdd2c9bf", "filename": "src/test/rustdoc/issue-55364.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fissue-55364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fissue-55364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-55364.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -2,19 +2,19 @@\n \n // @has issue_55364/subone/index.html\n // These foo/bar links in the module's documentation should refer inside `subone`\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.foo.html\"]' 'foo'\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.bar.html\"]' 'bar'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar'\n pub mod subone {\n     //! See either [foo] or [bar].\n \n     // This should refer to subone's `bar`\n     // @has issue_55364/subone/fn.foo.html\n-    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.bar.html\"]' 'bar'\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar'\n     /// See [bar]\n     pub fn foo() {}\n     // This should refer to subone's `foo`\n     // @has issue_55364/subone/fn.bar.html\n-    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.foo.html\"]' 'foo'\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.foo.html\"]' 'foo'\n     /// See [foo]\n     pub fn bar() {}\n }\n@@ -23,11 +23,11 @@ pub mod subone {\n \n // @has issue_55364/subtwo/index.html\n // These foo/bar links in the module's documentation should not reference inside `subtwo`\n-// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.foo.html\"]' 'foo'\n-// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.bar.html\"]' 'bar'\n+// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.foo.html\"]' 'foo'\n+// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar'\n // Instead it should be referencing the top level functions\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.foo.html\"]' 'foo'\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.bar.html\"]' 'bar'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../fn.bar.html\"]' 'bar'\n // Though there should be such links later\n // @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td/a[@class=\"fn\"][@href=\"fn.foo.html\"]' 'foo'\n // @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td/a[@class=\"fn\"][@href=\"fn.bar.html\"]' 'bar'\n@@ -37,13 +37,13 @@ pub mod subtwo {\n     // Despite the module's docs referring to the top level foo/bar,\n     // this should refer to subtwo's `bar`\n     // @has issue_55364/subtwo/fn.foo.html\n-    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.bar.html\"]' 'bar'\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar'\n     /// See [bar]\n     pub fn foo() {}\n     // Despite the module's docs referring to the top level foo/bar,\n     // this should refer to subtwo's `foo`\n     // @has issue_55364/subtwo/fn.bar.html\n-    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.foo.html\"]' 'foo'\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.foo.html\"]' 'foo'\n     /// See [foo]\n     pub fn bar() {}\n }\n@@ -59,17 +59,17 @@ pub fn bar() {}\n \n // @has issue_55364/subthree/index.html\n // This module should also refer to the top level foo/bar\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.foo.html\"]' 'foo'\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.bar.html\"]' 'bar'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../fn.bar.html\"]' 'bar'\n pub mod subthree {\n     //! See either [foo][super::foo] or [bar][super::bar]\n }\n \n // Next we go *deeper* - In order to ensure it's not just \"this or parent\"\n // we test `crate::` and a `super::super::...` chain\n // @has issue_55364/subfour/subfive/subsix/subseven/subeight/index.html\n-// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../../issue_55364/subone/fn.foo.html\"]' 'other foo'\n-// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../../issue_55364/subtwo/fn.bar.html\"]' 'other bar'\n+// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../subone/fn.foo.html\"]' 'other foo'\n+// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../subtwo/fn.bar.html\"]' 'other bar'\n pub mod subfour {\n     pub mod subfive {\n         pub mod subsix {"}, {"sha": "64044cfe94720f5531b77147f04560653104b042", "filename": "src/test/rustdoc/issue-72340.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-72340.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -10,7 +10,7 @@ impl Body {\n }\n \n impl Default for Body {\n-    // @has foo/struct.Body.html '//a/@href' '../foo/struct.Body.html#method.empty'\n+    // @has foo/struct.Body.html '//a/@href' 'struct.Body.html#method.empty'\n \n     /// Returns [`Body::empty()`](Body::empty).\n     fn default() -> Body {"}, {"sha": "75a2531a308f7d95d31d703bee35a99682e2efb3", "filename": "src/test/rustdoc/link-assoc-const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Flink-assoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Flink-assoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Flink-assoc-const.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1,7 +1,7 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/index.html '//a[@href=\"../foo/foo/constant.FIRSTCONST.html\"]' 'foo::FIRSTCONST'\n-// @has foo/index.html '//a[@href=\"../foo/struct.Bar.html#associatedconstant.CONST\"]' 'Bar::CONST'\n+// @has foo/index.html '//a[@href=\"foo/constant.FIRSTCONST.html\"]' 'foo::FIRSTCONST'\n+// @has foo/index.html '//a[@href=\"struct.Bar.html#associatedconstant.CONST\"]' 'Bar::CONST'\n \n //! We have here [`foo::FIRSTCONST`] and [`Bar::CONST`].\n "}, {"sha": "f6d1f2cf91b5fca1915212708a47ee68c3d6473b", "filename": "src/test/rustdoc/proc-macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fproc-macro.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -61,12 +61,12 @@ pub fn some_derive(_item: TokenStream) -> TokenStream {\n // @has some_macros/foo/index.html\n mod foo {\n     // @has - '//code' 'pub use some_proc_macro;'\n-    // @has - '//a/@href' '../../some_macros/macro.some_proc_macro.html'\n+    // @has - '//a/@href' '../macro.some_proc_macro.html'\n     pub use some_proc_macro;\n     // @has - '//code' 'pub use some_proc_attr;'\n-    // @has - '//a/@href' '../../some_macros/attr.some_proc_attr.html'\n+    // @has - '//a/@href' '../attr.some_proc_attr.html'\n     pub use some_proc_attr;\n     // @has - '//code' 'pub use some_derive;'\n-    // @has - '//a/@href' '../../some_macros/derive.SomeDerive.html'\n+    // @has - '//a/@href' '../derive.SomeDerive.html'\n     pub use some_derive;\n }"}, {"sha": "ad190361267606a0e514d7ee23f93eb5ce12de94", "filename": "src/test/rustdoc/raw-ident-eliminate-r-hashtag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -8,13 +8,13 @@ pub mod internal {\n     ///\n     /// [name]: mod\n     /// [other name]: crate::internal::mod\n-    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"../../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'name'\n-    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"../../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'other name'\n+    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"struct.mod.html\"]' 'name'\n+    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"struct.mod.html\"]' 'other name'\n     pub struct B;\n }\n \n /// See [name].\n ///\n /// [name]: internal::mod\n-// @has 'raw_ident_eliminate_r_hashtag/struct.A.html' '//*a[@href=\"../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'name'\n+// @has 'raw_ident_eliminate_r_hashtag/struct.A.html' '//*a[@href=\"internal/struct.mod.html\"]' 'name'\n pub struct A;"}, {"sha": "998683bdde7f27236af2fedf949f96fa81822ca5", "filename": "src/test/rustdoc/struct-field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fstruct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Fstruct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstruct-field.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1,9 +1,9 @@\n #![crate_name = \"foo\"]\n \n \n-// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"../foo/struct.Foo.html#structfield.bar\"]' 'Foo::bar'\n-// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"../foo/union.Bar.html#structfield.foo\"]' 'Bar::foo'\n-// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"../foo/enum.Uniooon.html#variant.X\"]' 'Uniooon::X'\n+// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"struct.Foo.html#structfield.bar\"]' 'Foo::bar'\n+// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"union.Bar.html#structfield.foo\"]' 'Bar::foo'\n+// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"enum.Uniooon.html#variant.X\"]' 'Uniooon::X'\n \n //! Test with [Foo::bar], [Bar::foo], [Uniooon::X]\n "}, {"sha": "c6a9313e821c9562fc55c2b952829b52d0d37cbc", "filename": "src/test/rustdoc/trait-impl-items-links-and-anchors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Ftrait-impl-items-links-and-anchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Ftrait-impl-items-links-and-anchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftrait-impl-items-links-and-anchors.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -40,25 +40,25 @@ impl MyTrait for Vec<u8> {\n impl MyTrait for MyStruct {\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"associatedtype.Assoc-3\"]//a[@class=\"type\"]/@href' #associatedtype.Assoc\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"associatedtype.Assoc-3\"]//a[@class=\"anchor\"]/@href' #associatedtype.Assoc-3\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedtype.Assoc\"]//a[@class=\"type\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#associatedtype.Assoc\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedtype.Assoc\"]//a[@class=\"type\"]/@href' trait.MyTrait.html#associatedtype.Assoc\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedtype.Assoc\"]//a[@class=\"anchor\"]/@href' #associatedtype.Assoc\n     type Assoc = bool;\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"associatedconstant.VALUE-3\"]//a[@class=\"constant\"]/@href' #associatedconstant.VALUE\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"associatedconstant.VALUE-3\"]//a[@class=\"anchor\"]/@href' #associatedconstant.VALUE-3\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedconstant.VALUE\"]//a[@class=\"constant\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#associatedconstant.VALUE\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedconstant.VALUE\"]//a[@class=\"constant\"]/@href' trait.MyTrait.html#associatedconstant.VALUE\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedconstant.VALUE\"]//a[@class=\"anchor\"]/@href' #associatedconstant.VALUE\n     const VALUE: u32 = 20;\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"method.trait_function-2\"]//a[@class=\"fnname\"]/@href' #tymethod.trait_function\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"method.trait_function-2\"]//a[@class=\"anchor\"]/@href' #method.trait_function-2\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.trait_function\"]//a[@class=\"fnname\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#tymethod.trait_function\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.trait_function\"]//a[@class=\"fnname\"]/@href' trait.MyTrait.html#tymethod.trait_function\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.trait_function\"]//a[@class=\"anchor\"]/@href' #method.trait_function\n     fn trait_function(&self) {}\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"method.defaulted_override-3\"]//a[@class=\"fnname\"]/@href' #method.defaulted_override\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"method.defaulted_override-3\"]//a[@class=\"anchor\"]/@href' #method.defaulted_override-3\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted_override\"]//a[@class=\"fnname\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#method.defaulted_override\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted_override\"]//a[@class=\"fnname\"]/@href' trait.MyTrait.html#method.defaulted_override\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted_override\"]//a[@class=\"anchor\"]/@href' #method.defaulted_override\n     fn defaulted_override(&self) {}\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted\"]//a[@class=\"fnname\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#method.defaulted\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted\"]//a[@class=\"fnname\"]/@href' trait.MyTrait.html#method.defaulted\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted\"]//a[@class=\"anchor\"]/@href' #method.defaulted\n }\n "}, {"sha": "e311dadff0e637f1393573cbbc00a4600df289cc", "filename": "src/test/rustdoc/trait-self-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Ftrait-self-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftest%2Frustdoc%2Ftrait-self-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftrait-self-link.rs?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -1,4 +1,4 @@\n-// @has trait_self_link/trait.Foo.html //a/@href ../trait_self_link/trait.Foo.html\n+// @has trait_self_link/trait.Foo.html //a/@href trait.Foo.html\n pub trait Foo {}\n \n pub struct Bar;"}, {"sha": "e583bd225a9eb164fe9901e3353712faeda67d9b", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/392ba2ba1a7d6c542d2459fb8133bebf62a4a423/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=392ba2ba1a7d6c542d2459fb8133bebf62a4a423", "patch": "@@ -246,7 +246,7 @@ function lookForEntry(entry, data) {\n     return null;\n }\n \n-function loadMainJsAndIndex(mainJs, searchIndex, storageJs, crate) {\n+function loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate) {\n     if (searchIndex[searchIndex.length - 1].length === 0) {\n         searchIndex.pop();\n     }\n@@ -270,9 +270,9 @@ function loadMainJsAndIndex(mainJs, searchIndex, storageJs, crate) {\n     ALIASES = {};\n     finalJS += 'window = { \"currentCrate\": \"' + crate + '\", rootPath: \"../\" };\\n';\n     finalJS += loadThings([\"hasOwnProperty\", \"onEach\"], 'function', extractFunction, storageJs);\n-    finalJS += loadThings(arraysToLoad, 'array', extractArrayVariable, mainJs);\n-    finalJS += loadThings(variablesToLoad, 'variable', extractVariable, mainJs);\n-    finalJS += loadThings(functionsToLoad, 'function', extractFunction, mainJs);\n+    finalJS += loadThings(arraysToLoad, 'array', extractArrayVariable, searchJs);\n+    finalJS += loadThings(variablesToLoad, 'variable', extractVariable, searchJs);\n+    finalJS += loadThings(functionsToLoad, 'function', extractFunction, searchJs);\n \n     var loaded = loadContent(finalJS);\n     var index = loaded.buildIndex(searchIndex.rawSearchIndex);\n@@ -382,12 +382,12 @@ function runChecks(testFile, loaded, index) {\n }\n \n function load_files(doc_folder, resource_suffix, crate) {\n-    var mainJs = readFile(path.join(doc_folder, \"main\" + resource_suffix + \".js\"));\n+    var searchJs = readFile(path.join(doc_folder, \"search\" + resource_suffix + \".js\"));\n     var storageJs = readFile(path.join(doc_folder, \"storage\" + resource_suffix + \".js\"));\n     var searchIndex = readFile(\n         path.join(doc_folder, \"search-index\" + resource_suffix + \".js\")).split(\"\\n\");\n \n-    return loadMainJsAndIndex(mainJs, searchIndex, storageJs, crate);\n+    return loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate);\n }\n \n function showHelp() {"}]}