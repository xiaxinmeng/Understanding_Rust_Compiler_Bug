{"sha": "e83f7563495dbe2629b0cbc738afb0808c4482e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4M2Y3NTYzNDk1ZGJlMjYyOWIwY2JjNzM4YWZiMDgwOGM0NDgyZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-26T20:12:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-26T20:12:48Z"}, "message": "Auto merge of #71593 - Dylan-DPC:rollup-ms7j94u, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #71421 (Add a function to turn Box<T> into Box<[T]>)\n - #71537 (Remove support for self-opening)\n - #71551 (Minor refactoring around IndexVec usage in generator transformation)\n - #71569 ([miri] Throw UB if target size and data size don't match)\n - #71576 (check that `AsRef` and `AsMut` are inlined)\n\nFailed merges:\n\n - #71558 (Cleanup and document `-Z tls-model` )\n\nr? @ghost", "tree": {"sha": "e6008f7c09e14c44b05015e5ede8c9e8c52c6683", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6008f7c09e14c44b05015e5ede8c9e8c52c6683"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e83f7563495dbe2629b0cbc738afb0808c4482e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e83f7563495dbe2629b0cbc738afb0808c4482e1", "html_url": "https://github.com/rust-lang/rust/commit/e83f7563495dbe2629b0cbc738afb0808c4482e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e83f7563495dbe2629b0cbc738afb0808c4482e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f", "html_url": "https://github.com/rust-lang/rust/commit/7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f"}, {"sha": "962cae070f085f7c67813aba6b75547e172ec669", "url": "https://api.github.com/repos/rust-lang/rust/commits/962cae070f085f7c67813aba6b75547e172ec669", "html_url": "https://github.com/rust-lang/rust/commit/962cae070f085f7c67813aba6b75547e172ec669"}], "stats": {"total": 402, "additions": 263, "deletions": 139}, "files": [{"sha": "b3a771a721d228d3c6debbfbc15bb8fe447b8339", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -239,6 +239,16 @@ impl<T> Box<T> {\n     pub fn pin(x: T) -> Pin<Box<T>> {\n         (box x).into()\n     }\n+\n+    /// Converts a `Box<T>` into a `Box<[T]>`\n+    ///\n+    /// This conversion does not allocate on the heap and happens in place.\n+    ///\n+    #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n+    pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n+        // *mut T and *mut [T; 1] have the same size and alignment\n+        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1] as *mut [T]) }\n+    }\n }\n \n impl<T> Box<[T]> {"}, {"sha": "72c25270a5d6918b662877de71ccc17f3c619152", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -205,7 +205,7 @@ pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n }\n \n fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n-    let lib = DynamicLibrary::open(Some(path)).unwrap_or_else(|err| {\n+    let lib = DynamicLibrary::open(path).unwrap_or_else(|err| {\n         let err = format!(\"couldn't load codegen backend {:?}: {:?}\", path, err);\n         early_error(ErrorOutputType::default(), &err);\n     });"}, {"sha": "6168f6e1e5c8855847a65e262f84d8038db8f030", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -591,7 +591,7 @@ impl<'a> CrateLoader<'a> {\n \n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n-        let lib = match DynamicLibrary::open(Some(&path)) {\n+        let lib = match DynamicLibrary::open(&path) {\n             Ok(lib) => lib,\n             Err(err) => self.sess.span_fatal(span, &err),\n         };"}, {"sha": "ce19240a009d091f52de29382790ef80f90500b3", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -16,10 +16,9 @@ impl Drop for DynamicLibrary {\n }\n \n impl DynamicLibrary {\n-    /// Lazily open a dynamic library. When passed None it gives a\n-    /// handle to the calling process\n-    pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> {\n-        let maybe_library = dl::open(filename.map(|path| path.as_os_str()));\n+    /// Lazily open a dynamic library.\n+    pub fn open(filename: &Path) -> Result<DynamicLibrary, String> {\n+        let maybe_library = dl::open(filename.as_os_str());\n \n         // The dynamic library must not be constructed if there is\n         // an error opening the library so the destructor does not\n@@ -57,24 +56,13 @@ mod dl {\n     use std::ptr;\n     use std::str;\n \n-    pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n+    pub(super) fn open(filename: &OsStr) -> Result<*mut u8, String> {\n         check_for_errors_in(|| unsafe {\n-            match filename {\n-                Some(filename) => open_external(filename),\n-                None => open_internal(),\n-            }\n+            let s = CString::new(filename.as_bytes()).unwrap();\n+            libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) as *mut u8\n         })\n     }\n \n-    unsafe fn open_external(filename: &OsStr) -> *mut u8 {\n-        let s = CString::new(filename.as_bytes()).unwrap();\n-        libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) as *mut u8\n-    }\n-\n-    unsafe fn open_internal() -> *mut u8 {\n-        libc::dlopen(ptr::null(), libc::RTLD_LAZY) as *mut u8\n-    }\n-\n     fn check_for_errors_in<T, F>(f: F) -> Result<T, String>\n     where\n         F: FnOnce() -> T,\n@@ -124,10 +112,10 @@ mod dl {\n \n     use winapi::shared::minwindef::HMODULE;\n     use winapi::um::errhandlingapi::SetThreadErrorMode;\n-    use winapi::um::libloaderapi::{FreeLibrary, GetModuleHandleExW, GetProcAddress, LoadLibraryW};\n+    use winapi::um::libloaderapi::{FreeLibrary, GetProcAddress, LoadLibraryW};\n     use winapi::um::winbase::SEM_FAILCRITICALERRORS;\n \n-    pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n+    pub(super) fn open(filename: &OsStr) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n         let prev_error_mode = unsafe {\n             let new_error_mode = SEM_FAILCRITICALERRORS;\n@@ -139,22 +127,9 @@ mod dl {\n             prev_error_mode\n         };\n \n-        let result = match filename {\n-            Some(filename) => {\n-                let filename_str: Vec<_> = filename.encode_wide().chain(Some(0)).collect();\n-                let result = unsafe { LoadLibraryW(filename_str.as_ptr()) } as *mut u8;\n-                ptr_result(result)\n-            }\n-            None => {\n-                let mut handle = ptr::null_mut();\n-                let succeeded = unsafe { GetModuleHandleExW(0, ptr::null(), &mut handle) };\n-                if succeeded == 0 {\n-                    Err(io::Error::last_os_error().to_string())\n-                } else {\n-                    Ok(handle as *mut u8)\n-                }\n-            }\n-        };\n+        let filename_str: Vec<_> = filename.encode_wide().chain(Some(0)).collect();\n+        let result = unsafe { LoadLibraryW(filename_str.as_ptr()) } as *mut u8;\n+        let result = ptr_result(result);\n \n         unsafe {\n             SetThreadErrorMode(prev_error_mode, ptr::null_mut());"}, {"sha": "7090bbf61c794747cf0d57d9f54da91c77069733", "filename": "src/librustc_metadata/dynamic_lib/tests.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_metadata%2Fdynamic_lib%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_metadata%2Fdynamic_lib%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib%2Ftests.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -1,32 +1,4 @@\n use super::*;\n-use std::mem;\n-\n-#[test]\n-fn test_loading_atoi() {\n-    if cfg!(windows) {\n-        return;\n-    }\n-\n-    // The C library does not need to be loaded since it is already linked in\n-    let lib = match DynamicLibrary::open(None) {\n-        Err(error) => panic!(\"Could not load self as module: {}\", error),\n-        Ok(lib) => lib,\n-    };\n-\n-    let atoi: extern \"C\" fn(*const libc::c_char) -> libc::c_int = unsafe {\n-        match lib.symbol(\"atoi\") {\n-            Err(error) => panic!(\"Could not load function atoi: {}\", error),\n-            Ok(atoi) => mem::transmute::<*mut u8, _>(atoi),\n-        }\n-    };\n-\n-    let argument = CString::new(\"1383428980\").unwrap();\n-    let expected_result = 0x52757374;\n-    let result = atoi(argument.as_ptr());\n-    if result != expected_result {\n-        panic!(\"atoi({:?}) != {} but equaled {} instead\", argument, expected_result, result)\n-    }\n-}\n \n #[test]\n fn test_errors_do_not_crash() {\n@@ -39,7 +11,7 @@ fn test_errors_do_not_crash() {\n     // Open /dev/null as a library to get an error, and make sure\n     // that only causes an error, and not a crash.\n     let path = Path::new(\"/dev/null\");\n-    match DynamicLibrary::open(Some(&path)) {\n+    match DynamicLibrary::open(&path) {\n         Err(_) => {}\n         Ok(_) => panic!(\"Successfully opened the empty library.\"),\n     }"}, {"sha": "e6557c9fbd59d4e61aacd27e58eb29f943d78e40", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -360,6 +360,11 @@ pub enum UndefinedBehaviorInfo {\n     InvalidUndefBytes(Option<Pointer>),\n     /// Working with a local that is not currently live.\n     DeadLocal,\n+    /// Data size is not equal to target size.\n+    ScalarSizeMismatch {\n+        target_size: u64,\n+        data_size: u64,\n+    },\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -421,6 +426,11 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n                 \"using uninitialized data, but this operation requires initialized memory\"\n             ),\n             DeadLocal => write!(f, \"accessing a dead local variable\"),\n+            ScalarSizeMismatch { target_size, data_size } => write!(\n+                f,\n+                \"scalar size mismatch: expected {} bytes but got {} bytes instead\",\n+                target_size, data_size\n+            ),\n         }\n     }\n }"}, {"sha": "6e013f75ed7590fa148e175fbe230d943aabcbe4", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -393,7 +393,12 @@ impl<'tcx, Tag> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), u64::from(size));\n+                if target_size.bytes() != u64::from(size) {\n+                    throw_ub!(ScalarSizeMismatch {\n+                        target_size: target_size.bytes(),\n+                        data_size: u64::from(size),\n+                    });\n+                }\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }"}, {"sha": "611d03405e2c84149f90530300e3bfe6cb279334", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -210,8 +210,7 @@ struct TransformVisitor<'tcx> {\n     remap: FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n-    // FIXME(eddyb) This should use `IndexVec<BasicBlock, Option<_>>`.\n-    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+    storage_liveness: IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n \n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint<'tcx>>,\n@@ -338,7 +337,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n                     resume,\n                     resume_arg,\n                     drop,\n-                    storage_liveness: self.storage_liveness.get(&block).unwrap().clone(),\n+                    storage_liveness: self.storage_liveness[block].clone().unwrap(),\n                 });\n \n                 VariantIdx::new(state)\n@@ -404,8 +403,7 @@ fn replace_local<'tcx>(\n         is_block_tail: None,\n         local_info: LocalInfo::Other,\n     };\n-    let new_local = Local::new(body.local_decls.len());\n-    body.local_decls.push(new_decl);\n+    let new_local = body.local_decls.push(new_decl);\n     body.local_decls.swap(local, new_local);\n \n     RenameLocalVisitor { from: local, to: new_local, tcx }.visit_body(body);\n@@ -431,7 +429,7 @@ struct LivenessInfo {\n \n     /// For every suspending block, the locals which are storage-live across\n     /// that suspension point.\n-    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+    storage_liveness: IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n }\n \n fn locals_live_across_suspend_points(\n@@ -472,7 +470,7 @@ fn locals_live_across_suspend_points(\n     let mut liveness = liveness::liveness_of_locals(body);\n     liveness::dump_mir(tcx, \"generator_liveness\", source, body_ref, &liveness);\n \n-    let mut storage_liveness_map = FxHashMap::default();\n+    let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n     let mut live_locals_at_suspension_points = Vec::new();\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n@@ -502,7 +500,7 @@ fn locals_live_across_suspend_points(\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n-            storage_liveness_map.insert(block, storage_liveness);\n+            storage_liveness_map[block] = Some(storage_liveness);\n \n             requires_storage_cursor.seek_before(loc);\n             let storage_required = requires_storage_cursor.get().clone();\n@@ -690,7 +688,7 @@ fn compute_layout<'tcx>(\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n-    FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+    IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n ) {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n@@ -925,14 +923,12 @@ fn create_generator_drop_shim<'tcx>(\n }\n \n fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n-    let term_block = BasicBlock::new(body.basic_blocks().len());\n     let source_info = source_info(body);\n     body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator { source_info, kind }),\n         is_cleanup: false,\n-    });\n-    term_block\n+    })\n }\n \n fn insert_panic_block<'tcx>(\n@@ -1030,9 +1026,8 @@ fn create_generator_resume_function<'tcx>(\n \n     // Poison the generator when it unwinds\n     if can_unwind {\n-        let poison_block = BasicBlock::new(body.basic_blocks().len());\n         let source_info = source_info(body);\n-        body.basic_blocks_mut().push(BasicBlockData {\n+        let poison_block = body.basic_blocks_mut().push(BasicBlockData {\n             statements: vec![transform.set_discr(VariantIdx::new(POISONED), source_info)],\n             terminator: Some(Terminator { source_info, kind: TerminatorKind::Resume }),\n             is_cleanup: true,\n@@ -1105,21 +1100,19 @@ fn source_info(body: &Body<'_>) -> SourceInfo {\n fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n-    // Create a block to destroy an unresumed generators. This can only destroy upvars.\n-    let drop_clean = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Drop {\n         location: Place::from(SELF_ARG),\n         target: return_block,\n         unwind: None,\n     };\n     let source_info = source_info(body);\n+\n+    // Create a block to destroy an unresumed generators. This can only destroy upvars.\n     body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator { source_info, kind: term }),\n         is_cleanup: false,\n-    });\n-\n-    drop_clean\n+    })\n }\n \n /// An operation that can be performed on a generator.\n@@ -1151,7 +1144,6 @@ fn create_cases<'tcx>(\n         .filter_map(|point| {\n             // Find the target for this suspension point, if applicable\n             operation.target_block(point).map(|target| {\n-                let block = BasicBlock::new(body.basic_blocks().len());\n                 let mut statements = Vec::new();\n \n                 // Create StorageLive instructions for locals with live storage\n@@ -1186,7 +1178,7 @@ fn create_cases<'tcx>(\n                 }\n \n                 // Then jump to the real target\n-                body.basic_blocks_mut().push(BasicBlockData {\n+                let block = body.basic_blocks_mut().push(BasicBlockData {\n                     statements,\n                     terminator: Some(Terminator {\n                         source_info,"}, {"sha": "f48d2b6c8b5e61dc18cf01ef6ddb88fa386e0ffd", "filename": "src/librustc_plugin_impl/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_plugin_impl%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Flibrustc_plugin_impl%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fload.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -76,7 +76,7 @@ fn dylink_registrar(\n     // Make sure the path contains a / or the linker will search for it.\n     let path = env::current_dir().unwrap().join(&path);\n \n-    let lib = match DynamicLibrary::open(Some(&path)) {\n+    let lib = match DynamicLibrary::open(&path) {\n         Ok(lib) => lib,\n         // this is fatal: there are almost certainly macros we need\n         // inside this crate, so continue would spew \"macro undefined\""}, {"sha": "317705f76121239709486103e4fa45f79dd3541d", "filename": "src/test/mir-opt/inline/issue-58867-inline-as-ref-as-mut.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -0,0 +1,27 @@\n+// EMIT_MIR rustc.a.Inline.after.mir\n+pub fn a<T>(x: &mut [T]) -> &mut [T] {\n+    x.as_mut()\n+}\n+\n+// EMIT_MIR rustc.b.Inline.after.mir\n+pub fn b<T>(x: &mut Box<T>) -> &mut T {\n+    x.as_mut()\n+}\n+\n+// EMIT_MIR rustc.c.Inline.after.mir\n+pub fn c<T>(x: &[T]) -> &[T] {\n+    x.as_ref()\n+}\n+\n+// EMIT_MIR rustc.d.Inline.after.mir\n+pub fn d<T>(x: &Box<T>) -> &T {\n+    x.as_ref()\n+}\n+\n+fn main() {\n+    let mut boxed = Box::new(1);\n+    println!(\"{:?}\", a(&mut [1]));\n+    println!(\"{:?}\", b(&mut boxed));\n+    println!(\"{:?}\", c(&[1]));\n+    println!(\"{:?}\", d(&boxed));\n+}"}, {"sha": "c5d44cbafac412db398b44550c48cd8fc61fdc1b", "filename": "src/test/mir-opt/inline/issue-58867-inline-as-ref-as-mut/rustc.a.Inline.after.mir", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.a.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.a.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.a.Inline.after.mir?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -0,0 +1,30 @@\n+// MIR for `a` after Inline\n+\n+fn a(_1: &mut [T]) -> &mut [T] {\n+    debug x => _1;                       // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:2:13: 2:14\n+    let mut _0: &mut [T];                // return place in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:2:29: 2:37\n+    let mut _2: &mut [T];                // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n+    let mut _3: &mut [T];                // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n+    let mut _4: &mut [T];                // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:6\n+    scope 1 {\n+        debug self => _4;                // in scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+        let mut _5: &mut [T];            // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // bb0[0]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n+        StorageLive(_3);                 // bb0[1]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n+        StorageLive(_4);                 // bb0[2]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:6\n+        _4 = &mut (*_1);                 // bb0[3]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:6\n+        StorageLive(_5);                 // bb0[4]: scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+        _5 = _4;                         // bb0[5]: scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+        _3 = _5;                         // bb0[6]: scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+        StorageDead(_5);                 // bb0[7]: scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+        _2 = &mut (*_3);                 // bb0[8]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n+        StorageDead(_4);                 // bb0[9]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:14: 3:15\n+        _0 = &mut (*_2);                 // bb0[10]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n+        StorageDead(_3);                 // bb0[11]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:4:1: 4:2\n+        StorageDead(_2);                 // bb0[12]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:4:1: 4:2\n+        return;                          // bb0[13]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:4:2: 4:2\n+    }\n+}"}, {"sha": "8384b949b954b45c2970d785be2d4c69672681c9", "filename": "src/test/mir-opt/inline/issue-58867-inline-as-ref-as-mut/rustc.b.Inline.after.mir", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.b.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.b.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.b.Inline.after.mir?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -0,0 +1,34 @@\n+// MIR for `b` after Inline\n+\n+fn b(_1: &mut std::boxed::Box<T>) -> &mut T {\n+    debug x => _1;                       // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:7:13: 7:14\n+    let mut _0: &mut T;                  // return place in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:7:32: 7:38\n+    let mut _2: &mut T;                  // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+    let mut _3: &mut T;                  // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+    let mut _4: &mut std::boxed::Box<T>; // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:6\n+    scope 1 {\n+        debug self => _4;                // in scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        let mut _5: &mut T;              // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+        let mut _6: &mut T;              // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // bb0[0]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+        StorageLive(_3);                 // bb0[1]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+        StorageLive(_4);                 // bb0[2]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:6\n+        _4 = &mut (*_1);                 // bb0[3]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:6\n+        StorageLive(_5);                 // bb0[4]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        StorageLive(_6);                 // bb0[5]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _6 = &mut (*(*_4));              // bb0[6]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _5 = _6;                         // bb0[7]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _3 = _5;                         // bb0[8]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        StorageDead(_6);                 // bb0[9]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        StorageDead(_5);                 // bb0[10]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _2 = &mut (*_3);                 // bb0[11]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+        StorageDead(_4);                 // bb0[12]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:14: 8:15\n+        _0 = &mut (*_2);                 // bb0[13]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+        StorageDead(_3);                 // bb0[14]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:9:1: 9:2\n+        StorageDead(_2);                 // bb0[15]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:9:1: 9:2\n+        return;                          // bb0[16]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:9:2: 9:2\n+    }\n+}"}, {"sha": "5adb4a68312576358084a2a3ed9c07a98a664a62", "filename": "src/test/mir-opt/inline/issue-58867-inline-as-ref-as-mut/rustc.c.Inline.after.mir", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.c.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.c.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.c.Inline.after.mir?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -0,0 +1,22 @@\n+// MIR for `c` after Inline\n+\n+fn c(_1: &[T]) -> &[T] {\n+    debug x => _1;                       // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:12:13: 12:14\n+    let mut _0: &[T];                    // return place in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:12:25: 12:29\n+    let _2: &[T];                        // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:15\n+    let mut _3: &[T];                    // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:6\n+    scope 1 {\n+        debug self => _3;                // in scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // bb0[0]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:15\n+        StorageLive(_3);                 // bb0[1]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:6\n+        _3 = &(*_1);                     // bb0[2]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:6\n+        _2 = _3;                         // bb0[3]: scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+        _0 = &(*_2);                     // bb0[4]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:15\n+        StorageDead(_3);                 // bb0[5]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:14: 13:15\n+        StorageDead(_2);                 // bb0[6]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:14:1: 14:2\n+        return;                          // bb0[7]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:14:2: 14:2\n+    }\n+}"}, {"sha": "d4d62dd788e0002bb997ec4a18c6a3ce8c8db3d1", "filename": "src/test/mir-opt/inline/issue-58867-inline-as-ref-as-mut/rustc.d.Inline.after.mir", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.d.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.d.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.d.Inline.after.mir?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -0,0 +1,26 @@\n+// MIR for `d` after Inline\n+\n+fn d(_1: &std::boxed::Box<T>) -> &T {\n+    debug x => _1;                       // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:17:13: 17:14\n+    let mut _0: &T;                      // return place in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:17:28: 17:30\n+    let _2: &T;                          // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n+    let mut _3: &std::boxed::Box<T>;     // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:6\n+    scope 1 {\n+        debug self => _3;                // in scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        let _4: &T;                      // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // bb0[0]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n+        StorageLive(_3);                 // bb0[1]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:6\n+        _3 = &(*_1);                     // bb0[2]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:6\n+        StorageLive(_4);                 // bb0[3]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _4 = &(*(*_3));                  // bb0[4]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _2 = _4;                         // bb0[5]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        StorageDead(_4);                 // bb0[6]: scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _0 = &(*_2);                     // bb0[7]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n+        StorageDead(_3);                 // bb0[8]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:14: 18:15\n+        StorageDead(_2);                 // bb0[9]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:19:1: 19:2\n+        return;                          // bb0[10]: scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:19:2: 19:2\n+    }\n+}"}, {"sha": "c1de6477585851296f8d535f682d61f24d75b1b5", "filename": "src/test/run-make-fulldeps/extern-fn-reachable/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fextern-fn-reachable%2Fmain.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -8,7 +8,7 @@ use std::path::Path;\n pub fn main() {\n     unsafe {\n         let path = Path::new(\"libdylib.so\");\n-        let a = DynamicLibrary::open(Some(&path)).unwrap();\n+        let a = DynamicLibrary::open(&path).unwrap();\n         assert!(a.symbol::<isize>(\"fun1\").is_ok());\n         assert!(a.symbol::<isize>(\"fun2\").is_ok());\n         assert!(a.symbol::<isize>(\"fun3\").is_ok());"}, {"sha": "837ed1f002fc99b3bb1198397989ad9ffd087a73", "filename": "src/test/ui-fulldeps/auxiliary/linkage-visibility.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flinkage-visibility.rs?ref=7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f", "patch": "@@ -1,35 +0,0 @@\n-// ignore-musl - dlsym doesn't see symbols without \"-C link-arg=-Wl,--export-dynamic\"\n-\n-#![feature(rustc_private)]\n-\n-extern crate rustc_metadata;\n-\n-use rustc_metadata::dynamic_lib::DynamicLibrary;\n-\n-#[no_mangle]\n-pub fn foo() {\n-    bar();\n-}\n-\n-pub fn foo2<T>() {\n-    fn bar2() {\n-        bar();\n-    }\n-    bar2();\n-}\n-\n-#[no_mangle]\n-fn bar() {}\n-\n-#[allow(dead_code)]\n-#[no_mangle]\n-fn baz() {}\n-\n-pub fn test() {\n-    let lib = DynamicLibrary::open(None).unwrap();\n-    unsafe {\n-        assert!(lib.symbol::<isize>(\"foo\").is_ok());\n-        assert!(lib.symbol::<isize>(\"baz\").is_ok());\n-        assert!(lib.symbol::<isize>(\"bar\").is_ok());\n-    }\n-}"}, {"sha": "ae46fbc4e8a03b9ad82980559173c64df63506c4", "filename": "src/test/ui-fulldeps/linkage-visibility.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f/src%2Ftest%2Fui-fulldeps%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f/src%2Ftest%2Fui-fulldeps%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flinkage-visibility.rs?ref=7f3b3df9e2f2efe3434b4f6fc76462d2c8ad332f", "patch": "@@ -1,13 +0,0 @@\n-// run-pass\n-// aux-build:linkage-visibility.rs\n-// ignore-android: FIXME(#10356)\n-// ignore-windows: std::dynamic_lib does not work on Windows well\n-// ignore-emscripten no dynamic linking\n-\n-extern crate linkage_visibility as foo;\n-\n-pub fn main() {\n-    foo::test();\n-    foo::foo2::<isize>();\n-    foo::foo();\n-}"}, {"sha": "5f8a3fd9d6a5491a96f02cb49184b1793e4d3df7", "filename": "src/test/ui/box-into-boxed-slice-fail.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fui%2Fbox-into-boxed-slice-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fui%2Fbox-into-boxed-slice-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox-into-boxed-slice-fail.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -0,0 +1,15 @@\n+// ignore-tidy-linelength\n+#![feature(box_into_boxed_slice)]\n+\n+use std::boxed::Box;\n+use std::fmt::Debug;\n+fn main() {\n+    let boxed_slice = Box::new([1,2,3]) as Box<[u8]>;\n+    let _ = Box::into_boxed_slice(boxed_slice);\n+    //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n+    //~^^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n+    let boxed_trait: Box<dyn Debug> = Box::new(5u8);\n+    let _ = Box::into_boxed_slice(boxed_trait);\n+    //~^ ERROR the size for values of type `dyn std::fmt::Debug` cannot be known at compilation time\n+    //~^^ ERROR the size for values of type `dyn std::fmt::Debug` cannot be known at compilation time\n+}"}, {"sha": "dfc4999958a5725602cbf1693362e51dd5f36199", "filename": "src/test/ui/box-into-boxed-slice-fail.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fui%2Fbox-into-boxed-slice-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fui%2Fbox-into-boxed-slice-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox-into-boxed-slice-fail.stderr?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -0,0 +1,43 @@\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/box-into-boxed-slice-fail.rs:8:35\n+   |\n+LL |     let _ = Box::into_boxed_slice(boxed_slice);\n+   |                                   ^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required by `std::boxed::Box::<T>::into_boxed_slice`\n+\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/box-into-boxed-slice-fail.rs:8:13\n+   |\n+LL |     let _ = Box::into_boxed_slice(boxed_slice);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: slice and array elements must have `Sized` type\n+\n+error[E0277]: the size for values of type `dyn std::fmt::Debug` cannot be known at compilation time\n+  --> $DIR/box-into-boxed-slice-fail.rs:12:35\n+   |\n+LL |     let _ = Box::into_boxed_slice(boxed_trait);\n+   |                                   ^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `dyn std::fmt::Debug`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required by `std::boxed::Box::<T>::into_boxed_slice`\n+\n+error[E0277]: the size for values of type `dyn std::fmt::Debug` cannot be known at compilation time\n+  --> $DIR/box-into-boxed-slice-fail.rs:12:13\n+   |\n+LL |     let _ = Box::into_boxed_slice(boxed_trait);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `dyn std::fmt::Debug`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: slice and array elements must have `Sized` type\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "61b3d91525347ae01075cf817f27bdc6ed32a3d5", "filename": "src/test/ui/box-into-boxed-slice.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fui%2Fbox-into-boxed-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83f7563495dbe2629b0cbc738afb0808c4482e1/src%2Ftest%2Fui%2Fbox-into-boxed-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox-into-boxed-slice.rs?ref=e83f7563495dbe2629b0cbc738afb0808c4482e1", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+#![feature(box_into_boxed_slice)]\n+\n+use std::boxed::Box;\n+fn main() {\n+    assert_eq!(Box::into_boxed_slice(Box::new(5u8)), Box::new([5u8]) as Box<[u8]>);\n+    assert_eq!(Box::into_boxed_slice(Box::new([25u8])), Box::new([[25u8]]) as Box<[[u8; 1]]>);\n+    let a: Box<[Box<[u8; 1]>]> = Box::into_boxed_slice(Box::new(Box::new([5u8])));\n+    let b: Box<[Box<[u8; 1]>]> = Box::new([Box::new([5u8])]);\n+    assert_eq!(a, b);\n+}"}]}