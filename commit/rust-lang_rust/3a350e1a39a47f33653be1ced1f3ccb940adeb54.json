{"sha": "3a350e1a39a47f33653be1ced1f3ccb940adeb54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMzUwZTFhMzlhNDdmMzM2NTNiZTFjZWQxZjNjY2I5NDBhZGViNTQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-30T13:11:49Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-01T12:16:43Z"}, "message": "Move early lint machanism in librustc_lint.", "tree": {"sha": "690e1bc6d07178bc9694967cba3367d928d4832a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/690e1bc6d07178bc9694967cba3367d928d4832a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a350e1a39a47f33653be1ced1f3ccb940adeb54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a350e1a39a47f33653be1ced1f3ccb940adeb54", "html_url": "https://github.com/rust-lang/rust/commit/3a350e1a39a47f33653be1ced1f3ccb940adeb54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a350e1a39a47f33653be1ced1f3ccb940adeb54/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e6fb538f9254884ca9f958fdce413d6c3f2016c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e6fb538f9254884ca9f958fdce413d6c3f2016c", "html_url": "https://github.com/rust-lang/rust/commit/9e6fb538f9254884ca9f958fdce413d6c3f2016c"}], "stats": {"total": 769, "additions": 399, "deletions": 370}, "files": [{"sha": "ad6bdae1697e0329031c6226c18c6a97e7416d00", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 364, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3a350e1a39a47f33653be1ced1f3ccb940adeb54", "patch": "@@ -23,7 +23,7 @@ use crate::hir::intravisit::Visitor;\n use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n-use crate::lint::{EarlyLintPass, EarlyLintPassObject, LateLintPass, LateLintPassObject};\n+use crate::lint::{EarlyLintPassObject, LateLintPass, LateLintPassObject};\n use crate::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId, LintPass};\n use crate::middle::privacy::AccessLevels;\n use crate::session::Session;\n@@ -38,7 +38,6 @@ use rustc_span::{symbol::Symbol, MultiSpan, Span};\n use std::slice;\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::visit as ast_visit;\n \n use rustc_error_codes::*;\n \n@@ -56,8 +55,8 @@ pub struct LintStore {\n     /// interior mutability, we don't enforce this (and lints should, in theory,\n     /// be compatible with being constructed more than once, though not\n     /// necessarily in a sane manner. This is safe though.)\n-    pre_expansion_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n-    early_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n+    pub pre_expansion_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n+    pub early_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n     late_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n     /// This is unique in that we construct them per-module, so not once.\n     late_module_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n@@ -455,7 +454,7 @@ pub struct LateContext<'a, 'tcx> {\n     pub generics: Option<&'tcx hir::Generics<'tcx>>,\n \n     /// We are only looking at one module\n-    only_module: bool,\n+    pub only_module: bool,\n }\n \n pub struct LateContextAndPass<'a, 'tcx, T: LateLintPass<'a, 'tcx>> {\n@@ -472,17 +471,12 @@ pub struct EarlyContext<'a> {\n     /// The crate being checked.\n     pub krate: &'a ast::Crate,\n \n-    builder: LintLevelsBuilder<'a>,\n+    pub builder: LintLevelsBuilder<'a>,\n \n     /// The store of registered lints and the lint levels.\n-    lint_store: &'a LintStore,\n+    pub lint_store: &'a LintStore,\n \n-    buffered: LintBuffer,\n-}\n-\n-pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n-    context: EarlyContext<'a>,\n-    pass: T,\n+    pub buffered: LintBuffer,\n }\n \n pub trait LintPassObject: Sized {}\n@@ -567,7 +561,7 @@ pub trait LintContext: Sized {\n }\n \n impl<'a> EarlyContext<'a> {\n-    fn new(\n+    pub fn new(\n         sess: &'a Session,\n         lint_store: &'a LintStore,\n         krate: &'a ast::Crate,\n@@ -588,48 +582,6 @@ macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n \n-macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    $cx.pass.$f(&$cx.context, $($args),*);\n-}) }\n-\n-impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n-    fn check_id(&mut self, id: ast::NodeId) {\n-        for early_lint in self.context.buffered.take(id) {\n-            self.context.lookup_and_emit_with_diagnostics(\n-                early_lint.lint_id.lint,\n-                Some(early_lint.span.clone()),\n-                &early_lint.msg,\n-                early_lint.diagnostic,\n-            );\n-        }\n-    }\n-\n-    /// Merge the lints specified by any lint attributes into the\n-    /// current lint context, call the provided function, then reset the\n-    /// lints in effect to their previous state.\n-    fn with_lint_attrs<F>(&mut self, id: ast::NodeId, attrs: &'a [ast::Attribute], f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let push = self.context.builder.push(attrs, &self.context.lint_store);\n-        self.check_id(id);\n-        self.enter_attrs(attrs);\n-        f(self);\n-        self.exit_attrs(attrs);\n-        self.context.builder.pop(push);\n-    }\n-\n-    fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n-        debug!(\"early context: enter_attrs({:?})\", attrs);\n-        run_early_pass!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n-        debug!(\"early context: exit_attrs({:?})\", attrs);\n-        run_early_pass!(self, exit_lint_attrs, attrs);\n-    }\n-}\n-\n impl LintContext for LateContext<'_, '_> {\n     type PassObject = LateLintPassObject;\n \n@@ -1103,195 +1055,6 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n     }\n }\n \n-impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n-    fn visit_param(&mut self, param: &'a ast::Param) {\n-        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n-            run_early_pass!(cx, check_param, param);\n-            ast_visit::walk_param(cx, param);\n-        });\n-    }\n-\n-    fn visit_item(&mut self, it: &'a ast::Item) {\n-        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n-            run_early_pass!(cx, check_item, it);\n-            ast_visit::walk_item(cx, it);\n-            run_early_pass!(cx, check_item_post, it);\n-        })\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n-        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n-            run_early_pass!(cx, check_foreign_item, it);\n-            ast_visit::walk_foreign_item(cx, it);\n-            run_early_pass!(cx, check_foreign_item_post, it);\n-        })\n-    }\n-\n-    fn visit_pat(&mut self, p: &'a ast::Pat) {\n-        run_early_pass!(self, check_pat, p);\n-        self.check_id(p.id);\n-        ast_visit::walk_pat(self, p);\n-        run_early_pass!(self, check_pat_post, p);\n-    }\n-\n-    fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n-            run_early_pass!(cx, check_expr, e);\n-            ast_visit::walk_expr(cx, e);\n-        })\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n-        run_early_pass!(self, check_stmt, s);\n-        self.check_id(s.id);\n-        ast_visit::walk_stmt(self, s);\n-    }\n-\n-    fn visit_fn(\n-        &mut self,\n-        fk: ast_visit::FnKind<'a>,\n-        decl: &'a ast::FnDecl,\n-        span: Span,\n-        id: ast::NodeId,\n-    ) {\n-        run_early_pass!(self, check_fn, fk, decl, span, id);\n-        self.check_id(id);\n-        ast_visit::walk_fn(self, fk, decl, span);\n-        run_early_pass!(self, check_fn_post, fk, decl, span, id);\n-    }\n-\n-    fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n-        run_early_pass!(self, check_struct_def, s);\n-        if let Some(ctor_hir_id) = s.ctor_id() {\n-            self.check_id(ctor_hir_id);\n-        }\n-        ast_visit::walk_struct_def(self, s);\n-        run_early_pass!(self, check_struct_def_post, s);\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n-        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n-            run_early_pass!(cx, check_struct_field, s);\n-            ast_visit::walk_struct_field(cx, s);\n-        })\n-    }\n-\n-    fn visit_variant(&mut self, v: &'a ast::Variant) {\n-        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            run_early_pass!(cx, check_variant, v);\n-            ast_visit::walk_variant(cx, v);\n-            run_early_pass!(cx, check_variant_post, v);\n-        })\n-    }\n-\n-    fn visit_ty(&mut self, t: &'a ast::Ty) {\n-        run_early_pass!(self, check_ty, t);\n-        self.check_id(t.id);\n-        ast_visit::walk_ty(self, t);\n-    }\n-\n-    fn visit_ident(&mut self, ident: ast::Ident) {\n-        run_early_pass!(self, check_ident, ident);\n-    }\n-\n-    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n-        run_early_pass!(self, check_mod, m, s, n);\n-        self.check_id(n);\n-        ast_visit::walk_mod(self, m);\n-        run_early_pass!(self, check_mod_post, m, s, n);\n-    }\n-\n-    fn visit_local(&mut self, l: &'a ast::Local) {\n-        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n-            run_early_pass!(cx, check_local, l);\n-            ast_visit::walk_local(cx, l);\n-        })\n-    }\n-\n-    fn visit_block(&mut self, b: &'a ast::Block) {\n-        run_early_pass!(self, check_block, b);\n-        self.check_id(b.id);\n-        ast_visit::walk_block(self, b);\n-        run_early_pass!(self, check_block_post, b);\n-    }\n-\n-    fn visit_arm(&mut self, a: &'a ast::Arm) {\n-        run_early_pass!(self, check_arm, a);\n-        ast_visit::walk_arm(self, a);\n-    }\n-\n-    fn visit_expr_post(&mut self, e: &'a ast::Expr) {\n-        run_early_pass!(self, check_expr_post, e);\n-    }\n-\n-    fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n-        run_early_pass!(self, check_generic_param, param);\n-        ast_visit::walk_generic_param(self, param);\n-    }\n-\n-    fn visit_generics(&mut self, g: &'a ast::Generics) {\n-        run_early_pass!(self, check_generics, g);\n-        ast_visit::walk_generics(self, g);\n-    }\n-\n-    fn visit_where_predicate(&mut self, p: &'a ast::WherePredicate) {\n-        run_early_pass!(self, check_where_predicate, p);\n-        ast_visit::walk_where_predicate(self, p);\n-    }\n-\n-    fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef, m: &'a ast::TraitBoundModifier) {\n-        run_early_pass!(self, check_poly_trait_ref, t, m);\n-        ast_visit::walk_poly_trait_ref(self, t, m);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'a ast::AssocItem) {\n-        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n-            run_early_pass!(cx, check_trait_item, trait_item);\n-            ast_visit::walk_trait_item(cx, trait_item);\n-            run_early_pass!(cx, check_trait_item_post, trait_item);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'a ast::AssocItem) {\n-        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n-            run_early_pass!(cx, check_impl_item, impl_item);\n-            ast_visit::walk_impl_item(cx, impl_item);\n-            run_early_pass!(cx, check_impl_item_post, impl_item);\n-        });\n-    }\n-\n-    fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n-        run_early_pass!(self, check_lifetime, lt);\n-        self.check_id(lt.id);\n-    }\n-\n-    fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n-        run_early_pass!(self, check_path, p, id);\n-        self.check_id(id);\n-        ast_visit::walk_path(self, p);\n-    }\n-\n-    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n-        run_early_pass!(self, check_attribute, attr);\n-    }\n-\n-    fn visit_mac_def(&mut self, mac: &'a ast::MacroDef, id: ast::NodeId) {\n-        run_early_pass!(self, check_mac_def, mac, id);\n-        self.check_id(id);\n-    }\n-\n-    fn visit_mac(&mut self, mac: &'a ast::Mac) {\n-        // FIXME(#54110): So, this setup isn't really right. I think\n-        // that (a) the libsyntax visitor ought to be doing this as\n-        // part of `walk_mac`, and (b) we should be calling\n-        // `visit_path`, *but* that would require a `NodeId`, and I\n-        // want to get #53686 fixed quickly. -nmatsakis\n-        ast_visit::walk_path(self, &mac.path);\n-\n-        run_early_pass!(self, check_mac, mac);\n-    }\n-}\n-\n struct LateLintPassObjects<'a> {\n     lints: &'a mut [LateLintPassObject],\n }\n@@ -1451,122 +1214,3 @@ pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         },\n     );\n }\n-\n-struct EarlyLintPassObjects<'a> {\n-    lints: &'a mut [EarlyLintPassObject],\n-}\n-\n-#[allow(rustc::lint_pass_impl_without_macro)]\n-impl LintPass for EarlyLintPassObjects<'_> {\n-    fn name(&self) -> &'static str {\n-        panic!()\n-    }\n-}\n-\n-macro_rules! expand_early_lint_pass_impl_methods {\n-    ([$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n-            for obj in self.lints.iter_mut() {\n-                obj.$name(context, $($param),*);\n-            }\n-        })*\n-    )\n-}\n-\n-macro_rules! early_lint_pass_impl {\n-    ([], [$($methods:tt)*]) => (\n-        impl EarlyLintPass for EarlyLintPassObjects<'_> {\n-            expand_early_lint_pass_impl_methods!([$($methods)*]);\n-        }\n-    )\n-}\n-\n-early_lint_methods!(early_lint_pass_impl, []);\n-\n-fn early_lint_crate<T: EarlyLintPass>(\n-    sess: &Session,\n-    lint_store: &LintStore,\n-    krate: &ast::Crate,\n-    pass: T,\n-    buffered: LintBuffer,\n-    warn_about_weird_lints: bool,\n-) -> LintBuffer {\n-    let mut cx = EarlyContextAndPass {\n-        context: EarlyContext::new(sess, lint_store, krate, buffered, warn_about_weird_lints),\n-        pass,\n-    };\n-\n-    // Visit the whole crate.\n-    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n-        // since the root module isn't visited as an item (because it isn't an\n-        // item), warn for it here.\n-        run_early_pass!(cx, check_crate, krate);\n-\n-        ast_visit::walk_crate(cx, krate);\n-\n-        run_early_pass!(cx, check_crate_post, krate);\n-    });\n-    cx.context.buffered\n-}\n-\n-pub fn check_ast_crate<T: EarlyLintPass>(\n-    sess: &Session,\n-    lint_store: &LintStore,\n-    krate: &ast::Crate,\n-    pre_expansion: bool,\n-    lint_buffer: Option<LintBuffer>,\n-    builtin_lints: T,\n-) {\n-    let mut passes: Vec<_> = if pre_expansion {\n-        lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect()\n-    } else {\n-        lint_store.early_passes.iter().map(|p| (p)()).collect()\n-    };\n-    let mut buffered = lint_buffer.unwrap_or_default();\n-\n-    if !sess.opts.debugging_opts.no_interleave_lints {\n-        buffered =\n-            early_lint_crate(sess, lint_store, krate, builtin_lints, buffered, pre_expansion);\n-\n-        if !passes.is_empty() {\n-            buffered = early_lint_crate(\n-                sess,\n-                lint_store,\n-                krate,\n-                EarlyLintPassObjects { lints: &mut passes[..] },\n-                buffered,\n-                pre_expansion,\n-            );\n-        }\n-    } else {\n-        for pass in &mut passes {\n-            buffered = time(sess, &format!(\"running lint: {}\", pass.name()), || {\n-                early_lint_crate(\n-                    sess,\n-                    lint_store,\n-                    krate,\n-                    EarlyLintPassObjects { lints: slice::from_mut(pass) },\n-                    buffered,\n-                    pre_expansion,\n-                )\n-            });\n-        }\n-    }\n-\n-    // All of the buffered lints should have been emitted at this point.\n-    // If not, that means that we somehow buffered a lint for a node id\n-    // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n-    //\n-    // Rustdoc runs everybody-loops before the early lints and removes\n-    // function bodies, so it's totally possible for linted\n-    // node ids to not exist (e.g., macros defined within functions for the\n-    // unused_macro lint) anymore. So we only run this check\n-    // when we're not in rustdoc mode. (see issue #47639)\n-    if !sess.opts.actually_rustdoc {\n-        for (_id, lints) in buffered.map {\n-            for early_lint in lints {\n-                sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n-            }\n-        }\n-    }\n-}"}, {"sha": "f2d7d72360d44b51e576bc61df7932024eb76d6b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=3a350e1a39a47f33653be1ced1f3ccb940adeb54", "patch": "@@ -39,8 +39,8 @@ use syntax::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n use syntax::symbol::Symbol;\n \n pub use crate::lint::context::{\n-    check_ast_crate, check_crate, late_lint_mod, BufferedEarlyLint, CheckLintNameResult,\n-    EarlyContext, LateContext, LintContext, LintStore,\n+    check_crate, late_lint_mod, BufferedEarlyLint, CheckLintNameResult, EarlyContext, LateContext,\n+    LintContext, LintStore,\n };\n \n pub use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintId};\n@@ -380,7 +380,7 @@ pub use self::levels::{LintLevelMap, LintLevelSets};\n \n #[derive(Default)]\n pub struct LintBuffer {\n-    map: NodeMap<Vec<BufferedEarlyLint>>,\n+    pub map: NodeMap<Vec<BufferedEarlyLint>>,\n }\n \n impl LintBuffer {\n@@ -405,7 +405,7 @@ impl LintBuffer {\n         }\n     }\n \n-    fn take(&mut self, id: ast::NodeId) -> Vec<BufferedEarlyLint> {\n+    pub fn take(&mut self, id: ast::NodeId) -> Vec<BufferedEarlyLint> {\n         self.map.remove(&id).unwrap_or_default()\n     }\n "}, {"sha": "35d6d3abdd894eab8000b5690069d9077f3c7672", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=3a350e1a39a47f33653be1ced1f3ccb940adeb54", "patch": "@@ -231,7 +231,7 @@ fn configure_and_expand_inner<'a>(\n     metadata_loader: &'a MetadataLoaderDyn,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     time(sess, \"pre-AST-expansion lint checks\", || {\n-        lint::check_ast_crate(\n+        rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n             &krate,\n@@ -458,7 +458,7 @@ pub fn lower_to_hir<'res, 'tcx>(\n     });\n \n     time(sess, \"early lint checks\", || {\n-        lint::check_ast_crate(\n+        rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n             &krate,"}, {"sha": "482a7822b7679f428b63b4f37df35d8675e46364", "filename": "src/librustc_lint/early.rs", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=3a350e1a39a47f33653be1ced1f3ccb940adeb54", "patch": "@@ -0,0 +1,383 @@\n+//! Implementation of lint checking.\n+//!\n+//! The lint checking is mostly consolidated into one pass which runs\n+//! after all other analyses. Throughout compilation, lint warnings\n+//! can be added via the `add_lint` method on the Session structure. This\n+//! requires a span and an ID of the node that the lint is being added to. The\n+//! lint isn't actually emitted at that time because it is unknown what the\n+//! actual lint level at that location is.\n+//!\n+//! To actually emit lint warnings/errors, a separate pass is used.\n+//! A context keeps track of the current state of all lint levels.\n+//! Upon entering a node of the ast which can modify the lint settings, the\n+//! previous lint state is pushed onto a stack and the ast is then recursed\n+//! upon. As the ast is traversed, this keeps track of the current lint level\n+//! for all lint attributes.\n+\n+use rustc::lint::{EarlyContext, LintStore};\n+use rustc::lint::{EarlyLintPass, EarlyLintPassObject};\n+use rustc::lint::{LintBuffer, LintContext, LintPass};\n+use rustc::session::Session;\n+use rustc::util::common::time;\n+\n+use rustc_span::Span;\n+use std::slice;\n+use syntax::ast;\n+use syntax::visit as ast_visit;\n+\n+use log::debug;\n+\n+macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n+}) }\n+\n+struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n+    context: EarlyContext<'a>,\n+    pass: T,\n+}\n+\n+impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n+    fn check_id(&mut self, id: ast::NodeId) {\n+        for early_lint in self.context.buffered.take(id) {\n+            self.context.lookup_and_emit_with_diagnostics(\n+                early_lint.lint_id.lint,\n+                Some(early_lint.span.clone()),\n+                &early_lint.msg,\n+                early_lint.diagnostic,\n+            );\n+        }\n+    }\n+\n+    /// Merge the lints specified by any lint attributes into the\n+    /// current lint context, call the provided function, then reset the\n+    /// lints in effect to their previous state.\n+    fn with_lint_attrs<F>(&mut self, id: ast::NodeId, attrs: &'a [ast::Attribute], f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let push = self.context.builder.push(attrs, &self.context.lint_store);\n+        self.check_id(id);\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.context.builder.pop(push);\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n+        debug!(\"early context: enter_attrs({:?})\", attrs);\n+        run_early_pass!(self, enter_lint_attrs, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n+        debug!(\"early context: exit_attrs({:?})\", attrs);\n+        run_early_pass!(self, exit_lint_attrs, attrs);\n+    }\n+}\n+\n+impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n+    fn visit_param(&mut self, param: &'a ast::Param) {\n+        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n+            run_early_pass!(cx, check_param, param);\n+            ast_visit::walk_param(cx, param);\n+        });\n+    }\n+\n+    fn visit_item(&mut self, it: &'a ast::Item) {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n+            run_early_pass!(cx, check_item, it);\n+            ast_visit::walk_item(cx, it);\n+            run_early_pass!(cx, check_item_post, it);\n+        })\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n+            run_early_pass!(cx, check_foreign_item, it);\n+            ast_visit::walk_foreign_item(cx, it);\n+            run_early_pass!(cx, check_foreign_item_post, it);\n+        })\n+    }\n+\n+    fn visit_pat(&mut self, p: &'a ast::Pat) {\n+        run_early_pass!(self, check_pat, p);\n+        self.check_id(p.id);\n+        ast_visit::walk_pat(self, p);\n+        run_early_pass!(self, check_pat_post, p);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n+        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n+            run_early_pass!(cx, check_expr, e);\n+            ast_visit::walk_expr(cx, e);\n+        })\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n+        run_early_pass!(self, check_stmt, s);\n+        self.check_id(s.id);\n+        ast_visit::walk_stmt(self, s);\n+    }\n+\n+    fn visit_fn(\n+        &mut self,\n+        fk: ast_visit::FnKind<'a>,\n+        decl: &'a ast::FnDecl,\n+        span: Span,\n+        id: ast::NodeId,\n+    ) {\n+        run_early_pass!(self, check_fn, fk, decl, span, id);\n+        self.check_id(id);\n+        ast_visit::walk_fn(self, fk, decl, span);\n+        run_early_pass!(self, check_fn_post, fk, decl, span, id);\n+    }\n+\n+    fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n+        run_early_pass!(self, check_struct_def, s);\n+        if let Some(ctor_hir_id) = s.ctor_id() {\n+            self.check_id(ctor_hir_id);\n+        }\n+        ast_visit::walk_struct_def(self, s);\n+        run_early_pass!(self, check_struct_def_post, s);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n+        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n+            run_early_pass!(cx, check_struct_field, s);\n+            ast_visit::walk_struct_field(cx, s);\n+        })\n+    }\n+\n+    fn visit_variant(&mut self, v: &'a ast::Variant) {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+            run_early_pass!(cx, check_variant, v);\n+            ast_visit::walk_variant(cx, v);\n+            run_early_pass!(cx, check_variant_post, v);\n+        })\n+    }\n+\n+    fn visit_ty(&mut self, t: &'a ast::Ty) {\n+        run_early_pass!(self, check_ty, t);\n+        self.check_id(t.id);\n+        ast_visit::walk_ty(self, t);\n+    }\n+\n+    fn visit_ident(&mut self, ident: ast::Ident) {\n+        run_early_pass!(self, check_ident, ident);\n+    }\n+\n+    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n+        run_early_pass!(self, check_mod, m, s, n);\n+        self.check_id(n);\n+        ast_visit::walk_mod(self, m);\n+        run_early_pass!(self, check_mod_post, m, s, n);\n+    }\n+\n+    fn visit_local(&mut self, l: &'a ast::Local) {\n+        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n+            run_early_pass!(cx, check_local, l);\n+            ast_visit::walk_local(cx, l);\n+        })\n+    }\n+\n+    fn visit_block(&mut self, b: &'a ast::Block) {\n+        run_early_pass!(self, check_block, b);\n+        self.check_id(b.id);\n+        ast_visit::walk_block(self, b);\n+        run_early_pass!(self, check_block_post, b);\n+    }\n+\n+    fn visit_arm(&mut self, a: &'a ast::Arm) {\n+        run_early_pass!(self, check_arm, a);\n+        ast_visit::walk_arm(self, a);\n+    }\n+\n+    fn visit_expr_post(&mut self, e: &'a ast::Expr) {\n+        run_early_pass!(self, check_expr_post, e);\n+    }\n+\n+    fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n+        run_early_pass!(self, check_generic_param, param);\n+        ast_visit::walk_generic_param(self, param);\n+    }\n+\n+    fn visit_generics(&mut self, g: &'a ast::Generics) {\n+        run_early_pass!(self, check_generics, g);\n+        ast_visit::walk_generics(self, g);\n+    }\n+\n+    fn visit_where_predicate(&mut self, p: &'a ast::WherePredicate) {\n+        run_early_pass!(self, check_where_predicate, p);\n+        ast_visit::walk_where_predicate(self, p);\n+    }\n+\n+    fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef, m: &'a ast::TraitBoundModifier) {\n+        run_early_pass!(self, check_poly_trait_ref, t, m);\n+        ast_visit::walk_poly_trait_ref(self, t, m);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'a ast::AssocItem) {\n+        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n+            run_early_pass!(cx, check_trait_item, trait_item);\n+            ast_visit::walk_trait_item(cx, trait_item);\n+            run_early_pass!(cx, check_trait_item_post, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'a ast::AssocItem) {\n+        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n+            run_early_pass!(cx, check_impl_item, impl_item);\n+            ast_visit::walk_impl_item(cx, impl_item);\n+            run_early_pass!(cx, check_impl_item_post, impl_item);\n+        });\n+    }\n+\n+    fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n+        run_early_pass!(self, check_lifetime, lt);\n+        self.check_id(lt.id);\n+    }\n+\n+    fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n+        run_early_pass!(self, check_path, p, id);\n+        self.check_id(id);\n+        ast_visit::walk_path(self, p);\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n+        run_early_pass!(self, check_attribute, attr);\n+    }\n+\n+    fn visit_mac_def(&mut self, mac: &'a ast::MacroDef, id: ast::NodeId) {\n+        run_early_pass!(self, check_mac_def, mac, id);\n+        self.check_id(id);\n+    }\n+\n+    fn visit_mac(&mut self, mac: &'a ast::Mac) {\n+        // FIXME(#54110): So, this setup isn't really right. I think\n+        // that (a) the libsyntax visitor ought to be doing this as\n+        // part of `walk_mac`, and (b) we should be calling\n+        // `visit_path`, *but* that would require a `NodeId`, and I\n+        // want to get #53686 fixed quickly. -nmatsakis\n+        ast_visit::walk_path(self, &mac.path);\n+\n+        run_early_pass!(self, check_mac, mac);\n+    }\n+}\n+\n+struct EarlyLintPassObjects<'a> {\n+    lints: &'a mut [EarlyLintPassObject],\n+}\n+\n+#[allow(rustc::lint_pass_impl_without_macro)]\n+impl LintPass for EarlyLintPassObjects<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! expand_early_lint_pass_impl_methods {\n+    ([$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n+            for obj in self.lints.iter_mut() {\n+                obj.$name(context, $($param),*);\n+            }\n+        })*\n+    )\n+}\n+\n+macro_rules! early_lint_pass_impl {\n+    ([], [$($methods:tt)*]) => (\n+        impl EarlyLintPass for EarlyLintPassObjects<'_> {\n+            expand_early_lint_pass_impl_methods!([$($methods)*]);\n+        }\n+    )\n+}\n+\n+early_lint_methods!(early_lint_pass_impl, []);\n+\n+fn early_lint_crate<T: EarlyLintPass>(\n+    sess: &Session,\n+    lint_store: &LintStore,\n+    krate: &ast::Crate,\n+    pass: T,\n+    buffered: LintBuffer,\n+    warn_about_weird_lints: bool,\n+) -> LintBuffer {\n+    let mut cx = EarlyContextAndPass {\n+        context: EarlyContext::new(sess, lint_store, krate, buffered, warn_about_weird_lints),\n+        pass,\n+    };\n+\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        run_early_pass!(cx, check_crate, krate);\n+\n+        ast_visit::walk_crate(cx, krate);\n+\n+        run_early_pass!(cx, check_crate_post, krate);\n+    });\n+    cx.context.buffered\n+}\n+\n+pub fn check_ast_crate<T: EarlyLintPass>(\n+    sess: &Session,\n+    lint_store: &LintStore,\n+    krate: &ast::Crate,\n+    pre_expansion: bool,\n+    lint_buffer: Option<LintBuffer>,\n+    builtin_lints: T,\n+) {\n+    let mut passes: Vec<_> = if pre_expansion {\n+        lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect()\n+    } else {\n+        lint_store.early_passes.iter().map(|p| (p)()).collect()\n+    };\n+    let mut buffered = lint_buffer.unwrap_or_default();\n+\n+    if !sess.opts.debugging_opts.no_interleave_lints {\n+        buffered =\n+            early_lint_crate(sess, lint_store, krate, builtin_lints, buffered, pre_expansion);\n+\n+        if !passes.is_empty() {\n+            buffered = early_lint_crate(\n+                sess,\n+                lint_store,\n+                krate,\n+                EarlyLintPassObjects { lints: &mut passes[..] },\n+                buffered,\n+                pre_expansion,\n+            );\n+        }\n+    } else {\n+        for pass in &mut passes {\n+            buffered = time(sess, &format!(\"running lint: {}\", pass.name()), || {\n+                early_lint_crate(\n+                    sess,\n+                    lint_store,\n+                    krate,\n+                    EarlyLintPassObjects { lints: slice::from_mut(pass) },\n+                    buffered,\n+                    pre_expansion,\n+                )\n+            });\n+        }\n+    }\n+\n+    // All of the buffered lints should have been emitted at this point.\n+    // If not, that means that we somehow buffered a lint for a node id\n+    // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n+    //\n+    // Rustdoc runs everybody-loops before the early lints and removes\n+    // function bodies, so it's totally possible for linted\n+    // node ids to not exist (e.g., macros defined within functions for the\n+    // unused_macro lint) anymore. So we only run this check\n+    // when we're not in rustdoc mode. (see issue #47639)\n+    if !sess.opts.actually_rustdoc {\n+        for (_id, lints) in buffered.map {\n+            for early_lint in lints {\n+                sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "57f260e758dee964ce3f63960586f14b0ea6c589", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a350e1a39a47f33653be1ced1f3ccb940adeb54/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=3a350e1a39a47f33653be1ced1f3ccb940adeb54", "patch": "@@ -24,6 +24,7 @@ extern crate rustc_session;\n \n mod array_into_iter;\n pub mod builtin;\n+mod early;\n mod non_ascii_idents;\n mod nonstandard_style;\n mod redundant_semicolon;\n@@ -57,6 +58,7 @@ use unused::*;\n \n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n+pub use early::check_ast_crate;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { lint_mod, ..*providers };"}]}