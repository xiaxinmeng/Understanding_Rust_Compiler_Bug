{"sha": "6335a76b6eb473ea399b16fe9309db142d6b68ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMzVhNzZiNmViNDczZWEzOTliMTZmZTkzMDlkYjE0MmQ2YjY4Y2U=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-02-24T03:24:27Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-02-25T03:56:10Z"}, "message": "rustc: rename `hash` to the proper name `state`", "tree": {"sha": "65bb7ecf9704f6f47b599c9b4824af0e539ea983", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65bb7ecf9704f6f47b599c9b4824af0e539ea983"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6335a76b6eb473ea399b16fe9309db142d6b68ce", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6335a76b6eb473ea399b16fe9309db142d6b68ce", "html_url": "https://github.com/rust-lang/rust/commit/6335a76b6eb473ea399b16fe9309db142d6b68ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6335a76b6eb473ea399b16fe9309db142d6b68ce/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "922eb47a20c432e079444032f9ece9a5a39f2080", "url": "https://api.github.com/repos/rust-lang/rust/commits/922eb47a20c432e079444032f9ece9a5a39f2080", "html_url": "https://github.com/rust-lang/rust/commit/922eb47a20c432e079444032f9ece9a5a39f2080"}], "stats": {"total": 56, "additions": 27, "deletions": 29}, "files": [{"sha": "06efe83231581934578c11e52a81be8ffaedfd71", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6335a76b6eb473ea399b16fe9309db142d6b68ce/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6335a76b6eb473ea399b16fe9309db142d6b68ce/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6335a76b6eb473ea399b16fe9309db142d6b68ce", "patch": "@@ -4925,13 +4925,11 @@ pub fn trait_method_of_method(tcx: ctxt,\n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n-    use std::hash::{sip, Hash};\n+    let mut state = sip::SipState::new(0, 0);\n+    macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n+    macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n \n-    let mut hash = sip::SipState::new(0, 0);\n-    macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut hash) } );\n-    macro_rules! hash( ($e:expr) => { $e.hash(&mut hash) } );\n-\n-    let region = |_hash: &mut sip::SipState, r: Region| {\n+    let region = |_state: &mut sip::SipState, r: Region| {\n         match r {\n             ReStatic => {}\n \n@@ -4945,27 +4943,27 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n             }\n         }\n     };\n-    let vstore = |hash: &mut sip::SipState, v: vstore| {\n+    let vstore = |state: &mut sip::SipState, v: vstore| {\n         match v {\n-            vstore_fixed(_) => 0u8.hash(hash),\n-            vstore_uniq => 1u8.hash(hash),\n+            vstore_fixed(_) => 0u8.hash(state),\n+            vstore_uniq => 1u8.hash(state),\n             vstore_slice(r) => {\n-                2u8.hash(hash);\n-                region(hash, r);\n+                2u8.hash(state);\n+                region(state, r);\n             }\n         }\n     };\n-    let did = |hash: &mut sip::SipState, did: DefId| {\n+    let did = |state: &mut sip::SipState, did: DefId| {\n         let h = if ast_util::is_local(did) {\n             local_hash.clone()\n         } else {\n             tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n-        h.as_bytes().hash(hash);\n-        did.node.hash(hash);\n+        h.as_bytes().hash(state);\n+        did.node.hash(state);\n     };\n-    let mt = |hash: &mut sip::SipState, mt: mt| {\n-        mt.mutbl.hash(hash);\n+    let mt = |state: &mut sip::SipState, mt: mt| {\n+        mt.mutbl.hash(state);\n     };\n     ty::walk_ty(t, |t| {\n         match ty::get(t).sty {\n@@ -5001,17 +4999,17 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n             }\n             ty_vec(m, v) => {\n                 byte!(11);\n-                mt(&mut hash, m);\n-                vstore(&mut hash, v);\n+                mt(&mut state, m);\n+                vstore(&mut state, v);\n             }\n             ty_ptr(m) => {\n                 byte!(12);\n-                mt(&mut hash, m);\n+                mt(&mut state, m);\n             }\n             ty_rptr(r, m) => {\n                 byte!(13);\n-                region(&mut hash, r);\n-                mt(&mut hash, m);\n+                region(&mut state, r);\n+                mt(&mut state, m);\n             }\n             ty_bare_fn(ref b) => {\n                 byte!(14);\n@@ -5024,24 +5022,24 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n                 hash!(c.sigil);\n                 hash!(c.onceness);\n                 hash!(c.bounds);\n-                region(&mut hash, c.region);\n+                region(&mut state, c.region);\n             }\n             ty_trait(d, _, store, m, bounds) => {\n                 byte!(17);\n-                did(&mut hash, d);\n+                did(&mut state, d);\n                 match store {\n                     UniqTraitStore => byte!(0),\n                     RegionTraitStore(r) => {\n                         byte!(1)\n-                        region(&mut hash, r);\n+                        region(&mut state, r);\n                     }\n                 }\n                 hash!(m);\n                 hash!(bounds);\n             }\n             ty_struct(d, _) => {\n                 byte!(18);\n-                did(&mut hash, d);\n+                did(&mut state, d);\n             }\n             ty_tup(ref inner) => {\n                 byte!(19);\n@@ -5050,22 +5048,22 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n             ty_param(p) => {\n                 byte!(20);\n                 hash!(p.idx);\n-                did(&mut hash, p.def_id);\n+                did(&mut state, p.def_id);\n             }\n             ty_self(d) => {\n                 byte!(21);\n-                did(&mut hash, d);\n+                did(&mut state, d);\n             }\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n             ty_unboxed_vec(m) => {\n                 byte!(24);\n-                mt(&mut hash, m);\n+                mt(&mut state, m);\n             }\n         }\n     });\n \n-    hash.result()\n+    state.result()\n }\n \n impl Variance {"}]}