{"sha": "4eac052a33f38688d582d3bb5242728f543a3c8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYWMwNTJhMzNmMzg2ODhkNTgyZDNiYjUyNDI3MjhmNTQzYTNjOGY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-25T15:32:44Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-28T00:56:46Z"}, "message": "rustc: move object default lifetimes to resolve_lifetimes.", "tree": {"sha": "bea0b6bee70c55860a0b569053dfdddf5e8fa72e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bea0b6bee70c55860a0b569053dfdddf5e8fa72e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eac052a33f38688d582d3bb5242728f543a3c8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eac052a33f38688d582d3bb5242728f543a3c8f", "html_url": "https://github.com/rust-lang/rust/commit/4eac052a33f38688d582d3bb5242728f543a3c8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eac052a33f38688d582d3bb5242728f543a3c8f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "html_url": "https://github.com/rust-lang/rust/commit/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1"}], "stats": {"total": 904, "additions": 445, "deletions": 459}, "files": [{"sha": "d11e6e3fc72bd415c31910243845b9a6bccae566", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -28,6 +28,7 @@ use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n use middle::lang_items;\n+use middle::resolve_lifetime::ObjectLifetimeDefault;\n use ty::{self, Ty, TyCtxt};\n use mir::Mir;\n use session::Session;\n@@ -183,6 +184,8 @@ pub trait CrateStore<'tcx> {\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx>;\n     fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize);\n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n@@ -334,6 +337,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                          -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize)\n         { bug!(\"item_generics_own_param_counts\") }\n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault>\n+        { bug!(\"item_generics_object_lifetime_defaults\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n         { bug!(\"trait_def\") }"}, {"sha": "88ef2c69a04dce975ab907a9ee7b1a1e97bee033", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 322, "deletions": 21, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -26,11 +26,12 @@ use ty;\n use std::cell::Cell;\n use std::mem::replace;\n use syntax::ast;\n+use syntax::attr;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n-use util::nodemap::{NodeMap, FxHashSet, FxHashMap};\n+use util::nodemap::{NodeMap, FxHashSet, FxHashMap, DefIdMap};\n use rustc_back::slice;\n \n use hir;\n@@ -102,8 +103,46 @@ impl Region {\n             _ => self\n         }\n     }\n+\n+    fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap)\n+             -> Option<Region> {\n+        if let Region::EarlyBound(index, _) = self {\n+            params.get(index as usize).and_then(|lifetime| {\n+                map.defs.get(&lifetime.id).cloned()\n+            })\n+        } else {\n+            Some(self)\n+        }\n+    }\n }\n \n+/// A set containing, at most, one known element.\n+/// If two distinct values are inserted into a set, then it\n+/// becomes `Many`, which can be used to detect ambiguities.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+pub enum Set1<T> {\n+    Empty,\n+    One(T),\n+    Many\n+}\n+\n+impl<T: PartialEq> Set1<T> {\n+    pub fn insert(&mut self, value: T) {\n+        if let Set1::Empty = *self {\n+            *self = Set1::One(value);\n+            return;\n+        }\n+        if let Set1::One(ref old) = *self {\n+            if *old == value {\n+                return;\n+            }\n+        }\n+        *self = Set1::Many;\n+    }\n+}\n+\n+pub type ObjectLifetimeDefault = Set1<Region>;\n+\n // Maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to.\n pub struct NamedRegionMap {\n@@ -115,6 +154,10 @@ pub struct NamedRegionMap {\n     // are named regions appearing in fn arguments that do not appear\n     // in where-clauses\n     pub late_bound: NodeMap<ty::Issue32330>,\n+\n+    // For each type and trait definition, maps type parameters\n+    // to the trait object lifetime defaults computed from them.\n+    pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n }\n \n struct LifetimeContext<'a, 'tcx: 'a> {\n@@ -141,6 +184,9 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n \n     // List of labels in the function/method currently under analysis.\n     labels_in_fn: Vec<(ast::Name, Span)>,\n+\n+    // Cache for cross-crate per-definition object lifetime defaults.\n+    xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n }\n \n #[derive(Debug)]\n@@ -170,6 +216,14 @@ enum Scope<'a> {\n         s: ScopeRef<'a>\n     },\n \n+    /// Use a specific lifetime (if `Some`) or leave it unset (to be\n+    /// inferred in a function body or potentially error outside one),\n+    /// for the default choice of lifetime in a trait object type.\n+    ObjectLifetimeDefault {\n+        lifetime: Option<Region>,\n+        s: ScopeRef<'a>\n+    },\n+\n     Root\n }\n \n@@ -208,6 +262,7 @@ pub fn krate(sess: &Session,\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),\n         late_bound: NodeMap(),\n+        object_lifetime_defaults: compute_object_lifetime_defaults(sess, hir_map),\n     };\n     sess.track_errors(|| {\n         let mut visitor = LifetimeContext {\n@@ -217,6 +272,7 @@ pub fn krate(sess: &Session,\n             scope: ROOT_SCOPE,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n+            xcrate_object_lifetime_defaults: DefIdMap(),\n         };\n         for (_, item) in &krate.items {\n             visitor.visit_item(item);\n@@ -326,10 +382,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n-                if !lifetime.is_elided() {\n+                if lifetime.is_elided() {\n+                    self.resolve_object_lifetime_default(lifetime)\n+                } else {\n                     self.visit_lifetime(lifetime);\n                 }\n             }\n+            hir::TyRptr(ref lifetime_ref, ref mt) => {\n+                self.visit_lifetime(lifetime_ref);\n+                let scope = Scope::ObjectLifetimeDefault {\n+                    lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n+                    s: self.scope\n+                };\n+                self.with(scope, |_, this| this.visit_ty(&mt.ty));\n+            }\n             _ => {\n                 intravisit::walk_ty(self, ty)\n             }\n@@ -372,20 +438,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n-    fn visit_path_parameters(&mut self, _: Span, params: &'tcx hir::PathParameters) {\n-        match *params {\n-            hir::AngleBracketedParameters(ref data) => {\n-                if data.lifetimes.iter().all(|l| l.is_elided()) {\n-                    self.resolve_elided_lifetimes(&data.lifetimes);\n-                } else {\n-                    for l in &data.lifetimes { self.visit_lifetime(l); }\n-                }\n-                for ty in &data.types { self.visit_ty(ty); }\n-                for b in &data.bindings { self.visit_assoc_type_binding(b); }\n-            }\n-            hir::ParenthesizedParameters(ref data) => {\n-                self.visit_fn_like_elision(&data.inputs, data.output.as_ref());\n-            }\n+    fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            let depth = path.segments.len() - i - 1;\n+            self.visit_segment_parameters(path.def, depth, &segment.parameters);\n         }\n     }\n \n@@ -466,7 +522,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for lifetime in &trait_ref.bound_lifetimes {\n                     this.visit_lifetime_def(lifetime);\n                 }\n-                intravisit::walk_path(this, &trait_ref.trait_ref.path)\n+                this.visit_trait_ref(&trait_ref.trait_ref)\n             })\n         } else {\n             self.visit_trait_ref(&trait_ref.trait_ref)\n@@ -585,7 +641,8 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n         loop {\n             match *scope {\n                 Scope::Body { s, .. } |\n-                Scope::Elision { s, .. } => { scope = s; }\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => { scope = s; }\n \n                 Scope::Root => { return; }\n \n@@ -606,6 +663,103 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n     }\n }\n \n+fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n+                                    -> NodeMap<Vec<ObjectLifetimeDefault>> {\n+    let mut map = NodeMap();\n+    for item in hir_map.krate().items.values() {\n+        match item.node {\n+            hir::ItemStruct(_, ref generics) |\n+            hir::ItemUnion(_, ref generics) |\n+            hir::ItemEnum(_, ref generics) |\n+            hir::ItemTy(_, ref generics) |\n+            hir::ItemTrait(_, ref generics, ..) => {\n+                let result = object_lifetime_defaults_for_item(hir_map, generics);\n+\n+                // Debugging aid.\n+                if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n+                    let object_lifetime_default_reprs: String =\n+                        result.iter().map(|set| {\n+                            match *set {\n+                                Set1::Empty => \"BaseDefault\".to_string(),\n+                                Set1::One(Region::Static) => \"'static\".to_string(),\n+                                Set1::One(Region::EarlyBound(i, _)) => {\n+                                    generics.lifetimes[i as usize].lifetime.name.to_string()\n+                                }\n+                                Set1::One(_) => bug!(),\n+                                Set1::Many => \"Ambiguous\".to_string(),\n+                            }\n+                        }).collect::<Vec<String>>().join(\",\");\n+                    sess.span_err(item.span, &object_lifetime_default_reprs);\n+                }\n+\n+                map.insert(item.id, result);\n+            }\n+            _ => {}\n+        }\n+    }\n+    map\n+}\n+\n+/// Scan the bounds and where-clauses on parameters to extract bounds\n+/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n+/// for each type parameter.\n+fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n+                                     -> Vec<ObjectLifetimeDefault> {\n+    fn add_bounds(set: &mut Set1<ast::Name>, bounds: &[hir::TyParamBound]) {\n+        for bound in bounds {\n+            if let hir::RegionTyParamBound(ref lifetime) = *bound {\n+                set.insert(lifetime.name);\n+            }\n+        }\n+    }\n+\n+    generics.ty_params.iter().map(|param| {\n+        let mut set = Set1::Empty;\n+\n+        add_bounds(&mut set, &param.bounds);\n+\n+        let param_def_id = hir_map.local_def_id(param.id);\n+        for predicate in &generics.where_clause.predicates {\n+            // Look for `type: ...` where clauses.\n+            let data = match *predicate {\n+                hir::WherePredicate::BoundPredicate(ref data) => data,\n+                _ => continue\n+            };\n+\n+            // Ignore `for<'a> type: ...` as they can change what\n+            // lifetimes mean (although we could \"just\" handle it).\n+            if !data.bound_lifetimes.is_empty() {\n+                continue;\n+            }\n+\n+            let def = match data.bounded_ty.node {\n+                hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                _ => continue\n+            };\n+\n+            if def == Def::TyParam(param_def_id) {\n+                add_bounds(&mut set, &data.bounds);\n+            }\n+        }\n+\n+        match set {\n+            Set1::Empty => Set1::Empty,\n+            Set1::One(name) => {\n+                if name == keywords::StaticLifetime.name() {\n+                    Set1::One(Region::Static)\n+                } else {\n+                    generics.lifetimes.iter().enumerate().find(|&(_, def)| {\n+                        def.lifetime.name == name\n+                    }).map_or(Set1::Many, |(i, def)| {\n+                        Set1::One(Region::EarlyBound(i as u32, def.lifetime.id))\n+                    })\n+                }\n+            }\n+            Set1::Many => Set1::Many\n+        }\n+    }).collect()\n+}\n+\n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     // FIXME(#37666) this works around a limitation in the region inferencer\n     fn hack<F>(&mut self, f: F) where\n@@ -619,18 +773,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     {\n         let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n         let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n+        let xcrate_object_lifetime_defaults =\n+            replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap());\n         let mut this = LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: *map,\n             scope: &wrap_scope,\n             trait_ref_hack: self.trait_ref_hack,\n             labels_in_fn: labels_in_fn,\n+            xcrate_object_lifetime_defaults: xcrate_object_lifetime_defaults,\n         };\n         debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);\n         debug!(\"exiting scope {:?}\", this.scope);\n         self.labels_in_fn = this.labels_in_fn;\n+        self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -727,7 +885,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n \n-                Scope::Elision { s, .. } => {\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -763,6 +922,109 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_segment_parameters(&mut self,\n+                                def: Def,\n+                                depth: usize,\n+                                params: &'tcx hir::PathParameters) {\n+        let data = match *params {\n+            hir::ParenthesizedParameters(ref data) => {\n+                self.visit_fn_like_elision(&data.inputs, data.output.as_ref());\n+                return;\n+            }\n+            hir::AngleBracketedParameters(ref data) => data\n+        };\n+\n+        if data.lifetimes.iter().all(|l| l.is_elided()) {\n+            self.resolve_elided_lifetimes(&data.lifetimes);\n+        } else {\n+            for l in &data.lifetimes { self.visit_lifetime(l); }\n+        }\n+\n+        // Figure out if this is a type/trait segment,\n+        // which requires object lifetime defaults.\n+        let parent_def_id = |this: &mut Self, def_id: DefId| {\n+            let def_key = if def_id.is_local() {\n+                this.hir_map.def_key(def_id)\n+            } else {\n+                this.sess.cstore.def_key(def_id)\n+            };\n+            DefId {\n+                krate: def_id.krate,\n+                index: def_key.parent.expect(\"missing parent\")\n+            }\n+        };\n+        let type_def_id = match def {\n+            Def::AssociatedTy(def_id) if depth == 1 => {\n+                Some(parent_def_id(self, def_id))\n+            }\n+            Def::Variant(def_id) if depth == 0 => {\n+                Some(parent_def_id(self, def_id))\n+            }\n+            Def::Struct(def_id) |\n+            Def::Union(def_id) |\n+            Def::Enum(def_id) |\n+            Def::TyAlias(def_id) |\n+            Def::Trait(def_id) if depth == 0 => Some(def_id),\n+            _ => None\n+        };\n+\n+        let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n+            let in_body = {\n+                let mut scope = self.scope;\n+                loop {\n+                    match *scope {\n+                        Scope::Root => break false,\n+\n+                        Scope::Body { .. } => break true,\n+\n+                        Scope::Binder { s, .. } |\n+                        Scope::Elision { s, .. } |\n+                        Scope::ObjectLifetimeDefault { s, .. } => {\n+                            scope = s;\n+                        }\n+                    }\n+                }\n+            };\n+\n+            let map = &self.map;\n+            let unsubst = if let Some(id) = self.hir_map.as_local_node_id(def_id) {\n+                &map.object_lifetime_defaults[&id]\n+            } else {\n+                let cstore = &self.sess.cstore;\n+                self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n+                    cstore.item_generics_object_lifetime_defaults(def_id)\n+                })\n+            };\n+            unsubst.iter().map(|set| {\n+                match *set {\n+                    Set1::Empty => {\n+                        if in_body {\n+                            None\n+                        } else {\n+                            Some(Region::Static)\n+                        }\n+                    }\n+                    Set1::One(r) => r.subst(&data.lifetimes, map),\n+                    Set1::Many => None\n+                }\n+            }).collect()\n+        });\n+\n+        for (i, ty) in data.types.iter().enumerate() {\n+            if let Some(&lt) = object_lifetime_defaults.get(i) {\n+                let scope = Scope::ObjectLifetimeDefault {\n+                    lifetime: lt,\n+                    s: self.scope\n+                };\n+                self.with(scope, |_, this| this.visit_ty(ty));\n+            } else {\n+                self.visit_ty(ty);\n+            }\n+        }\n+\n+        for b in &data.bindings { self.visit_assoc_type_binding(b); }\n+    }\n+\n     fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],\n                              output: Option<&'tcx P<hir::Ty>>) {\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n@@ -962,7 +1224,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 if let hir::TyBareFn(_) = ty.node {\n                     self.binder_depth += 1;\n                 }\n-                intravisit::walk_ty(self, ty);\n+                if let hir::TyTraitObject(ref bounds, ref lifetime) = ty.node {\n+                    for bound in bounds {\n+                        self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                    }\n+\n+                    // Stay on the safe side and don't include the object\n+                    // lifetime default (which may not end up being used).\n+                    if !lifetime.is_elided() {\n+                        self.visit_lifetime(lifetime);\n+                    }\n+                } else {\n+                    intravisit::walk_ty(self, ty);\n+                }\n                 if let hir::TyBareFn(_) = ty.node {\n                     self.binder_depth -= 1;\n                 }\n@@ -1045,6 +1319,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                     return;\n                 }\n+\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n             }\n         };\n \n@@ -1134,6 +1412,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn resolve_object_lifetime_default(&mut self, lifetime_ref: &hir::Lifetime) {\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let lifetime = loop {\n+            match *scope {\n+                Scope::Binder { s, .. } => {\n+                    late_depth += 1;\n+                    scope = s;\n+                }\n+\n+                Scope::Root |\n+                Scope::Elision { .. } => break Region::Static,\n+\n+                Scope::Body { .. } |\n+                Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n+\n+                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l\n+            }\n+        };\n+        self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n+    }\n+\n     fn check_lifetime_defs(&mut self, old_scope: ScopeRef, lifetimes: &[hir::LifetimeDef]) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n@@ -1192,7 +1492,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         loop {\n             match *old_scope {\n                 Scope::Body { s, .. } |\n-                Scope::Elision { s, .. } => {\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n                     old_scope = s;\n                 }\n "}, {"sha": "6ea083b314fef07a4b07a63b0ab20e80870d978f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -592,32 +592,13 @@ pub enum IntVarValue {\n     UintType(ast::UintTy),\n }\n \n-/// Default region to use for the bound of objects that are\n-/// supplied as the value for this type parameter. This is derived\n-/// from `T:'a` annotations appearing in the type definition.  If\n-/// this is `None`, then the default is inherited from the\n-/// surrounding context. See RFC #599 for details.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum ObjectLifetimeDefault<'tcx> {\n-    /// Require an explicit annotation. Occurs when multiple\n-    /// `T:'a` constraints are found.\n-    Ambiguous,\n-\n-    /// Use the base default, typically 'static, but in a fn body it is a fresh variable\n-    BaseDefault,\n-\n-    /// Use the given region as the default.\n-    Specific(&'tcx Region),\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n-    pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n     /// on generic parameter `T`, asserts data behind the parameter"}, {"sha": "56f5dbc735de4357a02cbae4917109de1beb5587", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -726,36 +726,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             index: self.index,\n             default: self.default.fold_with(folder),\n             default_def_id: self.default_def_id,\n-            object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n             pure_wrt_drop: self.pure_wrt_drop,\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.default.visit_with(visitor) ||\n-            self.object_lifetime_default.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Ambiguous =>\n-                ty::ObjectLifetimeDefault::Ambiguous,\n-\n-            ty::ObjectLifetimeDefault::BaseDefault =>\n-                ty::ObjectLifetimeDefault::BaseDefault,\n-\n-            ty::ObjectLifetimeDefault::Specific(r) =>\n-                ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Specific(r) => r.visit_with(visitor),\n-            _ => false,\n-        }\n+        self.default.visit_with(visitor)\n     }\n }\n "}, {"sha": "0522ea90522c1fce3177dcdec390f7e645c3f2fd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -523,16 +523,6 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n-            ty::ObjectLifetimeDefault::BaseDefault => write!(f, \"BaseDefault\"),\n-            ty::ObjectLifetimeDefault::Specific(ref r) => write!(f, \"{:?}\", r),\n-        }\n-    }\n-}\n-\n impl fmt::Display for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {"}, {"sha": "39581a46960887069faecd871888335f49a89c95", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind, ExternC\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -115,6 +116,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).generics_own_param_counts(def.index)\n     }\n \n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).generics_object_lifetime_defaults(def.index)\n+    }\n+\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));"}, {"sha": "dd44ef202dc2733bcf7185dae4a2dd968c7f4dd2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -20,6 +20,7 @@ use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -614,6 +615,12 @@ impl<'a, 'tcx> CrateMetadata {\n         (g.regions.len, g.types.len)\n     }\n \n+    pub fn generics_object_lifetime_defaults(&self, item_id: DefIndex)\n+                                             -> Vec<ObjectLifetimeDefault> {\n+        self.entry(item_id).generics.unwrap().decode(self)\n+                           .object_lifetime_defaults.decode(self).collect()\n+    }\n+\n     pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         self.entry(id).ty.unwrap().decode((self, tcx))\n     }"}, {"sha": "028555d1df848c9e2346f8532674a806d1f3f716", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -422,13 +422,20 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let g = tcx.item_generics(def_id);\n         let regions = self.lazy_seq_ref(&g.regions);\n         let types = self.lazy_seq_ref(&g.types);\n+        let mut object_lifetime_defaults = LazySeq::empty();\n+        if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+            if let Some(o) = tcx.named_region_map.object_lifetime_defaults.get(&id) {\n+                object_lifetime_defaults = self.lazy_seq_ref(o);\n+            }\n+        }\n         self.lazy(&Generics {\n             parent: g.parent,\n             parent_regions: g.parent_regions,\n             parent_types: g.parent_types,\n             regions: regions,\n             types: types,\n             has_self: g.has_self,\n+            object_lifetime_defaults: object_lifetime_defaults,\n         })\n     }\n "}, {"sha": "91375d42823fb8027f839b10cdca59ec05d6e91e", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -16,6 +16,7 @@ use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc_back::PanicStrategy;\n@@ -258,6 +259,7 @@ pub struct Generics<'tcx> {\n     pub regions: LazySeq<ty::RegionParameterDef<'tcx>>,\n     pub types: LazySeq<ty::TypeParameterDef<'tcx>>,\n     pub has_self: bool,\n+    pub object_lifetime_defaults: LazySeq<ObjectLifetimeDefault>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "56de539cbfe99d5031073e362277b49a68e650a8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 45, "deletions": 130, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -10,7 +10,7 @@\n \n //! Conversion from AST representation of types to the ty.rs\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n-//! is parameterized by an instance of `AstConv` and a `RegionScope`.\n+//! is parameterized by an instance of `AstConv`.\n //!\n //! The parameterization of `ast_ty_to_ty()` is because it behaves\n //! somewhat differently during the collect and check phases,\n@@ -22,31 +22,6 @@\n //! an error).  In the check phase, when the FnCtxt is used as the\n //! `AstConv`, `get_item_type()` just looks up the item type in\n //! `tcx.types` (using `TyCtxt::item_type`).\n-//!\n-//! The `RegionScope` trait controls what happens when the user does\n-//! not specify a region in some location where a region is required\n-//! (e.g., if the user writes `&Foo` as a type rather than `&'a Foo`).\n-//! See the `rscope` module for more details.\n-//!\n-//! Unlike the `AstConv` trait, the region scope can change as we descend\n-//! the type.  This is to accommodate the fact that (a) fn types are binding\n-//! scopes and (b) the default region may change.  To understand case (a),\n-//! consider something like:\n-//!\n-//!   type foo = { x: &a.int, y: |&a.int| }\n-//!\n-//! The type of `x` is an error because there is no region `a` in scope.\n-//! In the type of `y`, however, region `a` is considered a bound region\n-//! as it does not already appear in scope.\n-//!\n-//! Case (b) says that if you have a type:\n-//!   type foo<'a> = ...;\n-//!   type bar = fn(&foo, &a.foo)\n-//! The fully expanded version of type bar is:\n-//!   type bar = fn(&'foo &, &a.foo<'a>)\n-//! Note that the self region for the `foo` defaulted to `&` in the first\n-//! case but `&a` in the second.  Basically, defaults that appear inside\n-//! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n use rustc_const_eval::eval_length;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -61,8 +36,6 @@ use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n-use rscope::{RegionScope, ObjectLifetimeDefaultRscope, ShiftedRscope};\n-use rscope::ExplicitRscope;\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FxHashSet};\n \n@@ -110,7 +83,7 @@ pub trait AstConv<'gcx, 'tcx> {\n \n     /// What lifetime should we use when a lifetime is omitted (and not elided)?\n     fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n-                -> &'tcx ty::Region;\n+                -> Option<&'tcx ty::Region>;\n \n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n@@ -220,7 +193,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     // (*) -- not late-bound, won't change\n             }\n \n-            None => self.re_infer(lifetime.span, def)\n+            None => {\n+                self.re_infer(lifetime.span, def).expect(\"unelided lifetime in signature\")\n+            }\n         };\n \n         debug!(\"ast_region_to_region(lifetime={:?}) yields {:?}\",\n@@ -233,7 +208,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n     /// returns an appropriate set of substitutions for this particular reference to `I`.\n     pub fn ast_path_substs_for_ty(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         def_id: DefId,\n         item_segment: &hir::PathSegment)\n@@ -258,8 +232,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_path(rscope,\n-                                            span,\n+            self.create_substs_for_ast_path(span,\n                                             def_id,\n                                             &item_segment.parameters,\n                                             None);\n@@ -275,7 +248,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     ///\n     /// Note that the type listing given here is *exactly* what the user provided.\n     fn create_substs_for_ast_path(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         def_id: DefId,\n         parameters: &hir::PathParameters,\n@@ -357,11 +329,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // A provided type parameter.\n                 match *parameters {\n                     hir::AngleBracketedParameters(ref data) => {\n-                        self.ast_ty_arg_to_ty(rscope, Some(def), substs, &data.types[i])\n+                        self.ast_ty_to_ty(&data.types[i])\n                     }\n                     hir::ParenthesizedParameters(ref data) => {\n                         assert_eq!(i, 0);\n-                        let (ty, assoc) = self.convert_parenthesized_parameters(substs, data);\n+                        let (ty, assoc) = self.convert_parenthesized_parameters(data);\n                         output_assoc_binding = Some(assoc);\n                         ty\n                     }\n@@ -406,7 +378,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 data.bindings.iter().map(|b| {\n                     ConvertedBinding {\n                         item_name: b.name,\n-                        ty: self.ast_ty_to_ty(rscope, &b.ty),\n+                        ty: self.ast_ty_to_ty(&b.ty),\n                         span: b.span\n                     }\n                 }).collect()\n@@ -415,7 +387,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 vec![output_assoc_binding.unwrap_or_else(|| {\n                     // This is an error condition, but we should\n                     // get the associated type binding anyway.\n-                    self.convert_parenthesized_parameters(substs, data).1\n+                    self.convert_parenthesized_parameters(data).1\n                 })]\n             }\n         };\n@@ -427,17 +399,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn convert_parenthesized_parameters(&self,\n-                                        region_substs: &[Kind<'tcx>],\n                                         data: &hir::ParenthesizedParameterData)\n                                         -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n         let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n-            self.ast_ty_arg_to_ty(&ExplicitRscope, None, region_substs, a_t)\n+            self.ast_ty_to_ty(a_t)\n         }));\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n-                (self.ast_ty_to_ty(&ExplicitRscope, output_ty), output_ty.span)\n+                (self.ast_ty_to_ty(output_ty), output_ty.span)\n             }\n             None => {\n                 (self.tcx().mk_nil(), data.span)\n@@ -460,14 +431,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n     /// are disallowed. Otherwise, they are pushed onto the vector given.\n     pub fn instantiate_mono_trait_ref(&self,\n-        rscope: &RegionScope,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>\n     {\n         let trait_def_id = self.trait_def_id(trait_ref);\n-        self.ast_path_to_mono_trait_ref(rscope,\n-                                        trait_ref.path.span,\n+        self.ast_path_to_mono_trait_ref(trait_ref.path.span,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_ref.path.segments.last().unwrap())\n@@ -488,7 +457,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     pub fn instantiate_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n         ast_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n@@ -498,16 +466,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def_id = self.trait_def_id(trait_ref);\n \n         debug!(\"ast_path_to_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n-        // The trait reference introduces a binding level here, so\n-        // we need to shift the `rscope`. It'd be nice if we could\n-        // do away with this rscope stuff and work this knowledge\n-        // into resolve_lifetimes, as we do with non-omitted\n-        // lifetimes. Oh well, not there yet.\n-        let shifted_rscope = &ShiftedRscope::new(rscope);\n \n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_trait_ref(shifted_rscope,\n-                                                 trait_ref.path.span,\n+            self.create_substs_for_ast_trait_ref(trait_ref.path.span,\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_ref.path.segments.last().unwrap());\n@@ -528,16 +489,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn ast_path_to_mono_trait_ref(&self,\n-                                  rscope: &RegionScope,\n                                   span: Span,\n                                   trait_def_id: DefId,\n                                   self_ty: Ty<'tcx>,\n                                   trait_segment: &hir::PathSegment)\n                                   -> ty::TraitRef<'tcx>\n     {\n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_trait_ref(rscope,\n-                                                 span,\n+            self.create_substs_for_ast_trait_ref(span,\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n@@ -546,7 +505,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn create_substs_for_ast_trait_ref(&self,\n-                                       rscope: &RegionScope,\n                                        span: Span,\n                                        trait_def_id: DefId,\n                                        self_ty: Ty<'tcx>,\n@@ -590,8 +548,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         }\n \n-        self.create_substs_for_ast_path(rscope,\n-                                        span,\n+        self.create_substs_for_ast_path(span,\n                                         trait_def_id,\n                                         &trait_segment.parameters,\n                                         Some(self_ty))\n@@ -700,7 +657,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn ast_path_to_ty(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         did: DefId,\n         item_segment: &hir::PathSegment)\n@@ -714,8 +670,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n-        let substs = self.ast_path_substs_for_ty(rscope,\n-                                                 span,\n+        let substs = self.ast_path_substs_for_ty(span,\n                                                  did,\n                                                  item_segment);\n \n@@ -737,7 +692,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn conv_object_ty_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         trait_bounds: &[hir::PolyTraitRef],\n         lifetime: &hir::Lifetime)\n@@ -753,8 +707,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let mut projection_bounds = vec![];\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n-        let principal = self.instantiate_poly_trait_ref(rscope,\n-                                                        &trait_bounds[0],\n+        let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n                                                         dummy_self,\n                                                         &mut projection_bounds);\n \n@@ -839,15 +792,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n             self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n-                tcx.mk_region(match rscope.object_lifetime_default(span) {\n-                    Some(r) => r,\n-                    None => {\n-                        span_err!(self.tcx().sess, span, E0228,\n+                if tcx.named_region_map.defs.contains_key(&lifetime.id) {\n+                    self.ast_region_to_region(lifetime, None)\n+                } else {\n+                    self.re_infer(span, None).unwrap_or_else(|| {\n+                        span_err!(tcx.sess, span, E0228,\n                                   \"the lifetime bound for this object type cannot be deduced \\\n                                    from context; please supply an explicit bound\");\n-                        ty::ReStatic\n-                    }\n-                })\n+                        tcx.mk_region(ty::ReStatic)\n+                    })\n+                }\n             })\n         };\n \n@@ -1059,7 +1013,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn qpath_to_ty(&self,\n-                   rscope: &RegionScope,\n                    span: Span,\n                    opt_self_ty: Option<Ty<'tcx>>,\n                    trait_def_id: DefId,\n@@ -1084,8 +1037,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n-        let trait_ref = self.ast_path_to_mono_trait_ref(rscope,\n-                                                        span,\n+        let trait_ref = self.ast_path_to_mono_trait_ref(span,\n                                                         trait_def_id,\n                                                         self_ty,\n                                                         trait_segment);\n@@ -1095,38 +1047,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self.projected_ty(span, trait_ref, item_segment.name)\n     }\n \n-    /// Convert a type supplied as value for a type argument from AST into our\n-    /// our internal representation. This is the same as `ast_ty_to_ty` but that\n-    /// it applies the object lifetime default.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// * `this`, `rscope`: the surrounding context\n-    /// * `def`: the type parameter being instantiated (if available)\n-    /// * `region_substs`: a partial substitution consisting of\n-    ///   only the region type parameters being supplied to this type.\n-    /// * `ast_ty`: the ast representation of the type being supplied\n-    fn ast_ty_arg_to_ty(&self,\n-                        rscope: &RegionScope,\n-                        def: Option<&ty::TypeParameterDef<'tcx>>,\n-                        region_substs: &[Kind<'tcx>],\n-                        ast_ty: &hir::Ty)\n-                        -> Ty<'tcx>\n-    {\n-        let tcx = self.tcx();\n-\n-        if let Some(def) = def {\n-            let object_lifetime_default = def.object_lifetime_default.subst(tcx, region_substs);\n-            let rscope1 = &ObjectLifetimeDefaultRscope::new(rscope, object_lifetime_default);\n-            self.ast_ty_to_ty(rscope1, ast_ty)\n-        } else {\n-            self.ast_ty_to_ty(rscope, ast_ty)\n-        }\n-    }\n-\n     // Check a type Path and convert it to a Ty.\n     pub fn def_to_ty(&self,\n-                     rscope: &RegionScope,\n                      opt_self_ty: Option<Ty<'tcx>>,\n                      path: &hir::Path,\n                      permit_variants: bool)\n@@ -1141,15 +1063,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope, span, did, path.segments.last().unwrap())\n+                self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope,\n-                                    span,\n+                self.ast_path_to_ty(span,\n                                     tcx.parent_def_id(did).unwrap(),\n                                     path.segments.last().unwrap())\n             }\n@@ -1207,8 +1128,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::AssociatedTy(def_id) => {\n                 tcx.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n-                self.qpath_to_ty(rscope,\n-                                 span,\n+                self.qpath_to_ty(span,\n                                  opt_self_ty,\n                                  trait_did,\n                                  &path.segments[path.segments.len()-2],\n@@ -1228,7 +1148,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n-    pub fn ast_ty_to_ty(&self, rscope: &RegionScope, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?})\",\n                ast_ty.id, ast_ty);\n \n@@ -1241,29 +1161,25 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let result_ty = match ast_ty.node {\n             hir::TySlice(ref ty) => {\n-                tcx.mk_slice(self.ast_ty_to_ty(rscope, &ty))\n+                tcx.mk_slice(self.ast_ty_to_ty(&ty))\n             }\n             hir::TyPtr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut {\n-                    ty: self.ast_ty_to_ty(rscope, &mt.ty),\n+                    ty: self.ast_ty_to_ty(&mt.ty),\n                     mutbl: mt.mutbl\n                 })\n             }\n             hir::TyRptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(\"TyRef r={:?}\", r);\n-                let rscope1 =\n-                    &ObjectLifetimeDefaultRscope::new(\n-                        rscope,\n-                        ty::ObjectLifetimeDefault::Specific(r));\n-                let t = self.ast_ty_to_ty(rscope1, &mt.ty);\n+                let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n             hir::TyNever => {\n                 tcx.types.never\n             },\n             hir::TyTup(ref fields) => {\n-                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(rscope, &t)))\n+                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)))\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n@@ -1309,7 +1225,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_fn_ptr(bare_fn_ty)\n             }\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n-                self.conv_object_ty_poly_trait_ref(rscope, ast_ty.span, bounds, lifetime)\n+                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 use collect::{compute_bounds, SizedByDefault};\n@@ -1381,13 +1297,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                    self.ast_ty_to_ty(rscope, qself)\n+                    self.ast_ty_to_ty(qself)\n                 });\n-                self.def_to_ty(rscope, opt_self_ty, path, false)\n+                self.def_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n-                let ty = self.ast_ty_to_ty(rscope, qself);\n+                let ty = self.ast_ty_to_ty(qself);\n \n                 let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n@@ -1398,7 +1314,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyArray(ref ty, length) => {\n                 if let Ok(length) = eval_length(tcx.global_tcx(), length, \"array length\") {\n-                    tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n+                    tcx.mk_array(self.ast_ty_to_ty(&ty), length)\n                 } else {\n                     self.tcx().types.err\n                 }\n@@ -1426,15 +1342,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     pub fn ty_of_arg(&self,\n-                     rscope: &RegionScope,\n                      ty: &hir::Ty,\n                      expected_ty: Option<Ty<'tcx>>)\n                      -> Ty<'tcx>\n     {\n         match ty.node {\n             hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n             hir::TyInfer => self.ty_infer(ty.span),\n-            _ => self.ast_ty_to_ty(rscope, ty),\n+            _ => self.ast_ty_to_ty(ty),\n         }\n     }\n \n@@ -1446,10 +1361,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"ty_of_fn\");\n \n         let input_tys: Vec<Ty> =\n-            decl.inputs.iter().map(|a| self.ty_of_arg(&ExplicitRscope, a, None)).collect();\n+            decl.inputs.iter().map(|a| self.ty_of_arg(a, None)).collect();\n \n         let output_ty = match decl.output {\n-            hir::Return(ref output) => self.ast_ty_to_ty(&ExplicitRscope, output),\n+            hir::Return(ref output) => self.ast_ty_to_ty(output),\n             hir::DefaultReturn(..) => self.tcx().mk_nil(),\n         };\n \n@@ -1486,7 +1401,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     None\n                 }\n             });\n-            self.ty_of_arg(&ExplicitRscope, a, expected_arg_ty)\n+            self.ty_of_arg(a, expected_arg_ty)\n         });\n \n         let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n@@ -1502,7 +1417,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 expected_ret_ty.unwrap(),\n             _ if is_infer => self.ty_infer(decl.output.span()),\n             hir::Return(ref output) =>\n-                self.ast_ty_to_ty(&ExplicitRscope, &output),\n+                self.ast_ty_to_ty(&output),\n             hir::DefaultReturn(..) => bug!(),\n         };\n "}, {"sha": "c2f32c2b52bbebbefbc1e452f855dffa67f0a118", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -97,7 +97,6 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n-use rscope::RegionScope;\n use session::{Session, CompileResult};\n use CrateCtxt;\n use TypeAndSubsts;\n@@ -1411,12 +1410,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n-                -> &'tcx ty::Region {\n+                -> Option<&'tcx ty::Region> {\n         let v = match def {\n             Some(def) => infer::EarlyBoundRegion(span, def.name),\n             None => infer::MiscVariable(span)\n         };\n-        self.next_region_var(v)\n+        Some(self.next_region_var(v))\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n@@ -1459,23 +1458,6 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        // RFC #599 specifies that object lifetime defaults take\n-        // precedence over other defaults. But within a fn body we\n-        // don't have a *default* region, rather we use inference to\n-        // find the *correct* region, which is strictly more general\n-        // (and anyway, within a fn body the right region may not even\n-        // be something the user can write explicitly, since it might\n-        // be some expression).\n-        *self.next_region_var(infer::MiscVariable(span))\n-    }\n-}\n-\n /// Controls whether the arguments are tupled. This is used for the call\n /// operator.\n ///\n@@ -1832,7 +1814,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n-        let t = AstConv::ast_ty_to_ty(self, self, ast_t);\n+        let t = AstConv::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n         t\n     }\n@@ -3976,7 +3958,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match *qpath {\n             hir::QPath::Resolved(ref maybe_qself, ref path) => {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let ty = AstConv::def_to_ty(self, self, opt_self_ty, path, true);\n+                let ty = AstConv::def_to_ty(self, opt_self_ty, path, true);\n                 (path.def, ty)\n             }\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -4411,7 +4393,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let Some(lifetime) = lifetimes.get(i) {\n                 AstConv::ast_region_to_region(self, lifetime, Some(def))\n             } else {\n-                self.re_infer(span, Some(def))\n+                self.re_infer(span, Some(def)).unwrap()\n             }\n         }, |def, substs| {\n             let mut i = def.index as usize;"}, {"sha": "6f0825a25f94779400c95655861c281ee21b34f5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 117, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -68,10 +68,9 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n-use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n-use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeMap, FxHashMap};\n use CrateCtxt;\n \n use rustc_const_math::ConstInt;\n@@ -373,8 +372,8 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n }\n \n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &hir::Ty) -> Ty<'tcx> {\n-        AstConv::ast_ty_to_ty(self, rs, ast_ty)\n+    fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+        AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n \n@@ -437,9 +436,9 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         None\n     }\n \n-    fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n-                -> &'tcx ty::Region {\n-        span_bug!(span, \"unelided lifetime in signature\");\n+    fn re_infer(&self, _span: Span, _def: Option<&ty::RegionParameterDef>)\n+                -> Option<&'tcx ty::Region> {\n+        None\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n@@ -631,7 +630,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            field: &hir::StructField,\n                            ty_f: &'tcx ty::FieldDef)\n {\n-    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n+    let tt = ccx.icx(struct_predicates).to_ty(&field.ty);\n     ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n \n     let def_id = ccx.tcx.hir.local_def_id(field.id);\n@@ -757,7 +756,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         hir::ItemDefaultImpl(_, ref ast_trait_ref) => {\n             let trait_ref =\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&()),\n-                                                    &ExplicitRscope,\n                                                     ast_trait_ref,\n                                                     tcx.mk_self_type());\n \n@@ -779,12 +777,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n-            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n+            let selfty = ccx.icx(&ty_predicates).to_ty(&selfty);\n             tcx.item_types.borrow_mut().insert(def_id, selfty);\n \n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n-                                                    &ExplicitRscope,\n                                                     ast_trait_ref,\n                                                     selfty)\n             });\n@@ -850,8 +847,7 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n         hir::TraitItemKind::Const(ref ty, _) => {\n             let const_def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n             generics_of_def_id(ccx, const_def_id);\n-            let ty = ccx.icx(&trait_predicates)\n-                        .to_ty(&ExplicitRscope, &ty);\n+            let ty = ccx.icx(&trait_predicates).to_ty(&ty);\n             tcx.item_types.borrow_mut().insert(const_def_id, ty);\n             convert_associated_const(ccx, TraitContainer(trait_def_id),\n                                      trait_item.id, ty);\n@@ -862,7 +858,7 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n             generics_of_def_id(ccx, type_def_id);\n \n             let typ = opt_ty.as_ref().map({\n-                |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n+                |ty| ccx.icx(&trait_predicates).to_ty(&ty)\n             });\n \n             convert_associated_type(ccx, TraitContainer(trait_def_id), trait_item.id, typ);\n@@ -887,8 +883,7 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n         hir::ImplItemKind::Const(ref ty, _) => {\n             let const_def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n             generics_of_def_id(ccx, const_def_id);\n-            let ty = ccx.icx(&impl_predicates)\n-                        .to_ty(&ExplicitRscope, &ty);\n+            let ty = ccx.icx(&impl_predicates).to_ty(&ty);\n             tcx.item_types.borrow_mut().insert(const_def_id, ty);\n             convert_associated_const(ccx, ImplContainer(impl_def_id),\n                                      impl_item.id, ty);\n@@ -903,7 +898,7 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n                           \"associated types are not allowed in inherent impls\");\n             }\n \n-            let typ = ccx.icx(&impl_predicates).to_ty(&ExplicitRscope, ty);\n+            let typ = ccx.icx(&impl_predicates).to_ty(ty);\n \n             convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n         }\n@@ -1410,7 +1405,6 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             def_id: tcx.hir.local_def_id(param_id),\n                             default_def_id: tcx.hir.local_def_id(parent),\n                             default: None,\n-                            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n                             pure_wrt_drop: false,\n                         };\n                         tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n@@ -1463,7 +1457,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let type_start = own_start + regions.len() as u32;\n         let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n             let i = type_start + i as u32;\n-            get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n+            get_or_create_type_parameter_def(ccx, i, p, allow_defaults)\n         });\n         let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n \n@@ -1478,24 +1472,11 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     def_id: def_id,\n                     default_def_id: parent_def_id.unwrap(),\n                     default: None,\n-                    object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n                     pure_wrt_drop: false,\n                }));\n             });\n         }\n \n-        // Debugging aid.\n-        if tcx.has_attr(def_id, \"rustc_object_lifetime_default\") {\n-            let object_lifetime_default_reprs: String =\n-                types.iter().map(|t| {\n-                    match t.object_lifetime_default {\n-                        ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n-                        d => format!(\"{:?}\", d),\n-                    }\n-                }).collect::<Vec<String>>().join(\",\");\n-            tcx.sess.span_err(tcx.hir.span(node_id), &object_lifetime_default_reprs);\n-        }\n-\n         tcx.alloc_generics(ty::Generics {\n             parent: parent_def_id,\n             parent_regions: parent_regions,\n@@ -1526,15 +1507,15 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeItem(item) => {\n                 match item.node {\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&ExplicitRscope, &t)\n+                        ccx.icx(&()).to_ty(&t)\n                     }\n                     ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n                         let tofd = AstConv::ty_of_fn(&ccx.icx(generics), unsafety, abi, &decl);\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n                         ccx.tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n                     ItemTy(ref t, ref generics) => {\n-                        ccx.icx(generics).to_ty(&ExplicitRscope, &t)\n+                        ccx.icx(generics).to_ty(&t)\n                     }\n                     ItemEnum(ref ei, ref generics) => {\n                         let def = convert_enum_def(ccx, item, ei);\n@@ -1575,7 +1556,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             fn_decl, generics, abi)\n                     }\n                     ForeignItemStatic(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&ExplicitRscope, t)\n+                        ccx.icx(&()).to_ty(t)\n                     }\n                 }\n             }\n@@ -1771,7 +1752,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         match predicate {\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = AstConv::ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n-                                               &ExplicitRscope,\n                                                &bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n@@ -1782,7 +1762,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             let trait_ref =\n                                 AstConv::instantiate_poly_trait_ref(&ccx.icx(&(base_predicates,\n                                                                                ast_generics)),\n-                                                                    &ExplicitRscope,\n                                                                     poly_trait_ref,\n                                                                     ty,\n                                                                     &mut projections);\n@@ -1827,7 +1806,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                             ast_generics: &hir::Generics,\n                                              index: u32,\n                                              param: &hir::TyParam,\n                                              allow_defaults: bool)\n@@ -1840,11 +1818,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let default =\n-        param.default.as_ref().map(|def| ccx.icx(&()).to_ty(&ExplicitRscope, def));\n-\n-    let object_lifetime_default =\n-        compute_object_lifetime_default(ccx, param.id,\n-                                        &param.bounds, &ast_generics.where_clause);\n+        param.default.as_ref().map(|def| ccx.icx(&()).to_ty(def));\n \n     let parent = tcx.hir.get_parent(param.id);\n \n@@ -1865,7 +1839,6 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         def_id: ccx.tcx.hir.local_def_id(param.id),\n         default_def_id: ccx.tcx.hir.local_def_id(parent),\n         default: default,\n-        object_lifetime_default: object_lifetime_default,\n         pure_wrt_drop: param.pure_wrt_drop,\n     };\n \n@@ -1880,75 +1853,6 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     def\n }\n \n-/// Scan the bounds and where-clauses on a parameter to extract bounds\n-/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`.\n-/// This runs as part of computing the minimal type scheme, so we\n-/// intentionally avoid just asking astconv to convert all the where\n-/// clauses into a `ty::Predicate`. This is because that could induce\n-/// artificial cycles.\n-fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                            param_id: ast::NodeId,\n-                                            param_bounds: &[hir::TyParamBound],\n-                                            where_clause: &hir::WhereClause)\n-                                            -> ty::ObjectLifetimeDefault<'tcx>\n-{\n-    let inline_bounds = from_bounds(ccx, param_bounds);\n-    let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n-    let all_bounds: FxHashSet<_> = inline_bounds.into_iter()\n-                                                .chain(where_bounds)\n-                                                .collect();\n-    return if all_bounds.len() > 1 {\n-        ty::ObjectLifetimeDefault::Ambiguous\n-    } else if all_bounds.len() == 0 {\n-        ty::ObjectLifetimeDefault::BaseDefault\n-    } else {\n-        ty::ObjectLifetimeDefault::Specific(\n-            all_bounds.into_iter().next().unwrap())\n-    };\n-\n-    fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                            bounds: &[hir::TyParamBound])\n-                            -> Vec<&'tcx ty::Region>\n-    {\n-        bounds.iter()\n-              .filter_map(|bound| {\n-                  match *bound {\n-                      hir::TraitTyParamBound(..) =>\n-                          None,\n-                      hir::RegionTyParamBound(ref lifetime) =>\n-                          Some(AstConv::ast_region_to_region(&ccx.icx(&()), lifetime, None)),\n-                  }\n-              })\n-              .collect()\n-    }\n-\n-    fn from_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                param_id: ast::NodeId,\n-                                predicates: &[hir::WherePredicate])\n-                                -> Vec<&'tcx ty::Region>\n-    {\n-        predicates.iter()\n-                  .flat_map(|predicate| {\n-                      match *predicate {\n-                          hir::WherePredicate::BoundPredicate(ref data) => {\n-                              if data.bound_lifetimes.is_empty() &&\n-                                  is_param(ccx.tcx, &data.bounded_ty, param_id)\n-                              {\n-                                  from_bounds(ccx, &data.bounds).into_iter()\n-                              } else {\n-                                  Vec::new().into_iter()\n-                              }\n-                          }\n-                          hir::WherePredicate::RegionPredicate(..) |\n-                          hir::WherePredicate::EqPredicate(..) => {\n-                              Vec::new().into_iter()\n-                          }\n-                      }\n-                  })\n-                  .collect()\n-    }\n-}\n-\n pub enum SizedByDefault { Yes, No, }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n@@ -1978,8 +1882,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     let mut projection_bounds = vec![];\n \n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        astconv.instantiate_poly_trait_ref(&ExplicitRscope,\n-                                           bound,\n+        astconv.instantiate_poly_trait_ref(bound,\n                                            param_ty,\n                                            &mut projection_bounds)\n     }).collect();\n@@ -2017,8 +1920,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     match *bound {\n         hir::TraitTyParamBound(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n-            let pred = astconv.instantiate_poly_trait_ref(&ExplicitRscope,\n-                                                          tr,\n+            let pred = astconv.instantiate_poly_trait_ref(tr,\n                                                           param_ty,\n                                                           &mut projections);\n             projections.into_iter()"}, {"sha": "4ed116b88f6d942622476e27fc0cbbf66c51cba1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -127,7 +127,6 @@ pub mod diagnostics;\n \n pub mod check;\n pub mod check_unused;\n-mod rscope;\n mod astconv;\n pub mod collect;\n mod constrained_type_params;"}, {"sha": "d982c91e388d18ade4cbd92288f49cb80457d942", "filename": "src/librustc_typeck/rscope.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -1,113 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::ty;\n-\n-use syntax_pos::Span;\n-\n-/// Defines strategies for handling regions that are omitted.  For\n-/// example, if one writes the type `&Foo`, then the lifetime of\n-/// this reference has been omitted. When converting this\n-/// type, the generic functions in astconv will invoke `anon_region`\n-/// on the provided region-scope to decide how to translate this\n-/// omitted region.\n-///\n-/// It is not always legal to omit regions, therefore `anon_region`\n-/// can return `Err(())` to indicate that this is not a scope in which\n-/// regions can legally be omitted.\n-pub trait RegionScope {\n-    /// If an object omits any explicit lifetime bound, and none can\n-    /// be derived from the object traits, what should we use? If\n-    /// `None` is returned, an explicit annotation is required.\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region>;\n-\n-    /// The \"base\" default is the initial default for a scope. This is\n-    /// 'static except for in fn bodies, where it is a fresh inference\n-    /// variable. You shouldn't call this except for as part of\n-    /// computing `object_lifetime_default` (in particular, in legacy\n-    /// modes, it may not be relevant).\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region;\n-}\n-\n-// A scope in which all regions must be explicitly named. This is used\n-// for types that appear in structs and so on.\n-#[derive(Copy, Clone)]\n-pub struct ExplicitRscope;\n-\n-impl RegionScope for ExplicitRscope {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-/// A scope which overrides the default object lifetime but has no other effect.\n-pub struct ObjectLifetimeDefaultRscope<'r> {\n-    base_scope: &'r (RegionScope+'r),\n-    default: ty::ObjectLifetimeDefault<'r>,\n-}\n-\n-impl<'r> ObjectLifetimeDefaultRscope<'r> {\n-    pub fn new(base_scope: &'r (RegionScope+'r),\n-               default: ty::ObjectLifetimeDefault<'r>)\n-               -> ObjectLifetimeDefaultRscope<'r>\n-    {\n-        ObjectLifetimeDefaultRscope {\n-            base_scope: base_scope,\n-            default: default,\n-        }\n-    }\n-}\n-\n-impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        match self.default {\n-            ty::ObjectLifetimeDefault::Ambiguous =>\n-                None,\n-\n-            ty::ObjectLifetimeDefault::BaseDefault =>\n-                // NB: This behavior changed in Rust 1.3.\n-                Some(self.base_object_lifetime_default(span)),\n-\n-            ty::ObjectLifetimeDefault::Specific(r) =>\n-                Some(*r),\n-        }\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        self.base_scope.base_object_lifetime_default(span)\n-    }\n-}\n-\n-/// A scope which simply shifts the Debruijn index of other scopes\n-/// to account for binding levels.\n-pub struct ShiftedRscope<'r> {\n-    base_scope: &'r (RegionScope+'r)\n-}\n-\n-impl<'r> ShiftedRscope<'r> {\n-    pub fn new(base_scope: &'r (RegionScope+'r)) -> ShiftedRscope<'r> {\n-        ShiftedRscope { base_scope: base_scope }\n-    }\n-}\n-\n-impl<'r> RegionScope for ShiftedRscope<'r> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        self.base_scope.object_lifetime_default(span)\n-            .map(|r| ty::fold::shift_region(r, 1))\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        ty::fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n-    }\n-}"}, {"sha": "6aaf892097136b20af5c1c2ba690f0fd718c44ed", "filename": "src/test/run-pass/object-lifetime-default-from-ref-struct.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -15,6 +15,8 @@\n \n #![allow(dead_code)]\n \n+use std::fmt::Display;\n+\n trait Test {\n     fn foo(&self) { }\n }\n@@ -23,6 +25,11 @@ struct Ref<'a,T:'a+?Sized> {\n     r: &'a T\n }\n \n+struct Ref2<'a,'b,T:'a+'b+?Sized> {\n+    a: &'a T,\n+    b: &'b T\n+}\n+\n struct SomeStruct<'a> {\n     t: Ref<'a,Test>,\n     u: Ref<'a,Test+'a>,\n@@ -44,6 +51,17 @@ fn d<'a>(t: Ref<'a,Test+'a>, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n+fn e<'a>(_: Ref<'a, Display+'static>) {}\n+fn g<'a, 'b>(_: Ref2<'a, 'b, Display+'static>) {}\n+\n \n fn main() {\n+    // Inside a function body, we can just infer all\n+    // lifetimes, to allow Ref<'tmp, Display+'static>\n+    // and Ref2<'tmp, 'tmp, Display+'static>.\n+    let x = &0 as &(Display+'static);\n+    let r: Ref<Display> = Ref { r: x };\n+    let r2: Ref2<Display> = Ref2 { a: x, b: x };\n+    e(r);\n+    g(r2);\n }"}, {"sha": "cbff0d4dbaa3cae02eaee650cdc9e5640ac34675", "filename": "src/test/run-pass/object-lifetime-default-from-rptr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eac052a33f38688d582d3bb5242728f543a3c8f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs?ref=4eac052a33f38688d582d3bb5242728f543a3c8f", "patch": "@@ -15,6 +15,8 @@\n \n #![allow(dead_code)]\n \n+use std::fmt::Display;\n+\n trait Test {\n     fn foo(&self) { }\n }\n@@ -40,6 +42,10 @@ fn d<'a>(t: &'a (Test+'a), mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n+fn e<'a>(_: &'a (Display+'static)) {}\n \n fn main() {\n+    // Inside a function body, we can just infer both\n+    // lifetimes, to allow &'tmp (Display+'static).\n+    e(&0 as &Display);\n }"}]}