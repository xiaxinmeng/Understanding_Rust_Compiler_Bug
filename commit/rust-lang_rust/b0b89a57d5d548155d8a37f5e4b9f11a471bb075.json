{"sha": "b0b89a57d5d548155d8a37f5e4b9f11a471bb075", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYjg5YTU3ZDVkNTQ4MTU1ZDhhMzdmNWU0YjlmMTFhNDcxYmIwNzU=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-02-06T07:56:27Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-02-07T07:44:26Z"}, "message": "Add new function str::from_utf8_lossy()\n\nfrom_utf8_lossy() takes a byte vector and produces a ~str, converting\nany invalid UTF-8 sequence into the U+FFFD REPLACEMENT CHARACTER.\n\nThe replacement follows the guidelines in \u00a75.22 Best Practice for U+FFFD\nSubstitution from the Unicode Standard (Version 6.2)[1], which also\nmatches the WHATWG rules for utf-8 decoding[2].\n\n[1]: http://www.unicode.org/versions/Unicode6.2.0/ch05.pdf\n[2]: http://encoding.spec.whatwg.org/#utf-8", "tree": {"sha": "a7bdfd1e6990756d80ca79da11ae6bc07db89299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7bdfd1e6990756d80ca79da11ae6bc07db89299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0b89a57d5d548155d8a37f5e4b9f11a471bb075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b89a57d5d548155d8a37f5e4b9f11a471bb075", "html_url": "https://github.com/rust-lang/rust/commit/b0b89a57d5d548155d8a37f5e4b9f11a471bb075", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0b89a57d5d548155d8a37f5e4b9f11a471bb075/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6aad3bf944da209d1852c51144ba584de400a10c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6aad3bf944da209d1852c51144ba584de400a10c", "html_url": "https://github.com/rust-lang/rust/commit/6aad3bf944da209d1852c51144ba584de400a10c"}], "stats": {"total": 185, "additions": 179, "deletions": 6}, "files": [{"sha": "25e15fc16018e7c7e6dda796415e3e5280be3305", "filename": "src/libstd/str.rs", "status": "modified", "additions": 179, "deletions": 6, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/b0b89a57d5d548155d8a37f5e4b9f11a471bb075/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b89a57d5d548155d8a37f5e4b9f11a471bb075/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=b0b89a57d5d548155d8a37f5e4b9f11a471bb075", "patch": "@@ -900,16 +900,122 @@ pub struct CharRange {\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n macro_rules! utf8_first_byte(\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as uint)\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n )\n \n // return the value of $ch updated with continuation byte $byte\n macro_rules! utf8_acc_cont_byte(\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n )\n \n static TAG_CONT_U8: u8 = 128u8;\n \n+/// Converts a vector of bytes to a new utf-8 string.\n+/// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let input = bytes!(\"Hello \", 0xF0, 0x90, 0x80, \"World\");\n+/// let output = std::str::from_utf8_lossy(input);\n+/// assert_eq!(output, ~\"Hello \\uFFFDWorld\");\n+/// ```\n+pub fn from_utf8_lossy(v: &[u8]) -> ~str {\n+    static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n+    let mut i = 0u;\n+    let mut lastgood = 0u;\n+    let total = v.len();\n+    fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n+        unsafe { *xs.unsafe_ref(i) }\n+    }\n+    fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n+        if i >= total {\n+            0\n+        } else {\n+            unsafe_get(xs, i)\n+        }\n+    }\n+    let mut res = with_capacity(total);\n+\n+    while i < total {\n+        let i_ = i;\n+        let byte = unsafe_get(v, i);\n+        i += 1;\n+\n+        macro_rules! error(() => {\n+            unsafe {\n+                if lastgood != i_ {\n+                    raw::push_bytes(&mut res, v.slice(lastgood, i_));\n+                }\n+                lastgood = i;\n+                raw::push_bytes(&mut res, REPLACEMENT);\n+            }\n+        })\n+\n+        if byte < 128u8 {\n+            // lastgood handles this\n+        } else {\n+            let w = utf8_char_width(byte);\n+\n+            match w {\n+                2 => {\n+                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                        error!();\n+                        continue;\n+                    }\n+                    i += 1;\n+                }\n+                3 => {\n+                    match (byte, safe_get(v, i, total)) {\n+                        (0xE0        , 0xA0 .. 0xBF) => (),\n+                        (0xE1 .. 0xEC, 0x80 .. 0xBF) => (),\n+                        (0xED        , 0x80 .. 0x9F) => (),\n+                        (0xEE .. 0xEF, 0x80 .. 0xBF) => (),\n+                        _ => {\n+                            error!();\n+                            continue;\n+                        }\n+                    }\n+                    i += 1;\n+                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                        error!();\n+                        continue;\n+                    }\n+                    i += 1;\n+                }\n+                4 => {\n+                    match (byte, safe_get(v, i, total)) {\n+                        (0xF0        , 0x90 .. 0xBF) => (),\n+                        (0xF1 .. 0xF3, 0x80 .. 0xBF) => (),\n+                        (0xF4        , 0x80 .. 0x8F) => (),\n+                        _ => {\n+                            error!();\n+                            continue;\n+                        }\n+                    }\n+                    i += 1;\n+                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                        error!();\n+                        continue;\n+                    }\n+                    i += 1;\n+                    if safe_get(v, i, total) & 192u8 != TAG_CONT_U8 {\n+                        error!();\n+                        continue;\n+                    }\n+                    i += 1;\n+                }\n+                _ => {\n+                    error!();\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+    unsafe { raw::push_bytes(&mut res, v.slice(lastgood, total)) };\n+    res\n+}\n+\n /// Unsafe operations\n pub mod raw {\n     use cast;\n@@ -2211,7 +2317,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n         // Multibyte case is a fn to allow char_range_at to inline cleanly\n         fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n-            let mut val = s[i] as uint;\n+            let mut val = s[i] as u32;\n             let w = UTF8_CHAR_WIDTH[val] as uint;\n             assert!((w != 0));\n \n@@ -2220,7 +2326,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-            return CharRange {ch: unsafe { transmute(val as u32) }, next: i + w};\n+            return CharRange {ch: unsafe { transmute(val) }, next: i + w};\n         }\n \n         return multibyte_char_range_at(*self, i);\n@@ -2243,7 +2349,7 @@ impl<'a> StrSlice<'a> for &'a str {\n                 i -= 1u;\n             }\n \n-            let mut val = s[i] as uint;\n+            let mut val = s[i] as u32;\n             let w = UTF8_CHAR_WIDTH[val] as uint;\n             assert!((w != 0));\n \n@@ -2252,7 +2358,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-            return CharRange {ch: unsafe { transmute(val as u32) }, next: i};\n+            return CharRange {ch: unsafe { transmute(val) }, next: i};\n         }\n \n         return multibyte_char_range_at_reverse(*self, prev);\n@@ -3834,6 +3940,37 @@ mod tests {\n         assert_eq!(from_utf8_owned(xs), None);\n     }\n \n+    #[test]\n+    fn test_str_from_utf8_lossy() {\n+        let xs = bytes!(\"hello\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"hello\");\n+\n+        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+\n+        let xs = bytes!(\"Hello\", 0xC2, \" There\", 0xFF, \" Goodbye\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"Hello\\uFFFD There\\uFFFD Goodbye\");\n+\n+        let xs = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\");\n+\n+        let xs = bytes!(0xF5, \"foo\", 0xF5, 0x80, \"bar\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFD\\uFFFDbar\");\n+\n+        let xs = bytes!(0xF1, \"foo\", 0xF1, 0x80, \"bar\", 0xF1, 0x80, 0x80, \"baz\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\");\n+\n+        let xs = bytes!(0xF4, \"foo\", 0xF4, 0x80, \"bar\", 0xF4, 0xBF, \"baz\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\");\n+\n+        let xs = bytes!(0xF0, 0x80, 0x80, 0x80, \"foo\", 0xF0, 0x90, 0x80, 0x80, \"bar\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFD\\uFFFD\\uFFFD\\uFFFDfoo\\U00010000bar\");\n+\n+        // surrogates\n+        let xs = bytes!(0xED, 0xA0, 0x80, \"foo\", 0xED, 0xBF, 0xBF, \"bar\");\n+        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFD\\uFFFD\\uFFFDfoo\\uFFFD\\uFFFD\\uFFFDbar\");\n+    }\n+\n     #[test]\n     fn test_to_send_str() {\n         assert_eq!(\"abcde\".to_send_str(), SendStrStatic(\"abcde\"));\n@@ -3992,6 +4129,42 @@ mod bench {\n         });\n     }\n \n+    #[bench]\n+    fn from_utf8_lossy_100_ascii(bh: &mut BenchHarness) {\n+        let s = bytes!(\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                        Lorem ipsum dolor sit amet, consectetur. \");\n+\n+        assert_eq!(100, s.len());\n+        bh.iter(|| {\n+            let _ = from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_multibyte(bh: &mut BenchHarness) {\n+        let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n+        assert_eq!(100, s.len());\n+        bh.iter(|| {\n+            let _ = from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_invalid(bh: &mut BenchHarness) {\n+        let s = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n+        bh.iter(|| {\n+            let _ = from_utf8_lossy(s);\n+        });\n+    }\n+\n+    #[bench]\n+    fn from_utf8_lossy_100_invalid(bh: &mut BenchHarness) {\n+        let s = ::vec::from_elem(100, 0xF5u8);\n+        bh.iter(|| {\n+            let _ = from_utf8_lossy(s);\n+        });\n+    }\n+\n     #[bench]\n     fn bench_with_capacity(bh: &mut BenchHarness) {\n         bh.iter(|| {"}]}