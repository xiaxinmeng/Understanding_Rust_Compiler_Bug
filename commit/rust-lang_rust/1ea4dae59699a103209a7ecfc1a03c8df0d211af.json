{"sha": "1ea4dae59699a103209a7ecfc1a03c8df0d211af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYTRkYWU1OTY5OWExMDMyMDlhN2VjZmMxYTAzYzhkZjBkMjExYWY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-04T19:40:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-04T19:41:46Z"}, "message": "Document expansion queries", "tree": {"sha": "83e7822f41dd04db2f5e79d75f88a9c838beceee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83e7822f41dd04db2f5e79d75f88a9c838beceee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ea4dae59699a103209a7ecfc1a03c8df0d211af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea4dae59699a103209a7ecfc1a03c8df0d211af", "html_url": "https://github.com/rust-lang/rust/commit/1ea4dae59699a103209a7ecfc1a03c8df0d211af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ea4dae59699a103209a7ecfc1a03c8df0d211af/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f6980e4e146163de85ff780432f6f0c7b7645e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f6980e4e146163de85ff780432f6f0c7b7645e7", "html_url": "https://github.com/rust-lang/rust/commit/3f6980e4e146163de85ff780432f6f0c7b7645e7"}], "stats": {"total": 21, "additions": 21, "deletions": 0}, "files": [{"sha": "3e9abd8a1955477752f98e6d42bbc7e89e61ec5f", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4dae59699a103209a7ecfc1a03c8df0d211af/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4dae59699a103209a7ecfc1a03c8df0d211af/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=1ea4dae59699a103209a7ecfc1a03c8df0d211af", "patch": "@@ -87,24 +87,45 @@ impl TokenExpander {\n pub trait AstDatabase: SourceDatabase {\n     fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n+    /// Main public API -- parsis a hir file, not caring whether it's a real\n+    /// file or a macro expansion.\n     #[salsa::transparent]\n     fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n+    /// Implementation for the macro case.\n     fn parse_macro_expansion(\n         &self,\n         macro_file: MacroFile,\n     ) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>>;\n \n+    /// Macro ids. That's probably the tricksiest bit in rust-analyzer, and the\n+    /// reason why we use salsa at all.\n+    ///\n+    /// We encode macro definitions into ids of macro calls, this what allows us\n+    /// to be incremental.\n     #[salsa::interned]\n     fn intern_macro(&self, macro_call: MacroCallLoc) -> LazyMacroId;\n+    /// Certain built-in macros are eager (`format!(concat!(\"file: \", file!(), \"{}\"\")), 92`).\n+    /// For them, we actually want to encode the whole token tree as an argument.\n     #[salsa::interned]\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n \n+    /// Lowers syntactic macro call to a token tree representation.\n     #[salsa::transparent]\n     fn macro_arg(&self, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>>;\n+    /// Extracts syntax node, corresponding to a macro call. That's a firewall\n+    /// query, only typing in the macro call itself changes the returned\n+    /// subtree.\n     fn macro_arg_text(&self, id: MacroCallId) -> Option<GreenNode>;\n+    /// Gets the expander for this macro. This compiles declarative macros, and\n+    /// just fetches procedural ones.\n     fn macro_def(&self, id: MacroDefId) -> Option<Arc<TokenExpander>>;\n \n+    /// Expand macro call to a token tree. This query is LRUed (we keep 128 or so results in memory)\n     fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>>;\n+    /// Special case of the previous query for procedural macros. We can't LRU\n+    /// proc macros, since they are not deterministic in general, and\n+    /// non-determinism breaks salsa in a very, very, very bad way. @edwin0cheng\n+    /// heroically debugged this once!\n     fn expand_proc_macro(&self, call: MacroCallId) -> Result<tt::Subtree, mbe::ExpandError>;\n     /// Firewall query that returns the error from the `macro_expand` query.\n     fn macro_expand_error(&self, macro_call: MacroCallId) -> Option<ExpandError>;"}]}