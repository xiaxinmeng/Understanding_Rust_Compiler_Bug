{"sha": "40624e35d74e5d200ae689c02753f0d60924e668", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNjI0ZTM1ZDc0ZTVkMjAwYWU2ODljMDI3NTNmMGQ2MDkyNGU2Njg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-01T20:18:52Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-01T20:20:25Z"}, "message": "Start splitting up Makefile.in", "tree": {"sha": "e1e259098d5c49cd49844b40abd46ec35219d94a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1e259098d5c49cd49844b40abd46ec35219d94a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40624e35d74e5d200ae689c02753f0d60924e668", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40624e35d74e5d200ae689c02753f0d60924e668", "html_url": "https://github.com/rust-lang/rust/commit/40624e35d74e5d200ae689c02753f0d60924e668", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40624e35d74e5d200ae689c02753f0d60924e668/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d88776726ac5ee7d7c3d7e9ae57d323d768f7967", "url": "https://api.github.com/repos/rust-lang/rust/commits/d88776726ac5ee7d7c3d7e9ae57d323d768f7967", "html_url": "https://github.com/rust-lang/rust/commit/d88776726ac5ee7d7c3d7e9ae57d323d768f7967"}], "stats": {"total": 2095, "additions": 1062, "deletions": 1033}, "files": [{"sha": "2caeafe00e9f394603084316b554c324dd3bf571", "filename": "Makefile.in", "status": "modified", "additions": 18, "deletions": 1033, "changes": 1051, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -3,17 +3,16 @@\n ######################################################################\n \n include config.mk\n-MKFILES := Makefile config.mk\n+MKFILES := Makefile config.mk $(wildcard $(CFG_SRC_DIR)/mk/*.mk)\n \n ifneq ($(MAKE_RESTARTS),)\n CFG_INFO := $(info cfg: make restarts: $(MAKE_RESTARTS))\n endif\n \n CFG_INFO := $(info cfg: building on $(CFG_OSTYPE) $(CFG_CPUTYPE))\n \n-CFG_GCC_CFLAGS := -fno-strict-aliasing\n-CFG_GCC_LINK_FLAGS :=\n CFG_BOOT_FLAGS := $(BOOT_FLAGS)\n+\n ifdef CFG_DISABLE_OPTIMIZE\n   $(info cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE))\n   CFG_RUSTC_FLAGS :=\n@@ -31,176 +30,20 @@ ifdef NO_TYPESTATE\n   CFG_RUSTC_FLAGS += --no-typestate\n endif\n \n-# On Darwin, we need to run dsymutil so the debugging information ends\n-# up in the right place.  On other platforms, it automatically gets\n-# embedded into the executable, so use a no-op command.\n-CFG_DSYMUTIL := true\n-\n-ifeq ($(CFG_OSTYPE), FreeBSD)\n-  CFG_LIB_NAME=lib$(1).so\n-  CFG_GCC_CFLAGS += -fPIC -march=i686 -I/usr/local/include -O2\n-  CFG_GCC_LINK_FLAGS += -shared -fPIC -lpthread -lrt\n-  ifeq ($(CFG_CPUTYPE), x86_64)\n-    CFG_GCC_CFLAGS += -m32\n-    CFG_GCC_LINK_FLAGS += -m32\n-  endif\n-  CFG_UNIXY := 1\n-  CFG_LDENV := LD_LIBRARY_PATH\n-  CFG_DEF_SUFFIX := .bsd.def\n-endif\n-\n-ifeq ($(CFG_OSTYPE), Linux)\n-  CFG_LIB_NAME=lib$(1).so\n-  CFG_GCC_CFLAGS += -fPIC -march=i686 -O2\n-  CFG_GCC_LINK_FLAGS += -shared -fPIC -ldl -lpthread -lrt\n-  CFG_GCC_DEF_FLAG := -Wl,--export-dynamic,--dynamic-list=\n-  CFG_GCC_PRE_LIB_FLAGS := -Wl,-whole-archive\n-  CFG_GCC_POST_LIB_FLAGS := -Wl,-no-whole-archive\n-  ifeq ($(CFG_CPUTYPE), x86_64)\n-    CFG_GCC_CFLAGS += -m32\n-    CFG_GCC_LINK_FLAGS += -m32\n-  endif\n-  CFG_UNIXY := 1\n-  CFG_LDENV := LD_LIBRARY_PATH\n-  CFG_DEF_SUFFIX := .linux.def\n-endif\n-\n-ifeq ($(CFG_OSTYPE), Darwin)\n-  CFG_LIB_NAME=lib$(1).dylib\n-  CFG_UNIXY := 1\n-  CFG_LDENV := DYLD_LIBRARY_PATH\n-  CFG_GCC_LINK_FLAGS += -dynamiclib -lpthread\n-  CFG_GCC_DEF_FLAG := -Wl,-exported_symbols_list,\n-  # Darwin has a very blurry notion of \"64 bit\", and claims it's running\n-  # \"on an i386\" when the whole userspace is 64-bit and the compiler\n-  # emits 64-bit binaries by default. So we just force -m32 here. Smarter\n-  # approaches welcome!\n-  #\n-  # NB: Currently GCC's optimizer breaks rustrt (task-comm-1 hangs) on Darwin.\n-  CFG_GCC_CFLAGS += -m32 -O0\n-  CFG_GCC_LINK_FLAGS += -m32\n-  CFG_DSYMUTIL := dsymutil\n-  CFG_DEF_SUFFIX := .darwin.def\n-endif\n-\n-ifneq ($(findstring MINGW,$(CFG_OSTYPE)),)\n-  CFG_WINDOWSY := 1\n-endif\n-\n-CFG_LDPATH :=$(CFG_BUILD_DIR)/rt\n-CFG_LDPATH :=$(CFG_LDPATH):$(CFG_BUILD_DIR)/rustllvm\n-CFG_TESTLIB=$(CFG_BUILD_DIR)/$(strip     \\\n- $(if $(findstring stage0,$(1)),         \\\n-       stage1                            \\\n-      $(if $(findstring stage1,$(1)),    \\\n-           stage2                        \\\n-          $(if $(findstring stage2,$(1)),\\\n-               stage3                    \\\n-               ))))\n-\n-ifdef CFG_WINDOWSY\n-  CFG_INFO := $(info cfg: windows-y environment)\n-\n-  CFG_EXE_SUFFIX := .exe\n-  CFG_LIB_NAME=$(1).dll\n-  CFG_LDPATH :=$(CFG_LDPATH):$(CFG_LLVM_BINDIR)\n-  CFG_LDPATH :=$(CFG_LDPATH):$$PATH\n-  CFG_RUN_TEST=PATH=\"$(CFG_LDPATH):$(call CFG_TESTLIB,$(1))\" $(1)\n-  CFG_RUN_TARG=PATH=\"$(CFG_BUILD_DIR)/$(1):$(CFG_LDPATH)\" $(2)\n-\n-  CFG_PATH_MUNGE := $(strip perl -i.bak -p             \\\n-                           -e 's@\\\\(\\S)@/\\1@go;'       \\\n-                           -e 's@^/([a-zA-Z])/@\\1:/@o;')\n-  ifdef CFG_FLEXLINK\n-    CFG_BOOT_NATIVE := 1\n-  endif\n-  CFG_GCC_CFLAGS += -march=i686 -O2\n-  CFG_GCC_LINK_FLAGS += -shared -fPIC\n-  CFG_DEF_SUFFIX := .def\n-endif\n-\n-ifdef CFG_UNIXY\n-  CFG_INFO := $(info cfg: unix-y environment)\n-\n-  CFG_PATH_MUNGE := true\n-  CFG_EXE_SUFFIX :=\n-  CFG_LDPATH :=$(CFG_LDPATH):$(CFG_LLVM_LIBDIR)\n-  CFG_RUN_TARG=$(CFG_LDENV)=$(CFG_BUILD_DIR)/$(1):$(CFG_LDPATH) $(2)\n-  CFG_RUN_TEST=\\\n-      $(CFG_LDENV)=$(call CFG_TESTLIB,$(1)):$(CFG_LDPATH) \\\n-      $(CFG_VALGRIND) $(1)\n-\n-  CFG_BOOT_NATIVE := 1\n-\n-  ifdef MINGW_CROSS\n-    CFG_EXE_SUFFIX := .exe\n-    CFG_LIB_NAME=$(1).dll\n-    CFG_LDPATH :=$(CFG_LDPATH):$(CFG_LLVM_BINDIR)\n-    CFG_LDPATH :=$(CFG_LDPATH):$$PATH\n-    CFG_RUN_TARG=PATH=$(CFG_BUILD_DIR)/$(1):$(CFG_LDPATH) $(2)\n-    CFG_RUN_TEST=PATH=$(CFG_LDPATH):$(call CFG_TESTLIB,$(1)) $(1)\n-\n-    CFG_INFO := $(info cfg: mingw-cross)\n-    CFG_GCC_CROSS := i586-mingw32msvc-\n-    CFG_BOOT_FLAGS += -t win32-x86-pe\n-    ifdef CFG_VALGRIND\n-      CFG_VALGRIND += wine\n-    endif\n-    CFG_GCC_CFLAGS := -march=i686\n-    CFG_GCC_LINK_FLAGS := -shared\n-    ifeq ($(CFG_CPUTYPE), x86_64)\n-      CFG_GCC_CFLAGS += -m32\n-      CFG_GCC_LINK_FLAGS += -m32\n-    endif\n-  endif\n-  ifdef CFG_VALGRIND\n-    CFG_VALGRIND += --leak-check=full \\\n-                    --error-exitcode=1 \\\n-                    --quiet --vex-iropt-level=0 \\\n-                    --suppressions=$(CFG_SRC_DIR)src/etc/x86.supp\n-  endif\n-endif\n+# platform-specific auto-configuration\n+include $(CFG_SRC_DIR)/mk/platform.mk\n \n CFG_RUNTIME :=$(call CFG_LIB_NAME,rustrt)\n CFG_RUSTLLVM :=$(call CFG_LIB_NAME,rustllvm)\n CFG_STDLIB :=$(call CFG_LIB_NAME,std)\n \n-ifdef CFG_GCC\n-  CFG_INFO := $(info cfg: using gcc)\n-  CFG_GCC_CFLAGS += -Wall -Werror -fno-rtti -fno-exceptions -g\n-  CFG_GCC_LINK_FLAGS += -g\n-  CFG_COMPILE_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_CFLAGS) -c -o $(1) $(2)\n-  CFG_DEPEND_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_CFLAGS) -MT \"$(1)\" -MM $(2)\n-  CFG_LINK_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_LINK_FLAGS) -o $(1) \\\n-               $(CFG_GCC_DEF_FLAG)$(3) $(2)\n-else\n-  CFG_ERR := $(error please try on a system with gcc)\n-endif\n-\n ifdef CFG_OCAMLC_OPT\n   $(info cfg: have ocaml native compiler)\n   OPT=.opt\n else\n   $(info cfg: have only ocaml bytecode compiler)\n endif\n \n-ifdef CFG_BOOT_PROFILE\n-  $(info cfg: forcing native bootstrap compiler (CFG_BOOT_PROFILE))\n-  CFG_BOOT_NATIVE := 1\n-  CFG_OCAMLOPT_PROFILE_FLAGS := -p\n-endif\n-\n-ifdef CFG_BOOT_DEBUG\n-  $(info cfg: forcing bytecode bootstrap compiler (CFG_BOOT_DEBUG))\n-  CFG_BOOT_NATIVE :=\n-endif\n-\n-ifdef CFG_BOOT_NATIVE\n-  $(info cfg: building native bootstrap compiler)\n-else\n-  $(info cfg: building bytecode bootstrap compiler)\n-endif\n-\n ifdef CFG_DISABLE_VALGRIND\n   $(info cfg: disabling valgrind (CFG_DISABLE_VALGRIND))\n   CFG_VALGRIND :=\n@@ -247,7 +90,6 @@ X := $(CFG_EXE_SUFFIX)\n VPATH := $(S)doc $(S)src\n \n # Compilers we build, we now know how to run.\n-BOOT := $(Q)OCAMLRUNPARAM=\"b1\" boot/rustboot$(X) $(CFG_BOOT_FLAGS) -L stage0\n STAGE0 := $(Q)$(call CFG_RUN_TARG,stage0,\\\n                 stage0/rustc$(X) $(CFG_RUSTC_FLAGS) -L stage1)\n STAGE1 := $(Q)$(call CFG_RUN_TARG,stage1, \\\n@@ -256,7 +98,7 @@ STAGE2 := $(Q)$(call CFG_RUN_TARG,stage2, \\\n                 stage2/rustc$(X) $(CFG_RUSTC_FLAGS) -L stage3)\n \n # \"Source\" files we generate in builddir along the way.\n-GENERATED := boot/fe/lexer.ml boot/version.ml\n+GENERATED :=\n \n # Delete the built-in rules.\n .SUFFIXES:\n@@ -266,135 +108,6 @@ GENERATED := boot/fe/lexer.ml boot/version.ml\n %:: s.%\n %:: SCCS/s.%\n \n-######################################################################\n-# Bootstrap compiler variables\n-######################################################################\n-\n-# We must list them in link order.\n-# Nobody calculates the link-order DAG automatically, sadly.\n-\n-BOOT_MLS :=                                              \\\n-    $(addsuffix .ml,                                     \\\n-        boot/version                                     \\\n-        $(addprefix boot/util/, fmt common bits)         \\\n-        $(addprefix boot/driver/, session)               \\\n-        $(addprefix boot/fe/, ast token lexer parser     \\\n-          extfmt pexp item cexp fuzz)                    \\\n-        $(addprefix boot/be/, asm il abi)                \\\n-        $(addprefix boot/me/, walk semant resolve alias  \\\n-          simplify type dead layer typestate             \\\n-         loop layout transutil trans dwarf)              \\\n-        $(addprefix boot/be/, x86 ra pe elf macho)       \\\n-        $(addprefix boot/driver/, lib glue main))        \\\n-\n-BOOT_CMOS := $(BOOT_MLS:.ml=.cmo)\n-BOOT_CMXS := $(BOOT_MLS:.ml=.cmx)\n-BOOT_OBJS := $(BOOT_MLS:.ml=.o)\n-BOOT_CMIS := $(BOOT_MLS:.ml=.cmi)\n-\n-BS := $(S)src/boot\n-\n-BOOT_ML_DEP_INCS := -I $(BS)/fe   -I $(BS)/me      \\\n-                    -I $(BS)/be   -I $(BS)/driver  \\\n-                    -I $(BS)/util -I boot\n-\n-BOOT_ML_INCS    :=  -I boot/fe   -I boot/me      \\\n-                    -I boot/be   -I boot/driver  \\\n-                    -I boot/util -I boot\n-\n-BOOT_ML_LIBS        := unix.cma  nums.cma  bigarray.cma\n-BOOT_ML_NATIVE_LIBS := unix.cmxa nums.cmxa bigarray.cmxa\n-BOOT_OCAMLC_FLAGS   := -g $(BOOT_ML_INCS) -w Ael -warn-error Ael\n-BOOT_OCAMLOPT_FLAGS := -g $(BOOT_ML_INCS) -w Ael -warn-error Ael\n-\n-ifdef CFG_FLEXLINK\n-  BOOT_OCAMLOPT_FLAGS += -cclib -L/usr/lib\n-endif\n-\n-######################################################################\n-# Runtime (C++) library variables\n-######################################################################\n-\n-RUNTIME_CS := rt/sync/timer.cpp \\\n-              rt/sync/sync.cpp \\\n-              rt/sync/lock_and_signal.cpp \\\n-              rt/rust.cpp \\\n-              rt/rust_builtin.cpp \\\n-              rt/rust_run_program.cpp \\\n-              rt/rust_crate.cpp \\\n-              rt/rust_crate_cache.cpp \\\n-              rt/rust_crate_reader.cpp \\\n-              rt/rust_comm.cpp \\\n-              rt/rust_dom.cpp \\\n-              rt/rust_task.cpp \\\n-              rt/rust_task_list.cpp \\\n-              rt/rust_proxy.cpp \\\n-              rt/rust_chan.cpp \\\n-              rt/rust_port.cpp \\\n-              rt/rust_upcall.cpp \\\n-              rt/rust_log.cpp \\\n-              rt/rust_message.cpp \\\n-              rt/rust_timer.cpp \\\n-              rt/circular_buffer.cpp \\\n-              rt/isaac/randport.cpp \\\n-              rt/rust_srv.cpp \\\n-              rt/rust_kernel.cpp \\\n-              rt/memory_region.cpp \\\n-              rt/test/rust_test_harness.cpp \\\n-              rt/test/rust_test_runtime.cpp \\\n-              rt/test/rust_test_util.cpp\n-\n-RUNTIME_HDR := rt/globals.h \\\n-               rt/rust.h \\\n-               rt/rust_dwarf.h \\\n-               rt/rust_internal.h \\\n-               rt/rust_util.h \\\n-               rt/rust_chan.h \\\n-               rt/rust_port.h \\\n-               rt/rust_dom.h \\\n-               rt/rust_task.h \\\n-               rt/rust_task_list.h \\\n-               rt/rust_proxy.h \\\n-               rt/rust_log.h \\\n-               rt/rust_message.h \\\n-               rt/circular_buffer.h \\\n-               rt/util/array_list.h \\\n-               rt/util/indexed_list.h \\\n-               rt/util/synchronized_indexed_list.h \\\n-               rt/util/hash_map.h \\\n-               rt/sync/sync.h \\\n-               rt/sync/timer.h \\\n-               rt/sync/lock_and_signal.h \\\n-               rt/sync/lock_free_queue.h \\\n-               rt/rust_srv.h \\\n-               rt/rust_kernel.h \\\n-               rt/memory_region.h \\\n-               rt/memory.h \\\n-               rt/test/rust_test_harness.h \\\n-               rt/test/rust_test_runtime.h \\\n-               rt/test/rust_test_util.h\n-\n-RUNTIME_DEF := rt/rustrt$(CFG_DEF_SUFFIX)\n-RUNTIME_INCS := -I $(S)src/rt/isaac -I $(S)src/rt/uthash\n-RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o)\n-RUNTIME_LIBS := $(CFG_GCC_POST_LIB_FLAGS)\n-\n-######################################################################\n-# rustc LLVM-extensions (C++) library variables\n-######################################################################\n-\n-RUSTLLVM_LIB_CS := $(addprefix rustllvm/, \\\n-                     MachOObjectFile.cpp Passes.cpp)\n-\n-RUSTLLVM_OBJS_CS := $(addprefix rustllvm/, RustWrapper.cpp)\n-\n-RUSTLLVM_HDR := rustllvm/include/llvm-c/Object.h\n-RUSTLLVM_DEF := rustllvm/rustllvm$(CFG_DEF_SUFFIX)\n-\n-RUSTLLVM_INCS := -iquote $(CFG_LLVM_INCDIR) \\\n-                 -iquote $(S)src/rustllvm/include\n-RUSTLLVM_LIB_OBJS := $(RUSTLLVM_LIB_CS:.cpp=.o)\n-RUSTLLVM_OBJS_OBJS := $(RUSTLLVM_OBJS_CS:.cpp=.o)\n \n ######################################################################\n # Standard library variables\n@@ -412,7 +125,7 @@ COMPILER_INPUTS := $(wildcard $(addprefix $(S)src/comp/, \\\n                                 rustc.rc *.rs */*.rs))\n \n ######################################################################\n-# Test dependency variables\n+# Main target dependency variables\n ######################################################################\n \n LREQ := rt/$(CFG_RUNTIME) rustllvm/$(CFG_RUSTLLVM)\n@@ -443,643 +156,6 @@ all: boot/rustboot$(X)          \\\n #     stage2/rustc$(X)           \\\n #     stage3/rustc$(X)           \\\n \n-rt/$(CFG_RUNTIME): $(RUNTIME_OBJS) $(MKFILES) $(RUNTIME_HDR) $(RUNTIME_DEF)\n-\t@$(call E, link: $@)\n-\t$(Q)$(call CFG_LINK_C,$@,$(RUNTIME_LIBS) $(RUNTIME_OBJS),$(RUNTIME_DEF))\n-\n-# FIXME: Building a .a is a hack so that we build with both older and newer\n-# versions of LLVM. In newer versions some of the bits of this library are\n-# already in LLVM itself, so they are skipped.\n-rustllvm/rustllvmbits.a: $(RUSTLLVM_LIB_OBJS)\n-\trm -f $@\n-\tar crs $@ $^\n-\n-# Note: We pass $(CFG_LLVM_LIBS) twice to fix the windows link since\n-# it has no -whole-archive.\n-rustllvm/$(CFG_RUSTLLVM): rustllvm/rustllvmbits.a $(RUSTLLVM_OBJS_OBJS) \\\n-                          $(MKFILES) $(RUSTLLVM_HDR) $(RUSTLLVM_DEF)\n-\t@$(call E, link: $@)\n-\t$(Q)$(call CFG_LINK_C,$@,$(RUSTLLVM_OBJS_OBJS) \\\n-\t  $(CFG_GCC_PRE_LIB_FLAGS) $(CFG_LLVM_LIBS) \\\n-          $(CFG_GCC_POST_LIB_FLAGS) rustllvm/rustllvmbits.a \\\n-\t  $(CFG_LLVM_LIBS) \\\n-          $(CFG_LLVM_LDFLAGS),$(RUSTLLVM_DEF))\n-\n-ifdef CFG_BOOT_NATIVE\n-boot/rustboot$(X): $(BOOT_CMXS) $(MKFILES)\n-\t@$(call E, link: $@)\n-\t$(Q)ocamlopt$(OPT) -o $@ $(BOOT_OCAMLOPT_FLAGS) $(BOOT_ML_NATIVE_LIBS) \\\n-        $(BOOT_CMXS)\n-else\n-boot/rustboot$(X): $(BOOT_CMOS) $(MKFILES)\n-\t@$(call E, link: $@)\n-\t$(Q)ocamlc$(OPT) -o $@ $(BOOT_OCAMLC_FLAGS) $(BOOT_ML_LIBS) $(BOOT_CMOS)\n-endif\n-\n-boot/version.ml: $(MKFILES)\n-\t@$(call E, git: $@)\n-\t$(Q)(cd $(S) && git log -1 \\\n-      --pretty=format:'let version = \"prerelease (%h %ci)\";;') >$@ || exit 1\n-\n-\n-\n-stage0/$(CFG_STDLIB): $(STDLIB_CRATE) $(STDLIB_INPUTS) \\\n-                      boot/rustboot$(X) $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(BOOT) -shared -o $@ $<\n-\n-stage1/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage0/rustc$(X) $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(STAGE0) -c --shared -o $@ $<\n-\n-stage1/$(CFG_STDLIB): stage1/std.o stage1/glue.o\n-\t@$(call E, link: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) stage1/glue.o $(CFG_GCC_LINK_FLAGS) -o $@ $< \\\n-\t\t-Lstage1 -Lrt -lrustrt\n-\n-stage2/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage1/rustc$(X) $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(STAGE1) -c --shared -o $@ $<\n-\n-stage2/$(CFG_STDLIB): stage2/std.o stage2/glue.o\n-\t@$(call E, link: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) stage2/glue.o $(CFG_GCC_LINK_FLAGS) -o $@ $< \\\n-\t\t-Lstage2 -Lrt -lrustrt\n-\n-stage3/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage2/rustc$(X) $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(STAGE2) -c --shared -o $@ $<\n-\n-stage3/$(CFG_STDLIB): stage3/std.o stage3/glue.o\n-\t@$(call E, link: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) stage3/glue.o $(CFG_GCC_LINK_FLAGS) -o $@ $< \\\n-\t\t-Lstage3 -Lrt -lrustrt\n-\n-\n-\n-stage0/rustc$(X): $(COMPILER_CRATE) $(COMPILER_INPUTS) $(BREQ)\n-\t@$(call E, compile: $@)\n-\t$(BOOT) -minimal -o $@ $<\n-\t$(Q)chmod 0755 $@\n-\n-stage1/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ0)\n-\t@$(call E, compile: $@)\n-\t$(STAGE0) -c -o $@ $<\n-\n-stage2/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ1)\n-\t@$(call E, compile: $@)\n-\t$(STAGE1) -c -o $@ $<\n-\n-stage3/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ2)\n-\t@$(call E, compile: $@)\n-\t$(STAGE2) -c -o $@ $<\n-\n-\n-\n-stage1/glue.o: stage0/rustc$(X) stage0/$(CFG_STDLIB) \\\n-                rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n-\t@$(call E, generate: $@)\n-\t$(STAGE0) -c -o $@ --glue\n-\n-stage2/glue.o: stage1/rustc$(X) stage1/$(CFG_STDLIB) \\\n-                rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n-\t@$(call E, generate: $@)\n-\t$(STAGE1) -c -o $@ --glue\n-\n-stage3/glue.o: stage2/rustc$(X) stage2/$(CFG_STDLIB) \\\n-                rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n-\t@$(call E, generate: $@)\n-\t$(STAGE2) -c -o $@ --glue\n-\n-# Due to make not wanting to run the same implicit rules twice on the same\n-# rule tree (implicit-rule recursion prevention, see \"Chains of Implicit\n-# Rules\" in GNU Make manual) we have to re-state the %.o and %.s patterns here\n-# for different directories, to handle cases where (say) a test relies on a\n-# compiler that relies on a .o file.\n-\n-stage0/%.o: stage0/%.s\n-\t@$(call E, assemble [gcc]: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) -o $@ -c $<\n-\n-stage1/%.o: stage1/%.s\n-\t@$(call E, assemble [gcc]: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) -o $@ -c $<\n-\n-stage2/%.o: stage2/%.s\n-\t@$(call E, assemble [gcc]: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) -o $@ -c $<\n-\n-stage1/%$(X): stage1/%.o  $(SREQ0)\n-\t@$(call E, link [gcc]: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) stage1/glue.o -o $@ $< \\\n-      -Lstage1 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n-\t@# dsymutil sometimes fails or prints a warning, but the\n-\t@# program still runs.  Since it simplifies debugging other\n-\t@# programs, I\\'ll live with the noise.\n-\t-$(Q)$(CFG_DSYMUTIL) $@\n-\n-stage2/%$(X): stage2/%.o  $(SREQ1)\n-\t@$(call E, link [gcc]: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) stage2/glue.o -o $@ $< \\\n-      -Lstage2 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n-\t@# dsymutil sometimes fails or prints a warning, but the\n-\t@# program still runs.  Since it simplifies debugging other\n-\t@# programs, I\\'ll live with the noise.\n-\t-$(Q)$(CFG_DSYMUTIL) $@\n-\n-\n-\n-######################################################################\n-# Library and boot rules\n-######################################################################\n-\n-rt/%.o: rt/%.cpp $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n-\n-rustllvm/%.o: rustllvm/%.cpp $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)$(call CFG_COMPILE_C, $@, $(CFG_LLVM_CXXFLAGS) $(RUSTLLVM_INCS)) $<\n-\n-%.cmo: %.ml $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)ocamlc$(OPT) -c -o $@ $(BOOT_OCAMLC_FLAGS) $<\n-\n-%.cmo: %.cmi $(MKFILES)\n-\n-%.cmx %.o: %.ml $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)ocamlopt$(OPT) -c -o $@ $(BOOT_OCAMLOPT_FLAGS) $<\n-\n-%.ml: %.mll $(MKFILES)\n-\t@$(call E, lex-gen: $@)\n-\t$(Q)ocamllex$(OPT) -q -o $@ $<\n-\n-\n-%.linux.def:    %.def.in $(MKFILES)\n-\t@$(call E, def: $@)\n-\t$(Q)echo \"{\" > $@\n-\t$(Q)sed 's/.$$/&;/' $< >> $@\n-\t$(Q)echo \"};\" >> $@\n-\n-%.darwin.def:\t%.def.in $(MKFILES)\n-\t@$(call E, def: $@)\n-\t$(Q)sed 's/^./_&/' $< > $@\n-\n-ifdef CFG_WINDOWSY\n-%.def:\t%.def.in $(MKFILES)\n-\t@$(call E, def: $@)\n-\t$(Q)echo LIBRARY $* > $@\n-\t$(Q)echo EXPORTS >> $@\n-\t$(Q)sed 's/^./    &/' $< >> $@\n-endif\n-\n-######################################################################\n-# Doc rules\n-######################################################################\n-\n-doc/version.texi: $(MKFILES) rust.texi\n-\t(cd $(S) && git log -1 \\\n-      --pretty=format:'@macro gitversion%n%h %ci%n@end macro%n') >$@\n-\n-doc/%.pdf: %.texi doc/version.texi\n-\ttexi2pdf -I doc -o $@ --clean $<\n-\n-doc/%.html: %.texi doc/version.texi\n-\tmakeinfo -I doc --html --ifhtml --force --no-split --output=$@ $<\n-\n-docsnap: doc/rust.pdf\n-\tmv $< doc/rust-$(shell date +\"%Y-%m-%d\")-snap.pdf\n-\n-\n-######################################################################\n-# Testing variables\n-######################################################################\n-\n-ALL_TEST_INPUTS = $(wildcard $(S)src/test/*/*.rs   \\\n-                              $(S)src/test/*/*/*.rs \\\n-                              $(S)src/test/*/*.rc)\n-\n-TEST_XFAILS_BOOT = $(shell grep -l xfail-boot $(ALL_TEST_INPUTS))\n-TEST_XFAILS_STAGE0 = $(shell grep -l xfail-stage0 $(ALL_TEST_INPUTS))\n-TEST_XFAILS_STAGE1 = $(shell grep -l xfail-stage1 $(ALL_TEST_INPUTS))\n-TEST_XFAILS_STAGE2 = $(shell grep -l xfail-stage2 $(ALL_TEST_INPUTS))\n-\n-ifdef MINGW_CROSS\n-TEST_XFAILS_BOOT += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE0 += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE1 += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE2 += $(S)src/test/run-pass/native-mod.rc\n-endif\n-ifdef CFG_WINDOWSY\n-TEST_XFAILS_BOOT += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE0 += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE1 += $(S)src/test/run-pass/native-mod.rc\n-TEST_XFAILS_STAGE2 += $(S)src/test/run-pass/native-mod.rc\n-endif\n-\n-BENCH_RS = $(wildcard $(S)src/test/bench/shootout/*.rs) \\\n-            $(wildcard $(S)src/test/bench/99-bottles/*.rs)\n-RPASS_RC = $(wildcard $(S)src/test/run-pass/*.rc)\n-RPASS_RS = $(wildcard $(S)src/test/run-pass/*.rs) $(BENCH_RS)\n-RFAIL_RC = $(wildcard $(S)src/test/run-fail/*.rc)\n-RFAIL_RS = $(wildcard $(S)src/test/run-fail/*.rs)\n-CFAIL_RC = $(wildcard $(S)src/test/compile-fail/*.rc)\n-CFAIL_RS = $(wildcard $(S)src/test/compile-fail/*.rs)\n-\n-ifdef CHECK_XFAILS\n-TEST_RPASS_CRATES_BOOT = $(filter $(TEST_XFAILS_BOOT), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE0 = $(filter $(TEST_XFAILS_STAGE0), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE1 = $(filter $(TEST_XFAILS_STAGE1), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE2 = $(filter $(TEST_XFAILS_STAGE2), $(RPASS_RC))\n-TEST_RPASS_SOURCES_BOOT = $(filter $(TEST_XFAILS_BOOT), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE0 = $(filter $(TEST_XFAILS_STAGE0), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE1 = $(filter $(TEST_XFAILS_STAGE1), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE2 = $(filter $(TEST_XFAILS_STAGE2), $(RPASS_RS))\n-else\n-TEST_RPASS_CRATES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(RPASS_RC))\n-TEST_RPASS_CRATES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE2), $(RPASS_RC))\n-TEST_RPASS_SOURCES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(RPASS_RS))\n-TEST_RPASS_SOURCES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(RPASS_RS))\n-endif\n-\n-TEST_RPASS_EXES_BOOT = \\\n-  $(subst $(S)src/,,$(TEST_RPASS_CRATES_BOOT:.rc=.boot$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_BOOT:.rs=.boot$(X)))\n-TEST_RPASS_EXES_STAGE0 = \\\n-  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE0:.rc=.stage0$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE0:.rs=.stage0$(X)))\n-TEST_RPASS_EXES_STAGE1 = \\\n-  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE1:.rc=.stage1$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE1:.rs=.stage1$(X)))\n-TEST_RPASS_EXES_STAGE2 = \\\n-  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE1:.rc=.stage2$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE1:.rs=.stage2$(X)))\n-\n-TEST_RPASS_OUTS_BOOT  = \\\n-  $(TEST_RPASS_EXES_BOOT:.boot$(X)=.boot.out)\n-TEST_RPASS_OUTS_STAGE0 = \\\n-  $(TEST_RPASS_EXES_STAGE0:.stage0$(X)=.stage0.out)\n-TEST_RPASS_OUTS_STAGE1 = \\\n-  $(TEST_RPASS_EXES_STAGE1:.stage1$(X)=.stage1.out)\n-TEST_RPASS_OUTS_STAGE2 = \\\n-  $(TEST_RPASS_EXES_STAGE2:.stage2$(X)=.stage2.out)\n-\n-TEST_RPASS_TMPS_BOOT  = \\\n-  $(TEST_RPASS_EXES_BOOT:.boot$(X)=.boot$(X).tmp)\n-TEST_RPASS_TMPS_STAGE0 = \\\n-  $(TEST_RPASS_EXES_STAGE0:.stage0$(X)=.stage0$(X).tmp)\n-TEST_RPASS_TMPS_STAGE1 = \\\n-  $(TEST_RPASS_EXES_STAGE1:.stage1$(X)=.stage1$(X).tmp)\n-TEST_RPASS_TMPS_STAGE2 = \\\n-  $(TEST_RPASS_EXES_STAGE2:.stage2$(X)=.stage2$(X).tmp)\n-\n-\n-TEST_RFAIL_CRATES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(RFAIL_RC))\n-TEST_RFAIL_CRATES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(RFAIL_RC))\n-TEST_RFAIL_CRATES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(RFAIL_RC))\n-TEST_RFAIL_CRATES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(RFAIL_RC))\n-TEST_RFAIL_SOURCES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(RFAIL_RS))\n-TEST_RFAIL_SOURCES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(RFAIL_RS))\n-TEST_RFAIL_SOURCES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(RFAIL_RS))\n-TEST_RFAIL_SOURCES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(RFAIL_RS))\n-\n-TEST_RFAIL_EXES_BOOT = \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_BOOT:.rc=.boot$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_BOOT:.rs=.boot$(X)))\n-TEST_RFAIL_EXES_STAGE0 = \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE0:.rc=.stage0$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE0:.rs=.stage0$(X)))\n-TEST_RFAIL_EXES_STAGE1 = \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE1:.rc=.stage1$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE1:.rs=.stage1$(X)))\n-TEST_RFAIL_EXES_STAGE2 = \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE2:.rc=.stage2$(X))) \\\n-  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE2:.rs=.stage2$(X)))\n-\n-TEST_RFAIL_OUTS_BOOT  = \\\n-  $(TEST_RFAIL_EXES_BOOT:.boot$(X)=.boot.out)\n-TEST_RFAIL_OUTS_STAGE0 = \\\n-  $(TEST_RFAIL_EXES_STAGE0:.stage0$(X)=.stage0.out)\n-TEST_RFAIL_OUTS_STAGE1 = \\\n-  $(TEST_RFAIL_EXES_STAGE0:.stage1$(X)=.stage1.out)\n-TEST_RFAIL_OUTS_STAGE2 = \\\n-  $(TEST_RFAIL_EXES_STAGE0:.stage2$(X)=.stage2.out)\n-\n-TEST_RFAIL_TMPS_BOOT  = \\\n-  $(TEST_RFAIL_EXES_BOOT:.boot$(X)=.boot$(X).tmp)\n-TEST_RFAIL_TMPS_STAGE0 = \\\n-  $(TEST_RFAIL_EXES_STAGE0:.stage0$(X)=.stage0$(X).tmp)\n-TEST_RFAIL_TMPS_STAGE1 = \\\n-  $(TEST_RFAIL_EXES_STAGE1:.stage1$(X)=.stage1$(X).tmp)\n-TEST_RFAIL_TMPS_STAGE2 = \\\n-  $(TEST_RFAIL_EXES_STAGE2:.stage2$(X)=.stage2$(X).tmp)\n-\n-TEST_CFAIL_CRATES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(CFAIL_RC))\n-TEST_CFAIL_CRATES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(CFAIL_RC))\n-TEST_CFAIL_CRATES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(CFAIL_RC))\n-TEST_CFAIL_CRATES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(CFAIL_RC))\n-TEST_CFAIL_SOURCES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(CFAIL_RS))\n-TEST_CFAIL_SOURCES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(CFAIL_RS))\n-TEST_CFAIL_SOURCES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(CFAIL_RS))\n-TEST_CFAIL_SOURCES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(CFAIL_RS))\n-\n-TEST_CFAIL_EXES_BOOT = \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_BOOT:.rc=.boot$(X))) \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_BOOT:.rs=.boot$(X)))\n-TEST_CFAIL_EXES_STAGE0 = \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE0:.rc=.stage0$(X))) \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE0:.rs=.stage0$(X)))\n-TEST_CFAIL_EXES_STAGE1 = \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE1:.rc=.stage1$(X))) \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE1:.rs=.stage1$(X)))\n-TEST_CFAIL_EXES_STAGE2 = \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE2:.rc=.stage2$(X))) \\\n-  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE2:.rs=.stage2$(X)))\n-\n-TEST_CFAIL_OUTS_BOOT = \\\n-  $(TEST_CFAIL_EXES_BOOT:.boot$(X)=.boot.out)\n-TEST_CFAIL_OUTS_STAGE0 = \\\n-  $(TEST_CFAIL_EXES_STAGE0:.stage0$(X)=.stage0.out)\n-TEST_CFAIL_OUTS_STAGE1 = \\\n-  $(TEST_CFAIL_EXES_STAGE1:.stage1$(X)=.stage1.out)\n-TEST_CFAIL_OUTS_STAGE2 = \\\n-  $(TEST_CFAIL_EXES_STAGE0:.stage2$(X)=.stage2.out)\n-\n-TEST_CFAIL_TMPS_BOOT = \\\n-  $(TEST_CFAIL_EXES_BOOT:.boot$(X)=.boot$(X).tmp)\n-TEST_CFAIL_TMPS_STAGE0 = \\\n-  $(TEST_CFAIL_EXES_STAGE0:.stage0$(X)=.stage0$(X).tmp)\n-TEST_CFAIL_TMPS_STAGE1 = \\\n-  $(TEST_CFAIL_EXES_STAGE1:.stage1$(X)=.stage1$(X).tmp)\n-TEST_CFAIL_TMPS_STAGE0 = \\\n-  $(TEST_CFAIL_EXES_STAGE2:.stage2$(X)=.stage2$(X).tmp)\n-\n-\n-ALL_TEST_CRATES = $(TEST_CFAIL_CRATES_BOOT) \\\n-                   $(TEST_RFAIL_CRATES_BOOT) \\\n-                   $(TEST_RPASS_CRATES_BOOT) \\\n-                   $(TEST_CFAIL_CRATES_STAGE0) \\\n-                   $(TEST_RFAIL_CRATES_STAGE0) \\\n-                   $(TEST_RPASS_CRATES_STAGE0) \\\n-                   $(TEST_CFAIL_CRATES_STAGE1) \\\n-                   $(TEST_RFAIL_CRATES_STAGE1) \\\n-                   $(TEST_RPASS_CRATES_STAGE1) \\\n-                   $(TEST_CFAIL_CRATES_STAGE2) \\\n-                   $(TEST_RFAIL_CRATES_STAGE2) \\\n-                   $(TEST_RPASS_CRATES_STAGE2)\n-\n-ALL_TEST_SOURCES = $(TEST_CFAIL_SOURCES_BOOT) \\\n-                    $(TEST_RFAIL_SOURCES_BOOT) \\\n-                    $(TEST_RPASS_SOURCES_BOOT) \\\n-                    $(TEST_CFAIL_SOURCES_STAGE0) \\\n-                    $(TEST_RFAIL_SOURCES_STAGE0) \\\n-                    $(TEST_RPASS_SOURCES_STAGE0) \\\n-                    $(TEST_CFAIL_SOURCES_STAGE1) \\\n-                    $(TEST_RFAIL_SOURCES_STAGE1) \\\n-                    $(TEST_RPASS_SOURCES_STAGE1) \\\n-                    $(TEST_CFAIL_SOURCES_STAGE2) \\\n-                    $(TEST_RFAIL_SOURCES_STAGE2) \\\n-                    $(TEST_RPASS_SOURCES_STAGE2)\n-\n-# The test suite currently relies on logging to validate results so\n-# make sure that logging uses the default configuration\n-unexport RUST_LOG\n-\n-\n-check_nocompile: $(TEST_CFAIL_OUTS_BOOT) \\\n-                 $(TEST_CFAIL_OUTS_STAGE0)\n-\n-check: tidy \\\n-       $(TEST_RPASS_EXES_BOOT) $(TEST_RFAIL_EXES_BOOT) \\\n-       $(TEST_RPASS_OUTS_BOOT) $(TEST_RFAIL_OUTS_BOOT) \\\n-       $(TEST_CFAIL_OUTS_BOOT) \\\n-       $(TEST_RPASS_EXES_STAGE0) $(TEST_RFAIL_EXES_STAGE0) \\\n-       $(TEST_RPASS_OUTS_STAGE0) $(TEST_RFAIL_OUTS_STAGE0) \\\n-       $(TEST_CFAIL_OUTS_STAGE0)\n-#       $(TEST_RPASS_EXES_STAGE1) $(TEST_RFAIL_EXES_STAGE1) \\\n-#       $(TEST_RPASS_OUTS_STAGE1) $(TEST_RFAIL_OUTS_STAGE1) \\\n-#       $(TEST_CFAIL_OUTS_STAGE1) \\\n-#       $(TEST_RPASS_EXES_STAGE2) $(TEST_RFAIL_EXES_STAGE2) \\\n-#       $(TEST_RPASS_OUTS_STAGE2) $(TEST_RFAIL_OUTS_STAGE2) \\\n-#       $(TEST_CFAIL_OUTS_STAGE2)\n-\n-\n-compile-check: tidy \\\n-       $(TEST_RPASS_EXES_BOOT) $(TEST_RFAIL_EXES_BOOT) \\\n-       $(TEST_RPASS_EXES_STAGE0) $(TEST_RFAIL_EXES_STAGE0) \\\n-       $(TEST_RPASS_EXES_STAGE1) $(TEST_RFAIL_EXES_STAGE1) \\\n-       $(TEST_RPASS_EXES_STAGE2) $(TEST_RFAIL_EXES_STAGE2)\n-\n-\n-######################################################################\n-# Testing rules\n-######################################################################\n-\n-%.stage0$(X): %.stage0.o  $(SREQ0)\n-\t@$(call E, link [gcc]: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) stage1/glue.o -o $@ $< \\\n-      -Lstage1 -Lrt -lrustrt -lstd -lm\n-\t@# dsymutil sometimes fails or prints a warning, but the\n-\t@# program still runs.  Since it simplifies debugging other\n-\t@# programs, I\\'ll live with the noise.\n-\t-$(Q)$(CFG_DSYMUTIL) $@\n-\n-%.stage1$(X): %.stage1.o $(SREQ1)\n-\t@$(call E, link [gcc]: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) stage2/glue.o -o $@ $< \\\n-      -Lstage2 -Lrt -lrustrt -lstd -lm\n-\t@# dsymutil sometimes fails or prints a warning, but the\n-\t@# program still runs.  Since it simplifies debugging other\n-\t@# programs, I\\'ll live with the noise.\n-\t-$(Q)$(CFG_DSYMUTIL) $@\n-\n-%.stage2$(X): %.stage2.o $(SREQ2)\n-\t@$(call E, link [gcc]: $@)\n-\t$(Q)gcc $(CFG_GCC_CFLAGS) stage3/glue.o -o $@ $< \\\n-      -Lstage3 -Lrt -lrustrt -lstd -lm\n-\t@# dsymutil sometimes fails or prints a warning, but the\n-\t@# program still runs.  Since it simplifies debugging other\n-\t@# programs, I\\'ll live with the noise.\n-\t-$(Q)$(CFG_DSYMUTIL) $@\n-\n-\n-\n-%.boot$(X): %.rs $(BREQ)\n-\t@$(call E, compile [boot]: $@)\n-\t$(BOOT) -o $@ $<\n-\n-%.boot$(X): %.rc $(BREQ)\n-\t@$(call E, compile [boot]: $@)\n-\t$(BOOT) -o $@ $<\n-\n-%.stage0.o: %.rc $(SREQ0)\n-\t@$(call E, compile [stage0]: $@)\n-\t$(STAGE0) -c -o $@ $<\n-\n-%.stage0.o: %.rs $(SREQ0)\n-\t@$(call E, compile [stage0]: $@)\n-\t$(STAGE0) -c -o $@ $<\n-\n-%.stage1.o: %.rc $(SREQ1)\n-\t@$(call E, compile [stage1]: $@)\n-\t$(STAGE1) -c -o $@ $<\n-\n-%.stage1.o: %.rs $(SREQ1)\n-\t@$(call E, compile [stage1]: $@)\n-\t$(STAGE1) -c -o $@ $<\n-\n-%.stage2.o: %.rc $(SREQ2)\n-\t@$(call E, compile [stage2]: $@)\n-\t$(STAGE2) -c -o $@ $<\n-\n-%.stage2.o: %.rs $(SREQ2)\n-\t@$(call E, compile [stage2]: $@)\n-\t$(STAGE2) -c -o $@ $<\n-\n-# Cancel the implicit .out rule in GNU make.\n-%.out: %\n-\n-%.out: %.out.tmp\n-\t$(Q)mv $< $@\n-\n-test/run-pass/%.out.tmp: test/run-pass/%$(X) rt/$(CFG_RUNTIME)\n-\t$(Q)rm -f $<.tmp\n-\t@$(call E, run: $@)\n-\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n-\n-test/bench/shootout/%.out.tmp: test/bench/shootout/%$(X) \\\n-                               rt/$(CFG_RUNTIME)\n-\t$(Q)rm -f $<.tmp\n-\t@$(call E, run: $@)\n-\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n-\n-test/bench/99-bottles/%.out.tmp: test/bench/99-bottles/%$(X) \\\n-                                 rt/$(CFG_RUNTIME)\n-\t$(Q)rm -f $<.tmp\n-\t@$(call E, run: $@)\n-\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n-\n-test/run-fail/%.out.tmp: test/run-fail/%$(X) \\\n-                         rt/$(CFG_RUNTIME)\n-\t$(Q)rm -f $<.tmp\n-\t@$(call E, run: $@)\n-\t$(Q)grep -q error-pattern $(S)src/test/run-fail/$(basename $*).rs\n-\t$(Q)rm -f $@\n-\t$(Q)$(call CFG_RUN_TEST, $<) >$@ 2>&1 ; X=$$? ; \\\n-      if [ $$X -eq 0 ] ; then exit 1 ; else exit 0 ; fi\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $(S)src/test/run-fail/$(basename $*).rs \\\n-        | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-test/compile-fail/%.boot.out.tmp: test/compile-fail/%.rs $(BREQ)\n-\t@$(call E, compile [boot]: $@)\n-\t$(Q)grep -q error-pattern $<\n-\t$(Q)rm -f $@\n-\t$(BOOT) -o $(@:.out=$(X)) $< >$@ 2>&1; test $$? -ne 0\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-test/compile-fail/%.stage0.out.tmp: test/compile-fail/%.rs $(SREQ0)\n-\t@$(call E, compile [stage0]: $@)\n-\t$(Q)grep -q error-pattern $<\n-\t$(Q)rm -f $@\n-\t$(STAGE0) -o $(@:.out=$(X)) $< >$@ 2>&1; test $$? -ne 0\n-\t$(Q)grep --text --quiet \\\n-      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n-\n-\n-######################################################################\n-# Auto-dependency\n-######################################################################\n-\n-ML_DEPFILES := $(BOOT_MLS:%.ml=%.d)\n-C_DEPFILES := $(RUNTIME_CS:%.cpp=%.d) $(RUSTLLVM_LIB_CS:%.cpp=%.d) \\\n-              $(RUSTLLVM_OBJS_CS:%.cpp=%.d)\n-\n-rt/%.d: rt/%.cpp $(MKFILES)\n-\t@$(call E, dep: $@)\n-\t$(Q)$(call CFG_DEPEND_C, $@ \\\n-      $(subst $(S)src/,,$(patsubst %.cpp, %.o, $<)), \\\n-      $(RUNTIME_INCS)) $< >$@.tmp\n-\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)mv $@.tmp $@\n-\n-rustllvm/%.d: rustllvm/%.cpp $(MKFILES)\n-\t@$(call E, dep: $@)\n-\t$(Q)$(call CFG_DEPEND_C, $@ \\\n-      $(subst $(S)src/,,$(patsubst %.cpp, %.o, $<)), \\\n-      $(CFG_LLVM_CXXFLAGS) $(RUSTLLVM_INCS)) $< >$@.tmp\n-\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)mv $@.tmp $@\n-\n-%.d: %.ml $(MKFILES)\n-\t@$(call E, dep: $@)\n-\t$(Q)ocamldep$(OPT) -slash $(BOOT_ML_DEP_INCS) $< >$@.tmp\n-\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)perl -i.bak -pe \"s@$(S)src/@@go\" $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)mv $@.tmp $@\n-\n-%.d: %.mli $(MKFILES)\n-\t@$(call E, dep: $@)\n-\t$(Q)ocamldep$(OPT) -slash $(BOOT_ML_DEP_INCS) $< >$@.tmp\n-\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)perl -i.bak -pe \"s@$(S)src/@@go\" $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)mv $@.tmp $@\n-\n-ifneq ($(MAKECMDGOALS),clean)\n--include $(ML_DEPFILES) $(C_DEPFILES)\n-endif\n-\n-RUSTBOOT_PROBE := $(wildcard boot/rustboot$(X))\n-\n-ifneq ($(RUSTBOOT_PROBE),)\n-CFG_INFO := $(info cfg: using built boot/rustboot$(X) for rust deps)\n-CRATE_DEPFILES := $(subst $(S)src/,,$(ALL_TEST_CRATES:%.rc=%.d)) \\\n-                  boot/$(CFG_STDLIB).d \\\n-                  stage0/rustc$(X).d \\\n-                  stage0/$(CFG_STDLIB).d\n-\n-boot/$(CFG_STDLIB).d: $(STDLIB_CRATE) $(STDLIB_INPUTS) \\\n-                      $(MKFILES) boot/rustboot$(X)\n-\t@$(call E, dep: $@)\n-\t$(BOOT) -o $(patsubst %.d,%$(X),$@) -shared -rdeps $< >$@.tmp\n-\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)mv $@.tmp $@\n-\n-stage0/rustc$(X).d: $(COMPILER_CRATE) $(COMPILER_INPUTS) \\\n-                    $(STDLIB_CRATE) $(MKFILES) boot/rustboot$(X)\n-\t@$(call E, dep: $@)\n-\t$(BOOT) -o $(patsubst %.d,%$(X),$@) -shared -rdeps $< >$@.tmp\n-\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)mv $@.tmp $@\n-\n-%.d: %.rc $(MKFILES) boot/rustboot$(X)\n-\t@$(call E, dep: $@)\n-\t$(BOOT)  -o $(patsubst %.d,%$(X),$@) -rdeps $< >$@.tmp\n-\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n-\t$(Q)rm -f $@.tmp.bak\n-\t$(Q)mv $@.tmp $@\n-\n-ifneq ($(MAKECMDGOALS),clean)\n--include $(CRATE_DEPFILES)\n-endif\n-endif\n-\n-depend: boot/rustboot$(X) $(CRATE_DEPFILES) $(ML_DEPFILES) $(C_DEPFILES)\n-\n \n ######################################################################\n # Re-configuration\n@@ -1091,108 +167,17 @@ config.mk: $(S)configure $(S)Makefile.in\n \n \n ######################################################################\n-# Distribution\n+# Additional makefiles\n ######################################################################\n \n-PKG_NAME := rust\n-PKG_VER  = $(shell date +\"%Y-%m-%d\")-snap\n-PKG_DIR = $(PKG_NAME)-$(PKG_VER)\n-PKG_TAR = $(PKG_DIR).tar.gz\n-\n-PKG_3RDPARTY := rt/valgrind.h rt/memcheck.h \\\n-                rt/isaac/rand.h rt/isaac/standard.h \\\n-                rt/uthash/uthash.h rt/uthash/utlist.h \\\n-                rt/bigint/bigint.h rt/bigint/bigint_int.cpp \\\n-                rt/bigint/bigint_ext.cpp rt/bigint/low_primes.h\n-\n-PKG_FILES = \\\n-    $(wildcard $(S)src/etc/*.*)                \\\n-    $(S)LICENSE.txt $(S)README                 \\\n-    $(S)configure $(S)Makefile.in              \\\n-    $(addprefix $(S)src/,                      \\\n-      README boot/README comp/README           \\\n-      $(filter-out $(GENERATED), $(BOOT_MLS))  \\\n-      $(RUNTIME_CS) $(RUNTIME_HDR)             \\\n-      $(RUSTLLVM_LIB_CS) $(RUSTLLVM_OBJS_CS)   \\\n-      $(RUSTLLVM_HDR)                          \\\n-      $(PKG_3RDPARTY))                         \\\n-    $(GENERATED)                               \\\n-    $(S)src/boot/fe/lexer.ml                   \\\n-    $(COMPILER_INPUTS)                         \\\n-    $(STDLIB_INPUTS)                           \\\n-    $(ALL_TEST_INPUTS)                         \\\n-    $(GENERATED)\n-\n-dist: $(PKG_TAR)\n-\n-$(PKG_TAR): $(GENERATED)\n-\t@$(call E, making dist dir)\n-\t$(Q)rm -Rf dist\n-\t$(Q)mkdir -p dist/$(PKG_DIR)\n-\t$(Q)tar -c $(PKG_FILES) | tar -x -C dist/$(PKG_DIR)\n-\t$(Q)tar -czf $(PKG_TAR) -C dist $(PKG_DIR)\n-\t$(Q)rm -Rf dist\n-\n-distcheck: $(PKG_TAR)\n-\t$(Q)rm -Rf dist\n-\t$(Q)mkdir -p dist\n-\t@$(call E, unpacking $(PKG_TAR) in dist/$(PKG_DIR))\n-\t$(Q)cd dist && tar -xzf ../$(PKG_TAR)\n-\t@$(call E, configuring in dist/$(PKG_DIR)-build)\n-\t$(Q)mkdir -p dist/$(PKG_DIR)-build\n-\t$(Q)cd dist/$(PKG_DIR)-build && ../$(PKG_DIR)/configure\n-\t@$(call E, making 'check' in dist/$(PKG_DIR)-build)\n-\t$(Q)make -C dist/$(PKG_DIR)-build check\n-\t@$(call E, making 'clean' in dist/$(PKG_DIR)-build)\n-\t$(Q)make -C dist/$(PKG_DIR)-build clean\n-\t$(Q)rm -Rf dist\n-\t@echo\n-\t@echo -----------------------------------------------\n-\t@echo $(PKG_TAR) ready for distribution\n-\t@echo -----------------------------------------------\n-\n-\n-######################################################################\n-# Cleanup\n-######################################################################\n-\n-.PHONY: clean\n-\n-tidy:\n-\t@$(call E, check: formatting)\n-\t$(Q)echo \\\n-      $(filter-out $(GENERATED) $(addprefix $(S)src/, $(GENERATED)) \\\n-        $(addprefix $(S)src/, $(RUSTLLVM_LIB_CS) $(RUSTLLVM_OBJS_CS) \\\n-          $(RUSTLLVM_HDR) $(PKG_3RDPARTY)) \\\n-        $(S)src/etc/%, $(PKG_FILES)) \\\n-    | xargs -n 10 python $(S)src/etc/tidy.py\n-\n-clean:\n-\t@$(call E, cleaning)\n-\t$(Q)rm -f $(RUNTIME_OBJS) $(RUNTIME_DEF)\n-\t$(Q)rm -f $(RUSTLLVM_LIB_OBJS) $(RUSTLLVM_OBJS_OBJS) $(RUSTLLVM_DEF)\n-\t$(Q)rm -f $(BOOT_CMOS) $(BOOT_CMIS) $(BOOT_CMXS) $(BOOT_OBJS)\n-\t$(Q)rm -f $(ML_DEPFILES) $(C_DEPFILES) $(CRATE_DEPFILES)\n-\t$(Q)rm -f $(ML_DEPFILES:%.d=%.d.tmp)\n-\t$(Q)rm -f $(C_DEPFILES:%.d=%.d.tmp)\n-\t$(Q)rm -f $(CRATE_DEPFILES:%.d=%.d.tmp)\n-\t$(Q)rm -f $(GENERATED)\n-\t$(Q)rm -f boot/rustboot$(X) boot/$(CFG_STDLIB)\n-\t$(Q)rm -f stage0/rustc$(X) stage0/$(CFG_STDLIB)\n-\t$(Q)rm -f stage1/rustc$(X) stage1/$(CFG_STDLIB) stage1/glue*\n-\t$(Q)rm -f stage2/rustc$(X) stage2/$(CFG_STDLIB) stage2/glue*\n-\t$(Q)rm -f stage3/rustc$(X) stage3/$(CFG_STDLIB) stage3/glue*\n-\t$(Q)rm -f rustllvm/$(CFG_RUSTLLVM) rustllvm/rustllvmbits.a\n-\t$(Q)rm -f rt/$(CFG_RUNTIME)\n-\t$(Q)rm -Rf $(PKG_NAME)-*.tar.gz dist\n-\t$(Q)rm -f $(foreach ext,cmx cmi cmo cma bc o a d exe,\\\n-                        $(wildcard boot/*/*.$(ext) boot/*/*/*.$(ext)))\n-\t$(Q)rm -f $(foreach ext,o a d bc s exe,$(wildcard stage*/*.$(ext)))\n-\t$(Q)rm -Rf $(foreach ext,out out.tmp                               \\\n-                             boot$(X) stage0$(X) stage1$(X) stage2$(X) \\\n-                             bc o s exe dSYM,                          \\\n-                        $(wildcard test/*/*.$(ext) test/bench/*/*.$(ext)))\n-\t$(Q)rm -Rf $(foreach ext, \\\n-                 aux cp fn ky log pdf html pg toc tp vr cps, \\\n-                 $(wildcard doc/*.$(ext)))\n-\t$(Q)rm -Rf doc/version.texi\n+include $(CFG_SRC_DIR)/mk/boot.mk\n+include $(CFG_SRC_DIR)/mk/stage0.mk\n+include $(CFG_SRC_DIR)/mk/stage1.mk\n+include $(CFG_SRC_DIR)/mk/stage2.mk\n+include $(CFG_SRC_DIR)/mk/rt.mk\n+include $(CFG_SRC_DIR)/mk/rustllvm.mk\n+include $(CFG_SRC_DIR)/mk/docs.mk\n+include $(CFG_SRC_DIR)/mk/tests.mk\n+include $(CFG_SRC_DIR)/mk/dist.mk\n+include $(CFG_SRC_DIR)/mk/clean.mk\n+include $(CFG_SRC_DIR)/mk/autodep.mk"}, {"sha": "59f221d04e6a5aeac13e4df4eba3b031b8c4f17e", "filename": "mk/autodep.mk", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fautodep.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fautodep.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fautodep.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,86 @@\n+######################################################################\n+# Auto-dependency\n+######################################################################\n+\n+ML_DEPFILES := $(BOOT_MLS:%.ml=%.d)\n+C_DEPFILES := $(RUNTIME_CS:%.cpp=%.d) $(RUSTLLVM_LIB_CS:%.cpp=%.d) \\\n+              $(RUSTLLVM_OBJS_CS:%.cpp=%.d)\n+\n+rt/%.d: rt/%.cpp $(MKFILES)\n+\t@$(call E, dep: $@)\n+\t$(Q)$(call CFG_DEPEND_C, $@ \\\n+      $(subst $(S)src/,,$(patsubst %.cpp, %.o, $<)), \\\n+      $(RUNTIME_INCS)) $< >$@.tmp\n+\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)mv $@.tmp $@\n+\n+rustllvm/%.d: rustllvm/%.cpp $(MKFILES)\n+\t@$(call E, dep: $@)\n+\t$(Q)$(call CFG_DEPEND_C, $@ \\\n+      $(subst $(S)src/,,$(patsubst %.cpp, %.o, $<)), \\\n+      $(CFG_LLVM_CXXFLAGS) $(RUSTLLVM_INCS)) $< >$@.tmp\n+\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)mv $@.tmp $@\n+\n+%.d: %.ml $(MKFILES)\n+\t@$(call E, dep: $@)\n+\t$(Q)ocamldep$(OPT) -slash $(BOOT_ML_DEP_INCS) $< >$@.tmp\n+\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)perl -i.bak -pe \"s@$(S)src/@@go\" $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)mv $@.tmp $@\n+\n+%.d: %.mli $(MKFILES)\n+\t@$(call E, dep: $@)\n+\t$(Q)ocamldep$(OPT) -slash $(BOOT_ML_DEP_INCS) $< >$@.tmp\n+\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)perl -i.bak -pe \"s@$(S)src/@@go\" $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)mv $@.tmp $@\n+\n+ifneq ($(MAKECMDGOALS),clean)\n+-include $(ML_DEPFILES) $(C_DEPFILES)\n+endif\n+\n+RUSTBOOT_PROBE := $(wildcard boot/rustboot$(X))\n+\n+ifneq ($(RUSTBOOT_PROBE),)\n+CFG_INFO := $(info cfg: using built boot/rustboot$(X) for rust deps)\n+CRATE_DEPFILES := $(subst $(S)src/,,$(ALL_TEST_CRATES:%.rc=%.d)) \\\n+                  boot/$(CFG_STDLIB).d \\\n+                  stage0/rustc$(X).d \\\n+                  stage0/$(CFG_STDLIB).d\n+\n+boot/$(CFG_STDLIB).d: $(STDLIB_CRATE) $(STDLIB_INPUTS) \\\n+                      $(MKFILES) boot/rustboot$(X)\n+\t@$(call E, dep: $@)\n+\t$(BOOT) -o $(patsubst %.d,%$(X),$@) -shared -rdeps $< >$@.tmp\n+\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)mv $@.tmp $@\n+\n+stage0/rustc$(X).d: $(COMPILER_CRATE) $(COMPILER_INPUTS) \\\n+                    $(STDLIB_CRATE) $(MKFILES) boot/rustboot$(X)\n+\t@$(call E, dep: $@)\n+\t$(BOOT) -o $(patsubst %.d,%$(X),$@) -shared -rdeps $< >$@.tmp\n+\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)mv $@.tmp $@\n+\n+%.d: %.rc $(MKFILES) boot/rustboot$(X)\n+\t@$(call E, dep: $@)\n+\t$(BOOT)  -o $(patsubst %.d,%$(X),$@) -rdeps $< >$@.tmp\n+\t$(Q)$(CFG_PATH_MUNGE) $@.tmp\n+\t$(Q)rm -f $@.tmp.bak\n+\t$(Q)mv $@.tmp $@\n+\n+ifneq ($(MAKECMDGOALS),clean)\n+-include $(CRATE_DEPFILES)\n+endif\n+endif\n+\n+depend: boot/rustboot$(X) $(CRATE_DEPFILES) $(ML_DEPFILES) $(C_DEPFILES)"}, {"sha": "a6ab5ccca59717b731ffa518d5a163e13da2751e", "filename": "mk/boot.mk", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fboot.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fboot.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fboot.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,98 @@\n+######################################################################\n+# Bootstrap compiler variables and rules\n+######################################################################\n+\n+ifdef CFG_BOOT_PROFILE\n+  $(info cfg: forcing native bootstrap compiler (CFG_BOOT_PROFILE))\n+  CFG_BOOT_NATIVE := 1\n+  CFG_OCAMLOPT_PROFILE_FLAGS := -p\n+endif\n+\n+ifdef CFG_BOOT_DEBUG\n+  $(info cfg: forcing bytecode bootstrap compiler (CFG_BOOT_DEBUG))\n+  CFG_BOOT_NATIVE :=\n+endif\n+\n+ifdef CFG_BOOT_NATIVE\n+  $(info cfg: building native bootstrap compiler)\n+else\n+  $(info cfg: building bytecode bootstrap compiler)\n+endif\n+\n+GENERATED := boot/fe/lexer.ml boot/version.ml\n+\n+\n+# We must list them in link order.\n+# Nobody calculates the link-order DAG automatically, sadly.\n+\n+BOOT_MLS :=                                              \\\n+    $(addsuffix .ml,                                     \\\n+        boot/version                                     \\\n+        $(addprefix boot/util/, fmt common bits)         \\\n+        $(addprefix boot/driver/, session)               \\\n+        $(addprefix boot/fe/, ast token lexer parser     \\\n+          extfmt pexp item cexp fuzz)                    \\\n+        $(addprefix boot/be/, asm il abi)                \\\n+        $(addprefix boot/me/, walk semant resolve alias  \\\n+          simplify type dead layer typestate             \\\n+         loop layout transutil trans dwarf)              \\\n+        $(addprefix boot/be/, x86 ra pe elf macho)       \\\n+        $(addprefix boot/driver/, lib glue main))        \\\n+\n+BOOT_CMOS := $(BOOT_MLS:.ml=.cmo)\n+BOOT_CMXS := $(BOOT_MLS:.ml=.cmx)\n+BOOT_OBJS := $(BOOT_MLS:.ml=.o)\n+BOOT_CMIS := $(BOOT_MLS:.ml=.cmi)\n+\n+BS := $(S)src/boot\n+\n+BOOT_ML_DEP_INCS := -I $(BS)/fe   -I $(BS)/me      \\\n+                    -I $(BS)/be   -I $(BS)/driver  \\\n+                    -I $(BS)/util -I boot\n+\n+BOOT_ML_INCS    :=  -I boot/fe   -I boot/me      \\\n+                    -I boot/be   -I boot/driver  \\\n+                    -I boot/util -I boot\n+\n+BOOT_ML_LIBS        := unix.cma  nums.cma  bigarray.cma\n+BOOT_ML_NATIVE_LIBS := unix.cmxa nums.cmxa bigarray.cmxa\n+BOOT_OCAMLC_FLAGS   := -g $(BOOT_ML_INCS) -w Ael -warn-error Ael\n+BOOT_OCAMLOPT_FLAGS := -g $(BOOT_ML_INCS) -w Ael -warn-error Ael\n+\n+ifdef CFG_FLEXLINK\n+  BOOT_OCAMLOPT_FLAGS += -cclib -L/usr/lib\n+endif\n+\n+BOOT := $(Q)OCAMLRUNPARAM=\"b1\" boot/rustboot$(X) $(CFG_BOOT_FLAGS) -L stage0\n+\n+\n+ifdef CFG_BOOT_NATIVE\n+boot/rustboot$(X): $(BOOT_CMXS) $(MKFILES)\n+\t@$(call E, link: $@)\n+\t$(Q)ocamlopt$(OPT) -o $@ $(BOOT_OCAMLOPT_FLAGS) $(BOOT_ML_NATIVE_LIBS) \\\n+        $(BOOT_CMXS)\n+else\n+boot/rustboot$(X): $(BOOT_CMOS) $(MKFILES)\n+\t@$(call E, link: $@)\n+\t$(Q)ocamlc$(OPT) -o $@ $(BOOT_OCAMLC_FLAGS) $(BOOT_ML_LIBS) $(BOOT_CMOS)\n+endif\n+\n+boot/version.ml: $(MKFILES)\n+\t@$(call E, git: $@)\n+\t$(Q)(cd $(S) && git log -1 \\\n+      --pretty=format:'let version = \"prerelease (%h %ci)\";;') >$@ || exit 1\n+\n+%.cmo: %.ml $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)ocamlc$(OPT) -c -o $@ $(BOOT_OCAMLC_FLAGS) $<\n+\n+%.cmo: %.cmi $(MKFILES)\n+\n+%.cmx %.o: %.ml $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)ocamlopt$(OPT) -c -o $@ $(BOOT_OCAMLOPT_FLAGS) $<\n+\n+%.ml: %.mll $(MKFILES)\n+\t@$(call E, lex-gen: $@)\n+\t$(Q)ocamllex$(OPT) -q -o $@ $<\n+"}, {"sha": "3055b614b36532f254030701cfc94ca7c3e673d6", "filename": "mk/clean.mk", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,44 @@\n+######################################################################\n+# Cleanup\n+######################################################################\n+\n+.PHONY: clean\n+\n+tidy:\n+\t@$(call E, check: formatting)\n+\t$(Q)echo \\\n+      $(filter-out $(GENERATED) $(addprefix $(S)src/, $(GENERATED)) \\\n+        $(addprefix $(S)src/, $(RUSTLLVM_LIB_CS) $(RUSTLLVM_OBJS_CS) \\\n+          $(RUSTLLVM_HDR) $(PKG_3RDPARTY)) \\\n+        $(S)src/etc/%, $(PKG_FILES)) \\\n+    | xargs -n 10 python $(S)src/etc/tidy.py\n+\n+clean:\n+\t@$(call E, cleaning)\n+\t$(Q)rm -f $(RUNTIME_OBJS) $(RUNTIME_DEF)\n+\t$(Q)rm -f $(RUSTLLVM_LIB_OBJS) $(RUSTLLVM_OBJS_OBJS) $(RUSTLLVM_DEF)\n+\t$(Q)rm -f $(BOOT_CMOS) $(BOOT_CMIS) $(BOOT_CMXS) $(BOOT_OBJS)\n+\t$(Q)rm -f $(ML_DEPFILES) $(C_DEPFILES) $(CRATE_DEPFILES)\n+\t$(Q)rm -f $(ML_DEPFILES:%.d=%.d.tmp)\n+\t$(Q)rm -f $(C_DEPFILES:%.d=%.d.tmp)\n+\t$(Q)rm -f $(CRATE_DEPFILES:%.d=%.d.tmp)\n+\t$(Q)rm -f $(GENERATED)\n+\t$(Q)rm -f boot/rustboot$(X) boot/$(CFG_STDLIB)\n+\t$(Q)rm -f stage0/rustc$(X) stage0/$(CFG_STDLIB)\n+\t$(Q)rm -f stage1/rustc$(X) stage1/$(CFG_STDLIB) stage1/glue*\n+\t$(Q)rm -f stage2/rustc$(X) stage2/$(CFG_STDLIB) stage2/glue*\n+\t$(Q)rm -f stage3/rustc$(X) stage3/$(CFG_STDLIB) stage3/glue*\n+\t$(Q)rm -f rustllvm/$(CFG_RUSTLLVM) rustllvm/rustllvmbits.a\n+\t$(Q)rm -f rt/$(CFG_RUNTIME)\n+\t$(Q)rm -Rf $(PKG_NAME)-*.tar.gz dist\n+\t$(Q)rm -f $(foreach ext,cmx cmi cmo cma bc o a d exe,\\\n+                        $(wildcard boot/*/*.$(ext) boot/*/*/*.$(ext)))\n+\t$(Q)rm -f $(foreach ext,o a d bc s exe,$(wildcard stage*/*.$(ext)))\n+\t$(Q)rm -Rf $(foreach ext,out out.tmp                               \\\n+                             boot$(X) stage0$(X) stage1$(X) stage2$(X) \\\n+                             bc o s exe dSYM,                          \\\n+                        $(wildcard test/*/*.$(ext) test/bench/*/*.$(ext)))\n+\t$(Q)rm -Rf $(foreach ext, \\\n+                 aux cp fn ky log pdf html pg toc tp vr cps, \\\n+                 $(wildcard doc/*.$(ext)))\n+\t$(Q)rm -Rf doc/version.texi"}, {"sha": "45be80884895eaa8247bf43cf705e21d2ba9da22", "filename": "mk/dist.mk", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,62 @@\n+######################################################################\n+# Distribution\n+######################################################################\n+\n+PKG_NAME := rust\n+PKG_VER  = $(shell date +\"%Y-%m-%d\")-snap\n+PKG_DIR = $(PKG_NAME)-$(PKG_VER)\n+PKG_TAR = $(PKG_DIR).tar.gz\n+\n+PKG_3RDPARTY := rt/valgrind.h rt/memcheck.h \\\n+                rt/isaac/rand.h rt/isaac/standard.h \\\n+                rt/uthash/uthash.h rt/uthash/utlist.h \\\n+                rt/bigint/bigint.h rt/bigint/bigint_int.cpp \\\n+                rt/bigint/bigint_ext.cpp rt/bigint/low_primes.h\n+\n+PKG_FILES = \\\n+    $(wildcard $(S)src/etc/*.*)                \\\n+    $(S)LICENSE.txt $(S)README                 \\\n+    $(S)configure $(S)Makefile.in              \\\n+    $(addprefix $(S)src/,                      \\\n+      README boot/README comp/README           \\\n+      $(filter-out $(GENERATED), $(BOOT_MLS))  \\\n+      $(RUNTIME_CS) $(RUNTIME_HDR)             \\\n+      $(RUSTLLVM_LIB_CS) $(RUSTLLVM_OBJS_CS)   \\\n+      $(RUSTLLVM_HDR)                          \\\n+      $(PKG_3RDPARTY))                         \\\n+    $(GENERATED)                               \\\n+    $(S)src/boot/fe/lexer.ml                   \\\n+    $(COMPILER_INPUTS)                         \\\n+    $(STDLIB_INPUTS)                           \\\n+    $(ALL_TEST_INPUTS)                         \\\n+    $(GENERATED)\n+\n+dist: $(PKG_TAR)\n+\n+$(PKG_TAR): $(GENERATED)\n+\t@$(call E, making dist dir)\n+\t$(Q)rm -Rf dist\n+\t$(Q)mkdir -p dist/$(PKG_DIR)\n+\t$(Q)tar -c $(PKG_FILES) | tar -x -C dist/$(PKG_DIR)\n+\t$(Q)tar -czf $(PKG_TAR) -C dist $(PKG_DIR)\n+\t$(Q)rm -Rf dist\n+\n+distcheck: $(PKG_TAR)\n+\t$(Q)rm -Rf dist\n+\t$(Q)mkdir -p dist\n+\t@$(call E, unpacking $(PKG_TAR) in dist/$(PKG_DIR))\n+\t$(Q)cd dist && tar -xzf ../$(PKG_TAR)\n+\t@$(call E, configuring in dist/$(PKG_DIR)-build)\n+\t$(Q)mkdir -p dist/$(PKG_DIR)-build\n+\t$(Q)cd dist/$(PKG_DIR)-build && ../$(PKG_DIR)/configure\n+\t@$(call E, making 'check' in dist/$(PKG_DIR)-build)\n+\t$(Q)make -C dist/$(PKG_DIR)-build check\n+\t@$(call E, making 'clean' in dist/$(PKG_DIR)-build)\n+\t$(Q)make -C dist/$(PKG_DIR)-build clean\n+\t$(Q)rm -Rf dist\n+\t@echo\n+\t@echo -----------------------------------------------\n+\t@echo $(PKG_TAR) ready for distribution\n+\t@echo -----------------------------------------------\n+\n+"}, {"sha": "ba00f57cdf63a605fde5892d16b44efef3ef7bfe", "filename": "mk/docs.mk", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,16 @@\n+######################################################################\n+# Doc variables and rules\n+######################################################################\n+\n+doc/version.texi: $(MKFILES) rust.texi\n+\t(cd $(S) && git log -1 \\\n+      --pretty=format:'@macro gitversion%n%h %ci%n@end macro%n') >$@\n+\n+doc/%.pdf: %.texi doc/version.texi\n+\ttexi2pdf -I doc -o $@ --clean $<\n+\n+doc/%.html: %.texi doc/version.texi\n+\tmakeinfo -I doc --html --ifhtml --force --no-split --output=$@ $<\n+\n+docsnap: doc/rust.pdf\n+\tmv $< doc/rust-$(shell date +\"%Y-%m-%d\")-snap.pdf"}, {"sha": "ecf486f7e6d5e4c3facfdef4f3d3314d4aa3fbc5", "filename": "mk/platform.mk", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,144 @@\n+CFG_GCC_CFLAGS := -fno-strict-aliasing\n+CFG_GCC_LINK_FLAGS :=\n+\n+# On Darwin, we need to run dsymutil so the debugging information ends\n+# up in the right place.  On other platforms, it automatically gets\n+# embedded into the executable, so use a no-op command.\n+CFG_DSYMUTIL := true\n+\n+ifeq ($(CFG_OSTYPE), FreeBSD)\n+  CFG_LIB_NAME=lib$(1).so\n+  CFG_GCC_CFLAGS += -fPIC -march=i686 -I/usr/local/include -O2\n+  CFG_GCC_LINK_FLAGS += -shared -fPIC -lpthread -lrt\n+  ifeq ($(CFG_CPUTYPE), x86_64)\n+    CFG_GCC_CFLAGS += -m32\n+    CFG_GCC_LINK_FLAGS += -m32\n+  endif\n+  CFG_UNIXY := 1\n+  CFG_LDENV := LD_LIBRARY_PATH\n+  CFG_DEF_SUFFIX := .bsd.def\n+endif\n+\n+ifeq ($(CFG_OSTYPE), Linux)\n+  CFG_LIB_NAME=lib$(1).so\n+  CFG_GCC_CFLAGS += -fPIC -march=i686 -O2\n+  CFG_GCC_LINK_FLAGS += -shared -fPIC -ldl -lpthread -lrt\n+  CFG_GCC_DEF_FLAG := -Wl,--export-dynamic,--dynamic-list=\n+  CFG_GCC_PRE_LIB_FLAGS := -Wl,-whole-archive\n+  CFG_GCC_POST_LIB_FLAGS := -Wl,-no-whole-archive\n+  ifeq ($(CFG_CPUTYPE), x86_64)\n+    CFG_GCC_CFLAGS += -m32\n+    CFG_GCC_LINK_FLAGS += -m32\n+  endif\n+  CFG_UNIXY := 1\n+  CFG_LDENV := LD_LIBRARY_PATH\n+  CFG_DEF_SUFFIX := .linux.def\n+endif\n+\n+ifeq ($(CFG_OSTYPE), Darwin)\n+  CFG_LIB_NAME=lib$(1).dylib\n+  CFG_UNIXY := 1\n+  CFG_LDENV := DYLD_LIBRARY_PATH\n+  CFG_GCC_LINK_FLAGS += -dynamiclib -lpthread\n+  CFG_GCC_DEF_FLAG := -Wl,-exported_symbols_list,\n+  # Darwin has a very blurry notion of \"64 bit\", and claims it's running\n+  # \"on an i386\" when the whole userspace is 64-bit and the compiler\n+  # emits 64-bit binaries by default. So we just force -m32 here. Smarter\n+  # approaches welcome!\n+  #\n+  # NB: Currently GCC's optimizer breaks rustrt (task-comm-1 hangs) on Darwin.\n+  CFG_GCC_CFLAGS += -m32 -O0\n+  CFG_GCC_LINK_FLAGS += -m32\n+  CFG_DSYMUTIL := dsymutil\n+  CFG_DEF_SUFFIX := .darwin.def\n+endif\n+\n+ifneq ($(findstring MINGW,$(CFG_OSTYPE)),)\n+  CFG_WINDOWSY := 1\n+endif\n+\n+CFG_LDPATH :=$(CFG_BUILD_DIR)/rt\n+CFG_LDPATH :=$(CFG_LDPATH):$(CFG_BUILD_DIR)/rustllvm\n+CFG_TESTLIB=$(CFG_BUILD_DIR)/$(strip     \\\n+ $(if $(findstring stage0,$(1)),         \\\n+       stage1                            \\\n+      $(if $(findstring stage1,$(1)),    \\\n+           stage2                        \\\n+          $(if $(findstring stage2,$(1)),\\\n+               stage3                    \\\n+               ))))\n+\n+ifdef CFG_WINDOWSY\n+  CFG_INFO := $(info cfg: windows-y environment)\n+\n+  CFG_EXE_SUFFIX := .exe\n+  CFG_LIB_NAME=$(1).dll\n+  CFG_LDPATH :=$(CFG_LDPATH):$(CFG_LLVM_BINDIR)\n+  CFG_LDPATH :=$(CFG_LDPATH):$$PATH\n+  CFG_RUN_TEST=PATH=\"$(CFG_LDPATH):$(call CFG_TESTLIB,$(1))\" $(1)\n+  CFG_RUN_TARG=PATH=\"$(CFG_BUILD_DIR)/$(1):$(CFG_LDPATH)\" $(2)\n+\n+  CFG_PATH_MUNGE := $(strip perl -i.bak -p             \\\n+                           -e 's@\\\\(\\S)@/\\1@go;'       \\\n+                           -e 's@^/([a-zA-Z])/@\\1:/@o;')\n+  ifdef CFG_FLEXLINK\n+    CFG_BOOT_NATIVE := 1\n+  endif\n+  CFG_GCC_CFLAGS += -march=i686 -O2\n+  CFG_GCC_LINK_FLAGS += -shared -fPIC\n+  CFG_DEF_SUFFIX := .def\n+endif\n+\n+ifdef CFG_UNIXY\n+  CFG_INFO := $(info cfg: unix-y environment)\n+\n+  CFG_PATH_MUNGE := true\n+  CFG_EXE_SUFFIX :=\n+  CFG_LDPATH :=$(CFG_LDPATH):$(CFG_LLVM_LIBDIR)\n+  CFG_RUN_TARG=$(CFG_LDENV)=$(CFG_BUILD_DIR)/$(1):$(CFG_LDPATH) $(2)\n+  CFG_RUN_TEST=\\\n+      $(CFG_LDENV)=$(call CFG_TESTLIB,$(1)):$(CFG_LDPATH) \\\n+      $(CFG_VALGRIND) $(1)\n+\n+  CFG_BOOT_NATIVE := 1\n+\n+  ifdef MINGW_CROSS\n+    CFG_EXE_SUFFIX := .exe\n+    CFG_LIB_NAME=$(1).dll\n+    CFG_LDPATH :=$(CFG_LDPATH):$(CFG_LLVM_BINDIR)\n+    CFG_LDPATH :=$(CFG_LDPATH):$$PATH\n+    CFG_RUN_TARG=PATH=$(CFG_BUILD_DIR)/$(1):$(CFG_LDPATH) $(2)\n+    CFG_RUN_TEST=PATH=$(CFG_LDPATH):$(call CFG_TESTLIB,$(1)) $(1)\n+\n+    CFG_INFO := $(info cfg: mingw-cross)\n+    CFG_GCC_CROSS := i586-mingw32msvc-\n+    CFG_BOOT_FLAGS += -t win32-x86-pe\n+    ifdef CFG_VALGRIND\n+      CFG_VALGRIND += wine\n+    endif\n+    CFG_GCC_CFLAGS := -march=i686\n+    CFG_GCC_LINK_FLAGS := -shared\n+    ifeq ($(CFG_CPUTYPE), x86_64)\n+      CFG_GCC_CFLAGS += -m32\n+      CFG_GCC_LINK_FLAGS += -m32\n+    endif\n+  endif\n+  ifdef CFG_VALGRIND\n+    CFG_VALGRIND += --leak-check=full \\\n+                    --error-exitcode=1 \\\n+                    --quiet --vex-iropt-level=0 \\\n+                    --suppressions=$(CFG_SRC_DIR)src/etc/x86.supp\n+  endif\n+endif\n+\n+ifdef CFG_GCC\n+  CFG_INFO := $(info cfg: using gcc)\n+  CFG_GCC_CFLAGS += -Wall -Werror -fno-rtti -fno-exceptions -g\n+  CFG_GCC_LINK_FLAGS += -g\n+  CFG_COMPILE_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_CFLAGS) -c -o $(1) $(2)\n+  CFG_DEPEND_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_CFLAGS) -MT \"$(1)\" -MM $(2)\n+  CFG_LINK_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_LINK_FLAGS) -o $(1) \\\n+               $(CFG_GCC_DEF_FLAG)$(3) $(2)\n+else\n+  CFG_ERR := $(error please try on a system with gcc)\n+endif"}, {"sha": "ad43b616583b1e84742b5093000189a2102c5c42", "filename": "mk/rt.mk", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,97 @@\n+######################################################################\n+# Runtime (C++) library variables\n+######################################################################\n+\n+RUNTIME_CS := rt/sync/timer.cpp \\\n+              rt/sync/sync.cpp \\\n+              rt/sync/lock_and_signal.cpp \\\n+              rt/rust.cpp \\\n+              rt/rust_builtin.cpp \\\n+              rt/rust_run_program.cpp \\\n+              rt/rust_crate.cpp \\\n+              rt/rust_crate_cache.cpp \\\n+              rt/rust_crate_reader.cpp \\\n+              rt/rust_comm.cpp \\\n+              rt/rust_dom.cpp \\\n+              rt/rust_task.cpp \\\n+              rt/rust_task_list.cpp \\\n+              rt/rust_proxy.cpp \\\n+              rt/rust_chan.cpp \\\n+              rt/rust_port.cpp \\\n+              rt/rust_upcall.cpp \\\n+              rt/rust_log.cpp \\\n+              rt/rust_message.cpp \\\n+              rt/rust_timer.cpp \\\n+              rt/circular_buffer.cpp \\\n+              rt/isaac/randport.cpp \\\n+              rt/rust_srv.cpp \\\n+              rt/rust_kernel.cpp \\\n+              rt/memory_region.cpp \\\n+              rt/test/rust_test_harness.cpp \\\n+              rt/test/rust_test_runtime.cpp \\\n+              rt/test/rust_test_util.cpp\n+\n+RUNTIME_HDR := rt/globals.h \\\n+               rt/rust.h \\\n+               rt/rust_dwarf.h \\\n+               rt/rust_internal.h \\\n+               rt/rust_util.h \\\n+               rt/rust_chan.h \\\n+               rt/rust_port.h \\\n+               rt/rust_dom.h \\\n+               rt/rust_task.h \\\n+               rt/rust_task_list.h \\\n+               rt/rust_proxy.h \\\n+               rt/rust_log.h \\\n+               rt/rust_message.h \\\n+               rt/circular_buffer.h \\\n+               rt/util/array_list.h \\\n+               rt/util/indexed_list.h \\\n+               rt/util/synchronized_indexed_list.h \\\n+               rt/util/hash_map.h \\\n+               rt/sync/sync.h \\\n+               rt/sync/timer.h \\\n+               rt/sync/lock_and_signal.h \\\n+               rt/sync/lock_free_queue.h \\\n+               rt/rust_srv.h \\\n+               rt/rust_kernel.h \\\n+               rt/memory_region.h \\\n+               rt/memory.h \\\n+               rt/test/rust_test_harness.h \\\n+               rt/test/rust_test_runtime.h \\\n+               rt/test/rust_test_util.h\n+\n+RUNTIME_DEF := rt/rustrt$(CFG_DEF_SUFFIX)\n+RUNTIME_INCS := -I $(S)src/rt/isaac -I $(S)src/rt/uthash\n+RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o)\n+RUNTIME_LIBS := $(CFG_GCC_POST_LIB_FLAGS)\n+\n+\n+rt/%.o: rt/%.cpp $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n+\n+\n+rt/$(CFG_RUNTIME): $(RUNTIME_OBJS) $(MKFILES) $(RUNTIME_HDR) $(RUNTIME_DEF)\n+\t@$(call E, link: $@)\n+\t$(Q)$(call CFG_LINK_C,$@,$(RUNTIME_LIBS) $(RUNTIME_OBJS),$(RUNTIME_DEF))\n+\n+# These could go in rt.mk or rustllvm.mk, they're needed for both.\n+\n+%.linux.def:    %.def.in $(MKFILES)\n+\t@$(call E, def: $@)\n+\t$(Q)echo \"{\" > $@\n+\t$(Q)sed 's/.$$/&;/' $< >> $@\n+\t$(Q)echo \"};\" >> $@\n+\n+%.darwin.def:\t%.def.in $(MKFILES)\n+\t@$(call E, def: $@)\n+\t$(Q)sed 's/^./_&/' $< > $@\n+\n+ifdef CFG_WINDOWSY\n+%.def:\t%.def.in $(MKFILES)\n+\t@$(call E, def: $@)\n+\t$(Q)echo LIBRARY $* > $@\n+\t$(Q)echo EXPORTS >> $@\n+\t$(Q)sed 's/^./    &/' $< >> $@\n+endif"}, {"sha": "5940bf5e3250564fddd0e23c4087342ccfe49207", "filename": "mk/rustllvm.mk", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,41 @@\n+######################################################################\n+# rustc LLVM-extensions (C++) library variables and rules\n+######################################################################\n+\n+RUSTLLVM_LIB_CS := $(addprefix rustllvm/, \\\n+                     MachOObjectFile.cpp Passes.cpp)\n+\n+RUSTLLVM_OBJS_CS := $(addprefix rustllvm/, RustWrapper.cpp)\n+\n+RUSTLLVM_HDR := rustllvm/include/llvm-c/Object.h\n+RUSTLLVM_DEF := rustllvm/rustllvm$(CFG_DEF_SUFFIX)\n+\n+RUSTLLVM_INCS := -iquote $(CFG_LLVM_INCDIR) \\\n+                 -iquote $(S)src/rustllvm/include\n+RUSTLLVM_LIB_OBJS := $(RUSTLLVM_LIB_CS:.cpp=.o)\n+RUSTLLVM_OBJS_OBJS := $(RUSTLLVM_OBJS_CS:.cpp=.o)\n+\n+\n+# FIXME: Building a .a is a hack so that we build with both older and newer\n+# versions of LLVM. In newer versions some of the bits of this library are\n+# already in LLVM itself, so they are skipped.\n+rustllvm/rustllvmbits.a: $(RUSTLLVM_LIB_OBJS)\n+\trm -f $@\n+\tar crs $@ $^\n+\n+# Note: We pass $(CFG_LLVM_LIBS) twice to fix the windows link since\n+# it has no -whole-archive.\n+rustllvm/$(CFG_RUSTLLVM): rustllvm/rustllvmbits.a $(RUSTLLVM_OBJS_OBJS) \\\n+                          $(MKFILES) $(RUSTLLVM_HDR) $(RUSTLLVM_DEF)\n+\t@$(call E, link: $@)\n+\t$(Q)$(call CFG_LINK_C,$@,$(RUSTLLVM_OBJS_OBJS) \\\n+\t  $(CFG_GCC_PRE_LIB_FLAGS) $(CFG_LLVM_LIBS) \\\n+          $(CFG_GCC_POST_LIB_FLAGS) rustllvm/rustllvmbits.a \\\n+\t  $(CFG_LLVM_LIBS) \\\n+          $(CFG_LLVM_LDFLAGS),$(RUSTLLVM_DEF))\n+\n+\n+rustllvm/%.o: rustllvm/%.cpp $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)$(call CFG_COMPILE_C, $@, $(CFG_LLVM_CXXFLAGS) $(RUSTLLVM_INCS)) $<\n+"}, {"sha": "decf742bf18b041ff7883e2ff45aee56cec15a97", "filename": "mk/stage0.mk", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,9 @@\n+stage0/$(CFG_STDLIB): $(STDLIB_CRATE) $(STDLIB_INPUTS) \\\n+                      boot/rustboot$(X) $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(BOOT) -shared -o $@ $<\n+\n+stage0/rustc$(X): $(COMPILER_CRATE) $(COMPILER_INPUTS) $(BREQ)\n+\t@$(call E, compile: $@)\n+\t$(BOOT) -minimal -o $@ $<\n+\t$(Q)chmod 0755 $@"}, {"sha": "d003134a230c1e6e4b07cb3a51806364bd837454", "filename": "mk/stage1.mk", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fstage1.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fstage1.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage1.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,36 @@\n+stage1/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage0/rustc$(X) $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(STAGE0) -c --shared -o $@ $<\n+\n+stage1/$(CFG_STDLIB): stage1/std.o stage1/glue.o\n+\t@$(call E, link: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage1/glue.o $(CFG_GCC_LINK_FLAGS) -o $@ $< \\\n+\t\t-Lstage1 -Lrt -lrustrt\n+\n+stage1/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ0)\n+\t@$(call E, compile: $@)\n+\t$(STAGE0) -c -o $@ $<\n+\n+stage1/glue.o: stage0/rustc$(X) stage0/$(CFG_STDLIB) \\\n+                rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n+\t@$(call E, generate: $@)\n+\t$(STAGE0) -c -o $@ --glue\n+\n+# Due to make not wanting to run the same implicit rules twice on the same\n+# rule tree (implicit-rule recursion prevention, see \"Chains of Implicit\n+# Rules\" in GNU Make manual) we have to re-state the %.o and %.s patterns here\n+# for different directories, to handle cases where (say) a test relies on a\n+# compiler that relies on a .o file.\n+\n+stage1/%.o: stage1/%.s\n+\t@$(call E, assemble [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) -o $@ -c $<\n+\n+stage1/%$(X): stage1/%.o  $(SREQ0)\n+\t@$(call E, link [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage1/glue.o -o $@ $< \\\n+      -Lstage1 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+\t@# dsymutil sometimes fails or prints a warning, but the\n+\t@# program still runs.  Since it simplifies debugging other\n+\t@# programs, I\\'ll live with the noise.\n+\t-$(Q)$(CFG_DSYMUTIL) $@"}, {"sha": "600d55e4a74c5928df560799219266c1cc3cdd27", "filename": "mk/stage2.mk", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fstage2.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fstage2.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage2.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,36 @@\n+stage2/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage1/rustc$(X) $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(STAGE1) -c --shared -o $@ $<\n+\n+stage2/$(CFG_STDLIB): stage2/std.o stage2/glue.o\n+\t@$(call E, link: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage2/glue.o $(CFG_GCC_LINK_FLAGS) -o $@ $< \\\n+\t\t-Lstage2 -Lrt -lrustrt\n+\n+stage2/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ1)\n+\t@$(call E, compile: $@)\n+\t$(STAGE1) -c -o $@ $<\n+\n+stage2/glue.o: stage1/rustc$(X) stage1/$(CFG_STDLIB) \\\n+                rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n+\t@$(call E, generate: $@)\n+\t$(STAGE1) -c -o $@ --glue\n+\n+# Due to make not wanting to run the same implicit rules twice on the same\n+# rule tree (implicit-rule recursion prevention, see \"Chains of Implicit\n+# Rules\" in GNU Make manual) we have to re-state the %.o and %.s patterns here\n+# for different directories, to handle cases where (say) a test relies on a\n+# compiler that relies on a .o file.\n+\n+stage2/%.o: stage2/%.s\n+\t@$(call E, assemble [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) -o $@ -c $<\n+\n+stage2/%$(X): stage2/%.o  $(SREQ1)\n+\t@$(call E, link [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage2/glue.o -o $@ $< \\\n+      -Lstage2 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+\t@# dsymutil sometimes fails or prints a warning, but the\n+\t@# program still runs.  Since it simplifies debugging other\n+\t@# programs, I\\'ll live with the noise.\n+\t-$(Q)$(CFG_DSYMUTIL) $@"}, {"sha": "8f56637ef53c7b108755e002ea9d183676d90bf9", "filename": "mk/stage3.mk", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fstage3.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Fstage3.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage3.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,36 @@\n+stage3/std.o: $(STDLIB_CRATE) $(STDLIB_INPUTS) stage2/rustc$(X) $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(STAGE2) -c --shared -o $@ $<\n+\n+stage3/$(CFG_STDLIB): stage3/std.o stage3/glue.o\n+\t@$(call E, link: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage3/glue.o $(CFG_GCC_LINK_FLAGS) -o $@ $< \\\n+\t\t-Lstage3 -Lrt -lrustrt\n+\n+stage3/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ2)\n+\t@$(call E, compile: $@)\n+\t$(STAGE2) -c -o $@ $<\n+\n+stage3/glue.o: stage2/rustc$(X) stage2/$(CFG_STDLIB) \\\n+                rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n+\t@$(call E, generate: $@)\n+\t$(STAGE2) -c -o $@ --glue\n+\n+# Due to make not wanting to run the same implicit rules twice on the same\n+# rule tree (implicit-rule recursion prevention, see \"Chains of Implicit\n+# Rules\" in GNU Make manual) we have to re-state the %.o and %.s patterns here\n+# for different directories, to handle cases where (say) a test relies on a\n+# compiler that relies on a .o file.\n+\n+stage3/%.o: stage3/%.s\n+\t@$(call E, assemble [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) -o $@ -c $<\n+\n+stage3/%$(X): stage3/%.o  $(SREQ2)\n+\t@$(call E, link [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage3/glue.o -o $@ $< \\\n+      -Lstage3 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+\t@# dsymutil sometimes fails or prints a warning, but the\n+\t@# program still runs.  Since it simplifies debugging other\n+\t@# programs, I\\'ll live with the noise.\n+\t-$(Q)$(CFG_DSYMUTIL) $@"}, {"sha": "1314c6e581a53e21a0e05ee814f242dcdf16be07", "filename": "mk/tests.mk", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/40624e35d74e5d200ae689c02753f0d60924e668/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=40624e35d74e5d200ae689c02753f0d60924e668", "patch": "@@ -0,0 +1,339 @@\n+######################################################################\n+# Testing variables\n+######################################################################\n+\n+ALL_TEST_INPUTS = $(wildcard $(S)src/test/*/*.rs   \\\n+                              $(S)src/test/*/*/*.rs \\\n+                              $(S)src/test/*/*.rc)\n+\n+TEST_XFAILS_BOOT = $(shell grep -l xfail-boot $(ALL_TEST_INPUTS))\n+TEST_XFAILS_STAGE0 = $(shell grep -l xfail-stage0 $(ALL_TEST_INPUTS))\n+TEST_XFAILS_STAGE1 = $(shell grep -l xfail-stage1 $(ALL_TEST_INPUTS))\n+TEST_XFAILS_STAGE2 = $(shell grep -l xfail-stage2 $(ALL_TEST_INPUTS))\n+\n+ifdef MINGW_CROSS\n+TEST_XFAILS_BOOT += $(S)src/test/run-pass/native-mod.rc\n+TEST_XFAILS_STAGE0 += $(S)src/test/run-pass/native-mod.rc\n+TEST_XFAILS_STAGE1 += $(S)src/test/run-pass/native-mod.rc\n+TEST_XFAILS_STAGE2 += $(S)src/test/run-pass/native-mod.rc\n+endif\n+ifdef CFG_WINDOWSY\n+TEST_XFAILS_BOOT += $(S)src/test/run-pass/native-mod.rc\n+TEST_XFAILS_STAGE0 += $(S)src/test/run-pass/native-mod.rc\n+TEST_XFAILS_STAGE1 += $(S)src/test/run-pass/native-mod.rc\n+TEST_XFAILS_STAGE2 += $(S)src/test/run-pass/native-mod.rc\n+endif\n+\n+BENCH_RS = $(wildcard $(S)src/test/bench/shootout/*.rs) \\\n+            $(wildcard $(S)src/test/bench/99-bottles/*.rs)\n+RPASS_RC = $(wildcard $(S)src/test/run-pass/*.rc)\n+RPASS_RS = $(wildcard $(S)src/test/run-pass/*.rs) $(BENCH_RS)\n+RFAIL_RC = $(wildcard $(S)src/test/run-fail/*.rc)\n+RFAIL_RS = $(wildcard $(S)src/test/run-fail/*.rs)\n+CFAIL_RC = $(wildcard $(S)src/test/compile-fail/*.rc)\n+CFAIL_RS = $(wildcard $(S)src/test/compile-fail/*.rs)\n+\n+ifdef CHECK_XFAILS\n+TEST_RPASS_CRATES_BOOT = $(filter $(TEST_XFAILS_BOOT), $(RPASS_RC))\n+TEST_RPASS_CRATES_STAGE0 = $(filter $(TEST_XFAILS_STAGE0), $(RPASS_RC))\n+TEST_RPASS_CRATES_STAGE1 = $(filter $(TEST_XFAILS_STAGE1), $(RPASS_RC))\n+TEST_RPASS_CRATES_STAGE2 = $(filter $(TEST_XFAILS_STAGE2), $(RPASS_RC))\n+TEST_RPASS_SOURCES_BOOT = $(filter $(TEST_XFAILS_BOOT), $(RPASS_RS))\n+TEST_RPASS_SOURCES_STAGE0 = $(filter $(TEST_XFAILS_STAGE0), $(RPASS_RS))\n+TEST_RPASS_SOURCES_STAGE1 = $(filter $(TEST_XFAILS_STAGE1), $(RPASS_RS))\n+TEST_RPASS_SOURCES_STAGE2 = $(filter $(TEST_XFAILS_STAGE2), $(RPASS_RS))\n+else\n+TEST_RPASS_CRATES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(RPASS_RC))\n+TEST_RPASS_CRATES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(RPASS_RC))\n+TEST_RPASS_CRATES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(RPASS_RC))\n+TEST_RPASS_CRATES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE2), $(RPASS_RC))\n+TEST_RPASS_SOURCES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(RPASS_RS))\n+TEST_RPASS_SOURCES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(RPASS_RS))\n+TEST_RPASS_SOURCES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(RPASS_RS))\n+TEST_RPASS_SOURCES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(RPASS_RS))\n+endif\n+\n+TEST_RPASS_EXES_BOOT = \\\n+  $(subst $(S)src/,,$(TEST_RPASS_CRATES_BOOT:.rc=.boot$(X))) \\\n+  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_BOOT:.rs=.boot$(X)))\n+TEST_RPASS_EXES_STAGE0 = \\\n+  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE0:.rc=.stage0$(X))) \\\n+  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE0:.rs=.stage0$(X)))\n+TEST_RPASS_EXES_STAGE1 = \\\n+  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE1:.rc=.stage1$(X))) \\\n+  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE1:.rs=.stage1$(X)))\n+TEST_RPASS_EXES_STAGE2 = \\\n+  $(subst $(S)src/,,$(TEST_RPASS_CRATES_STAGE1:.rc=.stage2$(X))) \\\n+  $(subst $(S)src/,,$(TEST_RPASS_SOURCES_STAGE1:.rs=.stage2$(X)))\n+\n+TEST_RPASS_OUTS_BOOT  = \\\n+  $(TEST_RPASS_EXES_BOOT:.boot$(X)=.boot.out)\n+TEST_RPASS_OUTS_STAGE0 = \\\n+  $(TEST_RPASS_EXES_STAGE0:.stage0$(X)=.stage0.out)\n+TEST_RPASS_OUTS_STAGE1 = \\\n+  $(TEST_RPASS_EXES_STAGE1:.stage1$(X)=.stage1.out)\n+TEST_RPASS_OUTS_STAGE2 = \\\n+  $(TEST_RPASS_EXES_STAGE2:.stage2$(X)=.stage2.out)\n+\n+TEST_RPASS_TMPS_BOOT  = \\\n+  $(TEST_RPASS_EXES_BOOT:.boot$(X)=.boot$(X).tmp)\n+TEST_RPASS_TMPS_STAGE0 = \\\n+  $(TEST_RPASS_EXES_STAGE0:.stage0$(X)=.stage0$(X).tmp)\n+TEST_RPASS_TMPS_STAGE1 = \\\n+  $(TEST_RPASS_EXES_STAGE1:.stage1$(X)=.stage1$(X).tmp)\n+TEST_RPASS_TMPS_STAGE2 = \\\n+  $(TEST_RPASS_EXES_STAGE2:.stage2$(X)=.stage2$(X).tmp)\n+\n+\n+TEST_RFAIL_CRATES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(RFAIL_RC))\n+TEST_RFAIL_CRATES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(RFAIL_RC))\n+TEST_RFAIL_CRATES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(RFAIL_RC))\n+TEST_RFAIL_CRATES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(RFAIL_RC))\n+TEST_RFAIL_SOURCES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(RFAIL_RS))\n+TEST_RFAIL_SOURCES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(RFAIL_RS))\n+TEST_RFAIL_SOURCES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(RFAIL_RS))\n+TEST_RFAIL_SOURCES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(RFAIL_RS))\n+\n+TEST_RFAIL_EXES_BOOT = \\\n+  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_BOOT:.rc=.boot$(X))) \\\n+  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_BOOT:.rs=.boot$(X)))\n+TEST_RFAIL_EXES_STAGE0 = \\\n+  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE0:.rc=.stage0$(X))) \\\n+  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE0:.rs=.stage0$(X)))\n+TEST_RFAIL_EXES_STAGE1 = \\\n+  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE1:.rc=.stage1$(X))) \\\n+  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE1:.rs=.stage1$(X)))\n+TEST_RFAIL_EXES_STAGE2 = \\\n+  $(subst $(S)src/,,$(TEST_RFAIL_CRATES_STAGE2:.rc=.stage2$(X))) \\\n+  $(subst $(S)src/,,$(TEST_RFAIL_SOURCES_STAGE2:.rs=.stage2$(X)))\n+\n+TEST_RFAIL_OUTS_BOOT  = \\\n+  $(TEST_RFAIL_EXES_BOOT:.boot$(X)=.boot.out)\n+TEST_RFAIL_OUTS_STAGE0 = \\\n+  $(TEST_RFAIL_EXES_STAGE0:.stage0$(X)=.stage0.out)\n+TEST_RFAIL_OUTS_STAGE1 = \\\n+  $(TEST_RFAIL_EXES_STAGE0:.stage1$(X)=.stage1.out)\n+TEST_RFAIL_OUTS_STAGE2 = \\\n+  $(TEST_RFAIL_EXES_STAGE0:.stage2$(X)=.stage2.out)\n+\n+TEST_RFAIL_TMPS_BOOT  = \\\n+  $(TEST_RFAIL_EXES_BOOT:.boot$(X)=.boot$(X).tmp)\n+TEST_RFAIL_TMPS_STAGE0 = \\\n+  $(TEST_RFAIL_EXES_STAGE0:.stage0$(X)=.stage0$(X).tmp)\n+TEST_RFAIL_TMPS_STAGE1 = \\\n+  $(TEST_RFAIL_EXES_STAGE1:.stage1$(X)=.stage1$(X).tmp)\n+TEST_RFAIL_TMPS_STAGE2 = \\\n+  $(TEST_RFAIL_EXES_STAGE2:.stage2$(X)=.stage2$(X).tmp)\n+\n+TEST_CFAIL_CRATES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(CFAIL_RC))\n+TEST_CFAIL_CRATES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(CFAIL_RC))\n+TEST_CFAIL_CRATES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(CFAIL_RC))\n+TEST_CFAIL_CRATES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(CFAIL_RC))\n+TEST_CFAIL_SOURCES_BOOT = $(filter-out $(TEST_XFAILS_BOOT), $(CFAIL_RS))\n+TEST_CFAIL_SOURCES_STAGE0 = $(filter-out $(TEST_XFAILS_STAGE0), $(CFAIL_RS))\n+TEST_CFAIL_SOURCES_STAGE1 = $(filter-out $(TEST_XFAILS_STAGE1), $(CFAIL_RS))\n+TEST_CFAIL_SOURCES_STAGE2 = $(filter-out $(TEST_XFAILS_STAGE2), $(CFAIL_RS))\n+\n+TEST_CFAIL_EXES_BOOT = \\\n+  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_BOOT:.rc=.boot$(X))) \\\n+  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_BOOT:.rs=.boot$(X)))\n+TEST_CFAIL_EXES_STAGE0 = \\\n+  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE0:.rc=.stage0$(X))) \\\n+  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE0:.rs=.stage0$(X)))\n+TEST_CFAIL_EXES_STAGE1 = \\\n+  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE1:.rc=.stage1$(X))) \\\n+  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE1:.rs=.stage1$(X)))\n+TEST_CFAIL_EXES_STAGE2 = \\\n+  $(subst $(S)src/,,$(TEST_CFAIL_CRATES_STAGE2:.rc=.stage2$(X))) \\\n+  $(subst $(S)src/,,$(TEST_CFAIL_SOURCES_STAGE2:.rs=.stage2$(X)))\n+\n+TEST_CFAIL_OUTS_BOOT = \\\n+  $(TEST_CFAIL_EXES_BOOT:.boot$(X)=.boot.out)\n+TEST_CFAIL_OUTS_STAGE0 = \\\n+  $(TEST_CFAIL_EXES_STAGE0:.stage0$(X)=.stage0.out)\n+TEST_CFAIL_OUTS_STAGE1 = \\\n+  $(TEST_CFAIL_EXES_STAGE1:.stage1$(X)=.stage1.out)\n+TEST_CFAIL_OUTS_STAGE2 = \\\n+  $(TEST_CFAIL_EXES_STAGE0:.stage2$(X)=.stage2.out)\n+\n+TEST_CFAIL_TMPS_BOOT = \\\n+  $(TEST_CFAIL_EXES_BOOT:.boot$(X)=.boot$(X).tmp)\n+TEST_CFAIL_TMPS_STAGE0 = \\\n+  $(TEST_CFAIL_EXES_STAGE0:.stage0$(X)=.stage0$(X).tmp)\n+TEST_CFAIL_TMPS_STAGE1 = \\\n+  $(TEST_CFAIL_EXES_STAGE1:.stage1$(X)=.stage1$(X).tmp)\n+TEST_CFAIL_TMPS_STAGE0 = \\\n+  $(TEST_CFAIL_EXES_STAGE2:.stage2$(X)=.stage2$(X).tmp)\n+\n+\n+ALL_TEST_CRATES = $(TEST_CFAIL_CRATES_BOOT) \\\n+                   $(TEST_RFAIL_CRATES_BOOT) \\\n+                   $(TEST_RPASS_CRATES_BOOT) \\\n+                   $(TEST_CFAIL_CRATES_STAGE0) \\\n+                   $(TEST_RFAIL_CRATES_STAGE0) \\\n+                   $(TEST_RPASS_CRATES_STAGE0) \\\n+                   $(TEST_CFAIL_CRATES_STAGE1) \\\n+                   $(TEST_RFAIL_CRATES_STAGE1) \\\n+                   $(TEST_RPASS_CRATES_STAGE1) \\\n+                   $(TEST_CFAIL_CRATES_STAGE2) \\\n+                   $(TEST_RFAIL_CRATES_STAGE2) \\\n+                   $(TEST_RPASS_CRATES_STAGE2)\n+\n+ALL_TEST_SOURCES = $(TEST_CFAIL_SOURCES_BOOT) \\\n+                    $(TEST_RFAIL_SOURCES_BOOT) \\\n+                    $(TEST_RPASS_SOURCES_BOOT) \\\n+                    $(TEST_CFAIL_SOURCES_STAGE0) \\\n+                    $(TEST_RFAIL_SOURCES_STAGE0) \\\n+                    $(TEST_RPASS_SOURCES_STAGE0) \\\n+                    $(TEST_CFAIL_SOURCES_STAGE1) \\\n+                    $(TEST_RFAIL_SOURCES_STAGE1) \\\n+                    $(TEST_RPASS_SOURCES_STAGE1) \\\n+                    $(TEST_CFAIL_SOURCES_STAGE2) \\\n+                    $(TEST_RFAIL_SOURCES_STAGE2) \\\n+                    $(TEST_RPASS_SOURCES_STAGE2)\n+\n+# The test suite currently relies on logging to validate results so\n+# make sure that logging uses the default configuration\n+unexport RUST_LOG\n+\n+\n+check_nocompile: $(TEST_CFAIL_OUTS_BOOT) \\\n+                 $(TEST_CFAIL_OUTS_STAGE0)\n+\n+check: tidy \\\n+       $(TEST_RPASS_EXES_BOOT) $(TEST_RFAIL_EXES_BOOT) \\\n+       $(TEST_RPASS_OUTS_BOOT) $(TEST_RFAIL_OUTS_BOOT) \\\n+       $(TEST_CFAIL_OUTS_BOOT) \\\n+       $(TEST_RPASS_EXES_STAGE0) $(TEST_RFAIL_EXES_STAGE0) \\\n+       $(TEST_RPASS_OUTS_STAGE0) $(TEST_RFAIL_OUTS_STAGE0) \\\n+       $(TEST_CFAIL_OUTS_STAGE0)\n+#       $(TEST_RPASS_EXES_STAGE1) $(TEST_RFAIL_EXES_STAGE1) \\\n+#       $(TEST_RPASS_OUTS_STAGE1) $(TEST_RFAIL_OUTS_STAGE1) \\\n+#       $(TEST_CFAIL_OUTS_STAGE1) \\\n+#       $(TEST_RPASS_EXES_STAGE2) $(TEST_RFAIL_EXES_STAGE2) \\\n+#       $(TEST_RPASS_OUTS_STAGE2) $(TEST_RFAIL_OUTS_STAGE2) \\\n+#       $(TEST_CFAIL_OUTS_STAGE2)\n+\n+\n+compile-check: tidy \\\n+       $(TEST_RPASS_EXES_BOOT) $(TEST_RFAIL_EXES_BOOT) \\\n+       $(TEST_RPASS_EXES_STAGE0) $(TEST_RFAIL_EXES_STAGE0) \\\n+       $(TEST_RPASS_EXES_STAGE1) $(TEST_RFAIL_EXES_STAGE1) \\\n+       $(TEST_RPASS_EXES_STAGE2) $(TEST_RFAIL_EXES_STAGE2)\n+\n+\n+######################################################################\n+# Testing rules\n+######################################################################\n+\n+%.stage0$(X): %.stage0.o  $(SREQ0)\n+\t@$(call E, link [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage1/glue.o -o $@ $< \\\n+      -Lstage1 -Lrt -lrustrt -lstd -lm\n+\t@# dsymutil sometimes fails or prints a warning, but the\n+\t@# program still runs.  Since it simplifies debugging other\n+\t@# programs, I\\'ll live with the noise.\n+\t-$(Q)$(CFG_DSYMUTIL) $@\n+\n+%.stage1$(X): %.stage1.o $(SREQ1)\n+\t@$(call E, link [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage2/glue.o -o $@ $< \\\n+      -Lstage2 -Lrt -lrustrt -lstd -lm\n+\t@# dsymutil sometimes fails or prints a warning, but the\n+\t@# program still runs.  Since it simplifies debugging other\n+\t@# programs, I\\'ll live with the noise.\n+\t-$(Q)$(CFG_DSYMUTIL) $@\n+\n+%.stage2$(X): %.stage2.o $(SREQ2)\n+\t@$(call E, link [gcc]: $@)\n+\t$(Q)gcc $(CFG_GCC_CFLAGS) stage3/glue.o -o $@ $< \\\n+      -Lstage3 -Lrt -lrustrt -lstd -lm\n+\t@# dsymutil sometimes fails or prints a warning, but the\n+\t@# program still runs.  Since it simplifies debugging other\n+\t@# programs, I\\'ll live with the noise.\n+\t-$(Q)$(CFG_DSYMUTIL) $@\n+\n+\n+\n+%.boot$(X): %.rs $(BREQ)\n+\t@$(call E, compile [boot]: $@)\n+\t$(BOOT) -o $@ $<\n+\n+%.boot$(X): %.rc $(BREQ)\n+\t@$(call E, compile [boot]: $@)\n+\t$(BOOT) -o $@ $<\n+\n+%.stage0.o: %.rc $(SREQ0)\n+\t@$(call E, compile [stage0]: $@)\n+\t$(STAGE0) -c -o $@ $<\n+\n+%.stage0.o: %.rs $(SREQ0)\n+\t@$(call E, compile [stage0]: $@)\n+\t$(STAGE0) -c -o $@ $<\n+\n+%.stage1.o: %.rc $(SREQ1)\n+\t@$(call E, compile [stage1]: $@)\n+\t$(STAGE1) -c -o $@ $<\n+\n+%.stage1.o: %.rs $(SREQ1)\n+\t@$(call E, compile [stage1]: $@)\n+\t$(STAGE1) -c -o $@ $<\n+\n+%.stage2.o: %.rc $(SREQ2)\n+\t@$(call E, compile [stage2]: $@)\n+\t$(STAGE2) -c -o $@ $<\n+\n+%.stage2.o: %.rs $(SREQ2)\n+\t@$(call E, compile [stage2]: $@)\n+\t$(STAGE2) -c -o $@ $<\n+\n+# Cancel the implicit .out rule in GNU make.\n+%.out: %\n+\n+%.out: %.out.tmp\n+\t$(Q)mv $< $@\n+\n+test/run-pass/%.out.tmp: test/run-pass/%$(X) rt/$(CFG_RUNTIME)\n+\t$(Q)rm -f $<.tmp\n+\t@$(call E, run: $@)\n+\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n+\n+test/bench/shootout/%.out.tmp: test/bench/shootout/%$(X) \\\n+                               rt/$(CFG_RUNTIME)\n+\t$(Q)rm -f $<.tmp\n+\t@$(call E, run: $@)\n+\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n+\n+test/bench/99-bottles/%.out.tmp: test/bench/99-bottles/%$(X) \\\n+                                 rt/$(CFG_RUNTIME)\n+\t$(Q)rm -f $<.tmp\n+\t@$(call E, run: $@)\n+\t$(Q)$(call CFG_RUN_TEST, $<) > $@\n+\n+test/run-fail/%.out.tmp: test/run-fail/%$(X) \\\n+                         rt/$(CFG_RUNTIME)\n+\t$(Q)rm -f $<.tmp\n+\t@$(call E, run: $@)\n+\t$(Q)grep -q error-pattern $(S)src/test/run-fail/$(basename $*).rs\n+\t$(Q)rm -f $@\n+\t$(Q)$(call CFG_RUN_TEST, $<) >$@ 2>&1 ; X=$$? ; \\\n+      if [ $$X -eq 0 ] ; then exit 1 ; else exit 0 ; fi\n+\t$(Q)grep --text --quiet \\\n+      \"$$(grep error-pattern $(S)src/test/run-fail/$(basename $*).rs \\\n+        | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n+\n+test/compile-fail/%.boot.out.tmp: test/compile-fail/%.rs $(BREQ)\n+\t@$(call E, compile [boot]: $@)\n+\t$(Q)grep -q error-pattern $<\n+\t$(Q)rm -f $@\n+\t$(BOOT) -o $(@:.out=$(X)) $< >$@ 2>&1; test $$? -ne 0\n+\t$(Q)grep --text --quiet \\\n+      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@\n+\n+test/compile-fail/%.stage0.out.tmp: test/compile-fail/%.rs $(SREQ0)\n+\t@$(call E, compile [stage0]: $@)\n+\t$(Q)grep -q error-pattern $<\n+\t$(Q)rm -f $@\n+\t$(STAGE0) -o $(@:.out=$(X)) $< >$@ 2>&1; test $$? -ne 0\n+\t$(Q)grep --text --quiet \\\n+      \"$$(grep error-pattern $< | cut -d : -f 2- | tr -d '\\n\\r')\" $@"}]}