{"sha": "6889d096a905a417e1e61b6d10b803260f157f04", "node_id": "C_kwDOAAsO6NoAKDY4ODlkMDk2YTkwNWE0MTdlMWU2MWI2ZDEwYjgwMzI2MGYxNTdmMDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-11T17:39:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-11T17:39:25Z"}, "message": "Auto merge of #8726 - Serial-ATA:issue-8723, r=dswij,xFrednet\n\nFix `match_single_binding` suggestion for assign expressions\n\nchangelog: Fix suggestion for assign expressions in [`match_single_binding`]\ncloses: #8723", "tree": {"sha": "41a415ef170cdd17080526c7fe0cfdcb3a633b64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41a415ef170cdd17080526c7fe0cfdcb3a633b64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6889d096a905a417e1e61b6d10b803260f157f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6889d096a905a417e1e61b6d10b803260f157f04", "html_url": "https://github.com/rust-lang/rust/commit/6889d096a905a417e1e61b6d10b803260f157f04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6889d096a905a417e1e61b6d10b803260f157f04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d422baa30c415e6aed786f1953b0ac1b7d840dc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d422baa30c415e6aed786f1953b0ac1b7d840dc1", "html_url": "https://github.com/rust-lang/rust/commit/d422baa30c415e6aed786f1953b0ac1b7d840dc1"}, {"sha": "554dc41ceac0f4a625fc344e9248e7e1dae11378", "url": "https://api.github.com/repos/rust-lang/rust/commits/554dc41ceac0f4a625fc344e9248e7e1dae11378", "html_url": "https://github.com/rust-lang/rust/commit/554dc41ceac0f4a625fc344e9248e7e1dae11378"}], "stats": {"total": 242, "additions": 178, "deletions": 64}, "files": [{"sha": "a59711d4cace5f7b17b0a4f3bf8675cfb9ca4c80", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "modified", "additions": 120, "deletions": 53, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/6889d096a905a417e1e61b6d10b803260f157f04/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6889d096a905a417e1e61b6d10b803260f157f04/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=6889d096a905a417e1e61b6d10b803260f157f04", "patch": "@@ -1,15 +1,22 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{indent_of, snippet_block, snippet_with_applicability};\n+use clippy_utils::macros::HirNode;\n+use clippy_utils::source::{indent_of, snippet, snippet_block, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{get_parent_expr, is_refutable, peel_blocks};\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, Expr, ExprKind, Local, Node, PatKind};\n+use rustc_hir::{Arm, Expr, ExprKind, Node, PatKind};\n use rustc_lint::LateContext;\n+use rustc_span::Span;\n \n use super::MATCH_SINGLE_BINDING;\n \n+enum AssignmentExpr {\n+    Assign { span: Span, match_span: Span },\n+    Local { span: Span, pat_span: Span },\n+}\n+\n #[expect(clippy::too_many_lines)]\n-pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'a>) {\n     if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n     }\n@@ -42,61 +49,59 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n     let mut applicability = Applicability::MaybeIncorrect;\n     match arms[0].pat.kind {\n         PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n-            // If this match is in a local (`let`) stmt\n-            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n-                (\n-                    parent_let_node.span,\n+            let (target_span, sugg) = match opt_parent_assign_span(cx, ex) {\n+                Some(AssignmentExpr::Assign { span, match_span }) => {\n+                    let sugg = sugg_with_curlies(\n+                        cx,\n+                        (ex, expr),\n+                        (bind_names, matched_vars),\n+                        &*snippet_body,\n+                        &mut applicability,\n+                        Some(span),\n+                    );\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        MATCH_SINGLE_BINDING,\n+                        span.to(match_span),\n+                        \"this assignment could be simplified\",\n+                        \"consider removing the `match` expression\",\n+                        sugg,\n+                        applicability,\n+                    );\n+\n+                    return;\n+                },\n+                Some(AssignmentExpr::Local { span, pat_span }) => (\n+                    span,\n                     format!(\n                         \"let {} = {};\\n{}let {} = {};\",\n                         snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n                         snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n                         \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n-                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, pat_span, \"..\", &mut applicability),\n                         snippet_body\n                     ),\n-                )\n-            } else {\n-                // If we are in closure, we need curly braces around suggestion\n-                let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n-                let (mut cbrace_start, mut cbrace_end) = (\"\".to_string(), \"\".to_string());\n-                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n-                    if let ExprKind::Closure(..) = parent_expr.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the closure\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                // If the parent is already an arm, and the body is another match statement,\n-                // we need curly braces around suggestion\n-                let parent_node_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n-                if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n-                    if let ExprKind::Match(..) = arm.body.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the match\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                (\n-                    expr.span,\n-                    format!(\n-                        \"{}let {} = {};\\n{}{}{}\",\n-                        cbrace_start,\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        indent,\n-                        snippet_body,\n-                        cbrace_end\n-                    ),\n-                )\n+                ),\n+                None => {\n+                    let sugg = sugg_with_curlies(\n+                        cx,\n+                        (ex, expr),\n+                        (bind_names, matched_vars),\n+                        &*snippet_body,\n+                        &mut applicability,\n+                        None,\n+                    );\n+                    (expr.span, sugg)\n+                },\n             };\n+\n             span_lint_and_sugg(\n                 cx,\n                 MATCH_SINGLE_BINDING,\n                 target_span,\n                 \"this match could be written as a `let` statement\",\n-                \"consider using `let` statement\",\n+                \"consider using a `let` statement\",\n                 sugg,\n                 applicability,\n             );\n@@ -110,6 +115,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                     indent,\n                     snippet_body\n                 );\n+\n                 span_lint_and_sugg(\n                     cx,\n                     MATCH_SINGLE_BINDING,\n@@ -135,15 +141,76 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n     }\n }\n \n-/// Returns true if the `ex` match expression is in a local (`let`) statement\n-fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n+/// Returns true if the `ex` match expression is in a local (`let`) or assign expression\n+fn opt_parent_assign_span<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<AssignmentExpr> {\n     let map = &cx.tcx.hir();\n-    if_chain! {\n-        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n-        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n-        then {\n-            return Some(parent_let_expr);\n-        }\n+\n+    if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id)) {\n+        return match map.find(map.get_parent_node(parent_arm_expr.hir_id)) {\n+            Some(Node::Local(parent_let_expr)) => Some(AssignmentExpr::Local {\n+                span: parent_let_expr.span,\n+                pat_span: parent_let_expr.pat.span(),\n+            }),\n+            Some(Node::Expr(Expr {\n+                kind: ExprKind::Assign(parent_assign_expr, match_expr, _),\n+                ..\n+            })) => Some(AssignmentExpr::Assign {\n+                span: parent_assign_expr.span,\n+                match_span: match_expr.span,\n+            }),\n+            _ => None,\n+        };\n     }\n+\n     None\n }\n+\n+fn sugg_with_curlies<'a>(\n+    cx: &LateContext<'a>,\n+    (ex, match_expr): (&Expr<'a>, &Expr<'a>),\n+    (bind_names, matched_vars): (Span, Span),\n+    snippet_body: &str,\n+    applicability: &mut Applicability,\n+    assignment: Option<Span>,\n+) -> String {\n+    let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n+\n+    let (mut cbrace_start, mut cbrace_end) = (String::new(), String::new());\n+    if let Some(parent_expr) = get_parent_expr(cx, match_expr) {\n+        if let ExprKind::Closure(..) = parent_expr.kind {\n+            cbrace_end = format!(\"\\n{}}}\", indent);\n+            // Fix body indent due to the closure\n+            indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+            cbrace_start = format!(\"{{\\n{}\", indent);\n+        }\n+    }\n+\n+    // If the parent is already an arm, and the body is another match statement,\n+    // we need curly braces around suggestion\n+    let parent_node_id = cx.tcx.hir().get_parent_node(match_expr.hir_id);\n+    if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n+        if let ExprKind::Match(..) = arm.body.kind {\n+            cbrace_end = format!(\"\\n{}}}\", indent);\n+            // Fix body indent due to the match\n+            indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+            cbrace_start = format!(\"{{\\n{}\", indent);\n+        }\n+    }\n+\n+    let assignment_str = assignment.map_or_else(String::new, |span| {\n+        let mut s = snippet(cx, span, \"..\").to_string();\n+        s.push_str(\" = \");\n+        s\n+    });\n+\n+    format!(\n+        \"{}let {} = {};\\n{}{}{}{}\",\n+        cbrace_start,\n+        snippet_with_applicability(cx, bind_names, \"..\", applicability),\n+        snippet_with_applicability(cx, matched_vars, \"..\", applicability),\n+        indent,\n+        assignment_str,\n+        snippet_body,\n+        cbrace_end\n+    )\n+}"}, {"sha": "de46e6cff55ba2c773cc747d02e1157d749d9bf5", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6889d096a905a417e1e61b6d10b803260f157f04/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6889d096a905a417e1e61b6d10b803260f157f04/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=6889d096a905a417e1e61b6d10b803260f157f04", "patch": "@@ -111,3 +111,16 @@ fn main() {\n     let x = 1;\n     println!(\"Not an array index start\");\n }\n+\n+#[allow(dead_code)]\n+fn issue_8723() {\n+    let (mut val, idx) = (\"a b\", 1);\n+\n+    let (pre, suf) = val.split_at(idx);\n+    val = {\n+        println!(\"{}\", pre);\n+        suf\n+    };\n+\n+    let _ = val;\n+}"}, {"sha": "eea64fcb292b88602e3af07fc2ed08a42f3c808d", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6889d096a905a417e1e61b6d10b803260f157f04/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6889d096a905a417e1e61b6d10b803260f157f04/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=6889d096a905a417e1e61b6d10b803260f157f04", "patch": "@@ -126,3 +126,17 @@ fn main() {\n         _ => println!(\"Not an array index start\"),\n     }\n }\n+\n+#[allow(dead_code)]\n+fn issue_8723() {\n+    let (mut val, idx) = (\"a b\", 1);\n+\n+    val = match val.split_at(idx) {\n+        (pre, suf) => {\n+            println!(\"{}\", pre);\n+            suf\n+        },\n+    };\n+\n+    let _ = val;\n+}"}, {"sha": "5d4e7314b2137b9bf96fff539596dfa74b22e944", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6889d096a905a417e1e61b6d10b803260f157f04/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6889d096a905a417e1e61b6d10b803260f157f04/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=6889d096a905a417e1e61b6d10b803260f157f04", "patch": "@@ -9,7 +9,7 @@ LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::match-single-binding` implied by `-D warnings`\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~     let (x, y, z) = (a, b, c);\n LL +     {\n@@ -25,7 +25,7 @@ LL | |         (x, y, z) => println!(\"{} {} {}\", x, y, z),\n LL | |     }\n    | |_____^\n    |\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~     let (x, y, z) = (a, b, c);\n LL +     println!(\"{} {} {}\", x, y, z);\n@@ -88,7 +88,7 @@ LL | |         Point { x, y } => println!(\"Coords: ({}, {})\", x, y),\n LL | |     }\n    | |_____^\n    |\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~     let Point { x, y } = p;\n LL +     println!(\"Coords: ({}, {})\", x, y);\n@@ -102,7 +102,7 @@ LL | |         Point { x: x1, y: y1 } => println!(\"Coords: ({}, {})\", x1, y1),\n LL | |     }\n    | |_____^\n    |\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~     let Point { x: x1, y: y1 } = p;\n LL +     println!(\"Coords: ({}, {})\", x1, y1);\n@@ -116,7 +116,7 @@ LL | |         ref r => println!(\"Got a reference to {}\", r),\n LL | |     }\n    | |_____^\n    |\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~     let ref r = x;\n LL +     println!(\"Got a reference to {}\", r);\n@@ -130,7 +130,7 @@ LL | |         ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n LL | |     }\n    | |_____^\n    |\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~     let ref mut mr = x;\n LL +     println!(\"Got a mutable reference to {}\", mr);\n@@ -144,7 +144,7 @@ LL | |         Point { x, y } => x * y,\n LL | |     };\n    | |______^\n    |\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~     let Point { x, y } = coords();\n LL +     let product = x * y;\n@@ -159,7 +159,7 @@ LL | |             unwrapped => unwrapped,\n LL | |         })\n    | |_________^\n    |\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~         .map(|i| {\n LL +             let unwrapped = i.unwrap();\n@@ -176,5 +176,25 @@ LL | |         _ => println!(\"Not an array index start\"),\n LL | |     }\n    | |_____^ help: consider using the match body instead: `println!(\"Not an array index start\");`\n \n-error: aborting due to 12 previous errors\n+error: this assignment could be simplified\n+  --> $DIR/match_single_binding.rs:134:5\n+   |\n+LL | /     val = match val.split_at(idx) {\n+LL | |         (pre, suf) => {\n+LL | |             println!(\"{}\", pre);\n+LL | |             suf\n+LL | |         },\n+LL | |     };\n+   | |_____^\n+   |\n+help: consider removing the `match` expression\n+   |\n+LL ~     let (pre, suf) = val.split_at(idx);\n+LL +     val = {\n+LL +         println!(\"{}\", pre);\n+LL +         suf\n+LL ~     };\n+   |\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "22bf7d8be4a297f8c4b95162b3a18db283bd11e7", "filename": "tests/ui/match_single_binding2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6889d096a905a417e1e61b6d10b803260f157f04/tests%2Fui%2Fmatch_single_binding2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6889d096a905a417e1e61b6d10b803260f157f04/tests%2Fui%2Fmatch_single_binding2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding2.stderr?ref=6889d096a905a417e1e61b6d10b803260f157f04", "patch": "@@ -8,7 +8,7 @@ LL | |             },\n    | |_____________^\n    |\n    = note: `-D clippy::match-single-binding` implied by `-D warnings`\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~             Some((iter, _item)) => {\n LL +                 let (min, max) = iter.size_hint();\n@@ -24,7 +24,7 @@ LL | |                 (a, b) => println!(\"a {:?} and b {:?}\", a, b),\n LL | |             }\n    | |_____________^\n    |\n-help: consider using `let` statement\n+help: consider using a `let` statement\n    |\n LL ~             let (a, b) = get_tup();\n LL +             println!(\"a {:?} and b {:?}\", a, b);"}]}