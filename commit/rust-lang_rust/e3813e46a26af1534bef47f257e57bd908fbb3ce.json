{"sha": "e3813e46a26af1534bef47f257e57bd908fbb3ce", "node_id": "C_kwDOAAsO6NoAKGUzODEzZTQ2YTI2YWYxNTM0YmVmNDdmMjU3ZTU3YmQ5MDhmYmIzY2U", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-27T03:15:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-27T03:15:07Z"}, "message": "Rollup merge of #96051 - newpavlov:duration_rounding, r=nagisa,joshtriplett\n\nUse rounding in float to Duration conversion methods\n\nCloses #96045", "tree": {"sha": "fe4a84a98022ab5bdb60660e59934b4780146615", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe4a84a98022ab5bdb60660e59934b4780146615"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3813e46a26af1534bef47f257e57bd908fbb3ce", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJikEI7CRBK7hj4Ov3rIwAAk4QIAALFQrAGKKNYkiWd0wCuQk+a\n6B+DTwF1jYAU891kTQ07Sh4ecq4h7/gxOLSCAPvK5H4r2v+uSmrc4Q5IU/+WDeg8\nt1w2ZD+DymxsVYKNIAu2p0iYgBP3of/hhk7s+SpvDDCkdiRbGEG/gdG7YmuARZnU\nOXBEZSoP3jjVvSGDm9IumzIPoXW0c3bTlfpRHwtTmzaUVI+1zd7t4RZR1fWpMK03\nLbNG3/mJZdkpGA1Z9qBaSqAWGCRLslW3kEFegR8h0TUq3VAMfi2W6Ov3n7TIwTSW\nKwnMUnHXXQ+97DJzgJvWpGSd85Qk7wT2VpqgPMf/dp+j8nXvTBTj1Nd6VrkWfWA=\n=38vK\n-----END PGP SIGNATURE-----\n", "payload": "tree fe4a84a98022ab5bdb60660e59934b4780146615\nparent b2c9872c6c2c60c905e16bce0801934b86d15f95\nparent 6495963d5a2d3e36ce799cfb932aa1a4b080f262\nauthor Michael Goulet <michael@errs.io> 1653621307 -0700\ncommitter GitHub <noreply@github.com> 1653621307 -0700\n\nRollup merge of #96051 - newpavlov:duration_rounding, r=nagisa,joshtriplett\n\nUse rounding in float to Duration conversion methods\n\nCloses #96045\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3813e46a26af1534bef47f257e57bd908fbb3ce", "html_url": "https://github.com/rust-lang/rust/commit/e3813e46a26af1534bef47f257e57bd908fbb3ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3813e46a26af1534bef47f257e57bd908fbb3ce/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2c9872c6c2c60c905e16bce0801934b86d15f95", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c9872c6c2c60c905e16bce0801934b86d15f95", "html_url": "https://github.com/rust-lang/rust/commit/b2c9872c6c2c60c905e16bce0801934b86d15f95"}, {"sha": "6495963d5a2d3e36ce799cfb932aa1a4b080f262", "url": "https://api.github.com/repos/rust-lang/rust/commits/6495963d5a2d3e36ce799cfb932aa1a4b080f262", "html_url": "https://github.com/rust-lang/rust/commit/6495963d5a2d3e36ce799cfb932aa1a4b080f262"}], "stats": {"total": 136, "additions": 109, "deletions": 27}, "files": [{"sha": "756f1a1663ca718e227732ab7ae1b2a5234ae67d", "filename": "library/core/src/time.rs", "status": "modified", "additions": 109, "deletions": 27, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e3813e46a26af1534bef47f257e57bd908fbb3ce/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3813e46a26af1534bef47f257e57bd908fbb3ce/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=e3813e46a26af1534bef47f257e57bd908fbb3ce", "patch": "@@ -730,9 +730,9 @@ impl Duration {\n     /// // subnormal float\n     /// let res = Duration::from_secs_f64(f64::from_bits(1));\n     /// assert_eq!(res, Duration::new(0, 0));\n-    /// // conversion uses truncation, not rounding\n+    /// // conversion uses rounding\n     /// let res = Duration::from_secs_f64(0.999e-9);\n-    /// assert_eq!(res, Duration::new(0, 0));\n+    /// assert_eq!(res, Duration::new(0, 1));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -760,17 +760,17 @@ impl Duration {\n     /// let res = Duration::from_secs_f32(1e-20);\n     /// assert_eq!(res, Duration::new(0, 0));\n     /// let res = Duration::from_secs_f32(4.2e-7);\n-    /// assert_eq!(res, Duration::new(0, 419));\n+    /// assert_eq!(res, Duration::new(0, 420));\n     /// let res = Duration::from_secs_f32(2.7);\n-    /// assert_eq!(res, Duration::new(2, 700_000_047));\n+    /// assert_eq!(res, Duration::new(2, 700_000_048));\n     /// let res = Duration::from_secs_f32(3e10);\n     /// assert_eq!(res, Duration::new(30_000_001_024, 0));\n     /// // subnormal float\n     /// let res = Duration::from_secs_f32(f32::from_bits(1));\n     /// assert_eq!(res, Duration::new(0, 0));\n-    /// // conversion uses truncation, not rounding\n+    /// // conversion uses rounding\n     /// let res = Duration::from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Duration::new(0, 0));\n+    /// assert_eq!(res, Duration::new(0, 1));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -815,7 +815,7 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n-    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n+    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_641));\n     /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847800, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n@@ -838,8 +838,7 @@ impl Duration {\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n     /// assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));\n-    /// // note that truncation is used, not rounding\n-    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_598));\n+    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_599));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n@@ -862,9 +861,8 @@ impl Duration {\n     /// let dur = Duration::new(2, 700_000_000);\n     /// // note that due to rounding errors result is slightly\n     /// // different from 0.859_872_611\n-    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_579));\n-    /// // note that truncation is used, not rounding\n-    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n+    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_580));\n+    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_599));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n@@ -1272,19 +1270,53 @@ macro_rules! try_from_secs {\n         let mant = (bits & MANT_MASK) | (MANT_MASK + 1);\n         let exp = ((bits >> $mant_bits) & EXP_MASK) as i16 + MIN_EXP;\n \n-        let (secs, nanos) = if exp < -30 {\n-            // the input represents less than 1ns.\n+        let (secs, nanos) = if exp < -31 {\n+            // the input represents less than 1ns and can not be rounded to it\n             (0u64, 0u32)\n         } else if exp < 0 {\n             // the input is less than 1 second\n             let t = <$double_ty>::from(mant) << ($offset + exp);\n-            let nanos = (u128::from(NANOS_PER_SEC) * u128::from(t)) >> ($mant_bits + $offset);\n-            (0, nanos as u32)\n+            let nanos_offset = $mant_bits + $offset;\n+            let nanos_tmp = u128::from(NANOS_PER_SEC) * u128::from(t);\n+            let nanos = (nanos_tmp >> nanos_offset) as u32;\n+\n+            let rem_mask = (1 << nanos_offset) - 1;\n+            let rem_msb_mask = 1 << (nanos_offset - 1);\n+            let rem = nanos_tmp & rem_mask;\n+            let is_tie = rem == rem_msb_mask;\n+            let is_even = (nanos & 1) == 0;\n+            let rem_msb = nanos_tmp & rem_msb_mask == 0;\n+            let add_ns = !(rem_msb || (is_even && is_tie));\n+\n+            // f32 does not have enough presicion to trigger the second branch\n+            // since it can not represent numbers between 0.999_999_940_395 and 1.0.\n+            let nanos = nanos + add_ns as u32;\n+            if ($mant_bits == 23) || (nanos != NANOS_PER_SEC) { (0, nanos) } else { (1, 0) }\n         } else if exp < $mant_bits {\n-            let secs = mant >> ($mant_bits - exp);\n+            let secs = u64::from(mant >> ($mant_bits - exp));\n             let t = <$double_ty>::from((mant << exp) & MANT_MASK);\n-            let nanos = (<$double_ty>::from(NANOS_PER_SEC) * t) >> $mant_bits;\n-            (u64::from(secs), nanos as u32)\n+            let nanos_offset = $mant_bits;\n+            let nanos_tmp = <$double_ty>::from(NANOS_PER_SEC) * t;\n+            let nanos = (nanos_tmp >> nanos_offset) as u32;\n+\n+            let rem_mask = (1 << nanos_offset) - 1;\n+            let rem_msb_mask = 1 << (nanos_offset - 1);\n+            let rem = nanos_tmp & rem_mask;\n+            let is_tie = rem == rem_msb_mask;\n+            let is_even = (nanos & 1) == 0;\n+            let rem_msb = nanos_tmp & rem_msb_mask == 0;\n+            let add_ns = !(rem_msb || (is_even && is_tie));\n+\n+            // f32 does not have enough presicion to trigger the second branch.\n+            // For example, it can not represent numbers between 1.999_999_880...\n+            // and 2.0. Bigger values result in even smaller presicion of the\n+            // fractional part.\n+            let nanos = nanos + add_ns as u32;\n+            if ($mant_bits == 23) || (nanos != NANOS_PER_SEC) {\n+                (secs, nanos)\n+            } else {\n+                (secs + 1, 0)\n+            }\n         } else if exp < 64 {\n             // the input has no fractional part\n             let secs = u64::from(mant) << (exp - $mant_bits);\n@@ -1315,24 +1347,45 @@ impl Duration {\n     /// let res = Duration::try_from_secs_f32(1e-20);\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n     /// let res = Duration::try_from_secs_f32(4.2e-7);\n-    /// assert_eq!(res, Ok(Duration::new(0, 419)));\n+    /// assert_eq!(res, Ok(Duration::new(0, 420)));\n     /// let res = Duration::try_from_secs_f32(2.7);\n-    /// assert_eq!(res, Ok(Duration::new(2, 700_000_047)));\n+    /// assert_eq!(res, Ok(Duration::new(2, 700_000_048)));\n     /// let res = Duration::try_from_secs_f32(3e10);\n     /// assert_eq!(res, Ok(Duration::new(30_000_001_024, 0)));\n     /// // subnormal float:\n     /// let res = Duration::try_from_secs_f32(f32::from_bits(1));\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n-    /// // conversion uses truncation, not rounding\n-    /// let res = Duration::try_from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n     ///\n     /// let res = Duration::try_from_secs_f32(-5.0);\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f32(f32::NAN);\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f32(2e19);\n     /// assert!(res.is_err());\n+    ///\n+    /// // the conversion uses rounding with tie resolution to even\n+    /// let res = Duration::try_from_secs_f32(0.999e-9);\n+    /// assert_eq!(res, Ok(Duration::new(0, 1)));\n+    ///\n+    /// // this float represents exactly 976562.5e-9\n+    /// let val = f32::from_bits(0x3A80_0000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 976_562)));\n+    ///\n+    /// // this float represents exactly 2929687.5e-9\n+    /// let val = f32::from_bits(0x3B40_0000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 2_929_688)));\n+    ///\n+    /// // this float represents exactly 1.000_976_562_5\n+    /// let val = f32::from_bits(0x3F802000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 976_562)));\n+    ///\n+    /// // this float represents exactly 1.002_929_687_5\n+    /// let val = f32::from_bits(0x3F806000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n     #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n     #[inline]\n@@ -1372,16 +1425,45 @@ impl Duration {\n     /// // subnormal float\n     /// let res = Duration::try_from_secs_f64(f64::from_bits(1));\n     /// assert_eq!(res, Ok(Duration::new(0, 0)));\n-    /// // conversion uses truncation, not rounding\n-    /// let res = Duration::try_from_secs_f32(0.999e-9);\n-    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n     ///\n     /// let res = Duration::try_from_secs_f64(-5.0);\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f64(f64::NAN);\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f64(2e19);\n     /// assert!(res.is_err());\n+    ///\n+    /// // the conversion uses rounding with tie resolution to even\n+    /// let res = Duration::try_from_secs_f64(0.999e-9);\n+    /// assert_eq!(res, Ok(Duration::new(0, 1)));\n+    /// let res = Duration::try_from_secs_f64(0.999_999_999_499);\n+    /// assert_eq!(res, Ok(Duration::new(0, 999_999_999)));\n+    /// let res = Duration::try_from_secs_f64(0.999_999_999_501);\n+    /// assert_eq!(res, Ok(Duration::new(1, 0)));\n+    /// let res = Duration::try_from_secs_f64(42.999_999_999_499);\n+    /// assert_eq!(res, Ok(Duration::new(42, 999_999_999)));\n+    /// let res = Duration::try_from_secs_f64(42.999_999_999_501);\n+    /// assert_eq!(res, Ok(Duration::new(43, 0)));\n+    ///\n+    /// // this float represents exactly 976562.5e-9\n+    /// let val = f64::from_bits(0x3F50_0000_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 976_562)));\n+    ///\n+    /// // this float represents exactly 2929687.5e-9\n+    /// let val = f64::from_bits(0x3F68_0000_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 2_929_688)));\n+    ///\n+    /// // this float represents exactly 1.000_976_562_5\n+    /// let val = f64::from_bits(0x3FF0_0400_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 976_562)));\n+    ///\n+    /// // this float represents exactly 1.002_929_687_5\n+    /// let val = f64::from_bits(0x3_FF00_C000_0000_000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n     #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n     #[inline]"}]}