{"sha": "65f35781489ccaa66585b91f215308f3091bf404", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZjM1NzgxNDg5Y2NhYTY2NTg1YjkxZjIxNTMwOGYzMDkxYmY0MDQ=", "commit": {"author": {"name": "David Manescu", "email": "david.manescu@gmail.com", "date": "2014-01-31T13:03:20Z"}, "committer": {"name": "David Manescu", "email": "david.manescu@gmail.com", "date": "2014-02-04T01:33:41Z"}, "message": "Rename reserve to reserve_exact and reserve_at_least to reserve\n\nChanges in std::{str,vec,hashmap} and extra::{priority_queue,ringbuf}.\nFixes #11949", "tree": {"sha": "d83c8f842c730c0034301eda1621636ffa896bfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d83c8f842c730c0034301eda1621636ffa896bfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65f35781489ccaa66585b91f215308f3091bf404", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65f35781489ccaa66585b91f215308f3091bf404", "html_url": "https://github.com/rust-lang/rust/commit/65f35781489ccaa66585b91f215308f3091bf404", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65f35781489ccaa66585b91f215308f3091bf404/comments", "author": {"login": "dmanescu", "id": 5207313, "node_id": "MDQ6VXNlcjUyMDczMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5207313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmanescu", "html_url": "https://github.com/dmanescu", "followers_url": "https://api.github.com/users/dmanescu/followers", "following_url": "https://api.github.com/users/dmanescu/following{/other_user}", "gists_url": "https://api.github.com/users/dmanescu/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmanescu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmanescu/subscriptions", "organizations_url": "https://api.github.com/users/dmanescu/orgs", "repos_url": "https://api.github.com/users/dmanescu/repos", "events_url": "https://api.github.com/users/dmanescu/events{/privacy}", "received_events_url": "https://api.github.com/users/dmanescu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dmanescu", "id": 5207313, "node_id": "MDQ6VXNlcjUyMDczMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5207313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmanescu", "html_url": "https://github.com/dmanescu", "followers_url": "https://api.github.com/users/dmanescu/followers", "following_url": "https://api.github.com/users/dmanescu/following{/other_user}", "gists_url": "https://api.github.com/users/dmanescu/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmanescu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmanescu/subscriptions", "organizations_url": "https://api.github.com/users/dmanescu/orgs", "repos_url": "https://api.github.com/users/dmanescu/repos", "events_url": "https://api.github.com/users/dmanescu/events{/privacy}", "received_events_url": "https://api.github.com/users/dmanescu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d494198bbb9701b6336febcf9d0ceb39e4b7975", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d494198bbb9701b6336febcf9d0ceb39e4b7975", "html_url": "https://github.com/rust-lang/rust/commit/1d494198bbb9701b6336febcf9d0ceb39e4b7975"}], "stats": {"total": 104, "additions": 51, "deletions": 53}, "files": [{"sha": "3ae3dae9ea30703b250162f30cedbe06c05e70f9", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=65f35781489ccaa66585b91f215308f3091bf404", "patch": "@@ -51,10 +51,14 @@ impl<T:Ord> PriorityQueue<T> {\n     /// Returns the number of elements the queue can hold without reallocating\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    pub fn reserve(&mut self, n: uint) { self.data.reserve(n) }\n-\n-    pub fn reserve_at_least(&mut self, n: uint) {\n-        self.data.reserve_at_least(n)\n+    /// Reserve capacity for exactly n elements in the PriorityQueue.\n+    /// Do nothing if the capacity is already sufficient.\n+    pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n+\n+    /// Reserve capacity for at least n elements in the PriorityQueue.\n+    /// Do nothing if the capacity is already sufficient.\n+    pub fn reserve(&mut self, n: uint) {\n+        self.data.reserve(n)\n     }\n \n     /// Pop the greatest item from the queue - fails if empty\n@@ -203,7 +207,7 @@ impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n         let (lower, _) = iter.size_hint();\n \n         let len = self.capacity();\n-        self.reserve_at_least(len + lower);\n+        self.reserve(len + lower);\n \n         for elem in *iter {\n             self.push(elem);"}, {"sha": "f7ea1b0822d22f38315c887006f5b6a483f9d951", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=65f35781489ccaa66585b91f215308f3091bf404", "patch": "@@ -168,8 +168,8 @@ impl<T> RingBuf<T> {\n     /// # Arguments\n     ///\n     /// * n - The number of elements to reserve space for\n-    pub fn reserve(&mut self, n: uint) {\n-        self.elts.reserve(n);\n+    pub fn reserve_exact(&mut self, n: uint) {\n+        self.elts.reserve_exact(n);\n     }\n \n     /// Reserve capacity for at least `n` elements in the given RingBuf,\n@@ -182,8 +182,8 @@ impl<T> RingBuf<T> {\n     /// # Arguments\n     ///\n     /// * n - The number of elements to reserve space for\n-    pub fn reserve_at_least(&mut self, n: uint) {\n-        self.elts.reserve_at_least(n);\n+    pub fn reserve(&mut self, n: uint) {\n+        self.elts.reserve(n);\n     }\n \n     /// Front-to-back iterator.\n@@ -641,26 +641,26 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reserve() {\n+    fn test_reserve_exact() {\n         let mut d = RingBuf::new();\n         d.push_back(0u64);\n-        d.reserve(50);\n+        d.reserve_exact(50);\n         assert_eq!(d.elts.capacity(), 50);\n         let mut d = RingBuf::new();\n         d.push_back(0u32);\n-        d.reserve(50);\n+        d.reserve_exact(50);\n         assert_eq!(d.elts.capacity(), 50);\n     }\n \n     #[test]\n-    fn test_reserve_at_least() {\n+    fn test_reserve() {\n         let mut d = RingBuf::new();\n         d.push_back(0u64);\n-        d.reserve_at_least(50);\n+        d.reserve(50);\n         assert_eq!(d.elts.capacity(), 64);\n         let mut d = RingBuf::new();\n         d.push_back(0u32);\n-        d.reserve_at_least(50);\n+        d.reserve(50);\n         assert_eq!(d.elts.capacity(), 64);\n     }\n "}, {"sha": "7669467d4bbe8a46457b7c8c77d82a67ed9b2987", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=65f35781489ccaa66585b91f215308f3091bf404", "patch": "@@ -384,7 +384,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n-    pub fn reserve_at_least(&mut self, n: uint) {\n+    pub fn reserve(&mut self, n: uint) {\n         if n > self.buckets.len() {\n             let buckets = n * 4 / 3 + 1;\n             self.resize(num::next_power_of_two(buckets));\n@@ -793,8 +793,8 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n-    pub fn reserve_at_least(&mut self, n: uint) {\n-        self.map.reserve_at_least(n)\n+    pub fn reserve(&mut self, n: uint) {\n+        self.map.reserve(n)\n     }\n \n     /// Returns true if the hash set contains a value equivalent to the"}, {"sha": "e1387332e9fbf8593d27512fa773a48763bc0df5", "filename": "src/libstd/str.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=65f35781489ccaa66585b91f215308f3091bf404", "patch": "@@ -104,7 +104,7 @@ use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n use iter::{Rev, DoubleEndedIterator, ExactSize};\n use libc;\n-use num::{Saturating, checked_next_power_of_two};\n+use num::Saturating;\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n@@ -186,12 +186,7 @@ pub fn from_char(ch: char) -> ~str {\n \n /// Convert a vector of chars to a string\n pub fn from_chars(chs: &[char]) -> ~str {\n-    let mut buf = ~\"\";\n-    buf.reserve(chs.len());\n-    for ch in chs.iter() {\n-        buf.push_char(*ch)\n-    }\n-    buf\n+    chs.iter().map(|c| *c).collect()\n }\n \n #[doc(hidden)]\n@@ -875,8 +870,7 @@ pub fn utf16_chars(v: &[u16], f: |char|) {\n \n /// Allocates a new string from the utf-16 slice provided\n pub fn from_utf16(v: &[u16]) -> ~str {\n-    let mut buf = ~\"\";\n-    buf.reserve(v.len());\n+    let mut buf = with_capacity(v.len());\n     utf16_chars(v, |ch| buf.push_char(ch));\n     buf\n }\n@@ -2166,17 +2160,15 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     fn escape_default(&self) -> ~str {\n-        let mut out: ~str = ~\"\";\n-        out.reserve_at_least(self.len());\n+        let mut out = with_capacity(self.len());\n         for c in self.chars() {\n             c.escape_default(|c| out.push_char(c));\n         }\n         out\n     }\n \n     fn escape_unicode(&self) -> ~str {\n-        let mut out: ~str = ~\"\";\n-        out.reserve_at_least(self.len());\n+        let mut out = with_capacity(self.len());\n         for c in self.chars() {\n             c.escape_unicode(|c| out.push_char(c));\n         }\n@@ -2508,7 +2500,7 @@ pub trait OwnedStr {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n-    fn reserve(&mut self, n: uint);\n+    fn reserve_exact(&mut self, n: uint);\n \n     /// Reserves capacity for at least `n` bytes in the given string.\n     ///\n@@ -2526,7 +2518,7 @@ pub trait OwnedStr {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n-    fn reserve_at_least(&mut self, n: uint);\n+    fn reserve(&mut self, n: uint);\n \n     /// Returns the number of single-byte characters the string can hold without\n     /// reallocating\n@@ -2552,7 +2544,7 @@ impl OwnedStr for ~str {\n     #[inline]\n     fn push_str_no_overallocate(&mut self, rhs: &str) {\n         let new_cap = self.len() + rhs.len();\n-        self.reserve(new_cap);\n+        self.reserve_exact(new_cap);\n         self.push_str(rhs);\n     }\n \n@@ -2631,15 +2623,17 @@ impl OwnedStr for ~str {\n     }\n \n     #[inline]\n-    fn reserve(&mut self, n: uint) {\n+    fn reserve_exact(&mut self, n: uint) {\n         unsafe {\n-            raw::as_owned_vec(self).reserve(n)\n+            raw::as_owned_vec(self).reserve_exact(n)\n         }\n     }\n \n     #[inline]\n-    fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(checked_next_power_of_two(n).unwrap_or(n))\n+    fn reserve(&mut self, n: uint) {\n+        unsafe {\n+            raw::as_owned_vec(self).reserve(n)\n+        }\n     }\n \n     #[inline]\n@@ -2711,7 +2705,7 @@ impl Extendable<char> for ~str {\n     fn extend<T: Iterator<char>>(&mut self, iterator: &mut T) {\n         let (lower, _) = iterator.size_hint();\n         let reserve = lower + self.len();\n-        self.reserve_at_least(reserve);\n+        self.reserve(reserve);\n         for ch in *iterator {\n             self.push_char(ch)\n         }"}, {"sha": "f9a90150ad473273724f3b631861f8ad8a5e691d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f35781489ccaa66585b91f215308f3091bf404/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=65f35781489ccaa66585b91f215308f3091bf404", "patch": "@@ -1335,7 +1335,7 @@ pub trait OwnedVector<T> {\n      * This method always succeeds in reserving space for `n` elements, or it does\n      * not return.\n      */\n-    fn reserve(&mut self, n: uint);\n+    fn reserve_exact(&mut self, n: uint);\n     /**\n      * Reserves capacity for at least `n` elements in the given vector.\n      *\n@@ -1350,7 +1350,7 @@ pub trait OwnedVector<T> {\n      *\n      * * n - The number of elements to reserve space for\n      */\n-    fn reserve_at_least(&mut self, n: uint);\n+    fn reserve(&mut self, n: uint);\n     /**\n      * Reserves capacity for at least `n` additional elements in the given vector.\n      *\n@@ -1468,7 +1468,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.move_iter().rev()\n     }\n \n-    fn reserve(&mut self, n: uint) {\n+    fn reserve_exact(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if self.capacity() < n {\n             unsafe {\n@@ -1486,16 +1486,16 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(checked_next_power_of_two(n).unwrap_or(n));\n+    fn reserve(&mut self, n: uint) {\n+        self.reserve_exact(checked_next_power_of_two(n).unwrap_or(n));\n     }\n \n     #[inline]\n     fn reserve_additional(&mut self, n: uint) {\n         if self.capacity() - self.len() < n {\n             match self.len().checked_add(&n) {\n                 None => fail!(\"vec::reserve_additional: `uint` overflow\"),\n-                Some(new_cap) => self.reserve_at_least(new_cap)\n+                Some(new_cap) => self.reserve(new_cap)\n             }\n         }\n     }\n@@ -1678,7 +1678,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n     fn grow_fn(&mut self, n: uint, op: |uint| -> T) {\n         let new_len = self.len() + n;\n-        self.reserve_at_least(new_len);\n+        self.reserve(new_len);\n         let mut i: uint = 0u;\n         while i < n {\n             self.push(op(i));\n@@ -1737,15 +1737,15 @@ impl<T:Clone> OwnedCloneableVector<T> for ~[T] {\n     #[inline]\n     fn push_all(&mut self, rhs: &[T]) {\n         let new_len = self.len() + rhs.len();\n-        self.reserve(new_len);\n+        self.reserve_exact(new_len);\n \n         for elt in rhs.iter() {\n             self.push((*elt).clone())\n         }\n     }\n     fn grow(&mut self, n: uint, initval: &T) {\n         let new_len = self.len() + n;\n-        self.reserve_at_least(new_len);\n+        self.reserve(new_len);\n         let mut i: uint = 0u;\n \n         while i < n {\n@@ -2900,7 +2900,7 @@ impl<A> Extendable<A> for ~[A] {\n     fn extend<T: Iterator<A>>(&mut self, iterator: &mut T) {\n         let (lower, _) = iterator.size_hint();\n         let len = self.len();\n-        self.reserve(len + lower);\n+        self.reserve_exact(len + lower);\n         for x in *iterator {\n             self.push(x);\n         }\n@@ -3630,10 +3630,10 @@ mod tests {\n     #[test]\n     fn test_capacity() {\n         let mut v = ~[0u64];\n-        v.reserve(10u);\n+        v.reserve_exact(10u);\n         assert_eq!(v.capacity(), 10u);\n         let mut v = ~[0u32];\n-        v.reserve(10u);\n+        v.reserve_exact(10u);\n         assert_eq!(v.capacity(), 10u);\n     }\n \n@@ -4070,7 +4070,7 @@ mod tests {\n     #[should_fail]\n     fn test_overflow_does_not_cause_segfault() {\n         let mut v = ~[];\n-        v.reserve(-1);\n+        v.reserve_exact(-1);\n         v.push(1);\n         v.push(2);\n     }\n@@ -4080,7 +4080,7 @@ mod tests {\n     fn test_overflow_does_not_cause_segfault_managed() {\n         use rc::Rc;\n         let mut v = ~[Rc::new(1)];\n-        v.reserve(-1);\n+        v.reserve_exact(-1);\n         v.push(Rc::new(2));\n     }\n "}]}