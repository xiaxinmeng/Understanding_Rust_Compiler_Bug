{"sha": "1402a106bd66b88750f3cd255eb77451c3f432e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MDJhMTA2YmQ2NmI4ODc1MGYzY2QyNTVlYjc3NDUxYzNmNDMyZTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-05-27T20:02:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-05-30T12:58:20Z"}, "message": "std: Delete bundled libbacktrace module", "tree": {"sha": "5be91f54dc3ca1c50deac25356ced3be69f96ccd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5be91f54dc3ca1c50deac25356ced3be69f96ccd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1402a106bd66b88750f3cd255eb77451c3f432e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1402a106bd66b88750f3cd255eb77451c3f432e6", "html_url": "https://github.com/rust-lang/rust/commit/1402a106bd66b88750f3cd255eb77451c3f432e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1402a106bd66b88750f3cd255eb77451c3f432e6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20af72b943527d584df4b99e157262f9b297b3e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/20af72b943527d584df4b99e157262f9b297b3e4", "html_url": "https://github.com/rust-lang/rust/commit/20af72b943527d584df4b99e157262f9b297b3e4"}], "stats": {"total": 40219, "additions": 0, "deletions": 40219}, "files": [{"sha": "acc07047f6729cc578b55bec881acb8f8fd379ba", "filename": "src/libbacktrace/ChangeLog", "status": "removed", "additions": 0, "deletions": 590, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FChangeLog", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,590 +0,0 @@\n-2016-05-18  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\tPR target/71161\n-\t* elf.c (phdr_callback) [__i386__]: Add\n-\t__attribute__((__force_align_arg_pointer__)).\n-\n-2016-03-02  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>\n-\n-\t* elf.c (backtrace_initialize): Properly initialize elf_fileline_fn to\n-\tavoid possible crash.\n-\t(elf_add): Don't set *fileline_fn to elf_nodebug value in case of\n-\tmissing debug info anymore.\n-\n-2016-02-06  John David Anglin  <danglin@gcc.gnu.org>\n-\n-\t* mmap.c (MAP_FAILED): Define if not defined.\n-\n-2016-01-04  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tUpdate copyright years.\n-\n-2015-12-18  Andris Pavenis  <andris.pavenis@iki.fi>\n-\n-\t* configure.ac: Specify that DJGPP do not have mmap\n-\teven when sys/mman.h exists.\n-\t* configure: Regenerate\n-\n-2015-12-09  John David Anglin  <danglin@gcc.gnu.org>\n-\n-\tPR libgfortran/68115\n-\t* configure.ac: Set libbacktrace_cv_sys_sync to no on hppa*-*-hpux*.\n-\t* configure: Regenerate.\n-\t* elf.c (backtrace_initialize): Cast __sync_bool_compare_and_swap call\n-\tto void.\n-\n-2015-09-17  Ian Lance Taylor  <iant@google.com>\n-\n-\t* posix.c (backtrace_open): Cast second argument of open() to int.\n-\n-2015-09-11  Ian Lance Taylor  <iant@google.com>\n-\n-\t* Makefile.am (backtrace.lo): Depend on internal.h.\n-\t(sort.lo, stest.lo): Add explicit dependencies.\n-\t* Makefile.in: Rebuild.\n-\n-2015-09-09  Hans-Peter Nilsson  <hp@axis.com>\n-\n-\t* backtrace.c: #include <sys/types.h>.\n-\n-2015-09-08  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/67457\n-\t* backtrace.c: #include \"internal.h\".\n-\t(struct backtrace_data): Add can_alloc field.\n-\t(unwind): If can_alloc is false, don't try to get file/line\n-\tinformation.\n-\t(backtrace_full): Set can_alloc field in bdata.\n-\t* alloc.c (backtrace_alloc): Don't call error_callback if it is\n-\tNULL.\n-\t* mmap.c (backtrace_alloc): Likewise.\n-\t* internal.h: Update comments for backtrace_alloc and\n-\tbacktrace_free.\n-\n-2015-09-08  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/67457\n-\t* mmap.c (backtrace_alloc): Correct test for mmap failure.\n-\n-2015-08-31  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n-\n-\t* configure.ac: For spu-*-* targets, set have_fcntl to no.\n-\t* configure: Regenerate.\n-\n-2015-08-27  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n-\n-\t* configure.ac: Remove [disable-shared] argument to LT_INIT.\n-\tRemove setting PIC_FLAG when building as target library.\n-\t* configure: Regenerate.\n-\n-2015-08-26  Hans-Peter Nilsson  <hp@axis.com>\n-\n-\t* configure.ac: Only compile with -fPIC if the target\n-\tsupports it.\n-\t* configure: Regenerate.\n-\n-2015-08-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n-\n-\t* configure.ac: Set have_mmap to no on spu-*-* targets.\n-\t* configure: Regenerate.\n-\n-2015-08-13  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (read_function_entry): Add vec_inlined parameter.\n-\tChange all callers.\n-\n-2015-06-11  Martin Sebor  <msebor@redhat.com>\n-\n-\tPR sanitizer/65479\n-\t* dwarf.c (struct line): Add new field idx.\n-\t(line_compare): Use it.\n-\t(add_line): Set it.\n-\t(read_line_info): Reset it.\n-\n-2015-05-29  Tristan Gingold  <gingold@adacore.com>\n-\n-\t* pecoff.c: New file.\n-\t* Makefile.am (FORMAT_FILES): Add pecoff.c and dependencies.\n-\t* Makefile.in: Regenerate.\n-\t* filetype.awk: Detect pecoff.\n-\t* configure.ac: Define BACKTRACE_SUPPORTS_DATA on elf platforms.\n-\tAdd pecoff.\n-\t* btest.c (test5): Test enabled only if BACKTRACE_SUPPORTS_DATA is\n-\ttrue.\n-\t* backtrace-supported.h.in (BACKTRACE_SUPPORTS_DATA): Define.\n-\t* configure: Regenerate.\n-\t* pecoff.c: New file.\n-\n-2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n-\n-\t* Makefile.in: Regenerated with automake-1.11.6.\n-\t* aclocal.m4: Likewise.\n-\t* configure: Likewise.\n-\n-2015-01-24  Matthias Klose  <doko@ubuntu.com>\n-\n-\t* configure.ac: Move AM_ENABLE_MULTILIB before AC_PROG_CC.\n-\t* configure: Regenerate.\n-\n-2015-01-05  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tUpdate copyright years.\n-\n-2014-11-21  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\tPR bootstrap/63784\n-\t* configure: Regenerated.\n-\n-2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* ChangeLog.jit: New.\n-\n-2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n-\n-\tPR target/63610\n-\t* configure: Regenerate.\n-\n-2014-10-23  Ian Lance Taylor  <iant@google.com>\n-\n-\t* internal.h (backtrace_atomic_load_pointer) [no atomic or sync]:\n-\tFix to return void *.\n-\n-2014-05-08  Ian Lance Taylor  <iant@google.com>\n-\n-\t* mmap.c (backtrace_free): If freeing a large aligned block of\n-\tmemory, call munmap rather than holding onto it.\n-\t(backtrace_vector_grow): When growing a vector, double the number\n-\tof pages requested.  When releasing the old version of a grown\n-\tvector, pass the correct size to backtrace_free.\n-\n-2014-03-07  Ian Lance Taylor  <iant@google.com>\n-\n-\t* sort.c (backtrace_qsort): Use middle element as pivot.\n-\n-2014-03-06  Ian Lance Taylor  <iant@google.com>\n-\n-\t* sort.c: New file.\n-\t* stest.c: New file.\n-\t* internal.h (backtrace_qsort): Declare.\n-\t* dwarf.c (read_abbrevs): Call backtrace_qsort instead of qsort.\n-\t(read_line_info, read_function_entry): Likewise.\n-\t(read_function_info, build_dwarf_data): Likewise.\n-\t* elf.c (elf_initialize_syminfo): Likewise.\n-\t* Makefile.am (libbacktrace_la_SOURCES): Add sort.c.\n-\t(stest_SOURCES, stest_LDADD): Define.\n-\t(check_PROGRAMS): Add stest.\n-\n-2014-02-07  Misty De Meo  <misty@brew.sh>\n-\n-\tPR target/58710\n-\t* configure.ac: Use AC_LINK_IFELSE in check for\n-\t_Unwind_GetIPInfo.\n-\t* configure: Regenerate.\n-\n-2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n-\n-\tUpdate copyright years\n-\n-2013-12-06  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* elf.c (ET_DYN): Undefine and define again.\n-\t(elf_add): Add exe argument, if true and ehdr.e_type is ET_DYN,\n-\treturn early -1 without closing the descriptor.\n-\t(struct phdr_data): Add exe_descriptor.\n-\t(phdr_callback): If pd->exe_descriptor is not -1, for very first\n-\tcall if dlpi_name is NULL just call elf_add with the exe_descriptor,\n-\totherwise backtrace_close the exe_descriptor if not -1.  Adjust\n-\tcall to elf_add.\n-\t(backtrace_initialize): Adjust call to elf_add.  If it returns\n-\t-1, set pd.exe_descriptor to descriptor, otherwise set it to -1.\n-\n-2013-12-05  Ian Lance Taylor  <iant@google.com>\n-\n-\t* alloc.c (backtrace_vector_finish): Add error_callback and data\n-\tparameters.  Call backtrace_vector_release.  Return address base.\n-\t* mmap.c (backtrace_vector_finish): Add error_callback and data\n-\tparameters.  Return address base.\n-\t* dwarf.c (read_function_info): Get new address base from\n-\tbacktrace_vector_finish.\n-\t* internal.h (backtrace_vector_finish): Update declaration.\n-\n-2013-11-27  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (find_address_ranges): New static function, broken out\n-\tof build_address_map.\n-\t(build_address_map): Call it.\n-\t* btest.c (check): Check for missing filename or function, rather\n-\tthan crashing.\n-\t(f3): Check that enough frames were returned.\n-\n-2013-11-19  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* backtrace.h (backtrace_syminfo_callback): Add symsize argument.\n-\t* elf.c (elf_syminfo): Pass 0 or sym->size to the callback as\n-\tlast argument.\n-\t* btest.c (struct symdata): Add size field.\n-\t(callback_three): Add symsize argument.  Copy it to the data->size\n-\tfield.\n-\t(f23): Set symdata.size to 0.\n-\t(test5): Likewise.  If sizeof (int) > 1, lookup address of\n-\t((uintptr_t) &global) + 1.  Verify symdata.val and symdata.size\n-\tvalues.\n-\n-\t* atomic.c: Include sys/types.h.\n-\n-2013-11-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Check for support of __atomic extensions.\n-\t* internal.h: Declare or #define atomic functions for use in\n-\tbacktrace code.\n-\t* atomic.c: New file.\n-\t* dwarf.c (dwarf_lookup_pc): Use atomic functions.\n-\t(dwarf_fileline, backtrace_dwarf_add): Likewise.\n-\t* elf.c (elf_add_syminfo_data, elf_syminfo): Likewise.\n-\t(backtrace_initialize): Likewise.\n-\t* fileline.c (fileline_initialize): Likewise.\n-\t* Makefile.am (libbacktrace_la_SOURCES): Add atomic.c.\n-\t* configure, config.h.in, Makefile.in: Rebuild.\n-\n-2013-11-18  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* elf.c (SHN_UNDEF): Define.\n-\t(elf_initialize_syminfo): Add base_address argument.  Ignore symbols\n-\twith st_shndx == SHN_UNDEF.  Add base_address to address fields.\n-\t(elf_add): Adjust caller.\n-\n-\t* elf.c (phdr_callback): Process info->dlpi_addr == 0 normally.\n-\n-2013-11-16  Ian Lance Taylor  <iant@google.com>\n-\n-\t* backtrace.h (backtrace_create_state): Correct comment about\n-\tthreading.\n-\n-2013-11-15  Ian Lance Taylor  <iant@google.com>\n-\n-\t* backtrace.h (backtrace_syminfo): Update comment and parameter\n-\tname to take any address, not just a PC value.\n-\t* elf.c (STT_OBJECT): Define.\n-\t(elf_nosyms): Rename parameter pc to addr.\n-\t(elf_symbol_search): Rename local variable pc to addr.\n-\t(elf_initialize_syminfo): Add STT_OBJECT symbols to elf_symbols.\n-\t(elf_syminfo): Rename parameter pc to addr.\n-\t* btest.c (global): New global variable.\n-\t(test5): New test.\n-\t(main): Call test5.\n-\n-2013-10-17  Ian Lance Taylor  <iant@google.com>\n-\n-\t* elf.c (elf_add): Don't get the wrong offsets if a debug section\n-\tis missing.\n-\n-2013-10-15  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* configure.ac: Add --enable-host-shared, setting up\n-\tpre-existing PIC_FLAG variable within Makefile.am et al.\n-\t* configure: Regenerate.\n-\n-2013-09-20  Alan Modra  <amodra@gmail.com>\n-\n-\t* configure: Regenerate.\n-\n-2013-07-23  Alexander Monakov  <amonakov@ispras.ru>\n-\n-\t* elf.c (elf_syminfo): Loop over the elf_syminfo_data chain.\n-\n-2013-07-23  Alexander Monakov  <amonakov@ispras.ru>\n-\n-\t* elf.c (backtrace_initialize): Pass elf_fileline_fn to\n-\tdl_iterate_phdr callbacks.\n-\n-2013-03-25  Ian Lance Taylor  <iant@google.com>\n-\n-\t* alloc.c: #include <sys/types.h>.\n-\t* mmap.c: Likewise.\n-\n-2013-01-31  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (read_function_info): Permit fvec parameter to be NULL.\n-\t(dwarf_lookup_pc): Don't use ddata->fvec if threaded.\n-\n-2013-01-25  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR other/56076\n-\t* dwarf.c (read_line_header): Don't crash if DW_AT_comp_dir\n-\tattribute was not seen.\n-\n-2013-01-16  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (struct unit): Add filename and abs_filename fields.\n-\t(build_address_map): Set new fields when reading unit.\n-\t(dwarf_lookup_pc): If we don't find an entry in the line table,\n-\tjust return the main file name.\n-\n-2013-01-14  Richard Sandiford  <rdsandiford@googlemail.com>\n-\n-\tUpdate copyright years.\n-\n-2013-01-01  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54834\n-\t* Makefile.am (AM_CPPFLAGS): Remove -I ../gcc/include and -I\n-\t$(MULTIBUILDTOP)/../../gcc/include.\n-\t* Makefile.in: Rebuild.\n-\n-2013-01-01  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/55536\n-\t* mmap.c (backtrace_alloc): Don't call sync functions if not\n-\tthreaded.\n-\t(backtrace_free): Likewise.\n-\n-2012-12-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n-\n-\t* mmapio.c: Define MAP_FAILED if not defined.\n-\n-2012-12-11  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR bootstrap/54926\n-\t* Makefile.am (AM_CFLAGS): Remove -frandom-seed=$@.\n-\t* configure.ac: If --with-target-subdir, add -frandom-seed=$@\n-\tto EXTRA_FLAGS unconditionally, otherwise check whether the compiler\n-\taccepts it.\n-\t* Makefile.in: Regenerated.\n-\t* configure: Regenerated.\n-\n-2012-12-07  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR bootstrap/54926\n-\t* Makefile.am (AM_CFLAGS): Add -frandom-seed=$@.\n-\t* Makefile.in: Regenerated.\n-\n-2012-11-20  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (read_attribute): Always clear val.\n-\n-2012-11-13  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/55312\n-\t* configure.ac: Only add -Werror if building a target library.\n-\t* configure: Rebuild.\n-\n-2012-11-12  Ian Lance Taylor  <iant@google.com>\n-\t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\t    Gerald Pfeifer  <gerald@pfeifer.com>\n-\n-\t* configure.ac: Check for getexecname.\n-\t* fileline.c: #include <errno.h>.  Define getexecname if not\n-\tavailable.\n-\t(fileline_initialize): Try to find the executable in a few\n-\tdifferent ways.\n-\t* print.c (error_callback): Only print the filename if it came\n-\tfrom the backtrace state.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-10-29  Ian Lance Taylor  <iant@google.com>\n-\n-\t* mmap.c (backtrace_vector_release): Correct last patch: add\n-\taligned, not size.\n-\n-2012-10-29  Ian Lance Taylor  <iant@google.com>\n-\n-\t* mmap.c (backtrace_vector_release): Make sure freed block is\n-\taligned on 8-byte boundary.\n-\n-2012-10-26  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/55087\n-\t* posix.c (backtrace_open): Add does_not_exist parameter.\n-\t* elf.c (phdr_callback): Do not warn if shared library could not\n-\tbe opened.\n-\t* fileline.c (fileline_initialize): Update calls to\n-\tbacktrace_open.\n-\t* internal.h (backtrace_open): Update declaration.\n-\n-2012-10-26  Jack Howarth  <howarth@bromo.med.uc.edu>\n-\n-\tPR target/55061\n-\t* configure.ac: Check for _Unwind_GetIPInfo function declaration.\n-\t* configure: Regenerate.\n-\n-2012-10-24  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR target/55061\n-\t* configure.ac: Check whether -funwind-tables option works.\n-\t* configure: Rebuild.\n-\n-2012-10-11  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Do not use dl_iterate_phdr on Solaris 10.\n-\t* configure: Rebuild.\n-\n-2012-10-10  Ian Lance Taylor  <iant@google.com>\n-\n-\t* elf.c: Rename all Elf typedefs to start with b_elf, and be all\n-\tlower case.\n-\n-2012-10-10  Hans-Peter Nilsson  <hp@bitrange.com>\n-\n-\t* elf.c (elf_add_syminfo_data): Add casts to avoid warning.\n-\n-2012-10-09  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (dwarf_fileline): Add cast to avoid warning.\n-\t(backtrace_dwarf_add): Likewise.\n-\n-2012-10-09  Ian Lance Taylor  <iant@google.com>\n-\n-\tAdd support for tracing through shared libraries.\n-\t* configure.ac: Check for link.h and dl_iterate_phdr.\n-\t* elf.c: #include <link.h> if system has dl_iterate_phdr.  #undef\n-\tELF macros before #defining them.\n-\t(dl_phdr_info, dl_iterate_phdr): Define if system does not have\n-\tdl_iterate_phdr.\n-\t(struct elf_syminfo_data): Add next field.\n-\t(elf_initialize_syminfo): Initialize next field.\n-\t(elf_add_syminfo_data): New static function.\n-\t(elf_add): New static function, broken out of\n-\tbacktrace_initialize.  Call backtrace_dwarf_add instead of\n-\tbacktrace_dwarf_initialize.\n-\t(struct phdr_data): Define.\n-\t(phdr_callback): New static function.\n-\t(backtrace_initialize): Call elf_add.\n-\t* dwarf.c (struct dwarf_data): Add next and base_address fields.\n-\t(add_unit_addr): Add base_address parameter.  Change all callers.\n-\t(add_unit_ranges, build_address_map): Likewise.\n-\t(add_line): Add ddata parameter.  Change all callers.\n-\t(read_line_program, add_function_range): Likewise.\n-\t(dwarf_lookup_pc): New static function, broken out of\n-\tdwarf_fileline.\n-\t(dwarf_fileline): Call dwarf_lookup_pc.\n-\t(build_dwarf_data): New static function.\n-\t(backtrace_dwarf_add): New function.\n-\t(backtrace_dwarf_initialize): Remove.\n-\t* internal.h (backtrace_dwarf_initialize): Don't declare.\n-\t(backtrace_dwarf_add): Declare.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-10-04  Gerald Pfeifer  <gerald@pfeifer.com>\n-\n-\t* btest.c (f23): Avoid uninitialized variable warning.\n-\n-2012-10-04  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c: If the system header files do not declare strnlen,\n-\tprovide our own version.\n-\n-2012-10-03  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (read_uleb128): Fix overflow test.\n-\t(read_sleb128): Likewise.\n-\t(build_address_map): Don't change unit_buf.start.\n-\n-2012-10-02  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\tPR other/54761\n-\t* configure.ac (EXTRA_FLAGS): New.\n-\t* Makefile.am (AM_FLAGS): Add $(EXTRA_FLAGS).\n-\t* configure, Makefile.in: Regenerate.\n-\n-2012-09-29  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/54749\n-\t* fileline.c (fileline_initialize): Pass errnum as -1 when\n-\treporting that we could not read executable information after a\n-\tprevious failure.\n-\n-2012-09-27  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54732\n-\t* configure.ac: Add no-dependencies to AM_INIT_AUTOMAKE.\n-\t* Makefile.am: Add dependencies for all objects.\n-\t* configure, aclocal.m4, Makefile.in: Rebuild.\n-\n-2012-09-27  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/54726\n-\t* elf.c (backtrace_initialize): Set *fileln_fn, not\n-\tstate->fileln_fn.\n-\n-2012-09-19  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Only use GCC_CHECK_UNWIND_GETIPINFO when compiled\n-\tas a target library.\n-\t* configure: Rebuild.\n-\n-2012-09-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\t    Ian Lance Taylor  <iant@google.com>\n-\n-        * configure.ac (GCC_HEADER_STDINT): Invoke.\n-        * backtrace.h: If we can't find <stdint.h>, use \"gstdint.h\".\n-        * btest.c: Don't include <stdint.h>.\n-        * dwarf.c: Likewise.\n-        * configure, aclocal.m4, Makefile.in, config.h.in: Rebuild.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54623\n-\t* Makefile.am (AM_CPPFLAGS): Define.\n-\t(AM_CFLAGS): Remove -I options.\n-\t* Makefile.in: Rebuild.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* posix.c (O_BINARY): Define if not defined.\n-\t(backtrace_open): Pass O_BINARY to open.  Only call fcntl if\n-\tHAVE_FCNTL is defined.\n-\t* configure.ac: Test for the fcntl function.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* btest.c (test1, test2, test3, test4): Add the unused attribute.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c: Correct test of HAVE_DECL_STRNLEN.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Add AC_USE_SYSTEM_EXTENSIONS.\n-\t* mmapio.c: Don't define _GNU_SOURCE.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Check whether strnlen is declared.\n-\t* dwarf.c: Declare strnlen if not declared.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-09-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* fileline.c: Include <stdlib.h>.\n-\t* mmap.c: Likewise.\n-\n-2012-09-17  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54611\n-\t* nounwind.c (backtrace_full): Rename from backtrace.  Add state\n-\tparameter.\n-\n-2012-09-17  Gerald Pfeifer  <gerald@pfeifer.com>\n-\n-\tPR bootstrap/54611\n-\t* nounwind.c (backtrace_simple): Add state parameter.\n-\n-2012-09-17  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54609\n-\t* unknown.c (unknown_fileline): Add state parameter, remove\n-\tfileline_data parameter, name error_callback parameter.\n-\t(backtrace_initialize): Add state parameter.\n-\n-2012-09-17  Ian Lance Taylor  <iant@google.com>\n-\n-\t* Initial implementation.\n-\f\n-Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "6b60e3b3b07382a48c7ffbaf992876426234bdee", "filename": "src/libbacktrace/ChangeLog.jit", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FChangeLog.jit", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog.jit?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,14 +0,0 @@\n-2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* ChangeLog.jit: Add copyright footer.\n-\n-2013-10-03  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* configure.ac: Add --enable-host-shared.\n-\t* configure: Regenerate.\n-\f\n-Copyright (C) 2013-2014 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "a7df02590982255a96166a4be552f07e6f42cabb", "filename": "src/libbacktrace/Makefile.am", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.am?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,136 +0,0 @@\n-# Makefile.am -- Backtrace Makefile.\n-# Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-\n-# Redistribution and use in source and binary forms, with or without\n-# modification, are permitted provided that the following conditions are\n-# met:\n-\n-#     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer. \n-\n-#     (2) Redistributions in binary form must reproduce the above copyright\n-#     notice, this list of conditions and the following disclaimer in\n-#     the documentation and/or other materials provided with the\n-#     distribution.  \n-\n-#     (3) The name of the author may not be used to\n-#     endorse or promote products derived from this software without\n-#     specific prior written permission.\n-\n-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-# POSSIBILITY OF SUCH DAMAGE.\n-\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-\n-AM_CPPFLAGS = -I $(top_srcdir)/../include -I $(top_srcdir)/../libgcc \\\n-\t-I ../libgcc\n-\n-AM_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) $(PIC_FLAG)\n-\n-noinst_LTLIBRARIES = libbacktrace.la\n-\n-libbacktrace_la_SOURCES = \\\n-\tbacktrace.h \\\n-\tatomic.c \\\n-\tdwarf.c \\\n-\tfileline.c \\\n-\tinternal.h \\\n-\tposix.c \\\n-\tprint.c \\\n-\tsort.c \\\n-\tstate.c\n-\n-BACKTRACE_FILES = \\\n-\tbacktrace.c \\\n-\tsimple.c \\\n-\tnounwind.c\n-\n-FORMAT_FILES = \\\n-\telf.c \\\n-\tpecoff.c \\\n-\tunknown.c\n-\n-VIEW_FILES = \\\n-\tread.c \\\n-\tmmapio.c\n-\n-ALLOC_FILES = \\\n-\talloc.c \\\n-\tmmap.c\n-\n-EXTRA_libbacktrace_la_SOURCES = \\\n-\t$(BACKTRACE_FILES) \\\n-\t$(FORMAT_FILES) \\\n-\t$(VIEW_FILES) \\\n-\t$(ALLOC_FILES)\n-\n-libbacktrace_la_LIBADD = \\\n-\t$(BACKTRACE_FILE) \\\n-\t$(FORMAT_FILE) \\\n-\t$(VIEW_FILE) \\\n-\t$(ALLOC_FILE)\n-\n-libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n-\n-# Testsuite.\n-\n-check_PROGRAMS =\n-\n-TESTS = $(check_PROGRAMS)\n-\n-if NATIVE\n-\n-btest_SOURCES = btest.c\n-btest_CFLAGS = $(AM_CFLAGS) -g -O\n-btest_LDADD = libbacktrace.la\n-\n-check_PROGRAMS += btest\n-\n-stest_SOURCES = stest.c\n-stest_LDADD = libbacktrace.la\n-\n-check_PROGRAMS += stest\n-\n-endif NATIVE\n-\n-# We can't use automake's automatic dependency tracking, because it\n-# breaks when using bootstrap-lean.  Automatic dependency tracking\n-# with GCC bootstrap will cause some of the objects to depend on\n-# header files in prev-gcc/include, e.g., stddef.h and stdarg.h.  When\n-# using bootstrap-lean, prev-gcc is removed after each stage.  When\n-# running \"make install\", those header files will be gone, causing the\n-# library to be rebuilt at install time.  That may not succeed.\n-\n-# These manual dependencies do not include dependencies on unwind.h,\n-# even though that is part of GCC, because where to find it depends on\n-# whether we are being built as a host library or a target library.\n-\n-INCDIR = $(top_srcdir)/../include\n-alloc.lo: config.h backtrace.h internal.h\n-backtrace.lo: config.h backtrace.h internal.h\n-btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h\n-dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n-\t$(INCDIR)/filenames.h backtrace.h internal.h\n-elf.lo: config.h backtrace.h internal.h\n-fileline.lo: config.h backtrace.h internal.h\n-mmap.lo: config.h backtrace.h internal.h\n-mmapio.lo: config.h backtrace.h internal.h\n-nounwind.lo: config.h internal.h\n-pecoff.lo: config.h backtrace.h internal.h\n-posix.lo: config.h backtrace.h internal.h\n-print.lo: config.h backtrace.h internal.h\n-read.lo: config.h backtrace.h internal.h\n-simple.lo: config.h backtrace.h internal.h\n-sort.lo: config.h backtrace.h internal.h\n-stest.lo: config.h backtrace.h internal.h\n-state.lo: config.h backtrace.h backtrace-supported.h internal.h\n-unknown.lo: config.h backtrace.h internal.h"}, {"sha": "586b6a6eaa10e94d4bf4deb478e063f2653088ac", "filename": "src/libbacktrace/Makefile.in", "status": "removed", "additions": 0, "deletions": 770, "changes": 770, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.in?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,770 +0,0 @@\n-# Makefile.in generated by automake 1.11.6 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n-# Foundation, Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-# Makefile.am -- Backtrace Makefile.\n-# Copyright (C) 2012-2015 Free Software Foundation, Inc.\n-\n-# Redistribution and use in source and binary forms, with or without\n-# modification, are permitted provided that the following conditions are\n-# met:\n-\n-#     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer. \n-\n-#     (2) Redistributions in binary form must reproduce the above copyright\n-#     notice, this list of conditions and the following disclaimer in\n-#     the documentation and/or other materials provided with the\n-#     distribution.  \n-\n-#     (3) The name of the author may not be used to\n-#     endorse or promote products derived from this software without\n-#     specific prior written permission.\n-\n-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-# POSSIBILITY OF SUCH DAMAGE.\n-\n-VPATH = @srcdir@\n-am__make_dryrun = \\\n-  { \\\n-    am__dry=no; \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n-          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n-      *) \\\n-        for am__flg in $$MAKEFLAGS; do \\\n-          case $$am__flg in \\\n-            *=*|--*) ;; \\\n-            *n*) am__dry=yes; break;; \\\n-          esac; \\\n-        done;; \\\n-    esac; \\\n-    test $$am__dry = yes; \\\n-  }\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-check_PROGRAMS = $(am__EXEEXT_1)\n-@NATIVE_TRUE@am__append_1 = btest stest\n-subdir = .\n-DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n-\t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n-\t$(am__configure_deps) $(srcdir)/config.h.in \\\n-\t$(srcdir)/../mkinstalldirs $(srcdir)/backtrace-supported.h.in\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/stdint.m4 \\\n-\t$(top_srcdir)/../config/unwind_ipinfo.m4 \\\n-\t$(top_srcdir)/../config/warnings.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno config.status.lineno\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = config.h\n-CONFIG_CLEAN_FILES = backtrace-supported.h\n-CONFIG_CLEAN_VPATH_FILES =\n-LTLIBRARIES = $(noinst_LTLIBRARIES)\n-am__DEPENDENCIES_1 =\n-am_libbacktrace_la_OBJECTS = atomic.lo dwarf.lo fileline.lo posix.lo \\\n-\tprint.lo sort.lo state.lo\n-libbacktrace_la_OBJECTS = $(am_libbacktrace_la_OBJECTS)\n-@NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT) stest$(EXEEXT)\n-@NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT)\n-btest_OBJECTS = $(am_btest_OBJECTS)\n-@NATIVE_TRUE@btest_DEPENDENCIES = libbacktrace.la\n-btest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(btest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-@NATIVE_TRUE@am_stest_OBJECTS = stest.$(OBJEXT)\n-stest_OBJECTS = $(am_stest_OBJECTS)\n-@NATIVE_TRUE@stest_DEPENDENCIES = libbacktrace.la\n-DEFAULT_INCLUDES = -I.@am__isrc@\n-depcomp =\n-am__depfiles_maybe =\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n-\t$(btest_SOURCES) $(stest_SOURCES)\n-MULTISRCTOP = \n-MULTIBUILDTOP = \n-MULTIDIRS = \n-MULTISUBDIR = \n-MULTIDO = true\n-MULTICLEAN = true\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n-ETAGS = etags\n-CTAGS = ctags\n-am__tty_colors = \\\n-red=; grn=; lgn=; blu=; std=\n-ACLOCAL = @ACLOCAL@\n-ALLOC_FILE = @ALLOC_FILE@\n-AMTAR = @AMTAR@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-BACKTRACE_FILE = @BACKTRACE_FILE@\n-BACKTRACE_SUPPORTED = @BACKTRACE_SUPPORTED@\n-BACKTRACE_SUPPORTS_DATA = @BACKTRACE_SUPPORTS_DATA@\n-BACKTRACE_SUPPORTS_THREADS = @BACKTRACE_SUPPORTS_THREADS@\n-BACKTRACE_USES_MALLOC = @BACKTRACE_USES_MALLOC@\n-CC = @CC@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-EXTRA_FLAGS = @EXTRA_FLAGS@\n-FGREP = @FGREP@\n-FORMAT_FILE = @FORMAT_FILE@\n-GREP = @GREP@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-PIC_FLAG = @PIC_FLAG@\n-RANLIB = @RANLIB@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-VIEW_FILE = @VIEW_FILE@\n-WARN_FLAGS = @WARN_FLAGS@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__leading_dot = @am__leading_dot@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-exec_prefix = @exec_prefix@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-libtool_VERSION = @libtool_VERSION@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-AM_CPPFLAGS = -I $(top_srcdir)/../include -I $(top_srcdir)/../libgcc \\\n-\t-I ../libgcc\n-\n-AM_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) $(PIC_FLAG)\n-noinst_LTLIBRARIES = libbacktrace.la\n-libbacktrace_la_SOURCES = \\\n-\tbacktrace.h \\\n-\tatomic.c \\\n-\tdwarf.c \\\n-\tfileline.c \\\n-\tinternal.h \\\n-\tposix.c \\\n-\tprint.c \\\n-\tsort.c \\\n-\tstate.c\n-\n-BACKTRACE_FILES = \\\n-\tbacktrace.c \\\n-\tsimple.c \\\n-\tnounwind.c\n-\n-FORMAT_FILES = \\\n-\telf.c \\\n-\tpecoff.c \\\n-\tunknown.c\n-\n-VIEW_FILES = \\\n-\tread.c \\\n-\tmmapio.c\n-\n-ALLOC_FILES = \\\n-\talloc.c \\\n-\tmmap.c\n-\n-EXTRA_libbacktrace_la_SOURCES = \\\n-\t$(BACKTRACE_FILES) \\\n-\t$(FORMAT_FILES) \\\n-\t$(VIEW_FILES) \\\n-\t$(ALLOC_FILES)\n-\n-libbacktrace_la_LIBADD = \\\n-\t$(BACKTRACE_FILE) \\\n-\t$(FORMAT_FILE) \\\n-\t$(VIEW_FILE) \\\n-\t$(ALLOC_FILE)\n-\n-libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n-TESTS = $(check_PROGRAMS)\n-@NATIVE_TRUE@btest_SOURCES = btest.c\n-@NATIVE_TRUE@btest_CFLAGS = $(AM_CFLAGS) -g -O\n-@NATIVE_TRUE@btest_LDADD = libbacktrace.la\n-@NATIVE_TRUE@stest_SOURCES = stest.c\n-@NATIVE_TRUE@stest_LDADD = libbacktrace.la\n-\n-# We can't use automake's automatic dependency tracking, because it\n-# breaks when using bootstrap-lean.  Automatic dependency tracking\n-# with GCC bootstrap will cause some of the objects to depend on\n-# header files in prev-gcc/include, e.g., stddef.h and stdarg.h.  When\n-# using bootstrap-lean, prev-gcc is removed after each stage.  When\n-# running \"make install\", those header files will be gone, causing the\n-# library to be rebuilt at install time.  That may not succeed.\n-\n-# These manual dependencies do not include dependencies on unwind.h,\n-# even though that is part of GCC, because where to find it depends on\n-# whether we are being built as a host library or a target library.\n-INCDIR = $(top_srcdir)/../include\n-all: config.h\n-\t$(MAKE) $(AM_MAKEFLAGS) all-am\n-\n-.SUFFIXES:\n-.SUFFIXES: .c .lo .o .obj\n-am--refresh: Makefile\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign --ignore-deps'; \\\n-\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign --ignore-deps \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign --ignore-deps Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\t$(am__cd) $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-$(am__aclocal_m4_deps):\n-\n-config.h: stamp-h1\n-\t@if test ! -f $@; then rm -f stamp-h1; else :; fi\n-\t@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi\n-\n-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n-\t@rm -f stamp-h1\n-\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n-$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n-\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n-\trm -f stamp-h1\n-\ttouch $@\n-\n-distclean-hdr:\n-\t-rm -f config.h stamp-h1\n-backtrace-supported.h: $(top_builddir)/config.status $(srcdir)/backtrace-supported.h.in\n-\tcd $(top_builddir) && $(SHELL) ./config.status $@\n-\n-clean-noinstLTLIBRARIES:\n-\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n-\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n-\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n-\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n-\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n-\t  rm -f \"$${dir}/so_locations\"; \\\n-\tdone\n-libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) $(EXTRA_libbacktrace_la_DEPENDENCIES) \n-\t$(LINK)  $(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD) $(LIBS)\n-\n-clean-checkPROGRAMS:\n-\t@list='$(check_PROGRAMS)'; test -n \"$$list\" || exit 0; \\\n-\techo \" rm -f\" $$list; \\\n-\trm -f $$list || exit $$?; \\\n-\ttest -n \"$(EXEEXT)\" || exit 0; \\\n-\tlist=`for p in $$list; do echo \"$$p\"; done | sed 's/$(EXEEXT)$$//'`; \\\n-\techo \" rm -f\" $$list; \\\n-\trm -f $$list\n-btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) $(EXTRA_btest_DEPENDENCIES) \n-\t@rm -f btest$(EXEEXT)\n-\t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n-stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) $(EXTRA_stest_DEPENDENCIES) \n-\t@rm -f stest$(EXEEXT)\n-\t$(LINK) $(stest_OBJECTS) $(stest_LDADD) $(LIBS)\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-.c.o:\n-\t$(COMPILE) -c $<\n-\n-.c.obj:\n-\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n-\n-.c.lo:\n-\t$(LTCOMPILE) -c -o $@ $<\n-\n-btest-btest.o: btest.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n-\n-btest-btest.obj: btest.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\t-rm -f libtool config.lt\n-\n-# GNU Make needs to see an explicit $(MAKE) variable in the command it\n-# runs to enable its job server during parallel builds.  Hence the\n-# comments below.\n-all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n-install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n-\n-mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n-distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n-maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n-\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tmkid -fID $$unique\n-tags: TAGS\n-\n-TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tset x; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: CTAGS\n-CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-\n-check-TESTS: $(TESTS)\n-\t@failed=0; all=0; xfail=0; xpass=0; skip=0; \\\n-\tsrcdir=$(srcdir); export srcdir; \\\n-\tlist=' $(TESTS) '; \\\n-\t$(am__tty_colors); \\\n-\tif test -n \"$$list\"; then \\\n-\t  for tst in $$list; do \\\n-\t    if test -f ./$$tst; then dir=./; \\\n-\t    elif test -f $$tst; then dir=; \\\n-\t    else dir=\"$(srcdir)/\"; fi; \\\n-\t    if $(TESTS_ENVIRONMENT) $${dir}$$tst; then \\\n-\t      all=`expr $$all + 1`; \\\n-\t      case \" $(XFAIL_TESTS) \" in \\\n-\t      *[\\ \\\t]$$tst[\\ \\\t]*) \\\n-\t\txpass=`expr $$xpass + 1`; \\\n-\t\tfailed=`expr $$failed + 1`; \\\n-\t\tcol=$$red; res=XPASS; \\\n-\t      ;; \\\n-\t      *) \\\n-\t\tcol=$$grn; res=PASS; \\\n-\t      ;; \\\n-\t      esac; \\\n-\t    elif test $$? -ne 77; then \\\n-\t      all=`expr $$all + 1`; \\\n-\t      case \" $(XFAIL_TESTS) \" in \\\n-\t      *[\\ \\\t]$$tst[\\ \\\t]*) \\\n-\t\txfail=`expr $$xfail + 1`; \\\n-\t\tcol=$$lgn; res=XFAIL; \\\n-\t      ;; \\\n-\t      *) \\\n-\t\tfailed=`expr $$failed + 1`; \\\n-\t\tcol=$$red; res=FAIL; \\\n-\t      ;; \\\n-\t      esac; \\\n-\t    else \\\n-\t      skip=`expr $$skip + 1`; \\\n-\t      col=$$blu; res=SKIP; \\\n-\t    fi; \\\n-\t    echo \"$${col}$$res$${std}: $$tst\"; \\\n-\t  done; \\\n-\t  if test \"$$all\" -eq 1; then \\\n-\t    tests=\"test\"; \\\n-\t    All=\"\"; \\\n-\t  else \\\n-\t    tests=\"tests\"; \\\n-\t    All=\"All \"; \\\n-\t  fi; \\\n-\t  if test \"$$failed\" -eq 0; then \\\n-\t    if test \"$$xfail\" -eq 0; then \\\n-\t      banner=\"$$All$$all $$tests passed\"; \\\n-\t    else \\\n-\t      if test \"$$xfail\" -eq 1; then failures=failure; else failures=failures; fi; \\\n-\t      banner=\"$$All$$all $$tests behaved as expected ($$xfail expected $$failures)\"; \\\n-\t    fi; \\\n-\t  else \\\n-\t    if test \"$$xpass\" -eq 0; then \\\n-\t      banner=\"$$failed of $$all $$tests failed\"; \\\n-\t    else \\\n-\t      if test \"$$xpass\" -eq 1; then passes=pass; else passes=passes; fi; \\\n-\t      banner=\"$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)\"; \\\n-\t    fi; \\\n-\t  fi; \\\n-\t  dashes=\"$$banner\"; \\\n-\t  skipped=\"\"; \\\n-\t  if test \"$$skip\" -ne 0; then \\\n-\t    if test \"$$skip\" -eq 1; then \\\n-\t      skipped=\"($$skip test was not run)\"; \\\n-\t    else \\\n-\t      skipped=\"($$skip tests were not run)\"; \\\n-\t    fi; \\\n-\t    test `echo \"$$skipped\" | wc -c` -le `echo \"$$banner\" | wc -c` || \\\n-\t      dashes=\"$$skipped\"; \\\n-\t  fi; \\\n-\t  report=\"\"; \\\n-\t  if test \"$$failed\" -ne 0 && test -n \"$(PACKAGE_BUGREPORT)\"; then \\\n-\t    report=\"Please report to $(PACKAGE_BUGREPORT)\"; \\\n-\t    test `echo \"$$report\" | wc -c` -le `echo \"$$banner\" | wc -c` || \\\n-\t      dashes=\"$$report\"; \\\n-\t  fi; \\\n-\t  dashes=`echo \"$$dashes\" | sed s/./=/g`; \\\n-\t  if test \"$$failed\" -eq 0; then \\\n-\t    col=\"$$grn\"; \\\n-\t  else \\\n-\t    col=\"$$red\"; \\\n-\t  fi; \\\n-\t  echo \"$${col}$$dashes$${std}\"; \\\n-\t  echo \"$${col}$$banner$${std}\"; \\\n-\t  test -z \"$$skipped\" || echo \"$${col}$$skipped$${std}\"; \\\n-\t  test -z \"$$report\" || echo \"$${col}$$report$${std}\"; \\\n-\t  echo \"$${col}$$dashes$${std}\"; \\\n-\t  test \"$$failed\" -eq 0; \\\n-\telse :; fi\n-check-am: all-am\n-\t$(MAKE) $(AM_MAKEFLAGS) $(check_PROGRAMS)\n-\t$(MAKE) $(AM_MAKEFLAGS) check-TESTS\n-check: check-am\n-all-am: Makefile $(LTLIBRARIES) all-multi config.h\n-installdirs:\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am clean-multi\n-\n-clean-am: clean-checkPROGRAMS clean-generic clean-libtool \\\n-\tclean-noinstLTLIBRARIES mostlyclean-am\n-\n-distclean: distclean-am distclean-multi\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-hdr distclean-libtool distclean-tags\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-html-am:\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am:\n-\n-install-dvi: install-dvi-am\n-\n-install-dvi-am:\n-\n-install-exec-am: install-multi\n-\n-install-html: install-html-am\n-\n-install-html-am:\n-\n-install-info: install-info-am\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-am\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-am\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am maintainer-clean-multi\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am mostlyclean-multi\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am:\n-\n-.MAKE: all all-multi check-am clean-multi distclean-multi install-am \\\n-\tinstall-multi install-strip maintainer-clean-multi \\\n-\tmostlyclean-multi\n-\n-.PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-TESTS \\\n-\tcheck-am clean clean-checkPROGRAMS clean-generic clean-libtool \\\n-\tclean-multi clean-noinstLTLIBRARIES ctags distclean \\\n-\tdistclean-compile distclean-generic distclean-hdr \\\n-\tdistclean-libtool distclean-multi distclean-tags dvi dvi-am \\\n-\thtml html-am info info-am install install-am install-data \\\n-\tinstall-data-am install-dvi install-dvi-am install-exec \\\n-\tinstall-exec-am install-html install-html-am install-info \\\n-\tinstall-info-am install-man install-multi install-pdf \\\n-\tinstall-pdf-am install-ps install-ps-am install-strip \\\n-\tinstallcheck installcheck-am installdirs maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n-\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-multi pdf pdf-am ps ps-am tags uninstall \\\n-\tuninstall-am\n-\n-alloc.lo: config.h backtrace.h internal.h\n-backtrace.lo: config.h backtrace.h internal.h\n-btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h\n-dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n-\t$(INCDIR)/filenames.h backtrace.h internal.h\n-elf.lo: config.h backtrace.h internal.h\n-fileline.lo: config.h backtrace.h internal.h\n-mmap.lo: config.h backtrace.h internal.h\n-mmapio.lo: config.h backtrace.h internal.h\n-nounwind.lo: config.h internal.h\n-pecoff.lo: config.h backtrace.h internal.h\n-posix.lo: config.h backtrace.h internal.h\n-print.lo: config.h backtrace.h internal.h\n-read.lo: config.h backtrace.h internal.h\n-simple.lo: config.h backtrace.h internal.h\n-sort.lo: config.h backtrace.h internal.h\n-stest.lo: config.h backtrace.h internal.h\n-state.lo: config.h backtrace.h backtrace-supported.h internal.h\n-unknown.lo: config.h backtrace.h internal.h\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "e8b225745c9c639e67ea4f6fa0f97041ba978276", "filename": "src/libbacktrace/README", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FREADME?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,23 +0,0 @@\n-The libbacktrace library\n-Initially written by Ian Lance Taylor <iant@google.com>\n-\n-The libbacktrace library may be linked into a program or library and\n-used to produce symbolic backtraces.  Sample uses would be to print a\n-detailed backtrace when an error occurs or to gather detailed\n-profiling information.\n-\n-The libbacktrace library is provided under a BSD license.  See the\n-source files for the exact license text.\n-\n-The public functions are declared and documented in the header file\n-backtrace.h, which should be #include'd by a user of the library.\n-\n-Building libbacktrace will generate a file backtrace-supported.h,\n-which a user of the library may use to determine whether backtraces\n-will work.  See the source file backtrace-supported.h.in for the\n-macros that it defines.\n-\n-As of September 2012, libbacktrace only supports ELF executables with\n-DWARF debugging information.  The library is written to make it\n-straightforward to add support for other object file and debugging\n-formats."}, {"sha": "8e84ddd1f10132210a49e7d08ba522e09df3a8ad", "filename": "src/libbacktrace/aclocal.m4", "status": "removed", "additions": 0, "deletions": 683, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Faclocal.m4?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,683 +0,0 @@\n-# generated automatically by aclocal 1.11.6 -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,\n-# Inc.\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n-[m4_warning([this file was generated for autoconf 2.64.\n-You have another version of autoconf.  It may work, but is not guaranteed to.\n-If you have problems, you may need to regenerate the build system entirely.\n-To do so, use the procedure documented by the package, typically `autoreconf'.])])\n-\n-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software\n-# Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-# (This private macro should not be called outside this file.)\n-AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.11'\n-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n-dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.11.6], [],\n-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n-])\n-\n-# _AM_AUTOCONF_VERSION(VERSION)\n-# -----------------------------\n-# aclocal traces this macro to find the Autoconf version.\n-# This is a private macro too.  Using m4_define simplifies\n-# the logic in aclocal, which can simply ignore this definition.\n-m4_define([_AM_AUTOCONF_VERSION], [])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.11.6])dnl\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n-\n-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is `.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[dnl Rely on autoconf to set up CDPATH properly.\n-AC_PREREQ([2.50])dnl\n-# expand $ac_aux_dir to an absolute path\n-am_aux_dir=`cd $ac_aux_dir && pwd`\n-])\n-\n-# AM_CONDITIONAL                                            -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 9\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ(2.52)dnl\n- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])dnl\n-AC_SUBST([$1_FALSE])dnl\n-_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n-_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n-m4_define([_AM_COND_VALUE_$1], [$2])dnl\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.]])\n-fi])])\n-\n-# Do all the work for Automake.                             -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 16\n-\n-# This macro actually does too much.  Some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.62])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n-  # is not polluted with repeated \"-I.\"\n-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n-  # test to see if srcdir already configured\n-  if test -f $srcdir/config.status; then\n-    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-  fi\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n- AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n-AM_MISSING_PROG(AUTOCONF, autoconf)\n-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n-AM_MISSING_PROG(AUTOHEADER, autoheader)\n-AM_MISSING_PROG(MAKEINFO, makeinfo)\n-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n-AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n-# We need awk for the \"check\" target.  The system \"awk\" is bad on\n-# some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n-\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n-\t\t\t     [_AM_PROG_TAR([v7])])])\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-\t\t  [_AM_DEPENDENCIES(CC)],\n-\t\t  [define([AC_PROG_CC],\n-\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-\t\t  [_AM_DEPENDENCIES(CXX)],\n-\t\t  [define([AC_PROG_CXX],\n-\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n-\t\t  [_AM_DEPENDENCIES(OBJC)],\n-\t\t  [define([AC_PROG_OBJC],\n-\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n-])\n-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n-AC_CONFIG_COMMANDS_PRE(dnl\n-[m4_provide_if([_AM_COMPILER_EXEEXT],\n-  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n-])\n-\n-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n-dnl mangled by Autoconf and run in a shell conditional statement.\n-m4_define([_AC_COMPILER_EXEEXT],\n-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n-\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_arg=$1\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $_am_arg | $_am_arg:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n-\n-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,\n-# Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-if test x\"${install_sh}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n-  *)\n-    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n-  esac\n-fi\n-AC_SUBST(install_sh)])\n-\n-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n-# From Jim Meyering\n-\n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,\n-# 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_MAINTAINER_MODE([DEFAULT-MODE])\n-# ----------------------------------\n-# Control maintainer-specific portions of Makefiles.\n-# Default is to disable them, unless `enable' is passed literally.\n-# For symmetry, `disable' may be passed as well.  Anyway, the user\n-# can override the default with the --enable/--disable switch.\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[m4_case(m4_default([$1], [disable]),\n-       [enable], [m4_define([am_maintainer_other], [disable])],\n-       [disable], [m4_define([am_maintainer_other], [enable])],\n-       [m4_define([am_maintainer_other], [enable])\n-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n-  AC_ARG_ENABLE([maintainer-mode],\n-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n-\t\t\t  (and sometimes confusing) to the casual installer],\n-      [USE_MAINTAINER_MODE=$enableval],\n-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST([MAINT])dnl\n-]\n-)\n-\n-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n-\n-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 6\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it supports --run.\n-# If it does, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([missing])dnl\n-if test x\"${MISSING+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n-  esac\n-fi\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --run true\"; then\n-  am_missing_run=\"$MISSING --run \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN([`missing' script is too old or missing])\n-fi\n-])\n-\n-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,\n-# Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_MKDIR_P\n-# ---------------\n-# Check for `mkdir -p'.\n-AC_DEFUN([AM_PROG_MKDIR_P],\n-[AC_PREREQ([2.60])dnl\n-AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n-dnl while keeping a definition of mkdir_p for backward compatibility.\n-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n-dnl Makefile.ins that do not define MKDIR_P, so we do our own\n-dnl adjustment using top_builddir (which is defined more often than\n-dnl MKDIR_P).\n-AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n-case $mkdir_p in\n-  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n-  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n-esac\n-])\n-\n-# Helper functions for option handling.                     -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software\n-# Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# --------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Just in case\n-sleep 1\n-echo timestamp > conftest.file\n-# Reject unsafe characters in $srcdir or the absolute working directory\n-# name.  Accept space and tab only in the latter.\n-am_lf='\n-'\n-case `pwd` in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n-    AC_MSG_ERROR([unsafe absolute working directory name]);;\n-esac\n-case $srcdir in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n-esac\n-\n-# Do `set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n-   if test \"$[*]\" = \"X\"; then\n-      # -L didn't work.\n-      set X `ls -t \"$srcdir/configure\" conftest.file`\n-   fi\n-   rm -f conftest.file\n-   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-      # If neither matched, then we have a broken ls.  This can happen\n-      # if, for instance, CONFIG_SHELL is bash and it inherits a\n-      # broken ls alias from the environment.  This has actually\n-      # happened.  Such a system could not be considered \"sane\".\n-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-alias in your environment])\n-   fi\n-\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT(yes)])\n-\n-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_INSTALL_STRIP\n-# ---------------------\n-# One issue with vendor `install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in `make install-strip', and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using `strip' when the user\n-# run `make install-strip'.  However `strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the `STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-\n-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 3\n-\n-# _AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n-# This macro is traced by Automake.\n-AC_DEFUN([_AM_SUBST_NOTMAKE])\n-\n-# AM_SUBST_NOTMAKE(VARIABLE)\n-# --------------------------\n-# Public sister of _AM_SUBST_NOTMAKE.\n-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n-\n-# Check how to create a tarball.                            -*- Autoconf -*-\n-\n-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 2\n-\n-# _AM_PROG_TAR(FORMAT)\n-# --------------------\n-# Check how to create a tarball in format FORMAT.\n-# FORMAT should be one of `v7', `ustar', or `pax'.\n-#\n-# Substitute a variable $(am__tar) that is a command\n-# writing to stdout a FORMAT-tarball containing the directory\n-# $tardir.\n-#     tardir=directory && $(am__tar) > result.tar\n-#\n-# Substitute a variable $(am__untar) that extract such\n-# a tarball read from stdin.\n-#     $(am__untar) < result.tar\n-AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.  Yes, it's still used\n-# in the wild :-(  We should find a proper way to deprecate it ...\n-AC_SUBST([AMTAR], ['$${TAR-tar}'])\n-m4_if([$1], [v7],\n-     [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n-     [m4_case([$1], [ustar],, [pax],,\n-              [m4_fatal([Unknown tar format])])\n-AC_MSG_CHECKING([how to create a $1 tar archive])\n-# Loop over all known methods to create a tar archive until one works.\n-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n-_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n-# Do not fold the above two line into one, because Tru64 sh and\n-# Solaris sh will not grok spaces in the rhs of `-'.\n-for _am_tool in $_am_tools\n-do\n-  case $_am_tool in\n-  gnutar)\n-    for _am_tar in tar gnutar gtar;\n-    do\n-      AM_RUN_LOG([$_am_tar --version]) && break\n-    done\n-    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n-    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n-    am__untar=\"$_am_tar -xf -\"\n-    ;;\n-  plaintar)\n-    # Must skip GNU tar: if it does not support --format= it doesn't create\n-    # ustar tarball either.\n-    (tar --version) >/dev/null 2>&1 && continue\n-    am__tar='tar chf - \"$$tardir\"'\n-    am__tar_='tar chf - \"$tardir\"'\n-    am__untar='tar xf -'\n-    ;;\n-  pax)\n-    am__tar='pax -L -x $1 -w \"$$tardir\"'\n-    am__tar_='pax -L -x $1 -w \"$tardir\"'\n-    am__untar='pax -r'\n-    ;;\n-  cpio)\n-    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n-    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n-    am__untar='cpio -i -H $1 -d'\n-    ;;\n-  none)\n-    am__tar=false\n-    am__tar_=false\n-    am__untar=false\n-    ;;\n-  esac\n-\n-  # If the value was cached, stop now.  We just wanted to have am__tar\n-  # and am__untar set.\n-  test -n \"${am_cv_prog_tar_$1}\" && break\n-\n-  # tar/untar a dummy directory, and stop if the command works\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  echo GrepMe > conftest.dir/file\n-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n-  rm -rf conftest.dir\n-  if test -s conftest.tar; then\n-    AM_RUN_LOG([$am__untar <conftest.tar])\n-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n-  fi\n-done\n-rm -rf conftest.dir\n-\n-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n-AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n-AC_SUBST([am__tar])\n-AC_SUBST([am__untar])\n-]) # _AM_PROG_TAR\n-\n-m4_include([../config/lead-dot.m4])\n-m4_include([../config/multi.m4])\n-m4_include([../config/override.m4])\n-m4_include([../config/stdint.m4])\n-m4_include([../config/unwind_ipinfo.m4])\n-m4_include([../config/warnings.m4])\n-m4_include([../libtool.m4])\n-m4_include([../ltoptions.m4])\n-m4_include([../ltsugar.m4])\n-m4_include([../ltversion.m4])\n-m4_include([../lt~obsolete.m4])"}, {"sha": "a9f07a013f8feec7a4508b7fc7189fb188c90031", "filename": "src/libbacktrace/alloc.c", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Falloc.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Falloc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Falloc.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,156 +0,0 @@\n-/* alloc.c -- Memory allocation without mmap.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* Allocation routines to use on systems that do not support anonymous\n-   mmap.  This implementation just uses malloc, which means that the\n-   backtrace functions may not be safely invoked from a signal\n-   handler.  */\n-\n-/* Allocate memory like malloc.  If ERROR_CALLBACK is NULL, don't\n-   report an error.  */\n-\n-void *\n-backtrace_alloc (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t size_t size, backtrace_error_callback error_callback,\n-\t\t void *data)\n-{\n-  void *ret;\n-\n-  ret = malloc (size);\n-  if (ret == NULL)\n-    {\n-      if (error_callback)\n-\terror_callback (data, \"malloc\", errno);\n-    }\n-  return ret;\n-}\n-\n-/* Free memory.  */\n-\n-void\n-backtrace_free (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\tvoid *p, size_t size ATTRIBUTE_UNUSED,\n-\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t\tvoid *data ATTRIBUTE_UNUSED)\n-{\n-  free (p);\n-}\n-\n-/* Grow VEC by SIZE bytes.  */\n-\n-void *\n-backtrace_vector_grow (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t       size_t size, backtrace_error_callback error_callback,\n-\t\t       void *data, struct backtrace_vector *vec)\n-{\n-  void *ret;\n-\n-  if (size > vec->alc)\n-    {\n-      size_t alc;\n-      void *base;\n-\n-      if (vec->size == 0)\n-\talc = 32 * size;\n-      else if (vec->size >= 4096)\n-\talc = vec->size + 4096;\n-      else\n-\talc = 2 * vec->size;\n-\n-      if (alc < vec->size + size)\n-\talc = vec->size + size;\n-\n-      base = realloc (vec->base, alc);\n-      if (base == NULL)\n-\t{\n-\t  error_callback (data, \"realloc\", errno);\n-\t  return NULL;\n-\t}\n-\n-      vec->base = base;\n-      vec->alc = alc - vec->size;\n-    }\n-\n-  ret = (char *) vec->base + vec->size;\n-  vec->size += size;\n-  vec->alc -= size;\n-  return ret;\n-}\n-\n-/* Finish the current allocation on VEC.  */\n-\n-void *\n-backtrace_vector_finish (struct backtrace_state *state,\n-\t\t\t struct backtrace_vector *vec,\n-\t\t\t backtrace_error_callback error_callback,\n-\t\t\t void *data)\n-{\n-  void *ret;\n-\n-  /* With this allocator we call realloc in backtrace_vector_grow,\n-     which means we can't easily reuse the memory here.  So just\n-     release it.  */\n-  if (!backtrace_vector_release (state, vec, error_callback, data))\n-    return NULL;\n-  ret = vec->base;\n-  vec->base = NULL;\n-  vec->size = 0;\n-  vec->alc = 0;\n-  return ret;\n-}\n-\n-/* Release any extra space allocated for VEC.  */\n-\n-int\n-backtrace_vector_release (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t\t  struct backtrace_vector *vec,\n-\t\t\t  backtrace_error_callback error_callback,\n-\t\t\t  void *data)\n-{\n-  vec->base = realloc (vec->base, vec->size);\n-  if (vec->base == NULL)\n-    {\n-      error_callback (data, \"realloc\", errno);\n-      return 0;\n-    }\n-  vec->alc = 0;\n-  return 1;\n-}"}, {"sha": "4087dd729175082d6e00f7371b4fbab18236aa78", "filename": "src/libbacktrace/ansidecl.h", "status": "removed", "additions": 0, "deletions": 329, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fansidecl.h", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fansidecl.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fansidecl.h?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,329 +0,0 @@\n-/* ANSI and traditional C compatibility macros\n-   Copyright (C) 1991-2015 Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-\n-This program is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n-\n-/* ANSI and traditional C compatibility macros\n-\n-   ANSI C is assumed if __STDC__ is #defined.\n-\n-   Macro\t\tANSI C definition\tTraditional C definition\n-   -----\t\t---- - ----------\t----------- - ----------\n-   PTR\t\t\t`void *'\t\t`char *'\n-   const\t\tnot defined\t\t`'\n-   volatile\t\tnot defined\t\t`'\n-   signed\t\tnot defined\t\t`'\n-\n-   For ease of writing code which uses GCC extensions but needs to be\n-   portable to other compilers, we provide the GCC_VERSION macro that\n-   simplifies testing __GNUC__ and __GNUC_MINOR__ together, and various\n-   wrappers around __attribute__.  Also, __extension__ will be #defined\n-   to nothing if it doesn't work.  See below.  */\n-\n-#ifndef\t_ANSIDECL_H\n-#define _ANSIDECL_H\t1\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-/* Every source file includes this file,\n-   so they will all get the switch for lint.  */\n-/* LINTLIBRARY */\n-\n-/* Using MACRO(x,y) in cpp #if conditionals does not work with some\n-   older preprocessors.  Thus we can't define something like this:\n-\n-#define HAVE_GCC_VERSION(MAJOR, MINOR) \\\n-  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))\n-\n-and then test \"#if HAVE_GCC_VERSION(2,7)\".\n-\n-So instead we use the macro below and test it against specific values.  */\n-\n-/* This macro simplifies testing whether we are using gcc, and if it\n-   is of a particular minimum version. (Both major & minor numbers are\n-   significant.)  This macro will evaluate to 0 if we are not using\n-   gcc at all.  */\n-#ifndef GCC_VERSION\n-#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n-#endif /* GCC_VERSION */\n-\n-#if defined (__STDC__) || defined(__cplusplus) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)\n-/* All known AIX compilers implement these things (but don't always\n-   define __STDC__).  The RISC/OS MIPS compiler defines these things\n-   in SVR4 mode, but does not define __STDC__.  */\n-/* eraxxon@alumni.rice.edu: The Compaq C++ compiler, unlike many other\n-   C++ compilers, does not define __STDC__, though it acts as if this\n-   was so. (Verified versions: 5.7, 6.2, 6.3, 6.5) */\n-\n-#define PTR\t\tvoid *\n-\n-#undef const\n-#undef volatile\n-#undef signed\n-\n-/* inline requires special treatment; it's in C99, and GCC >=2.7 supports\n-   it too, but it's not in C89.  */\n-#undef inline\n-#if __STDC_VERSION__ >= 199901L || defined(__cplusplus) || (defined(__SUNPRO_C) && defined(__C99FEATURES__))\n-/* it's a keyword */\n-#else\n-# if GCC_VERSION >= 2007\n-#  define inline __inline__   /* __inline__ prevents -pedantic warnings */\n-# else\n-#  define inline  /* nothing */\n-# endif\n-#endif\n-\n-#else\t/* Not ANSI C.  */\n-\n-#define PTR\t\tchar *\n-\n-/* some systems define these in header files for non-ansi mode */\n-#undef const\n-#undef volatile\n-#undef signed\n-#undef inline\n-#define const\n-#define volatile\n-#define signed\n-#define inline\n-\n-#endif\t/* ANSI C.  */\n-\n-/* Define macros for some gcc attributes.  This permits us to use the\n-   macros freely, and know that they will come into play for the\n-   version of gcc in which they are supported.  */\n-\n-#if (GCC_VERSION < 2007)\n-# define __attribute__(x)\n-#endif\n-\n-/* Attribute __malloc__ on functions was valid as of gcc 2.96. */\n-#ifndef ATTRIBUTE_MALLOC\n-# if (GCC_VERSION >= 2096)\n-#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))\n-# else\n-#  define ATTRIBUTE_MALLOC\n-# endif /* GNUC >= 2.96 */\n-#endif /* ATTRIBUTE_MALLOC */\n-\n-/* Attributes on labels were valid as of gcc 2.93 and g++ 4.5.  For\n-   g++ an attribute on a label must be followed by a semicolon.  */\n-#ifndef ATTRIBUTE_UNUSED_LABEL\n-# ifndef __cplusplus\n-#  if GCC_VERSION >= 2093\n-#   define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED\n-#  else\n-#   define ATTRIBUTE_UNUSED_LABEL\n-#  endif\n-# else\n-#  if GCC_VERSION >= 4005\n-#   define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED ;\n-#  else\n-#   define ATTRIBUTE_UNUSED_LABEL\n-#  endif\n-# endif\n-#endif\n-\n-/* Similarly to ARG_UNUSED below.  Prior to GCC 3.4, the C++ frontend\n-   couldn't parse attributes placed after the identifier name, and now\n-   the entire compiler is built with C++.  */\n-#ifndef ATTRIBUTE_UNUSED\n-#if GCC_VERSION >= 3004\n-#  define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n-#else\n-#define ATTRIBUTE_UNUSED\n-#endif\n-#endif /* ATTRIBUTE_UNUSED */\n-\n-/* Before GCC 3.4, the C++ frontend couldn't parse attributes placed after the\n-   identifier name.  */\n-#if ! defined(__cplusplus) || (GCC_VERSION >= 3004)\n-# define ARG_UNUSED(NAME) NAME ATTRIBUTE_UNUSED\n-#else /* !__cplusplus || GNUC >= 3.4 */\n-# define ARG_UNUSED(NAME) NAME\n-#endif /* !__cplusplus || GNUC >= 3.4 */\n-\n-#ifndef ATTRIBUTE_NORETURN\n-#define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))\n-#endif /* ATTRIBUTE_NORETURN */\n-\n-/* Attribute `nonnull' was valid as of gcc 3.3.  */\n-#ifndef ATTRIBUTE_NONNULL\n-# if (GCC_VERSION >= 3003)\n-#  define ATTRIBUTE_NONNULL(m) __attribute__ ((__nonnull__ (m)))\n-# else\n-#  define ATTRIBUTE_NONNULL(m)\n-# endif /* GNUC >= 3.3 */\n-#endif /* ATTRIBUTE_NONNULL */\n-\n-/* Attribute `returns_nonnull' was valid as of gcc 4.9.  */\n-#ifndef ATTRIBUTE_RETURNS_NONNULL\n-# if (GCC_VERSION >= 4009)\n-#  define ATTRIBUTE_RETURNS_NONNULL __attribute__ ((__returns_nonnull__))\n-# else\n-#  define ATTRIBUTE_RETURNS_NONNULL\n-# endif /* GNUC >= 4.9 */\n-#endif /* ATTRIBUTE_RETURNS_NONNULL */\n-\n-/* Attribute `pure' was valid as of gcc 3.0.  */\n-#ifndef ATTRIBUTE_PURE\n-# if (GCC_VERSION >= 3000)\n-#  define ATTRIBUTE_PURE __attribute__ ((__pure__))\n-# else\n-#  define ATTRIBUTE_PURE\n-# endif /* GNUC >= 3.0 */\n-#endif /* ATTRIBUTE_PURE */\n-\n-/* Use ATTRIBUTE_PRINTF when the format specifier must not be NULL.\n-   This was the case for the `printf' format attribute by itself\n-   before GCC 3.3, but as of 3.3 we need to add the `nonnull'\n-   attribute to retain this behavior.  */\n-#ifndef ATTRIBUTE_PRINTF\n-#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n))) ATTRIBUTE_NONNULL(m)\n-#define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)\n-#define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)\n-#define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)\n-#define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)\n-#define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)\n-#endif /* ATTRIBUTE_PRINTF */\n-\n-/* Use ATTRIBUTE_FPTR_PRINTF when the format attribute is to be set on\n-   a function pointer.  Format attributes were allowed on function\n-   pointers as of gcc 3.1.  */\n-#ifndef ATTRIBUTE_FPTR_PRINTF\n-# if (GCC_VERSION >= 3001)\n-#  define ATTRIBUTE_FPTR_PRINTF(m, n) ATTRIBUTE_PRINTF(m, n)\n-# else\n-#  define ATTRIBUTE_FPTR_PRINTF(m, n)\n-# endif /* GNUC >= 3.1 */\n-# define ATTRIBUTE_FPTR_PRINTF_1 ATTRIBUTE_FPTR_PRINTF(1, 2)\n-# define ATTRIBUTE_FPTR_PRINTF_2 ATTRIBUTE_FPTR_PRINTF(2, 3)\n-# define ATTRIBUTE_FPTR_PRINTF_3 ATTRIBUTE_FPTR_PRINTF(3, 4)\n-# define ATTRIBUTE_FPTR_PRINTF_4 ATTRIBUTE_FPTR_PRINTF(4, 5)\n-# define ATTRIBUTE_FPTR_PRINTF_5 ATTRIBUTE_FPTR_PRINTF(5, 6)\n-#endif /* ATTRIBUTE_FPTR_PRINTF */\n-\n-/* Use ATTRIBUTE_NULL_PRINTF when the format specifier may be NULL.  A\n-   NULL format specifier was allowed as of gcc 3.3.  */\n-#ifndef ATTRIBUTE_NULL_PRINTF\n-# if (GCC_VERSION >= 3003)\n-#  define ATTRIBUTE_NULL_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n)))\n-# else\n-#  define ATTRIBUTE_NULL_PRINTF(m, n)\n-# endif /* GNUC >= 3.3 */\n-# define ATTRIBUTE_NULL_PRINTF_1 ATTRIBUTE_NULL_PRINTF(1, 2)\n-# define ATTRIBUTE_NULL_PRINTF_2 ATTRIBUTE_NULL_PRINTF(2, 3)\n-# define ATTRIBUTE_NULL_PRINTF_3 ATTRIBUTE_NULL_PRINTF(3, 4)\n-# define ATTRIBUTE_NULL_PRINTF_4 ATTRIBUTE_NULL_PRINTF(4, 5)\n-# define ATTRIBUTE_NULL_PRINTF_5 ATTRIBUTE_NULL_PRINTF(5, 6)\n-#endif /* ATTRIBUTE_NULL_PRINTF */\n-\n-/* Attribute `sentinel' was valid as of gcc 3.5.  */\n-#ifndef ATTRIBUTE_SENTINEL\n-# if (GCC_VERSION >= 3005)\n-#  define ATTRIBUTE_SENTINEL __attribute__ ((__sentinel__))\n-# else\n-#  define ATTRIBUTE_SENTINEL\n-# endif /* GNUC >= 3.5 */\n-#endif /* ATTRIBUTE_SENTINEL */\n-\n-\n-#ifndef ATTRIBUTE_ALIGNED_ALIGNOF\n-# if (GCC_VERSION >= 3000)\n-#  define ATTRIBUTE_ALIGNED_ALIGNOF(m) __attribute__ ((__aligned__ (__alignof__ (m))))\n-# else\n-#  define ATTRIBUTE_ALIGNED_ALIGNOF(m)\n-# endif /* GNUC >= 3.0 */\n-#endif /* ATTRIBUTE_ALIGNED_ALIGNOF */\n-\n-/* Useful for structures whose layout must much some binary specification\n-   regardless of the alignment and padding qualities of the compiler.  */\n-#ifndef ATTRIBUTE_PACKED\n-# define ATTRIBUTE_PACKED __attribute__ ((packed))\n-#endif\n-\n-/* Attribute `hot' and `cold' was valid as of gcc 4.3.  */\n-#ifndef ATTRIBUTE_COLD\n-# if (GCC_VERSION >= 4003)\n-#  define ATTRIBUTE_COLD __attribute__ ((__cold__))\n-# else\n-#  define ATTRIBUTE_COLD\n-# endif /* GNUC >= 4.3 */\n-#endif /* ATTRIBUTE_COLD */\n-#ifndef ATTRIBUTE_HOT\n-# if (GCC_VERSION >= 4003)\n-#  define ATTRIBUTE_HOT __attribute__ ((__hot__))\n-# else\n-#  define ATTRIBUTE_HOT\n-# endif /* GNUC >= 4.3 */\n-#endif /* ATTRIBUTE_HOT */\n-\n-/* Attribute 'no_sanitize_undefined' was valid as of gcc 4.9.  */\n-#ifndef ATTRIBUTE_NO_SANITIZE_UNDEFINED\n-# if (GCC_VERSION >= 4009)\n-#  define ATTRIBUTE_NO_SANITIZE_UNDEFINED __attribute__ ((no_sanitize_undefined))\n-# else\n-#  define ATTRIBUTE_NO_SANITIZE_UNDEFINED\n-# endif /* GNUC >= 4.9 */\n-#endif /* ATTRIBUTE_NO_SANITIZE_UNDEFINED */\n-\n-/* We use __extension__ in some places to suppress -pedantic warnings\n-   about GCC extensions.  This feature didn't work properly before\n-   gcc 2.8.  */\n-#if GCC_VERSION < 2008\n-#define __extension__\n-#endif\n-\n-/* This is used to declare a const variable which should be visible\n-   outside of the current compilation unit.  Use it as\n-     EXPORTED_CONST int i = 1;\n-   This is because the semantics of const are different in C and C++.\n-   \"extern const\" is permitted in C but it looks strange, and gcc\n-   warns about it when -Wc++-compat is not used.  */\n-#ifdef __cplusplus\n-#define EXPORTED_CONST extern const\n-#else\n-#define EXPORTED_CONST const\n-#endif\n-\n-/* Be conservative and only use enum bitfields with C++ or GCC.\n-   FIXME: provide a complete autoconf test for buggy enum bitfields.  */\n-\n-#ifdef __cplusplus\n-#define ENUM_BITFIELD(TYPE) enum TYPE\n-#elif (GCC_VERSION > 2000)\n-#define ENUM_BITFIELD(TYPE) __extension__ enum TYPE\n-#else\n-#define ENUM_BITFIELD(TYPE) unsigned int\n-#endif\n-\n-    /* This is used to mark a class or virtual function as final.  */\n-#if __cplusplus >= 201103L\n-#define GCC_FINAL final\n-#elif GCC_VERSION >= 4007\n-#define GCC_FINAL __final\n-#else\n-#define GCC_FINAL\n-#endif\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif\t/* ansidecl.h\t*/"}, {"sha": "cb0ad0298e68a4bd3fc92ca20efadde0d1a0a8ca", "filename": "src/libbacktrace/atomic.c", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fatomic.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fatomic.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fatomic.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,113 +0,0 @@\n-/* atomic.c -- Support for atomic functions if not present.\n-   Copyright (C) 2013-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"backtrace-supported.h\"\n-#include \"internal.h\"\n-\n-/* This file holds implementations of the atomic functions that are\n-   used if the host compiler has the sync functions but not the atomic\n-   functions, as is true of versions of GCC before 4.7.  */\n-\n-#if !defined (HAVE_ATOMIC_FUNCTIONS) && defined (HAVE_SYNC_FUNCTIONS)\n-\n-/* Do an atomic load of a pointer.  */\n-\n-void *\n-backtrace_atomic_load_pointer (void *arg)\n-{\n-  void **pp;\n-  void *p;\n-\n-  pp = (void **) arg;\n-  p = *pp;\n-  while (!__sync_bool_compare_and_swap (pp, p, p))\n-    p = *pp;\n-  return p;\n-}\n-\n-/* Do an atomic load of an int.  */\n-\n-int\n-backtrace_atomic_load_int (int *p)\n-{\n-  int i;\n-\n-  i = *p;\n-  while (!__sync_bool_compare_and_swap (p, i, i))\n-    i = *p;\n-  return i;\n-}\n-\n-/* Do an atomic store of a pointer.  */\n-\n-void\n-backtrace_atomic_store_pointer (void *arg, void *p)\n-{\n-  void **pp;\n-  void *old;\n-\n-  pp = (void **) arg;\n-  old = *pp;\n-  while (!__sync_bool_compare_and_swap (pp, old, p))\n-    old = *pp;\n-}\n-\n-/* Do an atomic store of a size_t value.  */\n-\n-void\n-backtrace_atomic_store_size_t (size_t *p, size_t v)\n-{\n-  size_t old;\n-\n-  old = *p;\n-  while (!__sync_bool_compare_and_swap (p, old, v))\n-    old = *p;\n-}\n-\n-/* Do an atomic store of a int value.  */\n-\n-void\n-backtrace_atomic_store_int (int *p, int v)\n-{\n-  size_t old;\n-\n-  old = *p;\n-  while (!__sync_bool_compare_and_swap (p, old, v))\n-    old = *p;\n-}\n-\n-#endif"}, {"sha": "ab34199fcd362cceefb43d28f2c28daad07cc1f8", "filename": "src/libbacktrace/backtrace-supported.h.in", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace-supported.h.in?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,66 +0,0 @@\n-/* backtrace-supported.h.in -- Whether stack backtrace is supported.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-/* The file backtrace-supported.h.in is used by configure to generate\n-   the file backtrace-supported.h.  The file backtrace-supported.h may\n-   be #include'd to see whether the backtrace library will be able to\n-   get a backtrace and produce symbolic information.  */\n-\n-\n-/* BACKTRACE_SUPPORTED will be #define'd as 1 if the backtrace library\n-   should work, 0 if it will not.  Libraries may #include this to make\n-   other arrangements.  */\n-\n-#define BACKTRACE_SUPPORTED @BACKTRACE_SUPPORTED@\n-\n-/* BACKTRACE_USES_MALLOC will be #define'd as 1 if the backtrace\n-   library will call malloc as it works, 0 if it will call mmap\n-   instead.  This may be used to determine whether it is safe to call\n-   the backtrace functions from a signal handler.  In general this\n-   only applies to calls like backtrace and backtrace_pcinfo.  It does\n-   not apply to backtrace_simple, which never calls malloc.  It does\n-   not apply to backtrace_print, which always calls fprintf and\n-   therefore malloc.  */\n-\n-#define BACKTRACE_USES_MALLOC @BACKTRACE_USES_MALLOC@\n-\n-/* BACKTRACE_SUPPORTS_THREADS will be #define'd as 1 if the backtrace\n-   library is configured with threading support, 0 if not.  If this is\n-   0, the threaded parameter to backtrace_create_state must be passed\n-   as 0.  */\n-\n-#define BACKTRACE_SUPPORTS_THREADS @BACKTRACE_SUPPORTS_THREADS@\n-\n-/* BACKTRACE_SUPPORTS_DATA will be #defined'd as 1 if the backtrace_syminfo\n-   will work for variables.  It will always work for functions.  */\n-\n-#define BACKTRACE_SUPPORTS_DATA @BACKTRACE_SUPPORTS_DATA@"}, {"sha": "b89bf554ac548d2ab2a88fe65aa3907ac354e4a8", "filename": "src/libbacktrace/backtrace.c", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fbacktrace.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,129 +0,0 @@\n-/* backtrace.c -- Entry point for stack backtrace library.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <sys/types.h>\n-\n-#include \"unwind.h\"\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* The main backtrace_full routine.  */\n-\n-/* Data passed through _Unwind_Backtrace.  */\n-\n-struct backtrace_data\n-{\n-  /* Number of frames to skip.  */\n-  int skip;\n-  /* Library state.  */\n-  struct backtrace_state *state;\n-  /* Callback routine.  */\n-  backtrace_full_callback callback;\n-  /* Error callback routine.  */\n-  backtrace_error_callback error_callback;\n-  /* Data to pass to callback routines.  */\n-  void *data;\n-  /* Value to return from backtrace_full.  */\n-  int ret;\n-  /* Whether there is any memory available.  */\n-  int can_alloc;\n-};\n-\n-/* Unwind library callback routine.  This is passed to\n-   _Unwind_Backtrace.  */\n-\n-static _Unwind_Reason_Code\n-unwind (struct _Unwind_Context *context, void *vdata)\n-{\n-  struct backtrace_data *bdata = (struct backtrace_data *) vdata;\n-  uintptr_t pc;\n-  int ip_before_insn = 0;\n-\n-#ifdef HAVE_GETIPINFO\n-  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n-#else\n-  pc = _Unwind_GetIP (context);\n-#endif\n-\n-  if (bdata->skip > 0)\n-    {\n-      --bdata->skip;\n-      return _URC_NO_REASON;\n-    }\n-\n-  if (!ip_before_insn)\n-    --pc;\n-\n-  if (!bdata->can_alloc)\n-    bdata->ret = bdata->callback (bdata->data, pc, NULL, 0, NULL);\n-  else\n-    bdata->ret = backtrace_pcinfo (bdata->state, pc, bdata->callback,\n-\t\t\t\t   bdata->error_callback, bdata->data);\n-  if (bdata->ret != 0)\n-    return _URC_END_OF_STACK;\n-\n-  return _URC_NO_REASON;\n-}\n-\n-/* Get a stack backtrace.  */\n-\n-int\n-backtrace_full (struct backtrace_state *state, int skip,\n-\t\tbacktrace_full_callback callback,\n-\t\tbacktrace_error_callback error_callback, void *data)\n-{\n-  struct backtrace_data bdata;\n-  void *p;\n-\n-  bdata.skip = skip + 1;\n-  bdata.state = state;\n-  bdata.callback = callback;\n-  bdata.error_callback = error_callback;\n-  bdata.data = data;\n-  bdata.ret = 0;\n-\n-  /* If we can't allocate any memory at all, don't try to produce\n-     file/line information.  */\n-  p = backtrace_alloc (state, 4096, NULL, NULL);\n-  if (p == NULL)\n-    bdata.can_alloc = 0;\n-  else\n-    {\n-      backtrace_free (state, p, 4096, NULL, NULL);\n-      bdata.can_alloc = 1;\n-    }\n-\n-  _Unwind_Backtrace (unwind, &bdata);\n-  return bdata.ret;\n-}"}, {"sha": "d209219d9a419ea82a723d4a4bf4282a7a900a83", "filename": "src/libbacktrace/backtrace.h", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.h?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,199 +0,0 @@\n-/* backtrace.h -- Public header file for stack backtrace library.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#ifndef BACKTRACE_H\n-#define BACKTRACE_H\n-\n-#include <stddef.h>\n-#include <stdio.h>\n-\n-/* We want to get a definition for uintptr_t, but we still care about\n-   systems that don't have <stdint.h>.  */\n-#if defined(__GLIBC__) && __GLIBC__ >= 2\n-\n-#include <stdint.h>\n-\n-#elif defined(HAVE_STDINT_H)\n-\n-#include <stdint.h>\n-\n-#else\n-\n-/* Systems that don't have <stdint.h> must provide gstdint.h, e.g.,\n-   from GCC_HEADER_STDINT in configure.ac.  */\n-#include \"gstdint.h\"\n-\n-#endif\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-/* The backtrace state.  This struct is intentionally not defined in\n-   the public interface.  */\n-\n-struct backtrace_state;\n-\n-/* The type of the error callback argument to backtrace functions.\n-   This function, if not NULL, will be called for certain error cases.\n-   The DATA argument is passed to the function that calls this one.\n-   The MSG argument is an error message.  The ERRNUM argument, if\n-   greater than 0, holds an errno value.  The MSG buffer may become\n-   invalid after this function returns.\n-\n-   As a special case, the ERRNUM argument will be passed as -1 if no\n-   debug info can be found for the executable, but the function\n-   requires debug info (e.g., backtrace_full, backtrace_pcinfo).  The\n-   MSG in this case will be something along the lines of \"no debug\n-   info\".  Similarly, ERRNUM will be passed as -1 if there is no\n-   symbol table, but the function requires a symbol table (e.g.,\n-   backtrace_syminfo).  This may be used as a signal that some other\n-   approach should be tried.  */\n-\n-typedef void (*backtrace_error_callback) (void *data, const char *msg,\n-\t\t\t\t\t  int errnum);\n-\n-/* Create state information for the backtrace routines.  This must be\n-   called before any of the other routines, and its return value must\n-   be passed to all of the other routines.  FILENAME is the path name\n-   of the executable file; if it is NULL the library will try\n-   system-specific path names.  If not NULL, FILENAME must point to a\n-   permanent buffer.  If THREADED is non-zero the state may be\n-   accessed by multiple threads simultaneously, and the library will\n-   use appropriate atomic operations.  If THREADED is zero the state\n-   may only be accessed by one thread at a time.  This returns a state\n-   pointer on success, NULL on error.  If an error occurs, this will\n-   call the ERROR_CALLBACK routine.  */\n-\n-extern struct backtrace_state *backtrace_create_state (\n-    const char *filename, int threaded,\n-    backtrace_error_callback error_callback, void *data);\n-\n-/* The type of the callback argument to the backtrace_full function.\n-   DATA is the argument passed to backtrace_full.  PC is the program\n-   counter.  FILENAME is the name of the file containing PC, or NULL\n-   if not available.  LINENO is the line number in FILENAME containing\n-   PC, or 0 if not available.  FUNCTION is the name of the function\n-   containing PC, or NULL if not available.  This should return 0 to\n-   continuing tracing.  The FILENAME and FUNCTION buffers may become\n-   invalid after this function returns.  */\n-\n-typedef int (*backtrace_full_callback) (void *data, uintptr_t pc,\n-\t\t\t\t\tconst char *filename, int lineno,\n-\t\t\t\t\tconst char *function);\n-\n-/* Get a full stack backtrace.  SKIP is the number of frames to skip;\n-   passing 0 will start the trace with the function calling\n-   backtrace_full.  DATA is passed to the callback routine.  If any\n-   call to CALLBACK returns a non-zero value, the stack backtrace\n-   stops, and backtrace returns that value; this may be used to limit\n-   the number of stack frames desired.  If all calls to CALLBACK\n-   return 0, backtrace returns 0.  The backtrace_full function will\n-   make at least one call to either CALLBACK or ERROR_CALLBACK.  This\n-   function requires debug info for the executable.  */\n-\n-extern int backtrace_full (struct backtrace_state *state, int skip,\n-\t\t\t   backtrace_full_callback callback,\n-\t\t\t   backtrace_error_callback error_callback,\n-\t\t\t   void *data);\n-\n-/* The type of the callback argument to the backtrace_simple function.\n-   DATA is the argument passed to simple_backtrace.  PC is the program\n-   counter.  This should return 0 to continue tracing.  */\n-\n-typedef int (*backtrace_simple_callback) (void *data, uintptr_t pc);\n-\n-/* Get a simple backtrace.  SKIP is the number of frames to skip, as\n-   in backtrace.  DATA is passed to the callback routine.  If any call\n-   to CALLBACK returns a non-zero value, the stack backtrace stops,\n-   and backtrace_simple returns that value.  Otherwise\n-   backtrace_simple returns 0.  The backtrace_simple function will\n-   make at least one call to either CALLBACK or ERROR_CALLBACK.  This\n-   function does not require any debug info for the executable.  */\n-\n-extern int backtrace_simple (struct backtrace_state *state, int skip,\n-\t\t\t     backtrace_simple_callback callback,\n-\t\t\t     backtrace_error_callback error_callback,\n-\t\t\t     void *data);\n-\n-/* Print the current backtrace in a user readable format to a FILE.\n-   SKIP is the number of frames to skip, as in backtrace_full.  Any\n-   error messages are printed to stderr.  This function requires debug\n-   info for the executable.  */\n-\n-extern void backtrace_print (struct backtrace_state *state, int skip, FILE *);\n-\n-/* Given PC, a program counter in the current program, call the\n-   callback function with filename, line number, and function name\n-   information.  This will normally call the callback function exactly\n-   once.  However, if the PC happens to describe an inlined call, and\n-   the debugging information contains the necessary information, then\n-   this may call the callback function multiple times.  This will make\n-   at least one call to either CALLBACK or ERROR_CALLBACK.  This\n-   returns the first non-zero value returned by CALLBACK, or 0.  */\n-\n-extern int backtrace_pcinfo (struct backtrace_state *state, uintptr_t pc,\n-\t\t\t     backtrace_full_callback callback,\n-\t\t\t     backtrace_error_callback error_callback,\n-\t\t\t     void *data);\n-\n-/* The type of the callback argument to backtrace_syminfo.  DATA and\n-   PC are the arguments passed to backtrace_syminfo.  SYMNAME is the\n-   name of the symbol for the corresponding code.  SYMVAL is the\n-   value and SYMSIZE is the size of the symbol.  SYMNAME will be NULL\n-   if no error occurred but the symbol could not be found.  */\n-\n-typedef void (*backtrace_syminfo_callback) (void *data, uintptr_t pc,\n-\t\t\t\t\t    const char *symname,\n-\t\t\t\t\t    uintptr_t symval,\n-\t\t\t\t\t    uintptr_t symsize);\n-\n-/* Given ADDR, an address or program counter in the current program,\n-   call the callback information with the symbol name and value\n-   describing the function or variable in which ADDR may be found.\n-   This will call either CALLBACK or ERROR_CALLBACK exactly once.\n-   This returns 1 on success, 0 on failure.  This function requires\n-   the symbol table but does not require the debug info.  Note that if\n-   the symbol table is present but ADDR could not be found in the\n-   table, CALLBACK will be called with a NULL SYMNAME argument.\n-   Returns 1 on success, 0 on error.  */\n-\n-extern int backtrace_syminfo (struct backtrace_state *state, uintptr_t addr,\n-\t\t\t      backtrace_syminfo_callback callback,\n-\t\t\t      backtrace_error_callback error_callback,\n-\t\t\t      void *data);\n-\n-#ifdef __cplusplus\n-} /* End extern \"C\".  */\n-#endif\n-\n-#endif"}, {"sha": "0506d2b112186b7b61fa89b3e2ec20b7286a699b", "filename": "src/libbacktrace/btest.c", "status": "removed", "additions": 0, "deletions": 721, "changes": 721, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fbtest.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbtest.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,721 +0,0 @@\n-/* btest.c -- Test for libbacktrace library\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-/* This program tests the externally visible interfaces of the\n-   libbacktrace library.  */\n-\n-#include <assert.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"filenames.h\"\n-\n-#include \"backtrace.h\"\n-#include \"backtrace-supported.h\"\n-\n-/* Portable attribute syntax.  Actually some of these tests probably\n-   won't work if the attributes are not recognized.  */\n-\n-#ifndef GCC_VERSION\n-# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n-#endif\n-\n-#if (GCC_VERSION < 2007)\n-# define __attribute__(x)\n-#endif\n-\n-#ifndef ATTRIBUTE_UNUSED\n-# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n-#endif\n-\n-/* Used to collect backtrace info.  */\n-\n-struct info\n-{\n-  char *filename;\n-  int lineno;\n-  char *function;\n-};\n-\n-/* Passed to backtrace callback function.  */\n-\n-struct bdata\n-{\n-  struct info *all;\n-  size_t index;\n-  size_t max;\n-  int failed;\n-};\n-\n-/* Passed to backtrace_simple callback function.  */\n-\n-struct sdata\n-{\n-  uintptr_t *addrs;\n-  size_t index;\n-  size_t max;\n-  int failed;\n-};\n-\n-/* Passed to backtrace_syminfo callback function.  */\n-\n-struct symdata\n-{\n-  const char *name;\n-  uintptr_t val, size;\n-  int failed;\n-};\n-\n-/* The backtrace state.  */\n-\n-static void *state;\n-\n-/* The number of failures.  */\n-\n-static int failures;\n-\n-/* Return the base name in a path.  */\n-\n-static const char *\n-base (const char *p)\n-{\n-  const char *last;\n-  const char *s;\n-\n-  last = NULL;\n-  for (s = p; *s != '\\0'; ++s)\n-    {\n-      if (IS_DIR_SEPARATOR (*s))\n-\tlast = s + 1;\n-    }\n-  return last != NULL ? last : p;\n-}\n-\n-/* Check an entry in a struct info array.  */\n-\n-static void\n-check (const char *name, int index, const struct info *all, int want_lineno,\n-       const char *want_function, int *failed)\n-{\n-  if (*failed)\n-    return;\n-  if (all[index].filename == NULL || all[index].function == NULL)\n-    {\n-      fprintf (stderr, \"%s: [%d]: missing file name or function name\\n\",\n-\t       name, index);\n-      *failed = 1;\n-      return;\n-    }\n-  if (strcmp (base (all[index].filename), \"btest.c\") != 0)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %s expected test.c\\n\", name, index,\n-\t       all[index].filename);\n-      *failed = 1;\n-    }\n-  if (all[index].lineno != want_lineno)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %d expected %d\\n\", name, index,\n-\t       all[index].lineno, want_lineno);\n-      *failed = 1;\n-    }\n-  if (strcmp (all[index].function, want_function) != 0)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n-\t       all[index].function, want_function);\n-      *failed = 1;\n-    }\n-}\n-\n-/* The backtrace callback function.  */\n-\n-static int\n-callback_one (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n-\t      const char *filename, int lineno, const char *function)\n-{\n-  struct bdata *data = (struct bdata *) vdata;\n-  struct info *p;\n-\n-  if (data->index >= data->max)\n-    {\n-      fprintf (stderr, \"callback_one: callback called too many times\\n\");\n-      data->failed = 1;\n-      return 1;\n-    }\n-\n-  p = &data->all[data->index];\n-  if (filename == NULL)\n-    p->filename = NULL;\n-  else\n-    {\n-      p->filename = strdup (filename);\n-      assert (p->filename != NULL);\n-    }\n-  p->lineno = lineno;\n-  if (function == NULL)\n-    p->function = NULL;\n-  else\n-    {\n-      p->function = strdup (function);\n-      assert (p->function != NULL);\n-    }\n-  ++data->index;\n-\n-  return 0;\n-}\n-\n-/* An error callback passed to backtrace.  */\n-\n-static void\n-error_callback_one (void *vdata, const char *msg, int errnum)\n-{\n-  struct bdata *data = (struct bdata *) vdata;\n-\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  data->failed = 1;\n-}\n-\n-/* The backtrace_simple callback function.  */\n-\n-static int\n-callback_two (void *vdata, uintptr_t pc)\n-{\n-  struct sdata *data = (struct sdata *) vdata;\n-\n-  if (data->index >= data->max)\n-    {\n-      fprintf (stderr, \"callback_two: callback called too many times\\n\");\n-      data->failed = 1;\n-      return 1;\n-    }\n-\n-  data->addrs[data->index] = pc;\n-  ++data->index;\n-\n-  return 0;\n-}\n-\n-/* An error callback passed to backtrace_simple.  */\n-\n-static void\n-error_callback_two (void *vdata, const char *msg, int errnum)\n-{\n-  struct sdata *data = (struct sdata *) vdata;\n-\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  data->failed = 1;\n-}\n-\n-/* The backtrace_syminfo callback function.  */\n-\n-static void\n-callback_three (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n-\t\tconst char *symname, uintptr_t symval,\n-\t\tuintptr_t symsize)\n-{\n-  struct symdata *data = (struct symdata *) vdata;\n-\n-  if (symname == NULL)\n-    data->name = NULL;\n-  else\n-    {\n-      data->name = strdup (symname);\n-      assert (data->name != NULL);\n-    }\n-  data->val = symval;\n-  data->size = symsize;\n-}\n-\n-/* The backtrace_syminfo error callback function.  */\n-\n-static void\n-error_callback_three (void *vdata, const char *msg, int errnum)\n-{\n-  struct symdata *data = (struct symdata *) vdata;\n-\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  data->failed = 1;\n-}\n-\n-/* Test the backtrace function with non-inlined functions.  */\n-\n-static int test1 (void) __attribute__ ((noinline, unused));\n-static int f2 (int) __attribute__ ((noinline));\n-static int f3 (int, int) __attribute__ ((noinline));\n-\n-static int\n-test1 (void)\n-{\n-  /* Returning a value here and elsewhere avoids a tailcall which\n-     would mess up the backtrace.  */\n-  return f2 (__LINE__) + 1;\n-}\n-\n-static int\n-f2 (int f1line)\n-{\n-  return f3 (f1line, __LINE__) + 2;\n-}\n-\n-static int\n-f3 (int f1line, int f2line)\n-{\n-  struct info all[20];\n-  struct bdata data;\n-  int f3line;\n-  int i;\n-\n-  data.all = &all[0];\n-  data.index = 0;\n-  data.max = 20;\n-  data.failed = 0;\n-\n-  f3line = __LINE__ + 1;\n-  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n-\n-  if (i != 0)\n-    {\n-      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n-      data.failed = 1;\n-    }\n-\n-  if (data.index < 3)\n-    {\n-      fprintf (stderr,\n-\t       \"test1: not enough frames; got %zu, expected at least 3\\n\",\n-\t       data.index);\n-      data.failed = 1;\n-    }\n-\n-  check (\"test1\", 0, all, f3line, \"f3\", &data.failed);\n-  check (\"test1\", 1, all, f2line, \"f2\", &data.failed);\n-  check (\"test1\", 2, all, f1line, \"test1\", &data.failed);\n-\n-  printf (\"%s: backtrace_full noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n-\n-  if (data.failed)\n-    ++failures;\n-\n-  return failures;\n-}\n-\n-/* Test the backtrace function with inlined functions.  */\n-\n-static inline int test2 (void) __attribute__ ((always_inline, unused));\n-static inline int f12 (int) __attribute__ ((always_inline));\n-static inline int f13 (int, int) __attribute__ ((always_inline));\n-\n-static inline int\n-test2 (void)\n-{\n-  return f12 (__LINE__) + 1;\n-}\n-\n-static inline int\n-f12 (int f1line)\n-{\n-  return f13 (f1line, __LINE__) + 2;\n-}\n-\n-static inline int\n-f13 (int f1line, int f2line)\n-{\n-  struct info all[20];\n-  struct bdata data;\n-  int f3line;\n-  int i;\n-\n-  data.all = &all[0];\n-  data.index = 0;\n-  data.max = 20;\n-  data.failed = 0;\n-\n-  f3line = __LINE__ + 1;\n-  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n-\n-  if (i != 0)\n-    {\n-      fprintf (stderr, \"test2: unexpected return value %d\\n\", i);\n-      data.failed = 1;\n-    }\n-\n-  check (\"test2\", 0, all, f3line, \"f13\", &data.failed);\n-  check (\"test2\", 1, all, f2line, \"f12\", &data.failed);\n-  check (\"test2\", 2, all, f1line, \"test2\", &data.failed);\n-\n-  printf (\"%s: backtrace_full inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n-\n-  if (data.failed)\n-    ++failures;\n-\n-  return failures;\n-}\n-\n-/* Test the backtrace_simple function with non-inlined functions.  */\n-\n-static int test3 (void) __attribute__ ((noinline, unused));\n-static int f22 (int) __attribute__ ((noinline));\n-static int f23 (int, int) __attribute__ ((noinline));\n-\n-static int\n-test3 (void)\n-{\n-  return f22 (__LINE__) + 1;\n-}\n-\n-static int\n-f22 (int f1line)\n-{\n-  return f23 (f1line, __LINE__) + 2;\n-}\n-\n-static int\n-f23 (int f1line, int f2line)\n-{\n-  uintptr_t addrs[20];\n-  struct sdata data;\n-  int f3line;\n-  int i;\n-\n-  data.addrs = &addrs[0];\n-  data.index = 0;\n-  data.max = 20;\n-  data.failed = 0;\n-\n-  f3line = __LINE__ + 1;\n-  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n-\n-  if (i != 0)\n-    {\n-      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n-      data.failed = 1;\n-    }\n-\n-  if (!data.failed)\n-    {\n-      struct info all[20];\n-      struct bdata bdata;\n-      int j;\n-\n-      bdata.all = &all[0];\n-      bdata.index = 0;\n-      bdata.max = 20;\n-      bdata.failed = 0;\n-\n-      for (j = 0; j < 3; ++j)\n-\t{\n-\t  i = backtrace_pcinfo (state, addrs[j], callback_one,\n-\t\t\t\terror_callback_one, &bdata);\n-\t  if (i != 0)\n-\t    {\n-\t      fprintf (stderr,\n-\t\t       (\"test3: unexpected return value \"\n-\t\t\t\"from backtrace_pcinfo %d\\n\"),\n-\t\t       i);\n-\t      bdata.failed = 1;\n-\t    }\n-\t  if (!bdata.failed && bdata.index != (size_t) (j + 1))\n-\t    {\n-\t      fprintf (stderr,\n-\t\t       (\"wrong number of calls from backtrace_pcinfo \"\n-\t\t\t\"got %u expected %d\\n\"),\n-\t\t       (unsigned int) bdata.index, j + 1);\n-\t      bdata.failed = 1;\n-\t    }\n-\t}      \n-\n-      check (\"test3\", 0, all, f3line, \"f23\", &bdata.failed);\n-      check (\"test3\", 1, all, f2line, \"f22\", &bdata.failed);\n-      check (\"test3\", 2, all, f1line, \"test3\", &bdata.failed);\n-\n-      if (bdata.failed)\n-\tdata.failed = 1;\n-\n-      for (j = 0; j < 3; ++j)\n-\t{\n-\t  struct symdata symdata;\n-\n-\t  symdata.name = NULL;\n-\t  symdata.val = 0;\n-\t  symdata.size = 0;\n-\t  symdata.failed = 0;\n-\n-\t  i = backtrace_syminfo (state, addrs[j], callback_three,\n-\t\t\t\t error_callback_three, &symdata);\n-\t  if (i == 0)\n-\t    {\n-\t      fprintf (stderr,\n-\t\t       (\"test3: [%d]: unexpected return value \"\n-\t\t\t\"from backtrace_syminfo %d\\n\"),\n-\t\t       j, i);\n-\t      symdata.failed = 1;\n-\t    }\n-\n-\t  if (!symdata.failed)\n-\t    {\n-\t      const char *expected;\n-\n-\t      switch (j)\n-\t\t{\n-\t\tcase 0:\n-\t\t  expected = \"f23\";\n-\t\t  break;\n-\t\tcase 1:\n-\t\t  expected = \"f22\";\n-\t\t  break;\n-\t\tcase 2:\n-\t\t  expected = \"test3\";\n-\t\t  break;\n-\t\tdefault:\n-\t\t  assert (0);\n-\t\t}\n-\n-\t      if (symdata.name == NULL)\n-\t\t{\n-\t\t  fprintf (stderr, \"test3: [%d]: NULL syminfo name\\n\", j);\n-\t\t  symdata.failed = 1;\n-\t\t}\n-\t      /* Use strncmp, not strcmp, because GCC might create a\n-\t\t clone.  */\n-\t      else if (strncmp (symdata.name, expected, strlen (expected))\n-\t\t       != 0)\n-\t\t{\n-\t\t  fprintf (stderr,\n-\t\t\t   (\"test3: [%d]: unexpected syminfo name \"\n-\t\t\t    \"got %s expected %s\\n\"),\n-\t\t\t   j, symdata.name, expected);\n-\t\t  symdata.failed = 1;\n-\t\t}\n-\t    }\n-\n-\t  if (symdata.failed)\n-\t    data.failed = 1;\n-\t}\n-    }\n-\n-  printf (\"%s: backtrace_simple noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n-\n-  if (data.failed)\n-    ++failures;\n-\n-  return failures;\n-}\n-\n-/* Test the backtrace_simple function with inlined functions.  */\n-\n-static inline int test4 (void) __attribute__ ((always_inline, unused));\n-static inline int f32 (int) __attribute__ ((always_inline));\n-static inline int f33 (int, int) __attribute__ ((always_inline));\n-\n-static inline int\n-test4 (void)\n-{\n-  return f32 (__LINE__) + 1;\n-}\n-\n-static inline int\n-f32 (int f1line)\n-{\n-  return f33 (f1line, __LINE__) + 2;\n-}\n-\n-static inline int\n-f33 (int f1line, int f2line)\n-{\n-  uintptr_t addrs[20];\n-  struct sdata data;\n-  int f3line;\n-  int i;\n-\n-  data.addrs = &addrs[0];\n-  data.index = 0;\n-  data.max = 20;\n-  data.failed = 0;\n-\n-  f3line = __LINE__ + 1;\n-  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n-\n-  if (i != 0)\n-    {\n-      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n-      data.failed = 1;\n-    }\n-\n-  if (!data.failed)\n-    {\n-      struct info all[20];\n-      struct bdata bdata;\n-\n-      bdata.all = &all[0];\n-      bdata.index = 0;\n-      bdata.max = 20;\n-      bdata.failed = 0;\n-\n-      i = backtrace_pcinfo (state, addrs[0], callback_one, error_callback_one,\n-\t\t\t    &bdata);\n-      if (i != 0)\n-\t{\n-\t  fprintf (stderr,\n-\t\t   (\"test4: unexpected return value \"\n-\t\t    \"from backtrace_pcinfo %d\\n\"),\n-\t\t   i);\n-\t  bdata.failed = 1;\n-\t}\n-\n-      check (\"test4\", 0, all, f3line, \"f33\", &bdata.failed);\n-      check (\"test4\", 1, all, f2line, \"f32\", &bdata.failed);\n-      check (\"test4\", 2, all, f1line, \"test4\", &bdata.failed);\n-\n-      if (bdata.failed)\n-\tdata.failed = 1;\n-    }\n-\n-  printf (\"%s: backtrace_simple inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n-\n-  if (data.failed)\n-    ++failures;\n-\n-  return failures;\n-}\n-\n-#if BACKTRACE_SUPPORTS_DATA\n-\n-int global = 1;\n-\n-static int\n-test5 (void)\n-{\n-  struct symdata symdata;\n-  int i;\n-  uintptr_t addr = (uintptr_t) &global;\n-\n-  if (sizeof (global) > 1)\n-    addr += 1;\n-\n-  symdata.name = NULL;\n-  symdata.val = 0;\n-  symdata.size = 0;\n-  symdata.failed = 0;\n-\n-  i = backtrace_syminfo (state, addr, callback_three,\n-\t\t\t error_callback_three, &symdata);\n-  if (i == 0)\n-    {\n-      fprintf (stderr,\n-\t       \"test5: unexpected return value from backtrace_syminfo %d\\n\",\n-\t       i);\n-      symdata.failed = 1;\n-    }\n-\n-  if (!symdata.failed)\n-    {\n-      if (symdata.name == NULL)\n-\t{\n-\t  fprintf (stderr, \"test5: NULL syminfo name\\n\");\n-\t  symdata.failed = 1;\n-\t}\n-      else if (strcmp (symdata.name, \"global\") != 0)\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \"test5: unexpected syminfo name got %s expected %s\\n\",\n-\t\t   symdata.name, \"global\");\n-\t  symdata.failed = 1;\n-\t}\n-      else if (symdata.val != (uintptr_t) &global)\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \"test5: unexpected syminfo value got %lx expected %lx\\n\",\n-\t\t   (unsigned long) symdata.val,\n-\t\t   (unsigned long) (uintptr_t) &global);\n-\t  symdata.failed = 1;\n-\t}\n-      else if (symdata.size != sizeof (global))\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \"test5: unexpected syminfo size got %lx expected %lx\\n\",\n-\t\t   (unsigned long) symdata.size,\n-\t\t   (unsigned long) sizeof (global));\n-\t  symdata.failed = 1;\n-\t}\n-    }\n-\n-  printf (\"%s: backtrace_syminfo variable\\n\",\n-\t  symdata.failed ? \"FAIL\" : \"PASS\");\n-\n-  if (symdata.failed)\n-    ++failures;\n-\n-  return failures;\n-}\n-\n-#endif /* BACKTRACE_SUPPORTS_DATA  */\n-\n-static void\n-error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n-\t\t       int errnum)\n-{\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  exit (EXIT_FAILURE);\n-}\n-\n-/* Run all the tests.  */\n-\n-int\n-main (int argc ATTRIBUTE_UNUSED, char **argv)\n-{\n-  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n-\t\t\t\t  error_callback_create, NULL);\n-\n-#if BACKTRACE_SUPPORTED\n-  test1 ();\n-  test2 ();\n-  test3 ();\n-  test4 ();\n-#if BACKTRACE_SUPPORTS_DATA\n-  test5 ();\n-#endif\n-#endif\n-\n-  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n-}"}, {"sha": "87cb805984d4f06782ed96a509fe18a290377f33", "filename": "src/libbacktrace/config.h.in", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.h.in?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,134 +0,0 @@\n-/* config.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* ELF size: 32 or 64 */\n-#undef BACKTRACE_ELF_SIZE\n-\n-/* Define to 1 if you have the __atomic functions */\n-#undef HAVE_ATOMIC_FUNCTIONS\n-\n-/* Define to 1 if you have the declaration of `strnlen', and to 0 if you\n-   don't. */\n-#undef HAVE_DECL_STRNLEN\n-\n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-#undef HAVE_DLFCN_H\n-\n-/* Define if dl_iterate_phdr is available. */\n-#undef HAVE_DL_ITERATE_PHDR\n-\n-/* Define to 1 if you have the fcntl function */\n-#undef HAVE_FCNTL\n-\n-/* Define if getexecname is available. */\n-#undef HAVE_GETEXECNAME\n-\n-/* Define if _Unwind_GetIPInfo is available. */\n-#undef HAVE_GETIPINFO\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#undef HAVE_INTTYPES_H\n-\n-/* Define to 1 if you have the <link.h> header file. */\n-#undef HAVE_LINK_H\n-\n-/* Define to 1 if you have the <memory.h> header file. */\n-#undef HAVE_MEMORY_H\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#undef HAVE_STDINT_H\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#undef HAVE_STDLIB_H\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#undef HAVE_STRINGS_H\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#undef HAVE_STRING_H\n-\n-/* Define to 1 if you have the __sync functions */\n-#undef HAVE_SYNC_FUNCTIONS\n-\n-/* Define to 1 if you have the <sys/mman.h> header file. */\n-#undef HAVE_SYS_MMAN_H\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#undef HAVE_SYS_STAT_H\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#undef HAVE_SYS_TYPES_H\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#undef HAVE_UNISTD_H\n-\n-/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   */\n-#undef LT_OBJDIR\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#undef PACKAGE_BUGREPORT\n-\n-/* Define to the full name of this package. */\n-#undef PACKAGE_NAME\n-\n-/* Define to the full name and version of this package. */\n-#undef PACKAGE_STRING\n-\n-/* Define to the one symbol short name of this package. */\n-#undef PACKAGE_TARNAME\n-\n-/* Define to the home page for this package. */\n-#undef PACKAGE_URL\n-\n-/* Define to the version of this package. */\n-#undef PACKAGE_VERSION\n-\n-/* The size of `char', as computed by sizeof. */\n-#undef SIZEOF_CHAR\n-\n-/* The size of `int', as computed by sizeof. */\n-#undef SIZEOF_INT\n-\n-/* The size of `long', as computed by sizeof. */\n-#undef SIZEOF_LONG\n-\n-/* The size of `short', as computed by sizeof. */\n-#undef SIZEOF_SHORT\n-\n-/* The size of `void *', as computed by sizeof. */\n-#undef SIZEOF_VOID_P\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#undef STDC_HEADERS\n-\n-/* Enable extensions on AIX 3, Interix.  */\n-#ifndef _ALL_SOURCE\n-# undef _ALL_SOURCE\n-#endif\n-/* Enable GNU extensions on systems that have them.  */\n-#ifndef _GNU_SOURCE\n-# undef _GNU_SOURCE\n-#endif\n-/* Enable threading extensions on Solaris.  */\n-#ifndef _POSIX_PTHREAD_SEMANTICS\n-# undef _POSIX_PTHREAD_SEMANTICS\n-#endif\n-/* Enable extensions on HP NonStop.  */\n-#ifndef _TANDEM_SOURCE\n-# undef _TANDEM_SOURCE\n-#endif\n-/* Enable general extensions on Solaris.  */\n-#ifndef __EXTENSIONS__\n-# undef __EXTENSIONS__\n-#endif\n-\n-\n-/* Define to 1 if on MINIX. */\n-#undef _MINIX\n-\n-/* Define to 2 if the system does not provide POSIX.1 features except with\n-   this defined. */\n-#undef _POSIX_1_SOURCE\n-\n-/* Define to 1 if you need to in order for `stat' and other things to work. */\n-#undef _POSIX_SOURCE"}, {"sha": "40ea5dfe1152f0fc5160879bb71bfe1fae2595f6", "filename": "src/libbacktrace/config.sub", "status": "removed", "additions": 0, "deletions": 1836, "changes": 1836, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.sub?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,1836 +0,0 @@\n-#! /bin/sh\n-# Configuration validation subroutine script.\n-#   Copyright 1992-2017 Free Software Foundation, Inc.\n-\n-timestamp='2017-04-02'\n-\n-# This file is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful, but\n-# WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-# General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, see <http://www.gnu.org/licenses/>.\n-#\n-# As a special exception to the GNU General Public License, if you\n-# distribute this file as part of a program that contains a\n-# configuration script generated by Autoconf, you may include it under\n-# the same distribution terms that you use for the rest of that\n-# program.  This Exception is an additional permission under section 7\n-# of the GNU General Public License, version 3 (\"GPLv3\").\n-\n-\n-# Please send patches to <config-patches@gnu.org>.\n-#\n-# Configuration subroutine to validate and canonicalize a configuration type.\n-# Supply the specified configuration type as an argument.\n-# If it is invalid, we print an error message on stderr and exit with code 1.\n-# Otherwise, we print the canonical config type on stdout and succeed.\n-\n-# You can get the latest version of this script from:\n-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub\n-\n-# This file is supposed to be the same for all GNU packages\n-# and recognize all the CPU types, system types and aliases\n-# that are meaningful with *any* GNU software.\n-# Each package is responsible for reporting which valid configurations\n-# it does not support.  The user should be able to distinguish\n-# a failure to support a valid configuration from a meaningless\n-# configuration.\n-\n-# The goal of this file is to map all the various variations of a given\n-# machine specification into a single specification in the form:\n-#\tCPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n-# or in some cases, the newer four-part form:\n-#\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n-# It is wrong to echo any other type of specification.\n-\n-me=`echo \"$0\" | sed -e 's,.*/,,'`\n-\n-usage=\"\\\n-Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS\n-\n-Canonicalize a configuration name.\n-\n-Operation modes:\n-  -h, --help         print this help, then exit\n-  -t, --time-stamp   print date of last modification, then exit\n-  -v, --version      print version number, then exit\n-\n-Report bugs and patches to <config-patches@gnu.org>.\"\n-\n-version=\"\\\n-GNU config.sub ($timestamp)\n-\n-Copyright 1992-2017 Free Software Foundation, Inc.\n-\n-This is free software; see the source for copying conditions.  There is NO\n-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n-\n-help=\"\n-Try \\`$me --help' for more information.\"\n-\n-# Parse command line\n-while test $# -gt 0 ; do\n-  case $1 in\n-    --time-stamp | --time* | -t )\n-       echo \"$timestamp\" ; exit ;;\n-    --version | -v )\n-       echo \"$version\" ; exit ;;\n-    --help | --h* | -h )\n-       echo \"$usage\"; exit ;;\n-    -- )     # Stop option processing\n-       shift; break ;;\n-    - )\t# Use stdin as input.\n-       break ;;\n-    -* )\n-       echo \"$me: invalid option $1$help\"\n-       exit 1 ;;\n-\n-    *local*)\n-       # First pass through any local machine types.\n-       echo $1\n-       exit ;;\n-\n-    * )\n-       break ;;\n-  esac\n-done\n-\n-case $# in\n- 0) echo \"$me: missing argument$help\" >&2\n-    exit 1;;\n- 1) ;;\n- *) echo \"$me: too many arguments$help\" >&2\n-    exit 1;;\n-esac\n-\n-# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).\n-# Here we must recognize all the valid KERNEL-OS combinations.\n-maybe_os=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\2/'`\n-case $maybe_os in\n-  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \\\n-  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \\\n-  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \\\n-  kopensolaris*-gnu* | cloudabi*-eabi* | \\\n-  storm-chaos* | os2-emx* | rtmk-nova*)\n-    os=-$maybe_os\n-    basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`\n-    ;;\n-  android-linux)\n-    os=-linux-android\n-    basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`-unknown\n-    ;;\n-  *)\n-    basic_machine=`echo $1 | sed 's/-[^-]*$//'`\n-    if [ $basic_machine != $1 ]\n-    then os=`echo $1 | sed 's/.*-/-/'`\n-    else os=; fi\n-    ;;\n-esac\n-\n-### Let's recognize common machines as not being operating systems so\n-### that things like config.sub decstation-3100 work.  We also\n-### recognize some manufacturers as not being operating systems, so we\n-### can provide default operating systems below.\n-case $os in\n-\t-sun*os*)\n-\t\t# Prevent following clause from handling this invalid input.\n-\t\t;;\n-\t-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \\\n-\t-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \\\n-\t-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \\\n-\t-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\\\n-\t-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \\\n-\t-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \\\n-\t-apple | -axis | -knuth | -cray | -microblaze*)\n-\t\tos=\n-\t\tbasic_machine=$1\n-\t\t;;\n-\t-bluegene*)\n-\t\tos=-cnk\n-\t\t;;\n-\t-sim | -cisco | -oki | -wec | -winbond)\n-\t\tos=\n-\t\tbasic_machine=$1\n-\t\t;;\n-\t-scout)\n-\t\t;;\n-\t-wrs)\n-\t\tos=-vxworks\n-\t\tbasic_machine=$1\n-\t\t;;\n-\t-chorusos*)\n-\t\tos=-chorusos\n-\t\tbasic_machine=$1\n-\t\t;;\n-\t-chorusrdb)\n-\t\tos=-chorusrdb\n-\t\tbasic_machine=$1\n-\t\t;;\n-\t-hiux*)\n-\t\tos=-hiuxwe2\n-\t\t;;\n-\t-sco6)\n-\t\tos=-sco5v6\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-sco5)\n-\t\tos=-sco3.2v5\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-sco4)\n-\t\tos=-sco3.2v4\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-sco3.2.[4-9]*)\n-\t\tos=`echo $os | sed -e 's/sco3.2./sco3.2v/'`\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-sco3.2v[4-9]*)\n-\t\t# Don't forget version if it is 3.2v4 or newer.\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-sco5v6*)\n-\t\t# Don't forget version if it is 3.2v4 or newer.\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-sco*)\n-\t\tos=-sco3.2v2\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-udk*)\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-isc)\n-\t\tos=-isc2.2\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-clix*)\n-\t\tbasic_machine=clipper-intergraph\n-\t\t;;\n-\t-isc*)\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n-\t\t;;\n-\t-lynx*178)\n-\t\tos=-lynxos178\n-\t\t;;\n-\t-lynx*5)\n-\t\tos=-lynxos5\n-\t\t;;\n-\t-lynx*)\n-\t\tos=-lynxos\n-\t\t;;\n-\t-ptx*)\n-\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`\n-\t\t;;\n-\t-windowsnt*)\n-\t\tos=`echo $os | sed -e 's/windowsnt/winnt/'`\n-\t\t;;\n-\t-psos*)\n-\t\tos=-psos\n-\t\t;;\n-\t-mint | -mint[0-9]*)\n-\t\tbasic_machine=m68k-atari\n-\t\tos=-mint\n-\t\t;;\n-esac\n-\n-# Decode aliases for certain CPU-COMPANY combinations.\n-case $basic_machine in\n-\t# Recognize the basic CPU types without company name.\n-\t# Some are omitted here because they have special meanings below.\n-\t1750a | 580 \\\n-\t| a29k \\\n-\t| aarch64 | aarch64_be \\\n-\t| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \\\n-\t| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \\\n-\t| am33_2.0 \\\n-\t| arc | arceb \\\n-\t| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \\\n-\t| avr | avr32 \\\n-\t| ba \\\n-\t| be32 | be64 \\\n-\t| bfin \\\n-\t| c4x | c8051 | clipper \\\n-\t| d10v | d30v | dlx | dsp16xx \\\n-\t| e2k | epiphany \\\n-\t| fido | fr30 | frv | ft32 \\\n-\t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n-\t| hexagon \\\n-\t| i370 | i860 | i960 | ia16 | ia64 \\\n-\t| ip2k | iq2000 \\\n-\t| k1om \\\n-\t| le32 | le64 \\\n-\t| lm32 \\\n-\t| m32c | m32r | m32rle | m68000 | m68k | m88k \\\n-\t| maxq | mb | microblaze | microblazeel | mcore | mep | metag \\\n-\t| mips | mipsbe | mipseb | mipsel | mipsle \\\n-\t| mips16 \\\n-\t| mips64 | mips64el \\\n-\t| mips64octeon | mips64octeonel \\\n-\t| mips64orion | mips64orionel \\\n-\t| mips64r5900 | mips64r5900el \\\n-\t| mips64vr | mips64vrel \\\n-\t| mips64vr4100 | mips64vr4100el \\\n-\t| mips64vr4300 | mips64vr4300el \\\n-\t| mips64vr5000 | mips64vr5000el \\\n-\t| mips64vr5900 | mips64vr5900el \\\n-\t| mipsisa32 | mipsisa32el \\\n-\t| mipsisa32r2 | mipsisa32r2el \\\n-\t| mipsisa32r6 | mipsisa32r6el \\\n-\t| mipsisa64 | mipsisa64el \\\n-\t| mipsisa64r2 | mipsisa64r2el \\\n-\t| mipsisa64r6 | mipsisa64r6el \\\n-\t| mipsisa64sb1 | mipsisa64sb1el \\\n-\t| mipsisa64sr71k | mipsisa64sr71kel \\\n-\t| mipsr5900 | mipsr5900el \\\n-\t| mipstx39 | mipstx39el \\\n-\t| mn10200 | mn10300 \\\n-\t| moxie \\\n-\t| mt \\\n-\t| msp430 \\\n-\t| nds32 | nds32le | nds32be \\\n-\t| nios | nios2 | nios2eb | nios2el \\\n-\t| ns16k | ns32k \\\n-\t| open8 | or1k | or1knd | or32 \\\n-\t| pdp10 | pdp11 | pj | pjl \\\n-\t| powerpc | powerpc64 | powerpc64le | powerpcle \\\n-\t| pru \\\n-\t| pyramid \\\n-\t| riscv32 | riscv64 \\\n-\t| rl78 | rx \\\n-\t| score \\\n-\t| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[234]eb | sheb | shbe | shle | sh[1234]le | sh3ele \\\n-\t| sh64 | sh64le \\\n-\t| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \\\n-\t| sparcv8 | sparcv9 | sparcv9b | sparcv9v \\\n-\t| spu \\\n-\t| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \\\n-\t| ubicom32 \\\n-\t| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \\\n-\t| visium \\\n-\t| wasm32 \\\n-\t| we32k \\\n-\t| x86 | xc16x | xstormy16 | xtensa \\\n-\t| z8k | z80)\n-\t\tbasic_machine=$basic_machine-unknown\n-\t\t;;\n-\tc54x)\n-\t\tbasic_machine=tic54x-unknown\n-\t\t;;\n-\tc55x)\n-\t\tbasic_machine=tic55x-unknown\n-\t\t;;\n-\tc6x)\n-\t\tbasic_machine=tic6x-unknown\n-\t\t;;\n-\tleon|leon[3-9])\n-\t\tbasic_machine=sparc-$basic_machine\n-\t\t;;\n-\tm6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)\n-\t\tbasic_machine=$basic_machine-unknown\n-\t\tos=-none\n-\t\t;;\n-\tm88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)\n-\t\t;;\n-\tms1)\n-\t\tbasic_machine=mt-unknown\n-\t\t;;\n-\n-\tstrongarm | thumb | xscale)\n-\t\tbasic_machine=arm-unknown\n-\t\t;;\n-\txgate)\n-\t\tbasic_machine=$basic_machine-unknown\n-\t\tos=-none\n-\t\t;;\n-\txscaleeb)\n-\t\tbasic_machine=armeb-unknown\n-\t\t;;\n-\n-\txscaleel)\n-\t\tbasic_machine=armel-unknown\n-\t\t;;\n-\n-\t# We use `pc' rather than `unknown'\n-\t# because (1) that's what they normally are, and\n-\t# (2) the word \"unknown\" tends to confuse beginning users.\n-\ti*86 | x86_64)\n-\t  basic_machine=$basic_machine-pc\n-\t  ;;\n-\t# Object if more than one company name word.\n-\t*-*-*)\n-\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n-\t\texit 1\n-\t\t;;\n-\t# Recognize the basic CPU types with company name.\n-\t580-* \\\n-\t| a29k-* \\\n-\t| aarch64-* | aarch64_be-* \\\n-\t| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \\\n-\t| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \\\n-\t| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \\\n-\t| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \\\n-\t| avr-* | avr32-* \\\n-\t| ba-* \\\n-\t| be32-* | be64-* \\\n-\t| bfin-* | bs2000-* \\\n-\t| c[123]* | c30-* | [cjt]90-* | c4x-* \\\n-\t| c8051-* | clipper-* | craynv-* | cydra-* \\\n-\t| d10v-* | d30v-* | dlx-* \\\n-\t| e2k-* | elxsi-* \\\n-\t| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \\\n-\t| h8300-* | h8500-* \\\n-\t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n-\t| hexagon-* \\\n-\t| i*86-* | i860-* | i960-* | ia16-* | ia64-* \\\n-\t| ip2k-* | iq2000-* \\\n-\t| k1om-* \\\n-\t| le32-* | le64-* \\\n-\t| lm32-* \\\n-\t| m32c-* | m32r-* | m32rle-* \\\n-\t| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \\\n-\t| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \\\n-\t| microblaze-* | microblazeel-* \\\n-\t| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \\\n-\t| mips16-* \\\n-\t| mips64-* | mips64el-* \\\n-\t| mips64octeon-* | mips64octeonel-* \\\n-\t| mips64orion-* | mips64orionel-* \\\n-\t| mips64r5900-* | mips64r5900el-* \\\n-\t| mips64vr-* | mips64vrel-* \\\n-\t| mips64vr4100-* | mips64vr4100el-* \\\n-\t| mips64vr4300-* | mips64vr4300el-* \\\n-\t| mips64vr5000-* | mips64vr5000el-* \\\n-\t| mips64vr5900-* | mips64vr5900el-* \\\n-\t| mipsisa32-* | mipsisa32el-* \\\n-\t| mipsisa32r2-* | mipsisa32r2el-* \\\n-\t| mipsisa32r6-* | mipsisa32r6el-* \\\n-\t| mipsisa64-* | mipsisa64el-* \\\n-\t| mipsisa64r2-* | mipsisa64r2el-* \\\n-\t| mipsisa64r6-* | mipsisa64r6el-* \\\n-\t| mipsisa64sb1-* | mipsisa64sb1el-* \\\n-\t| mipsisa64sr71k-* | mipsisa64sr71kel-* \\\n-\t| mipsr5900-* | mipsr5900el-* \\\n-\t| mipstx39-* | mipstx39el-* \\\n-\t| mmix-* \\\n-\t| mt-* \\\n-\t| msp430-* \\\n-\t| nds32-* | nds32le-* | nds32be-* \\\n-\t| nios-* | nios2-* | nios2eb-* | nios2el-* \\\n-\t| none-* | np1-* | ns16k-* | ns32k-* \\\n-\t| open8-* \\\n-\t| or1k*-* \\\n-\t| orion-* \\\n-\t| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \\\n-\t| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \\\n-\t| pru-* \\\n-\t| pyramid-* \\\n-\t| riscv32-* | riscv64-* \\\n-\t| rl78-* | romp-* | rs6000-* | rx-* \\\n-\t| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \\\n-\t| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \\\n-\t| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \\\n-\t| sparclite-* \\\n-\t| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \\\n-\t| tahoe-* \\\n-\t| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \\\n-\t| tile*-* \\\n-\t| tron-* \\\n-\t| ubicom32-* \\\n-\t| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \\\n-\t| vax-* \\\n-\t| visium-* \\\n-\t| wasm32-* \\\n-\t| we32k-* \\\n-\t| x86-* | x86_64-* | xc16x-* | xps100-* \\\n-\t| xstormy16-* | xtensa*-* \\\n-\t| ymp-* \\\n-\t| z8k-* | z80-*)\n-\t\t;;\n-\t# Recognize the basic CPU types without company name, with glob match.\n-\txtensa*)\n-\t\tbasic_machine=$basic_machine-unknown\n-\t\t;;\n-\t# Recognize the various machine names and aliases which stand\n-\t# for a CPU type and a company and sometimes even an OS.\n-\t386bsd)\n-\t\tbasic_machine=i386-unknown\n-\t\tos=-bsd\n-\t\t;;\n-\t3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)\n-\t\tbasic_machine=m68000-att\n-\t\t;;\n-\t3b*)\n-\t\tbasic_machine=we32k-att\n-\t\t;;\n-\ta29khif)\n-\t\tbasic_machine=a29k-amd\n-\t\tos=-udi\n-\t\t;;\n-\tabacus)\n-\t\tbasic_machine=abacus-unknown\n-\t\t;;\n-\tadobe68k)\n-\t\tbasic_machine=m68010-adobe\n-\t\tos=-scout\n-\t\t;;\n-\talliant | fx80)\n-\t\tbasic_machine=fx80-alliant\n-\t\t;;\n-\taltos | altos3068)\n-\t\tbasic_machine=m68k-altos\n-\t\t;;\n-\tam29k)\n-\t\tbasic_machine=a29k-none\n-\t\tos=-bsd\n-\t\t;;\n-\tamd64)\n-\t\tbasic_machine=x86_64-pc\n-\t\t;;\n-\tamd64-*)\n-\t\tbasic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tamdahl)\n-\t\tbasic_machine=580-amdahl\n-\t\tos=-sysv\n-\t\t;;\n-\tamiga | amiga-*)\n-\t\tbasic_machine=m68k-unknown\n-\t\t;;\n-\tamigaos | amigados)\n-\t\tbasic_machine=m68k-unknown\n-\t\tos=-amigaos\n-\t\t;;\n-\tamigaunix | amix)\n-\t\tbasic_machine=m68k-unknown\n-\t\tos=-sysv4\n-\t\t;;\n-\tapollo68)\n-\t\tbasic_machine=m68k-apollo\n-\t\tos=-sysv\n-\t\t;;\n-\tapollo68bsd)\n-\t\tbasic_machine=m68k-apollo\n-\t\tos=-bsd\n-\t\t;;\n-\taros)\n-\t\tbasic_machine=i386-pc\n-\t\tos=-aros\n-\t\t;;\n-\tasmjs)\n-\t\tbasic_machine=asmjs-unknown\n-\t\t;;\n-\taux)\n-\t\tbasic_machine=m68k-apple\n-\t\tos=-aux\n-\t\t;;\n-\tbalance)\n-\t\tbasic_machine=ns32k-sequent\n-\t\tos=-dynix\n-\t\t;;\n-\tblackfin)\n-\t\tbasic_machine=bfin-unknown\n-\t\tos=-linux\n-\t\t;;\n-\tblackfin-*)\n-\t\tbasic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\tos=-linux\n-\t\t;;\n-\tbluegene*)\n-\t\tbasic_machine=powerpc-ibm\n-\t\tos=-cnk\n-\t\t;;\n-\tc54x-*)\n-\t\tbasic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tc55x-*)\n-\t\tbasic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tc6x-*)\n-\t\tbasic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tc90)\n-\t\tbasic_machine=c90-cray\n-\t\tos=-unicos\n-\t\t;;\n-\tcegcc)\n-\t\tbasic_machine=arm-unknown\n-\t\tos=-cegcc\n-\t\t;;\n-\tconvex-c1)\n-\t\tbasic_machine=c1-convex\n-\t\tos=-bsd\n-\t\t;;\n-\tconvex-c2)\n-\t\tbasic_machine=c2-convex\n-\t\tos=-bsd\n-\t\t;;\n-\tconvex-c32)\n-\t\tbasic_machine=c32-convex\n-\t\tos=-bsd\n-\t\t;;\n-\tconvex-c34)\n-\t\tbasic_machine=c34-convex\n-\t\tos=-bsd\n-\t\t;;\n-\tconvex-c38)\n-\t\tbasic_machine=c38-convex\n-\t\tos=-bsd\n-\t\t;;\n-\tcray | j90)\n-\t\tbasic_machine=j90-cray\n-\t\tos=-unicos\n-\t\t;;\n-\tcraynv)\n-\t\tbasic_machine=craynv-cray\n-\t\tos=-unicosmp\n-\t\t;;\n-\tcr16 | cr16-*)\n-\t\tbasic_machine=cr16-unknown\n-\t\tos=-elf\n-\t\t;;\n-\tcrds | unos)\n-\t\tbasic_machine=m68k-crds\n-\t\t;;\n-\tcrisv32 | crisv32-* | etraxfs*)\n-\t\tbasic_machine=crisv32-axis\n-\t\t;;\n-\tcris | cris-* | etrax*)\n-\t\tbasic_machine=cris-axis\n-\t\t;;\n-\tcrx)\n-\t\tbasic_machine=crx-unknown\n-\t\tos=-elf\n-\t\t;;\n-\tda30 | da30-*)\n-\t\tbasic_machine=m68k-da30\n-\t\t;;\n-\tdecstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)\n-\t\tbasic_machine=mips-dec\n-\t\t;;\n-\tdecsystem10* | dec10*)\n-\t\tbasic_machine=pdp10-dec\n-\t\tos=-tops10\n-\t\t;;\n-\tdecsystem20* | dec20*)\n-\t\tbasic_machine=pdp10-dec\n-\t\tos=-tops20\n-\t\t;;\n-\tdelta | 3300 | motorola-3300 | motorola-delta \\\n-\t      | 3300-motorola | delta-motorola)\n-\t\tbasic_machine=m68k-motorola\n-\t\t;;\n-\tdelta88)\n-\t\tbasic_machine=m88k-motorola\n-\t\tos=-sysv3\n-\t\t;;\n-\tdicos)\n-\t\tbasic_machine=i686-pc\n-\t\tos=-dicos\n-\t\t;;\n-\tdjgpp)\n-\t\tbasic_machine=i586-pc\n-\t\tos=-msdosdjgpp\n-\t\t;;\n-\tdpx20 | dpx20-*)\n-\t\tbasic_machine=rs6000-bull\n-\t\tos=-bosx\n-\t\t;;\n-\tdpx2* | dpx2*-bull)\n-\t\tbasic_machine=m68k-bull\n-\t\tos=-sysv3\n-\t\t;;\n-\te500v[12])\n-\t\tbasic_machine=powerpc-unknown\n-\t\tos=$os\"spe\"\n-\t\t;;\n-\te500v[12]-*)\n-\t\tbasic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\tos=$os\"spe\"\n-\t\t;;\n-\tebmon29k)\n-\t\tbasic_machine=a29k-amd\n-\t\tos=-ebmon\n-\t\t;;\n-\telxsi)\n-\t\tbasic_machine=elxsi-elxsi\n-\t\tos=-bsd\n-\t\t;;\n-\tencore | umax | mmax)\n-\t\tbasic_machine=ns32k-encore\n-\t\t;;\n-\tes1800 | OSE68k | ose68k | ose | OSE)\n-\t\tbasic_machine=m68k-ericsson\n-\t\tos=-ose\n-\t\t;;\n-\tfx2800)\n-\t\tbasic_machine=i860-alliant\n-\t\t;;\n-\tgenix)\n-\t\tbasic_machine=ns32k-ns\n-\t\t;;\n-\tgmicro)\n-\t\tbasic_machine=tron-gmicro\n-\t\tos=-sysv\n-\t\t;;\n-\tgo32)\n-\t\tbasic_machine=i386-pc\n-\t\tos=-go32\n-\t\t;;\n-\th3050r* | hiux*)\n-\t\tbasic_machine=hppa1.1-hitachi\n-\t\tos=-hiuxwe2\n-\t\t;;\n-\th8300hms)\n-\t\tbasic_machine=h8300-hitachi\n-\t\tos=-hms\n-\t\t;;\n-\th8300xray)\n-\t\tbasic_machine=h8300-hitachi\n-\t\tos=-xray\n-\t\t;;\n-\th8500hms)\n-\t\tbasic_machine=h8500-hitachi\n-\t\tos=-hms\n-\t\t;;\n-\tharris)\n-\t\tbasic_machine=m88k-harris\n-\t\tos=-sysv3\n-\t\t;;\n-\thp300-*)\n-\t\tbasic_machine=m68k-hp\n-\t\t;;\n-\thp300bsd)\n-\t\tbasic_machine=m68k-hp\n-\t\tos=-bsd\n-\t\t;;\n-\thp300hpux)\n-\t\tbasic_machine=m68k-hp\n-\t\tos=-hpux\n-\t\t;;\n-\thp3k9[0-9][0-9] | hp9[0-9][0-9])\n-\t\tbasic_machine=hppa1.0-hp\n-\t\t;;\n-\thp9k2[0-9][0-9] | hp9k31[0-9])\n-\t\tbasic_machine=m68000-hp\n-\t\t;;\n-\thp9k3[2-9][0-9])\n-\t\tbasic_machine=m68k-hp\n-\t\t;;\n-\thp9k6[0-9][0-9] | hp6[0-9][0-9])\n-\t\tbasic_machine=hppa1.0-hp\n-\t\t;;\n-\thp9k7[0-79][0-9] | hp7[0-79][0-9])\n-\t\tbasic_machine=hppa1.1-hp\n-\t\t;;\n-\thp9k78[0-9] | hp78[0-9])\n-\t\t# FIXME: really hppa2.0-hp\n-\t\tbasic_machine=hppa1.1-hp\n-\t\t;;\n-\thp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)\n-\t\t# FIXME: really hppa2.0-hp\n-\t\tbasic_machine=hppa1.1-hp\n-\t\t;;\n-\thp9k8[0-9][13679] | hp8[0-9][13679])\n-\t\tbasic_machine=hppa1.1-hp\n-\t\t;;\n-\thp9k8[0-9][0-9] | hp8[0-9][0-9])\n-\t\tbasic_machine=hppa1.0-hp\n-\t\t;;\n-\thppa-next)\n-\t\tos=-nextstep3\n-\t\t;;\n-\thppaosf)\n-\t\tbasic_machine=hppa1.1-hp\n-\t\tos=-osf\n-\t\t;;\n-\thppro)\n-\t\tbasic_machine=hppa1.1-hp\n-\t\tos=-proelf\n-\t\t;;\n-\ti370-ibm* | ibm*)\n-\t\tbasic_machine=i370-ibm\n-\t\t;;\n-\ti*86v32)\n-\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n-\t\tos=-sysv32\n-\t\t;;\n-\ti*86v4*)\n-\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n-\t\tos=-sysv4\n-\t\t;;\n-\ti*86v)\n-\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n-\t\tos=-sysv\n-\t\t;;\n-\ti*86sol2)\n-\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n-\t\tos=-solaris2\n-\t\t;;\n-\ti386mach)\n-\t\tbasic_machine=i386-mach\n-\t\tos=-mach\n-\t\t;;\n-\ti386-vsta | vsta)\n-\t\tbasic_machine=i386-unknown\n-\t\tos=-vsta\n-\t\t;;\n-\tiris | iris4d)\n-\t\tbasic_machine=mips-sgi\n-\t\tcase $os in\n-\t\t    -irix*)\n-\t\t\t;;\n-\t\t    *)\n-\t\t\tos=-irix4\n-\t\t\t;;\n-\t\tesac\n-\t\t;;\n-\tisi68 | isi)\n-\t\tbasic_machine=m68k-isi\n-\t\tos=-sysv\n-\t\t;;\n-\tleon-*|leon[3-9]-*)\n-\t\tbasic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`\n-\t\t;;\n-\tm68knommu)\n-\t\tbasic_machine=m68k-unknown\n-\t\tos=-linux\n-\t\t;;\n-\tm68knommu-*)\n-\t\tbasic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\tos=-linux\n-\t\t;;\n-\tm88k-omron*)\n-\t\tbasic_machine=m88k-omron\n-\t\t;;\n-\tmagnum | m3230)\n-\t\tbasic_machine=mips-mips\n-\t\tos=-sysv\n-\t\t;;\n-\tmerlin)\n-\t\tbasic_machine=ns32k-utek\n-\t\tos=-sysv\n-\t\t;;\n-\tmicroblaze*)\n-\t\tbasic_machine=microblaze-xilinx\n-\t\t;;\n-\tmingw64)\n-\t\tbasic_machine=x86_64-pc\n-\t\tos=-mingw64\n-\t\t;;\n-\tmingw32)\n-\t\tbasic_machine=i686-pc\n-\t\tos=-mingw32\n-\t\t;;\n-\tmingw32ce)\n-\t\tbasic_machine=arm-unknown\n-\t\tos=-mingw32ce\n-\t\t;;\n-\tminiframe)\n-\t\tbasic_machine=m68000-convergent\n-\t\t;;\n-\t*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)\n-\t\tbasic_machine=m68k-atari\n-\t\tos=-mint\n-\t\t;;\n-\tmips3*-*)\n-\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`\n-\t\t;;\n-\tmips3*)\n-\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown\n-\t\t;;\n-\tmonitor)\n-\t\tbasic_machine=m68k-rom68k\n-\t\tos=-coff\n-\t\t;;\n-\tmorphos)\n-\t\tbasic_machine=powerpc-unknown\n-\t\tos=-morphos\n-\t\t;;\n-\tmoxiebox)\n-\t\tbasic_machine=moxie-unknown\n-\t\tos=-moxiebox\n-\t\t;;\n-\tmsdos)\n-\t\tbasic_machine=i386-pc\n-\t\tos=-msdos\n-\t\t;;\n-\tms1-*)\n-\t\tbasic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`\n-\t\t;;\n-\tmsys)\n-\t\tbasic_machine=i686-pc\n-\t\tos=-msys\n-\t\t;;\n-\tmvs)\n-\t\tbasic_machine=i370-ibm\n-\t\tos=-mvs\n-\t\t;;\n-\tnacl)\n-\t\tbasic_machine=le32-unknown\n-\t\tos=-nacl\n-\t\t;;\n-\tncr3000)\n-\t\tbasic_machine=i486-ncr\n-\t\tos=-sysv4\n-\t\t;;\n-\tnetbsd386)\n-\t\tbasic_machine=i386-unknown\n-\t\tos=-netbsd\n-\t\t;;\n-\tnetwinder)\n-\t\tbasic_machine=armv4l-rebel\n-\t\tos=-linux\n-\t\t;;\n-\tnews | news700 | news800 | news900)\n-\t\tbasic_machine=m68k-sony\n-\t\tos=-newsos\n-\t\t;;\n-\tnews1000)\n-\t\tbasic_machine=m68030-sony\n-\t\tos=-newsos\n-\t\t;;\n-\tnews-3600 | risc-news)\n-\t\tbasic_machine=mips-sony\n-\t\tos=-newsos\n-\t\t;;\n-\tnecv70)\n-\t\tbasic_machine=v70-nec\n-\t\tos=-sysv\n-\t\t;;\n-\tnext | m*-next )\n-\t\tbasic_machine=m68k-next\n-\t\tcase $os in\n-\t\t    -nextstep* )\n-\t\t\t;;\n-\t\t    -ns2*)\n-\t\t      os=-nextstep2\n-\t\t\t;;\n-\t\t    *)\n-\t\t      os=-nextstep3\n-\t\t\t;;\n-\t\tesac\n-\t\t;;\n-\tnh3000)\n-\t\tbasic_machine=m68k-harris\n-\t\tos=-cxux\n-\t\t;;\n-\tnh[45]000)\n-\t\tbasic_machine=m88k-harris\n-\t\tos=-cxux\n-\t\t;;\n-\tnindy960)\n-\t\tbasic_machine=i960-intel\n-\t\tos=-nindy\n-\t\t;;\n-\tmon960)\n-\t\tbasic_machine=i960-intel\n-\t\tos=-mon960\n-\t\t;;\n-\tnonstopux)\n-\t\tbasic_machine=mips-compaq\n-\t\tos=-nonstopux\n-\t\t;;\n-\tnp1)\n-\t\tbasic_machine=np1-gould\n-\t\t;;\n-\tneo-tandem)\n-\t\tbasic_machine=neo-tandem\n-\t\t;;\n-\tnse-tandem)\n-\t\tbasic_machine=nse-tandem\n-\t\t;;\n-\tnsr-tandem)\n-\t\tbasic_machine=nsr-tandem\n-\t\t;;\n-\tnsx-tandem)\n-\t\tbasic_machine=nsx-tandem\n-\t\t;;\n-\top50n-* | op60c-*)\n-\t\tbasic_machine=hppa1.1-oki\n-\t\tos=-proelf\n-\t\t;;\n-\topenrisc | openrisc-*)\n-\t\tbasic_machine=or32-unknown\n-\t\t;;\n-\tos400)\n-\t\tbasic_machine=powerpc-ibm\n-\t\tos=-os400\n-\t\t;;\n-\tOSE68000 | ose68000)\n-\t\tbasic_machine=m68000-ericsson\n-\t\tos=-ose\n-\t\t;;\n-\tos68k)\n-\t\tbasic_machine=m68k-none\n-\t\tos=-os68k\n-\t\t;;\n-\tpa-hitachi)\n-\t\tbasic_machine=hppa1.1-hitachi\n-\t\tos=-hiuxwe2\n-\t\t;;\n-\tparagon)\n-\t\tbasic_machine=i860-intel\n-\t\tos=-osf\n-\t\t;;\n-\tparisc)\n-\t\tbasic_machine=hppa-unknown\n-\t\tos=-linux\n-\t\t;;\n-\tparisc-*)\n-\t\tbasic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\tos=-linux\n-\t\t;;\n-\tpbd)\n-\t\tbasic_machine=sparc-tti\n-\t\t;;\n-\tpbb)\n-\t\tbasic_machine=m68k-tti\n-\t\t;;\n-\tpc532 | pc532-*)\n-\t\tbasic_machine=ns32k-pc532\n-\t\t;;\n-\tpc98)\n-\t\tbasic_machine=i386-pc\n-\t\t;;\n-\tpc98-*)\n-\t\tbasic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tpentium | p5 | k5 | k6 | nexgen | viac3)\n-\t\tbasic_machine=i586-pc\n-\t\t;;\n-\tpentiumpro | p6 | 6x86 | athlon | athlon_*)\n-\t\tbasic_machine=i686-pc\n-\t\t;;\n-\tpentiumii | pentium2 | pentiumiii | pentium3)\n-\t\tbasic_machine=i686-pc\n-\t\t;;\n-\tpentium4)\n-\t\tbasic_machine=i786-pc\n-\t\t;;\n-\tpentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)\n-\t\tbasic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tpentiumpro-* | p6-* | 6x86-* | athlon-*)\n-\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tpentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)\n-\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tpentium4-*)\n-\t\tbasic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tpn)\n-\t\tbasic_machine=pn-gould\n-\t\t;;\n-\tpower)\tbasic_machine=power-ibm\n-\t\t;;\n-\tppc | ppcbe)\tbasic_machine=powerpc-unknown\n-\t\t;;\n-\tppc-* | ppcbe-*)\n-\t\tbasic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tppcle | powerpclittle)\n-\t\tbasic_machine=powerpcle-unknown\n-\t\t;;\n-\tppcle-* | powerpclittle-*)\n-\t\tbasic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tppc64)\tbasic_machine=powerpc64-unknown\n-\t\t;;\n-\tppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tppc64le | powerpc64little)\n-\t\tbasic_machine=powerpc64le-unknown\n-\t\t;;\n-\tppc64le-* | powerpc64little-*)\n-\t\tbasic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tps2)\n-\t\tbasic_machine=i386-ibm\n-\t\t;;\n-\tpw32)\n-\t\tbasic_machine=i586-unknown\n-\t\tos=-pw32\n-\t\t;;\n-\trdos | rdos64)\n-\t\tbasic_machine=x86_64-pc\n-\t\tos=-rdos\n-\t\t;;\n-\trdos32)\n-\t\tbasic_machine=i386-pc\n-\t\tos=-rdos\n-\t\t;;\n-\trom68k)\n-\t\tbasic_machine=m68k-rom68k\n-\t\tos=-coff\n-\t\t;;\n-\trm[46]00)\n-\t\tbasic_machine=mips-siemens\n-\t\t;;\n-\trtpc | rtpc-*)\n-\t\tbasic_machine=romp-ibm\n-\t\t;;\n-\ts390 | s390-*)\n-\t\tbasic_machine=s390-ibm\n-\t\t;;\n-\ts390x | s390x-*)\n-\t\tbasic_machine=s390x-ibm\n-\t\t;;\n-\tsa29200)\n-\t\tbasic_machine=a29k-amd\n-\t\tos=-udi\n-\t\t;;\n-\tsb1)\n-\t\tbasic_machine=mipsisa64sb1-unknown\n-\t\t;;\n-\tsb1el)\n-\t\tbasic_machine=mipsisa64sb1el-unknown\n-\t\t;;\n-\tsde)\n-\t\tbasic_machine=mipsisa32-sde\n-\t\tos=-elf\n-\t\t;;\n-\tsei)\n-\t\tbasic_machine=mips-sei\n-\t\tos=-seiux\n-\t\t;;\n-\tsequent)\n-\t\tbasic_machine=i386-sequent\n-\t\t;;\n-\tsh)\n-\t\tbasic_machine=sh-hitachi\n-\t\tos=-hms\n-\t\t;;\n-\tsh5el)\n-\t\tbasic_machine=sh5le-unknown\n-\t\t;;\n-\tsh64)\n-\t\tbasic_machine=sh64-unknown\n-\t\t;;\n-\tsparclite-wrs | simso-wrs)\n-\t\tbasic_machine=sparclite-wrs\n-\t\tos=-vxworks\n-\t\t;;\n-\tsps7)\n-\t\tbasic_machine=m68k-bull\n-\t\tos=-sysv2\n-\t\t;;\n-\tspur)\n-\t\tbasic_machine=spur-unknown\n-\t\t;;\n-\tst2000)\n-\t\tbasic_machine=m68k-tandem\n-\t\t;;\n-\tstratus)\n-\t\tbasic_machine=i860-stratus\n-\t\tos=-sysv4\n-\t\t;;\n-\tstrongarm-* | thumb-*)\n-\t\tbasic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`\n-\t\t;;\n-\tsun2)\n-\t\tbasic_machine=m68000-sun\n-\t\t;;\n-\tsun2os3)\n-\t\tbasic_machine=m68000-sun\n-\t\tos=-sunos3\n-\t\t;;\n-\tsun2os4)\n-\t\tbasic_machine=m68000-sun\n-\t\tos=-sunos4\n-\t\t;;\n-\tsun3os3)\n-\t\tbasic_machine=m68k-sun\n-\t\tos=-sunos3\n-\t\t;;\n-\tsun3os4)\n-\t\tbasic_machine=m68k-sun\n-\t\tos=-sunos4\n-\t\t;;\n-\tsun4os3)\n-\t\tbasic_machine=sparc-sun\n-\t\tos=-sunos3\n-\t\t;;\n-\tsun4os4)\n-\t\tbasic_machine=sparc-sun\n-\t\tos=-sunos4\n-\t\t;;\n-\tsun4sol2)\n-\t\tbasic_machine=sparc-sun\n-\t\tos=-solaris2\n-\t\t;;\n-\tsun3 | sun3-*)\n-\t\tbasic_machine=m68k-sun\n-\t\t;;\n-\tsun4)\n-\t\tbasic_machine=sparc-sun\n-\t\t;;\n-\tsun386 | sun386i | roadrunner)\n-\t\tbasic_machine=i386-sun\n-\t\t;;\n-\tsv1)\n-\t\tbasic_machine=sv1-cray\n-\t\tos=-unicos\n-\t\t;;\n-\tsymmetry)\n-\t\tbasic_machine=i386-sequent\n-\t\tos=-dynix\n-\t\t;;\n-\tt3e)\n-\t\tbasic_machine=alphaev5-cray\n-\t\tos=-unicos\n-\t\t;;\n-\tt90)\n-\t\tbasic_machine=t90-cray\n-\t\tos=-unicos\n-\t\t;;\n-\ttile*)\n-\t\tbasic_machine=$basic_machine-unknown\n-\t\tos=-linux-gnu\n-\t\t;;\n-\ttx39)\n-\t\tbasic_machine=mipstx39-unknown\n-\t\t;;\n-\ttx39el)\n-\t\tbasic_machine=mipstx39el-unknown\n-\t\t;;\n-\ttoad1)\n-\t\tbasic_machine=pdp10-xkl\n-\t\tos=-tops20\n-\t\t;;\n-\ttower | tower-32)\n-\t\tbasic_machine=m68k-ncr\n-\t\t;;\n-\ttpf)\n-\t\tbasic_machine=s390x-ibm\n-\t\tos=-tpf\n-\t\t;;\n-\tudi29k)\n-\t\tbasic_machine=a29k-amd\n-\t\tos=-udi\n-\t\t;;\n-\tultra3)\n-\t\tbasic_machine=a29k-nyu\n-\t\tos=-sym1\n-\t\t;;\n-\tv810 | necv810)\n-\t\tbasic_machine=v810-nec\n-\t\tos=-none\n-\t\t;;\n-\tvaxv)\n-\t\tbasic_machine=vax-dec\n-\t\tos=-sysv\n-\t\t;;\n-\tvms)\n-\t\tbasic_machine=vax-dec\n-\t\tos=-vms\n-\t\t;;\n-\tvpp*|vx|vx-*)\n-\t\tbasic_machine=f301-fujitsu\n-\t\t;;\n-\tvxworks960)\n-\t\tbasic_machine=i960-wrs\n-\t\tos=-vxworks\n-\t\t;;\n-\tvxworks68)\n-\t\tbasic_machine=m68k-wrs\n-\t\tos=-vxworks\n-\t\t;;\n-\tvxworks29k)\n-\t\tbasic_machine=a29k-wrs\n-\t\tos=-vxworks\n-\t\t;;\n-\twasm32)\n-\t\tbasic_machine=wasm32-unknown\n-\t\t;;\n-\tw65*)\n-\t\tbasic_machine=w65-wdc\n-\t\tos=-none\n-\t\t;;\n-\tw89k-*)\n-\t\tbasic_machine=hppa1.1-winbond\n-\t\tos=-proelf\n-\t\t;;\n-\txbox)\n-\t\tbasic_machine=i686-pc\n-\t\tos=-mingw32\n-\t\t;;\n-\txps | xps100)\n-\t\tbasic_machine=xps100-honeywell\n-\t\t;;\n-\txscale-* | xscalee[bl]-*)\n-\t\tbasic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`\n-\t\t;;\n-\tymp)\n-\t\tbasic_machine=ymp-cray\n-\t\tos=-unicos\n-\t\t;;\n-\tz8k-*-coff)\n-\t\tbasic_machine=z8k-unknown\n-\t\tos=-sim\n-\t\t;;\n-\tz80-*-coff)\n-\t\tbasic_machine=z80-unknown\n-\t\tos=-sim\n-\t\t;;\n-\tnone)\n-\t\tbasic_machine=none-none\n-\t\tos=-none\n-\t\t;;\n-\n-# Here we handle the default manufacturer of certain CPU types.  It is in\n-# some cases the only manufacturer, in others, it is the most popular.\n-\tw89k)\n-\t\tbasic_machine=hppa1.1-winbond\n-\t\t;;\n-\top50n)\n-\t\tbasic_machine=hppa1.1-oki\n-\t\t;;\n-\top60c)\n-\t\tbasic_machine=hppa1.1-oki\n-\t\t;;\n-\tromp)\n-\t\tbasic_machine=romp-ibm\n-\t\t;;\n-\tmmix)\n-\t\tbasic_machine=mmix-knuth\n-\t\t;;\n-\trs6000)\n-\t\tbasic_machine=rs6000-ibm\n-\t\t;;\n-\tvax)\n-\t\tbasic_machine=vax-dec\n-\t\t;;\n-\tpdp10)\n-\t\t# there are many clones, so DEC is not a safe bet\n-\t\tbasic_machine=pdp10-unknown\n-\t\t;;\n-\tpdp11)\n-\t\tbasic_machine=pdp11-dec\n-\t\t;;\n-\twe32k)\n-\t\tbasic_machine=we32k-att\n-\t\t;;\n-\tsh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)\n-\t\tbasic_machine=sh-unknown\n-\t\t;;\n-\tsparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)\n-\t\tbasic_machine=sparc-sun\n-\t\t;;\n-\tcydra)\n-\t\tbasic_machine=cydra-cydrome\n-\t\t;;\n-\torion)\n-\t\tbasic_machine=orion-highlevel\n-\t\t;;\n-\torion105)\n-\t\tbasic_machine=clipper-highlevel\n-\t\t;;\n-\tmac | mpw | mac-mpw)\n-\t\tbasic_machine=m68k-apple\n-\t\t;;\n-\tpmac | pmac-mpw)\n-\t\tbasic_machine=powerpc-apple\n-\t\t;;\n-\t*-unknown)\n-\t\t# Make sure to match an already-canonicalized machine name.\n-\t\t;;\n-\t*)\n-\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n-\t\texit 1\n-\t\t;;\n-esac\n-\n-# Here we canonicalize certain aliases for manufacturers.\n-case $basic_machine in\n-\t*-digital*)\n-\t\tbasic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`\n-\t\t;;\n-\t*-commodore*)\n-\t\tbasic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`\n-\t\t;;\n-\t*)\n-\t\t;;\n-esac\n-\n-# Decode manufacturer-specific aliases for certain operating systems.\n-\n-if [ x\"$os\" != x\"\" ]\n-then\n-case $os in\n-\t# First match some system type aliases\n-\t# that might get confused with valid system types.\n-\t# -solaris* is a basic system type, with this one exception.\n-\t-auroraux)\n-\t\tos=-auroraux\n-\t\t;;\n-\t-solaris1 | -solaris1.*)\n-\t\tos=`echo $os | sed -e 's|solaris1|sunos4|'`\n-\t\t;;\n-\t-solaris)\n-\t\tos=-solaris2\n-\t\t;;\n-\t-svr4*)\n-\t\tos=-sysv4\n-\t\t;;\n-\t-unixware*)\n-\t\tos=-sysv4.2uw\n-\t\t;;\n-\t-gnu/linux*)\n-\t\tos=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`\n-\t\t;;\n-\t# First accept the basic system types.\n-\t# The portable systems comes first.\n-\t# Each alternative MUST END IN A *, to match a version number.\n-\t# -sysv* is not here because it comes later, after sysvr4.\n-\t-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \\\n-\t      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\\\n-\t      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \\\n-\t      | -sym* | -kopensolaris* | -plan9* \\\n-\t      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \\\n-\t      | -aos* | -aros* | -cloudabi* | -sortix* \\\n-\t      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \\\n-\t      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \\\n-\t      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \\\n-\t      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \\\n-\t      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \\\n-\t      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \\\n-\t      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \\\n-\t      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \\\n-\t      | -chorusos* | -chorusrdb* | -cegcc* | -glidix* \\\n-\t      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n-\t      | -midipix* | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \\\n-\t      | -linux-newlib* | -linux-musl* | -linux-uclibc* \\\n-\t      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \\\n-\t      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \\\n-\t      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \\\n-\t      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \\\n-\t      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \\\n-\t      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \\\n-\t      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \\\n-\t      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \\\n-\t      | -onefs* | -tirtos* | -phoenix* | -fuchsia* | -redox*)\n-\t# Remember, each alternative MUST END IN *, to match a version number.\n-\t\t;;\n-\t-qnx*)\n-\t\tcase $basic_machine in\n-\t\t    x86-* | i*86-*)\n-\t\t\t;;\n-\t\t    *)\n-\t\t\tos=-nto$os\n-\t\t\t;;\n-\t\tesac\n-\t\t;;\n-\t-nto-qnx*)\n-\t\t;;\n-\t-nto*)\n-\t\tos=`echo $os | sed -e 's|nto|nto-qnx|'`\n-\t\t;;\n-\t-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \\\n-\t      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \\\n-\t      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)\n-\t\t;;\n-\t-mac*)\n-\t\tos=`echo $os | sed -e 's|mac|macos|'`\n-\t\t;;\n-\t-linux-dietlibc)\n-\t\tos=-linux-dietlibc\n-\t\t;;\n-\t-linux*)\n-\t\tos=`echo $os | sed -e 's|linux|linux-gnu|'`\n-\t\t;;\n-\t-sunos5*)\n-\t\tos=`echo $os | sed -e 's|sunos5|solaris2|'`\n-\t\t;;\n-\t-sunos6*)\n-\t\tos=`echo $os | sed -e 's|sunos6|solaris3|'`\n-\t\t;;\n-\t-opened*)\n-\t\tos=-openedition\n-\t\t;;\n-\t-os400*)\n-\t\tos=-os400\n-\t\t;;\n-\t-wince*)\n-\t\tos=-wince\n-\t\t;;\n-\t-osfrose*)\n-\t\tos=-osfrose\n-\t\t;;\n-\t-osf*)\n-\t\tos=-osf\n-\t\t;;\n-\t-utek*)\n-\t\tos=-bsd\n-\t\t;;\n-\t-dynix*)\n-\t\tos=-bsd\n-\t\t;;\n-\t-acis*)\n-\t\tos=-aos\n-\t\t;;\n-\t-atheos*)\n-\t\tos=-atheos\n-\t\t;;\n-\t-syllable*)\n-\t\tos=-syllable\n-\t\t;;\n-\t-386bsd)\n-\t\tos=-bsd\n-\t\t;;\n-\t-ctix* | -uts*)\n-\t\tos=-sysv\n-\t\t;;\n-\t-nova*)\n-\t\tos=-rtmk-nova\n-\t\t;;\n-\t-ns2 )\n-\t\tos=-nextstep2\n-\t\t;;\n-\t-nsk*)\n-\t\tos=-nsk\n-\t\t;;\n-\t# Preserve the version number of sinix5.\n-\t-sinix5.*)\n-\t\tos=`echo $os | sed -e 's|sinix|sysv|'`\n-\t\t;;\n-\t-sinix*)\n-\t\tos=-sysv4\n-\t\t;;\n-\t-tpf*)\n-\t\tos=-tpf\n-\t\t;;\n-\t-triton*)\n-\t\tos=-sysv3\n-\t\t;;\n-\t-oss*)\n-\t\tos=-sysv3\n-\t\t;;\n-\t-svr4)\n-\t\tos=-sysv4\n-\t\t;;\n-\t-svr3)\n-\t\tos=-sysv3\n-\t\t;;\n-\t-sysvr4)\n-\t\tos=-sysv4\n-\t\t;;\n-\t# This must come after -sysvr4.\n-\t-sysv*)\n-\t\t;;\n-\t-ose*)\n-\t\tos=-ose\n-\t\t;;\n-\t-es1800*)\n-\t\tos=-ose\n-\t\t;;\n-\t-xenix)\n-\t\tos=-xenix\n-\t\t;;\n-\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n-\t\tos=-mint\n-\t\t;;\n-\t-aros*)\n-\t\tos=-aros\n-\t\t;;\n-\t-zvmoe)\n-\t\tos=-zvmoe\n-\t\t;;\n-\t-dicos*)\n-\t\tos=-dicos\n-\t\t;;\n-\t-nacl*)\n-\t\t;;\n-\t-ios)\n-\t\t;;\n-\t-none)\n-\t\t;;\n-\t*)\n-\t\t# Get rid of the `-' at the beginning of $os.\n-\t\tos=`echo $os | sed 's/[^-]*-//'`\n-\t\techo Invalid configuration \\`$1\\': system \\`$os\\' not recognized 1>&2\n-\t\texit 1\n-\t\t;;\n-esac\n-else\n-\n-# Here we handle the default operating systems that come with various machines.\n-# The value should be what the vendor currently ships out the door with their\n-# machine or put another way, the most popular os provided with the machine.\n-\n-# Note that if you're going to try to match \"-MANUFACTURER\" here (say,\n-# \"-sun\"), then you have to tell the case statement up towards the top\n-# that MANUFACTURER isn't an operating system.  Otherwise, code above\n-# will signal an error saying that MANUFACTURER isn't an operating\n-# system, and we'll never get to this point.\n-\n-case $basic_machine in\n-\tscore-*)\n-\t\tos=-elf\n-\t\t;;\n-\tspu-*)\n-\t\tos=-elf\n-\t\t;;\n-\t*-acorn)\n-\t\tos=-riscix1.2\n-\t\t;;\n-\tarm*-rebel)\n-\t\tos=-linux\n-\t\t;;\n-\tarm*-semi)\n-\t\tos=-aout\n-\t\t;;\n-\tc4x-* | tic4x-*)\n-\t\tos=-coff\n-\t\t;;\n-\tc8051-*)\n-\t\tos=-elf\n-\t\t;;\n-\thexagon-*)\n-\t\tos=-elf\n-\t\t;;\n-\ttic54x-*)\n-\t\tos=-coff\n-\t\t;;\n-\ttic55x-*)\n-\t\tos=-coff\n-\t\t;;\n-\ttic6x-*)\n-\t\tos=-coff\n-\t\t;;\n-\t# This must come before the *-dec entry.\n-\tpdp10-*)\n-\t\tos=-tops20\n-\t\t;;\n-\tpdp11-*)\n-\t\tos=-none\n-\t\t;;\n-\t*-dec | vax-*)\n-\t\tos=-ultrix4.2\n-\t\t;;\n-\tm68*-apollo)\n-\t\tos=-domain\n-\t\t;;\n-\ti386-sun)\n-\t\tos=-sunos4.0.2\n-\t\t;;\n-\tm68000-sun)\n-\t\tos=-sunos3\n-\t\t;;\n-\tm68*-cisco)\n-\t\tos=-aout\n-\t\t;;\n-\tmep-*)\n-\t\tos=-elf\n-\t\t;;\n-\tmips*-cisco)\n-\t\tos=-elf\n-\t\t;;\n-\tmips*-*)\n-\t\tos=-elf\n-\t\t;;\n-\tor32-*)\n-\t\tos=-coff\n-\t\t;;\n-\t*-tti)\t# must be before sparc entry or we get the wrong os.\n-\t\tos=-sysv3\n-\t\t;;\n-\tsparc-* | *-sun)\n-\t\tos=-sunos4.1.1\n-\t\t;;\n-\tpru-*)\n-\t\tos=-elf\n-\t\t;;\n-\t*-be)\n-\t\tos=-beos\n-\t\t;;\n-\t*-haiku)\n-\t\tos=-haiku\n-\t\t;;\n-\t*-ibm)\n-\t\tos=-aix\n-\t\t;;\n-\t*-knuth)\n-\t\tos=-mmixware\n-\t\t;;\n-\t*-wec)\n-\t\tos=-proelf\n-\t\t;;\n-\t*-winbond)\n-\t\tos=-proelf\n-\t\t;;\n-\t*-oki)\n-\t\tos=-proelf\n-\t\t;;\n-\t*-hp)\n-\t\tos=-hpux\n-\t\t;;\n-\t*-hitachi)\n-\t\tos=-hiux\n-\t\t;;\n-\ti860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)\n-\t\tos=-sysv\n-\t\t;;\n-\t*-cbm)\n-\t\tos=-amigaos\n-\t\t;;\n-\t*-dg)\n-\t\tos=-dgux\n-\t\t;;\n-\t*-dolphin)\n-\t\tos=-sysv3\n-\t\t;;\n-\tm68k-ccur)\n-\t\tos=-rtu\n-\t\t;;\n-\tm88k-omron*)\n-\t\tos=-luna\n-\t\t;;\n-\t*-next )\n-\t\tos=-nextstep\n-\t\t;;\n-\t*-sequent)\n-\t\tos=-ptx\n-\t\t;;\n-\t*-crds)\n-\t\tos=-unos\n-\t\t;;\n-\t*-ns)\n-\t\tos=-genix\n-\t\t;;\n-\ti370-*)\n-\t\tos=-mvs\n-\t\t;;\n-\t*-next)\n-\t\tos=-nextstep3\n-\t\t;;\n-\t*-gould)\n-\t\tos=-sysv\n-\t\t;;\n-\t*-highlevel)\n-\t\tos=-bsd\n-\t\t;;\n-\t*-encore)\n-\t\tos=-bsd\n-\t\t;;\n-\t*-sgi)\n-\t\tos=-irix\n-\t\t;;\n-\t*-siemens)\n-\t\tos=-sysv4\n-\t\t;;\n-\t*-masscomp)\n-\t\tos=-rtu\n-\t\t;;\n-\tf30[01]-fujitsu | f700-fujitsu)\n-\t\tos=-uxpv\n-\t\t;;\n-\t*-rom68k)\n-\t\tos=-coff\n-\t\t;;\n-\t*-*bug)\n-\t\tos=-coff\n-\t\t;;\n-\t*-apple)\n-\t\tos=-macos\n-\t\t;;\n-\t*-atari*)\n-\t\tos=-mint\n-\t\t;;\n-\t*)\n-\t\tos=-none\n-\t\t;;\n-esac\n-fi\n-\n-# Here we handle the case where we know the os, and the CPU type, but not the\n-# manufacturer.  We pick the logical manufacturer.\n-vendor=unknown\n-case $basic_machine in\n-\t*-unknown)\n-\t\tcase $os in\n-\t\t\t-riscix*)\n-\t\t\t\tvendor=acorn\n-\t\t\t\t;;\n-\t\t\t-sunos*)\n-\t\t\t\tvendor=sun\n-\t\t\t\t;;\n-\t\t\t-cnk*|-aix*)\n-\t\t\t\tvendor=ibm\n-\t\t\t\t;;\n-\t\t\t-beos*)\n-\t\t\t\tvendor=be\n-\t\t\t\t;;\n-\t\t\t-hpux*)\n-\t\t\t\tvendor=hp\n-\t\t\t\t;;\n-\t\t\t-mpeix*)\n-\t\t\t\tvendor=hp\n-\t\t\t\t;;\n-\t\t\t-hiux*)\n-\t\t\t\tvendor=hitachi\n-\t\t\t\t;;\n-\t\t\t-unos*)\n-\t\t\t\tvendor=crds\n-\t\t\t\t;;\n-\t\t\t-dgux*)\n-\t\t\t\tvendor=dg\n-\t\t\t\t;;\n-\t\t\t-luna*)\n-\t\t\t\tvendor=omron\n-\t\t\t\t;;\n-\t\t\t-genix*)\n-\t\t\t\tvendor=ns\n-\t\t\t\t;;\n-\t\t\t-mvs* | -opened*)\n-\t\t\t\tvendor=ibm\n-\t\t\t\t;;\n-\t\t\t-os400*)\n-\t\t\t\tvendor=ibm\n-\t\t\t\t;;\n-\t\t\t-ptx*)\n-\t\t\t\tvendor=sequent\n-\t\t\t\t;;\n-\t\t\t-tpf*)\n-\t\t\t\tvendor=ibm\n-\t\t\t\t;;\n-\t\t\t-vxsim* | -vxworks* | -windiss*)\n-\t\t\t\tvendor=wrs\n-\t\t\t\t;;\n-\t\t\t-aux*)\n-\t\t\t\tvendor=apple\n-\t\t\t\t;;\n-\t\t\t-hms*)\n-\t\t\t\tvendor=hitachi\n-\t\t\t\t;;\n-\t\t\t-mpw* | -macos*)\n-\t\t\t\tvendor=apple\n-\t\t\t\t;;\n-\t\t\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n-\t\t\t\tvendor=atari\n-\t\t\t\t;;\n-\t\t\t-vos*)\n-\t\t\t\tvendor=stratus\n-\t\t\t\t;;\n-\t\tesac\n-\t\tbasic_machine=`echo $basic_machine | sed \"s/unknown/$vendor/\"`\n-\t\t;;\n-esac\n-\n-echo $basic_machine$os\n-exit\n-\n-# Local variables:\n-# eval: (add-hook 'write-file-hooks 'time-stamp)\n-# time-stamp-start: \"timestamp='\"\n-# time-stamp-format: \"%:y-%02m-%02d\"\n-# time-stamp-end: \"'\"\n-# End:"}, {"sha": "8bdb29d25606f81756b37437032f286dadcad96d", "filename": "src/libbacktrace/configure", "status": "removed", "additions": 0, "deletions": 15199, "changes": 15199, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=20af72b943527d584df4b99e157262f9b297b3e4"}, {"sha": "ea1b27d807e13d9741f4fa7821f16e6f2e0006c3", "filename": "src/libbacktrace/configure.ac", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,418 +0,0 @@\n-# configure.ac -- Backtrace configure script.\n-# Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-\n-# Redistribution and use in source and binary forms, with or without\n-# modification, are permitted provided that the following conditions are\n-# met:\n-\n-#     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer. \n-\n-#     (2) Redistributions in binary form must reproduce the above copyright\n-#     notice, this list of conditions and the following disclaimer in\n-#     the documentation and/or other materials provided with the\n-#     distribution.  \n-    \n-#     (3) The name of the author may not be used to\n-#     endorse or promote products derived from this software without\n-#     specific prior written permission.\n-\n-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-# POSSIBILITY OF SUCH DAMAGE.\n-\n-AC_PREREQ(2.64)\n-AC_INIT(package-unused, version-unused,, libbacktrace)\n-AC_CONFIG_SRCDIR(backtrace.h)\n-AC_CONFIG_HEADER(config.h)\n-\n-if test -n \"${with_target_subdir}\"; then\n-  AM_ENABLE_MULTILIB(, ..)\n-fi\n-\n-AC_CANONICAL_SYSTEM\n-target_alias=${target_alias-$host_alias}\n-\n-AC_USE_SYSTEM_EXTENSIONS\n-\n-libtool_VERSION=1:0:0\n-AC_SUBST(libtool_VERSION)\n-\n-# 1.11.1: Require that version of automake.\n-# foreign: Don't require README, INSTALL, NEWS, etc.\n-# no-define: Don't define PACKAGE and VERSION.\n-# no-dependencies: Don't generate automatic dependencies.\n-#    (because it breaks when using bootstrap-lean, since some of the\n-#    headers are gone at \"make install\" time).\n-# -Wall: Issue all automake warnings.\n-# -Wno-portability: Don't warn about constructs supported by GNU make.\n-#    (because GCC requires GNU make anyhow).\n-AM_INIT_AUTOMAKE([1.11.1 foreign no-dist no-define no-dependencies -Wall -Wno-portability])\n-\n-AM_MAINTAINER_MODE\n-\n-AC_ARG_WITH(target-subdir,\n-[  --with-target-subdir=SUBDIR      Configuring in a subdirectory for target])\n-\n-# We must force CC to /not/ be precious variables; otherwise\n-# the wrong, non-multilib-adjusted value will be used in multilibs.\n-# As a side effect, we have to subst CFLAGS ourselves.\n-m4_rename([_AC_ARG_VAR_PRECIOUS],[backtrace_PRECIOUS])\n-m4_define([_AC_ARG_VAR_PRECIOUS],[])\n-AC_PROG_CC\n-m4_rename_force([backtrace_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n-\n-AC_SUBST(CFLAGS)\n-\n-AC_PROG_RANLIB\n-\n-AC_PROG_AWK\n-case \"$AWK\" in\n-\"\") AC_MSG_ERROR([can't build without awk]) ;;\n-esac\n-\n-LT_INIT\n-AM_PROG_LIBTOOL\n-\n-backtrace_supported=yes\n-\n-if test -n \"${with_target_subdir}\"; then\n-  # We are compiling a GCC library.  We can assume that the unwind\n-  # library exists.\n-  BACKTRACE_FILE=\"backtrace.lo simple.lo\"\n-else\n-  AC_CHECK_HEADER([unwind.h],\n-    [AC_CHECK_FUNC([_Unwind_Backtrace],\n-\t           [BACKTRACE_FILE=\"backtrace.lo simple.lo\"],\n-\t\t   [BACKTRACE_FILE=\"nounwind.lo\"\n-                    backtrace_supported=no])],\n-    [BACKTRACE_FILE=\"nounwind.lo\"\n-     backtrace_supported=no])\n-fi\n-AC_SUBST(BACKTRACE_FILE)\n-\n-EXTRA_FLAGS=\n-if test -n \"${with_target_subdir}\"; then\n-  EXTRA_FLAGS=\"-funwind-tables -frandom-seed=\\$@\"\n-else\n-  AC_CACHE_CHECK([for -funwind-tables option],\n-    [libbacktrace_cv_c_unwind_tables],\n-    [CFLAGS_hold=\"$CFLAGS\"\n-     CFLAGS=\"$CFLAGS -funwind-tables\"\n-     AC_COMPILE_IFELSE(\n-       [AC_LANG_PROGRAM([static int f() { return 0; }], [return f();])],\n-       [libbacktrace_cv_c_unwind_tables=yes],\n-       [libbacktrace_cv_c_unwind_tables=no])\n-     CFLAGS=\"$CFLAGS_hold\"])\n-  if test \"$libbacktrace_cv_c_unwind_tables\" = \"yes\"; then\n-    EXTRA_FLAGS=-funwind-tables\n-  fi\n-  AC_CACHE_CHECK([for -frandom-seed=string option],\n-    [libbacktrace_cv_c_random_seed_string],\n-    [CFLAGS_hold=\"$CFLAGS\"\n-     CFLAGS=\"$CFLAGS -frandom-seed=conftest.lo\"\n-     AC_COMPILE_IFELSE(\n-       [AC_LANG_PROGRAM([], [return 0;])],\n-       [libbacktrace_cv_c_random_seed_string=yes],\n-       [libbacktrace_cv_c_random_seed_string=no])\n-     CFLAGS=\"$CFLAGS_hold\"])\n-  if test \"$libbacktrace_cv_c_random_seed_string\" = \"yes\"; then\n-    EXTRA_FLAGS=\"$EXTRA_FLAGS -frandom-seed=\\$@\"\n-  fi\n-fi\n-AC_SUBST(EXTRA_FLAGS)\n-\n-ACX_PROG_CC_WARNING_OPTS([-W -Wall -Wwrite-strings -Wstrict-prototypes \\\n-\t\t\t  -Wmissing-prototypes -Wold-style-definition \\\n-\t\t\t  -Wmissing-format-attribute -Wcast-qual],\n-\t\t\t  [WARN_FLAGS])\n-\n-if test -n \"${with_target_subdir}\"; then\n-  WARN_FLAGS=\"$WARN_FLAGS -Werror\"\n-fi\n-\n-AC_SUBST(WARN_FLAGS)\n-\n-if test -n \"${with_target_subdir}\"; then\n-  GCC_CHECK_UNWIND_GETIPINFO\n-else\n-  ac_save_CFFLAGS=\"$CFLAGS\"\n-  CFLAGS=\"$CFLAGS -Werror-implicit-function-declaration\"\n-  AC_MSG_CHECKING([for _Unwind_GetIPInfo])\n-  AC_LINK_IFELSE(\n-    [AC_LANG_PROGRAM(\n-       [#include \"unwind.h\"\n-\tstruct _Unwind_Context *context;\n-\tint ip_before_insn = 0;],\n-\t[return _Unwind_GetIPInfo (context, &ip_before_insn);])],\n-\t[have_unwind_getipinfo=yes], [have_unwind_getipinfo=no])\n-  CFLAGS=\"$ac_save_CFLAGS\"\n-  AC_MSG_RESULT([$have_unwind_getipinfo])\n-  if test \"$have_unwind_getipinfo\" = \"yes\"; then\n-    AC_DEFINE(HAVE_GETIPINFO, 1, [Define if _Unwind_GetIPInfo is available.])\n-  fi\n-fi\n-\n-# Enable --enable-host-shared.\n-AC_ARG_ENABLE(host-shared,\n-[AS_HELP_STRING([--enable-host-shared],\n-\t\t[build host code as shared libraries])],\n-[PIC_FLAG=-fPIC], [PIC_FLAG=])\n-AC_SUBST(PIC_FLAG)\n-\n-# Test for __sync support.\n-AC_CACHE_CHECK([__sync extensions],\n-[libbacktrace_cv_sys_sync],\n-[if test -n \"${with_target_subdir}\"; then\n-   case \"${host}\" in\n-   hppa*-*-hpux*) libbacktrace_cv_sys_sync=no ;;\n-   *) libbacktrace_cv_sys_sync=yes ;;\n-   esac\n- else\n-   AC_LINK_IFELSE(\n-     [AC_LANG_PROGRAM([int i;],\n-                      [__sync_bool_compare_and_swap (&i, i, i);\n-                       __sync_lock_test_and_set (&i, 1);\n-                       __sync_lock_release (&i);])],\n-     [libbacktrace_cv_sys_sync=yes],\n-     [libbacktrace_cv_sys_sync=no])\n- fi])\n-BACKTRACE_SUPPORTS_THREADS=0\n-if test \"$libbacktrace_cv_sys_sync\" = \"yes\"; then\n-  BACKTRACE_SUPPORTS_THREADS=1\n-  AC_DEFINE([HAVE_SYNC_FUNCTIONS], 1,\n-\t    [Define to 1 if you have the __sync functions])\n-fi\n-AC_SUBST(BACKTRACE_SUPPORTS_THREADS)\n-\n-# Test for __atomic support.\n-AC_CACHE_CHECK([__atomic extensions],\n-[libbacktrace_cv_sys_atomic],\n-[if test -n \"${with_target_subdir}\"; then\n-   libbacktrace_cv_sys_atomic=yes\n- else\n-   AC_LINK_IFELSE(\n-     [AC_LANG_PROGRAM([int i;],\n-     \t\t      [__atomic_load_n (&i, __ATOMIC_ACQUIRE);\n-\t\t       __atomic_store_n (&i, 1, __ATOMIC_RELEASE);])],\n-     [libbacktrace_cv_sys_atomic=yes],\n-     [libbacktrace_cv_sys_atomic=no])\n- fi])\n-if test \"$libbacktrace_cv_sys_atomic\" = \"yes\"; then\n-  AC_DEFINE([HAVE_ATOMIC_FUNCTIONS], 1,\n-\t    [Define to 1 if you have the __atomic functions])\n-fi\n-\n-# The library needs to be able to read the executable itself.  Compile\n-# a file to determine the executable format.  The awk script\n-# filetype.awk prints out the file type.\n-AC_CACHE_CHECK([output filetype],\n-[libbacktrace_cv_sys_filetype],\n-[filetype=\n-AC_COMPILE_IFELSE(\n-  [AC_LANG_PROGRAM([int i;], [int j;])],\n-  [filetype=`${AWK} -f $srcdir/filetype.awk conftest.$ac_objext`],\n-  [AC_MSG_FAILURE([compiler failed])])\n-libbacktrace_cv_sys_filetype=$filetype])\n-\n-# Match the file type to decide what files to compile.\n-FORMAT_FILE=\n-backtrace_supports_data=yes\n-case \"$libbacktrace_cv_sys_filetype\" in\n-elf*) FORMAT_FILE=\"elf.lo\" ;;\n-pecoff) FORMAT_FILE=\"pecoff.lo\"\n-        backtrace_supports_data=no\n-\t;;\n-macho*) FORMAT_FILE=\"macho.lo\"\n-        backtrace_supports_data=no\n-        ;;\n-*) AC_MSG_WARN([could not determine output file type])\n-   FORMAT_FILE=\"unknown.lo\"\n-   backtrace_supported=no\n-   ;;\n-esac\n-AC_SUBST(FORMAT_FILE)\n-\n-# ELF defines.\n-elfsize=\n-case \"$libbacktrace_cv_sys_filetype\" in\n-elf32) elfsize=32 ;;\n-elf64) elfsize=64 ;;\n-*)     elfsize=unused\n-esac\n-AC_DEFINE_UNQUOTED([BACKTRACE_ELF_SIZE], [$elfsize], [ELF size: 32 or 64])\n-\n-BACKTRACE_SUPPORTED=0\n-if test \"$backtrace_supported\" = \"yes\"; then\n-  BACKTRACE_SUPPORTED=1\n-fi\n-AC_SUBST(BACKTRACE_SUPPORTED)\n-\n-BACKTRACE_SUPPORTS_DATA=0\n-if test \"$backtrace_supports_data\" = \"yes\"; then\n-  BACKTRACE_SUPPORTS_DATA=1\n-fi\n-AC_SUBST(BACKTRACE_SUPPORTS_DATA)\n-\n-GCC_HEADER_STDINT(gstdint.h)\n-\n-AC_CHECK_HEADERS(sys/mman.h)\n-if test \"$ac_cv_header_sys_mman_h\" = \"no\"; then\n-  have_mmap=no\n-else\n-  if test -n \"${with_target_subdir}\"; then\n-    # When built as a GCC target library, we can't do a link test.  We\n-    # simply assume that if we have mman.h, we have mmap.\n-    have_mmap=yes\n-    case \"${host}\" in\n-    spu-*-*|*-*-msdosdjgpp)\n-        # The SPU does not have mmap, but it has a sys/mman.h header file\n-        # containing \"mmap_eaddr\" and the mmap flags, confusing the test.\n-        # DJGPP also has sys/man.h, but no mmap\n-\thave_mmap=no ;;\n-    esac\n-  else\n-    AC_CHECK_FUNC(mmap, [have_mmap=yes], [have_mmap=no])\n-  fi\n-fi\n-\n-case \"${host_os}\" in\n-darwin*)\n-  have_mmap=no ;;\n-esac\n-\n-if test \"$have_mmap\" = \"no\"; then\n-  VIEW_FILE=read.lo\n-  ALLOC_FILE=alloc.lo\n-else\n-  VIEW_FILE=mmapio.lo\n-  AC_PREPROC_IFELSE([\n-#include <sys/mman.h>\n-#if !defined(MAP_ANONYMOUS) && !defined(MAP_ANON)\n-  #error no MAP_ANONYMOUS\n-#endif\n-], [ALLOC_FILE=mmap.lo], [ALLOC_FILE=alloc.lo])\n-fi\n-AC_SUBST(VIEW_FILE)\n-AC_SUBST(ALLOC_FILE)\n-\n-BACKTRACE_USES_MALLOC=0\n-if test \"$ALLOC_FILE\" = \"alloc.lo\"; then\n-  BACKTRACE_USES_MALLOC=1\n-fi\n-AC_SUBST(BACKTRACE_USES_MALLOC)\n-\n-# Check for dl_iterate_phdr.\n-AC_CHECK_HEADERS(link.h)\n-if test \"$ac_cv_header_link_h\" = \"no\"; then\n-  have_dl_iterate_phdr=no\n-else\n-  if test -n \"${with_target_subdir}\"; then\n-    # When built as a GCC target library, we can't do a link test.\n-    AC_EGREP_HEADER([dl_iterate_phdr], [link.h], [have_dl_iterate_phdr=yes],\n-\t\t    [have_dl_iterate_phdr=no])\n-    case \"${host}\" in\n-    *-*-solaris2.10*)\n-        # Avoid dl_iterate_phdr on Solaris 10, where it is in the\n-    \t# header file but is only in -ldl.\n-\thave_dl_iterate_phdr=no ;;\n-    esac\n-  else\n-    AC_CHECK_FUNC([dl_iterate_phdr], [have_dl_iterate_phdr=yes],\n-\t\t  [have_dl_iterate_phdr=no])\n-  fi\n-fi\n-if test \"$have_dl_iterate_phdr\" = \"yes\"; then\n-  AC_DEFINE(HAVE_DL_ITERATE_PHDR, 1, [Define if dl_iterate_phdr is available.])\n-fi\n-\n-# Check for the fcntl function.\n-if test -n \"${with_target_subdir}\"; then\n-   case \"${host}\" in\n-   *-*-mingw*) have_fcntl=no ;;\n-   spu-*-*) have_fcntl=no ;;\n-   *) have_fcntl=yes ;;\n-   esac\n-else\n-  AC_CHECK_FUNC(fcntl, [have_fcntl=yes], [have_fcntl=no])\n-fi\n-if test \"$have_fcntl\" = \"yes\"; then\n-  AC_DEFINE([HAVE_FCNTL], 1,\n-\t    [Define to 1 if you have the fcntl function])\n-fi\n-\n-AC_CHECK_DECLS(strnlen)\n-\n-# Check for getexecname function.\n-if test -n \"${with_target_subdir}\"; then\n-   case \"${host}\" in\n-   *-*-solaris2*) have_getexecname=yes ;;\n-   *) have_getexecname=no ;;\n-   esac\n-else\n-  AC_CHECK_FUNC(getexecname, [have_getexecname=yes], [have_getexecname=no])\n-fi\n-if test \"$have_getexecname\" = \"yes\"; then\n-  AC_DEFINE(HAVE_GETEXECNAME, 1, [Define if getexecname is available.])\n-fi\n-\n-AC_CACHE_CHECK([whether tests can run],\n-  [libbacktrace_cv_sys_native],\n-  [AC_RUN_IFELSE([AC_LANG_PROGRAM([], [return 0;])],\n-     [libbacktrace_cv_sys_native=yes],\n-     [libbacktrace_cv_sys_native=no],\n-     [libbacktrace_cv_sys_native=no])])\n-AM_CONDITIONAL(NATIVE, test \"$libbacktrace_cv_sys_native\" = \"yes\")\n-\n-if test \"${multilib}\" = \"yes\"; then\n-  multilib_arg=\"--enable-multilib\"\n-else\n-  multilib_arg=\n-fi\n-\n-AC_CONFIG_FILES(Makefile backtrace-supported.h)\n-\n-# We need multilib support, but only if configuring for the target.\n-AC_CONFIG_COMMANDS([default],\n-[if test -n \"$CONFIG_FILES\"; then\n-   if test -n \"${with_target_subdir}\"; then\n-     # Multilibs need MULTISUBDIR defined correctly in certain makefiles so\n-     # that multilib installs will end up installed in the correct place.\n-     # The testsuite needs it for multilib-aware ABI baseline files.\n-     # To work around this not being passed down from config-ml.in ->\n-     # srcdir/Makefile.am -> srcdir/{src,libsupc++,...}/Makefile.am, manually\n-     # append it here.  Only modify Makefiles that have just been created.\n-     #\n-     # Also, get rid of this simulated-VPATH thing that automake does.\n-     cat > vpsed << \\_EOF\n-  s!`test -f '$<' || echo '$(srcdir)/'`!!\n-_EOF\n-     for i in $SUBDIRS; do\n-      case $CONFIG_FILES in\n-       *${i}/Makefile*)\n-\t #echo \"Adding MULTISUBDIR to $i/Makefile\"\n-\t sed -f vpsed $i/Makefile > tmp\n-\t grep '^MULTISUBDIR =' Makefile >> tmp\n-\t mv tmp $i/Makefile\n-\t ;;\n-      esac\n-     done\n-     rm vpsed\n-   fi\n- fi\n-],\n-[\n-# Variables needed in config.status (file generation) which aren't already\n-# passed by autoconf.\n-SUBDIRS=\"$SUBDIRS\"\n-])\n-\n-AC_OUTPUT"}, {"sha": "55b8d7dc2a56d96e69df0a1be6728bad212754c7", "filename": "src/libbacktrace/dwarf.c", "status": "removed", "additions": 0, "deletions": 3038, "changes": 3038, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fdwarf.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf.c?ref=20af72b943527d584df4b99e157262f9b297b3e4"}, {"sha": "2dfee5666dea68d8292f04c5100c93e1f1fcf4f4", "filename": "src/libbacktrace/dwarf2.def", "status": "removed", "additions": 0, "deletions": 713, "changes": 713, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fdwarf2.def", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fdwarf2.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.def?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,713 +0,0 @@\n-/* -*- c -*-\n-   Declarations and definitions of codes relating to the DWARF2 and\n-   DWARF3 symbolic debugging information formats.\n-   Copyright (C) 1992-2015 Free Software Foundation, Inc.\n-\n-   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program\n-   Office (AJPO), Florida State University and Silicon Graphics Inc.\n-   provided support for this effort -- June 21, 1995.\n-\n-   Derived from the DWARF 1 implementation written by Ron Guilmette\n-   (rfg@netcom.com), November 1990.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* This file is derived from the DWARF specification (a public document)\n-   Revision 2.0.0 (July 27, 1993) developed by the UNIX International\n-   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n-   by UNIX International.  Copies of this specification are available from\n-   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n-\n-   This file also now contains definitions from the DWARF 3 specification\n-   published Dec 20, 2005, available from: http://dwarf.freestandards.org.\n-\n-   This file also now contains definitions from the DWARF 4\n-   specification, available from: http://dwarfstd.org/ */\n-\n-/* This file declares various DWARF-related constants using a set of\n-   macros which can be redefined by the including file.\n-   \n-   The macros are in sections.  Each section corresponds to a single\n-   set of DWARF constants and has a corresponding key.  The key is\n-   used in all the macro names.\n-   \n-   The sections are TAG (for DW_TAG_ constants), FORM (DW_FORM_), AT\n-   (DW_AT_), OP (DW_OP_), ATE (DW_ATE_), and CFA (DW_CFA_).\n-   \n-   Using TAG as an example, the following macros may be used for each\n-   key:\n-   \n-   DW_FIRST_TAG(name, value) - Introduce the first DW_TAG constant.\n-   \n-   DW_TAG(name, value) - Define a subsequent constant.\n-   \n-   DW_TAG_DUP(name, value) - Define a subsequent constant whose value\n-   is a duplicate of some other constant.  Not all keys use the _DUP\n-   macro form.  If more than one name shares a value, then the base\n-   (DW_TAG) form will be the preferred name and DW_TAG_DUP will hold\n-   any alternate names.\n-   \n-   DW_END_TAG - Invoked at the end of the DW_TAG constants.  */\n-\n-DW_FIRST_TAG (DW_TAG_padding, 0x00)\n-DW_TAG (DW_TAG_array_type, 0x01)\n-DW_TAG (DW_TAG_class_type, 0x02)\n-DW_TAG (DW_TAG_entry_point, 0x03)\n-DW_TAG (DW_TAG_enumeration_type, 0x04)\n-DW_TAG (DW_TAG_formal_parameter, 0x05)\n-DW_TAG (DW_TAG_imported_declaration, 0x08)\n-DW_TAG (DW_TAG_label, 0x0a)\n-DW_TAG (DW_TAG_lexical_block, 0x0b)\n-DW_TAG (DW_TAG_member, 0x0d)\n-DW_TAG (DW_TAG_pointer_type, 0x0f)\n-DW_TAG (DW_TAG_reference_type, 0x10)\n-DW_TAG (DW_TAG_compile_unit, 0x11)\n-DW_TAG (DW_TAG_string_type, 0x12)\n-DW_TAG (DW_TAG_structure_type, 0x13)\n-DW_TAG (DW_TAG_subroutine_type, 0x15)\n-DW_TAG (DW_TAG_typedef, 0x16)\n-DW_TAG (DW_TAG_union_type, 0x17)\n-DW_TAG (DW_TAG_unspecified_parameters, 0x18)\n-DW_TAG (DW_TAG_variant, 0x19)\n-DW_TAG (DW_TAG_common_block, 0x1a)\n-DW_TAG (DW_TAG_common_inclusion, 0x1b)\n-DW_TAG (DW_TAG_inheritance, 0x1c)\n-DW_TAG (DW_TAG_inlined_subroutine, 0x1d)\n-DW_TAG (DW_TAG_module, 0x1e)\n-DW_TAG (DW_TAG_ptr_to_member_type, 0x1f)\n-DW_TAG (DW_TAG_set_type, 0x20)\n-DW_TAG (DW_TAG_subrange_type, 0x21)\n-DW_TAG (DW_TAG_with_stmt, 0x22)\n-DW_TAG (DW_TAG_access_declaration, 0x23)\n-DW_TAG (DW_TAG_base_type, 0x24)\n-DW_TAG (DW_TAG_catch_block, 0x25)\n-DW_TAG (DW_TAG_const_type, 0x26)\n-DW_TAG (DW_TAG_constant, 0x27)\n-DW_TAG (DW_TAG_enumerator, 0x28)\n-DW_TAG (DW_TAG_file_type, 0x29)\n-DW_TAG (DW_TAG_friend, 0x2a)\n-DW_TAG (DW_TAG_namelist, 0x2b)\n-DW_TAG (DW_TAG_namelist_item, 0x2c)\n-DW_TAG (DW_TAG_packed_type, 0x2d)\n-DW_TAG (DW_TAG_subprogram, 0x2e)\n-DW_TAG (DW_TAG_template_type_param, 0x2f)\n-DW_TAG (DW_TAG_template_value_param, 0x30)\n-DW_TAG (DW_TAG_thrown_type, 0x31)\n-DW_TAG (DW_TAG_try_block, 0x32)\n-DW_TAG (DW_TAG_variant_part, 0x33)\n-DW_TAG (DW_TAG_variable, 0x34)\n-DW_TAG (DW_TAG_volatile_type, 0x35)\n-/* DWARF 3.  */\n-DW_TAG (DW_TAG_dwarf_procedure, 0x36)\n-DW_TAG (DW_TAG_restrict_type, 0x37)\n-DW_TAG (DW_TAG_interface_type, 0x38)\n-DW_TAG (DW_TAG_namespace, 0x39)\n-DW_TAG (DW_TAG_imported_module, 0x3a)\n-DW_TAG (DW_TAG_unspecified_type, 0x3b)\n-DW_TAG (DW_TAG_partial_unit, 0x3c)\n-DW_TAG (DW_TAG_imported_unit, 0x3d)\n-DW_TAG (DW_TAG_condition, 0x3f)\n-DW_TAG (DW_TAG_shared_type, 0x40)\n-/* DWARF 4.  */\n-DW_TAG (DW_TAG_type_unit, 0x41)\n-DW_TAG (DW_TAG_rvalue_reference_type, 0x42)\n-DW_TAG (DW_TAG_template_alias, 0x43)\n-/* DWARF 5.  */\n-DW_TAG (DW_TAG_atomic_type, 0x47)\n-\n-DW_TAG_DUP (DW_TAG_lo_user, 0x4080)\n-DW_TAG_DUP (DW_TAG_hi_user, 0xffff)\n-\n-/* SGI/MIPS Extensions.  */\n-DW_TAG (DW_TAG_MIPS_loop, 0x4081)\n-\n-/* HP extensions.  See: ftp://ftp.hp.com/pub/lang/tools/WDB/wdb-4.0.tar.gz .  */\n-DW_TAG (DW_TAG_HP_array_descriptor, 0x4090)\n-DW_TAG (DW_TAG_HP_Bliss_field, 0x4091)\n-DW_TAG (DW_TAG_HP_Bliss_field_set, 0x4092)\n-\n-/* GNU extensions.  */\n-DW_TAG (DW_TAG_format_label, 0x4101)\t/* For FORTRAN 77 and Fortran 90.  */\n-DW_TAG (DW_TAG_function_template, 0x4102)\t/* For C++.  */\n-DW_TAG (DW_TAG_class_template, 0x4103)\t/* For C++.  */\n-DW_TAG (DW_TAG_GNU_BINCL, 0x4104)\n-DW_TAG (DW_TAG_GNU_EINCL, 0x4105)\n-/* Template template parameter.\n-   See http://gcc.gnu.org/wiki/TemplateParmsDwarf .  */\n-DW_TAG (DW_TAG_GNU_template_template_param, 0x4106)\n-\n-/* Template parameter pack extension, specified at\n-   http://wiki.dwarfstd.org/index.php?title=C%2B%2B0x:_Variadic_templates\n-   The values of these two TAGS are in the DW_TAG_GNU_* space until the tags\n-   are properly part of DWARF 5.  */\n-DW_TAG (DW_TAG_GNU_template_parameter_pack, 0x4107)\n-DW_TAG (DW_TAG_GNU_formal_parameter_pack, 0x4108)\n-/* The GNU call site extension, specified at\n-   http://www.dwarfstd.org/ShowIssue.php?issue=100909.2&type=open .\n-   The values of these two TAGS are in the DW_TAG_GNU_* space until the tags\n-   are properly part of DWARF 5.  */\n-DW_TAG (DW_TAG_GNU_call_site, 0x4109)\n-DW_TAG (DW_TAG_GNU_call_site_parameter, 0x410a)\n-/* Extensions for UPC.  See: http://dwarfstd.org/doc/DWARF4.pdf.  */\n-DW_TAG (DW_TAG_upc_shared_type, 0x8765)\n-DW_TAG (DW_TAG_upc_strict_type, 0x8766)\n-DW_TAG (DW_TAG_upc_relaxed_type, 0x8767)\n-/* PGI (STMicroelectronics) extensions.  No documentation available.  */\n-DW_TAG (DW_TAG_PGI_kanji_type, 0xA000)\n-DW_TAG (DW_TAG_PGI_interface_block, 0xA020)\n-DW_END_TAG\n-\n-DW_FIRST_FORM (DW_FORM_addr, 0x01)\n-DW_FORM (DW_FORM_block2, 0x03)\n-DW_FORM (DW_FORM_block4, 0x04)\n-DW_FORM (DW_FORM_data2, 0x05)\n-DW_FORM (DW_FORM_data4, 0x06)\n-DW_FORM (DW_FORM_data8, 0x07)\n-DW_FORM (DW_FORM_string, 0x08)\n-DW_FORM (DW_FORM_block, 0x09)\n-DW_FORM (DW_FORM_block1, 0x0a)\n-DW_FORM (DW_FORM_data1, 0x0b)\n-DW_FORM (DW_FORM_flag, 0x0c)\n-DW_FORM (DW_FORM_sdata, 0x0d)\n-DW_FORM (DW_FORM_strp, 0x0e)\n-DW_FORM (DW_FORM_udata, 0x0f)\n-DW_FORM (DW_FORM_ref_addr, 0x10)\n-DW_FORM (DW_FORM_ref1, 0x11)\n-DW_FORM (DW_FORM_ref2, 0x12)\n-DW_FORM (DW_FORM_ref4, 0x13)\n-DW_FORM (DW_FORM_ref8, 0x14)\n-DW_FORM (DW_FORM_ref_udata, 0x15)\n-DW_FORM (DW_FORM_indirect, 0x16)\n-/* DWARF 4.  */\n-DW_FORM (DW_FORM_sec_offset, 0x17)\n-DW_FORM (DW_FORM_exprloc, 0x18)\n-DW_FORM (DW_FORM_flag_present, 0x19)\n-DW_FORM (DW_FORM_ref_sig8, 0x20)\n-/* Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n-DW_FORM (DW_FORM_GNU_addr_index, 0x1f01)\n-DW_FORM (DW_FORM_GNU_str_index, 0x1f02)\n-/* Extensions for DWZ multifile.\n-   See http://www.dwarfstd.org/ShowIssue.php?issue=120604.1&type=open .  */\n-DW_FORM (DW_FORM_GNU_ref_alt, 0x1f20)\n-DW_FORM (DW_FORM_GNU_strp_alt, 0x1f21)\n-DW_END_FORM\n-\n-DW_FIRST_AT (DW_AT_sibling, 0x01)\n-DW_AT (DW_AT_location, 0x02)\n-DW_AT (DW_AT_name, 0x03)\n-DW_AT (DW_AT_ordering, 0x09)\n-DW_AT (DW_AT_subscr_data, 0x0a)\n-DW_AT (DW_AT_byte_size, 0x0b)\n-DW_AT (DW_AT_bit_offset, 0x0c)\n-DW_AT (DW_AT_bit_size, 0x0d)\n-DW_AT (DW_AT_element_list, 0x0f)\n-DW_AT (DW_AT_stmt_list, 0x10)\n-DW_AT (DW_AT_low_pc, 0x11)\n-DW_AT (DW_AT_high_pc, 0x12)\n-DW_AT (DW_AT_language, 0x13)\n-DW_AT (DW_AT_member, 0x14)\n-DW_AT (DW_AT_discr, 0x15)\n-DW_AT (DW_AT_discr_value, 0x16)\n-DW_AT (DW_AT_visibility, 0x17)\n-DW_AT (DW_AT_import, 0x18)\n-DW_AT (DW_AT_string_length, 0x19)\n-DW_AT (DW_AT_common_reference, 0x1a)\n-DW_AT (DW_AT_comp_dir, 0x1b)\n-DW_AT (DW_AT_const_value, 0x1c)\n-DW_AT (DW_AT_containing_type, 0x1d)\n-DW_AT (DW_AT_default_value, 0x1e)\n-DW_AT (DW_AT_inline, 0x20)\n-DW_AT (DW_AT_is_optional, 0x21)\n-DW_AT (DW_AT_lower_bound, 0x22)\n-DW_AT (DW_AT_producer, 0x25)\n-DW_AT (DW_AT_prototyped, 0x27)\n-DW_AT (DW_AT_return_addr, 0x2a)\n-DW_AT (DW_AT_start_scope, 0x2c)\n-DW_AT (DW_AT_bit_stride, 0x2e)\n-DW_AT (DW_AT_upper_bound, 0x2f)\n-DW_AT (DW_AT_abstract_origin, 0x31)\n-DW_AT (DW_AT_accessibility, 0x32)\n-DW_AT (DW_AT_address_class, 0x33)\n-DW_AT (DW_AT_artificial, 0x34)\n-DW_AT (DW_AT_base_types, 0x35)\n-DW_AT (DW_AT_calling_convention, 0x36)\n-DW_AT (DW_AT_count, 0x37)\n-DW_AT (DW_AT_data_member_location, 0x38)\n-DW_AT (DW_AT_decl_column, 0x39)\n-DW_AT (DW_AT_decl_file, 0x3a)\n-DW_AT (DW_AT_decl_line, 0x3b)\n-DW_AT (DW_AT_declaration, 0x3c)\n-DW_AT (DW_AT_discr_list, 0x3d)\n-DW_AT (DW_AT_encoding, 0x3e)\n-DW_AT (DW_AT_external, 0x3f)\n-DW_AT (DW_AT_frame_base, 0x40)\n-DW_AT (DW_AT_friend, 0x41)\n-DW_AT (DW_AT_identifier_case, 0x42)\n-DW_AT (DW_AT_macro_info, 0x43)\n-DW_AT (DW_AT_namelist_items, 0x44)\n-DW_AT (DW_AT_priority, 0x45)\n-DW_AT (DW_AT_segment, 0x46)\n-DW_AT (DW_AT_specification, 0x47)\n-DW_AT (DW_AT_static_link, 0x48)\n-DW_AT (DW_AT_type, 0x49)\n-DW_AT (DW_AT_use_location, 0x4a)\n-DW_AT (DW_AT_variable_parameter, 0x4b)\n-DW_AT (DW_AT_virtuality, 0x4c)\n-DW_AT (DW_AT_vtable_elem_location, 0x4d)\n-/* DWARF 3 values.  */\n-DW_AT (DW_AT_allocated, 0x4e)\n-DW_AT (DW_AT_associated, 0x4f)\n-DW_AT (DW_AT_data_location, 0x50)\n-DW_AT (DW_AT_byte_stride, 0x51)\n-DW_AT (DW_AT_entry_pc, 0x52)\n-DW_AT (DW_AT_use_UTF8, 0x53)\n-DW_AT (DW_AT_extension, 0x54)\n-DW_AT (DW_AT_ranges, 0x55)\n-DW_AT (DW_AT_trampoline, 0x56)\n-DW_AT (DW_AT_call_column, 0x57)\n-DW_AT (DW_AT_call_file, 0x58)\n-DW_AT (DW_AT_call_line, 0x59)\n-DW_AT (DW_AT_description, 0x5a)\n-DW_AT (DW_AT_binary_scale, 0x5b)\n-DW_AT (DW_AT_decimal_scale, 0x5c)\n-DW_AT (DW_AT_small, 0x5d)\n-DW_AT (DW_AT_decimal_sign, 0x5e)\n-DW_AT (DW_AT_digit_count, 0x5f)\n-DW_AT (DW_AT_picture_string, 0x60)\n-DW_AT (DW_AT_mutable, 0x61)\n-DW_AT (DW_AT_threads_scaled, 0x62)\n-DW_AT (DW_AT_explicit, 0x63)\n-DW_AT (DW_AT_object_pointer, 0x64)\n-DW_AT (DW_AT_endianity, 0x65)\n-DW_AT (DW_AT_elemental, 0x66)\n-DW_AT (DW_AT_pure, 0x67)\n-DW_AT (DW_AT_recursive, 0x68)\n-/* DWARF 4.  */\n-DW_AT (DW_AT_signature, 0x69)\n-DW_AT (DW_AT_main_subprogram, 0x6a)\n-DW_AT (DW_AT_data_bit_offset, 0x6b)\n-DW_AT (DW_AT_const_expr, 0x6c)\n-DW_AT (DW_AT_enum_class, 0x6d)\n-DW_AT (DW_AT_linkage_name, 0x6e)\n-/* DWARF 5.  */\n-DW_AT (DW_AT_noreturn, 0x87)\n-\n-DW_AT_DUP (DW_AT_lo_user, 0x2000) /* Implementation-defined range start.  */\n-DW_AT_DUP (DW_AT_hi_user, 0x3fff) /* Implementation-defined range end.  */\n-\n-/* SGI/MIPS extensions.  */\n-DW_AT (DW_AT_MIPS_fde, 0x2001)\n-DW_AT (DW_AT_MIPS_loop_begin, 0x2002)\n-DW_AT (DW_AT_MIPS_tail_loop_begin, 0x2003)\n-DW_AT (DW_AT_MIPS_epilog_begin, 0x2004)\n-DW_AT (DW_AT_MIPS_loop_unroll_factor, 0x2005)\n-DW_AT (DW_AT_MIPS_software_pipeline_depth, 0x2006)\n-DW_AT (DW_AT_MIPS_linkage_name, 0x2007)\n-DW_AT (DW_AT_MIPS_stride, 0x2008)\n-DW_AT (DW_AT_MIPS_abstract_name, 0x2009)\n-DW_AT (DW_AT_MIPS_clone_origin, 0x200a)\n-DW_AT (DW_AT_MIPS_has_inlines, 0x200b)\n-/* HP extensions.  */\n-DW_AT (DW_AT_HP_block_index, 0x2000)\n-DW_AT_DUP (DW_AT_HP_unmodifiable, 0x2001) /* Same as DW_AT_MIPS_fde.  */\n-DW_AT_DUP (DW_AT_HP_prologue, 0x2005) /* Same as DW_AT_MIPS_loop_unroll.  */\n-DW_AT_DUP (DW_AT_HP_epilogue, 0x2008) /* Same as DW_AT_MIPS_stride.  */\n-DW_AT (DW_AT_HP_actuals_stmt_list, 0x2010)\n-DW_AT (DW_AT_HP_proc_per_section, 0x2011)\n-DW_AT (DW_AT_HP_raw_data_ptr, 0x2012)\n-DW_AT (DW_AT_HP_pass_by_reference, 0x2013)\n-DW_AT (DW_AT_HP_opt_level, 0x2014)\n-DW_AT (DW_AT_HP_prof_version_id, 0x2015)\n-DW_AT (DW_AT_HP_opt_flags, 0x2016)\n-DW_AT (DW_AT_HP_cold_region_low_pc, 0x2017)\n-DW_AT (DW_AT_HP_cold_region_high_pc, 0x2018)\n-DW_AT (DW_AT_HP_all_variables_modifiable, 0x2019)\n-DW_AT (DW_AT_HP_linkage_name, 0x201a)\n-DW_AT (DW_AT_HP_prof_flags, 0x201b)  /* In comp unit of procs_info for -g.  */\n-DW_AT (DW_AT_HP_unit_name, 0x201f)\n-DW_AT (DW_AT_HP_unit_size, 0x2020)\n-DW_AT (DW_AT_HP_widened_byte_size, 0x2021)\n-DW_AT (DW_AT_HP_definition_points, 0x2022)\n-DW_AT (DW_AT_HP_default_location, 0x2023)\n-DW_AT (DW_AT_HP_is_result_param, 0x2029)\n-\n-/* GNU extensions.  */\n-DW_AT (DW_AT_sf_names, 0x2101)\n-DW_AT (DW_AT_src_info, 0x2102)\n-DW_AT (DW_AT_mac_info, 0x2103)\n-DW_AT (DW_AT_src_coords, 0x2104)\n-DW_AT (DW_AT_body_begin, 0x2105)\n-DW_AT (DW_AT_body_end, 0x2106)\n-DW_AT (DW_AT_GNU_vector, 0x2107)\n-/* Thread-safety annotations.\n-   See http://gcc.gnu.org/wiki/ThreadSafetyAnnotation .  */\n-DW_AT (DW_AT_GNU_guarded_by, 0x2108)\n-DW_AT (DW_AT_GNU_pt_guarded_by, 0x2109)\n-DW_AT (DW_AT_GNU_guarded, 0x210a)\n-DW_AT (DW_AT_GNU_pt_guarded, 0x210b)\n-DW_AT (DW_AT_GNU_locks_excluded, 0x210c)\n-DW_AT (DW_AT_GNU_exclusive_locks_required, 0x210d)\n-DW_AT (DW_AT_GNU_shared_locks_required, 0x210e)\n-/* One-definition rule violation detection.\n-   See http://gcc.gnu.org/wiki/DwarfSeparateTypeInfo .  */\n-DW_AT (DW_AT_GNU_odr_signature, 0x210f)\n-/* Template template argument name.\n-   See http://gcc.gnu.org/wiki/TemplateParmsDwarf .  */\n-DW_AT (DW_AT_GNU_template_name, 0x2110)\n-/* The GNU call site extension.\n-   See http://www.dwarfstd.org/ShowIssue.php?issue=100909.2&type=open .  */\n-DW_AT (DW_AT_GNU_call_site_value, 0x2111)\n-DW_AT (DW_AT_GNU_call_site_data_value, 0x2112)\n-DW_AT (DW_AT_GNU_call_site_target, 0x2113)\n-DW_AT (DW_AT_GNU_call_site_target_clobbered, 0x2114)\n-DW_AT (DW_AT_GNU_tail_call, 0x2115)\n-DW_AT (DW_AT_GNU_all_tail_call_sites, 0x2116)\n-DW_AT (DW_AT_GNU_all_call_sites, 0x2117)\n-DW_AT (DW_AT_GNU_all_source_call_sites, 0x2118)\n-/* Section offset into .debug_macro section.  */\n-DW_AT (DW_AT_GNU_macros, 0x2119)\n-/* Attribute for C++ deleted special member functions (= delete;).  */\n-DW_AT (DW_AT_GNU_deleted, 0x211a)\n-/* Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n-DW_AT (DW_AT_GNU_dwo_name, 0x2130)\n-DW_AT (DW_AT_GNU_dwo_id, 0x2131)\n-DW_AT (DW_AT_GNU_ranges_base, 0x2132)\n-DW_AT (DW_AT_GNU_addr_base, 0x2133)\n-DW_AT (DW_AT_GNU_pubnames, 0x2134)\n-DW_AT (DW_AT_GNU_pubtypes, 0x2135)\n-/* Attribute for discriminator.\n-   See http://gcc.gnu.org/wiki/Discriminator  */\n-DW_AT (DW_AT_GNU_discriminator, 0x2136)\n-/* VMS extensions.  */\n-DW_AT (DW_AT_VMS_rtnbeg_pd_address, 0x2201)\n-/* GNAT extensions.  */\n-/* GNAT descriptive type.\n-   See http://gcc.gnu.org/wiki/DW_AT_GNAT_descriptive_type .  */\n-DW_AT (DW_AT_use_GNAT_descriptive_type, 0x2301)\n-DW_AT (DW_AT_GNAT_descriptive_type, 0x2302)\n-/* Rational constant extension.\n-   See https://gcc.gnu.org/wiki/DW_AT_GNU_numerator_denominator .  */\n-DW_TAG (DW_AT_GNU_numerator, 0x2303)\n-DW_TAG (DW_AT_GNU_denominator, 0x2304)\n-/* Biased integer extension.\n-   See https://gcc.gnu.org/wiki/DW_AT_GNU_bias .  */\n-DW_TAG (DW_AT_GNU_bias, 0x2305)\n-/* UPC extension.  */\n-DW_AT (DW_AT_upc_threads_scaled, 0x3210)\n-/* PGI (STMicroelectronics) extensions.  */\n-DW_AT (DW_AT_PGI_lbase, 0x3a00)\n-DW_AT (DW_AT_PGI_soffset, 0x3a01)\n-DW_AT (DW_AT_PGI_lstride, 0x3a02)\n-/* Apple extensions.  */\n-DW_AT (DW_AT_APPLE_optimized, 0x3fe1)\n-DW_AT (DW_AT_APPLE_flags, 0x3fe2)\n-DW_AT (DW_AT_APPLE_isa, 0x3fe3)\n-DW_AT (DW_AT_APPLE_block, 0x3fe4)\n-DW_AT (DW_AT_APPLE_major_runtime_vers, 0x3fe5)\n-DW_AT (DW_AT_APPLE_runtime_class, 0x3fe6)\n-DW_AT (DW_AT_APPLE_omit_frame_ptr, 0x3fe7)\n-DW_AT (DW_AT_APPLE_property_name, 0x3fe8)\n-DW_AT (DW_AT_APPLE_property_getter, 0x3fe9)\n-DW_AT (DW_AT_APPLE_property_setter, 0x3fea)\n-DW_AT (DW_AT_APPLE_property_attribute, 0x3feb)\n-DW_AT (DW_AT_APPLE_objc_complete_type, 0x3fec)\n-DW_AT (DW_AT_APPLE_property, 0x3fed)\n-DW_END_AT\n-\n-DW_FIRST_OP (DW_OP_addr, 0x03)\n-DW_OP (DW_OP_deref, 0x06)\n-DW_OP (DW_OP_const1u, 0x08)\n-DW_OP (DW_OP_const1s, 0x09)\n-DW_OP (DW_OP_const2u, 0x0a)\n-DW_OP (DW_OP_const2s, 0x0b)\n-DW_OP (DW_OP_const4u, 0x0c)\n-DW_OP (DW_OP_const4s, 0x0d)\n-DW_OP (DW_OP_const8u, 0x0e)\n-DW_OP (DW_OP_const8s, 0x0f)\n-DW_OP (DW_OP_constu, 0x10)\n-DW_OP (DW_OP_consts, 0x11)\n-DW_OP (DW_OP_dup, 0x12)\n-DW_OP (DW_OP_drop, 0x13)\n-DW_OP (DW_OP_over, 0x14)\n-DW_OP (DW_OP_pick, 0x15)\n-DW_OP (DW_OP_swap, 0x16)\n-DW_OP (DW_OP_rot, 0x17)\n-DW_OP (DW_OP_xderef, 0x18)\n-DW_OP (DW_OP_abs, 0x19)\n-DW_OP (DW_OP_and, 0x1a)\n-DW_OP (DW_OP_div, 0x1b)\n-DW_OP (DW_OP_minus, 0x1c)\n-DW_OP (DW_OP_mod, 0x1d)\n-DW_OP (DW_OP_mul, 0x1e)\n-DW_OP (DW_OP_neg, 0x1f)\n-DW_OP (DW_OP_not, 0x20)\n-DW_OP (DW_OP_or, 0x21)\n-DW_OP (DW_OP_plus, 0x22)\n-DW_OP (DW_OP_plus_uconst, 0x23)\n-DW_OP (DW_OP_shl, 0x24)\n-DW_OP (DW_OP_shr, 0x25)\n-DW_OP (DW_OP_shra, 0x26)\n-DW_OP (DW_OP_xor, 0x27)\n-DW_OP (DW_OP_bra, 0x28)\n-DW_OP (DW_OP_eq, 0x29)\n-DW_OP (DW_OP_ge, 0x2a)\n-DW_OP (DW_OP_gt, 0x2b)\n-DW_OP (DW_OP_le, 0x2c)\n-DW_OP (DW_OP_lt, 0x2d)\n-DW_OP (DW_OP_ne, 0x2e)\n-DW_OP (DW_OP_skip, 0x2f)\n-DW_OP (DW_OP_lit0, 0x30)\n-DW_OP (DW_OP_lit1, 0x31)\n-DW_OP (DW_OP_lit2, 0x32)\n-DW_OP (DW_OP_lit3, 0x33)\n-DW_OP (DW_OP_lit4, 0x34)\n-DW_OP (DW_OP_lit5, 0x35)\n-DW_OP (DW_OP_lit6, 0x36)\n-DW_OP (DW_OP_lit7, 0x37)\n-DW_OP (DW_OP_lit8, 0x38)\n-DW_OP (DW_OP_lit9, 0x39)\n-DW_OP (DW_OP_lit10, 0x3a)\n-DW_OP (DW_OP_lit11, 0x3b)\n-DW_OP (DW_OP_lit12, 0x3c)\n-DW_OP (DW_OP_lit13, 0x3d)\n-DW_OP (DW_OP_lit14, 0x3e)\n-DW_OP (DW_OP_lit15, 0x3f)\n-DW_OP (DW_OP_lit16, 0x40)\n-DW_OP (DW_OP_lit17, 0x41)\n-DW_OP (DW_OP_lit18, 0x42)\n-DW_OP (DW_OP_lit19, 0x43)\n-DW_OP (DW_OP_lit20, 0x44)\n-DW_OP (DW_OP_lit21, 0x45)\n-DW_OP (DW_OP_lit22, 0x46)\n-DW_OP (DW_OP_lit23, 0x47)\n-DW_OP (DW_OP_lit24, 0x48)\n-DW_OP (DW_OP_lit25, 0x49)\n-DW_OP (DW_OP_lit26, 0x4a)\n-DW_OP (DW_OP_lit27, 0x4b)\n-DW_OP (DW_OP_lit28, 0x4c)\n-DW_OP (DW_OP_lit29, 0x4d)\n-DW_OP (DW_OP_lit30, 0x4e)\n-DW_OP (DW_OP_lit31, 0x4f)\n-DW_OP (DW_OP_reg0, 0x50)\n-DW_OP (DW_OP_reg1, 0x51)\n-DW_OP (DW_OP_reg2, 0x52)\n-DW_OP (DW_OP_reg3, 0x53)\n-DW_OP (DW_OP_reg4, 0x54)\n-DW_OP (DW_OP_reg5, 0x55)\n-DW_OP (DW_OP_reg6, 0x56)\n-DW_OP (DW_OP_reg7, 0x57)\n-DW_OP (DW_OP_reg8, 0x58)\n-DW_OP (DW_OP_reg9, 0x59)\n-DW_OP (DW_OP_reg10, 0x5a)\n-DW_OP (DW_OP_reg11, 0x5b)\n-DW_OP (DW_OP_reg12, 0x5c)\n-DW_OP (DW_OP_reg13, 0x5d)\n-DW_OP (DW_OP_reg14, 0x5e)\n-DW_OP (DW_OP_reg15, 0x5f)\n-DW_OP (DW_OP_reg16, 0x60)\n-DW_OP (DW_OP_reg17, 0x61)\n-DW_OP (DW_OP_reg18, 0x62)\n-DW_OP (DW_OP_reg19, 0x63)\n-DW_OP (DW_OP_reg20, 0x64)\n-DW_OP (DW_OP_reg21, 0x65)\n-DW_OP (DW_OP_reg22, 0x66)\n-DW_OP (DW_OP_reg23, 0x67)\n-DW_OP (DW_OP_reg24, 0x68)\n-DW_OP (DW_OP_reg25, 0x69)\n-DW_OP (DW_OP_reg26, 0x6a)\n-DW_OP (DW_OP_reg27, 0x6b)\n-DW_OP (DW_OP_reg28, 0x6c)\n-DW_OP (DW_OP_reg29, 0x6d)\n-DW_OP (DW_OP_reg30, 0x6e)\n-DW_OP (DW_OP_reg31, 0x6f)\n-DW_OP (DW_OP_breg0, 0x70)\n-DW_OP (DW_OP_breg1, 0x71)\n-DW_OP (DW_OP_breg2, 0x72)\n-DW_OP (DW_OP_breg3, 0x73)\n-DW_OP (DW_OP_breg4, 0x74)\n-DW_OP (DW_OP_breg5, 0x75)\n-DW_OP (DW_OP_breg6, 0x76)\n-DW_OP (DW_OP_breg7, 0x77)\n-DW_OP (DW_OP_breg8, 0x78)\n-DW_OP (DW_OP_breg9, 0x79)\n-DW_OP (DW_OP_breg10, 0x7a)\n-DW_OP (DW_OP_breg11, 0x7b)\n-DW_OP (DW_OP_breg12, 0x7c)\n-DW_OP (DW_OP_breg13, 0x7d)\n-DW_OP (DW_OP_breg14, 0x7e)\n-DW_OP (DW_OP_breg15, 0x7f)\n-DW_OP (DW_OP_breg16, 0x80)\n-DW_OP (DW_OP_breg17, 0x81)\n-DW_OP (DW_OP_breg18, 0x82)\n-DW_OP (DW_OP_breg19, 0x83)\n-DW_OP (DW_OP_breg20, 0x84)\n-DW_OP (DW_OP_breg21, 0x85)\n-DW_OP (DW_OP_breg22, 0x86)\n-DW_OP (DW_OP_breg23, 0x87)\n-DW_OP (DW_OP_breg24, 0x88)\n-DW_OP (DW_OP_breg25, 0x89)\n-DW_OP (DW_OP_breg26, 0x8a)\n-DW_OP (DW_OP_breg27, 0x8b)\n-DW_OP (DW_OP_breg28, 0x8c)\n-DW_OP (DW_OP_breg29, 0x8d)\n-DW_OP (DW_OP_breg30, 0x8e)\n-DW_OP (DW_OP_breg31, 0x8f)\n-DW_OP (DW_OP_regx, 0x90)\n-DW_OP (DW_OP_fbreg, 0x91)\n-DW_OP (DW_OP_bregx, 0x92)\n-DW_OP (DW_OP_piece, 0x93)\n-DW_OP (DW_OP_deref_size, 0x94)\n-DW_OP (DW_OP_xderef_size, 0x95)\n-DW_OP (DW_OP_nop, 0x96)\n-/* DWARF 3 extensions.  */\n-DW_OP (DW_OP_push_object_address, 0x97)\n-DW_OP (DW_OP_call2, 0x98)\n-DW_OP (DW_OP_call4, 0x99)\n-DW_OP (DW_OP_call_ref, 0x9a)\n-DW_OP (DW_OP_form_tls_address, 0x9b)\n-DW_OP (DW_OP_call_frame_cfa, 0x9c)\n-DW_OP (DW_OP_bit_piece, 0x9d)\n-\n-/* DWARF 4 extensions.  */\n-DW_OP (DW_OP_implicit_value, 0x9e)\n-DW_OP (DW_OP_stack_value, 0x9f)\n-\n-DW_OP_DUP (DW_OP_lo_user, 0xe0)\t/* Implementation-defined range start.  */\n-DW_OP_DUP (DW_OP_hi_user, 0xff)\t/* Implementation-defined range end.  */\n-\n-/* GNU extensions.  */\n-DW_OP (DW_OP_GNU_push_tls_address, 0xe0)\n-/* The following is for marking variables that are uninitialized.  */\n-DW_OP (DW_OP_GNU_uninit, 0xf0)\n-DW_OP (DW_OP_GNU_encoded_addr, 0xf1)\n-/* The GNU implicit pointer extension.\n-   See http://www.dwarfstd.org/ShowIssue.php?issue=100831.1&type=open .  */\n-DW_OP (DW_OP_GNU_implicit_pointer, 0xf2)\n-/* The GNU entry value extension.\n-   See http://www.dwarfstd.org/ShowIssue.php?issue=100909.1&type=open .  */\n-DW_OP (DW_OP_GNU_entry_value, 0xf3)\n-/* The GNU typed stack extension.\n-   See http://www.dwarfstd.org/doc/040408.1.html .  */\n-DW_OP (DW_OP_GNU_const_type, 0xf4)\n-DW_OP (DW_OP_GNU_regval_type, 0xf5)\n-DW_OP (DW_OP_GNU_deref_type, 0xf6)\n-DW_OP (DW_OP_GNU_convert, 0xf7)\n-DW_OP (DW_OP_GNU_reinterpret, 0xf9)\n-/* The GNU parameter ref extension.  */\n-DW_OP (DW_OP_GNU_parameter_ref, 0xfa)\n-/* Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n-DW_OP (DW_OP_GNU_addr_index, 0xfb)\n-DW_OP (DW_OP_GNU_const_index, 0xfc)\n-/* HP extensions.  */\n-DW_OP_DUP (DW_OP_HP_unknown, 0xe0) /* Ouch, the same as GNU_push_tls_address.  */\n-DW_OP (DW_OP_HP_is_value, 0xe1)\n-DW_OP (DW_OP_HP_fltconst4, 0xe2)\n-DW_OP (DW_OP_HP_fltconst8, 0xe3)\n-DW_OP (DW_OP_HP_mod_range, 0xe4)\n-DW_OP (DW_OP_HP_unmod_range, 0xe5)\n-DW_OP (DW_OP_HP_tls, 0xe6)\n-/* PGI (STMicroelectronics) extensions.  */\n-DW_OP (DW_OP_PGI_omp_thread_num, 0xf8)\n-DW_END_OP\n-\n-DW_FIRST_ATE (DW_ATE_void, 0x0)\n-DW_ATE (DW_ATE_address, 0x1)\n-DW_ATE (DW_ATE_boolean, 0x2)\n-DW_ATE (DW_ATE_complex_float, 0x3)\n-DW_ATE (DW_ATE_float, 0x4)\n-DW_ATE (DW_ATE_signed, 0x5)\n-DW_ATE (DW_ATE_signed_char, 0x6)\n-DW_ATE (DW_ATE_unsigned, 0x7)\n-DW_ATE (DW_ATE_unsigned_char, 0x8)\n-/* DWARF 3.  */\n-DW_ATE (DW_ATE_imaginary_float, 0x9)\n-DW_ATE (DW_ATE_packed_decimal, 0xa)\n-DW_ATE (DW_ATE_numeric_string, 0xb)\n-DW_ATE (DW_ATE_edited, 0xc)\n-DW_ATE (DW_ATE_signed_fixed, 0xd)\n-DW_ATE (DW_ATE_unsigned_fixed, 0xe)\n-DW_ATE (DW_ATE_decimal_float, 0xf)\n-/* DWARF 4.  */\n-DW_ATE (DW_ATE_UTF, 0x10)\n-\n-DW_ATE_DUP (DW_ATE_lo_user, 0x80)\n-DW_ATE_DUP (DW_ATE_hi_user, 0xff)\n-\n-/* HP extensions.  */\n-DW_ATE (DW_ATE_HP_float80, 0x80) /* Floating-point (80 bit).  */\n-DW_ATE (DW_ATE_HP_complex_float80, 0x81) /* Complex floating-point (80 bit).  */\n-DW_ATE (DW_ATE_HP_float128, 0x82) /* Floating-point (128 bit).  */\n-DW_ATE (DW_ATE_HP_complex_float128, 0x83) /* Complex fp (128 bit).  */\n-DW_ATE (DW_ATE_HP_floathpintel, 0x84) /* Floating-point (82 bit IA64).  */\n-DW_ATE (DW_ATE_HP_imaginary_float80, 0x85)\n-DW_ATE (DW_ATE_HP_imaginary_float128, 0x86)\n-DW_ATE (DW_ATE_HP_VAX_float, 0x88) /* F or G floating.  */\n-DW_ATE (DW_ATE_HP_VAX_float_d, 0x89) /* D floating.  */\n-DW_ATE (DW_ATE_HP_packed_decimal, 0x8a) /* Cobol.  */\n-DW_ATE (DW_ATE_HP_zoned_decimal, 0x8b) /* Cobol.  */\n-DW_ATE (DW_ATE_HP_edited, 0x8c) /* Cobol.  */\n-DW_ATE (DW_ATE_HP_signed_fixed, 0x8d) /* Cobol.  */\n-DW_ATE (DW_ATE_HP_unsigned_fixed, 0x8e) /* Cobol.  */\n-DW_ATE (DW_ATE_HP_VAX_complex_float, 0x8f) /* F or G floating complex.  */\n-DW_ATE (DW_ATE_HP_VAX_complex_float_d, 0x90) /* D floating complex.  */\n-\n-DW_END_ATE\n-\n-DW_FIRST_CFA (DW_CFA_advance_loc, 0x40)\n-DW_CFA (DW_CFA_offset, 0x80)\n-DW_CFA (DW_CFA_restore, 0xc0)\n-DW_CFA (DW_CFA_nop, 0x00)\n-DW_CFA (DW_CFA_set_loc, 0x01)\n-DW_CFA (DW_CFA_advance_loc1, 0x02)\n-DW_CFA (DW_CFA_advance_loc2, 0x03)\n-DW_CFA (DW_CFA_advance_loc4, 0x04)\n-DW_CFA (DW_CFA_offset_extended, 0x05)\n-DW_CFA (DW_CFA_restore_extended, 0x06)\n-DW_CFA (DW_CFA_undefined, 0x07)\n-DW_CFA (DW_CFA_same_value, 0x08)\n-DW_CFA (DW_CFA_register, 0x09)\n-DW_CFA (DW_CFA_remember_state, 0x0a)\n-DW_CFA (DW_CFA_restore_state, 0x0b)\n-DW_CFA (DW_CFA_def_cfa, 0x0c)\n-DW_CFA (DW_CFA_def_cfa_register, 0x0d)\n-DW_CFA (DW_CFA_def_cfa_offset, 0x0e)\n-/* DWARF 3.  */\n-DW_CFA (DW_CFA_def_cfa_expression, 0x0f)\n-DW_CFA (DW_CFA_expression, 0x10)\n-DW_CFA (DW_CFA_offset_extended_sf, 0x11)\n-DW_CFA (DW_CFA_def_cfa_sf, 0x12)\n-DW_CFA (DW_CFA_def_cfa_offset_sf, 0x13)\n-DW_CFA (DW_CFA_val_offset, 0x14)\n-DW_CFA (DW_CFA_val_offset_sf, 0x15)\n-DW_CFA (DW_CFA_val_expression, 0x16)\n-\n-DW_CFA (DW_CFA_lo_user, 0x1c)\n-DW_CFA (DW_CFA_hi_user, 0x3f)\n-\n-/* SGI/MIPS specific.  */\n-DW_CFA (DW_CFA_MIPS_advance_loc8, 0x1d)\n-/* GNU extensions.  */\n-DW_CFA (DW_CFA_GNU_window_save, 0x2d)\n-DW_CFA (DW_CFA_GNU_args_size, 0x2e)\n-DW_CFA (DW_CFA_GNU_negative_offset_extended, 0x2f)\n-\n-DW_END_CFA"}, {"sha": "4ada87162fa868eb80c6994e1877c6d9897ae732", "filename": "src/libbacktrace/dwarf2.h", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fdwarf2.h", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.h?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,430 +0,0 @@\n-/* Declarations and definitions of codes relating to the DWARF2 and\n-   DWARF3 symbolic debugging information formats.\n-   Copyright (C) 1992-2015 Free Software Foundation, Inc.\n-\n-   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program\n-   Office (AJPO), Florida State University and Silicon Graphics Inc.\n-   provided support for this effort -- June 21, 1995.\n-\n-   Derived from the DWARF 1 implementation written by Ron Guilmette\n-   (rfg@netcom.com), November 1990.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it under\n-   the terms of the GNU General Public License as published by the Free\n-   Software Foundation; either version 3, or (at your option) any later\n-   version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* This file is derived from the DWARF specification (a public document)\n-   Revision 2.0.0 (July 27, 1993) developed by the UNIX International\n-   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n-   by UNIX International.  Copies of this specification are available from\n-   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n-\n-   This file also now contains definitions from the DWARF 3 specification\n-   published Dec 20, 2005, available from: http://dwarf.freestandards.org.  */\n-\n-#ifndef _DWARF2_H\n-#define _DWARF2_H\n-\n-#define DW_TAG(name, value) , name = value\n-#define DW_TAG_DUP(name, value) , name = value\n-#define DW_FORM(name, value) , name = value\n-#define DW_AT(name, value) , name = value\n-#define DW_AT_DUP(name, value) , name = value\n-#define DW_OP(name, value) , name = value\n-#define DW_OP_DUP(name, value) , name = value\n-#define DW_ATE(name, value) , name = value\n-#define DW_ATE_DUP(name, value) , name = value\n-#define DW_CFA(name, value) , name = value\n-\n-#define DW_FIRST_TAG(name, value) enum dwarf_tag { \\\n-  name = value\n-#define DW_END_TAG };\n-#define DW_FIRST_FORM(name, value) enum dwarf_form { \\\n-  name = value\n-#define DW_END_FORM };\n-#define DW_FIRST_AT(name, value) enum dwarf_attribute { \\\n-  name = value\n-#define DW_END_AT };\n-#define DW_FIRST_OP(name, value) enum dwarf_location_atom { \\\n-  name = value\n-#define DW_END_OP };\n-#define DW_FIRST_ATE(name, value) enum dwarf_type { \\\n-  name = value\n-#define DW_END_ATE };\n-#define DW_FIRST_CFA(name, value) enum dwarf_call_frame_info { \\\n-  name = value\n-#define DW_END_CFA };\n-\n-#include \"dwarf2.def\"\n-\n-#undef DW_FIRST_TAG\n-#undef DW_END_TAG\n-#undef DW_FIRST_FORM\n-#undef DW_END_FORM\n-#undef DW_FIRST_AT\n-#undef DW_END_AT\n-#undef DW_FIRST_OP\n-#undef DW_END_OP\n-#undef DW_FIRST_ATE\n-#undef DW_END_ATE\n-#undef DW_FIRST_CFA\n-#undef DW_END_CFA\n-\n-#undef DW_TAG\n-#undef DW_TAG_DUP\n-#undef DW_FORM\n-#undef DW_AT\n-#undef DW_AT_DUP\n-#undef DW_OP\n-#undef DW_OP_DUP\n-#undef DW_ATE\n-#undef DW_ATE_DUP\n-#undef DW_CFA\n-\n-/* Flag that tells whether entry has a child or not.  */\n-#define DW_children_no   0\n-#define\tDW_children_yes  1\n-\n-#define DW_AT_stride_size   DW_AT_bit_stride  /* Note: The use of DW_AT_stride_size is deprecated.  */\n-#define DW_AT_stride   DW_AT_byte_stride  /* Note: The use of DW_AT_stride is deprecated.  */\n-\n-/* Decimal sign encodings.  */\n-enum dwarf_decimal_sign_encoding\n-  {\n-    /* DWARF 3.  */\n-    DW_DS_unsigned = 0x01,\n-    DW_DS_leading_overpunch = 0x02,\n-    DW_DS_trailing_overpunch = 0x03,\n-    DW_DS_leading_separate = 0x04,\n-    DW_DS_trailing_separate = 0x05\n-  };\n-\n-/* Endianity encodings.  */\n-enum dwarf_endianity_encoding\n-  {\n-    /* DWARF 3.  */\n-    DW_END_default = 0x00,\n-    DW_END_big = 0x01,\n-    DW_END_little = 0x02,\n-\n-    DW_END_lo_user = 0x40,\n-    DW_END_hi_user = 0xff\n-  };\n-\n-/* Array ordering names and codes.  */\n-enum dwarf_array_dim_ordering\n-  {\n-    DW_ORD_row_major = 0,\n-    DW_ORD_col_major = 1\n-  };\n-\n-/* Access attribute.  */\n-enum dwarf_access_attribute\n-  {\n-    DW_ACCESS_public = 1,\n-    DW_ACCESS_protected = 2,\n-    DW_ACCESS_private = 3\n-  };\n-\n-/* Visibility.  */\n-enum dwarf_visibility_attribute\n-  {\n-    DW_VIS_local = 1,\n-    DW_VIS_exported = 2,\n-    DW_VIS_qualified = 3\n-  };\n-\n-/* Virtuality.  */\n-enum dwarf_virtuality_attribute\n-  {\n-    DW_VIRTUALITY_none = 0,\n-    DW_VIRTUALITY_virtual = 1,\n-    DW_VIRTUALITY_pure_virtual = 2\n-  };\n-\n-/* Case sensitivity.  */\n-enum dwarf_id_case\n-  {\n-    DW_ID_case_sensitive = 0,\n-    DW_ID_up_case = 1,\n-    DW_ID_down_case = 2,\n-    DW_ID_case_insensitive = 3\n-  };\n-\n-/* Calling convention.  */\n-enum dwarf_calling_convention\n-  {\n-    DW_CC_normal = 0x1,\n-    DW_CC_program = 0x2,\n-    DW_CC_nocall = 0x3,\n-\n-    DW_CC_lo_user = 0x40,\n-    DW_CC_hi_user = 0xff,\n-\n-    DW_CC_GNU_renesas_sh = 0x40,\n-    DW_CC_GNU_borland_fastcall_i386 = 0x41,\n-\n-    /* This DW_CC_ value is not currently generated by any toolchain.  It is\n-       used internally to GDB to indicate OpenCL C functions that have been\n-       compiled with the IBM XL C for OpenCL compiler and use a non-platform\n-       calling convention for passing OpenCL C vector types.  This value may\n-       be changed freely as long as it does not conflict with any other DW_CC_\n-       value defined here.  */\n-    DW_CC_GDB_IBM_OpenCL = 0xff\n-  };\n-\n-/* Inline attribute.  */\n-enum dwarf_inline_attribute\n-  {\n-    DW_INL_not_inlined = 0,\n-    DW_INL_inlined = 1,\n-    DW_INL_declared_not_inlined = 2,\n-    DW_INL_declared_inlined = 3\n-  };\n-\n-/* Discriminant lists.  */\n-enum dwarf_discrim_list\n-  {\n-    DW_DSC_label = 0,\n-    DW_DSC_range = 1\n-  };\n-\n-/* Line number opcodes.  */\n-enum dwarf_line_number_ops\n-  {\n-    DW_LNS_extended_op = 0,\n-    DW_LNS_copy = 1,\n-    DW_LNS_advance_pc = 2,\n-    DW_LNS_advance_line = 3,\n-    DW_LNS_set_file = 4,\n-    DW_LNS_set_column = 5,\n-    DW_LNS_negate_stmt = 6,\n-    DW_LNS_set_basic_block = 7,\n-    DW_LNS_const_add_pc = 8,\n-    DW_LNS_fixed_advance_pc = 9,\n-    /* DWARF 3.  */\n-    DW_LNS_set_prologue_end = 10,\n-    DW_LNS_set_epilogue_begin = 11,\n-    DW_LNS_set_isa = 12\n-  };\n-\n-/* Line number extended opcodes.  */\n-enum dwarf_line_number_x_ops\n-  {\n-    DW_LNE_end_sequence = 1,\n-    DW_LNE_set_address = 2,\n-    DW_LNE_define_file = 3,\n-    DW_LNE_set_discriminator = 4,\n-    /* HP extensions.  */\n-    DW_LNE_HP_negate_is_UV_update      = 0x11,\n-    DW_LNE_HP_push_context             = 0x12,\n-    DW_LNE_HP_pop_context              = 0x13,\n-    DW_LNE_HP_set_file_line_column     = 0x14,\n-    DW_LNE_HP_set_routine_name         = 0x15,\n-    DW_LNE_HP_set_sequence             = 0x16,\n-    DW_LNE_HP_negate_post_semantics    = 0x17,\n-    DW_LNE_HP_negate_function_exit     = 0x18,\n-    DW_LNE_HP_negate_front_end_logical = 0x19,\n-    DW_LNE_HP_define_proc              = 0x20,\n-    DW_LNE_HP_source_file_correlation  = 0x80,\n-\n-    DW_LNE_lo_user = 0x80,\n-    DW_LNE_hi_user = 0xff\n-  };\n-\n-/* Sub-opcodes for DW_LNE_HP_source_file_correlation.  */\n-enum dwarf_line_number_hp_sfc_ops\n-  {\n-    DW_LNE_HP_SFC_formfeed = 1,\n-    DW_LNE_HP_SFC_set_listing_line = 2,\n-    DW_LNE_HP_SFC_associate = 3\n-  };\n-\n-/* Type codes for location list entries.\n-   Extension for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n-\n-enum dwarf_location_list_entry_type\n-  {\n-    DW_LLE_GNU_end_of_list_entry = 0,\n-    DW_LLE_GNU_base_address_selection_entry = 1,\n-    DW_LLE_GNU_start_end_entry = 2,\n-    DW_LLE_GNU_start_length_entry = 3\n-  };\n-\n-#define DW_CIE_ID\t  0xffffffff\n-#define DW64_CIE_ID\t  0xffffffffffffffffULL\n-#define DW_CIE_VERSION\t  1\n-\n-#define DW_CFA_extended   0\n-\n-#define DW_CHILDREN_no\t\t     0x00\n-#define DW_CHILDREN_yes\t\t     0x01\n-\n-#define DW_ADDR_none\t\t0\n-\n-/* Source language names and codes.  */\n-enum dwarf_source_language\n-  {\n-    DW_LANG_C89 = 0x0001,\n-    DW_LANG_C = 0x0002,\n-    DW_LANG_Ada83 = 0x0003,\n-    DW_LANG_C_plus_plus = 0x0004,\n-    DW_LANG_Cobol74 = 0x0005,\n-    DW_LANG_Cobol85 = 0x0006,\n-    DW_LANG_Fortran77 = 0x0007,\n-    DW_LANG_Fortran90 = 0x0008,\n-    DW_LANG_Pascal83 = 0x0009,\n-    DW_LANG_Modula2 = 0x000a,\n-    /* DWARF 3.  */\n-    DW_LANG_Java = 0x000b,\n-    DW_LANG_C99 = 0x000c,\n-    DW_LANG_Ada95 = 0x000d,\n-    DW_LANG_Fortran95 = 0x000e,\n-    DW_LANG_PLI = 0x000f,\n-    DW_LANG_ObjC = 0x0010,\n-    DW_LANG_ObjC_plus_plus = 0x0011,\n-    DW_LANG_UPC = 0x0012,\n-    DW_LANG_D = 0x0013,\n-    /* DWARF 4.  */\n-    DW_LANG_Python = 0x0014,\n-    /* DWARF 5.  */\n-    DW_LANG_Go = 0x0016,\n-\n-    DW_LANG_C_plus_plus_11 = 0x001a, /* dwarf5.20141029.pdf DRAFT */\n-    DW_LANG_C11 = 0x001d,\n-    DW_LANG_C_plus_plus_14 = 0x0021,\n-    DW_LANG_Fortran03 = 0x0022,\n-    DW_LANG_Fortran08 = 0x0023,\n-\n-    DW_LANG_lo_user = 0x8000,\t/* Implementation-defined range start.  */\n-    DW_LANG_hi_user = 0xffff,\t/* Implementation-defined range start.  */\n-\n-    /* MIPS.  */\n-    DW_LANG_Mips_Assembler = 0x8001,\n-    /* UPC.  */\n-    DW_LANG_Upc = 0x8765,\n-    /* HP extensions.  */\n-    DW_LANG_HP_Bliss     = 0x8003,\n-    DW_LANG_HP_Basic91   = 0x8004,\n-    DW_LANG_HP_Pascal91  = 0x8005,\n-    DW_LANG_HP_IMacro    = 0x8006,\n-    DW_LANG_HP_Assembler = 0x8007\n-  };\n-\n-/* Names and codes for macro information.  */\n-enum dwarf_macinfo_record_type\n-  {\n-    DW_MACINFO_define = 1,\n-    DW_MACINFO_undef = 2,\n-    DW_MACINFO_start_file = 3,\n-    DW_MACINFO_end_file = 4,\n-    DW_MACINFO_vendor_ext = 255\n-  };\n-\n-/* Names and codes for new style macro information.  */\n-enum dwarf_macro_record_type\n-  {\n-    DW_MACRO_GNU_define = 1,\n-    DW_MACRO_GNU_undef = 2,\n-    DW_MACRO_GNU_start_file = 3,\n-    DW_MACRO_GNU_end_file = 4,\n-    DW_MACRO_GNU_define_indirect = 5,\n-    DW_MACRO_GNU_undef_indirect = 6,\n-    DW_MACRO_GNU_transparent_include = 7,\n-    /* Extensions for DWZ multifile.\n-       See http://www.dwarfstd.org/ShowIssue.php?issue=120604.1&type=open .  */\n-    DW_MACRO_GNU_define_indirect_alt = 8,\n-    DW_MACRO_GNU_undef_indirect_alt = 9,\n-    DW_MACRO_GNU_transparent_include_alt = 10,\n-    DW_MACRO_GNU_lo_user = 0xe0,\n-    DW_MACRO_GNU_hi_user = 0xff\n-  };\n-\f\n-/* @@@ For use with GNU frame unwind information.  */\n-\n-#define DW_EH_PE_absptr\t\t0x00\n-#define DW_EH_PE_omit\t\t0xff\n-\n-#define DW_EH_PE_uleb128\t0x01\n-#define DW_EH_PE_udata2\t\t0x02\n-#define DW_EH_PE_udata4\t\t0x03\n-#define DW_EH_PE_udata8\t\t0x04\n-#define DW_EH_PE_sleb128\t0x09\n-#define DW_EH_PE_sdata2\t\t0x0A\n-#define DW_EH_PE_sdata4\t\t0x0B\n-#define DW_EH_PE_sdata8\t\t0x0C\n-#define DW_EH_PE_signed\t\t0x08\n-\n-#define DW_EH_PE_pcrel\t\t0x10\n-#define DW_EH_PE_textrel\t0x20\n-#define DW_EH_PE_datarel\t0x30\n-#define DW_EH_PE_funcrel\t0x40\n-#define DW_EH_PE_aligned\t0x50\n-\n-#define DW_EH_PE_indirect\t0x80\n-\n-/* Codes for the debug sections in a dwarf package (.dwp) file.\n-   Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFissionDWP.  */\n-enum dwarf_sect\n-  {\n-    DW_SECT_INFO = 1,\n-    DW_SECT_TYPES = 2,\n-    DW_SECT_ABBREV = 3,\n-    DW_SECT_LINE = 4,\n-    DW_SECT_LOC = 5,\n-    DW_SECT_STR_OFFSETS = 6,\n-    DW_SECT_MACINFO = 7,\n-    DW_SECT_MACRO = 8,\n-    DW_SECT_MAX = 8\n-  };\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif /* __cplusplus */\n-\n-/* Return the name of a DW_TAG_ constant, or NULL if the value is not\n-   recognized.  */\n-extern const char *get_DW_TAG_name (unsigned int tag);\n-\n-/* Return the name of a DW_AT_ constant, or NULL if the value is not\n-   recognized.  */\n-extern const char *get_DW_AT_name (unsigned int attr);\n-\n-/* Return the name of a DW_FORM_ constant, or NULL if the value is not\n-   recognized.  */\n-extern const char *get_DW_FORM_name (unsigned int form);\n-\n-/* Return the name of a DW_OP_ constant, or NULL if the value is not\n-   recognized.  */\n-extern const char *get_DW_OP_name (unsigned int op);\n-\n-/* Return the name of a DW_ATE_ constant, or NULL if the value is not\n-   recognized.  */\n-extern const char *get_DW_ATE_name (unsigned int enc);\n-\n-/* Return the name of a DW_CFA_ constant, or NULL if the value is not\n-   recognized.  */\n-extern const char *get_DW_CFA_name (unsigned int opc);\n-\n-#ifdef __cplusplus\n-}\n-#endif /* __cplusplus */\n-\n-#endif /* _DWARF2_H */"}, {"sha": "81ba3440ab7d18539180f53805ac36c408284a66", "filename": "src/libbacktrace/elf.c", "status": "removed", "additions": 0, "deletions": 979, "changes": 979, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Felf.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Felf.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,979 +0,0 @@\n-/* elf.c -- Get debug data from an ELF file for backtraces.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys/types.h>\n-\n-#ifdef HAVE_DL_ITERATE_PHDR\n-#include <link.h>\n-#endif\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-#ifndef HAVE_DL_ITERATE_PHDR\n-\n-/* Dummy version of dl_iterate_phdr for systems that don't have it.  */\n-\n-#define dl_phdr_info x_dl_phdr_info\n-#define dl_iterate_phdr x_dl_iterate_phdr\n-\n-struct dl_phdr_info\n-{\n-  uintptr_t dlpi_addr;\n-  const char *dlpi_name;\n-};\n-\n-static int\n-dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n-\t\t\t\t  size_t, void *) ATTRIBUTE_UNUSED,\n-\t\t void *data ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n-\n-#endif /* ! defined (HAVE_DL_ITERATE_PHDR) */\n-\n-/* The configure script must tell us whether we are 32-bit or 64-bit\n-   ELF.  We could make this code test and support either possibility,\n-   but there is no point.  This code only works for the currently\n-   running executable, which means that we know the ELF mode at\n-   configure mode.  */\n-\n-#if BACKTRACE_ELF_SIZE != 32 && BACKTRACE_ELF_SIZE != 64\n-#error \"Unknown BACKTRACE_ELF_SIZE\"\n-#endif\n-\n-/* <link.h> might #include <elf.h> which might define our constants\n-   with slightly different values.  Undefine them to be safe.  */\n-\n-#undef EI_NIDENT\n-#undef EI_MAG0\n-#undef EI_MAG1\n-#undef EI_MAG2\n-#undef EI_MAG3\n-#undef EI_CLASS\n-#undef EI_DATA\n-#undef EI_VERSION\n-#undef ELF_MAG0\n-#undef ELF_MAG1\n-#undef ELF_MAG2\n-#undef ELF_MAG3\n-#undef ELFCLASS32\n-#undef ELFCLASS64\n-#undef ELFDATA2LSB\n-#undef ELFDATA2MSB\n-#undef EV_CURRENT\n-#undef ET_DYN\n-#undef SHN_LORESERVE\n-#undef SHN_XINDEX\n-#undef SHN_UNDEF\n-#undef SHT_SYMTAB\n-#undef SHT_STRTAB\n-#undef SHT_DYNSYM\n-#undef STT_OBJECT\n-#undef STT_FUNC\n-\n-/* Basic types.  */\n-\n-typedef uint16_t b_elf_half;    /* Elf_Half.  */\n-typedef uint32_t b_elf_word;    /* Elf_Word.  */\n-typedef int32_t  b_elf_sword;   /* Elf_Sword.  */\n-\n-#if BACKTRACE_ELF_SIZE == 32\n-\n-typedef uint32_t b_elf_addr;    /* Elf_Addr.  */\n-typedef uint32_t b_elf_off;     /* Elf_Off.  */\n-\n-typedef uint32_t b_elf_wxword;  /* 32-bit Elf_Word, 64-bit ELF_Xword.  */\n-\n-#else\n-\n-typedef uint64_t b_elf_addr;    /* Elf_Addr.  */\n-typedef uint64_t b_elf_off;     /* Elf_Off.  */\n-typedef uint64_t b_elf_xword;   /* Elf_Xword.  */\n-typedef int64_t  b_elf_sxword;  /* Elf_Sxword.  */\n-\n-typedef uint64_t b_elf_wxword;  /* 32-bit Elf_Word, 64-bit ELF_Xword.  */\n-\n-#endif\n-\n-/* Data structures and associated constants.  */\n-\n-#define EI_NIDENT 16\n-\n-typedef struct {\n-  unsigned char\te_ident[EI_NIDENT];\t/* ELF \"magic number\" */\n-  b_elf_half\te_type;\t\t\t/* Identifies object file type */\n-  b_elf_half\te_machine;\t\t/* Specifies required architecture */\n-  b_elf_word\te_version;\t\t/* Identifies object file version */\n-  b_elf_addr\te_entry;\t\t/* Entry point virtual address */\n-  b_elf_off\te_phoff;\t\t/* Program header table file offset */\n-  b_elf_off\te_shoff;\t\t/* Section header table file offset */\n-  b_elf_word\te_flags;\t\t/* Processor-specific flags */\n-  b_elf_half\te_ehsize;\t\t/* ELF header size in bytes */\n-  b_elf_half\te_phentsize;\t\t/* Program header table entry size */\n-  b_elf_half\te_phnum;\t\t/* Program header table entry count */\n-  b_elf_half\te_shentsize;\t\t/* Section header table entry size */\n-  b_elf_half\te_shnum;\t\t/* Section header table entry count */\n-  b_elf_half\te_shstrndx;\t\t/* Section header string table index */\n-} b_elf_ehdr;  /* Elf_Ehdr.  */\n-\n-#define EI_MAG0 0\n-#define EI_MAG1 1\n-#define EI_MAG2 2\n-#define EI_MAG3 3\n-#define EI_CLASS 4\n-#define EI_DATA 5\n-#define EI_VERSION 6\n-\n-#define ELFMAG0 0x7f\n-#define ELFMAG1 'E'\n-#define ELFMAG2 'L'\n-#define ELFMAG3 'F'\n-\n-#define ELFCLASS32 1\n-#define ELFCLASS64 2\n-\n-#define ELFDATA2LSB 1\n-#define ELFDATA2MSB 2\n-\n-#define EV_CURRENT 1\n-\n-#define ET_DYN 3\n-\n-typedef struct {\n-  b_elf_word\tsh_name;\t\t/* Section name, index in string tbl */\n-  b_elf_word\tsh_type;\t\t/* Type of section */\n-  b_elf_wxword\tsh_flags;\t\t/* Miscellaneous section attributes */\n-  b_elf_addr\tsh_addr;\t\t/* Section virtual addr at execution */\n-  b_elf_off\tsh_offset;\t\t/* Section file offset */\n-  b_elf_wxword\tsh_size;\t\t/* Size of section in bytes */\n-  b_elf_word\tsh_link;\t\t/* Index of another section */\n-  b_elf_word\tsh_info;\t\t/* Additional section information */\n-  b_elf_wxword\tsh_addralign;\t\t/* Section alignment */\n-  b_elf_wxword\tsh_entsize;\t\t/* Entry size if section holds table */\n-} b_elf_shdr;  /* Elf_Shdr.  */\n-\n-#define SHN_UNDEF\t0x0000\t\t/* Undefined section */\n-#define SHN_LORESERVE\t0xFF00\t\t/* Begin range of reserved indices */\n-#define SHN_XINDEX\t0xFFFF\t\t/* Section index is held elsewhere */\n-\n-#define SHT_SYMTAB 2\n-#define SHT_STRTAB 3\n-#define SHT_DYNSYM 11\n-\n-#if BACKTRACE_ELF_SIZE == 32\n-\n-typedef struct\n-{\n-  b_elf_word\tst_name;\t\t/* Symbol name, index in string tbl */\n-  b_elf_addr\tst_value;\t\t/* Symbol value */\n-  b_elf_word\tst_size;\t\t/* Symbol size */\n-  unsigned char\tst_info;\t\t/* Symbol binding and type */\n-  unsigned char\tst_other;\t\t/* Visibility and other data */\n-  b_elf_half\tst_shndx;\t\t/* Symbol section index */\n-} b_elf_sym;  /* Elf_Sym.  */\n-\n-#else /* BACKTRACE_ELF_SIZE != 32 */\n-\n-typedef struct\n-{\n-  b_elf_word\tst_name;\t\t/* Symbol name, index in string tbl */\n-  unsigned char\tst_info;\t\t/* Symbol binding and type */\n-  unsigned char\tst_other;\t\t/* Visibility and other data */\n-  b_elf_half\tst_shndx;\t\t/* Symbol section index */\n-  b_elf_addr\tst_value;\t\t/* Symbol value */\n-  b_elf_xword\tst_size;\t\t/* Symbol size */\n-} b_elf_sym;  /* Elf_Sym.  */\n-\n-#endif /* BACKTRACE_ELF_SIZE != 32 */\n-\n-#define STT_OBJECT 1\n-#define STT_FUNC 2\n-\n-/* An index of ELF sections we care about.  */\n-\n-enum debug_section\n-{\n-  DEBUG_INFO,\n-  DEBUG_LINE,\n-  DEBUG_ABBREV,\n-  DEBUG_RANGES,\n-  DEBUG_STR,\n-  DEBUG_MAX\n-};\n-\n-/* Names of sections, indexed by enum elf_section.  */\n-\n-static const char * const debug_section_names[DEBUG_MAX] =\n-{\n-  \".debug_info\",\n-  \".debug_line\",\n-  \".debug_abbrev\",\n-  \".debug_ranges\",\n-  \".debug_str\"\n-};\n-\n-/* Information we gather for the sections we care about.  */\n-\n-struct debug_section_info\n-{\n-  /* Section file offset.  */\n-  off_t offset;\n-  /* Section size.  */\n-  size_t size;\n-  /* Section contents, after read from file.  */\n-  const unsigned char *data;\n-};\n-\n-/* Information we keep for an ELF symbol.  */\n-\n-struct elf_symbol\n-{\n-  /* The name of the symbol.  */\n-  const char *name;\n-  /* The address of the symbol.  */\n-  uintptr_t address;\n-  /* The size of the symbol.  */\n-  size_t size;\n-};\n-\n-/* Information to pass to elf_syminfo.  */\n-\n-struct elf_syminfo_data\n-{\n-  /* Symbols for the next module.  */\n-  struct elf_syminfo_data *next;\n-  /* The ELF symbols, sorted by address.  */\n-  struct elf_symbol *symbols;\n-  /* The number of symbols.  */\n-  size_t count;\n-};\n-\n-/* A dummy callback function used when we can't find any debug info.  */\n-\n-static int\n-elf_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t     uintptr_t pc ATTRIBUTE_UNUSED,\n-\t     backtrace_full_callback callback ATTRIBUTE_UNUSED,\n-\t     backtrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data, \"no debug info in ELF executable\", -1);\n-  return 0;\n-}\n-\n-/* A dummy callback function used when we can't find a symbol\n-   table.  */\n-\n-static void\n-elf_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t    uintptr_t addr ATTRIBUTE_UNUSED,\n-\t    backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n-\t    backtrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data, \"no symbol table in ELF executable\", -1);\n-}\n-\n-/* Compare struct elf_symbol for qsort.  */\n-\n-static int\n-elf_symbol_compare (const void *v1, const void *v2)\n-{\n-  const struct elf_symbol *e1 = (const struct elf_symbol *) v1;\n-  const struct elf_symbol *e2 = (const struct elf_symbol *) v2;\n-\n-  if (e1->address < e2->address)\n-    return -1;\n-  else if (e1->address > e2->address)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Compare an ADDR against an elf_symbol for bsearch.  We allocate one\n-   extra entry in the array so that this can look safely at the next\n-   entry.  */\n-\n-static int\n-elf_symbol_search (const void *vkey, const void *ventry)\n-{\n-  const uintptr_t *key = (const uintptr_t *) vkey;\n-  const struct elf_symbol *entry = (const struct elf_symbol *) ventry;\n-  uintptr_t addr;\n-\n-  addr = *key;\n-  if (addr < entry->address)\n-    return -1;\n-  else if (addr >= entry->address + entry->size)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Initialize the symbol table info for elf_syminfo.  */\n-\n-static int\n-elf_initialize_syminfo (struct backtrace_state *state,\n-\t\t\tuintptr_t base_address,\n-\t\t\tconst unsigned char *symtab_data, size_t symtab_size,\n-\t\t\tconst unsigned char *strtab, size_t strtab_size,\n-\t\t\tbacktrace_error_callback error_callback,\n-\t\t\tvoid *data, struct elf_syminfo_data *sdata)\n-{\n-  size_t sym_count;\n-  const b_elf_sym *sym;\n-  size_t elf_symbol_count;\n-  size_t elf_symbol_size;\n-  struct elf_symbol *elf_symbols;\n-  size_t i;\n-  unsigned int j;\n-\n-  sym_count = symtab_size / sizeof (b_elf_sym);\n-\n-  /* We only care about function symbols.  Count them.  */\n-  sym = (const b_elf_sym *) symtab_data;\n-  elf_symbol_count = 0;\n-  for (i = 0; i < sym_count; ++i, ++sym)\n-    {\n-      int info;\n-\n-      info = sym->st_info & 0xf;\n-      if ((info == STT_FUNC || info == STT_OBJECT)\n-\t  && sym->st_shndx != SHN_UNDEF)\n-\t++elf_symbol_count;\n-    }\n-\n-  elf_symbol_size = elf_symbol_count * sizeof (struct elf_symbol);\n-  elf_symbols = ((struct elf_symbol *)\n-\t\t backtrace_alloc (state, elf_symbol_size, error_callback,\n-\t\t\t\t  data));\n-  if (elf_symbols == NULL)\n-    return 0;\n-\n-  sym = (const b_elf_sym *) symtab_data;\n-  j = 0;\n-  for (i = 0; i < sym_count; ++i, ++sym)\n-    {\n-      int info;\n-\n-      info = sym->st_info & 0xf;\n-      if (info != STT_FUNC && info != STT_OBJECT)\n-\tcontinue;\n-      if (sym->st_shndx == SHN_UNDEF)\n-\tcontinue;\n-      if (sym->st_name >= strtab_size)\n-\t{\n-\t  error_callback (data, \"symbol string index out of range\", 0);\n-\t  backtrace_free (state, elf_symbols, elf_symbol_size, error_callback,\n-\t\t\t  data);\n-\t  return 0;\n-\t}\n-      elf_symbols[j].name = (const char *) strtab + sym->st_name;\n-      elf_symbols[j].address = sym->st_value + base_address;\n-      elf_symbols[j].size = sym->st_size;\n-      ++j;\n-    }\n-\n-  backtrace_qsort (elf_symbols, elf_symbol_count, sizeof (struct elf_symbol),\n-\t\t   elf_symbol_compare);\n-\n-  sdata->next = NULL;\n-  sdata->symbols = elf_symbols;\n-  sdata->count = elf_symbol_count;\n-\n-  return 1;\n-}\n-\n-/* Add EDATA to the list in STATE.  */\n-\n-static void\n-elf_add_syminfo_data (struct backtrace_state *state,\n-\t\t      struct elf_syminfo_data *edata)\n-{\n-  if (!state->threaded)\n-    {\n-      struct elf_syminfo_data **pp;\n-\n-      for (pp = (struct elf_syminfo_data **) (void *) &state->syminfo_data;\n-\t   *pp != NULL;\n-\t   pp = &(*pp)->next)\n-\t;\n-      *pp = edata;\n-    }\n-  else\n-    {\n-      while (1)\n-\t{\n-\t  struct elf_syminfo_data **pp;\n-\n-\t  pp = (struct elf_syminfo_data **) (void *) &state->syminfo_data;\n-\n-\t  while (1)\n-\t    {\n-\t      struct elf_syminfo_data *p;\n-\n-\t      p = backtrace_atomic_load_pointer (pp);\n-\n-\t      if (p == NULL)\n-\t\tbreak;\n-\n-\t      pp = &p->next;\n-\t    }\n-\n-\t  if (__sync_bool_compare_and_swap (pp, NULL, edata))\n-\t    break;\n-\t}\n-    }\n-}\n-\n-/* Return the symbol name and value for an ADDR.  */\n-\n-static void\n-elf_syminfo (struct backtrace_state *state, uintptr_t addr,\n-\t     backtrace_syminfo_callback callback,\n-\t     backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t     void *data)\n-{\n-  struct elf_syminfo_data *edata;\n-  struct elf_symbol *sym = NULL;\n-\n-  if (!state->threaded)\n-    {\n-      for (edata = (struct elf_syminfo_data *) state->syminfo_data;\n-\t   edata != NULL;\n-\t   edata = edata->next)\n-\t{\n-\t  sym = ((struct elf_symbol *)\n-\t\t bsearch (&addr, edata->symbols, edata->count,\n-\t\t\t  sizeof (struct elf_symbol), elf_symbol_search));\n-\t  if (sym != NULL)\n-\t    break;\n-\t}\n-    }\n-  else\n-    {\n-      struct elf_syminfo_data **pp;\n-\n-      pp = (struct elf_syminfo_data **) (void *) &state->syminfo_data;\n-      while (1)\n-\t{\n-\t  edata = backtrace_atomic_load_pointer (pp);\n-\t  if (edata == NULL)\n-\t    break;\n-\n-\t  sym = ((struct elf_symbol *)\n-\t\t bsearch (&addr, edata->symbols, edata->count,\n-\t\t\t  sizeof (struct elf_symbol), elf_symbol_search));\n-\t  if (sym != NULL)\n-\t    break;\n-\n-\t  pp = &edata->next;\n-\t}\n-    }\n-\n-  if (sym == NULL)\n-    callback (data, addr, NULL, 0, 0);\n-  else\n-    callback (data, addr, sym->name, sym->address, sym->size);\n-}\n-\n-/* Add the backtrace data for one ELF file.  Returns 1 on success,\n-   0 on failure (in both cases descriptor is closed) or -1 if exe\n-   is non-zero and the ELF file is ET_DYN, which tells the caller that\n-   elf_add will need to be called on the descriptor again after\n-   base_address is determined.  */\n-\n-static int\n-elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n-\t backtrace_error_callback error_callback, void *data,\n-\t fileline *fileline_fn, int *found_sym, int *found_dwarf, int exe)\n-{\n-  struct backtrace_view ehdr_view;\n-  b_elf_ehdr ehdr;\n-  off_t shoff;\n-  unsigned int shnum;\n-  unsigned int shstrndx;\n-  struct backtrace_view shdrs_view;\n-  int shdrs_view_valid;\n-  const b_elf_shdr *shdrs;\n-  const b_elf_shdr *shstrhdr;\n-  size_t shstr_size;\n-  off_t shstr_off;\n-  struct backtrace_view names_view;\n-  int names_view_valid;\n-  const char *names;\n-  unsigned int symtab_shndx;\n-  unsigned int dynsym_shndx;\n-  unsigned int i;\n-  struct debug_section_info sections[DEBUG_MAX];\n-  struct backtrace_view symtab_view;\n-  int symtab_view_valid;\n-  struct backtrace_view strtab_view;\n-  int strtab_view_valid;\n-  off_t min_offset;\n-  off_t max_offset;\n-  struct backtrace_view debug_view;\n-  int debug_view_valid;\n-\n-  *found_sym = 0;\n-  *found_dwarf = 0;\n-\n-  shdrs_view_valid = 0;\n-  names_view_valid = 0;\n-  symtab_view_valid = 0;\n-  strtab_view_valid = 0;\n-  debug_view_valid = 0;\n-\n-  if (!backtrace_get_view (state, descriptor, 0, sizeof ehdr, error_callback,\n-\t\t\t   data, &ehdr_view))\n-    goto fail;\n-\n-  memcpy (&ehdr, ehdr_view.data, sizeof ehdr);\n-\n-  backtrace_release_view (state, &ehdr_view, error_callback, data);\n-\n-  if (ehdr.e_ident[EI_MAG0] != ELFMAG0\n-      || ehdr.e_ident[EI_MAG1] != ELFMAG1\n-      || ehdr.e_ident[EI_MAG2] != ELFMAG2\n-      || ehdr.e_ident[EI_MAG3] != ELFMAG3)\n-    {\n-      error_callback (data, \"executable file is not ELF\", 0);\n-      goto fail;\n-    }\n-  if (ehdr.e_ident[EI_VERSION] != EV_CURRENT)\n-    {\n-      error_callback (data, \"executable file is unrecognized ELF version\", 0);\n-      goto fail;\n-    }\n-\n-#if BACKTRACE_ELF_SIZE == 32\n-#define BACKTRACE_ELFCLASS ELFCLASS32\n-#else\n-#define BACKTRACE_ELFCLASS ELFCLASS64\n-#endif\n-\n-  if (ehdr.e_ident[EI_CLASS] != BACKTRACE_ELFCLASS)\n-    {\n-      error_callback (data, \"executable file is unexpected ELF class\", 0);\n-      goto fail;\n-    }\n-\n-  if (ehdr.e_ident[EI_DATA] != ELFDATA2LSB\n-      && ehdr.e_ident[EI_DATA] != ELFDATA2MSB)\n-    {\n-      error_callback (data, \"executable file has unknown endianness\", 0);\n-      goto fail;\n-    }\n-\n-  /* If the executable is ET_DYN, it is either a PIE, or we are running\n-     directly a shared library with .interp.  We need to wait for\n-     dl_iterate_phdr in that case to determine the actual base_address.  */\n-  if (exe && ehdr.e_type == ET_DYN)\n-    return -1;\n-\n-  shoff = ehdr.e_shoff;\n-  shnum = ehdr.e_shnum;\n-  shstrndx = ehdr.e_shstrndx;\n-\n-  if ((shnum == 0 || shstrndx == SHN_XINDEX)\n-      && shoff != 0)\n-    {\n-      struct backtrace_view shdr_view;\n-      const b_elf_shdr *shdr;\n-\n-      if (!backtrace_get_view (state, descriptor, shoff, sizeof shdr,\n-\t\t\t       error_callback, data, &shdr_view))\n-\tgoto fail;\n-\n-      shdr = (const b_elf_shdr *) shdr_view.data;\n-\n-      if (shnum == 0)\n-\tshnum = shdr->sh_size;\n-\n-      if (shstrndx == SHN_XINDEX)\n-\t{\n-\t  shstrndx = shdr->sh_link;\n-\n-\t  /* Versions of the GNU binutils between 2.12 and 2.18 did\n-\t     not handle objects with more than SHN_LORESERVE sections\n-\t     correctly.  All large section indexes were offset by\n-\t     0x100.  There is more information at\n-\t     http://sourceware.org/bugzilla/show_bug.cgi?id-5900 .\n-\t     Fortunately these object files are easy to detect, as the\n-\t     GNU binutils always put the section header string table\n-\t     near the end of the list of sections.  Thus if the\n-\t     section header string table index is larger than the\n-\t     number of sections, then we know we have to subtract\n-\t     0x100 to get the real section index.  */\n-\t  if (shstrndx >= shnum && shstrndx >= SHN_LORESERVE + 0x100)\n-\t    shstrndx -= 0x100;\n-\t}\n-\n-      backtrace_release_view (state, &shdr_view, error_callback, data);\n-    }\n-\n-  /* To translate PC to file/line when using DWARF, we need to find\n-     the .debug_info and .debug_line sections.  */\n-\n-  /* Read the section headers, skipping the first one.  */\n-\n-  if (!backtrace_get_view (state, descriptor, shoff + sizeof (b_elf_shdr),\n-\t\t\t   (shnum - 1) * sizeof (b_elf_shdr),\n-\t\t\t   error_callback, data, &shdrs_view))\n-    goto fail;\n-  shdrs_view_valid = 1;\n-  shdrs = (const b_elf_shdr *) shdrs_view.data;\n-\n-  /* Read the section names.  */\n-\n-  shstrhdr = &shdrs[shstrndx - 1];\n-  shstr_size = shstrhdr->sh_size;\n-  shstr_off = shstrhdr->sh_offset;\n-\n-  if (!backtrace_get_view (state, descriptor, shstr_off, shstr_size,\n-\t\t\t   error_callback, data, &names_view))\n-    goto fail;\n-  names_view_valid = 1;\n-  names = (const char *) names_view.data;\n-\n-  symtab_shndx = 0;\n-  dynsym_shndx = 0;\n-\n-  memset (sections, 0, sizeof sections);\n-\n-  /* Look for the symbol table.  */\n-  for (i = 1; i < shnum; ++i)\n-    {\n-      const b_elf_shdr *shdr;\n-      unsigned int sh_name;\n-      const char *name;\n-      int j;\n-\n-      shdr = &shdrs[i - 1];\n-\n-      if (shdr->sh_type == SHT_SYMTAB)\n-\tsymtab_shndx = i;\n-      else if (shdr->sh_type == SHT_DYNSYM)\n-\tdynsym_shndx = i;\n-\n-      sh_name = shdr->sh_name;\n-      if (sh_name >= shstr_size)\n-\t{\n-\t  error_callback (data, \"ELF section name out of range\", 0);\n-\t  goto fail;\n-\t}\n-\n-      name = names + sh_name;\n-\n-      for (j = 0; j < (int) DEBUG_MAX; ++j)\n-\t{\n-\t  if (strcmp (name, debug_section_names[j]) == 0)\n-\t    {\n-\t      sections[j].offset = shdr->sh_offset;\n-\t      sections[j].size = shdr->sh_size;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  if (symtab_shndx == 0)\n-    symtab_shndx = dynsym_shndx;\n-  if (symtab_shndx != 0)\n-    {\n-      const b_elf_shdr *symtab_shdr;\n-      unsigned int strtab_shndx;\n-      const b_elf_shdr *strtab_shdr;\n-      struct elf_syminfo_data *sdata;\n-\n-      symtab_shdr = &shdrs[symtab_shndx - 1];\n-      strtab_shndx = symtab_shdr->sh_link;\n-      if (strtab_shndx >= shnum)\n-\t{\n-\t  error_callback (data,\n-\t\t\t  \"ELF symbol table strtab link out of range\", 0);\n-\t  goto fail;\n-\t}\n-      strtab_shdr = &shdrs[strtab_shndx - 1];\n-\n-      if (!backtrace_get_view (state, descriptor, symtab_shdr->sh_offset,\n-\t\t\t       symtab_shdr->sh_size, error_callback, data,\n-\t\t\t       &symtab_view))\n-\tgoto fail;\n-      symtab_view_valid = 1;\n-\n-      if (!backtrace_get_view (state, descriptor, strtab_shdr->sh_offset,\n-\t\t\t       strtab_shdr->sh_size, error_callback, data,\n-\t\t\t       &strtab_view))\n-\tgoto fail;\n-      strtab_view_valid = 1;\n-\n-      sdata = ((struct elf_syminfo_data *)\n-\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n-      if (sdata == NULL)\n-\tgoto fail;\n-\n-      if (!elf_initialize_syminfo (state, base_address,\n-\t\t\t\t   symtab_view.data, symtab_shdr->sh_size,\n-\t\t\t\t   strtab_view.data, strtab_shdr->sh_size,\n-\t\t\t\t   error_callback, data, sdata))\n-\t{\n-\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n-\t  goto fail;\n-\t}\n-\n-      /* We no longer need the symbol table, but we hold on to the\n-\t string table permanently.  */\n-      backtrace_release_view (state, &symtab_view, error_callback, data);\n-\n-      *found_sym = 1;\n-\n-      elf_add_syminfo_data (state, sdata);\n-    }\n-\n-  /* FIXME: Need to handle compressed debug sections.  */\n-\n-  backtrace_release_view (state, &shdrs_view, error_callback, data);\n-  shdrs_view_valid = 0;\n-  backtrace_release_view (state, &names_view, error_callback, data);\n-  names_view_valid = 0;\n-\n-  /* Read all the debug sections in a single view, since they are\n-     probably adjacent in the file.  We never release this view.  */\n-\n-  min_offset = 0;\n-  max_offset = 0;\n-  for (i = 0; i < (int) DEBUG_MAX; ++i)\n-    {\n-      off_t end;\n-\n-      if (sections[i].size == 0)\n-\tcontinue;\n-      if (min_offset == 0 || sections[i].offset < min_offset)\n-\tmin_offset = sections[i].offset;\n-      end = sections[i].offset + sections[i].size;\n-      if (end > max_offset)\n-\tmax_offset = end;\n-    }\n-  if (min_offset == 0 || max_offset == 0)\n-    {\n-      if (!backtrace_close (descriptor, error_callback, data))\n-\tgoto fail;\n-      return 1;\n-    }\n-\n-  if (!backtrace_get_view (state, descriptor, min_offset,\n-\t\t\t   max_offset - min_offset,\n-\t\t\t   error_callback, data, &debug_view))\n-    goto fail;\n-  debug_view_valid = 1;\n-\n-  /* We've read all we need from the executable.  */\n-  if (!backtrace_close (descriptor, error_callback, data))\n-    goto fail;\n-  descriptor = -1;\n-\n-  for (i = 0; i < (int) DEBUG_MAX; ++i)\n-    {\n-      if (sections[i].size == 0)\n-\tsections[i].data = NULL;\n-      else\n-\tsections[i].data = ((const unsigned char *) debug_view.data\n-\t\t\t    + (sections[i].offset - min_offset));\n-    }\n-\n-  if (!backtrace_dwarf_add (state, base_address,\n-\t\t\t    sections[DEBUG_INFO].data,\n-\t\t\t    sections[DEBUG_INFO].size,\n-\t\t\t    sections[DEBUG_LINE].data,\n-\t\t\t    sections[DEBUG_LINE].size,\n-\t\t\t    sections[DEBUG_ABBREV].data,\n-\t\t\t    sections[DEBUG_ABBREV].size,\n-\t\t\t    sections[DEBUG_RANGES].data,\n-\t\t\t    sections[DEBUG_RANGES].size,\n-\t\t\t    sections[DEBUG_STR].data,\n-\t\t\t    sections[DEBUG_STR].size,\n-\t\t\t    ehdr.e_ident[EI_DATA] == ELFDATA2MSB,\n-\t\t\t    error_callback, data, fileline_fn))\n-    goto fail;\n-\n-  *found_dwarf = 1;\n-\n-  return 1;\n-\n- fail:\n-  if (shdrs_view_valid)\n-    backtrace_release_view (state, &shdrs_view, error_callback, data);\n-  if (names_view_valid)\n-    backtrace_release_view (state, &names_view, error_callback, data);\n-  if (symtab_view_valid)\n-    backtrace_release_view (state, &symtab_view, error_callback, data);\n-  if (strtab_view_valid)\n-    backtrace_release_view (state, &strtab_view, error_callback, data);\n-  if (debug_view_valid)\n-    backtrace_release_view (state, &debug_view, error_callback, data);\n-  if (descriptor != -1)\n-    backtrace_close (descriptor, error_callback, data);\n-  return 0;\n-}\n-\n-/* Data passed to phdr_callback.  */\n-\n-struct phdr_data\n-{\n-  struct backtrace_state *state;\n-  backtrace_error_callback error_callback;\n-  void *data;\n-  fileline *fileline_fn;\n-  int *found_sym;\n-  int *found_dwarf;\n-  int exe_descriptor;\n-};\n-\n-/* Callback passed to dl_iterate_phdr.  Load debug info from shared\n-   libraries.  */\n-\n-static int\n-#ifdef __i386__\n-__attribute__ ((__force_align_arg_pointer__))\n-#endif\n-phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n-\t       void *pdata)\n-{\n-  struct phdr_data *pd = (struct phdr_data *) pdata;\n-  int descriptor;\n-  int does_not_exist;\n-  fileline elf_fileline_fn;\n-  int found_dwarf;\n-\n-  /* There is not much we can do if we don't have the module name,\n-     unless executable is ET_DYN, where we expect the very first\n-     phdr_callback to be for the PIE.  */\n-  if (info->dlpi_name == NULL || info->dlpi_name[0] == '\\0')\n-    {\n-      if (pd->exe_descriptor == -1)\n-\treturn 0;\n-      descriptor = pd->exe_descriptor;\n-      pd->exe_descriptor = -1;\n-    }\n-  else\n-    {\n-      if (pd->exe_descriptor != -1)\n-\t{\n-\t  backtrace_close (pd->exe_descriptor, pd->error_callback, pd->data);\n-\t  pd->exe_descriptor = -1;\n-\t}\n-\n-      descriptor = backtrace_open (info->dlpi_name, pd->error_callback,\n-\t\t\t\t   pd->data, &does_not_exist);\n-      if (descriptor < 0)\n-\treturn 0;\n-    }\n-\n-  if (elf_add (pd->state, descriptor, info->dlpi_addr, pd->error_callback,\n-\t       pd->data, &elf_fileline_fn, pd->found_sym, &found_dwarf, 0))\n-    {\n-      if (found_dwarf)\n-\t{\n-\t  *pd->found_dwarf = 1;\n-\t  *pd->fileline_fn = elf_fileline_fn;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Initialize the backtrace data we need from an ELF executable.  At\n-   the ELF level, all we need to do is find the debug info\n-   sections.  */\n-\n-int\n-backtrace_initialize (struct backtrace_state *state, int descriptor,\n-\t\t      backtrace_error_callback error_callback,\n-\t\t      void *data, fileline *fileline_fn)\n-{\n-  int ret;\n-  int found_sym;\n-  int found_dwarf;\n-  fileline elf_fileline_fn = elf_nodebug;\n-  struct phdr_data pd;\n-\n-  ret = elf_add (state, descriptor, 0, error_callback, data, &elf_fileline_fn,\n-\t\t &found_sym, &found_dwarf, 1);\n-  if (!ret)\n-    return 0;\n-\n-  pd.state = state;\n-  pd.error_callback = error_callback;\n-  pd.data = data;\n-  pd.fileline_fn = &elf_fileline_fn;\n-  pd.found_sym = &found_sym;\n-  pd.found_dwarf = &found_dwarf;\n-  pd.exe_descriptor = ret < 0 ? descriptor : -1;\n-\n-  dl_iterate_phdr (phdr_callback, (void *) &pd);\n-\n-  if (!state->threaded)\n-    {\n-      if (found_sym)\n-\tstate->syminfo_fn = elf_syminfo;\n-      else if (state->syminfo_fn == NULL)\n-\tstate->syminfo_fn = elf_nosyms;\n-    }\n-  else\n-    {\n-      if (found_sym)\n-\tbacktrace_atomic_store_pointer (&state->syminfo_fn, elf_syminfo);\n-      else\n-\t(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n-\t\t\t\t\t     elf_nosyms);\n-    }\n-\n-  if (!state->threaded)\n-    {\n-      if (state->fileline_fn == NULL || state->fileline_fn == elf_nodebug)\n-\t*fileline_fn = elf_fileline_fn;\n-    }\n-  else\n-    {\n-      fileline current_fn;\n-\n-      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n-      if (current_fn == NULL || current_fn == elf_nodebug)\n-\t*fileline_fn = elf_fileline_fn;\n-    }\n-\n-  return 1;\n-}"}, {"sha": "27ebbedc21ccf39f86f439138c2e418b556ccbd8", "filename": "src/libbacktrace/fileline.c", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Ffileline.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffileline.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,194 +0,0 @@\n-/* fileline.c -- Get file and line number information in a backtrace.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <stdlib.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-#ifndef HAVE_GETEXECNAME\n-#define getexecname() NULL\n-#endif\n-\n-/* Initialize the fileline information from the executable.  Returns 1\n-   on success, 0 on failure.  */\n-\n-static int\n-fileline_initialize (struct backtrace_state *state,\n-\t\t     backtrace_error_callback error_callback, void *data)\n-{\n-  int failed;\n-  fileline fileline_fn;\n-  int pass;\n-  int called_error_callback;\n-  int descriptor;\n-\n-  if (!state->threaded)\n-    failed = state->fileline_initialization_failed;\n-  else\n-    failed = backtrace_atomic_load_int (&state->fileline_initialization_failed);\n-\n-  if (failed)\n-    {\n-      error_callback (data, \"failed to read executable information\", -1);\n-      return 0;\n-    }\n-\n-  if (!state->threaded)\n-    fileline_fn = state->fileline_fn;\n-  else\n-    fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n-  if (fileline_fn != NULL)\n-    return 1;\n-\n-  /* We have not initialized the information.  Do it now.  */\n-\n-  descriptor = -1;\n-  called_error_callback = 0;\n-  for (pass = 0; pass < 4; ++pass)\n-    {\n-      const char *filename;\n-      int does_not_exist;\n-\n-      switch (pass)\n-\t{\n-\tcase 0:\n-\t  filename = state->filename;\n-\t  break;\n-\tcase 1:\n-\t  filename = getexecname ();\n-\t  break;\n-\tcase 2:\n-\t  filename = \"/proc/self/exe\";\n-\t  break;\n-\tcase 3:\n-\t  filename = \"/proc/curproc/file\";\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-      if (filename == NULL)\n-\tcontinue;\n-\n-      descriptor = backtrace_open (filename, error_callback, data,\n-\t\t\t\t   &does_not_exist);\n-      if (descriptor < 0 && !does_not_exist)\n-\t{\n-\t  called_error_callback = 1;\n-\t  break;\n-\t}\n-      if (descriptor >= 0)\n-\tbreak;\n-    }\n-\n-  if (descriptor < 0)\n-    {\n-      if (!called_error_callback)\n-\t{\n-\t  if (state->filename != NULL)\n-\t    error_callback (data, state->filename, ENOENT);\n-\t  else\n-\t    error_callback (data,\n-\t\t\t    \"libbacktrace could not find executable to open\",\n-\t\t\t    0);\n-\t}\n-      failed = 1;\n-    }\n-\n-  if (!failed)\n-    {\n-      if (!backtrace_initialize (state, descriptor, error_callback, data,\n-\t\t\t\t &fileline_fn))\n-\tfailed = 1;\n-    }\n-\n-  if (failed)\n-    {\n-      if (!state->threaded)\n-\tstate->fileline_initialization_failed = 1;\n-      else\n-\tbacktrace_atomic_store_int (&state->fileline_initialization_failed, 1);\n-      return 0;\n-    }\n-\n-  if (!state->threaded)\n-    state->fileline_fn = fileline_fn;\n-  else\n-    {\n-      backtrace_atomic_store_pointer (&state->fileline_fn, fileline_fn);\n-\n-      /* Note that if two threads initialize at once, one of the data\n-\t sets may be leaked.  */\n-    }\n-\n-  return 1;\n-}\n-\n-/* Given a PC, find the file name, line number, and function name.  */\n-\n-int\n-backtrace_pcinfo (struct backtrace_state *state, uintptr_t pc,\n-\t\t  backtrace_full_callback callback,\n-\t\t  backtrace_error_callback error_callback, void *data)\n-{\n-  if (!fileline_initialize (state, error_callback, data))\n-    return 0;\n-\n-  if (state->fileline_initialization_failed)\n-    return 0;\n-\n-  return state->fileline_fn (state, pc, callback, error_callback, data);\n-}\n-\n-/* Given a PC, find the symbol for it, and its value.  */\n-\n-int\n-backtrace_syminfo (struct backtrace_state *state, uintptr_t pc,\n-\t\t   backtrace_syminfo_callback callback,\n-\t\t   backtrace_error_callback error_callback, void *data)\n-{\n-  if (!fileline_initialize (state, error_callback, data))\n-    return 0;\n-\n-  if (state->fileline_initialization_failed)\n-    return 0;\n-\n-  state->syminfo_fn (state, pc, callback, error_callback, data);\n-  return 1;\n-}"}, {"sha": "1161daaa4f3581c81c4842509aa7c7298d3bbd7b", "filename": "src/libbacktrace/filenames.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Ffilenames.h", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Ffilenames.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffilenames.h?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,99 +0,0 @@\n-/* Macros for taking apart, interpreting and processing file names.\n-\n-   These are here because some non-Posix (a.k.a. DOSish) systems have\n-   drive letter brain-damage at the beginning of an absolute file name,\n-   use forward- and back-slash in path names interchangeably, and\n-   some of them have case-insensitive file names.\n-\n-   Copyright (C) 2000-2015 Free Software Foundation, Inc.\n-\n-This file is part of BFD, the Binary File Descriptor library.\n-\n-This program is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n-\n-#ifndef FILENAMES_H\n-#define FILENAMES_H\n-\n-#include \"hashtab.h\" /* for hashval_t */\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__)\n-#  ifndef HAVE_DOS_BASED_FILE_SYSTEM\n-#    define HAVE_DOS_BASED_FILE_SYSTEM 1\n-#  endif\n-#  ifndef HAVE_CASE_INSENSITIVE_FILE_SYSTEM\n-#    define HAVE_CASE_INSENSITIVE_FILE_SYSTEM 1\n-#  endif\n-#  define HAS_DRIVE_SPEC(f) HAS_DOS_DRIVE_SPEC (f)\n-#  define IS_DIR_SEPARATOR(c) IS_DOS_DIR_SEPARATOR (c)\n-#  define IS_ABSOLUTE_PATH(f) IS_DOS_ABSOLUTE_PATH (f)\n-#else /* not DOSish */\n-#  if defined(__APPLE__)\n-#    ifndef HAVE_CASE_INSENSITIVE_FILE_SYSTEM\n-#      define HAVE_CASE_INSENSITIVE_FILE_SYSTEM 1\n-#    endif\n-#  endif /* __APPLE__ */\n-#  define HAS_DRIVE_SPEC(f) (0)\n-#  define IS_DIR_SEPARATOR(c) IS_UNIX_DIR_SEPARATOR (c)\n-#  define IS_ABSOLUTE_PATH(f) IS_UNIX_ABSOLUTE_PATH (f)\n-#endif\n-\n-#define IS_DIR_SEPARATOR_1(dos_based, c)\t\t\t\t\\\n-  (((c) == '/')\t\t\t\t\t\t\t\t\\\n-   || (((c) == '\\\\') && (dos_based)))\n-\n-#define HAS_DRIVE_SPEC_1(dos_based, f)\t\t\t\\\n-  ((f)[0] && ((f)[1] == ':') && (dos_based))\n-\n-/* Remove the drive spec from F, assuming HAS_DRIVE_SPEC (f).\n-   The result is a pointer to the remainder of F.  */\n-#define STRIP_DRIVE_SPEC(f)\t((f) + 2)\n-\n-#define IS_DOS_DIR_SEPARATOR(c) IS_DIR_SEPARATOR_1 (1, c)\n-#define IS_DOS_ABSOLUTE_PATH(f) IS_ABSOLUTE_PATH_1 (1, f)\n-#define HAS_DOS_DRIVE_SPEC(f) HAS_DRIVE_SPEC_1 (1, f)\n-\n-#define IS_UNIX_DIR_SEPARATOR(c) IS_DIR_SEPARATOR_1 (0, c)\n-#define IS_UNIX_ABSOLUTE_PATH(f) IS_ABSOLUTE_PATH_1 (0, f)\n-\n-/* Note that when DOS_BASED is true, IS_ABSOLUTE_PATH accepts d:foo as\n-   well, although it is only semi-absolute.  This is because the users\n-   of IS_ABSOLUTE_PATH want to know whether to prepend the current\n-   working directory to a file name, which should not be done with a\n-   name like d:foo.  */\n-#define IS_ABSOLUTE_PATH_1(dos_based, f)\t\t \\\n-  (IS_DIR_SEPARATOR_1 (dos_based, (f)[0])\t\t \\\n-   || HAS_DRIVE_SPEC_1 (dos_based, f))\n-\n-extern int filename_cmp (const char *s1, const char *s2);\n-#define FILENAME_CMP(s1, s2)\tfilename_cmp(s1, s2)\n-\n-extern int filename_ncmp (const char *s1, const char *s2,\n-\t\t\t  size_t n);\n-\n-extern hashval_t filename_hash (const void *s);\n-\n-extern int filename_eq (const void *s1, const void *s2);\n-\n-extern int canonical_filename_eq (const char *a, const char *b);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif /* FILENAMES_H */"}, {"sha": "a5f6c8cc1800f0cb24d415cade2b0905f54a730f", "filename": "src/libbacktrace/filetype.awk", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffiletype.awk?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,11 +0,0 @@\n-# An awk script to determine the type of a file.\n-/\\177ELF\\001/ { if (NR == 1) { print \"elf32\"; exit } }\n-/\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }\n-/\\114\\001/    { if (NR == 1) { print \"pecoff\"; exit } }\n-/\\144\\206/    { if (NR == 1) { print \"pecoff\"; exit } }\n-/\\xFE\\xED\\xFA\\xCE/ { if (NR == 1) { print \"macho32\"; exit } }\n-/\\xCE\\xFA\\xED\\xFE/ { if (NR == 1) { print \"macho32\"; exit } }\n-/\\xFE\\xED\\xFA\\xCF/ { if (NR == 1) { print \"macho64\"; exit } }\n-/\\xCF\\xFA\\xED\\xFE/ { if (NR == 1) { print \"macho64\"; exit } }\n-/\\xCA\\xFE\\xBA\\xBE/ { if (NR == 1) { print \"macho-fat\"; exit } }\n-/\\xBE\\xBA\\xFE\\xCA/ { if (NR == 1) { print \"macho-fat\"; exit } }"}, {"sha": "b1b5877aae7ca83dd2f04cc050c352b82e4a8d35", "filename": "src/libbacktrace/hashtab.h", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fhashtab.h", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fhashtab.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fhashtab.h?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,204 +0,0 @@\n-/* An expandable hash tables datatype.  \n-   Copyright (C) 1999-2015 Free Software Foundation, Inc.\n-   Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n-\n-This program is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n-\n-/* This package implements basic hash table functionality.  It is possible\n-   to search for an entry, create an entry and destroy an entry.\n-\n-   Elements in the table are generic pointers.\n-\n-   The size of the table is not fixed; if the occupancy of the table\n-   grows too high the hash table will be expanded.\n-\n-   The abstract data implementation is based on generalized Algorithm D\n-   from Knuth's book \"The art of computer programming\".  Hash table is\n-   expanded by creation of new hash table and transferring elements from\n-   the old table to the new table.  */\n-\n-#ifndef __HASHTAB_H__\n-#define __HASHTAB_H__\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif /* __cplusplus */\n-\n-#include \"ansidecl.h\"\n-\n-/* The type for a hash code.  */\n-typedef unsigned int hashval_t;\n-\n-/* Callback function pointer types.  */\n-\n-/* Calculate hash of a table entry.  */\n-typedef hashval_t (*htab_hash) (const void *);\n-\n-/* Compare a table entry with a possible entry.  The entry already in\n-   the table always comes first, so the second element can be of a\n-   different type (but in this case htab_find and htab_find_slot\n-   cannot be used; instead the variants that accept a hash value\n-   must be used).  */\n-typedef int (*htab_eq) (const void *, const void *);\n-\n-/* Cleanup function called whenever a live element is removed from\n-   the hash table.  */\n-typedef void (*htab_del) (void *);\n-  \n-/* Function called by htab_traverse for each live element.  The first\n-   arg is the slot of the element (which can be passed to htab_clear_slot\n-   if desired), the second arg is the auxiliary pointer handed to\n-   htab_traverse.  Return 1 to continue scan, 0 to stop.  */\n-typedef int (*htab_trav) (void **, void *);\n-\n-/* Memory-allocation function, with the same functionality as calloc().\n-   Iff it returns NULL, the hash table implementation will pass an error\n-   code back to the user, so if your code doesn't handle errors,\n-   best if you use xcalloc instead.  */\n-typedef void *(*htab_alloc) (size_t, size_t);\n-\n-/* We also need a free() routine.  */\n-typedef void (*htab_free) (void *);\n-\n-/* Memory allocation and deallocation; variants which take an extra\n-   argument.  */\n-typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);\n-typedef void (*htab_free_with_arg) (void *, void *);\n-\n-/* This macro defines reserved value for empty table entry.  */\n-\n-#define HTAB_EMPTY_ENTRY    ((PTR) 0)\n-\n-/* This macro defines reserved value for table entry which contained\n-   a deleted element. */\n-\n-#define HTAB_DELETED_ENTRY  ((PTR) 1)\n-\n-/* Hash tables are of the following type.  The structure\n-   (implementation) of this type is not needed for using the hash\n-   tables.  All work with hash table should be executed only through\n-   functions mentioned below.  The size of this structure is subject to\n-   change.  */\n-\n-struct htab {\n-  /* Pointer to hash function.  */\n-  htab_hash hash_f;\n-\n-  /* Pointer to comparison function.  */\n-  htab_eq eq_f;\n-\n-  /* Pointer to cleanup function.  */\n-  htab_del del_f;\n-\n-  /* Table itself.  */\n-  void **entries;\n-\n-  /* Current size (in entries) of the hash table.  */\n-  size_t size;\n-\n-  /* Current number of elements including also deleted elements.  */\n-  size_t n_elements;\n-\n-  /* Current number of deleted elements in the table.  */\n-  size_t n_deleted;\n-\n-  /* The following member is used for debugging. Its value is number\n-     of all calls of `htab_find_slot' for the hash table. */\n-  unsigned int searches;\n-\n-  /* The following member is used for debugging.  Its value is number\n-     of collisions fixed for time of work with the hash table. */\n-  unsigned int collisions;\n-\n-  /* Pointers to allocate/free functions.  */\n-  htab_alloc alloc_f;\n-  htab_free free_f;\n-\n-  /* Alternate allocate/free functions, which take an extra argument.  */\n-  void *alloc_arg;\n-  htab_alloc_with_arg alloc_with_arg_f;\n-  htab_free_with_arg free_with_arg_f;\n-\n-  /* Current size (in entries) of the hash table, as an index into the\n-     table of primes.  */\n-  unsigned int size_prime_index;\n-};\n-\n-typedef struct htab *htab_t;\n-\n-/* An enum saying whether we insert into the hash table or not.  */\n-enum insert_option {NO_INSERT, INSERT};\n-\n-/* The prototypes of the package functions. */\n-\n-extern htab_t\thtab_create_alloc  (size_t, htab_hash,\n-                                    htab_eq, htab_del,\n-                                    htab_alloc, htab_free);\n-\n-extern htab_t\thtab_create_alloc_ex (size_t, htab_hash,\n-                                      htab_eq, htab_del,\n-                                      void *, htab_alloc_with_arg,\n-                                      htab_free_with_arg);\n-\n-extern htab_t  htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,\n-\t\t\t\t\thtab_alloc, htab_alloc, htab_free);\n-\n-/* Backward-compatibility functions.  */\n-extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);\n-extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);\n-\n-extern void\thtab_set_functions_ex (htab_t, htab_hash,\n-                                       htab_eq, htab_del,\n-                                       void *, htab_alloc_with_arg,\n-                                       htab_free_with_arg);\n-\n-extern void\thtab_delete (htab_t);\n-extern void\thtab_empty (htab_t);\n-\n-extern void *\thtab_find (htab_t, const void *);\n-extern void **\thtab_find_slot (htab_t, const void *, enum insert_option);\n-extern void *\thtab_find_with_hash (htab_t, const void *, hashval_t);\n-extern void **\thtab_find_slot_with_hash (htab_t, const void *,\n-\t\t\t\t\t  hashval_t, enum insert_option);\n-extern void\thtab_clear_slot\t(htab_t, void **);\n-extern void\thtab_remove_elt\t(htab_t, void *);\n-extern void\thtab_remove_elt_with_hash (htab_t, void *, hashval_t);\n-\n-extern void\thtab_traverse (htab_t, htab_trav, void *);\n-extern void\thtab_traverse_noresize (htab_t, htab_trav, void *);\n-\n-extern size_t\thtab_size (htab_t);\n-extern size_t\thtab_elements (htab_t);\n-extern double\thtab_collisions\t(htab_t);\n-\n-/* A hash function for pointers.  */\n-extern htab_hash htab_hash_pointer;\n-\n-/* An equality function for pointers.  */\n-extern htab_eq htab_eq_pointer;\n-\n-/* A hash function for null-terminated strings.  */\n-extern hashval_t htab_hash_string (const void *);\n-\n-/* An iterative hash function for arbitrary data.  */\n-extern hashval_t iterative_hash (const void *, size_t, hashval_t);\n-/* Shorthand for hashing something with an intrinsic size.  */\n-#define iterative_hash_object(OB,INIT) iterative_hash (&OB, sizeof (OB), INIT)\n-\n-#ifdef __cplusplus\n-}\n-#endif /* __cplusplus */\n-\n-#endif /* __HASHTAB_H */"}, {"sha": "0b0fdcbba69ab6dd05ca162a5328828d46ab1d54", "filename": "src/libbacktrace/install-sh", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Finstall-sh", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Finstall-sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finstall-sh?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,501 +0,0 @@\n-#!/bin/sh\n-# install - install a program, script, or datafile\n-\n-scriptversion=2013-12-25.23; # UTC\n-\n-# This originates from X11R5 (mit/util/scripts/install.sh), which was\n-# later released in X11R6 (xc/config/util/install.sh) with the\n-# following copyright and license.\n-#\n-# Copyright (C) 1994 X Consortium\n-#\n-# Permission is hereby granted, free of charge, to any person obtaining a copy\n-# of this software and associated documentation files (the \"Software\"), to\n-# deal in the Software without restriction, including without limitation the\n-# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n-# sell copies of the Software, and to permit persons to whom the Software is\n-# furnished to do so, subject to the following conditions:\n-#\n-# The above copyright notice and this permission notice shall be included in\n-# all copies or substantial portions of the Software.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n-# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n-# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-\n-# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n-#\n-# Except as contained in this notice, the name of the X Consortium shall not\n-# be used in advertising or otherwise to promote the sale, use or other deal-\n-# ings in this Software without prior written authorization from the X Consor-\n-# tium.\n-#\n-#\n-# FSF changes to this file are in the public domain.\n-#\n-# Calling this script install-sh is preferred over install.sh, to prevent\n-# 'make' implicit rules from creating a file called install from it\n-# when there is no Makefile.\n-#\n-# This script is compatible with the BSD install script, but was written\n-# from scratch.\n-\n-tab='\t'\n-nl='\n-'\n-IFS=\" $tab$nl\"\n-\n-# Set DOITPROG to \"echo\" to test this script.\n-\n-doit=${DOITPROG-}\n-doit_exec=${doit:-exec}\n-\n-# Put in absolute file names if you don't have them in your path;\n-# or use environment vars.\n-\n-chgrpprog=${CHGRPPROG-chgrp}\n-chmodprog=${CHMODPROG-chmod}\n-chownprog=${CHOWNPROG-chown}\n-cmpprog=${CMPPROG-cmp}\n-cpprog=${CPPROG-cp}\n-mkdirprog=${MKDIRPROG-mkdir}\n-mvprog=${MVPROG-mv}\n-rmprog=${RMPROG-rm}\n-stripprog=${STRIPPROG-strip}\n-\n-posix_mkdir=\n-\n-# Desired mode of installed file.\n-mode=0755\n-\n-chgrpcmd=\n-chmodcmd=$chmodprog\n-chowncmd=\n-mvcmd=$mvprog\n-rmcmd=\"$rmprog -f\"\n-stripcmd=\n-\n-src=\n-dst=\n-dir_arg=\n-dst_arg=\n-\n-copy_on_change=false\n-is_target_a_directory=possibly\n-\n-usage=\"\\\n-Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE\n-   or: $0 [OPTION]... SRCFILES... DIRECTORY\n-   or: $0 [OPTION]... -t DIRECTORY SRCFILES...\n-   or: $0 [OPTION]... -d DIRECTORIES...\n-\n-In the 1st form, copy SRCFILE to DSTFILE.\n-In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.\n-In the 4th, create DIRECTORIES.\n-\n-Options:\n-     --help     display this help and exit.\n-     --version  display version info and exit.\n-\n-  -c            (ignored)\n-  -C            install only if different (preserve the last data modification time)\n-  -d            create directories instead of installing files.\n-  -g GROUP      $chgrpprog installed files to GROUP.\n-  -m MODE       $chmodprog installed files to MODE.\n-  -o USER       $chownprog installed files to USER.\n-  -s            $stripprog installed files.\n-  -t DIRECTORY  install into DIRECTORY.\n-  -T            report an error if DSTFILE is a directory.\n-\n-Environment variables override the default commands:\n-  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG\n-  RMPROG STRIPPROG\n-\"\n-\n-while test $# -ne 0; do\n-  case $1 in\n-    -c) ;;\n-\n-    -C) copy_on_change=true;;\n-\n-    -d) dir_arg=true;;\n-\n-    -g) chgrpcmd=\"$chgrpprog $2\"\n-        shift;;\n-\n-    --help) echo \"$usage\"; exit $?;;\n-\n-    -m) mode=$2\n-        case $mode in\n-          *' '* | *\"$tab\"* | *\"$nl\"* | *'*'* | *'?'* | *'['*)\n-            echo \"$0: invalid mode: $mode\" >&2\n-            exit 1;;\n-        esac\n-        shift;;\n-\n-    -o) chowncmd=\"$chownprog $2\"\n-        shift;;\n-\n-    -s) stripcmd=$stripprog;;\n-\n-    -t)\n-        is_target_a_directory=always\n-        dst_arg=$2\n-        # Protect names problematic for 'test' and other utilities.\n-        case $dst_arg in\n-          -* | [=\\(\\)!]) dst_arg=./$dst_arg;;\n-        esac\n-        shift;;\n-\n-    -T) is_target_a_directory=never;;\n-\n-    --version) echo \"$0 $scriptversion\"; exit $?;;\n-\n-    --) shift\n-        break;;\n-\n-    -*) echo \"$0: invalid option: $1\" >&2\n-        exit 1;;\n-\n-    *)  break;;\n-  esac\n-  shift\n-done\n-\n-# We allow the use of options -d and -T together, by making -d\n-# take the precedence; this is for compatibility with GNU install.\n-\n-if test -n \"$dir_arg\"; then\n-  if test -n \"$dst_arg\"; then\n-    echo \"$0: target directory not allowed when installing a directory.\" >&2\n-    exit 1\n-  fi\n-fi\n-\n-if test $# -ne 0 && test -z \"$dir_arg$dst_arg\"; then\n-  # When -d is used, all remaining arguments are directories to create.\n-  # When -t is used, the destination is already specified.\n-  # Otherwise, the last argument is the destination.  Remove it from $@.\n-  for arg\n-  do\n-    if test -n \"$dst_arg\"; then\n-      # $@ is not empty: it contains at least $arg.\n-      set fnord \"$@\" \"$dst_arg\"\n-      shift # fnord\n-    fi\n-    shift # arg\n-    dst_arg=$arg\n-    # Protect names problematic for 'test' and other utilities.\n-    case $dst_arg in\n-      -* | [=\\(\\)!]) dst_arg=./$dst_arg;;\n-    esac\n-  done\n-fi\n-\n-if test $# -eq 0; then\n-  if test -z \"$dir_arg\"; then\n-    echo \"$0: no input file specified.\" >&2\n-    exit 1\n-  fi\n-  # It's OK to call 'install-sh -d' without argument.\n-  # This can happen when creating conditional directories.\n-  exit 0\n-fi\n-\n-if test -z \"$dir_arg\"; then\n-  if test $# -gt 1 || test \"$is_target_a_directory\" = always; then\n-    if test ! -d \"$dst_arg\"; then\n-      echo \"$0: $dst_arg: Is not a directory.\" >&2\n-      exit 1\n-    fi\n-  fi\n-fi\n-\n-if test -z \"$dir_arg\"; then\n-  do_exit='(exit $ret); exit $ret'\n-  trap \"ret=129; $do_exit\" 1\n-  trap \"ret=130; $do_exit\" 2\n-  trap \"ret=141; $do_exit\" 13\n-  trap \"ret=143; $do_exit\" 15\n-\n-  # Set umask so as not to create temps with too-generous modes.\n-  # However, 'strip' requires both read and write access to temps.\n-  case $mode in\n-    # Optimize common cases.\n-    *644) cp_umask=133;;\n-    *755) cp_umask=22;;\n-\n-    *[0-7])\n-      if test -z \"$stripcmd\"; then\n-        u_plus_rw=\n-      else\n-        u_plus_rw='% 200'\n-      fi\n-      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;\n-    *)\n-      if test -z \"$stripcmd\"; then\n-        u_plus_rw=\n-      else\n-        u_plus_rw=,u+rw\n-      fi\n-      cp_umask=$mode$u_plus_rw;;\n-  esac\n-fi\n-\n-for src\n-do\n-  # Protect names problematic for 'test' and other utilities.\n-  case $src in\n-    -* | [=\\(\\)!]) src=./$src;;\n-  esac\n-\n-  if test -n \"$dir_arg\"; then\n-    dst=$src\n-    dstdir=$dst\n-    test -d \"$dstdir\"\n-    dstdir_status=$?\n-  else\n-\n-    # Waiting for this to be detected by the \"$cpprog $src $dsttmp\" command\n-    # might cause directories to be created, which would be especially bad\n-    # if $src (and thus $dsttmp) contains '*'.\n-    if test ! -f \"$src\" && test ! -d \"$src\"; then\n-      echo \"$0: $src does not exist.\" >&2\n-      exit 1\n-    fi\n-\n-    if test -z \"$dst_arg\"; then\n-      echo \"$0: no destination specified.\" >&2\n-      exit 1\n-    fi\n-    dst=$dst_arg\n-\n-    # If destination is a directory, append the input filename; won't work\n-    # if double slashes aren't ignored.\n-    if test -d \"$dst\"; then\n-      if test \"$is_target_a_directory\" = never; then\n-        echo \"$0: $dst_arg: Is a directory\" >&2\n-        exit 1\n-      fi\n-      dstdir=$dst\n-      dst=$dstdir/`basename \"$src\"`\n-      dstdir_status=0\n-    else\n-      dstdir=`dirname \"$dst\"`\n-      test -d \"$dstdir\"\n-      dstdir_status=$?\n-    fi\n-  fi\n-\n-  obsolete_mkdir_used=false\n-\n-  if test $dstdir_status != 0; then\n-    case $posix_mkdir in\n-      '')\n-        # Create intermediate dirs using mode 755 as modified by the umask.\n-        # This is like FreeBSD 'install' as of 1997-10-28.\n-        umask=`umask`\n-        case $stripcmd.$umask in\n-          # Optimize common cases.\n-          *[2367][2367]) mkdir_umask=$umask;;\n-          .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;\n-\n-          *[0-7])\n-            mkdir_umask=`expr $umask + 22 \\\n-              - $umask % 100 % 40 + $umask % 20 \\\n-              - $umask % 10 % 4 + $umask % 2\n-            `;;\n-          *) mkdir_umask=$umask,go-w;;\n-        esac\n-\n-        # With -d, create the new directory with the user-specified mode.\n-        # Otherwise, rely on $mkdir_umask.\n-        if test -n \"$dir_arg\"; then\n-          mkdir_mode=-m$mode\n-        else\n-          mkdir_mode=\n-        fi\n-\n-        posix_mkdir=false\n-        case $umask in\n-          *[123567][0-7][0-7])\n-            # POSIX mkdir -p sets u+wx bits regardless of umask, which\n-            # is incompatible with FreeBSD 'install' when (umask & 300) != 0.\n-            ;;\n-          *)\n-            tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$\n-            trap 'ret=$?; rmdir \"$tmpdir/d\" \"$tmpdir\" 2>/dev/null; exit $ret' 0\n-\n-            if (umask $mkdir_umask &&\n-                exec $mkdirprog $mkdir_mode -p -- \"$tmpdir/d\") >/dev/null 2>&1\n-            then\n-              if test -z \"$dir_arg\" || {\n-                   # Check for POSIX incompatibilities with -m.\n-                   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or\n-                   # other-writable bit of parent directory when it shouldn't.\n-                   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.\n-                   ls_ld_tmpdir=`ls -ld \"$tmpdir\"`\n-                   case $ls_ld_tmpdir in\n-                     d????-?r-*) different_mode=700;;\n-                     d????-?--*) different_mode=755;;\n-                     *) false;;\n-                   esac &&\n-                   $mkdirprog -m$different_mode -p -- \"$tmpdir\" && {\n-                     ls_ld_tmpdir_1=`ls -ld \"$tmpdir\"`\n-                     test \"$ls_ld_tmpdir\" = \"$ls_ld_tmpdir_1\"\n-                   }\n-                 }\n-              then posix_mkdir=:\n-              fi\n-              rmdir \"$tmpdir/d\" \"$tmpdir\"\n-            else\n-              # Remove any dirs left behind by ancient mkdir implementations.\n-              rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null\n-            fi\n-            trap '' 0;;\n-        esac;;\n-    esac\n-\n-    if\n-      $posix_mkdir && (\n-        umask $mkdir_umask &&\n-        $doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\"\n-      )\n-    then :\n-    else\n-\n-      # The umask is ridiculous, or mkdir does not conform to POSIX,\n-      # or it failed possibly due to a race condition.  Create the\n-      # directory the slow way, step by step, checking for races as we go.\n-\n-      case $dstdir in\n-        /*) prefix='/';;\n-        [-=\\(\\)!]*) prefix='./';;\n-        *)  prefix='';;\n-      esac\n-\n-      oIFS=$IFS\n-      IFS=/\n-      set -f\n-      set fnord $dstdir\n-      shift\n-      set +f\n-      IFS=$oIFS\n-\n-      prefixes=\n-\n-      for d\n-      do\n-        test X\"$d\" = X && continue\n-\n-        prefix=$prefix$d\n-        if test -d \"$prefix\"; then\n-          prefixes=\n-        else\n-          if $posix_mkdir; then\n-            (umask=$mkdir_umask &&\n-             $doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\") && break\n-            # Don't fail if two instances are running concurrently.\n-            test -d \"$prefix\" || exit 1\n-          else\n-            case $prefix in\n-              *\\'*) qprefix=`echo \"$prefix\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;;\n-              *) qprefix=$prefix;;\n-            esac\n-            prefixes=\"$prefixes '$qprefix'\"\n-          fi\n-        fi\n-        prefix=$prefix/\n-      done\n-\n-      if test -n \"$prefixes\"; then\n-        # Don't fail if two instances are running concurrently.\n-        (umask $mkdir_umask &&\n-         eval \"\\$doit_exec \\$mkdirprog $prefixes\") ||\n-          test -d \"$dstdir\" || exit 1\n-        obsolete_mkdir_used=true\n-      fi\n-    fi\n-  fi\n-\n-  if test -n \"$dir_arg\"; then\n-    { test -z \"$chowncmd\" || $doit $chowncmd \"$dst\"; } &&\n-    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dst\"; } &&\n-    { test \"$obsolete_mkdir_used$chowncmd$chgrpcmd\" = false ||\n-      test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dst\"; } || exit 1\n-  else\n-\n-    # Make a couple of temp file names in the proper directory.\n-    dsttmp=$dstdir/_inst.$$_\n-    rmtmp=$dstdir/_rm.$$_\n-\n-    # Trap to clean up those temp files at exit.\n-    trap 'ret=$?; rm -f \"$dsttmp\" \"$rmtmp\" && exit $ret' 0\n-\n-    # Copy the file name to the temp name.\n-    (umask $cp_umask && $doit_exec $cpprog \"$src\" \"$dsttmp\") &&\n-\n-    # and set any options; do chmod last to preserve setuid bits.\n-    #\n-    # If any of these fail, we abort the whole thing.  If we want to\n-    # ignore errors from any of these, just make sure not to ignore\n-    # errors from the above \"$doit $cpprog $src $dsttmp\" command.\n-    #\n-    { test -z \"$chowncmd\" || $doit $chowncmd \"$dsttmp\"; } &&\n-    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dsttmp\"; } &&\n-    { test -z \"$stripcmd\" || $doit $stripcmd \"$dsttmp\"; } &&\n-    { test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dsttmp\"; } &&\n-\n-    # If -C, don't bother to copy if it wouldn't change the file.\n-    if $copy_on_change &&\n-       old=`LC_ALL=C ls -dlL \"$dst\"     2>/dev/null` &&\n-       new=`LC_ALL=C ls -dlL \"$dsttmp\"  2>/dev/null` &&\n-       set -f &&\n-       set X $old && old=:$2:$4:$5:$6 &&\n-       set X $new && new=:$2:$4:$5:$6 &&\n-       set +f &&\n-       test \"$old\" = \"$new\" &&\n-       $cmpprog \"$dst\" \"$dsttmp\" >/dev/null 2>&1\n-    then\n-      rm -f \"$dsttmp\"\n-    else\n-      # Rename the file to the real destination.\n-      $doit $mvcmd -f \"$dsttmp\" \"$dst\" 2>/dev/null ||\n-\n-      # The rename failed, perhaps because mv can't rename something else\n-      # to itself, or perhaps because mv is so ancient that it does not\n-      # support -f.\n-      {\n-        # Now remove or move aside any old file at destination location.\n-        # We try this two ways since rm can't unlink itself on some\n-        # systems and the destination file might be busy for other\n-        # reasons.  In this case, the final cleanup might fail but the new\n-        # file should still install successfully.\n-        {\n-          test ! -f \"$dst\" ||\n-          $doit $rmcmd -f \"$dst\" 2>/dev/null ||\n-          { $doit $mvcmd -f \"$dst\" \"$rmtmp\" 2>/dev/null &&\n-            { $doit $rmcmd -f \"$rmtmp\" 2>/dev/null; :; }\n-          } ||\n-          { echo \"$0: cannot unlink or rename $dst\" >&2\n-            (exit 1); exit 1\n-          }\n-        } &&\n-\n-        # Now rename the file to the real destination.\n-        $doit $mvcmd \"$dsttmp\" \"$dst\"\n-      }\n-    fi || exit 1\n-\n-    trap '' 0\n-  fi\n-done\n-\n-# Local variables:\n-# eval: (add-hook 'write-file-hooks 'time-stamp)\n-# time-stamp-start: \"scriptversion=\"\n-# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n-# time-stamp-time-zone: \"UTC\"\n-# time-stamp-end: \"; # UTC\"\n-# End:"}, {"sha": "73728da3f5664db0306a9ffd6e23066fff2df45d", "filename": "src/libbacktrace/internal.h", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finternal.h?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,294 +0,0 @@\n-/* internal.h -- Internal header file for stack backtrace library.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#ifndef BACKTRACE_INTERNAL_H\n-#define BACKTRACE_INTERNAL_H\n-\n-/* We assume that <sys/types.h> and \"backtrace.h\" have already been\n-   included.  */\n-\n-#ifndef GCC_VERSION\n-# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n-#endif\n-\n-#if (GCC_VERSION < 2007)\n-# define __attribute__(x)\n-#endif\n-\n-#ifndef ATTRIBUTE_UNUSED\n-# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n-#endif\n-\n-#ifndef ATTRIBUTE_MALLOC\n-# if (GCC_VERSION >= 2096)\n-#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))\n-# else\n-#  define ATTRIBUTE_MALLOC\n-# endif\n-#endif\n-\n-#ifndef HAVE_SYNC_FUNCTIONS\n-\n-/* Define out the sync functions.  These should never be called if\n-   they are not available.  */\n-\n-#define __sync_bool_compare_and_swap(A, B, C) (abort(), 1)\n-#define __sync_lock_test_and_set(A, B) (abort(), 0)\n-#define __sync_lock_release(A) abort()\n-\n-#endif /* !defined (HAVE_SYNC_FUNCTIONS) */\n-\n-#ifdef HAVE_ATOMIC_FUNCTIONS\n-\n-/* We have the atomic builtin functions.  */\n-\n-#define backtrace_atomic_load_pointer(p) \\\n-    __atomic_load_n ((p), __ATOMIC_ACQUIRE)\n-#define backtrace_atomic_load_int(p) \\\n-    __atomic_load_n ((p), __ATOMIC_ACQUIRE)\n-#define backtrace_atomic_store_pointer(p, v) \\\n-    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n-#define backtrace_atomic_store_size_t(p, v) \\\n-    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n-#define backtrace_atomic_store_int(p, v) \\\n-    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n-\n-#else /* !defined (HAVE_ATOMIC_FUNCTIONS) */\n-#ifdef HAVE_SYNC_FUNCTIONS\n-\n-/* We have the sync functions but not the atomic functions.  Define\n-   the atomic ones in terms of the sync ones.  */\n-\n-extern void *backtrace_atomic_load_pointer (void *);\n-extern int backtrace_atomic_load_int (int *);\n-extern void backtrace_atomic_store_pointer (void *, void *);\n-extern void backtrace_atomic_store_size_t (size_t *, size_t);\n-extern void backtrace_atomic_store_int (int *, int);\n-\n-#else /* !defined (HAVE_SYNC_FUNCTIONS) */\n-\n-/* We have neither the sync nor the atomic functions.  These will\n-   never be called.  */\n-\n-#define backtrace_atomic_load_pointer(p) (abort(), (void *) NULL)\n-#define backtrace_atomic_load_int(p) (abort(), 0)\n-#define backtrace_atomic_store_pointer(p, v) abort()\n-#define backtrace_atomic_store_size_t(p, v) abort()\n-#define backtrace_atomic_store_int(p, v) abort()\n-\n-#endif /* !defined (HAVE_SYNC_FUNCTIONS) */\n-#endif /* !defined (HAVE_ATOMIC_FUNCTIONS) */\n-\n-/* The type of the function that collects file/line information.  This\n-   is like backtrace_pcinfo.  */\n-\n-typedef int (*fileline) (struct backtrace_state *state, uintptr_t pc,\n-\t\t\t backtrace_full_callback callback,\n-\t\t\t backtrace_error_callback error_callback, void *data);\n-\n-/* The type of the function that collects symbol information.  This is\n-   like backtrace_syminfo.  */\n-\n-typedef void (*syminfo) (struct backtrace_state *state, uintptr_t pc,\n-\t\t\t backtrace_syminfo_callback callback,\n-\t\t\t backtrace_error_callback error_callback, void *data);\n-\n-/* What the backtrace state pointer points to.  */\n-\n-struct backtrace_state\n-{\n-  /* The name of the executable.  */\n-  const char *filename;\n-  /* Non-zero if threaded.  */\n-  int threaded;\n-  /* The master lock for fileline_fn, fileline_data, syminfo_fn,\n-     syminfo_data, fileline_initialization_failed and everything the\n-     data pointers point to.  */\n-  void *lock;\n-  /* The function that returns file/line information.  */\n-  fileline fileline_fn;\n-  /* The data to pass to FILELINE_FN.  */\n-  void *fileline_data;\n-  /* The function that returns symbol information.  */\n-  syminfo syminfo_fn;\n-  /* The data to pass to SYMINFO_FN.  */\n-  void *syminfo_data;\n-  /* Whether initializing the file/line information failed.  */\n-  int fileline_initialization_failed;\n-  /* The lock for the freelist.  */\n-  int lock_alloc;\n-  /* The freelist when using mmap.  */\n-  struct backtrace_freelist_struct *freelist;\n-};\n-\n-/* Open a file for reading.  Returns -1 on error.  If DOES_NOT_EXIST\n-   is not NULL, *DOES_NOT_EXIST will be set to 0 normally and set to 1\n-   if the file does not exist.  If the file does not exist and\n-   DOES_NOT_EXIST is not NULL, the function will return -1 and will\n-   not call ERROR_CALLBACK.  On other errors, or if DOES_NOT_EXIST is\n-   NULL, the function will call ERROR_CALLBACK before returning.  */\n-extern int backtrace_open (const char *filename,\n-\t\t\t   backtrace_error_callback error_callback,\n-\t\t\t   void *data,\n-\t\t\t   int *does_not_exist);\n-\n-/* A view of the contents of a file.  This supports mmap when\n-   available.  A view will remain in memory even after backtrace_close\n-   is called on the file descriptor from which the view was\n-   obtained.  */\n-\n-struct backtrace_view\n-{\n-  /* The data that the caller requested.  */\n-  const void *data;\n-  /* The base of the view.  */\n-  void *base;\n-  /* The total length of the view.  */\n-  size_t len;\n-};\n-\n-/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  Store the\n-   result in *VIEW.  Returns 1 on success, 0 on error.  */\n-extern int backtrace_get_view (struct backtrace_state *state, int descriptor,\n-\t\t\t       off_t offset, size_t size,\n-\t\t\t       backtrace_error_callback error_callback,\n-\t\t\t       void *data, struct backtrace_view *view);\n-\n-/* Release a view created by backtrace_get_view.  */\n-extern void backtrace_release_view (struct backtrace_state *state,\n-\t\t\t\t    struct backtrace_view *view,\n-\t\t\t\t    backtrace_error_callback error_callback,\n-\t\t\t\t    void *data);\n-\n-/* Close a file opened by backtrace_open.  Returns 1 on success, 0 on\n-   error.  */\n-\n-extern int backtrace_close (int descriptor,\n-\t\t\t    backtrace_error_callback error_callback,\n-\t\t\t    void *data);\n-\n-/* Sort without using memory.  */\n-\n-extern void backtrace_qsort (void *base, size_t count, size_t size,\n-\t\t\t     int (*compar) (const void *, const void *));\n-\n-/* Allocate memory.  This is like malloc.  If ERROR_CALLBACK is NULL,\n-   this does not report an error, it just returns NULL.  */\n-\n-extern void *backtrace_alloc (struct backtrace_state *state, size_t size,\n-\t\t\t      backtrace_error_callback error_callback,\n-\t\t\t      void *data) ATTRIBUTE_MALLOC;\n-\n-/* Free memory allocated by backtrace_alloc.  If ERROR_CALLBACK is\n-   NULL, this does not report an error.  */\n-\n-extern void backtrace_free (struct backtrace_state *state, void *mem,\n-\t\t\t    size_t size,\n-\t\t\t    backtrace_error_callback error_callback,\n-\t\t\t    void *data);\n-\n-/* A growable vector of some struct.  This is used for more efficient\n-   allocation when we don't know the final size of some group of data\n-   that we want to represent as an array.  */\n-\n-struct backtrace_vector\n-{\n-  /* The base of the vector.  */\n-  void *base;\n-  /* The number of bytes in the vector.  */\n-  size_t size;\n-  /* The number of bytes available at the current allocation.  */\n-  size_t alc;\n-};\n-\n-/* Grow VEC by SIZE bytes.  Return a pointer to the newly allocated\n-   bytes.  Note that this may move the entire vector to a new memory\n-   location.  Returns NULL on failure.  */\n-\n-extern void *backtrace_vector_grow (struct backtrace_state *state, size_t size,\n-\t\t\t\t    backtrace_error_callback error_callback,\n-\t\t\t\t    void *data,\n-\t\t\t\t    struct backtrace_vector *vec);\n-\n-/* Finish the current allocation on VEC.  Prepare to start a new\n-   allocation.  The finished allocation will never be freed.  Returns\n-   a pointer to the base of the finished entries, or NULL on\n-   failure.  */\n-\n-extern void* backtrace_vector_finish (struct backtrace_state *state,\n-\t\t\t\t      struct backtrace_vector *vec,\n-\t\t\t\t      backtrace_error_callback error_callback,\n-\t\t\t\t      void *data);\n-\n-/* Release any extra space allocated for VEC.  This may change\n-   VEC->base.  Returns 1 on success, 0 on failure.  */\n-\n-extern int backtrace_vector_release (struct backtrace_state *state,\n-\t\t\t\t     struct backtrace_vector *vec,\n-\t\t\t\t     backtrace_error_callback error_callback,\n-\t\t\t\t     void *data);\n-\n-/* Read initial debug data from a descriptor, and set the\n-   fileline_data, syminfo_fn, and syminfo_data fields of STATE.\n-   Return the fileln_fn field in *FILELN_FN--this is done this way so\n-   that the synchronization code is only implemented once.  This is\n-   called after the descriptor has first been opened.  It will close\n-   the descriptor if it is no longer needed.  Returns 1 on success, 0\n-   on error.  There will be multiple implementations of this function,\n-   for different file formats.  Each system will compile the\n-   appropriate one.  */\n-\n-extern int backtrace_initialize (struct backtrace_state *state,\n-\t\t\t\t int descriptor,\n-\t\t\t\t backtrace_error_callback error_callback,\n-\t\t\t\t void *data,\n-\t\t\t\t fileline *fileline_fn);\n-\n-/* Add file/line information for a DWARF module.  */\n-\n-extern int backtrace_dwarf_add (struct backtrace_state *state,\n-\t\t\t\tuintptr_t base_address,\n-\t\t\t\tconst unsigned char* dwarf_info,\n-\t\t\t\tsize_t dwarf_info_size,\n-\t\t\t\tconst unsigned char *dwarf_line,\n-\t\t\t\tsize_t dwarf_line_size,\n-\t\t\t\tconst unsigned char *dwarf_abbrev,\n-\t\t\t\tsize_t dwarf_abbrev_size,\n-\t\t\t\tconst unsigned char *dwarf_ranges,\n-\t\t\t\tsize_t dwarf_range_size,\n-\t\t\t\tconst unsigned char *dwarf_str,\n-\t\t\t\tsize_t dwarf_str_size,\n-\t\t\t\tint is_bigendian,\n-\t\t\t\tbacktrace_error_callback error_callback,\n-\t\t\t\tvoid *data, fileline *fileline_fn);\n-\n-#endif"}, {"sha": "fd23815fc617a5cb8f77cdc4e95a3d177db97cbb", "filename": "src/libbacktrace/ltmain.sh", "status": "removed", "additions": 0, "deletions": 8636, "changes": 8636, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fltmain.sh?ref=20af72b943527d584df4b99e157262f9b297b3e4"}, {"sha": "ba7f94c079f8a8e3c227093524d8a725b1978ae9", "filename": "src/libbacktrace/macho.c", "status": "removed", "additions": 0, "deletions": 1416, "changes": 1416, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fmacho.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fmacho.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmacho.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,1416 +0,0 @@\n-/* macho.c -- Get debug data from an Mach-O file for backtraces.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by John Colanduoni.\n-\n-   Pending upstream pull request:\n-   https://github.com/ianlancetaylor/libbacktrace/pull/2\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.\n-\n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-/* We can't use autotools to detect the pointer width of our program because\n-   we may be building a fat Mach-O file containing both 32-bit and 64-bit\n-   variants. However Mach-O runs a limited set of platforms so detection\n-   via preprocessor is not difficult.  */\n-\n-#if defined(__MACH__)\n-#if defined(__LP64__)\n-#define BACKTRACE_BITS 64\n-#else\n-#define BACKTRACE_BITS 32\n-#endif\n-#else\n-#error Attempting to build Mach-O support on incorrect platform\n-#endif\n-\n-#if defined(__x86_64__)\n-#define NATIVE_CPU_TYPE CPU_TYPE_X86_64\n-#elif defined(__i386__)\n-#define NATIVE_CPU_TYPE CPU_TYPE_X86\n-#elif defined(__aarch64__)\n-#define NATIVE_CPU_TYPE CPU_TYPE_ARM64\n-#elif defined(__arm__)\n-#define NATIVE_CPU_TYPE CPU_TYPE_ARM\n-#else\n-#error Could not detect native Mach-O cpu_type_t\n-#endif\n-\n-#include <sys/types.h>\n-#include <sys/syslimits.h>\n-#include <string.h>\n-#include <mach-o/loader.h>\n-#include <mach-o/nlist.h>\n-#include <mach-o/fat.h>\n-#include <mach-o/dyld.h>\n-#include <uuid/uuid.h>\n-#include <dirent.h>\n-#include <stdlib.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-struct macho_commands_view\n-{\n-    struct backtrace_view view;\n-    uint32_t commands_count;\n-    uint32_t commands_total_size;\n-    int bytes_swapped;\n-    size_t base_offset;\n-};\n-\n-enum debug_section\n-{\n-    DEBUG_INFO,\n-    DEBUG_LINE,\n-    DEBUG_ABBREV,\n-    DEBUG_RANGES,\n-    DEBUG_STR,\n-    DEBUG_MAX\n-};\n-\n-static const char *const debug_section_names[DEBUG_MAX] =\n-    {\n-        \"__debug_info\",\n-        \"__debug_line\",\n-        \"__debug_abbrev\",\n-        \"__debug_ranges\",\n-        \"__debug_str\"\n-    };\n-\n-struct found_dwarf_section\n-{\n-    uint32_t file_offset;\n-    uintptr_t file_size;\n-    const unsigned char *data;\n-};\n-\n-/* Mach-O symbols don't have a length. As a result we have to infer it\n-   by sorting the symbol addresses for each image and recording the\n-   memory range attributed to each image.  */\n-struct macho_symbol\n-{\n-    uintptr_t addr;\n-    size_t size;\n-    const char *name;\n-};\n-\n-struct macho_syminfo_data\n-{\n-    struct macho_syminfo_data *next;\n-    struct macho_symbol *symbols;\n-    size_t symbol_count;\n-    uintptr_t min_addr;\n-    uintptr_t max_addr;\n-};\n-\n-uint16_t\n-macho_file_to_host_u16 (int file_bytes_swapped, uint16_t input)\n-{\n-  if (file_bytes_swapped)\n-    return (input >> 8) | (input << 8);\n-  else\n-    return input;\n-}\n-\n-uint32_t\n-macho_file_to_host_u32 (int file_bytes_swapped, uint32_t input)\n-{\n-  if (file_bytes_swapped)\n-    {\n-      return ((input >> 24) & 0x000000FF)\n-             | ((input >> 8) & 0x0000FF00)\n-             | ((input << 8) & 0x00FF0000)\n-             | ((input << 24) & 0xFF000000);\n-    }\n-  else\n-    {\n-      return input;\n-    }\n-}\n-\n-uint64_t\n-macho_file_to_host_u64 (int file_bytes_swapped, uint64_t input)\n-{\n-  if (file_bytes_swapped)\n-    {\n-      return macho_file_to_host_u32 (file_bytes_swapped,\n-                                     (uint32_t) (input >> 32))\n-             | (((uint64_t) macho_file_to_host_u32 (file_bytes_swapped,\n-                                                    (uint32_t) input)) << 32);\n-    }\n-  else\n-    {\n-      return input;\n-    }\n-}\n-\n-#if BACKTRACE_BITS == 64\n-#define macho_file_to_host_usize macho_file_to_host_u64\n-typedef struct mach_header_64 mach_header_native_t;\n-#define LC_SEGMENT_NATIVE LC_SEGMENT_64\n-typedef struct segment_command_64 segment_command_native_t;\n-typedef struct nlist_64 nlist_native_t;\n-typedef struct section_64 section_native_t;\n-#else /* BACKTRACE_BITS == 32 */\n-#define macho_file_to_host_usize macho_file_to_host_u32\n-typedef struct mach_header mach_header_native_t;\n-#define LC_SEGMENT_NATIVE LC_SEGMENT\n-typedef struct segment_command segment_command_native_t;\n-typedef struct nlist nlist_native_t;\n-typedef struct section section_native_t;\n-#endif\n-\n-// Gets a view into a Mach-O image, taking any slice offset into account\n-int\n-macho_get_view (struct backtrace_state *state, int descriptor,\n-                off_t offset, size_t size,\n-                backtrace_error_callback error_callback,\n-                void *data, struct macho_commands_view *commands_view,\n-                struct backtrace_view *view)\n-{\n-  return backtrace_get_view (state, descriptor,\n-                             commands_view->base_offset + offset, size,\n-                             error_callback, data, view);\n-}\n-\n-int\n-macho_get_commands (struct backtrace_state *state, int descriptor,\n-                    backtrace_error_callback error_callback,\n-                    void *data, struct macho_commands_view *commands_view,\n-                    int *incompatible)\n-{\n-  int ret = 0;\n-  int is_fat = 0;\n-  struct backtrace_view file_header_view;\n-  int file_header_view_valid = 0;\n-  struct backtrace_view fat_archs_view;\n-  int fat_archs_view_valid = 0;\n-  const mach_header_native_t *file_header;\n-  uint64_t commands_offset;\n-\n-  *incompatible = 0;\n-\n-  if (!backtrace_get_view (state, descriptor, 0, sizeof (mach_header_native_t),\n-                           error_callback, data, &file_header_view))\n-    goto end;\n-  file_header_view_valid = 1;\n-\n-  switch (*(uint32_t *) file_header_view.data)\n-    {\n-      case MH_MAGIC:\n-        if (BACKTRACE_BITS == 32)\n-          commands_view->bytes_swapped = 0;\n-        else\n-          {\n-            *incompatible = 1;\n-            goto end;\n-          }\n-      break;\n-      case MH_CIGAM:\n-        if (BACKTRACE_BITS == 32)\n-          commands_view->bytes_swapped = 1;\n-        else\n-          {\n-            *incompatible = 1;\n-            goto end;\n-          }\n-      break;\n-      case MH_MAGIC_64:\n-        if (BACKTRACE_BITS == 64)\n-          commands_view->bytes_swapped = 0;\n-        else\n-          {\n-            *incompatible = 1;\n-            goto end;\n-          }\n-      break;\n-      case MH_CIGAM_64:\n-        if (BACKTRACE_BITS == 64)\n-          commands_view->bytes_swapped = 1;\n-        else\n-          {\n-            *incompatible = 1;\n-            goto end;\n-          }\n-      break;\n-      case FAT_MAGIC:\n-        is_fat = 1;\n-        commands_view->bytes_swapped = 0;\n-      break;\n-      case FAT_CIGAM:\n-        is_fat = 1;\n-        commands_view->bytes_swapped = 1;\n-      break;\n-      default:\n-        goto end;\n-    }\n-\n-  if (is_fat)\n-    {\n-      uint32_t native_slice_offset;\n-      size_t archs_total_size;\n-      uint32_t arch_count;\n-      const struct fat_header *fat_header;\n-      const struct fat_arch *archs;\n-      uint32_t i;\n-\n-      fat_header = file_header_view.data;\n-      arch_count =\n-          macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                  fat_header->nfat_arch);\n-\n-      archs_total_size = arch_count * sizeof (struct fat_arch);\n-\n-      if (!backtrace_get_view (state, descriptor, sizeof (struct fat_header),\n-                               archs_total_size, error_callback,\n-                               data, &fat_archs_view))\n-        goto end;\n-      fat_archs_view_valid = 1;\n-\n-      native_slice_offset = 0;\n-      archs = fat_archs_view.data;\n-      for (i = 0; i < arch_count; i++)\n-        {\n-          const struct fat_arch *raw_arch = archs + i;\n-          int cpu_type =\n-              (int) macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                            (uint32_t) raw_arch->cputype);\n-\n-          if (cpu_type == NATIVE_CPU_TYPE)\n-            {\n-              native_slice_offset =\n-                  macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                          raw_arch->offset);\n-\n-              break;\n-            }\n-        }\n-\n-      if (native_slice_offset == 0)\n-        {\n-          *incompatible = 1;\n-          goto end;\n-        }\n-\n-      backtrace_release_view (state, &file_header_view, error_callback, data);\n-      file_header_view_valid = 0;\n-      if (!backtrace_get_view (state, descriptor, native_slice_offset,\n-                               sizeof (mach_header_native_t), error_callback,\n-                               data, &file_header_view))\n-        goto end;\n-      file_header_view_valid = 1;\n-\n-      // The endianness of the slice may be different than the fat image\n-      switch (*(uint32_t *) file_header_view.data)\n-        {\n-          case MH_MAGIC:\n-            if (BACKTRACE_BITS == 32)\n-              commands_view->bytes_swapped = 0;\n-            else\n-              goto end;\n-          break;\n-          case MH_CIGAM:\n-            if (BACKTRACE_BITS == 32)\n-              commands_view->bytes_swapped = 1;\n-            else\n-              goto end;\n-          break;\n-          case MH_MAGIC_64:\n-            if (BACKTRACE_BITS == 64)\n-              commands_view->bytes_swapped = 0;\n-            else\n-              goto end;\n-          break;\n-          case MH_CIGAM_64:\n-            if (BACKTRACE_BITS == 64)\n-              commands_view->bytes_swapped = 1;\n-            else\n-              goto end;\n-          break;\n-          default:\n-            goto end;\n-        }\n-\n-      commands_view->base_offset = native_slice_offset;\n-    }\n-  else\n-    commands_view->base_offset = 0;\n-\n-  file_header = file_header_view.data;\n-  commands_view->commands_count =\n-      macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                              file_header->ncmds);\n-  commands_view->commands_total_size =\n-      macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                              file_header->sizeofcmds);\n-  commands_offset =\n-      commands_view->base_offset + sizeof (mach_header_native_t);\n-\n-  if (!backtrace_get_view (state, descriptor, commands_offset,\n-                           commands_view->commands_total_size, error_callback,\n-                           data, &commands_view->view))\n-    goto end;\n-\n-  ret = 1;\n-\n-end:\n-  if (file_header_view_valid)\n-    backtrace_release_view (state, &file_header_view, error_callback, data);\n-  if (fat_archs_view_valid)\n-    backtrace_release_view (state, &fat_archs_view, error_callback, data);\n-  return ret;\n-}\n-\n-int\n-macho_get_uuid (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-                int descriptor ATTRIBUTE_UNUSED,\n-                backtrace_error_callback error_callback,\n-                void *data, struct macho_commands_view *commands_view,\n-                uuid_t *uuid)\n-{\n-  size_t offset = 0;\n-  uint32_t i = 0;\n-\n-  for (i = 0; i < commands_view->commands_count; i++)\n-    {\n-      const struct load_command *raw_command;\n-      struct load_command command;\n-\n-      if (offset + sizeof (struct load_command)\n-          > commands_view->commands_total_size)\n-        {\n-          error_callback (data,\n-                          \"executable file contains out of range command offset\",\n-                          0);\n-          return 0;\n-        }\n-\n-      raw_command =\n-          commands_view->view.data + offset;\n-      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                            raw_command->cmd);\n-      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                                raw_command->cmdsize);\n-\n-      if (command.cmd == LC_UUID)\n-        {\n-          const struct uuid_command *uuid_command;\n-\n-          if (offset + sizeof (struct uuid_command)\n-              > commands_view->commands_total_size)\n-            {\n-              error_callback (data,\n-                              \"executable file contains out of range command offset\",\n-                              0);\n-              return 0;\n-            }\n-\n-          uuid_command =\n-              (struct uuid_command *) raw_command;\n-          memcpy (uuid, uuid_command->uuid, sizeof (uuid_t));\n-          return 1;\n-        }\n-\n-      offset += command.cmdsize;\n-    }\n-\n-  error_callback (data, \"executable file is missing an identifying UUID\", 0);\n-  return 0;\n-}\n-\n-/* Returns the base address of a Mach-O image, as encoded in the file header.\n- * WARNING: This does not take ASLR into account, which is ubiquitous on recent\n- * Darwin platforms.\n- */\n-int\n-macho_get_addr_range (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-                      int descriptor ATTRIBUTE_UNUSED,\n-                      backtrace_error_callback error_callback,\n-                      void *data, struct macho_commands_view *commands_view,\n-                      uintptr_t *base_address, uintptr_t *max_address)\n-{\n-  size_t offset = 0;\n-  int found_text = 0;\n-  uint32_t i = 0;\n-\n-  *max_address = 0;\n-\n-  for (i = 0; i < commands_view->commands_count; i++)\n-    {\n-      const struct load_command *raw_command;\n-      struct load_command command;\n-\n-      if (offset + sizeof (struct load_command)\n-          > commands_view->commands_total_size)\n-        {\n-          error_callback (data,\n-                          \"executable file contains out of range command offset\",\n-                          0);\n-          return 0;\n-        }\n-\n-      raw_command = commands_view->view.data + offset;\n-      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                            raw_command->cmd);\n-      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                                raw_command->cmdsize);\n-\n-      if (command.cmd == LC_SEGMENT_NATIVE)\n-        {\n-          const segment_command_native_t *raw_segment;\n-          uintptr_t segment_vmaddr;\n-          uintptr_t segment_vmsize;\n-          uintptr_t segment_maxaddr;\n-          uintptr_t text_fileoff;\n-\n-          if (offset + sizeof (segment_command_native_t)\n-              > commands_view->commands_total_size)\n-            {\n-              error_callback (data,\n-                              \"executable file contains out of range command offset\",\n-                              0);\n-              return 0;\n-            }\n-\n-          raw_segment = (segment_command_native_t *) raw_command;\n-\n-          segment_vmaddr = macho_file_to_host_usize (\n-              commands_view->bytes_swapped, raw_segment->vmaddr);\n-          segment_vmsize = macho_file_to_host_usize (\n-              commands_view->bytes_swapped, raw_segment->vmsize);\n-          segment_maxaddr = segment_vmaddr + segment_vmsize;\n-\n-          if (strncmp (raw_segment->segname, \"__TEXT\",\n-                       sizeof (raw_segment->segname)) == 0)\n-            {\n-              text_fileoff = macho_file_to_host_usize (\n-                  commands_view->bytes_swapped, raw_segment->fileoff);\n-              *base_address = segment_vmaddr - text_fileoff;\n-\n-              found_text = 1;\n-            }\n-\n-          if (segment_maxaddr > *max_address)\n-            *max_address = segment_maxaddr;\n-        }\n-\n-      offset += command.cmdsize;\n-    }\n-\n-  if (found_text)\n-    return 1;\n-  else\n-    {\n-      error_callback (data, \"executable is missing __TEXT segment\", 0);\n-      return 0;\n-    }\n-}\n-\n-static int\n-macho_symbol_compare_addr (const void *left_raw, const void *right_raw)\n-{\n-  const struct macho_symbol *left = left_raw;\n-  const struct macho_symbol *right = right_raw;\n-\n-  if (left->addr > right->addr)\n-    return 1;\n-  else if (left->addr < right->addr)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-int\n-macho_symbol_type_relevant (uint8_t type)\n-{\n-  uint8_t type_field = (uint8_t) (type & N_TYPE);\n-\n-  return !(type & N_EXT) &&\n-         (type_field == N_ABS || type_field == N_SECT);\n-}\n-\n-int\n-macho_add_symtab (struct backtrace_state *state,\n-                  backtrace_error_callback error_callback,\n-                  void *data, int descriptor,\n-                  struct macho_commands_view *commands_view,\n-                  uintptr_t base_address, uintptr_t max_image_address,\n-                  intptr_t vmslide, int *found_sym)\n-{\n-  struct macho_syminfo_data *syminfo_data;\n-\n-  int ret = 0;\n-  size_t offset = 0;\n-  struct backtrace_view symtab_view;\n-  int symtab_view_valid = 0;\n-  struct backtrace_view strtab_view;\n-  int strtab_view_valid = 0;\n-  size_t syminfo_index = 0;\n-  size_t function_count = 0;\n-  uint32_t i = 0;\n-  uint32_t j = 0;\n-  uint32_t symtab_index = 0;\n-\n-  *found_sym = 0;\n-\n-  for (i = 0; i < commands_view->commands_count; i++)\n-    {\n-      const struct load_command *raw_command;\n-      struct load_command command;\n-\n-      if (offset + sizeof (struct load_command)\n-          > commands_view->commands_total_size)\n-        {\n-          error_callback (data,\n-                          \"executable file contains out of range command offset\",\n-                          0);\n-          return 0;\n-        }\n-\n-      raw_command = commands_view->view.data + offset;\n-      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                            raw_command->cmd);\n-      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n-                                                raw_command->cmdsize);\n-\n-      if (command.cmd == LC_SYMTAB)\n-        {\n-          const struct symtab_command *symtab_command;\n-          uint32_t symbol_table_offset;\n-          uint32_t symbol_count;\n-          uint32_t string_table_offset;\n-          uint32_t string_table_size;\n-\n-          if (offset + sizeof (struct symtab_command)\n-              > commands_view->commands_total_size)\n-            {\n-              error_callback (data,\n-                              \"executable file contains out of range command offset\",\n-                              0);\n-              return 0;\n-            }\n-\n-          symtab_command = (struct symtab_command *) raw_command;\n-\n-          symbol_table_offset = macho_file_to_host_u32 (\n-              commands_view->bytes_swapped, symtab_command->symoff);\n-          symbol_count = macho_file_to_host_u32 (\n-              commands_view->bytes_swapped, symtab_command->nsyms);\n-          string_table_offset = macho_file_to_host_u32 (\n-              commands_view->bytes_swapped, symtab_command->stroff);\n-          string_table_size = macho_file_to_host_u32 (\n-              commands_view->bytes_swapped, symtab_command->strsize);\n-\n-\n-          if (!macho_get_view (state, descriptor, symbol_table_offset,\n-                               symbol_count * sizeof (nlist_native_t),\n-                               error_callback, data, commands_view,\n-                               &symtab_view))\n-            goto end;\n-          symtab_view_valid = 1;\n-\n-          if (!macho_get_view (state, descriptor, string_table_offset,\n-                               string_table_size, error_callback, data,\n-                               commands_view, &strtab_view))\n-            goto end;\n-          strtab_view_valid = 1;\n-\n-          // Count functions first\n-          for (j = 0; j < symbol_count; j++)\n-            {\n-              const nlist_native_t *raw_sym =\n-                  ((const nlist_native_t *) symtab_view.data) + j;\n-\n-              if (macho_symbol_type_relevant (raw_sym->n_type))\n-                {\n-                  function_count += 1;\n-                }\n-            }\n-\n-          // Allocate space for the:\n-          //  (a) macho_syminfo_data for this image\n-          //  (b) macho_symbol entries\n-          syminfo_data =\n-              backtrace_alloc (state,\n-                               sizeof (struct macho_syminfo_data),\n-                               error_callback, data);\n-          if (syminfo_data == NULL)\n-            goto end;\n-\n-          syminfo_data->symbols = backtrace_alloc (\n-              state, function_count * sizeof (struct macho_symbol),\n-              error_callback, data);\n-          if (syminfo_data->symbols == NULL)\n-            goto end;\n-\n-          syminfo_data->symbol_count = function_count;\n-          syminfo_data->next = NULL;\n-          syminfo_data->min_addr = base_address;\n-          syminfo_data->max_addr = max_image_address;\n-\n-          for (symtab_index = 0;\n-               symtab_index < symbol_count; symtab_index++)\n-            {\n-              const nlist_native_t *raw_sym =\n-                  ((const nlist_native_t *) symtab_view.data) +\n-                  symtab_index;\n-\n-              if (macho_symbol_type_relevant (raw_sym->n_type))\n-                {\n-                  size_t strtab_index;\n-                  const char *name;\n-                  size_t max_len_plus_one;\n-\n-                  syminfo_data->symbols[syminfo_index].addr =\n-                      macho_file_to_host_usize (commands_view->bytes_swapped,\n-                                                raw_sym->n_value) + vmslide;\n-\n-                  strtab_index = macho_file_to_host_u32 (\n-                      commands_view->bytes_swapped,\n-                      raw_sym->n_un.n_strx);\n-\n-                  // Check the range of the supposed \"string\" we've been\n-                  // given\n-                  if (strtab_index >= string_table_size)\n-                    {\n-                      error_callback (\n-                          data,\n-                          \"dSYM file contains out of range string table index\",\n-                          0);\n-                      goto end;\n-                    }\n-\n-                  name = strtab_view.data + strtab_index;\n-                  max_len_plus_one = string_table_size - strtab_index;\n-\n-                  if (strnlen (name, max_len_plus_one) >= max_len_plus_one)\n-                    {\n-                      error_callback (\n-                          data,\n-                          \"dSYM file contains unterminated string\",\n-                          0);\n-                      goto end;\n-                    }\n-\n-                  // Remove underscore prefixes\n-                  if (name[0] == '_')\n-                    {\n-                      name = name + 1;\n-                    }\n-\n-                  syminfo_data->symbols[syminfo_index].name = name;\n-\n-                  syminfo_index += 1;\n-                }\n-            }\n-\n-          backtrace_qsort (syminfo_data->symbols,\n-                           syminfo_data->symbol_count,\n-                           sizeof (struct macho_symbol),\n-                           macho_symbol_compare_addr);\n-\n-          // Calculate symbol sizes\n-          for (syminfo_index = 0;\n-               syminfo_index < syminfo_data->symbol_count; syminfo_index++)\n-            {\n-              if (syminfo_index + 1 < syminfo_data->symbol_count)\n-                {\n-                  syminfo_data->symbols[syminfo_index].size =\n-                      syminfo_data->symbols[syminfo_index + 1].addr -\n-                      syminfo_data->symbols[syminfo_index].addr;\n-                }\n-              else\n-                {\n-                  syminfo_data->symbols[syminfo_index].size =\n-                      max_image_address -\n-                      syminfo_data->symbols[syminfo_index].addr;\n-                }\n-            }\n-\n-          if (!state->threaded)\n-            {\n-              struct macho_syminfo_data **pp;\n-\n-              for (pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n-                   *pp != NULL;\n-                   pp = &(*pp)->next);\n-              *pp = syminfo_data;\n-            }\n-          else\n-            {\n-              while (1)\n-                {\n-                  struct macho_syminfo_data **pp;\n-\n-                  pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n-\n-                  while (1)\n-                    {\n-                      struct macho_syminfo_data *p;\n-\n-                      p = backtrace_atomic_load_pointer (pp);\n-\n-                      if (p == NULL)\n-                        break;\n-\n-                      pp = &p->next;\n-                    }\n-\n-                  if (__sync_bool_compare_and_swap (pp, NULL, syminfo_data))\n-                    break;\n-                }\n-            }\n-\n-          strtab_view_valid = 0; // We need to keep string table around\n-          *found_sym = 1;\n-          ret = 1;\n-          goto end;\n-        }\n-\n-      offset += command.cmdsize;\n-    }\n-\n-  // No symbol table here\n-  ret = 1;\n-  goto end;\n-\n-end:\n-  if (symtab_view_valid)\n-    backtrace_release_view (state, &symtab_view, error_callback, data);\n-  if (strtab_view_valid)\n-    backtrace_release_view (state, &strtab_view, error_callback, data);\n-  return ret;\n-}\n-\n-int\n-macho_try_dwarf (struct backtrace_state *state,\n-                 backtrace_error_callback error_callback,\n-                 void *data, fileline *fileline_fn, uuid_t *executable_uuid,\n-                 uintptr_t base_address, uintptr_t max_image_address,\n-                 intptr_t vmslide, char *dwarf_filename, int *matched,\n-                 int *found_sym, int *found_dwarf)\n-{\n-  uuid_t dwarf_uuid;\n-\n-  int ret = 0;\n-  int dwarf_descriptor;\n-  int dwarf_descriptor_valid = 0;\n-  struct macho_commands_view commands_view;\n-  int commands_view_valid = 0;\n-  struct backtrace_view dwarf_view;\n-  int dwarf_view_valid = 0;\n-  size_t offset = 0;\n-  struct found_dwarf_section dwarf_sections[DEBUG_MAX];\n-  uintptr_t min_dwarf_offset = 0;\n-  uintptr_t max_dwarf_offset = 0;\n-  uint32_t i = 0;\n-  uint32_t j = 0;\n-  int k = 0;\n-\n-  *matched = 0;\n-  *found_sym = 0;\n-  *found_dwarf = 0;\n-\n-  if ((dwarf_descriptor = backtrace_open (dwarf_filename, error_callback,\n-                                          data, NULL)) == 0)\n-    goto end;\n-  dwarf_descriptor_valid = 1;\n-\n-  int incompatible;\n-  if (!macho_get_commands (state, dwarf_descriptor, error_callback, data,\n-                           &commands_view, &incompatible))\n-    {\n-      // Failing to read the header here is fine, because this dSYM may be\n-      // for a different architecture\n-      if (incompatible)\n-        {\n-          ret = 1;\n-        }\n-      goto end;\n-    }\n-  commands_view_valid = 1;\n-\n-  // Get dSYM UUID and compare\n-  if (!macho_get_uuid (state, dwarf_descriptor, error_callback, data,\n-                       &commands_view, &dwarf_uuid))\n-    {\n-      error_callback (data, \"dSYM file is missing an identifying uuid\", 0);\n-      goto end;\n-    }\n-  if (memcmp (executable_uuid, &dwarf_uuid, sizeof (uuid_t)) != 0)\n-    {\n-      // DWARF doesn't belong to desired executable\n-      ret = 1;\n-      goto end;\n-    }\n-\n-  *matched = 1;\n-\n-  // Read symbol table\n-  if (!macho_add_symtab (state, error_callback, data, dwarf_descriptor,\n-                         &commands_view, base_address, max_image_address,\n-                         vmslide, found_sym))\n-    goto end;\n-\n-  // Get DWARF sections\n-\n-  memset (dwarf_sections, 0, sizeof (dwarf_sections));\n-  offset = 0;\n-  for (i = 0; i < commands_view.commands_count; i++)\n-    {\n-      const struct load_command *raw_command;\n-      struct load_command command;\n-\n-      if (offset + sizeof (struct load_command)\n-          > commands_view.commands_total_size)\n-        {\n-          error_callback (data,\n-                          \"dSYM file contains out of range command offset\", 0);\n-          goto end;\n-        }\n-\n-      raw_command = commands_view.view.data + offset;\n-      command.cmd = macho_file_to_host_u32 (commands_view.bytes_swapped,\n-                                            raw_command->cmd);\n-      command.cmdsize = macho_file_to_host_u32 (commands_view.bytes_swapped,\n-                                                raw_command->cmdsize);\n-\n-      if (command.cmd == LC_SEGMENT_NATIVE)\n-        {\n-          uint32_t section_count;\n-          size_t section_offset;\n-          const segment_command_native_t *raw_segment;\n-\n-          if (offset + sizeof (segment_command_native_t)\n-              > commands_view.commands_total_size)\n-            {\n-              error_callback (data,\n-                              \"dSYM file contains out of range command offset\",\n-                              0);\n-              goto end;\n-            }\n-\n-          raw_segment = (const segment_command_native_t *) raw_command;\n-\n-          if (strncmp (raw_segment->segname, \"__DWARF\",\n-                       sizeof (raw_segment->segname)) == 0)\n-            {\n-              section_count = macho_file_to_host_u32 (\n-                  commands_view.bytes_swapped,\n-                  raw_segment->nsects);\n-\n-              section_offset = offset + sizeof (segment_command_native_t);\n-\n-              // Search sections for relevant DWARF section names\n-              for (j = 0; j < section_count; j++)\n-                {\n-                  const section_native_t *raw_section;\n-\n-                  if (section_offset + sizeof (section_native_t) >\n-                      commands_view.commands_total_size)\n-                    {\n-                      error_callback (data,\n-                                      \"dSYM file contains out of range command offset\",\n-                                      0);\n-                      goto end;\n-                    }\n-\n-                  raw_section = commands_view.view.data + section_offset;\n-\n-                  for (k = 0; k < DEBUG_MAX; k++)\n-                    {\n-                      uintptr_t dwarf_section_end;\n-\n-                      if (strncmp (raw_section->sectname,\n-                                   debug_section_names[k],\n-                                   sizeof (raw_section->sectname)) == 0)\n-                        {\n-                          *found_dwarf = 1;\n-\n-                          dwarf_sections[k].file_offset =\n-                              macho_file_to_host_u32 (\n-                                  commands_view.bytes_swapped,\n-                                  raw_section->offset);\n-                          dwarf_sections[k].file_size =\n-                              macho_file_to_host_usize (\n-                                  commands_view.bytes_swapped,\n-                                  raw_section->size);\n-\n-                          if (min_dwarf_offset == 0 ||\n-                              dwarf_sections[k].file_offset <\n-                              min_dwarf_offset)\n-                            min_dwarf_offset = dwarf_sections[k].file_offset;\n-\n-                          dwarf_section_end =\n-                              dwarf_sections[k].file_offset +\n-                              dwarf_sections[k].file_size;\n-                          if (dwarf_section_end > max_dwarf_offset)\n-                            max_dwarf_offset = dwarf_section_end;\n-\n-                          break;\n-                        }\n-                    }\n-\n-                  section_offset += sizeof (section_native_t);\n-                }\n-\n-              break;\n-            }\n-        }\n-\n-      offset += command.cmdsize;\n-    }\n-\n-  if (!*found_dwarf)\n-    {\n-      // No DWARF in this file\n-      ret = 1;\n-      goto end;\n-    }\n-\n-  if (!macho_get_view (state, dwarf_descriptor, (off_t) min_dwarf_offset,\n-                       max_dwarf_offset - min_dwarf_offset, error_callback,\n-                       data, &commands_view, &dwarf_view))\n-    goto end;\n-  dwarf_view_valid = 1;\n-\n-  for (i = 0; i < DEBUG_MAX; i++)\n-    {\n-      if (dwarf_sections[i].file_offset == 0)\n-        dwarf_sections[i].data = NULL;\n-      else\n-        dwarf_sections[i].data =\n-            dwarf_view.data + dwarf_sections[i].file_offset - min_dwarf_offset;\n-    }\n-\n-  if (!backtrace_dwarf_add (state, vmslide,\n-                            dwarf_sections[DEBUG_INFO].data,\n-                            dwarf_sections[DEBUG_INFO].file_size,\n-                            dwarf_sections[DEBUG_LINE].data,\n-                            dwarf_sections[DEBUG_LINE].file_size,\n-                            dwarf_sections[DEBUG_ABBREV].data,\n-                            dwarf_sections[DEBUG_ABBREV].file_size,\n-                            dwarf_sections[DEBUG_RANGES].data,\n-                            dwarf_sections[DEBUG_RANGES].file_size,\n-                            dwarf_sections[DEBUG_STR].data,\n-                            dwarf_sections[DEBUG_STR].file_size,\n-                            ((__DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN)\n-                            ^ commands_view.bytes_swapped),\n-                            error_callback, data, fileline_fn))\n-    goto end;\n-\n-  // Don't release the DWARF view because it is still in use\n-  dwarf_descriptor_valid = 0;\n-  dwarf_view_valid = 0;\n-  ret = 1;\n-\n-end:\n-  if (dwarf_descriptor_valid)\n-    backtrace_close (dwarf_descriptor, error_callback, data);\n-  if (commands_view_valid)\n-    backtrace_release_view (state, &commands_view.view, error_callback, data);\n-  if (dwarf_view_valid)\n-    backtrace_release_view (state, &dwarf_view, error_callback, data);\n-  return ret;\n-}\n-\n-int\n-macho_try_dsym (struct backtrace_state *state,\n-                backtrace_error_callback error_callback,\n-                void *data, fileline *fileline_fn, uuid_t *executable_uuid,\n-                uintptr_t base_address, uintptr_t max_image_address,\n-                intptr_t vmslide, char *dsym_filename, int *matched,\n-                int *found_sym, int *found_dwarf)\n-{\n-  int ret = 0;\n-  char dwarf_image_dir_path[PATH_MAX];\n-  DIR *dwarf_image_dir;\n-  int dwarf_image_dir_valid = 0;\n-  struct dirent *directory_entry;\n-  char dwarf_filename[PATH_MAX];\n-  int dwarf_matched;\n-  int dwarf_had_sym;\n-  int dwarf_had_dwarf;\n-\n-  *matched = 0;\n-  *found_sym = 0;\n-  *found_dwarf = 0;\n-\n-  strncpy (dwarf_image_dir_path, dsym_filename, PATH_MAX);\n-  strncat (dwarf_image_dir_path, \"/Contents/Resources/DWARF\", PATH_MAX);\n-\n-  if (!(dwarf_image_dir = opendir (dwarf_image_dir_path)))\n-    {\n-      error_callback (data, \"could not open DWARF directory in dSYM\",\n-                      0);\n-      goto end;\n-    }\n-  dwarf_image_dir_valid = 1;\n-\n-  while ((directory_entry = readdir (dwarf_image_dir)))\n-    {\n-      if (directory_entry->d_type != DT_REG)\n-        continue;\n-\n-      strncpy (dwarf_filename, dwarf_image_dir_path, PATH_MAX);\n-      strncat (dwarf_filename, \"/\", PATH_MAX);\n-      strncat (dwarf_filename, directory_entry->d_name, PATH_MAX);\n-\n-      if (!macho_try_dwarf (state, error_callback, data, fileline_fn,\n-                            executable_uuid, base_address, max_image_address,\n-                            vmslide, dwarf_filename,\n-                            &dwarf_matched, &dwarf_had_sym, &dwarf_had_dwarf))\n-        goto end;\n-\n-      if (dwarf_matched)\n-        {\n-          *matched = 1;\n-          *found_sym = dwarf_had_sym;\n-          *found_dwarf = dwarf_had_dwarf;\n-          ret = 1;\n-          goto end;\n-        }\n-    }\n-\n-  // No matching DWARF in this dSYM\n-  ret = 1;\n-  goto end;\n-\n-end:\n-  if (dwarf_image_dir_valid)\n-    closedir (dwarf_image_dir);\n-  return ret;\n-}\n-\n-int\n-macho_add (struct backtrace_state *state,\n-           backtrace_error_callback error_callback, void *data, int descriptor,\n-           const char *filename, fileline *fileline_fn, intptr_t vmslide,\n-           int *found_sym, int *found_dwarf)\n-{\n-  uuid_t image_uuid;\n-  uintptr_t image_file_base_address;\n-  uintptr_t image_file_max_address;\n-  uintptr_t image_actual_base_address = 0;\n-  uintptr_t image_actual_max_address = 0;\n-\n-  int ret = 0;\n-  struct macho_commands_view commands_view;\n-  int commands_view_valid = 0;\n-  char executable_dirname[PATH_MAX];\n-  size_t filename_len;\n-  DIR *executable_dir = NULL;\n-  int executable_dir_valid = 0;\n-  struct dirent *directory_entry;\n-  char dsym_full_path[PATH_MAX];\n-  static const char *extension;\n-  size_t extension_len;\n-  ssize_t i;\n-\n-  *found_sym = 0;\n-  *found_dwarf = 0;\n-\n-  // Find Mach-O commands list\n-  int incompatible;\n-  if (!macho_get_commands (state, descriptor, error_callback, data,\n-                           &commands_view, &incompatible))\n-    goto end;\n-  commands_view_valid = 1;\n-\n-  // First we need to get the uuid of our file so we can hunt down the correct\n-  // dSYM\n-  if (!macho_get_uuid (state, descriptor, error_callback, data, &commands_view,\n-                       &image_uuid))\n-    goto end;\n-\n-  // Now we need to find the in memory base address. Step one is to find out\n-  // what the executable thinks the base address is\n-  if (!macho_get_addr_range (state, descriptor, error_callback, data,\n-                             &commands_view,\n-                             &image_file_base_address,\n-                             &image_file_max_address))\n-    goto end;\n-\n-  image_actual_base_address =\n-      image_file_base_address + vmslide;\n-  image_actual_max_address =\n-      image_file_max_address + vmslide;\n-\n-  if (image_actual_base_address == 0)\n-    {\n-      error_callback (data, \"executable file is not loaded\", 0);\n-      goto end;\n-    }\n-\n-  // Look for dSYM in our executable's directory\n-  strncpy (executable_dirname, filename, PATH_MAX);\n-  filename_len = strlen (executable_dirname);\n-  for (i = filename_len - 1; i >= 0; i--)\n-    {\n-      if (executable_dirname[i] == '/')\n-        {\n-          executable_dirname[i] = '\\0';\n-          break;\n-        }\n-      else if (i == 0)\n-        {\n-          executable_dirname[0] = '.';\n-          executable_dirname[1] = '\\0';\n-          break;\n-        }\n-    }\n-\n-  if (!(executable_dir = opendir (executable_dirname)))\n-    {\n-      error_callback (data, \"could not open directory containing executable\",\n-                      0);\n-      goto end;\n-    }\n-  executable_dir_valid = 1;\n-\n-  extension = \".dSYM\";\n-  extension_len = strlen (extension);\n-  while ((directory_entry = readdir (executable_dir)))\n-    {\n-      if (directory_entry->d_namlen < extension_len)\n-        continue;\n-      if (strncasecmp (directory_entry->d_name + directory_entry->d_namlen\n-                       - extension_len, extension, extension_len) == 0)\n-        {\n-          int matched;\n-          int dsym_had_sym;\n-          int dsym_had_dwarf;\n-\n-          // Found a dSYM\n-          strncpy (dsym_full_path, executable_dirname, PATH_MAX);\n-          strncat (dsym_full_path, \"/\", PATH_MAX);\n-          strncat (dsym_full_path, directory_entry->d_name, PATH_MAX);\n-\n-          if (!macho_try_dsym (state, error_callback, data,\n-                               fileline_fn, &image_uuid,\n-                               image_actual_base_address,\n-                               image_actual_max_address, vmslide,\n-                               dsym_full_path,\n-                               &matched, &dsym_had_sym, &dsym_had_dwarf))\n-            goto end;\n-\n-          if (matched)\n-            {\n-              *found_sym = dsym_had_sym;\n-              *found_dwarf = dsym_had_dwarf;\n-              ret = 1;\n-              goto end;\n-            }\n-        }\n-    }\n-\n-  // No matching dSYM\n-  ret = 1;\n-  goto end;\n-\n-end:\n-  if (commands_view_valid)\n-    backtrace_release_view (state, &commands_view.view, error_callback,\n-                            data);\n-  if (executable_dir_valid)\n-    closedir (executable_dir);\n-  return ret;\n-}\n-\n-static int\n-macho_symbol_search (const void *vkey, const void *ventry)\n-{\n-  const uintptr_t *key = (const uintptr_t *) vkey;\n-  const struct macho_symbol *entry = (const struct macho_symbol *) ventry;\n-  uintptr_t addr;\n-\n-  addr = *key;\n-  if (addr < entry->addr)\n-    return -1;\n-  else if (addr >= entry->addr + entry->size)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-static void\n-macho_syminfo (struct backtrace_state *state,\n-               uintptr_t addr,\n-               backtrace_syminfo_callback callback,\n-               backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-               void *data)\n-{\n-  struct macho_syminfo_data *edata;\n-  struct macho_symbol *sym = NULL;\n-\n-  if (!state->threaded)\n-    {\n-      for (edata = (struct macho_syminfo_data *) state->syminfo_data;\n-           edata != NULL;\n-           edata = edata->next)\n-        {\n-          if (addr >= edata->min_addr && addr <= edata->max_addr)\n-            {\n-              sym = ((struct macho_symbol *)\n-                  bsearch (&addr, edata->symbols, edata->symbol_count,\n-                           sizeof (struct macho_symbol), macho_symbol_search));\n-              if (sym != NULL)\n-                break;\n-            }\n-        }\n-    }\n-  else\n-    {\n-      struct macho_syminfo_data **pp;\n-\n-      pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n-      while (1)\n-        {\n-          edata = backtrace_atomic_load_pointer (pp);\n-          if (edata == NULL)\n-            break;\n-\n-          if (addr >= edata->min_addr && addr <= edata->max_addr)\n-            {\n-              sym = ((struct macho_symbol *)\n-                  bsearch (&addr, edata->symbols, edata->symbol_count,\n-                           sizeof (struct macho_symbol), macho_symbol_search));\n-              if (sym != NULL)\n-                break;\n-            }\n-\n-          pp = &edata->next;\n-        }\n-    }\n-\n-  if (sym == NULL)\n-    callback (data, addr, NULL, 0, 0);\n-  else\n-    callback (data, addr, sym->name, sym->addr, sym->size);\n-}\n-\n-\n-static int\n-macho_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-               uintptr_t pc ATTRIBUTE_UNUSED,\n-               backtrace_full_callback callback ATTRIBUTE_UNUSED,\n-               backtrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data, \"no debug info in Mach-O executable\", -1);\n-  return 0;\n-}\n-\n-static void\n-macho_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-              uintptr_t addr ATTRIBUTE_UNUSED,\n-              backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n-              backtrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data, \"no symbol table in Mach-O executable\", -1);\n-}\n-\n-int\n-backtrace_initialize (struct backtrace_state *state, int descriptor,\n-                      backtrace_error_callback error_callback,\n-                      void *data, fileline *fileline_fn)\n-{\n-  int ret;\n-  fileline macho_fileline_fn = macho_nodebug;\n-  int found_sym = 0;\n-  int found_dwarf = 0;\n-  uint32_t i = 0;\n-  uint32_t loaded_image_count;\n-\n-  // Add all loaded images\n-  loaded_image_count = _dyld_image_count ();\n-  for (i = 0; i < loaded_image_count; i++)\n-    {\n-      int current_found_sym;\n-      int current_found_dwarf;\n-      int current_descriptor;\n-      intptr_t current_vmslide;\n-      const char *current_name;\n-\n-      current_vmslide = _dyld_get_image_vmaddr_slide (i);\n-      current_name = _dyld_get_image_name (i);\n-\n-      if (current_name == NULL || (i != 0 && current_vmslide == 0))\n-        continue;\n-\n-      if (!(current_descriptor =\n-                backtrace_open (current_name, error_callback, data, NULL)))\n-        {\n-          continue;\n-        }\n-\n-      if (macho_add (state, error_callback, data, current_descriptor,\n-                      current_name, &macho_fileline_fn, current_vmslide,\n-                      &current_found_sym, &current_found_dwarf))\n-        {\n-          found_sym = found_sym || current_found_sym;\n-          found_dwarf = found_dwarf || current_found_dwarf;\n-        }\n-\n-      backtrace_close (current_descriptor, error_callback, data);\n-    }\n-\n-  if (!state->threaded)\n-    {\n-      if (found_sym)\n-        state->syminfo_fn = macho_syminfo;\n-      else if (state->syminfo_fn == NULL)\n-        state->syminfo_fn = macho_nosyms;\n-    }\n-  else\n-    {\n-      if (found_sym)\n-        backtrace_atomic_store_pointer (&state->syminfo_fn, macho_syminfo);\n-      else\n-        (void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n-                                             macho_nosyms);\n-    }\n-\n-  if (!state->threaded)\n-    {\n-      if (state->fileline_fn == NULL || state->fileline_fn == macho_nodebug)\n-        *fileline_fn = macho_fileline_fn;\n-    }\n-  else\n-    {\n-      fileline current_fn;\n-\n-      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n-      if (current_fn == NULL || current_fn == macho_nodebug)\n-        *fileline_fn = macho_fileline_fn;\n-    }\n-\n-  return 1;\n-}\n-"}, {"sha": "138ef70711a02597b6e843516d84c687f9aef753", "filename": "src/libbacktrace/mmap.c", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fmmap.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmap.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,303 +0,0 @@\n-/* mmap.c -- Memory allocation with mmap.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <errno.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include <sys/types.h>\n-#include <sys/mman.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* Memory allocation on systems that provide anonymous mmap.  This\n-   permits the backtrace functions to be invoked from a signal\n-   handler, assuming that mmap is async-signal safe.  */\n-\n-#ifndef MAP_ANONYMOUS\n-#define MAP_ANONYMOUS MAP_ANON\n-#endif\n-\n-#ifndef MAP_FAILED\n-#define MAP_FAILED ((void *)-1)\n-#endif\n-\n-/* A list of free memory blocks.  */\n-\n-struct backtrace_freelist_struct\n-{\n-  /* Next on list.  */\n-  struct backtrace_freelist_struct *next;\n-  /* Size of this block, including this structure.  */\n-  size_t size;\n-};\n-\n-/* Free memory allocated by backtrace_alloc.  */\n-\n-static void\n-backtrace_free_locked (struct backtrace_state *state, void *addr, size_t size)\n-{\n-  /* Just leak small blocks.  We don't have to be perfect.  */\n-  if (size >= sizeof (struct backtrace_freelist_struct))\n-    {\n-      struct backtrace_freelist_struct *p;\n-\n-      p = (struct backtrace_freelist_struct *) addr;\n-      p->next = state->freelist;\n-      p->size = size;\n-      state->freelist = p;\n-    }\n-}\n-\n-/* Allocate memory like malloc.  If ERROR_CALLBACK is NULL, don't\n-   report an error.  */\n-\n-void *\n-backtrace_alloc (struct backtrace_state *state,\n-\t\t size_t size, backtrace_error_callback error_callback,\n-\t\t void *data)\n-{\n-  void *ret;\n-  int locked;\n-  struct backtrace_freelist_struct **pp;\n-  size_t pagesize;\n-  size_t asksize;\n-  void *page;\n-\n-  ret = NULL;\n-\n-  /* If we can acquire the lock, then see if there is space on the\n-     free list.  If we can't acquire the lock, drop straight into\n-     using mmap.  __sync_lock_test_and_set returns the old state of\n-     the lock, so we have acquired it if it returns 0.  */\n-\n-  if (!state->threaded)\n-    locked = 1;\n-  else\n-    locked = __sync_lock_test_and_set (&state->lock_alloc, 1) == 0;\n-\n-  if (locked)\n-    {\n-      for (pp = &state->freelist; *pp != NULL; pp = &(*pp)->next)\n-\t{\n-\t  if ((*pp)->size >= size)\n-\t    {\n-\t      struct backtrace_freelist_struct *p;\n-\n-\t      p = *pp;\n-\t      *pp = p->next;\n-\n-\t      /* Round for alignment; we assume that no type we care about\n-\t\t is more than 8 bytes.  */\n-\t      size = (size + 7) & ~ (size_t) 7;\n-\t      if (size < p->size)\n-\t\tbacktrace_free_locked (state, (char *) p + size,\n-\t\t\t\t       p->size - size);\n-\n-\t      ret = (void *) p;\n-\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (state->threaded)\n-\t__sync_lock_release (&state->lock_alloc);\n-    }\n-\n-  if (ret == NULL)\n-    {\n-      /* Allocate a new page.  */\n-\n-      pagesize = getpagesize ();\n-      asksize = (size + pagesize - 1) & ~ (pagesize - 1);\n-      page = mmap (NULL, asksize, PROT_READ | PROT_WRITE,\n-\t\t   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n-      if (page == MAP_FAILED)\n-\t{\n-\t  if (error_callback)\n-\t    error_callback (data, \"mmap\", errno);\n-\t}\n-      else\n-\t{\n-\t  size = (size + 7) & ~ (size_t) 7;\n-\t  if (size < asksize)\n-\t    backtrace_free (state, (char *) page + size, asksize - size,\n-\t\t\t    error_callback, data);\n-\n-\t  ret = page;\n-\t}\n-    }\n-\n-  return ret;\n-}\n-\n-/* Free memory allocated by backtrace_alloc.  */\n-\n-void\n-backtrace_free (struct backtrace_state *state, void *addr, size_t size,\n-\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t\tvoid *data ATTRIBUTE_UNUSED)\n-{\n-  int locked;\n-\n-  /* If we are freeing a large aligned block, just release it back to\n-     the system.  This case arises when growing a vector for a large\n-     binary with lots of debug info.  Calling munmap here may cause us\n-     to call mmap again if there is also a large shared library; we\n-     just live with that.  */\n-  if (size >= 16 * 4096)\n-    {\n-      size_t pagesize;\n-\n-      pagesize = getpagesize ();\n-      if (((uintptr_t) addr & (pagesize - 1)) == 0\n-\t  && (size & (pagesize - 1)) == 0)\n-\t{\n-\t  /* If munmap fails for some reason, just add the block to\n-\t     the freelist.  */\n-\t  if (munmap (addr, size) == 0)\n-\t    return;\n-\t}\n-    }\n-\n-  /* If we can acquire the lock, add the new space to the free list.\n-     If we can't acquire the lock, just leak the memory.\n-     __sync_lock_test_and_set returns the old state of the lock, so we\n-     have acquired it if it returns 0.  */\n-\n-  if (!state->threaded)\n-    locked = 1;\n-  else\n-    locked = __sync_lock_test_and_set (&state->lock_alloc, 1) == 0;\n-\n-  if (locked)\n-    {\n-      backtrace_free_locked (state, addr, size);\n-\n-      if (state->threaded)\n-\t__sync_lock_release (&state->lock_alloc);\n-    }\n-}\n-\n-/* Grow VEC by SIZE bytes.  */\n-\n-void *\n-backtrace_vector_grow (struct backtrace_state *state,size_t size,\n-\t\t       backtrace_error_callback error_callback,\n-\t\t       void *data, struct backtrace_vector *vec)\n-{\n-  void *ret;\n-\n-  if (size > vec->alc)\n-    {\n-      size_t pagesize;\n-      size_t alc;\n-      void *base;\n-\n-      pagesize = getpagesize ();\n-      alc = vec->size + size;\n-      if (vec->size == 0)\n-\talc = 16 * size;\n-      else if (alc < pagesize)\n-\t{\n-\t  alc *= 2;\n-\t  if (alc > pagesize)\n-\t    alc = pagesize;\n-\t}\n-      else\n-\t{\n-\t  alc *= 2;\n-\t  alc = (alc + pagesize - 1) & ~ (pagesize - 1);\n-\t}\n-      base = backtrace_alloc (state, alc, error_callback, data);\n-      if (base == NULL)\n-\treturn NULL;\n-      if (vec->base != NULL)\n-\t{\n-\t  memcpy (base, vec->base, vec->size);\n-\t  backtrace_free (state, vec->base, vec->size + vec->alc,\n-\t\t\t  error_callback, data);\n-\t}\n-      vec->base = base;\n-      vec->alc = alc - vec->size;\n-    }\n-\n-  ret = (char *) vec->base + vec->size;\n-  vec->size += size;\n-  vec->alc -= size;\n-  return ret;\n-}\n-\n-/* Finish the current allocation on VEC.  */\n-\n-void *\n-backtrace_vector_finish (\n-  struct backtrace_state *state ATTRIBUTE_UNUSED,\n-  struct backtrace_vector *vec,\n-  backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-  void *data ATTRIBUTE_UNUSED)\n-{\n-  void *ret;\n-\n-  ret = vec->base;\n-  vec->base = (char *) vec->base + vec->size;\n-  vec->size = 0;\n-  return ret;\n-}\n-\n-/* Release any extra space allocated for VEC.  */\n-\n-int\n-backtrace_vector_release (struct backtrace_state *state,\n-\t\t\t  struct backtrace_vector *vec,\n-\t\t\t  backtrace_error_callback error_callback,\n-\t\t\t  void *data)\n-{\n-  size_t size;\n-  size_t alc;\n-  size_t aligned;\n-\n-  /* Make sure that the block that we free is aligned on an 8-byte\n-     boundary.  */\n-  size = vec->size;\n-  alc = vec->alc;\n-  aligned = (size + 7) & ~ (size_t) 7;\n-  alc -= aligned - size;\n-\n-  backtrace_free (state, (char *) vec->base + aligned, alc,\n-\t\t  error_callback, data);\n-  vec->alc = 0;\n-  return 1;\n-}"}, {"sha": "dfdaf6fa52e6e774c1c59e5b4509b8c54a7e110a", "filename": "src/libbacktrace/mmapio.c", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fmmapio.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fmmapio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmapio.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,100 +0,0 @@\n-/* mmapio.c -- File views using mmap.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <errno.h>\n-#include <sys/types.h>\n-#include <sys/mman.h>\n-#include <unistd.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-#ifndef MAP_FAILED\n-#define MAP_FAILED ((void *)-1)\n-#endif\n-\n-/* This file implements file views and memory allocation when mmap is\n-   available.  */\n-\n-/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */\n-\n-int\n-backtrace_get_view (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t    int descriptor, off_t offset, size_t size,\n-\t\t    backtrace_error_callback error_callback,\n-\t\t    void *data, struct backtrace_view *view)\n-{\n-  size_t pagesize;\n-  unsigned int inpage;\n-  off_t pageoff;\n-  void *map;\n-\n-  pagesize = getpagesize ();\n-  inpage = offset % pagesize;\n-  pageoff = offset - inpage;\n-\n-  size += inpage;\n-  size = (size + (pagesize - 1)) & ~ (pagesize - 1);\n-\n-  map = mmap (NULL, size, PROT_READ, MAP_PRIVATE, descriptor, pageoff);\n-  if (map == MAP_FAILED)\n-    {\n-      error_callback (data, \"mmap\", errno);\n-      return 0;\n-    }\n-\n-  view->data = (char *) map + inpage;\n-  view->base = map;\n-  view->len = size;\n-\n-  return 1;\n-}\n-\n-/* Release a view read by backtrace_get_view.  */\n-\n-void\n-backtrace_release_view (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t\tstruct backtrace_view *view,\n-\t\t\tbacktrace_error_callback error_callback,\n-\t\t\tvoid *data)\n-{\n-  union {\n-    const void *cv;\n-    void *v;\n-  } const_cast;\n-\n-  const_cast.cv = view->base;\n-  if (munmap (const_cast.v, view->len) < 0)\n-    error_callback (data, \"munmap\", errno);\n-}"}, {"sha": "448a2049f1d1b46aa393f3b17e60d9a799181fc4", "filename": "src/libbacktrace/nounwind.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fnounwind.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fnounwind.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fnounwind.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,66 +0,0 @@\n-/* backtrace.c -- Entry point for stack backtrace library.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-\n-#include \"internal.h\"\n-\n-/* This source file is compiled if the unwind library is not\n-   available.  */\n-\n-int\n-backtrace_full (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\tint skip ATTRIBUTE_UNUSED,\n-\t\tbacktrace_full_callback callback ATTRIBUTE_UNUSED,\n-\t\tbacktrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data,\n-\t\t  \"no stack trace because unwind library not available\",\n-\t\t  0);\n-  return 0;\n-}\n-\n-int\n-backtrace_simple (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t  int skip ATTRIBUTE_UNUSED,\n-\t\t  backtrace_simple_callback callback ATTRIBUTE_UNUSED,\n-\t\t  backtrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data,\n-\t\t  \"no stack trace because unwind library not available\",\n-\t\t  0);\n-  return 0;\n-}"}, {"sha": "2d6a9877219dcacac0a2fe31f6c4fe83193804e1", "filename": "src/libbacktrace/pecoff.c", "status": "removed", "additions": 0, "deletions": 942, "changes": 942, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fpecoff.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fpecoff.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fpecoff.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,942 +0,0 @@\n-/* pecoff.c -- Get debug data from a PE/COFFF file for backtraces.\n-   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n-   Adapted from elf.c by Tristan Gingold, AdaCore.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.\n-\n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* Coff file header.  */\n-\n-typedef struct {\n-  uint16_t machine;\n-  uint16_t number_of_sections;\n-  uint32_t time_date_stamp;\n-  uint32_t pointer_to_symbol_table;\n-  uint32_t number_of_symbols;\n-  uint16_t size_of_optional_header;\n-  uint16_t characteristics;\n-} b_coff_file_header;\n-\n-/* Coff optional header.  */\n-\n-typedef struct {\n-  uint16_t magic;\n-  uint8_t  major_linker_version;\n-  uint8_t  minor_linker_version;\n-  uint32_t size_of_code;\n-  uint32_t size_of_initialized_data;\n-  uint32_t size_of_uninitialized_data;\n-  uint32_t address_of_entry_point;\n-  uint32_t base_of_code;\n-  union {\n-    struct {\n-      uint32_t base_of_data;\n-      uint32_t image_base;\n-    } pe;\n-    struct {\n-      uint64_t image_base;\n-    } pep;\n-  } u;\n-} b_coff_optional_header;\n-\n-/* Values of magic in optional header.  */\n-\n-#define PE_MAGIC 0x10b\t\t/* PE32 executable.  */\n-#define PEP_MAGIC 0x20b\t\t/* PE32+ executable (for 64bit targets).  */\n-\n-/* Coff section header.  */\n-\n-typedef struct {\n-  char name[8];\n-  uint32_t virtual_size;\n-  uint32_t virtual_address;\n-  uint32_t size_of_raw_data;\n-  uint32_t pointer_to_raw_data;\n-  uint32_t pointer_to_relocations;\n-  uint32_t pointer_to_line_numbers;\n-  uint16_t number_of_relocations;\n-  uint16_t number_of_line_numbers;\n-  uint32_t characteristics;\n-} b_coff_section_header;\n-\n-/* Coff symbol name.  */\n-\n-typedef union {\n-  char short_name[8];\n-  struct {\n-    unsigned char zeroes[4];\n-    unsigned char off[4];\n-  } long_name;\n-} b_coff_name;\n-\n-/* Coff symbol (external representation which is unaligned).  */\n-\n-typedef struct {\n-  b_coff_name name;\n-  unsigned char value[4];\n-  unsigned char section_number[2];\n-  unsigned char type[2];\n-  unsigned char storage_class;\n-  unsigned char number_of_aux_symbols;\n-} b_coff_external_symbol;\n-\n-/* Symbol types.  */\n-\n-#define N_TBSHFT 4\t\t\t/* Shift for the derived type.  */\n-#define IMAGE_SYM_DTYPE_FUNCTION 2\t/* Function derived type.  */\n-\n-/* Size of a coff symbol.  */\n-\n-#define SYM_SZ 18\n-\n-/* Coff symbol, internal representation (aligned).  */\n-\n-typedef struct {\n-  const char *name;\n-  uint32_t value;\n-  int16_t sec;\n-  uint16_t type;\n-  uint16_t sc;\n-} b_coff_internal_symbol;\n-\n-/* An index of sections we care about.  */\n-\n-enum debug_section\n-{\n-  DEBUG_INFO,\n-  DEBUG_LINE,\n-  DEBUG_ABBREV,\n-  DEBUG_RANGES,\n-  DEBUG_STR,\n-  DEBUG_MAX\n-};\n-\n-/* Names of sections, indexed by enum debug_section.  */\n-\n-static const char * const debug_section_names[DEBUG_MAX] =\n-{\n-  \".debug_info\",\n-  \".debug_line\",\n-  \".debug_abbrev\",\n-  \".debug_ranges\",\n-  \".debug_str\"\n-};\n-\n-/* Information we gather for the sections we care about.  */\n-\n-struct debug_section_info\n-{\n-  /* Section file offset.  */\n-  off_t offset;\n-  /* Section size.  */\n-  size_t size;\n-  /* Section contents, after read from file.  */\n-  const unsigned char *data;\n-};\n-\n-/* Information we keep for an coff symbol.  */\n-\n-struct coff_symbol\n-{\n-  /* The name of the symbol.  */\n-  const char *name;\n-  /* The address of the symbol.  */\n-  uintptr_t address;\n-};\n-\n-/* Information to pass to coff_syminfo.  */\n-\n-struct coff_syminfo_data\n-{\n-  /* Symbols for the next module.  */\n-  struct coff_syminfo_data *next;\n-  /* The COFF symbols, sorted by address.  */\n-  struct coff_symbol *symbols;\n-  /* The number of symbols.  */\n-  size_t count;\n-};\n-\n-/* A dummy callback function used when we can't find any debug info.  */\n-\n-static int\n-coff_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t      uintptr_t pc ATTRIBUTE_UNUSED,\n-\t      backtrace_full_callback callback ATTRIBUTE_UNUSED,\n-\t      backtrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data, \"no debug info in PE/COFF executable\", -1);\n-  return 0;\n-}\n-\n-/* A dummy callback function used when we can't find a symbol\n-   table.  */\n-\n-static void\n-coff_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t     uintptr_t addr ATTRIBUTE_UNUSED,\n-\t     backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n-\t     backtrace_error_callback error_callback, void *data)\n-{\n-  error_callback (data, \"no symbol table in PE/COFF executable\", -1);\n-}\n-\n-/* Read a potentially unaligned 4 byte word at P, using native endianness.  */\n-\n-static uint32_t\n-coff_read4 (const unsigned char *p)\n-{\n-  uint32_t res;\n-\n-  memcpy (&res, p, 4);\n-  return res;\n-}\n-\n-/* Read a potentially unaligned 2 byte word at P, using native endianness.\n-   All 2 byte word in symbols are always aligned, but for coherency all\n-   fields are declared as char arrays.  */\n-\n-static uint16_t\n-coff_read2 (const unsigned char *p)\n-{\n-  uint16_t res;\n-\n-  memcpy (&res, p, sizeof (res));\n-  return res;\n-}\n-\n-/* Return the length (without the trailing 0) of a COFF short name.  */\n-\n-static size_t\n-coff_short_name_len (const char *name)\n-{\n-  int i;\n-\n-  for (i = 0; i < 8; i++)\n-    if (name[i] == 0)\n-      return i;\n-  return 8;\n-}\n-\n-/* Return true iff COFF short name CNAME is the same as NAME (a NUL-terminated\n-   string).  */\n-\n-static int\n-coff_short_name_eq (const char *name, const char *cname)\n-{\n-  int i;\n-\n-  for (i = 0; i < 8; i++)\n-    {\n-      if (name[i] != cname[i])\n-\treturn 0;\n-      if (name[i] == 0)\n-\treturn 1;\n-    }\n-  return name[8] == 0;\n-}\n-\n-/* Return true iff NAME is the same as string at offset OFF.  */\n-\n-static int\n-coff_long_name_eq (const char *name, unsigned int off,\n-\t\t   struct backtrace_view *str_view)\n-{\n-  if (off >= str_view->len)\n-    return 0;\n-  return strcmp (name, (const char *)str_view->data + off) == 0;\n-}\n-\n-/* Compare struct coff_symbol for qsort.  */\n-\n-static int\n-coff_symbol_compare (const void *v1, const void *v2)\n-{\n-  const struct coff_symbol *e1 = (const struct coff_symbol *) v1;\n-  const struct coff_symbol *e2 = (const struct coff_symbol *) v2;\n-\n-  if (e1->address < e2->address)\n-    return -1;\n-  else if (e1->address > e2->address)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Convert SYM to internal (and aligned) format ISYM, using string table\n-   from STRTAB and STRTAB_SIZE, and number of sections SECTS_NUM.\n-   Return -1 in case of error (invalid section number or string index).  */\n-\n-static int\n-coff_expand_symbol (b_coff_internal_symbol *isym,\n-\t\t    const b_coff_external_symbol *sym,\n-\t\t    uint16_t sects_num,\n-\t\t    const unsigned char *strtab, size_t strtab_size)\n-{\n-  isym->type = coff_read2 (sym->type);\n-  isym->sec = coff_read2 (sym->section_number);\n-  isym->sc = sym->storage_class;\n-\n-  if (isym->sec > 0 && (uint16_t) isym->sec > sects_num)\n-    return -1;\n-  if (sym->name.short_name[0] != 0)\n-    isym->name = sym->name.short_name;\n-  else\n-    {\n-      uint32_t off = coff_read4 (sym->name.long_name.off);\n-\n-      if (off >= strtab_size)\n-\treturn -1;\n-      isym->name = (const char *) strtab + off;\n-    }\n-  return 0;\n-}\n-\n-/* Return true iff SYM is a defined symbol for a function.  Data symbols\n-   aren't considered because they aren't easily identified (same type as\n-   section names, presence of symbols defined by the linker script).  */\n-\n-static int\n-coff_is_function_symbol (const b_coff_internal_symbol *isym)\n-{\n-  return (isym->type >> N_TBSHFT) == IMAGE_SYM_DTYPE_FUNCTION\n-    && isym->sec > 0;\n-}\n-\n-/* Initialize the symbol table info for coff_syminfo.  */\n-\n-static int\n-coff_initialize_syminfo (struct backtrace_state *state,\n-\t\t\t uintptr_t base_address,\n-\t\t\t const b_coff_section_header *sects, size_t sects_num,\n-\t\t\t const b_coff_external_symbol *syms, size_t syms_size,\n-\t\t\t const unsigned char *strtab, size_t strtab_size,\n-\t\t\t backtrace_error_callback error_callback,\n-\t\t\t void *data, struct coff_syminfo_data *sdata)\n-{\n-  size_t syms_count;\n-  char *coff_symstr;\n-  size_t coff_symstr_len;\n-  size_t coff_symbol_count;\n-  size_t coff_symbol_size;\n-  struct coff_symbol *coff_symbols;\n-  struct coff_symbol *coff_sym;\n-  char *coff_str;\n-  size_t i;\n-\n-  syms_count = syms_size / SYM_SZ;\n-\n-  /* We only care about function symbols.  Count them.  Also count size of\n-     strings for in-symbol names.  */\n-  coff_symbol_count = 0;\n-  coff_symstr_len = 0;\n-  for (i = 0; i < syms_count; ++i)\n-    {\n-      const b_coff_external_symbol *asym = &syms[i];\n-      b_coff_internal_symbol isym;\n-\n-      if (coff_expand_symbol (&isym, asym, sects_num, strtab, strtab_size) < 0)\n-\t{\n-\t  error_callback (data, \"invalid section or offset in coff symbol\", 0);\n-\t  return 0;\n-\t}\n-      if (coff_is_function_symbol (&isym))\n-\t{\n-\t  ++coff_symbol_count;\n-\t  if (asym->name.short_name[0] != 0)\n-\t    coff_symstr_len += coff_short_name_len (asym->name.short_name) + 1;\n-\t}\n-\n-      i += asym->number_of_aux_symbols;\n-    }\n-\n-  coff_symbol_size = (coff_symbol_count + 1) * sizeof (struct coff_symbol);\n-  coff_symbols = ((struct coff_symbol *)\n-\t\t  backtrace_alloc (state, coff_symbol_size, error_callback,\n-\t\t\t\t   data));\n-  if (coff_symbols == NULL)\n-    return 0;\n-\n-  /* Allocate memory for symbols strings.  */\n-  if (coff_symstr_len > 0)\n-    {\n-      coff_symstr = ((char *)\n-\t\t     backtrace_alloc (state, coff_symstr_len, error_callback,\n-\t\t\t\t      data));\n-      if (coff_symstr == NULL)\n-\t{\n-\t  backtrace_free (state, coff_symbols, coff_symbol_size,\n-\t\t\t  error_callback, data);\n-\t  return 0;\n-\t}\n-    }\n-  else\n-    coff_symstr = NULL;\n-\n-  /* Copy symbols.  */\n-  coff_sym = coff_symbols;\n-  coff_str = coff_symstr;\n-  for (i = 0; i < syms_count; ++i)\n-    {\n-      const b_coff_external_symbol *asym = &syms[i];\n-      b_coff_internal_symbol isym;\n-\n-      if (coff_expand_symbol (&isym, asym, sects_num, strtab, strtab_size))\n-\t{\n-\t  /* Should not fail, as it was already tested in the previous\n-\t     loop.  */\n-\t  abort ();\n-\t}\n-      if (coff_is_function_symbol (&isym))\n-\t{\n-\t  const char *name;\n-\t  int16_t secnum;\n-\n-\t  if (asym->name.short_name[0] != 0)\n-\t    {\n-\t      size_t len = coff_short_name_len (isym.name);\n-\t      name = coff_str;\n-\t      memcpy (coff_str, isym.name, len);\n-\t      coff_str[len] = 0;\n-\t      coff_str += len + 1;\n-\t    }\n-\t  else\n-\t    name = isym.name;\n-\n-\t  /* Strip leading '_'.  */\n-\t  if (name[0] == '_')\n-\t    name++;\n-\n-\t  /* Symbol value is section relative, so we need to read the address\n-\t     of its section.  */\n-\t  secnum = coff_read2 (asym->section_number);\n-\n-\t  coff_sym->name = name;\n-\t  coff_sym->address = (coff_read4 (asym->value)\n-\t\t\t       + sects[secnum - 1].virtual_address\n-\t\t\t       + base_address);\n-\t  coff_sym++;\n-\t}\n-\n-      i += asym->number_of_aux_symbols;\n-    }\n-\n-  /* End of symbols marker.  */\n-  coff_sym->name = NULL;\n-  coff_sym->address = -1;\n-\n-  backtrace_qsort (coff_symbols, coff_symbol_count,\n-\t\t   sizeof (struct coff_symbol), coff_symbol_compare);\n-\n-  sdata->next = NULL;\n-  sdata->symbols = coff_symbols;\n-  sdata->count = coff_symbol_count;\n-\n-  return 1;\n-}\n-\n-/* Add EDATA to the list in STATE.  */\n-\n-static void\n-coff_add_syminfo_data (struct backtrace_state *state,\n-\t\t       struct coff_syminfo_data *sdata)\n-{\n-  if (!state->threaded)\n-    {\n-      struct coff_syminfo_data **pp;\n-\n-      for (pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n-\t   *pp != NULL;\n-\t   pp = &(*pp)->next)\n-\t;\n-      *pp = sdata;\n-    }\n-  else\n-    {\n-      while (1)\n-\t{\n-\t  struct coff_syminfo_data **pp;\n-\n-\t  pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n-\n-\t  while (1)\n-\t    {\n-\t      struct coff_syminfo_data *p;\n-\n-\t      p = backtrace_atomic_load_pointer (pp);\n-\n-\t      if (p == NULL)\n-\t\tbreak;\n-\n-\t      pp = &p->next;\n-\t    }\n-\n-\t  if (__sync_bool_compare_and_swap (pp, NULL, sdata))\n-\t    break;\n-\t}\n-    }\n-}\n-\n-/* Compare an ADDR against an elf_symbol for bsearch.  We allocate one\n-   extra entry in the array so that this can look safely at the next\n-   entry.  */\n-\n-static int\n-coff_symbol_search (const void *vkey, const void *ventry)\n-{\n-  const uintptr_t *key = (const uintptr_t *) vkey;\n-  const struct coff_symbol *entry = (const struct coff_symbol *) ventry;\n-  uintptr_t addr;\n-\n-  addr = *key;\n-  if (addr < entry->address)\n-    return -1;\n-  else if (addr >= entry[1].address)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Return the symbol name and value for an ADDR.  */\n-\n-static void\n-coff_syminfo (struct backtrace_state *state, uintptr_t addr,\n-\t      backtrace_syminfo_callback callback,\n-\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t      void *data)\n-{\n-  struct coff_syminfo_data *sdata;\n-  struct coff_symbol *sym = NULL;\n-\n-  if (!state->threaded)\n-    {\n-      for (sdata = (struct coff_syminfo_data *) state->syminfo_data;\n-\t   sdata != NULL;\n-\t   sdata = sdata->next)\n-\t{\n-\t  sym = ((struct coff_symbol *)\n-\t\t bsearch (&addr, sdata->symbols, sdata->count,\n-\t\t\t  sizeof (struct coff_symbol), coff_symbol_search));\n-\t  if (sym != NULL)\n-\t    break;\n-\t}\n-    }\n-  else\n-    {\n-      struct coff_syminfo_data **pp;\n-\n-      pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n-      while (1)\n-\t{\n-\t  sdata = backtrace_atomic_load_pointer (pp);\n-\t  if (sdata == NULL)\n-\t    break;\n-\n-\t  sym = ((struct coff_symbol *)\n-\t\t bsearch (&addr, sdata->symbols, sdata->count,\n-\t\t\t  sizeof (struct coff_symbol), coff_symbol_search));\n-\t  if (sym != NULL)\n-\t    break;\n-\n-\t  pp = &sdata->next;\n-\t}\n-    }\n-\n-  if (sym == NULL)\n-    callback (data, addr, NULL, 0, 0);\n-  else\n-    callback (data, addr, sym->name, sym->address, 0);\n-}\n-\n-/* Add the backtrace data for one PE/COFF file.  Returns 1 on success,\n-   0 on failure (in both cases descriptor is closed).  */\n-\n-static int\n-coff_add (struct backtrace_state *state, int descriptor,\n-\t  backtrace_error_callback error_callback, void *data,\n-\t  fileline *fileline_fn, int *found_sym, int *found_dwarf)\n-{\n-  struct backtrace_view fhdr_view;\n-  off_t fhdr_off;\n-  int magic_ok;\n-  b_coff_file_header fhdr;\n-  off_t opt_sects_off;\n-  size_t opt_sects_size;\n-  unsigned int sects_num;\n-  struct backtrace_view sects_view;\n-  int sects_view_valid;\n-  const b_coff_optional_header *opt_hdr;\n-  const b_coff_section_header *sects;\n-  struct backtrace_view str_view;\n-  int str_view_valid;\n-  // NOTE: upstream this is a `size_t` but this was fixed in Rust commit\n-  //       55e2b7e1b, see #33729 for more info. If you see this in a diff\n-  //       against the upstream libbacktrace, that's what's going on.\n-  uint32_t str_size;\n-  off_t str_off;\n-  // NOTE: upstream doesn't have `{0}`, this is a fix for Rust issue #39468.\n-  //       If syms_view is not initialized, then `free(syms_view.base)` may segfault later.\n-  struct backtrace_view syms_view = {0};\n-  off_t syms_off;\n-  size_t syms_size;\n-  int syms_view_valid;\n-  unsigned int syms_num;\n-  unsigned int i;\n-  struct debug_section_info sections[DEBUG_MAX];\n-  off_t min_offset;\n-  off_t max_offset;\n-  struct backtrace_view debug_view;\n-  int debug_view_valid;\n-  uintptr_t image_base;\n-\n-  *found_sym = 0;\n-  *found_dwarf = 0;\n-\n-  sects_view_valid = 0;\n-  syms_view_valid = 0;\n-  str_view_valid = 0;\n-  debug_view_valid = 0;\n-\n-  /* Map the MS-DOS stub (if any) and extract file header offset.  */\n-  if (!backtrace_get_view (state, descriptor, 0, 0x40, error_callback,\n-\t\t\t   data, &fhdr_view))\n-    goto fail;\n-\n-  {\n-    const char *vptr = (const char *)fhdr_view.data;\n-\n-    if (vptr[0] == 'M' && vptr[1] == 'Z')\n-      memcpy (&fhdr_off, vptr + 0x3c, 4);\n-    else\n-      fhdr_off = 0;\n-  }\n-\n-  backtrace_release_view (state, &fhdr_view, error_callback, data);\n-\n-  /* Map the coff file header.  */\n-  if (!backtrace_get_view (state, descriptor, fhdr_off,\n-\t\t\t   sizeof (b_coff_file_header) + 4,\n-\t\t\t   error_callback, data, &fhdr_view))\n-    goto fail;\n-\n-  if (fhdr_off != 0)\n-    {\n-      const char *magic = (const char *) fhdr_view.data;\n-      magic_ok = memcmp (magic, \"PE\\0\", 4) == 0;\n-      fhdr_off += 4;\n-\n-      memcpy (&fhdr, fhdr_view.data + 4, sizeof fhdr);\n-    }\n-  else\n-    {\n-      memcpy (&fhdr, fhdr_view.data, sizeof fhdr);\n-      /* TODO: test fhdr.machine for coff but non-PE platforms.  */\n-      magic_ok = 0;\n-    }\n-  backtrace_release_view (state, &fhdr_view, error_callback, data);\n-\n-  if (!magic_ok)\n-    {\n-      error_callback (data, \"executable file is not COFF\", 0);\n-      goto fail;\n-    }\n-\n-  sects_num = fhdr.number_of_sections;\n-  syms_num = fhdr.number_of_symbols;\n-\n-  opt_sects_off = fhdr_off + sizeof (fhdr);\n-  opt_sects_size = (fhdr.size_of_optional_header\n-\t\t    + sects_num * sizeof (b_coff_section_header));\n-\n-  /* To translate PC to file/line when using DWARF, we need to find\n-     the .debug_info and .debug_line sections.  */\n-\n-  /* Read the optional header and the section headers.  */\n-\n-  if (!backtrace_get_view (state, descriptor, opt_sects_off, opt_sects_size,\n-\t\t\t   error_callback, data, &sects_view))\n-    goto fail;\n-  sects_view_valid = 1;\n-  opt_hdr = (const b_coff_optional_header *) sects_view.data;\n-  sects = (const b_coff_section_header *)\n-    (sects_view.data + fhdr.size_of_optional_header);\n-\n-  if (fhdr.size_of_optional_header > sizeof (*opt_hdr))\n-    {\n-      if (opt_hdr->magic == PE_MAGIC)\n-\timage_base = opt_hdr->u.pe.image_base;\n-      else if (opt_hdr->magic == PEP_MAGIC)\n-\timage_base = opt_hdr->u.pep.image_base;\n-      else\n-\t{\n-\t  error_callback (data, \"bad magic in PE optional header\", 0);\n-\t  goto fail;\n-\t}\n-    }\n-  else\n-    image_base = 0;\n-\n-  /* Read the symbol table and the string table.  */\n-\n-  if (fhdr.pointer_to_symbol_table == 0)\n-    {\n-      /* No symbol table, no string table.  */\n-      str_off = 0;\n-      str_size = 0;\n-      syms_num = 0;\n-      syms_size = 0;\n-    }\n-  else\n-    {\n-      /* Symbol table is followed by the string table.  The string table\n-\t starts with its length (on 4 bytes).\n-\t Map the symbol table and the length of the string table.  */\n-      syms_off = fhdr.pointer_to_symbol_table;\n-      syms_size = syms_num * SYM_SZ;\n-\n-      if (!backtrace_get_view (state, descriptor, syms_off, syms_size + 4,\n-\t\t\t       error_callback, data, &syms_view))\n-\tgoto fail;\n-      syms_view_valid = 1;\n-\n-      memcpy (&str_size, syms_view.data + syms_size, 4);\n-\n-      str_off = syms_off + syms_size;\n-\n-      if (str_size > 4)\n-\t{\n-\t  /* Map string table (including the length word).  */\n-\n-\t  if (!backtrace_get_view (state, descriptor, str_off, str_size,\n-\t\t\t\t   error_callback, data, &str_view))\n-\t    goto fail;\n-\t  str_view_valid = 1;\n-\t}\n-    }\n-\n-  memset (sections, 0, sizeof sections);\n-\n-  /* Look for the symbol table.  */\n-  for (i = 0; i < sects_num; ++i)\n-    {\n-      const b_coff_section_header *s = sects + i;\n-      unsigned int str_off;\n-      int j;\n-\n-      if (s->name[0] == '/')\n-\t{\n-\t  /* Extended section name.  */\n-\t  str_off = atoi (s->name + 1);\n-\t}\n-      else\n-\tstr_off = 0;\n-\n-      for (j = 0; j < (int) DEBUG_MAX; ++j)\n-\t{\n-\t  const char *dbg_name = debug_section_names[j];\n-\t  int match;\n-\n-\t  if (str_off != 0)\n-\t    match = coff_long_name_eq (dbg_name, str_off, &str_view);\n-\t  else\n-\t    match = coff_short_name_eq (dbg_name, s->name);\n-\t  if (match)\n-\t    {\n-\t      sections[j].offset = s->pointer_to_raw_data;\n-\t      sections[j].size = s->virtual_size <= s->size_of_raw_data ?\n-\t\ts->virtual_size : s->size_of_raw_data;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  if (syms_num != 0)\n-    {\n-      struct coff_syminfo_data *sdata;\n-\n-      sdata = ((struct coff_syminfo_data *)\n-\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n-      if (sdata == NULL)\n-\tgoto fail;\n-\n-      if (!coff_initialize_syminfo (state, image_base,\n-\t\t\t\t    sects, sects_num,\n-\t\t\t\t    syms_view.data, syms_size,\n-\t\t\t\t    str_view.data, str_size,\n-\t\t\t\t    error_callback, data, sdata))\n-\t{\n-\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n-\t  goto fail;\n-\t}\n-\n-      *found_sym = 1;\n-\n-      coff_add_syminfo_data (state, sdata);\n-    }\n-\n-  backtrace_release_view (state, &sects_view, error_callback, data);\n-  sects_view_valid = 0;\n-  backtrace_release_view (state, &syms_view, error_callback, data);\n-  syms_view_valid = 0;\n-\n-  /* Read all the debug sections in a single view, since they are\n-     probably adjacent in the file.  We never release this view.  */\n-\n-  min_offset = 0;\n-  max_offset = 0;\n-  for (i = 0; i < (int) DEBUG_MAX; ++i)\n-    {\n-      off_t end;\n-\n-      if (sections[i].size == 0)\n-\tcontinue;\n-      if (min_offset == 0 || sections[i].offset < min_offset)\n-\tmin_offset = sections[i].offset;\n-      end = sections[i].offset + sections[i].size;\n-      if (end > max_offset)\n-\tmax_offset = end;\n-    }\n-  if (min_offset == 0 || max_offset == 0)\n-    {\n-      if (!backtrace_close (descriptor, error_callback, data))\n-\tgoto fail;\n-      *fileline_fn = coff_nodebug;\n-      return 1;\n-    }\n-\n-  if (!backtrace_get_view (state, descriptor, min_offset,\n-\t\t\t   max_offset - min_offset,\n-\t\t\t   error_callback, data, &debug_view))\n-    goto fail;\n-  debug_view_valid = 1;\n-\n-  /* We've read all we need from the executable.  */\n-  if (!backtrace_close (descriptor, error_callback, data))\n-    goto fail;\n-  descriptor = -1;\n-\n-  for (i = 0; i < (int) DEBUG_MAX; ++i)\n-    {\n-      if (sections[i].size == 0)\n-\tsections[i].data = NULL;\n-      else\n-\tsections[i].data = ((const unsigned char *) debug_view.data\n-\t\t\t    + (sections[i].offset - min_offset));\n-    }\n-\n-  if (!backtrace_dwarf_add (state, /* base_address */ 0,\n-\t\t\t    sections[DEBUG_INFO].data,\n-\t\t\t    sections[DEBUG_INFO].size,\n-\t\t\t    sections[DEBUG_LINE].data,\n-\t\t\t    sections[DEBUG_LINE].size,\n-\t\t\t    sections[DEBUG_ABBREV].data,\n-\t\t\t    sections[DEBUG_ABBREV].size,\n-\t\t\t    sections[DEBUG_RANGES].data,\n-\t\t\t    sections[DEBUG_RANGES].size,\n-\t\t\t    sections[DEBUG_STR].data,\n-\t\t\t    sections[DEBUG_STR].size,\n-\t\t\t    0, /* FIXME */\n-\t\t\t    error_callback, data, fileline_fn))\n-    goto fail;\n-\n-  *found_dwarf = 1;\n-\n-  return 1;\n-\n- fail:\n-  if (sects_view_valid)\n-    backtrace_release_view (state, &sects_view, error_callback, data);\n-  if (str_view_valid)\n-    backtrace_release_view (state, &str_view, error_callback, data);\n-  if (syms_view_valid)\n-    backtrace_release_view (state, &syms_view, error_callback, data);\n-  if (debug_view_valid)\n-    backtrace_release_view (state, &debug_view, error_callback, data);\n-  if (descriptor != -1)\n-    backtrace_close (descriptor, error_callback, data);\n-  return 0;\n-}\n-\n-/* Initialize the backtrace data we need from an ELF executable.  At\n-   the ELF level, all we need to do is find the debug info\n-   sections.  */\n-\n-int\n-backtrace_initialize (struct backtrace_state *state, int descriptor,\n-\t\t      backtrace_error_callback error_callback,\n-\t\t      void *data, fileline *fileline_fn)\n-{\n-  int ret;\n-  int found_sym;\n-  int found_dwarf;\n-  fileline coff_fileline_fn;\n-\n-  ret = coff_add (state, descriptor, error_callback, data,\n-\t\t  &coff_fileline_fn, &found_sym, &found_dwarf);\n-  if (!ret)\n-    return 0;\n-\n-  if (!state->threaded)\n-    {\n-      if (found_sym)\n-\tstate->syminfo_fn = coff_syminfo;\n-      else if (state->syminfo_fn == NULL)\n-\tstate->syminfo_fn = coff_nosyms;\n-    }\n-  else\n-    {\n-      if (found_sym)\n-\tbacktrace_atomic_store_pointer (&state->syminfo_fn, coff_syminfo);\n-      else\n-\t__sync_bool_compare_and_swap (&state->syminfo_fn, NULL, coff_nosyms);\n-    }\n-\n-  if (!state->threaded)\n-    {\n-      if (state->fileline_fn == NULL || state->fileline_fn == coff_nodebug)\n-\t*fileline_fn = coff_fileline_fn;\n-    }\n-  else\n-    {\n-      fileline current_fn;\n-\n-      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n-      if (current_fn == NULL || current_fn == coff_nodebug)\n-\t*fileline_fn = coff_fileline_fn;\n-    }\n-\n-  return 1;\n-}"}, {"sha": "09f5e95a6e42d824b1ef09d3d4ff489e61644f58", "filename": "src/libbacktrace/posix.c", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fposix.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fposix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fposix.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,100 +0,0 @@\n-/* posix.c -- POSIX file I/O routines for the backtrace library.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <errno.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-#include <unistd.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-#ifndef O_BINARY\n-#define O_BINARY 0\n-#endif\n-\n-#ifndef O_CLOEXEC\n-#define O_CLOEXEC 0\n-#endif\n-\n-#ifndef FD_CLOEXEC\n-#define FD_CLOEXEC 1\n-#endif\n-\n-/* Open a file for reading.  */\n-\n-int\n-backtrace_open (const char *filename, backtrace_error_callback error_callback,\n-\t\tvoid *data, int *does_not_exist)\n-{\n-  int descriptor;\n-\n-  if (does_not_exist != NULL)\n-    *does_not_exist = 0;\n-\n-  descriptor = open (filename, (int) (O_RDONLY | O_BINARY | O_CLOEXEC));\n-  if (descriptor < 0)\n-    {\n-      if (does_not_exist != NULL && errno == ENOENT)\n-\t*does_not_exist = 1;\n-      else\n-\terror_callback (data, filename, errno);\n-      return -1;\n-    }\n-\n-#ifdef HAVE_FCNTL\n-  /* Set FD_CLOEXEC just in case the kernel does not support\n-     O_CLOEXEC. It doesn't matter if this fails for some reason.\n-     FIXME: At some point it should be safe to only do this if\n-     O_CLOEXEC == 0.  */\n-  fcntl (descriptor, F_SETFD, FD_CLOEXEC);\n-#endif\n-\n-  return descriptor;\n-}\n-\n-/* Close DESCRIPTOR.  */\n-\n-int\n-backtrace_close (int descriptor, backtrace_error_callback error_callback,\n-\t\t void *data)\n-{\n-  if (close (descriptor) < 0)\n-    {\n-      error_callback (data, \"close\", errno);\n-      return 0;\n-    }\n-  return 1;\n-}"}, {"sha": "74c8fcbee5a1f9bc853a0bb6e3607a15a20f9dba", "filename": "src/libbacktrace/print.c", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fprint.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fprint.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fprint.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,92 +0,0 @@\n-/* print.c -- Print the current backtrace.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* Passed to callbacks.  */\n-\n-struct print_data\n-{\n-  struct backtrace_state *state;\n-  FILE *f;\n-};\n-\n-/* Print one level of a backtrace.  */\n-\n-static int\n-print_callback (void *data, uintptr_t pc, const char *filename, int lineno,\n-\t\tconst char *function)\n-{\n-  struct print_data *pdata = (struct print_data *) data;\n-\n-  fprintf (pdata->f, \"0x%lx %s\\n\\t%s:%d\\n\",\n-\t   (unsigned long) pc,\n-\t   function == NULL ? \"???\" : function,\n-\t   filename == NULL ? \"???\" : filename,\n-\t   lineno);\n-  return 0;\n-}\n-\n-/* Print errors to stderr.  */\n-\n-static void\n-error_callback (void *data, const char *msg, int errnum)\n-{\n-  struct print_data *pdata = (struct print_data *) data;\n-\n-  if (pdata->state->filename != NULL)\n-    fprintf (stderr, \"%s: \", pdata->state->filename);\n-  fprintf (stderr, \"libbacktrace: %s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fputc ('\\n', stderr);\n-}\n-\n-/* Print a backtrace.  */\n-\n-void\n-backtrace_print (struct backtrace_state *state, int skip, FILE *f)\n-{\n-  struct print_data data;\n-\n-  data.state = state;\n-  data.f = f;\n-  backtrace_full (state, skip + 1, print_callback, error_callback,\n-\t\t  (void *) &data);\n-}"}, {"sha": "7f0317c3a8ce91e3de6c8bc95cae597e3163faf2", "filename": "src/libbacktrace/read.c", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fread.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fread.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fread.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,96 +0,0 @@\n-/* read.c -- File views without mmap.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <sys/types.h>\n-#include <unistd.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* This file implements file views when mmap is not available.  */\n-\n-/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */\n-\n-int\n-backtrace_get_view (struct backtrace_state *state, int descriptor,\n-\t\t    off_t offset, size_t size,\n-\t\t    backtrace_error_callback error_callback,\n-\t\t    void *data, struct backtrace_view *view)\n-{\n-  ssize_t got;\n-\n-  if (lseek (descriptor, offset, SEEK_SET) < 0)\n-    {\n-      error_callback (data, \"lseek\", errno);\n-      return 0;\n-    }\n-\n-  view->base = backtrace_alloc (state, size, error_callback, data);\n-  if (view->base == NULL)\n-    return 0;\n-  view->data = view->base;\n-  view->len = size;\n-\n-  got = read (descriptor, view->base, size);\n-  if (got < 0)\n-    {\n-      error_callback (data, \"read\", errno);\n-      free (view->base);\n-      return 0;\n-    }\n-\n-  if ((size_t) got < size)\n-    {\n-      error_callback (data, \"file too short\", 0);\n-      free (view->base);\n-      return 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Release a view read by backtrace_get_view.  */\n-\n-void\n-backtrace_release_view (struct backtrace_state *state,\n-\t\t\tstruct backtrace_view *view,\n-\t\t\tbacktrace_error_callback error_callback,\n-\t\t\tvoid *data)\n-{\n-  backtrace_free (state, view->base, view->len, error_callback, data);\n-  view->data = NULL;\n-  view->base = NULL;\n-}"}, {"sha": "018773a7e5dbdb66de407529f2508a5cd5769b54", "filename": "src/libbacktrace/simple.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fsimple.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fsimple.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsimple.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,108 +0,0 @@\n-/* simple.c -- The backtrace_simple function.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include \"unwind.h\"\n-#include \"backtrace.h\"\n-\n-/* The simple_backtrace routine.  */\n-\n-/* Data passed through _Unwind_Backtrace.  */\n-\n-struct backtrace_simple_data\n-{\n-  /* Number of frames to skip.  */\n-  int skip;\n-  /* Library state.  */\n-  struct backtrace_state *state;\n-  /* Callback routine.  */\n-  backtrace_simple_callback callback;\n-  /* Error callback routine.  */\n-  backtrace_error_callback error_callback;\n-  /* Data to pass to callback routine.  */\n-  void *data;\n-  /* Value to return from backtrace.  */\n-  int ret;\n-};\n-\n-/* Unwind library callback routine.  This is passd to\n-   _Unwind_Backtrace.  */\n-\n-static _Unwind_Reason_Code\n-simple_unwind (struct _Unwind_Context *context, void *vdata)\n-{\n-  struct backtrace_simple_data *bdata = (struct backtrace_simple_data *) vdata;\n-  uintptr_t pc;\n-  int ip_before_insn = 0;\n-\n-#ifdef HAVE_GETIPINFO\n-  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n-#else\n-  pc = _Unwind_GetIP (context);\n-#endif\n-\n-  if (bdata->skip > 0)\n-    {\n-      --bdata->skip;\n-      return _URC_NO_REASON;\n-    }\n-\n-  if (!ip_before_insn)\n-    --pc;\n-\n-  bdata->ret = bdata->callback (bdata->data, pc);\n-\n-  if (bdata->ret != 0)\n-    return _URC_END_OF_STACK;\n-\n-  return _URC_NO_REASON;\n-}\n-\n-/* Get a simple stack backtrace.  */\n-\n-int\n-backtrace_simple (struct backtrace_state *state, int skip,\n-\t\t  backtrace_simple_callback callback,\n-\t\t  backtrace_error_callback error_callback, void *data)\n-{\n-  struct backtrace_simple_data bdata;\n-\n-  bdata.skip = skip + 1;\n-  bdata.state = state;\n-  bdata.callback = callback;\n-  bdata.error_callback = error_callback;\n-  bdata.data = data;\n-  bdata.ret = 0;\n-  _Unwind_Backtrace (simple_unwind, &bdata);\n-  return bdata.ret;\n-}"}, {"sha": "68a7df65a47f6e4cd8bcc9171410c269b462033e", "filename": "src/libbacktrace/sort.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fsort.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fsort.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsort.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,108 +0,0 @@\n-/* sort.c -- Sort without allocating memory\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <stddef.h>\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* The GNU glibc version of qsort allocates memory, which we must not\n-   do if we are invoked by a signal handler.  So provide our own\n-   sort.  */\n-\n-static void\n-swap (char *a, char *b, size_t size)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < size; i++, a++, b++)\n-    {\n-      char t;\n-\n-      t = *a;\n-      *a = *b;\n-      *b = t;\n-    }\n-}\n-\n-void\n-backtrace_qsort (void *basearg, size_t count, size_t size,\n-\t\t int (*compar) (const void *, const void *))\n-{\n-  char *base = (char *) basearg;\n-  size_t i;\n-  size_t mid;\n-\n- tail_recurse:\n-  if (count < 2)\n-    return;\n-\n-  /* The symbol table and DWARF tables, which is all we use this\n-     routine for, tend to be roughly sorted.  Pick the middle element\n-     in the array as our pivot point, so that we are more likely to\n-     cut the array in half for each recursion step.  */\n-  swap (base, base + (count / 2) * size, size);\n-\n-  mid = 0;\n-  for (i = 1; i < count; i++)\n-    {\n-      if ((*compar) (base, base + i * size) > 0)\n-\t{\n-\t  ++mid;\n-\t  if (i != mid)\n-\t    swap (base + mid * size, base + i * size, size);\n-\t}\n-    }\n-\n-  if (mid > 0)\n-    swap (base, base + mid * size, size);\n-\n-  /* Recurse with the smaller array, loop with the larger one.  That\n-     ensures that our maximum stack depth is log count.  */\n-  if (2 * mid < count)\n-    {\n-      backtrace_qsort (base, mid, size, compar);\n-      base += (mid + 1) * size;\n-      count -= mid + 1;\n-      goto tail_recurse;\n-    }\n-  else\n-    {\n-      backtrace_qsort (base + (mid + 1) * size, count - (mid + 1),\n-\t\t       size, compar);\n-      count = mid;\n-      goto tail_recurse;\n-    }\n-}"}, {"sha": "93420d9c61b19939ebd28d4fe0dccae745d2af57", "filename": "src/libbacktrace/state.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fstate.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fstate.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstate.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,72 +0,0 @@\n-/* state.c -- Create the backtrace state.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <string.h>\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"backtrace-supported.h\"\n-#include \"internal.h\"\n-\n-/* Create the backtrace state.  This will then be passed to all the\n-   other routines.  */\n-\n-struct backtrace_state *\n-backtrace_create_state (const char *filename, int threaded,\n-\t\t\tbacktrace_error_callback error_callback,\n-\t\t\tvoid *data)\n-{\n-  struct backtrace_state init_state;\n-  struct backtrace_state *state;\n-\n-#ifndef HAVE_SYNC_FUNCTIONS\n-  if (threaded)\n-    {\n-      error_callback (data, \"backtrace library does not support threads\", 0);\n-      return NULL;\n-    }\n-#endif\n-\n-  memset (&init_state, 0, sizeof init_state);\n-  init_state.filename = filename;\n-  init_state.threaded = threaded;\n-\n-  state = ((struct backtrace_state *)\n-\t   backtrace_alloc (&init_state, sizeof *state, error_callback, data));\n-  if (state == NULL)\n-    return NULL;\n-  *state = init_state;\n-\n-  return state;\n-}"}, {"sha": "55ec31d10bc8168343550e57a71da06dbd5f64fd", "filename": "src/libbacktrace/stest.c", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fstest.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Fstest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstest.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,137 +0,0 @@\n-/* stest.c -- Test for libbacktrace internal sort function\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* Test the local qsort implementation.  */\n-\n-#define MAX 10\n-\n-struct test\n-{\n-  size_t count;\n-  int input[MAX];\n-  int output[MAX];\n-};\n-\n-static struct test tests[] =\n-  {\n-    {\n-      10,\n-      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n-      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }\n-    },\n-    {\n-      9,\n-      { 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n-      { 1, 2, 3, 4, 5, 6, 7, 8, 9 }\n-    },\n-    {\n-      10,\n-      { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 },\n-      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n-    },\n-    {\n-      9,\n-      { 9, 8, 7, 6, 5, 4, 3, 2, 1 },\n-      { 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n-    },\n-    {\n-      10,\n-      { 2, 4, 6, 8, 10, 1, 3, 5, 7, 9 },\n-      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n-    },\n-    {\n-      5,\n-      { 4, 5, 3, 1, 2 },\n-      { 1, 2, 3, 4, 5 },\n-    },\n-    {\n-      5,\n-      { 1, 1, 1, 1, 1 },\n-      { 1, 1, 1, 1, 1 },\n-    },\n-    {\n-      5,\n-      { 1, 1, 2, 1, 1 },\n-      { 1, 1, 1, 1, 2 },\n-    },\n-    {\n-      5,\n-      { 2, 1, 1, 1, 1 },\n-      { 1, 1, 1, 1, 2 },\n-    },\n-  };\n-\n-static int\n-compare (const void *a, const void *b)\n-{\n-  const int *ai = (const int *) a;\n-  const int *bi = (const int *) b;\n-\n-  return *ai - *bi;\n-}\n-\n-int\n-main (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n-{\n-  int failures;\n-  size_t i;\n-  int a[MAX];\n-\n-  failures = 0;\n-  for (i = 0; i < sizeof tests / sizeof tests[0]; i++)\n-    {\n-      memcpy (a, tests[i].input, tests[i].count * sizeof (int));\n-      backtrace_qsort (a, tests[i].count, sizeof (int), compare);\n-      if (memcmp (a, tests[i].output, tests[i].count * sizeof (int)) != 0)\n-\t{\n-\t  size_t j;\n-\n-\t  fprintf (stderr, \"test %d failed:\", (int) i);\n-\t  for (j = 0; j < tests[i].count; j++)\n-\t    fprintf (stderr, \" %d\", a[j]);\n-\t  fprintf (stderr, \"\\n\");\n-\t  ++failures;\n-\t}\n-    }\n-\n-  exit (failures > 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n-}"}, {"sha": "8d06c31549f70a0fbfa049bd9eda0921591b4a31", "filename": "src/libbacktrace/unknown.c", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Funknown.c", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibbacktrace%2Funknown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Funknown.c?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -1,64 +0,0 @@\n-/* unknown.c -- used when backtrace configury does not know file format.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* A trivial routine that always fails to find fileline data.  */\n-\n-static int\n-unknown_fileline (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t  uintptr_t pc, backtrace_full_callback callback,\n-\t\t  backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t\t  void *data)\n-\n-{\n-  return callback (data, pc, NULL, 0, NULL);\n-}\n-\n-/* Initialize the backtrace data when we don't know how to read the\n-   debug info.  */\n-\n-int\n-backtrace_initialize (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t      int descriptor ATTRIBUTE_UNUSED,\n-\t\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t\t      void *data ATTRIBUTE_UNUSED, fileline *fileline_fn)\n-{\n-  state->fileline_data = NULL;\n-  *fileline_fn = unknown_fileline;\n-  return 1;\n-}"}]}