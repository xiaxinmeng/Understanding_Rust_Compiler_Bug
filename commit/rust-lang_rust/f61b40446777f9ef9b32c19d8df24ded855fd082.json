{"sha": "f61b40446777f9ef9b32c19d8df24ded855fd082", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MWI0MDQ0Njc3N2Y5ZWY5YjMyYzE5ZDhkZjI0ZGVkODU1ZmQwODI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-13T23:55:34Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-19T22:13:35Z"}, "message": "Split up NodeCollector so that defs are collected separately from nodes for the HIR map.", "tree": {"sha": "6463a92ba6ed17893a4772e36d389d1da5d910ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6463a92ba6ed17893a4772e36d389d1da5d910ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f61b40446777f9ef9b32c19d8df24ded855fd082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f61b40446777f9ef9b32c19d8df24ded855fd082", "html_url": "https://github.com/rust-lang/rust/commit/f61b40446777f9ef9b32c19d8df24ded855fd082", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f61b40446777f9ef9b32c19d8df24ded855fd082/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c99b73a767a38d5b97214b7dbf6ee3c08ac782fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c99b73a767a38d5b97214b7dbf6ee3c08ac782fd", "html_url": "https://github.com/rust-lang/rust/commit/c99b73a767a38d5b97214b7dbf6ee3c08ac782fd"}], "stats": {"total": 398, "additions": 263, "deletions": 135}, "files": [{"sha": "7f6a587fade24d0c44147e636592fcbbf55b6a87", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 216, "deletions": 107, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/f61b40446777f9ef9b32c19d8df24ded855fd082/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f61b40446777f9ef9b32c19d8df24ded855fd082/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=f61b40446777f9ef9b32c19d8df24ded855fd082", "patch": "@@ -19,25 +19,28 @@ use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n \n-/// A Visitor that walks over an AST and collects Node's into an AST\n-/// Map.\n+/// A Visitor that walks over the HIR and collects Node's into a HIR map.\n pub struct NodeCollector<'ast> {\n     pub krate: &'ast Crate,\n     pub map: Vec<MapEntry<'ast>>,\n-    pub definitions: Definitions,\n     pub parent_node: NodeId,\n }\n \n-impl<'ast> NodeCollector<'ast> {\n-    pub fn root(krate: &'ast Crate) -> NodeCollector<'ast> {\n-        let mut collector = NodeCollector {\n+pub struct DefCollector<'ast> {\n+    pub krate: &'ast Crate,\n+    pub map: &'ast [MapEntry<'ast>],\n+    pub definitions: Definitions,\n+    pub parent_def: Option<DefIndex>,\n+}\n+\n+impl<'ast> DefCollector<'ast> {\n+    pub fn root(krate: &'ast Crate, map: &'ast [MapEntry<'ast>]) -> DefCollector<'ast> {\n+        let mut collector = DefCollector {\n             krate: krate,\n-            map: vec![],\n+            map: map,\n             definitions: Definitions::new(),\n-            parent_node: CRATE_NODE_ID,\n+            parent_def: None,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate);\n-\n         let result = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n         assert_eq!(result, CRATE_DEF_INDEX);\n \n@@ -47,17 +50,16 @@ impl<'ast> NodeCollector<'ast> {\n     }\n \n     pub fn extend(krate: &'ast Crate,\n-                  parent: &'ast InlinedItem,\n                   parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n-                  map: Vec<MapEntry<'ast>>,\n+                  map: &'ast [MapEntry<'ast>],\n                   definitions: Definitions)\n-                  -> NodeCollector<'ast> {\n-        let mut collector = NodeCollector {\n+                  -> DefCollector<'ast> {\n+        let mut collector = DefCollector {\n             krate: krate,\n             map: map,\n-            parent_node: parent_node,\n+            parent_def: None,\n             definitions: definitions,\n         };\n \n@@ -67,21 +69,14 @@ impl<'ast> NodeCollector<'ast> {\n             def_id: parent_def_id,\n         });\n \n-        collector.insert_entry(parent_node, RootInlinedParent(parent));\n-        collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n+        let def = collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n+        collector.parent_def = Some(def);\n \n         collector\n     }\n \n     fn parent_def(&self) -> Option<DefIndex> {\n-        let mut parent_node = Some(self.parent_node);\n-        while let Some(p) = parent_node {\n-            if let Some(q) = self.definitions.opt_def_index(p) {\n-                return Some(q);\n-            }\n-            parent_node = self.map[p as usize].parent_node();\n-        }\n-        None\n+        self.parent_def\n     }\n \n     fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n@@ -97,28 +92,9 @@ impl<'ast> NodeCollector<'ast> {\n                               -> DefIndex {\n         self.definitions.create_def_with_parent(parent, node_id, data)\n     }\n-\n-    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n-        debug!(\"ast_map: {:?} => {:?}\", id, entry);\n-        let len = self.map.len();\n-        if id as usize >= len {\n-            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n-        }\n-        self.map[id as usize] = entry;\n-    }\n-\n-    fn insert_def(&mut self, id: NodeId, node: Node<'ast>, data: DefPathData) -> DefIndex {\n-        self.insert(id, node);\n-        self.create_def(id, data)\n-    }\n-\n-    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n-        let entry = MapEntry::from_node(self.parent_node, node);\n-        self.insert_entry(id, entry);\n-    }\n }\n \n-impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n+impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n@@ -146,18 +122,16 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                 DefPathData::Misc,\n         };\n \n-        self.insert_def(i.id, NodeItem(i), def_data);\n+        let def = self.create_def(i.id, def_data);\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = i.id;\n+        let parent_def = self.parent_def;\n+        self.parent_def = Some(def);\n \n         match i.node {\n-            ItemImpl(..) => {}\n             ItemEnum(ref enum_definition, _) => {\n                 for v in &enum_definition.variants {\n                     let variant_def_index =\n-                        self.insert_def(v.node.data.id(),\n-                                        NodeVariant(v),\n+                        self.create_def(v.node.data.id(),\n                                         DefPathData::EnumVariant(v.node.name));\n \n                     for field in v.node.data.fields() {\n@@ -168,58 +142,35 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                     }\n                 }\n             }\n-            ItemForeignMod(..) => {\n-            }\n             ItemStruct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n                 if !struct_def.is_struct() {\n-                    self.insert_def(struct_def.id(),\n-                                    NodeStructCtor(struct_def),\n+                    self.create_def(struct_def.id(),\n                                     DefPathData::StructCtor);\n                 }\n \n                 for field in struct_def.fields() {\n                     self.create_def(field.id, DefPathData::Field(field.name));\n                 }\n             }\n-            ItemTrait(_, _, ref bounds, _) => {\n-                for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n-                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n-                    }\n-                }\n-            }\n-            ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.insert(path.node.id(), NodeItem(i));\n-                        }\n-                    }\n-                    _ => ()\n-                }\n-            }\n             _ => {}\n         }\n         intravisit::walk_item(self, i);\n-        self.parent_node = parent_node;\n+        self.parent_def = parent_def;\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n-        self.insert_def(foreign_item.id,\n-                        NodeForeignItem(foreign_item),\n-                        DefPathData::ValueNs(foreign_item.name));\n+        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.name));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = foreign_item.id;\n+        let parent_def = self.parent_def;\n+        self.parent_def = Some(def);\n         intravisit::walk_foreign_item(self, foreign_item);\n-        self.parent_node = parent_node;\n+        self.parent_def = parent_def;\n     }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.insert_def(ty_param.id,\n-                            NodeTyParam(ty_param),\n+            self.create_def(ty_param.id,\n                             DefPathData::TypeParam(ty_param.name));\n         }\n \n@@ -232,11 +183,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n         };\n \n-        self.insert(ti.id, NodeTraitItem(ti));\n-        self.create_def(ti.id, def_data);\n+        let def = self.create_def(ti.id, def_data);\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = ti.id;\n+        let parent_def = self.parent_def;\n+        self.parent_def = Some(def);\n \n         match ti.node {\n             ConstTraitItem(_, Some(ref expr)) => {\n@@ -247,7 +197,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n         intravisit::walk_trait_item(self, ti);\n \n-        self.parent_node = parent_node;\n+        self.parent_def = parent_def;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n@@ -256,10 +206,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n         };\n \n-        self.insert_def(ii.id, NodeImplItem(ii), def_data);\n+        let def = self.create_def(ii.id, def_data);\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = ii.id;\n+        let parent_def = self.parent_def;\n+        self.parent_def = Some(def);\n \n         match ii.node {\n             ImplItemKind::Const(_, ref expr) => {\n@@ -270,7 +220,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n         intravisit::walk_impl_item(self, ii);\n \n-        self.parent_node = parent_node;\n+        self.parent_def = parent_def;\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n@@ -279,11 +229,184 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             _ => None\n         };\n \n+        let parent_def = self.parent_def;\n         if let Some(id) = maybe_binding {\n-            self.insert_def(pat.id, NodeLocal(pat), DefPathData::Binding(id.name));\n-        } else {\n-            self.insert(pat.id, NodePat(pat));\n+            let def = self.create_def(pat.id, DefPathData::Binding(id.name));\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        let parent_def = self.parent_def;\n+\n+        if let ExprClosure(..) = expr.node {\n+            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n+        intravisit::walk_stmt(self, stmt);\n+    }\n+\n+    fn visit_block(&mut self, block: &'ast Block) {\n+        intravisit::walk_block(self, block);\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n+    }\n+}\n+\n+impl<'ast> NodeCollector<'ast> {\n+    pub fn root(krate: &'ast Crate) -> NodeCollector<'ast> {\n+        let mut collector = NodeCollector {\n+            krate: krate,\n+            map: vec![],\n+            parent_node: CRATE_NODE_ID,\n+        };\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+\n+        collector\n+    }\n+\n+    pub fn extend(krate: &'ast Crate,\n+                  parent: &'ast InlinedItem,\n+                  parent_node: NodeId,\n+                  parent_def_path: DefPath,\n+                  parent_def_id: DefId,\n+                  map: Vec<MapEntry<'ast>>)\n+                  -> NodeCollector<'ast> {\n+        let mut collector = NodeCollector {\n+            krate: krate,\n+            map: map,\n+            parent_node: parent_node,\n+        };\n+\n+        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n+        collector.insert_entry(parent_node, RootInlinedParent(parent));\n+\n+        collector\n+    }\n+\n+    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n+        debug!(\"ast_map: {:?} => {:?}\", id, entry);\n+        let len = self.map.len();\n+        if id as usize >= len {\n+            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n         }\n+        self.map[id as usize] = entry;\n+    }\n+\n+    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n+        let entry = MapEntry::from_node(self.parent_node, node);\n+        self.insert_entry(id, entry);\n+    }\n+}\n+\n+impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n+    /// Because we want to track parent items and so forth, enable\n+    /// deep walking so that we walk nested items in the context of\n+    /// their outer items.\n+    fn visit_nested_item(&mut self, item: ItemId) {\n+        debug!(\"visit_nested_item: {:?}\", item);\n+        self.visit_item(self.krate.item(item.id))\n+    }\n+\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+\n+        self.insert(i.id, NodeItem(i));\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = i.id;\n+\n+        match i.node {\n+            ItemEnum(ref enum_definition, _) => {\n+                for v in &enum_definition.variants {\n+                    self.insert(v.node.data.id(), NodeVariant(v));\n+                }\n+            }\n+            ItemStruct(ref struct_def, _) => {\n+                // If this is a tuple-like struct, register the constructor.\n+                if !struct_def.is_struct() {\n+                    self.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                }\n+            }\n+            ItemTrait(_, _, ref bounds, _) => {\n+                for b in bounds.iter() {\n+                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n+                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n+                    }\n+                }\n+            }\n+            ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathList(_, ref paths) => {\n+                        for path in paths {\n+                            self.insert(path.node.id(), NodeItem(i));\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            _ => {}\n+        }\n+        intravisit::walk_item(self, i);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+        self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = foreign_item.id;\n+        intravisit::walk_foreign_item(self, foreign_item);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.insert(ty_param.id, NodeTyParam(ty_param));\n+        }\n+\n+        intravisit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        self.insert(ti.id, NodeTraitItem(ti));\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = ti.id;\n+\n+        intravisit::walk_trait_item(self, ti);\n+\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+        self.insert(ii.id, NodeImplItem(ii));\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = ii.id;\n+\n+        intravisit::walk_impl_item(self, ii);\n+\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast Pat) {\n+        self.insert(pat.id, NodeLocal(pat));\n \n         let parent_node = self.parent_node;\n         self.parent_node = pat.id;\n@@ -294,11 +417,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.insert(expr.id, NodeExpr(expr));\n \n-        match expr.node {\n-            ExprClosure(..) => { self.create_def(expr.id, DefPathData::ClosureExpr); }\n-            _ => { }\n-        }\n-\n         let parent_node = self.parent_node;\n         self.parent_node = expr.id;\n         intravisit::walk_expr(self, expr);\n@@ -331,13 +449,4 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n-        self.visit_lifetime(&def.lifetime);\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n-    }\n }"}, {"sha": "6331f7d3009ee20c298d9efb3d864fbf5204ff60", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f61b40446777f9ef9b32c19d8df24ded855fd082/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f61b40446777f9ef9b32c19d8df24ded855fd082/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f61b40446777f9ef9b32c19d8df24ded855fd082", "patch": "@@ -10,7 +10,7 @@\n \n pub use self::Node::*;\n use self::MapEntry::*;\n-use self::collector::NodeCollector;\n+use self::collector::{NodeCollector, DefCollector};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, InlinedRootPath};\n \n@@ -784,7 +784,14 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n     let (map, definitions) = {\n         let mut collector = NodeCollector::root(&forest.krate);\n         intravisit::walk_crate(&mut collector, &forest.krate);\n-        (collector.map, collector.definitions)\n+\n+        let definitions = {\n+            let mut def_collector = DefCollector::root(&forest.krate, &collector.map);\n+            intravisit::walk_crate(&mut def_collector, &forest.krate);\n+            def_collector.definitions\n+        };\n+\n+        (collector.map, definitions)\n     };\n \n     if log_enabled!(::log::DEBUG) {\n@@ -836,19 +843,26 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let ii = map.forest.inlined_items.alloc(ii);\n \n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-    let mut collector =\n-        NodeCollector::extend(\n-            map.krate(),\n-            ii,\n-            ii_parent_id,\n-            parent_def_path,\n-            parent_def_id,\n-            mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-            mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n+    let mut collector = NodeCollector::extend(map.krate(),\n+                                              ii,\n+                                              ii_parent_id,\n+                                              parent_def_path.clone(),\n+                                              parent_def_id,\n+                                              mem::replace(&mut *map.map.borrow_mut(), vec![]));\n     ii.visit(&mut collector);\n \n+    {\n+        let mut def_collector = DefCollector::extend(map.krate(),\n+                                                     ii_parent_id,\n+                                                     parent_def_path,\n+                                                     parent_def_id,\n+                                                     &collector.map,\n+                                                     mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n+        ii.visit(&mut def_collector);\n+        *map.definitions.borrow_mut() = def_collector.definitions;\n+    }\n+\n     *map.map.borrow_mut() = collector.map;\n-    *map.definitions.borrow_mut() = collector.definitions;\n \n     ii\n }"}, {"sha": "c211fa2925e6995c7d74a3a7e7036f900341680f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f61b40446777f9ef9b32c19d8df24ded855fd082/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f61b40446777f9ef9b32c19d8df24ded855fd082/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f61b40446777f9ef9b32c19d8df24ded855fd082", "patch": "@@ -120,6 +120,27 @@ pub fn compile_input(sess: &Session,\n                                 Ok(()));\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n+        let dep_graph = DepGraph::new(sess.opts.build_dep_graph);\n+        \n+        // TODO\n+        // time(sess.time_passes(),\n+        //      \"external crate/lib resolution\",\n+        //      || LocalCrateReader::new(sess, &cstore, &defs, &id).read_crates());\n+\n+        // TODO\n+        panic!();\n+\n+        // TODO CrateMap result\n+        // let resolve::CrateMap {\n+        //     def_map,\n+        //     freevars,\n+        //     export_map,\n+        //     trait_map,\n+        //     glob_map,\n+        // } = time(sess.time_passes(),\n+        //          \"name resolution\",\n+        //          || resolve::resolve_crate(sess, &hir_map, control.make_glob_map));\n+\n         // Lower ast -> hir.\n         let lcx = LoweringContext::new(sess, Some(&expanded_crate));\n         let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n@@ -175,7 +196,6 @@ pub fn compile_input(sess: &Session,\n                                     hir_map,\n                                     &arenas,\n                                     &id,\n-                                    control.make_glob_map,\n                                     |tcx, mir_map, analysis, result| {\n             {\n                 // Eventually, we will want to track plugins.\n@@ -743,7 +763,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n-                                               make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: FnOnce(&TyCtxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n@@ -762,20 +781,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let time_passes = sess.time_passes();\n \n-    time(time_passes,\n-         \"external crate/lib resolution\",\n-         || LocalCrateReader::new(sess, cstore, &hir_map, name).read_crates());\n-\n-    let resolve::CrateMap {\n-        def_map,\n-        freevars,\n-        export_map,\n-        trait_map,\n-        glob_map,\n-    } = time(time_passes,\n-             \"name resolution\",\n-             || resolve::resolve_crate(sess, &hir_map, make_glob_map));\n-\n     let lang_items = time(time_passes, \"language item collection\", || {\n         sess.track_errors(|| {\n             middle::lang_items::collect_language_items(&sess, &hir_map)"}]}