{"sha": "fb1fab5a67955240330038414c23d912766ddeaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMWZhYjVhNjc5NTUyNDAzMzAwMzg0MTRjMjNkOTEyNzY2ZGRlYWY=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2020-09-07T17:07:15Z"}, "committer": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2020-09-09T00:24:28Z"}, "message": "Tests for HashMap/HashSet::drain_filter", "tree": {"sha": "3c671ecec8844afa6e201318cc741451e3bf60af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c671ecec8844afa6e201318cc741451e3bf60af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb1fab5a67955240330038414c23d912766ddeaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb1fab5a67955240330038414c23d912766ddeaf", "html_url": "https://github.com/rust-lang/rust/commit/fb1fab5a67955240330038414c23d912766ddeaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb1fab5a67955240330038414c23d912766ddeaf/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49aef963d3fb50c6961077cc11c6ce93ee719d73", "url": "https://api.github.com/repos/rust-lang/rust/commits/49aef963d3fb50c6961077cc11c6ce93ee719d73", "html_url": "https://github.com/rust-lang/rust/commit/49aef963d3fb50c6961077cc11c6ce93ee719d73"}], "stats": {"total": 232, "additions": 232, "deletions": 0}, "files": [{"sha": "467968354e25d984d1b47f885da660a1ae238a9d", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/fb1fab5a67955240330038414c23d912766ddeaf/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1fab5a67955240330038414c23d912766ddeaf/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=fb1fab5a67955240330038414c23d912766ddeaf", "patch": "@@ -924,3 +924,164 @@ fn test_raw_entry() {\n         }\n     }\n }\n+\n+mod test_drain_filter {\n+    use super::*;\n+\n+    use crate::panic::{catch_unwind, AssertUnwindSafe};\n+    use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+    trait EqSorted: Iterator {\n+        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool;\n+    }\n+\n+    impl<T: Iterator> EqSorted for T\n+    where\n+        T::Item: Eq + Ord,\n+    {\n+        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool {\n+            let mut v: Vec<_> = self.collect();\n+            v.sort_unstable();\n+            v.into_iter().eq(other)\n+        }\n+    }\n+\n+    #[test]\n+    fn empty() {\n+        let mut map: HashMap<i32, i32> = HashMap::new();\n+        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn consuming_nothing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(map.drain_filter(|_, _| false).eq_sorted(crate::iter::empty()));\n+        assert_eq!(map.len(), 3);\n+    }\n+\n+    #[test]\n+    fn consuming_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.clone().collect();\n+        assert!(map.drain_filter(|_, _| true).eq_sorted(pairs));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn mutating_and_keeping() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                false\n+            })\n+            .eq_sorted(crate::iter::empty())\n+        );\n+        assert!(map.keys().copied().eq_sorted(0..3));\n+        assert!(map.values().copied().eq_sorted(6..9));\n+    }\n+\n+    #[test]\n+    fn mutating_and_removing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                true\n+            })\n+            .eq_sorted((0..3).map(|i| (i, i + 6)))\n+        );\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn drop_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                    panic!(\"panic in `drop`\");\n+                }\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        catch_unwind(move || {\n+            drop(map.drain_filter(|_, _| {\n+                PREDS.fetch_add(1, Ordering::SeqCst);\n+                true\n+            }))\n+        })\n+        .unwrap_err();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    }\n+\n+    #[test]\n+    fn pred_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        catch_unwind(AssertUnwindSafe(|| {\n+            drop(map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+                0 => true,\n+                _ => panic!(),\n+            }))\n+        }))\n+        .unwrap_err();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+    }\n+\n+    // Same as above, but attempt to use the iterator again after the panic in the predicate\n+    #[test]\n+    fn pred_panic_reuse() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        {\n+            let mut it = map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+                0 => true,\n+                _ => panic!(),\n+            });\n+            catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n+            // Iterator behaviour after a panic is explicitly unspecified,\n+            // so this is just the current implementation:\n+            let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+            assert!(result.is_err());\n+        }\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+    }\n+}"}, {"sha": "40f8467fd93fddf18907d1a9d55440164a9a522f", "filename": "library/std/src/collections/hash/set/tests.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/fb1fab5a67955240330038414c23d912766ddeaf/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1fab5a67955240330038414c23d912766ddeaf/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs?ref=fb1fab5a67955240330038414c23d912766ddeaf", "patch": "@@ -1,6 +1,9 @@\n use super::super::map::RandomState;\n use super::HashSet;\n \n+use crate::panic::{catch_unwind, AssertUnwindSafe};\n+use crate::sync::atomic::{AtomicU32, Ordering};\n+\n #[test]\n fn test_zero_capacities() {\n     type HS = HashSet<i32>;\n@@ -413,3 +416,71 @@ fn test_retain() {\n     assert!(set.contains(&4));\n     assert!(set.contains(&6));\n }\n+\n+#[test]\n+fn test_drain_filter() {\n+    let mut x: HashSet<_> = [1].iter().copied().collect();\n+    let mut y: HashSet<_> = [1].iter().copied().collect();\n+\n+    x.drain_filter(|_| true);\n+    y.drain_filter(|_| false);\n+    assert_eq!(x.len(), 0);\n+    assert_eq!(y.len(), 1);\n+}\n+\n+#[test]\n+fn test_drain_filter_drop_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut set = (0..3).map(|i| D(i)).collect::<HashSet<_>>();\n+\n+    catch_unwind(move || {\n+        drop(set.drain_filter(|_| {\n+            PREDS.fetch_add(1, Ordering::SeqCst);\n+            true\n+        }))\n+    })\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+}\n+\n+#[test]\n+fn test_drain_filter_pred_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n+    struct D;\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let mut set: HashSet<_> = (0..3).map(|_| D).collect();\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(set.drain_filter(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+            0 => true,\n+            _ => panic!(),\n+        }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 1);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    assert_eq!(set.len(), 0);\n+}"}]}