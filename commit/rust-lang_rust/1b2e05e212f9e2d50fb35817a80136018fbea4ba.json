{"sha": "1b2e05e212f9e2d50fb35817a80136018fbea4ba", "node_id": "C_kwDOAAsO6NoAKDFiMmUwNWUyMTJmOWUyZDUwZmIzNTgxN2E4MDEzNjAxOGZiZWE0YmE", "commit": {"author": {"name": "Preston From", "email": "prestonfrom@gmail.com", "date": "2022-07-28T06:10:19Z"}, "committer": {"name": "Preston From", "email": "prestonfrom@gmail.com", "date": "2022-07-28T06:10:19Z"}, "message": "Use more idiomatic rust, comment for lint logic", "tree": {"sha": "3b453e9a13a0305225e1bde89302e7255d24f5ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b453e9a13a0305225e1bde89302e7255d24f5ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b2e05e212f9e2d50fb35817a80136018fbea4ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b2e05e212f9e2d50fb35817a80136018fbea4ba", "html_url": "https://github.com/rust-lang/rust/commit/1b2e05e212f9e2d50fb35817a80136018fbea4ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b2e05e212f9e2d50fb35817a80136018fbea4ba/comments", "author": {"login": "PrestonFrom", "id": 12164367, "node_id": "MDQ6VXNlcjEyMTY0MzY3", "avatar_url": "https://avatars.githubusercontent.com/u/12164367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PrestonFrom", "html_url": "https://github.com/PrestonFrom", "followers_url": "https://api.github.com/users/PrestonFrom/followers", "following_url": "https://api.github.com/users/PrestonFrom/following{/other_user}", "gists_url": "https://api.github.com/users/PrestonFrom/gists{/gist_id}", "starred_url": "https://api.github.com/users/PrestonFrom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PrestonFrom/subscriptions", "organizations_url": "https://api.github.com/users/PrestonFrom/orgs", "repos_url": "https://api.github.com/users/PrestonFrom/repos", "events_url": "https://api.github.com/users/PrestonFrom/events{/privacy}", "received_events_url": "https://api.github.com/users/PrestonFrom/received_events", "type": "User", "site_admin": false}, "committer": {"login": "PrestonFrom", "id": 12164367, "node_id": "MDQ6VXNlcjEyMTY0MzY3", "avatar_url": "https://avatars.githubusercontent.com/u/12164367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PrestonFrom", "html_url": "https://github.com/PrestonFrom", "followers_url": "https://api.github.com/users/PrestonFrom/followers", "following_url": "https://api.github.com/users/PrestonFrom/following{/other_user}", "gists_url": "https://api.github.com/users/PrestonFrom/gists{/gist_id}", "starred_url": "https://api.github.com/users/PrestonFrom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PrestonFrom/subscriptions", "organizations_url": "https://api.github.com/users/PrestonFrom/orgs", "repos_url": "https://api.github.com/users/PrestonFrom/repos", "events_url": "https://api.github.com/users/PrestonFrom/events{/privacy}", "received_events_url": "https://api.github.com/users/PrestonFrom/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a08b1704472320e8b1c03c0cf8cd9d4958343e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a08b1704472320e8b1c03c0cf8cd9d4958343e0", "html_url": "https://github.com/rust-lang/rust/commit/1a08b1704472320e8b1c03c0cf8cd9d4958343e0"}], "stats": {"total": 129, "additions": 79, "deletions": 50}, "files": [{"sha": "082c78934262bf23bfdabce0fa9f8d2a41294eaf", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 79, "deletions": 50, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/1b2e05e212f9e2d50fb35817a80136018fbea4ba/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2e05e212f9e2d50fb35817a80136018fbea4ba/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=1b2e05e212f9e2d50fb35817a80136018fbea4ba", "patch": "@@ -18,7 +18,6 @@ use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n-use std::ops::Deref;\n \n #[derive(PartialEq)]\n enum ArgumentType {\n@@ -71,14 +70,10 @@ impl PositionalNamedArg {\n             // In the case of a named argument whose position is implicit, there will not be a span\n             // to replace. Instead, we insert the name after the `{`, which is the first character\n             // of arg_span.\n-            if let Some(arg_span) = cx.arg_spans.get(self.cur_piece).copied() {\n-                return Some(Span::new(\n-                    arg_span.lo() + BytePos(1),\n-                    arg_span.lo() + BytePos(1),\n-                    self.positional_named_arg_span.ctxt(),\n-                    self.positional_named_arg_span.parent(),\n-                ));\n-            }\n+            return cx\n+                .arg_spans\n+                .get(self.cur_piece)\n+                .map(|arg_span| arg_span.with_lo(arg_span.lo() + BytePos(1)).shrink_to_lo());\n         }\n \n         None\n@@ -92,6 +87,43 @@ struct PositionalNamedArgsLint {\n }\n \n impl PositionalNamedArgsLint {\n+    /// For a given positional argument, check if the index is for a named argument.\n+    ///\n+    /// Since positional arguments are required to come before named arguments, if the positional\n+    /// index is greater than or equal to the start of named arguments, we know it's a named\n+    /// argument used positionally.\n+    ///\n+    /// Example:\n+    /// println!(\"{} {} {2}\", 0, a=1, b=2);\n+    ///\n+    /// In this case, the first piece (`{}`) would be ArgumentImplicitlyIs with an index of 0. The\n+    /// total number of arguments is 3 and the number of named arguments is 2, so the start of named\n+    /// arguments is index 1. Therefore, the index of 0 is okay.\n+    ///\n+    /// The second piece (`{}`) would be ArgumentImplicitlyIs with an index of 1, which is the start\n+    /// of named arguments, and so we should add a lint to use the named argument `a`.\n+    ///\n+    /// The third piece (`{2}`) would be ArgumentIs with an index of 2, which is greater than the\n+    /// start of named arguments, and so we should add a lint to use the named argument `b`.\n+    ///\n+    /// This same check also works for width and precision formatting when either or both are\n+    /// CountIsParam, which contains an index into the arguments.\n+    fn maybe_add_positional_named_arg(\n+        &mut self,\n+        current_positional_arg: usize,\n+        total_args_length: usize,\n+        format_argument_index: usize,\n+        ty: PositionalNamedArgType,\n+        cur_piece: usize,\n+        inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n+        names: &FxHashMap<Symbol, (usize, Span)>,\n+    ) {\n+        let start_of_named_args = total_args_length - names.len();\n+        if current_positional_arg >= start_of_named_args {\n+            self.maybe_push(format_argument_index, ty, cur_piece, inner_span_to_replace, names)\n+        }\n+    }\n+\n     /// Try constructing a PositionalNamedArg struct and pushing it into the vec of positional\n     /// named arguments. If a named arg associated with `format_argument_index` cannot be found,\n     /// a new item will not be added as the lint cannot be emitted in this case.\n@@ -100,30 +132,30 @@ impl PositionalNamedArgsLint {\n         format_argument_index: usize,\n         ty: PositionalNamedArgType,\n         cur_piece: usize,\n-        mut inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n+        inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n         names: &FxHashMap<Symbol, (usize, Span)>,\n     ) {\n         let named_arg = names\n             .iter()\n-            .find(|name| name.deref().1.0 == format_argument_index)\n+            .find(|&(_, &(index, _))| index == format_argument_index)\n             .map(|found| found.clone());\n \n-        if let Some(named_arg) = named_arg {\n+        if let Some((&replacement, &(_, positional_named_arg_span))) = named_arg {\n             // In FormatSpec, `precision_span` starts at the leading `.`, which we want to keep in\n             // the lint suggestion, so increment `start` by 1 when `PositionalArgumentType` is\n             // `Precision`.\n-            if ty == PositionalNamedArgType::Precision {\n-                inner_span_to_replace = inner_span_to_replace.map(|mut is| {\n-                    is.start += 1;\n-                    is\n-                });\n-            }\n+            let inner_span_to_replace = if ty == PositionalNamedArgType::Precision {\n+                inner_span_to_replace\n+                    .map(|is| rustc_parse_format::InnerSpan { start: is.start + 1, end: is.end })\n+            } else {\n+                inner_span_to_replace\n+            };\n             self.positional_named_args.push(PositionalNamedArg {\n                 ty,\n                 cur_piece,\n                 inner_span_to_replace,\n-                replacement: named_arg.0.clone(),\n-                positional_named_arg_span: named_arg.1.1.clone(),\n+                replacement,\n+                positional_named_arg_span,\n             });\n         }\n     }\n@@ -386,30 +418,28 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n                     parse::ArgumentIs(i, arg_end) => {\n-                        let start_of_named_args = self.args.len() - self.names.len();\n-                        if self.curpiece >= start_of_named_args {\n-                            self.unused_names_lint.maybe_push(\n-                                i,\n-                                PositionalNamedArgType::Arg,\n-                                self.curpiece,\n-                                arg_end,\n-                                &self.names,\n-                            );\n-                        }\n+                        self.unused_names_lint.maybe_add_positional_named_arg(\n+                            i,\n+                            self.args.len(),\n+                            i,\n+                            PositionalNamedArgType::Arg,\n+                            self.curpiece,\n+                            arg_end,\n+                            &self.names,\n+                        );\n \n                         Exact(i)\n                     }\n                     parse::ArgumentImplicitlyIs(i) => {\n-                        let start_of_named_args = self.args.len() - self.names.len();\n-                        if self.curpiece >= start_of_named_args {\n-                            self.unused_names_lint.maybe_push(\n-                                i,\n-                                PositionalNamedArgType::Arg,\n-                                self.curpiece,\n-                                None,\n-                                &self.names,\n-                            );\n-                        }\n+                        self.unused_names_lint.maybe_add_positional_named_arg(\n+                            i,\n+                            self.args.len(),\n+                            i,\n+                            PositionalNamedArgType::Arg,\n+                            self.curpiece,\n+                            None,\n+                            &self.names,\n+                        );\n                         Exact(i)\n                     }\n                     parse::ArgumentNamed(s, span) => {\n@@ -491,16 +521,15 @@ impl<'a, 'b> Context<'a, 'b> {\n         match c {\n             parse::CountImplied | parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n-                let start_of_named_args = self.args.len() - self.names.len();\n-                if i >= start_of_named_args {\n-                    self.unused_names_lint.maybe_push(\n-                        i,\n-                        named_arg_type,\n-                        self.curpiece,\n-                        inner_span.clone(),\n-                        &self.names,\n-                    );\n-                }\n+                self.unused_names_lint.maybe_add_positional_named_arg(\n+                    i,\n+                    self.args.len(),\n+                    i,\n+                    named_arg_type,\n+                    self.curpiece,\n+                    *inner_span,\n+                    &self.names,\n+                );\n                 self.verify_arg_type(Exact(i), Count);\n             }\n             parse::CountIsName(s, span) => {"}]}