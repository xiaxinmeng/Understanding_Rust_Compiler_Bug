{"sha": "9b47acfc104228c3da00ae5bfb55dfd17be1977a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNDdhY2ZjMTA0MjI4YzNkYTAwYWU1YmZiNTVkZmQxN2JlMTk3N2E=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-29T12:03:33Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-29T12:03:33Z"}, "message": "Create a struct for optimization fuel data", "tree": {"sha": "27019d019cafcf92c0a56c6b93a0b7d328fa7376", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27019d019cafcf92c0a56c6b93a0b7d328fa7376"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b47acfc104228c3da00ae5bfb55dfd17be1977a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b47acfc104228c3da00ae5bfb55dfd17be1977a", "html_url": "https://github.com/rust-lang/rust/commit/9b47acfc104228c3da00ae5bfb55dfd17be1977a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b47acfc104228c3da00ae5bfb55dfd17be1977a/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03b7cec2defdec00bef79045252341dd49fc9f0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/03b7cec2defdec00bef79045252341dd49fc9f0c", "html_url": "https://github.com/rust-lang/rust/commit/03b7cec2defdec00bef79045252341dd49fc9f0c"}], "stats": {"total": 56, "additions": 26, "deletions": 30}, "files": [{"sha": "f7e7c8d415955deafad7c7742378c05c02beb356", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9b47acfc104228c3da00ae5bfb55dfd17be1977a/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b47acfc104228c3da00ae5bfb55dfd17be1977a/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=9b47acfc104228c3da00ae5bfb55dfd17be1977a", "patch": "@@ -17,7 +17,7 @@ use util::common::ProfileQueriesMsg;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{\n-    self, Lrc, Lock, OneThread, Once, RwLock, AtomicU64, AtomicUsize, AtomicBool, Ordering,\n+    self, Lrc, Lock, OneThread, Once, RwLock, AtomicU64, AtomicUsize, Ordering,\n     Ordering::SeqCst,\n };\n \n@@ -50,6 +50,13 @@ pub mod config;\n pub mod filesearch;\n pub mod search_paths;\n \n+pub struct OptimizationFuel {\n+    /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n+    remaining: u64,\n+    /// We're rejecting all further optimizations.\n+    out_of_fuel: bool,\n+}\n+\n /// Represents the data associated with a compilation\n /// session for a single crate.\n pub struct Session {\n@@ -139,10 +146,9 @@ pub struct Session {\n \n     /// If -zfuel=crate=n is specified, Some(crate).\n     optimization_fuel_crate: Option<String>,\n-    /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n-    optimization_fuel_limit: AtomicU64,\n-    /// We're rejecting all further optimizations.\n-    out_of_fuel: AtomicBool,\n+\n+    /// Tracks fuel info if If -zfuel=crate=n is specified\n+    optimization_fuel: Lock<OptimizationFuel>,\n \n     // The next two are public because the driver needs to read them.\n     /// If -zprint-fuel=crate, Some(crate).\n@@ -859,43 +865,32 @@ impl Session {\n                  self.perf_stats.normalize_projection_ty.load(Ordering::Relaxed));\n     }\n \n-    #[inline(never)]\n-    #[cold]\n-    pub fn consider_optimizing_cold<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n+    /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n+    /// This expends fuel if applicable, and records fuel if applicable.\n+    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n         let mut ret = true;\n         if let Some(ref c) = self.optimization_fuel_crate {\n             if c == crate_name {\n                 assert_eq!(self.query_threads(), 1);\n-                let fuel = self.optimization_fuel_limit.load(SeqCst);\n-                ret = fuel != 0;\n-                if fuel == 0 && !self.out_of_fuel.load(SeqCst) {\n+                let mut fuel = self.optimization_fuel.lock();\n+                ret = fuel.remaining != 0;\n+                if fuel.remaining == 0 && !fuel.out_of_fuel {\n                     eprintln!(\"optimization-fuel-exhausted: {}\", msg());\n-                    self.out_of_fuel.store(true, SeqCst);\n-                } else if fuel > 0 {\n-                    self.optimization_fuel_limit.store(fuel - 1, SeqCst);\n+                    fuel.out_of_fuel = true;\n+                } else if fuel.remaining > 0 {\n+                    fuel.remaining -= 1;\n                 }\n             }\n         }\n         if let Some(ref c) = self.print_fuel_crate {\n             if c == crate_name {\n                 assert_eq!(self.query_threads(), 1);\n-                self.print_fuel.store(self.print_fuel.load(SeqCst) + 1, SeqCst);\n+                self.print_fuel.fetch_add(1, SeqCst);\n             }\n         }\n         ret\n     }\n \n-    /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n-    /// This expends fuel if applicable, and records fuel if applicable.\n-    #[inline(always)]\n-    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n-        if likely!(self.optimization_fuel_crate.is_none() && self.print_fuel_crate.is_none()) {\n-            true\n-        } else {\n-            self.consider_optimizing_cold(crate_name, msg)\n-        }\n-    }\n-\n     /// Returns the number of query threads that should be used for this\n     /// compilation\n     pub fn query_threads_from_opts(opts: &config::Options) -> usize {\n@@ -1140,8 +1135,10 @@ pub fn build_session_(\n         local_crate_source_file.map(|path| file_path_mapping.map_prefix(path).0);\n \n     let optimization_fuel_crate = sopts.debugging_opts.fuel.as_ref().map(|i| i.0.clone());\n-    let optimization_fuel_limit =\n-        AtomicU64::new(sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0));\n+    let optimization_fuel = Lock::new(OptimizationFuel {\n+        remaining: sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0),\n+        out_of_fuel: false,\n+    });\n     let print_fuel_crate = sopts.debugging_opts.print_fuel.clone();\n     let print_fuel = AtomicU64::new(0);\n \n@@ -1205,10 +1202,9 @@ pub fn build_session_(\n         },\n         code_stats: Default::default(),\n         optimization_fuel_crate,\n-        optimization_fuel_limit,\n+        optimization_fuel,\n         print_fuel_crate,\n         print_fuel,\n-        out_of_fuel: AtomicBool::new(false),\n         // Note that this is unsafe because it may misinterpret file descriptors\n         // on Unix as jobserver file descriptors. We hopefully execute this near\n         // the beginning of the process though to ensure we don't get false"}]}