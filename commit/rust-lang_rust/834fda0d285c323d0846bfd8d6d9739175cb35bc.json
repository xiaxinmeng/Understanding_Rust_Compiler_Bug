{"sha": "834fda0d285c323d0846bfd8d6d9739175cb35bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNGZkYTBkMjg1YzMyM2QwODQ2YmZkOGQ2ZDk3MzkxNzVjYjM1YmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-07T18:17:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-07T18:17:38Z"}, "message": "Merge #8388\n\n8388: Autoclose blocks when typing `{` r=jonas-schievink a=jonas-schievink\n\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "b25dcb73f9a702f06dd2302a8837d04e610c2e52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b25dcb73f9a702f06dd2302a8837d04e610c2e52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/834fda0d285c323d0846bfd8d6d9739175cb35bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgbfdCCRBK7hj4Ov3rIwAAdHIIAIdhvhOrLLoCoLOmsapc7RaM\n3PGQ1qj4FudEXH1fzdwcmvUmB5eB6Z+Ij2ExAC3NU01ayKa77kFmFocVlSFWWK8D\n1ZdaDMJFpXhV5qLSjGefVl5puWpKq5ZzhRYCbW/tvbPoK+dAUl3qVGlc5we2cz7I\nh45U0Y8JvIrTzLHcjXAZ7EcH/t4nc3+NQbLoM4aEsWQKKk9/sGISq2aGN8h77xF+\nzG07PqjBAZUc7OOw2+hEkgVXcSePpSSqC8T5bQKykSxeSdbHNDKlDpjz1GwM+cd4\nSR+RGBXGEcNexrMcW/cS50WP87lSBEljY72qQLDgE7pN+vp2EANC3ONxcI/qPk0=\n=Gm09\n-----END PGP SIGNATURE-----\n", "payload": "tree b25dcb73f9a702f06dd2302a8837d04e610c2e52\nparent 09b730d1e1b485ff582f3f237d39136ce50ea0cc\nparent d789cf8f31b3f8281046a352a73e17e15ff3c224\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617819458 +0000\ncommitter GitHub <noreply@github.com> 1617819458 +0000\n\nMerge #8388\n\n8388: Autoclose blocks when typing `{` r=jonas-schievink a=jonas-schievink\n\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/834fda0d285c323d0846bfd8d6d9739175cb35bc", "html_url": "https://github.com/rust-lang/rust/commit/834fda0d285c323d0846bfd8d6d9739175cb35bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/834fda0d285c323d0846bfd8d6d9739175cb35bc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09b730d1e1b485ff582f3f237d39136ce50ea0cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/09b730d1e1b485ff582f3f237d39136ce50ea0cc", "html_url": "https://github.com/rust-lang/rust/commit/09b730d1e1b485ff582f3f237d39136ce50ea0cc"}, {"sha": "d789cf8f31b3f8281046a352a73e17e15ff3c224", "url": "https://api.github.com/repos/rust-lang/rust/commits/d789cf8f31b3f8281046a352a73e17e15ff3c224", "html_url": "https://github.com/rust-lang/rust/commit/d789cf8f31b3f8281046a352a73e17e15ff3c224"}], "stats": {"total": 171, "additions": 154, "deletions": 17}, "files": [{"sha": "1378048e51b8fe8854fcdf126033c242f6a07e5c", "filename": "crates/ide/src/typing.rs", "status": "modified", "additions": 153, "deletions": 15, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/834fda0d285c323d0846bfd8d6d9739175cb35bc/crates%2Fide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/834fda0d285c323d0846bfd8d6d9739175cb35bc/crates%2Fide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ftyping.rs?ref=834fda0d285c323d0846bfd8d6d9739175cb35bc", "patch": "@@ -22,25 +22,27 @@ use ide_db::{\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, edit::IndentLevel, AstToken},\n-    AstNode, SourceFile,\n+    AstNode, Parse, SourceFile,\n     SyntaxKind::{FIELD_EXPR, METHOD_CALL_EXPR},\n     TextRange, TextSize,\n };\n \n-use text_edit::TextEdit;\n+use text_edit::{Indel, TextEdit};\n \n use crate::SourceChange;\n \n pub(crate) use on_enter::on_enter;\n \n-pub(crate) const TRIGGER_CHARS: &str = \".=>\";\n+// Don't forget to add new trigger characters to `server_capabilities` in `caps.rs`.\n+pub(crate) const TRIGGER_CHARS: &str = \".=>{\";\n \n // Feature: On Typing Assists\n //\n // Some features trigger on typing certain characters:\n //\n // - typing `let =` tries to smartly add `;` if `=` is followed by an existing expression\n // - typing `.` in a chain method call auto-indents\n+// - typing `{` in front of an expression inserts a closing `}` after the expression\n //\n // VS Code::\n //\n@@ -57,28 +59,79 @@ pub(crate) fn on_char_typed(\n     position: FilePosition,\n     char_typed: char,\n ) -> Option<SourceChange> {\n-    assert!(TRIGGER_CHARS.contains(char_typed));\n-    let file = &db.parse(position.file_id).tree();\n-    assert_eq!(file.syntax().text().char_at(position.offset), Some(char_typed));\n+    if !stdx::always!(TRIGGER_CHARS.contains(char_typed)) {\n+        return None;\n+    }\n+    let file = &db.parse(position.file_id);\n+    if !stdx::always!(file.tree().syntax().text().char_at(position.offset) == Some(char_typed)) {\n+        return None;\n+    }\n     let edit = on_char_typed_inner(file, position.offset, char_typed)?;\n     Some(SourceChange::from_text_edit(position.file_id, edit))\n }\n \n-fn on_char_typed_inner(file: &SourceFile, offset: TextSize, char_typed: char) -> Option<TextEdit> {\n-    assert!(TRIGGER_CHARS.contains(char_typed));\n+fn on_char_typed_inner(\n+    file: &Parse<SourceFile>,\n+    offset: TextSize,\n+    char_typed: char,\n+) -> Option<TextEdit> {\n+    if !stdx::always!(TRIGGER_CHARS.contains(char_typed)) {\n+        return None;\n+    }\n     match char_typed {\n-        '.' => on_dot_typed(file, offset),\n-        '=' => on_eq_typed(file, offset),\n-        '>' => on_arrow_typed(file, offset),\n+        '.' => on_dot_typed(&file.tree(), offset),\n+        '=' => on_eq_typed(&file.tree(), offset),\n+        '>' => on_arrow_typed(&file.tree(), offset),\n+        '{' => on_opening_brace_typed(file, offset),\n         _ => unreachable!(),\n     }\n }\n \n+/// Inserts a closing `}` when the user types an opening `{`, wrapping an existing expression in a\n+/// block.\n+fn on_opening_brace_typed(file: &Parse<SourceFile>, offset: TextSize) -> Option<TextEdit> {\n+    if !stdx::always!(file.tree().syntax().text().char_at(offset) == Some('{')) {\n+        return None;\n+    }\n+\n+    let brace_token = file.tree().syntax().token_at_offset(offset).right_biased()?;\n+\n+    // Remove the `{` to get a better parse tree, and reparse\n+    let file = file.reparse(&Indel::delete(brace_token.text_range()));\n+\n+    let mut expr: ast::Expr = find_node_at_offset(file.tree().syntax(), offset)?;\n+    if expr.syntax().text_range().start() != offset {\n+        return None;\n+    }\n+\n+    // Enclose the outermost expression starting at `offset`\n+    while let Some(parent) = expr.syntax().parent() {\n+        if parent.text_range().start() != expr.syntax().text_range().start() {\n+            break;\n+        }\n+\n+        match ast::Expr::cast(parent) {\n+            Some(parent) => expr = parent,\n+            None => break,\n+        }\n+    }\n+\n+    // If it's a statement in a block, we don't know how many statements should be included\n+    if ast::ExprStmt::can_cast(expr.syntax().parent()?.kind()) {\n+        return None;\n+    }\n+\n+    // Insert `}` right after the expression.\n+    Some(TextEdit::insert(expr.syntax().text_range().end() + TextSize::of(\"{\"), \"}\".to_string()))\n+}\n+\n /// Returns an edit which should be applied after `=` was typed. Primarily,\n /// this works when adding `let =`.\n // FIXME: use a snippet completion instead of this hack here.\n fn on_eq_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n-    assert_eq!(file.syntax().text().char_at(offset), Some('='));\n+    if !stdx::always!(file.syntax().text().char_at(offset) == Some('=')) {\n+        return None;\n+    }\n     let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.semicolon_token().is_some() {\n         return None;\n@@ -100,7 +153,9 @@ fn on_eq_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n \n /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n-    assert_eq!(file.syntax().text().char_at(offset), Some('.'));\n+    if !stdx::always!(file.syntax().text().char_at(offset) == Some('.')) {\n+        return None;\n+    }\n     let whitespace =\n         file.syntax().token_at_offset(offset).left_biased().and_then(ast::Whitespace::cast)?;\n \n@@ -129,7 +184,9 @@ fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n /// Adds a space after an arrow when `fn foo() { ... }` is turned into `fn foo() -> { ... }`\n fn on_arrow_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n     let file_text = file.syntax().text();\n-    assert_eq!(file_text.char_at(offset), Some('>'));\n+    if !stdx::always!(file_text.char_at(offset) == Some('>')) {\n+        return None;\n+    }\n     let after_arrow = offset + TextSize::of('>');\n     if file_text.char_at(after_arrow) != Some('{') {\n         return None;\n@@ -152,7 +209,7 @@ mod tests {\n         let edit = TextEdit::insert(offset, char_typed.to_string());\n         edit.apply(&mut before);\n         let parse = SourceFile::parse(&before);\n-        on_char_typed_inner(&parse.tree(), offset, char_typed).map(|it| {\n+        on_char_typed_inner(&parse, offset, char_typed).map(|it| {\n             it.apply(&mut before);\n             before.to_string()\n         })\n@@ -373,4 +430,85 @@ fn main() {\n     fn adds_space_after_return_type() {\n         type_char('>', \"fn foo() -$0{ 92 }\", \"fn foo() -> { 92 }\")\n     }\n+\n+    #[test]\n+    fn adds_closing_brace() {\n+        type_char(\n+            '{',\n+            r#\"\n+fn f() { match () { _ => $0() } }\n+            \"#,\n+            r#\"\n+fn f() { match () { _ => {()} } }\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+fn f() { $0() }\n+            \"#,\n+            r#\"\n+fn f() { {()} }\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+fn f() { let x = $0(); }\n+            \"#,\n+            r#\"\n+fn f() { let x = {()}; }\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+fn f() { let x = $0a.b(); }\n+            \"#,\n+            r#\"\n+fn f() { let x = {a.b()}; }\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+const S: () = $0();\n+fn f() {}\n+            \"#,\n+            r#\"\n+const S: () = {()};\n+fn f() {}\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+const S: () = $0a.b();\n+fn f() {}\n+            \"#,\n+            r#\"\n+const S: () = {a.b()};\n+fn f() {}\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+fn f() {\n+    match x {\n+        0 => $0(),\n+        1 => (),\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn f() {\n+    match x {\n+        0 => {()},\n+        1 => (),\n+    }\n+}\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "3c87782f28466fbec97927558894c92245793806", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/834fda0d285c323d0846bfd8d6d9739175cb35bc/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/834fda0d285c323d0846bfd8d6d9739175cb35bc/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=834fda0d285c323d0846bfd8d6d9739175cb35bc", "patch": "@@ -57,7 +57,7 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n         document_range_formatting_provider: None,\n         document_on_type_formatting_provider: Some(DocumentOnTypeFormattingOptions {\n             first_trigger_character: \"=\".to_string(),\n-            more_trigger_character: Some(vec![\".\".to_string(), \">\".to_string()]),\n+            more_trigger_character: Some(vec![\".\".to_string(), \">\".to_string(), \"{\".to_string()]),\n         }),\n         selection_range_provider: Some(SelectionRangeProviderCapability::Simple(true)),\n         folding_range_provider: Some(FoldingRangeProviderCapability::Simple(true)),"}, {"sha": "31d8c487be988fa593667d8685e3a7fd9354501b", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/834fda0d285c323d0846bfd8d6d9739175cb35bc/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/834fda0d285c323d0846bfd8d6d9739175cb35bc/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=834fda0d285c323d0846bfd8d6d9739175cb35bc", "patch": "@@ -231,7 +231,6 @@ pub(crate) fn handle_on_enter(\n     Ok(Some(edit))\n }\n \n-// Don't forget to add new trigger characters to `ServerCapabilities` in `caps.rs`.\n pub(crate) fn handle_on_type_formatting(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentOnTypeFormattingParams,"}]}