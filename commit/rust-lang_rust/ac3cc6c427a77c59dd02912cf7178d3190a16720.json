{"sha": "ac3cc6c427a77c59dd02912cf7178d3190a16720", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjM2NjNmM0MjdhNzdjNTlkZDAyOTEyY2Y3MTc4ZDMxOTBhMTY3MjA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-08T15:34:11Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-08T15:34:11Z"}, "message": "Rollup merge of #24143 - michaelsproul:extended-errors, r=pnkfelix\n\nI've taken another look at extended errors - fixing up the printing and adding a few more for match expressions.\r\n\r\nWith regards to printing, the previous behaviour was to just print the error message string directly, despite it containing indentation which caused it to overflow the standard terminal width of 80 columns (try `rustc --explain E0004`). The first approach I considered was to strip the leading whitespace from each line and lay out the text dynamically, inserting spaces in between. This approach became quite messy when taking multi-paragraph errors into account (and seemed overkill). The approach I settled on removes the indentation in the string itself and begins each message with a newline that is stripped before printing.\r\n\r\nI feel like complete extended errors would be nice to have for 1.0.0 and I'm happy to spearhead an effort to get them written. Brian got me onto writing them at an SF meetup and I think it shouldn't be too hard to get the remaining 80 or so written with the help of people who don't really work on compiler innards.", "tree": {"sha": "a44d351e78fef9f7026f0bda04566f30e65c1083", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a44d351e78fef9f7026f0bda04566f30e65c1083"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac3cc6c427a77c59dd02912cf7178d3190a16720", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac3cc6c427a77c59dd02912cf7178d3190a16720", "html_url": "https://github.com/rust-lang/rust/commit/ac3cc6c427a77c59dd02912cf7178d3190a16720", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac3cc6c427a77c59dd02912cf7178d3190a16720/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "926f38e588bb99aff1902fa94ab82b1db89cbbce", "url": "https://api.github.com/repos/rust-lang/rust/commits/926f38e588bb99aff1902fa94ab82b1db89cbbce", "html_url": "https://github.com/rust-lang/rust/commit/926f38e588bb99aff1902fa94ab82b1db89cbbce"}, {"sha": "039a5539986b38852bca772b8709bab533ca5be0", "url": "https://api.github.com/repos/rust-lang/rust/commits/039a5539986b38852bca772b8709bab533ca5be0", "html_url": "https://github.com/rust-lang/rust/commit/039a5539986b38852bca772b8709bab533ca5be0"}], "stats": {"total": 147, "additions": 115, "deletions": 32}, "files": [{"sha": "b15304d6dc50c5c5ce646efff5a4700306e39c35", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 113, "deletions": 31, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/ac3cc6c427a77c59dd02912cf7178d3190a16720/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3cc6c427a77c59dd02912cf7178d3190a16720/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ac3cc6c427a77c59dd02912cf7178d3190a16720", "patch": "@@ -10,51 +10,134 @@\n \n #![allow(non_snake_case)]\n \n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80 characters.\n+// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n-    E0001: r##\"\n-    This error suggests that the expression arm corresponding to the noted pattern\n-    will never be reached as for all possible values of the expression being matched,\n-    one of the preceding patterns will match.\n \n-    This means that perhaps some of the preceding patterns are too general, this\n-    one is too specific or the ordering is incorrect.\n+E0001: r##\"\n+This error suggests that the expression arm corresponding to the noted pattern\n+will never be reached as for all possible values of the expression being\n+matched, one of the preceding patterns will match.\n+\n+This means that perhaps some of the preceding patterns are too general, this one\n+is too specific or the ordering is incorrect.\n+\"##,\n+\n+E0002: r##\"\n+This error indicates that an empty match expression is illegal because the type\n+it is matching on is non-empty (there exist values of this type). In safe code\n+it is impossible to create an instance of an empty type, so empty match\n+expressions are almost never desired.  This error is typically fixed by adding\n+one or more cases to the match expression.\n+\n+An example of an empty type is `enum Empty { }`.\n \"##,\n \n-    E0003: r##\"\n-    Not-a-Number (NaN) values can not be compared for equality and hence can never match\n-    the input to a match expression. To match against NaN values, you should instead use\n-    the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n+E0003: r##\"\n+Not-a-Number (NaN) values cannot be compared for equality and hence can never\n+match the input to a match expression. To match against NaN values, you should\n+instead use the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n \"##,\n \n-    E0004: r##\"\n-    This error indicates that the compiler can not guarantee a matching pattern for one\n-    or more possible inputs to a match expression. Guaranteed matches are required in order\n-    to assign values to match expressions, or alternatively, determine the flow of execution.\n+E0004: r##\"\n+This error indicates that the compiler cannot guarantee a matching pattern for\n+one or more possible inputs to a match expression. Guaranteed matches are\n+required in order to assign values to match expressions, or alternatively,\n+determine the flow of execution.\n \n-    If you encounter this error you must alter your patterns so that every possible value of\n-    the input type is matched. For types with a small number of variants (like enums) you\n-    should probably cover all cases explicitly. Alternatively, the underscore `_` wildcard\n-    pattern can be added after all other patterns to match \"anything else\".\n+If you encounter this error you must alter your patterns so that every possible\n+value of the input type is matched. For types with a small number of variants\n+(like enums) you should probably cover all cases explicitly. Alternatively, the\n+underscore `_` wildcard pattern can be added after all other patterns to match\n+\"anything else\".\n \"##,\n \n-    // FIXME: Remove duplication here?\n-    E0005: r##\"\n-    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n-    name will be extracted in all cases. If you encounter this error you probably need\n-    to use a `match` or `if let` to deal with the possibility of failure.\n+// FIXME: Remove duplication here?\n+E0005: r##\"\n+Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+name will be extracted in all cases. If you encounter this error you probably need\n+to use a `match` or `if let` to deal with the possibility of failure.\n \"##,\n \n-    E0006: r##\"\n-    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n-    name will be extracted in all cases. If you encounter this error you probably need\n-    to use a `match` or `if let` to deal with the possibility of failure.\n+E0006: r##\"\n+Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+name will be extracted in all cases. If you encounter this error you probably need\n+to use a `match` or `if let` to deal with the possibility of failure.\n+\"##,\n+\n+E0007: r##\"\n+This error indicates that the bindings in a match arm would require a value to\n+be moved into more than one location, thus violating unique ownership. Code like\n+the following is invalid as it requires the entire Option<String> to be moved\n+into a variable called `op_string` while simultaneously requiring the inner\n+String to be moved into a variable called `s`.\n+\n+let x = Some(\"s\".to_string());\n+match x {\n+    op_string @ Some(s) => ...\n+    None => ...\n+}\n+\n+See also Error 303.\n+\"##,\n+\n+E0008: r##\"\n+Names bound in match arms retain their type in pattern guards. As such, if a\n+name is bound by move in a pattern, it should also be moved to wherever it is\n+referenced in the pattern guard code. Doing so however would prevent the name\n+from being available in the body of the match arm. Consider the following:\n+\n+match Some(\"hi\".to_string()) {\n+    Some(s) if s.len() == 0 => // use s.\n+    ...\n+}\n+\n+The variable `s` has type String, and its use in the guard is as a variable of\n+type String. The guard code effectively executes in a separate scope to the body\n+of the arm, so the value would be moved into this anonymous scope and therefore\n+become unavailable in the body of the arm. Although this example seems\n+innocuous, the problem is most clear when considering functions that take their\n+argument by value.\n+\n+match Some(\"hi\".to_string()) {\n+    Some(s) if { drop(s); false } => (),\n+    Some(s) => // use s.\n+    ...\n+}\n+\n+The value would be dropped in the guard then become unavailable not only in the\n+body of that arm but also in all subsequent arms! The solution is to bind by\n+reference when using guards or refactor the entire expression, perhaps by\n+putting the condition inside the body of the arm.\n+\"##,\n+\n+E0303: r##\"\n+In certain cases it is possible for sub-bindings to violate memory safety.\n+Updates to the borrow checker in a future version of Rust may remove this\n+restriction, but for now patterns must be rewritten without sub-bindings.\n+\n+// Code like this...\n+match Some(5) {\n+    ref op_num @ Some(num) => ...\n+    None => ...\n+}\n+\n+// ... should be updated to code like this.\n+match Some(5) {\n+    Some(num) => {\n+        let op_num = &Some(num);\n+        ...\n+    }\n+    None => ...\n+}\n+\n+See also https://github.com/rust-lang/rust/issues/14587\n \"##\n+\n }\n \n register_diagnostics! {\n-    E0002,\n-    E0007,\n-    E0008,\n     E0009,\n     E0010,\n     E0011,\n@@ -117,7 +200,6 @@ register_diagnostics! {\n     E0300, // unexpanded macro\n     E0301, // cannot mutable borrow in a pattern guard\n     E0302, // cannot assign in a pattern guard\n-    E0303, // pattern bindings are not allowed after an `@`\n     E0304, // expected signed integer constant\n     E0305, // expected constant\n     E0306, // expected positive integer for repeat count"}, {"sha": "89c19cfb0b02a8d714676eec12a1921f9dfad349", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac3cc6c427a77c59dd02912cf7178d3190a16720/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3cc6c427a77c59dd02912cf7178d3190a16720/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ac3cc6c427a77c59dd02912cf7178d3190a16720", "patch": "@@ -277,7 +277,8 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             Some(ref code) => {\n                 match descriptions.find_description(&code[..]) {\n                     Some(ref description) => {\n-                        println!(\"{}\", description);\n+                        // Slice off the leading newline and print.\n+                        print!(\"{}\", &description[1..]);\n                     }\n                     None => {\n                         early_error(&format!(\"no extended information for {}\", code));"}]}