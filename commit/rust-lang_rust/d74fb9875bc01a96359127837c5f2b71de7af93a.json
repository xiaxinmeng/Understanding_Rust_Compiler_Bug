{"sha": "d74fb9875bc01a96359127837c5f2b71de7af93a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NGZiOTg3NWJjMDFhOTYzNTkxMjc4MzdjNWYyYjcxZGU3YWY5M2E=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-21T02:06:32Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-25T19:12:25Z"}, "message": "Refactoring pipes to allow implementing bounded protocols.", "tree": {"sha": "803903b90dde0498715a460bbb0683e8f62259fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/803903b90dde0498715a460bbb0683e8f62259fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d74fb9875bc01a96359127837c5f2b71de7af93a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d74fb9875bc01a96359127837c5f2b71de7af93a", "html_url": "https://github.com/rust-lang/rust/commit/d74fb9875bc01a96359127837c5f2b71de7af93a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d74fb9875bc01a96359127837c5f2b71de7af93a/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f65d6026ef84d16e5b27ab4c852df46044091e2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f65d6026ef84d16e5b27ab4c852df46044091e2d", "html_url": "https://github.com/rust-lang/rust/commit/f65d6026ef84d16e5b27ab4c852df46044091e2d"}], "stats": {"total": 279, "additions": 216, "deletions": 63}, "files": [{"sha": "e020d5c3e9f4d7861d05dea1dd06c09c225238ce", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 211, "deletions": 61, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/d74fb9875bc01a96359127837c5f2b71de7af93a/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74fb9875bc01a96359127837c5f2b71de7af93a/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=d74fb9875bc01a96359127837c5f2b71de7af93a", "patch": "@@ -6,7 +6,7 @@ import option::unwrap;\n import arc::methods;\n \n // Things used by code generated by the pipe compiler.\n-export entangle;\n+export entangle, get_buffer, drop_buffer;\n \n // User-level things\n export send_packet, recv_packet, send, recv, try_recv, peek;\n@@ -22,39 +22,146 @@ macro_rules! move {\n // places. Once there is unary move, it can be removed.\n fn move<T>(-x: T) -> T { x }\n \n+/**\n+\n+Some thoughts about fixed buffers.\n+\n+The idea is if a protocol is bounded, we will synthesize a record that\n+has a field for each state. Each of these states contains a packet for\n+the messages that are legal to be sent in that state. Then, instead of\n+allocating, the send code just finds a pointer to the right field and\n+uses that instead.\n+\n+Unforunately, this makes things kind of tricky. We need to be able to\n+find the buffer, which means we need to pass it around. This could\n+either be associated with the (send|recv)_packet classes, or with the\n+packet itself. We will also need some form of reference counting so we\n+can track who has the responsibility of freeing the buffer.\n+\n+We want to preserve the ability to do things like optimistic buffer\n+re-use, and skipping over to a new buffer when necessary. What I mean\n+is, suppose we had the typical stream protocol. It'd make sense to\n+amortize allocation costs by allocating a buffer with say 16\n+messages. When the sender gets to the end of the buffer, it could\n+check if the receiver is done with the packet in slot 0. If so, it can\n+just reuse that one, checking if the receiver is done with the next\n+one in each case. If it is ever not done, it just allocates a new\n+buffer and skips over to that.\n+\n+Also, since protocols are in libcore, we have to do this in a way that\n+maintains backwards compatibility.\n+\n+buffer header and buffer. Cast as c_void when necessary.\n+\n+===\n+\n+Okay, here are some new ideas.\n+\n+It'd be nice to keep the bounded/unbounded case as uniform as\n+possible. It leads to less code duplication, and less things that can\n+go sublty wrong. For the bounded case, we could either have a struct\n+with a bunch of unique pointers to pre-allocated packets, or we could\n+lay them out inline. Inline layout is better, if for no other reason\n+than that we don't have to allocate each packet\n+individually. Currently we pass unique packets around as unsafe\n+pointers, but they are actually unique pointers. We should instead use\n+real unsafe pointers. This makes freeing data and running destructors\n+trickier though. Thus, we should allocate all packets in parter of a\n+higher level buffer structure. Packets can maintain a pointer to their\n+buffer, and this is the part that gets freed.\n+\n+It might be helpful to have some idea of a semi-unique pointer (like\n+being partially pregnant, also like an ARC). \n+\n+*/\n+\n enum state {\n     empty,\n     full,\n     blocked,\n     terminated\n }\n \n-type packet_header_ = {\n-    mut state: state,\n-    mut blocked_task: option<*rust_task>,\n+class buffer_header {\n+    // Tracks whether this buffer needs to be freed. We can probably\n+    // get away with restricting it to 0 or 1, if we're careful.\n+    let mut ref_count: int;\n+\n+    new() { self.ref_count = 1; }\n+\n+    // We may want a drop, and to be careful about stringing this\n+    // thing along.\n+}\n+\n+// This is for protocols to associate extra data to thread around.\n+type buffer<T: send> = {\n+    header: buffer_header,\n+    data: T,\n };\n \n-enum packet_header {\n-    packet_header_(packet_header_)\n+class packet_header {\n+    let mut state: state;\n+    let mut blocked_task: option<*rust_task>;\n+\n+    // This is a reinterpret_cast of a ~buffer, that can also be cast\n+    // to a buffer_header if need be.\n+    let mut buffer: *libc::c_void;\n+\n+    new() {\n+        self.state = empty;\n+        self.blocked_task = none;\n+        self.buffer = ptr::null();\n+    }\n+\n+    // Returns the old state.\n+    unsafe fn mark_blocked(this: *rust_task) -> state {\n+        self.blocked_task = some(this);\n+        swap_state_acq(self.state, blocked)\n+    }\n+\n+    unsafe fn unblock() {\n+        alt swap_state_acq(self.state, empty) {\n+          empty | blocked { }\n+          terminated { self.state = terminated; }\n+          full { self.state = full; }\n+        }\n+    }\n+\n+    // unsafe because this can do weird things to the space/time\n+    // continuum. It ends making multiple unique pointers to the same\n+    // thing. You'll proobably want to forget them when you're done.\n+    unsafe fn buf_header() -> ~buffer_header {\n+        assert self.buffer.is_not_null();\n+        reinterpret_cast(self.buffer)\n+    }\n }\n \n-type packet_<T:send> = {\n+type packet<T: send> = {\n     header: packet_header,\n-    mut payload: option<T>\n+    mut payload: option<T>,\n };\n \n-enum packet<T:send> {\n-    packet_(packet_<T>)\n+fn unibuffer<T: send>() -> ~buffer<packet<T>> {\n+    let b = ~{\n+        header: buffer_header(),\n+        data: {\n+            header: packet_header(),\n+            mut payload: none,\n+        }\n+    };\n+\n+    unsafe {\n+        b.data.header.buffer = reinterpret_cast(b);\n+    }\n+\n+    b\n }\n \n-fn packet<T: send>() -> *packet<T> unsafe {\n-    let p: *packet<T> = unsafe::transmute(~{\n-        header: {\n-            mut state: empty,\n-            mut blocked_task: none::<task::task>,\n-        },\n-        mut payload: none::<T>\n-    });\n+fn packet<T: send>() -> *packet<T> {\n+    let b = unibuffer();\n+    let p = ptr::addr_of(b.data);\n+    // We'll take over memory management from here.\n+    unsafe { forget(b) }\n     p\n }\n \n@@ -65,6 +172,10 @@ extern mod rusti {\n     fn atomic_xchng_rel(&dst: int, src: int) -> int;\n }\n \n+fn atomic_xchng_rel(&dst: int, src: int) -> int {\n+    rusti::atomic_xchng_rel(dst, src)\n+}\n+\n type rust_task = libc::c_void;\n \n extern mod rustrt {\n@@ -75,13 +186,7 @@ extern mod rustrt {\n     fn task_clear_event_reject(task: *rust_task);\n \n     fn task_wait_event(this: *rust_task, killed: &mut *libc::c_void) -> bool;\n-    fn task_signal_event(target: *rust_task, event: *libc::c_void);\n-}\n-\n-// We should consider moving this to core::unsafe, although I\n-// suspect graydon would want us to use void pointers instead.\n-unsafe fn uniquify<T>(x: *T) -> ~T {\n-    unsafe { unsafe::reinterpret_cast(x) }\n+    pure fn task_signal_event(target: *rust_task, event: *libc::c_void);\n }\n \n fn wait_event(this: *rust_task) -> *libc::c_void {\n@@ -110,18 +215,42 @@ fn swap_state_rel(&dst: state, src: state) -> state {\n     }\n }\n \n+unsafe fn get_buffer<T: send>(p: *packet_header) -> ~buffer<T> {\n+    transmute((*p).buf_header())\n+}\n+\n+class buffer_resource<T: send> {\n+    let buffer: ~buffer<T>;\n+    new(+b: ~buffer<T>) {\n+        self.buffer = b;\n+    }\n+\n+    drop unsafe {\n+        let b = move!{self.buffer};\n+        let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n+        if old_count == 0 {\n+            // go go gadget drop glue\n+        }\n+        else {\n+            forget(b)\n+        }\n+    }\n+}\n+\n fn send<T: send>(-p: send_packet<T>, -payload: T) {\n+    let header = p.header();\n     let p_ = p.unwrap();\n-    let p = unsafe { uniquify(p_) };\n-    assert (*p).payload == none;\n-    (*p).payload <- some(payload);\n+    let p = unsafe { &*p_ };\n+    assert ptr::addr_of(p.header) == header;\n+    assert p.payload == none;\n+    p.payload <- some(payload);\n     let old_state = swap_state_rel(p.header.state, full);\n     alt old_state {\n       empty {\n         // Yay, fastpath.\n \n         // The receiver will eventually clean this up.\n-        unsafe { forget(p); }\n+        //unsafe { forget(p); }\n       }\n       full { fail ~\"duplicate send\" }\n       blocked {\n@@ -135,7 +264,7 @@ fn send<T: send>(-p: send_packet<T>, -payload: T) {\n         }\n \n         // The receiver will eventually clean this up.\n-        unsafe { forget(p); }\n+        //unsafe { forget(p); }\n       }\n       terminated {\n         // The receiver will never receive this. Rely on drop_glue\n@@ -150,7 +279,7 @@ fn recv<T: send>(-p: recv_packet<T>) -> T {\n \n fn try_recv<T: send>(-p: recv_packet<T>) -> option<T> {\n     let p_ = p.unwrap();\n-    let p = unsafe { uniquify(p_) };\n+    let p = unsafe { &*p_ };\n     let this = rustrt::rust_get_task();\n     rustrt::task_clear_event_reject(this);\n     p.header.blocked_task = some(this);\n@@ -163,7 +292,7 @@ fn try_recv<T: send>(-p: recv_packet<T>) -> option<T> {\n           empty {\n             #debug(\"no data available on %?, going to sleep.\", p_);\n             wait_event(this);\n-            #debug(\"woke up, p.state = %?\", p.header.state);\n+            #debug(\"woke up, p.state = %?\", copy p.header.state);\n           }\n           blocked {\n             if first {\n@@ -172,7 +301,7 @@ fn try_recv<T: send>(-p: recv_packet<T>) -> option<T> {\n           }\n           full {\n             let mut payload = none;\n-            payload <-> (*p).payload;\n+            payload <-> p.payload;\n             p.header.state = terminated;\n             ret some(option::unwrap(payload))\n           }\n@@ -195,11 +324,11 @@ pure fn peek<T: send>(p: recv_packet<T>) -> bool {\n }\n \n fn sender_terminate<T: send>(p: *packet<T>) {\n-    let p = unsafe { uniquify(p) };\n+    let p = unsafe { &*p };\n     alt swap_state_rel(p.header.state, terminated) {\n       empty {\n         // The receiver will eventually clean up.\n-        unsafe { forget(p) }\n+        //unsafe { forget(p) }\n       }\n       blocked {\n         // wake up the target\n@@ -208,7 +337,7 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n                                   ptr::addr_of(p.header) as *libc::c_void);\n \n         // The receiver will eventually clean up.\n-        unsafe { forget(p) }\n+        //unsafe { forget(p) }\n       }\n       full {\n         // This is impossible\n@@ -221,11 +350,11 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n }\n \n fn receiver_terminate<T: send>(p: *packet<T>) {\n-    let p = unsafe { uniquify(p) };\n+    let p = unsafe { &*p };\n     alt swap_state_rel(p.header.state, terminated) {\n       empty {\n         // the sender will clean up\n-        unsafe { forget(p) }\n+        //unsafe { forget(p) }\n       }\n       blocked {\n         // this shouldn't happen.\n@@ -237,24 +366,6 @@ fn receiver_terminate<T: send>(p: *packet<T>) {\n     }\n }\n \n-impl private_methods for *packet_header {\n-    // Returns the old state.\n-    unsafe fn mark_blocked(this: *rust_task) -> state {\n-        let self = &*self;\n-        self.blocked_task = some(this);\n-        swap_state_acq(self.state, blocked)\n-    }\n-\n-    unsafe fn unblock() {\n-        let self = &*self;\n-        alt swap_state_acq(self.state, empty) {\n-          empty | blocked { }\n-          terminated { self.state = terminated; }\n-          full { self.state = full; }\n-        }\n-    }\n-}\n-\n #[doc = \"Returns when one of the packet headers reports data is\n available.\"]\n fn wait_many(pkts: &[*packet_header]) -> uint {\n@@ -264,6 +375,7 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n     let mut data_avail = false;\n     let mut ready_packet = pkts.len();\n     for pkts.eachi |i, p| unsafe {\n+        let p = unsafe { &*p };\n         let old = p.mark_blocked(this);\n         alt old {\n           full | terminated {\n@@ -295,7 +407,7 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n \n     #debug(\"%?\", pkts[ready_packet]);\n \n-    for pkts.each |p| { unsafe{p.unblock()} }\n+    for pkts.each |p| { unsafe{ (*p).unblock()} }\n \n     #debug(\"%?, %?\", ready_packet, pkts[ready_packet]);\n \n@@ -359,11 +471,23 @@ fn select<T: send>(+endpoints: ~[recv_packet<T>])\n     (ready, result, remaining)\n }\n \n-class send_packet<T: send> {\n+type send_packet<T: send> = send_packet_buffered<T, packet<T>>;\n+\n+fn send_packet<T: send>(p: *packet<T>) -> send_packet<T> {\n+    send_packet_buffered(p)\n+}\n+\n+class send_packet_buffered<T: send, Tbuffer: send> {\n     let mut p: option<*packet<T>>;\n+    let mut buffer: option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n         //#debug(\"take send %?\", p);\n         self.p = some(p);\n+        unsafe {\n+            self.buffer = some(\n+                buffer_resource(\n+                    get_buffer(ptr::addr_of((*p).header))));\n+        };\n     }\n     drop {\n         //if self.p != none {\n@@ -380,13 +504,39 @@ class send_packet<T: send> {\n         p <-> self.p;\n         option::unwrap(p)\n     }\n+\n+    pure fn header() -> *packet_header {\n+        alt self.p {\n+          some(packet) {\n+            unsafe {\n+                let packet = &*packet;\n+                let header = ptr::addr_of(packet.header);\n+                //forget(packet);\n+                header\n+            }\n+          }\n+          none { fail ~\"packet already consumed\" }\n+        }\n+    }\n }\n \n-class recv_packet<T: send> {\n+type recv_packet<T: send> = recv_packet_buffered<T, packet<T>>;\n+\n+fn recv_packet<T: send>(p: *packet<T>) -> recv_packet<T> {\n+    recv_packet_buffered(p)\n+}\n+\n+class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     let mut p: option<*packet<T>>;\n+    let mut buffer: option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n         //#debug(\"take recv %?\", p);\n         self.p = some(p);\n+        unsafe {\n+            self.buffer = some(\n+                buffer_resource(\n+                    get_buffer(ptr::addr_of((*p).header))));\n+        };\n     }\n     drop {\n         //if self.p != none {\n@@ -408,9 +558,9 @@ class recv_packet<T: send> {\n         alt self.p {\n           some(packet) {\n             unsafe {\n-                let packet = uniquify(packet);\n+                let packet = &*packet;\n                 let header = ptr::addr_of(packet.header);\n-                forget(packet);\n+                //forget(packet);\n                 header\n             }\n           }"}, {"sha": "70423f5437cd1f0a35ff6db464d60c2286e7b2f2", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d74fb9875bc01a96359127837c5f2b71de7af93a/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74fb9875bc01a96359127837c5f2b71de7af93a/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=d74fb9875bc01a96359127837c5f2b71de7af93a", "patch": "@@ -51,10 +51,12 @@ impl compile of gen_send for message {\n                 |n, t| cx.arg_mode(n, t, ast::by_copy)\n             );\n \n+            let pipe_ty = cx.ty_path_ast_builder(\n+                path(this.data_name())\n+                .add_tys(cx.ty_vars(this.ty_params)));\n             let args_ast = vec::append(\n                 ~[cx.arg_mode(@~\"pipe\",\n-                              cx.ty_path_ast_builder(path(this.data_name())\n-                                        .add_tys(cx.ty_vars(this.ty_params))),\n+                              pipe_ty,\n                               ast::by_copy)],\n                 args_ast);\n \n@@ -73,6 +75,7 @@ impl compile of gen_send for message {\n                                       .map(|x| *x),\n                                       ~\", \"));\n             body += #fmt(\"pipes::send(pipe, message);\\n\");\n+            // return the new channel\n             body += ~\"c }\";\n \n             let body = cx.parse_expr(body);"}]}