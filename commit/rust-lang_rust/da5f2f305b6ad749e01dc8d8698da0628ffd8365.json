{"sha": "da5f2f305b6ad749e01dc8d8698da0628ffd8365", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNWYyZjMwNWI2YWQ3NDllMDFkYzhkODY5OGRhMDYyOGZmZDgzNjU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-27T18:39:00Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-27T18:39:00Z"}, "message": "implement TLS cleanup for macOS", "tree": {"sha": "900f557850e81daebba2fcb360819314d5c479d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/900f557850e81daebba2fcb360819314d5c479d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da5f2f305b6ad749e01dc8d8698da0628ffd8365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da5f2f305b6ad749e01dc8d8698da0628ffd8365", "html_url": "https://github.com/rust-lang/rust/commit/da5f2f305b6ad749e01dc8d8698da0628ffd8365", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da5f2f305b6ad749e01dc8d8698da0628ffd8365/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2a9c7baed31d29c02d62acfcf49e61af1c37f12", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2a9c7baed31d29c02d62acfcf49e61af1c37f12", "html_url": "https://github.com/rust-lang/rust/commit/e2a9c7baed31d29c02d62acfcf49e61af1c37f12"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "7f07fc1a7db6b0bb76138688df9ede07de2d47a4", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da5f2f305b6ad749e01dc8d8698da0628ffd8365/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5f2f305b6ad749e01dc8d8698da0628ffd8365/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=da5f2f305b6ad749e01dc8d8698da0628ffd8365", "patch": "@@ -186,8 +186,8 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) -> Option<i64> {\n     // FIXME: We always ignore leaks on some OSs where we do not\n     // correctly implement TLS destructors.\n-    let target_os = tcx.sess.target.target.target_os.as_str();\n-    let ignore_leaks = config.ignore_leaks || target_os == \"windows\" || target_os == \"macos\";\n+    let target_os = &tcx.sess.target.target.target_os;\n+    let ignore_leaks = config.ignore_leaks || target_os == \"windows\";\n \n     let (mut ecx, ret_place) = match create_ecx(tcx, main_id, config) {\n         Ok(v) => v,"}, {"sha": "325be877d0443a94ea181c36cca3db59fd766af9", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da5f2f305b6ad749e01dc8d8698da0628ffd8365/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5f2f305b6ad749e01dc8d8698da0628ffd8365/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=da5f2f305b6ad749e01dc8d8698da0628ffd8365", "patch": "@@ -87,7 +87,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"_tlv_atexit\" => {\n-                // FIXME: register the destructor.\n+                let dtor = this.read_scalar(args[0])?.not_undef()?;\n+                let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n+                let data = this.read_scalar(args[1])?.not_undef()?;\n+                this.machine.tls.set_global_dtor(dtor, data)?;\n             }\n \n             \"_NSGetArgc\" => {"}, {"sha": "6635978cb2e37a472e61772de7ccdfd5f69143c7", "filename": "src/shims/tls.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/da5f2f305b6ad749e01dc8d8698da0628ffd8365/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5f2f305b6ad749e01dc8d8698da0628ffd8365/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=da5f2f305b6ad749e01dc8d8698da0628ffd8365", "patch": "@@ -25,13 +25,21 @@ pub struct TlsData<'tcx> {\n \n     /// pthreads-style thread-local storage.\n     keys: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+\n+    /// A single global dtor (that's how things work on macOS) with a data argument.\n+    global_dtor: Option<(ty::Instance<'tcx>, Scalar<Tag>)>,\n+\n+    /// Whether we are in the \"destruct\" phase, during which some operations are UB.\n+    dtors_running: bool,\n }\n \n impl<'tcx> Default for TlsData<'tcx> {\n     fn default() -> Self {\n         TlsData {\n             next_key: 1, // start with 1 as we must not use 0 on Windows\n             keys: Default::default(),\n+            global_dtor: None,\n+            dtors_running: false,\n         }\n     }\n }\n@@ -86,6 +94,19 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n+    pub fn set_global_dtor(&mut self, dtor: ty::Instance<'tcx>, data: Scalar<Tag>) -> InterpResult<'tcx> {\n+        if self.dtors_running {\n+            // UB, according to libstd docs.\n+            throw_ub_format!(\"setting global destructor while destructors are already running\");\n+        }\n+        if self.global_dtor.is_some() {\n+            throw_unsup_format!(\"setting more than one global destructor is not supported\");\n+        }\n+\n+        self.global_dtor = Some((dtor, data));\n+        Ok(())\n+    }\n+\n     /// Returns a dtor, its argument and its index, if one is supposed to run\n     ///\n     /// An optional destructor function may be associated with each key value.\n@@ -134,11 +155,30 @@ impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tc\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn run_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        assert!(!this.machine.tls.dtors_running, \"running TLS dtors twice\");\n+        this.machine.tls.dtors_running = true;\n+\n+        // The macOS global dtor runs \"before any TLS slots get freed\", so do that first.\n+        if let Some((instance, data)) = this.machine.tls.global_dtor {\n+            trace!(\"Running global dtor {:?} on {:?}\", instance, data);\n+\n+            let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n+            this.call_function(\n+                instance,\n+                &[data.into()],\n+                Some(ret_place),\n+                StackPopCleanup::None { cleanup: true },\n+            )?;\n+\n+            // step until out of stackframes\n+            this.run()?;\n+        }\n+\n+        // Now run the \"keyed\" destructors.\n         let mut dtor = this.machine.tls.fetch_tls_dtor(None);\n-        // FIXME: replace loop by some structure that works with stepping\n         while let Some((instance, ptr, key)) = dtor {\n             trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n-            assert!(!this.is_null(ptr).unwrap(), \"Data can't be NULL when dtor is called!\");\n+            assert!(!this.is_null(ptr).unwrap(), \"data can't be NULL when dtor is called!\");\n \n             let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n             this.call_function("}]}