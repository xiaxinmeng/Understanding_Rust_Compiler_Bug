{"sha": "b2a02b580d4193a75e4aacdd58e87805437480c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYTAyYjU4MGQ0MTkzYTc1ZTRhYWNkZDU4ZTg3ODA1NDM3NDgwYzU=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-17T18:40:39Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-18T12:10:39Z"}, "message": "Fill in documentation for HashSet.\n\nExample how to use the set with a custom type. Fill in examples for the missing methods.", "tree": {"sha": "336048da5188805dc5068420d4e6569e1c346300", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/336048da5188805dc5068420d4e6569e1c346300"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2a02b580d4193a75e4aacdd58e87805437480c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2a02b580d4193a75e4aacdd58e87805437480c5", "html_url": "https://github.com/rust-lang/rust/commit/b2a02b580d4193a75e4aacdd58e87805437480c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2a02b580d4193a75e4aacdd58e87805437480c5/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9f1d6b7f69f293ba5f060fd9e179de228d9497b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f1d6b7f69f293ba5f060fd9e179de228d9497b", "html_url": "https://github.com/rust-lang/rust/commit/d9f1d6b7f69f293ba5f060fd9e179de228d9497b"}], "stats": {"total": 304, "additions": 267, "deletions": 37}, "files": [{"sha": "12b80d1b4674d70fb7251fbadd3588fb4565d83d", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 267, "deletions": 37, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/b2a02b580d4193a75e4aacdd58e87805437480c5/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a02b580d4193a75e4aacdd58e87805437480c5/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=b2a02b580d4193a75e4aacdd58e87805437480c5", "patch": "@@ -1514,49 +1514,39 @@ pub type SetMoveItems<K> =\n ///     println!(\"{}\", *book);\n /// }\n /// ```\n+///\n+/// The easiest way to use `HashSet` with a custom type is to derive\n+/// `Eq` and `Hash`. We must also derive `PartialEq`, this will in the\n+/// future be implied by `Eq`.\n+///\n+/// ```rust\n+/// use std::collections::HashSet;\n+///\n+/// #[deriving(Hash, Eq, PartialEq, Show)]\n+/// struct Viking<'a> {\n+///     name: &'a str,\n+///     power: uint,\n+/// }\n+///\n+/// let mut vikings = HashSet::new();\n+///\n+/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n+/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n+/// vikings.insert(Viking { name: \"Olaf\", power: 4u });\n+/// vikings.insert(Viking { name: \"Harald\", power: 8u });\n+///\n+/// // Use derived implementation to print the vikings.\n+/// for x in vikings.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+/// ```\n #[deriving(Clone)]\n pub struct HashSet<T, H = RandomSipHasher> {\n     map: HashMap<T, (), H>\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n-    fn eq(&self, other: &HashSet<T, H>) -> bool {\n-        if self.len() != other.len() { return false; }\n-\n-        self.iter().all(|key| other.contains(key))\n-    }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Collection for HashSet<T, H> {\n-    fn len(&self) -> uint { self.map.len() }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n-    fn clear(&mut self) { self.map.clear() }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n-    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n-\n-    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n-        self.iter().all(|v| !other.contains(v))\n-    }\n-\n-    fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n-        self.iter().all(|v| other.contains(v))\n-    }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n-    /// Create an empty HashSet\n+    /// Create an empty HashSet.\n     ///\n     /// # Example\n     ///\n@@ -1589,6 +1579,17 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// keys.\n     ///\n     /// The hash set is also created with the default initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut set = HashSet::with_hasher(h);\n+    /// set.insert(2u);\n+    /// ```\n     #[inline]\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n@@ -1601,6 +1602,17 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// is designed to allow `HashSet`s to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut set = HashSet::with_capacity_and_hasher(10u, h);\n+    /// set.insert(1i);\n+    /// ```\n     #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n         HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n@@ -1621,6 +1633,45 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n     /// Returns true if the hash set contains a value equivalent to the\n     /// given query value.\n+    ///\n+    /// # Example\n+    ///\n+    /// This is a slightly silly example where we define the number's\n+    /// parity as the equivilance class. It is important that the\n+    /// values hash the same, which is why we implement `Hash`.\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// use std::hash::Hash;\n+    /// use std::hash::sip::SipState;\n+    ///\n+    /// #[deriving(Eq, PartialEq)]\n+    /// struct EvenOrOdd {\n+    ///     num: uint\n+    /// };\n+    ///\n+    /// impl Hash for EvenOrOdd {\n+    ///     fn hash(&self, state: &mut SipState) {\n+    ///         let parity = self.num % 2;\n+    ///         parity.hash(state);\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n+    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n+    ///         self.num % 2 == other.num % 2\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut set = HashSet::new();\n+    /// set.insert(EvenOrOdd { num: 3u });\n+    ///\n+    /// assert!(set.contains_equiv(&EvenOrOdd { num: 3u }));\n+    /// assert!(set.contains_equiv(&EvenOrOdd { num: 5u }));\n+    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 4u }));\n+    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 2u }));\n+    ///\n+    /// ```\n     pub fn contains_equiv<Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n@@ -1771,7 +1822,154 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     }\n }\n \n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n+    /// Partial equality between sets.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [1i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let c: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    ///\n+    /// assert!(a.eq(&c));\n+    ///\n+    /// // eq and ne defines the == and != operators\n+    /// assert!(a == c);\n+    /// assert!(a != b);\n+    /// ```\n+    fn eq(&self, other: &HashSet<T, H>) -> bool {\n+        if self.len() != other.len() { return false; }\n+\n+        self.iter().all(|key| other.contains(key))\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Collection for HashSet<T, H> {\n+    /// Return the number of elements in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let set: HashSet<int> = [1i, 2, 3, 2].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.len(), 3);\n+    /// ```\n+    fn len(&self) -> uint { self.map.len() }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n+    /// Clear the set. Keeps the allocated memory for reuse.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// set.clear();\n+    /// assert!(set.is_empty());\n+    /// ```\n+    fn clear(&mut self) { self.map.clear() }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n+    /// Return true if `value` is contained by the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let set: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+\n+    /// Return true if the set is disjoint with `other`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: HashSet<int> = HashSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n+        self.iter().all(|v| !other.contains(v))\n+    }\n+\n+    /// Return true if the set is a subset of `other`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let sup: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: HashSet<int> = HashSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n+        self.iter().all(|v| other.contains(v))\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n+    /// Insert an element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(2i);\n+    /// set.insert(2i);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove an element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(2i);\n+    ///\n+    /// // Return boolean success flag.\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n+\n impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n+    /// Implement the `Show` trait for easy output format. The values in the\n+    /// set must also implement `Show`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// // Will call .fmt() to print, in some order.\n+    /// println!(\"{}\", a);\n+    /// ```\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n \n@@ -1785,6 +1983,17 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n+    /// Build a set from an external iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let values = vec!(1i, 2, 3);\n+    /// let set: HashSet<int> = values.move_iter().collect();\n+    /// let another_set: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set, another_set);\n+    /// ```\n     fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> {\n         let (lower, _) = iter.size_hint();\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n@@ -1794,6 +2003,18 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T,\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n+    /// Extend the set with the values yielded by an iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let values = vec!(1i, 2, 3);\n+    /// let mut set = HashSet::new();\n+    /// set.insert(0i);\n+    /// set.extend(values.move_iter());\n+    /// assert_eq!(set.len(), 4);\n+    /// ```\n     fn extend<I: Iterator<T>>(&mut self, mut iter: I) {\n         for k in iter {\n             self.insert(k);\n@@ -1802,6 +2023,15 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H>\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n+    /// Create a default set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// use std::default::Default;\n+    /// let mut set: HashSet<int> = Default::default();\n+    /// ```\n     fn default() -> HashSet<T, H> {\n         HashSet::with_hasher(Default::default())\n     }"}]}