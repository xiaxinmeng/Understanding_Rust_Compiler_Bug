{"sha": "679eb9191dd06a2e0dacf3602da56765211fd76a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3OWViOTE5MWRkMDZhMmUwZGFjZjM2MDJkYTU2NzY1MjExZmQ3NmE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-06T16:25:09Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-06T18:08:24Z"}, "message": "DTSify libserialize traits\n\n- ToBase64\n- FromBase64\n- ToHex\n- FromHex\n- ToJson\n- Encodable", "tree": {"sha": "5f54112030558429db3a1e1729faa5ef5b0da9ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f54112030558429db3a1e1729faa5ef5b0da9ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/679eb9191dd06a2e0dacf3602da56765211fd76a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/679eb9191dd06a2e0dacf3602da56765211fd76a", "html_url": "https://github.com/rust-lang/rust/commit/679eb9191dd06a2e0dacf3602da56765211fd76a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/679eb9191dd06a2e0dacf3602da56765211fd76a/comments", "author": null, "committer": null, "parents": [{"sha": "60a669a1743b845dfa349684ef057bc98ec6d840", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a669a1743b845dfa349684ef057bc98ec6d840", "html_url": "https://github.com/rust-lang/rust/commit/60a669a1743b845dfa349684ef057bc98ec6d840"}], "stats": {"total": 43, "additions": 25, "deletions": 18}, "files": [{"sha": "f287fb99750aa6a09b2ac44a054c1ac5eb2be5b9", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/679eb9191dd06a2e0dacf3602da56765211fd76a/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679eb9191dd06a2e0dacf3602da56765211fd76a/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=679eb9191dd06a2e0dacf3602da56765211fd76a", "patch": "@@ -54,13 +54,13 @@ static URLSAFE_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                        0123456789-_\";\n \n /// A trait for converting a value to base64 encoding.\n-pub trait ToBase64 {\n+pub trait ToBase64 for Sized? {\n     /// Converts the value of `self` to a base64 value following the specified\n     /// format configuration, returning the owned string.\n     fn to_base64(&self, config: Config) -> String;\n }\n \n-impl<'a> ToBase64 for &'a [u8] {\n+impl ToBase64 for [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a base64 string.\n      *\n@@ -155,7 +155,7 @@ impl<'a> ToBase64 for &'a [u8] {\n }\n \n /// A trait for converting from base64 encoded values.\n-pub trait FromBase64 {\n+pub trait FromBase64 for Sized? {\n     /// Converts the value of `self`, interpreted as base64 encoded data, into\n     /// an owned vector of bytes, returning the vector.\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error>;\n@@ -192,7 +192,7 @@ impl error::Error for FromBase64Error {\n     }\n }\n \n-impl<'a> FromBase64 for &'a str {\n+impl FromBase64 for str {\n     /**\n      * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n@@ -227,7 +227,7 @@ impl<'a> FromBase64 for &'a str {\n     }\n }\n \n-impl<'a> FromBase64 for &'a [u8] {\n+impl FromBase64 for [u8] {\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n         let mut r = Vec::new();\n         let mut buf: u32 = 0;"}, {"sha": "e045f94c08e67b87840609ec7d351a662ab381a7", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/679eb9191dd06a2e0dacf3602da56765211fd76a/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679eb9191dd06a2e0dacf3602da56765211fd76a/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=679eb9191dd06a2e0dacf3602da56765211fd76a", "patch": "@@ -16,15 +16,15 @@ use std::string;\n use std::error;\n \n /// A trait for converting a value to hexadecimal encoding\n-pub trait ToHex {\n+pub trait ToHex for Sized? {\n     /// Converts the value of `self` to a hex value, returning the owned\n     /// string.\n     fn to_hex(&self) -> String;\n }\n \n static CHARS: &'static[u8] = b\"0123456789abcdef\";\n \n-impl<'a> ToHex for &'a [u8] {\n+impl ToHex for [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a hexadecimal string.\n      *\n@@ -54,7 +54,7 @@ impl<'a> ToHex for &'a [u8] {\n }\n \n /// A trait for converting hexadecimal encoded values\n-pub trait FromHex {\n+pub trait FromHex for Sized? {\n     /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n     /// into an owned vector of bytes, returning the vector.\n     fn from_hex(&self) -> Result<Vec<u8>, FromHexError>;\n@@ -92,7 +92,7 @@ impl error::Error for FromHexError {\n }\n \n \n-impl<'a> FromHex for &'a str {\n+impl FromHex for str {\n     /**\n      * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes."}, {"sha": "7093fefeb8f375f4d4d22c8091e5d5d8fb59a543", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/679eb9191dd06a2e0dacf3602da56765211fd76a/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679eb9191dd06a2e0dacf3602da56765211fd76a/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=679eb9191dd06a2e0dacf3602da56765211fd76a", "patch": "@@ -2303,7 +2303,7 @@ impl ::Decoder<DecoderError> for Decoder {\n }\n \n /// A trait for converting values to JSON\n-pub trait ToJson {\n+pub trait ToJson for Sized? {\n     /// Converts the value of `self` to an instance of JSON\n     fn to_json(&self) -> Json;\n }\n@@ -2389,7 +2389,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n \n-impl<'a, A: ToJson> ToJson for &'a [A] {\n+impl<A: ToJson> ToJson for [A] {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n "}, {"sha": "7539a6dc3486b285ea54f31313f8c971c31ef342", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/679eb9191dd06a2e0dacf3602da56765211fd76a/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679eb9191dd06a2e0dacf3602da56765211fd76a/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=679eb9191dd06a2e0dacf3602da56765211fd76a", "patch": "@@ -169,7 +169,7 @@ pub trait Decoder<E> {\n     fn error(&mut self, err: &str) -> E;\n }\n \n-pub trait Encodable<S:Encoder<E>, E> {\n+pub trait Encodable<S:Encoder<E>, E> for Sized? {\n     fn encode(&self, s: &mut S) -> Result<(), E>;\n }\n \n@@ -297,9 +297,9 @@ impl<E, D:Decoder<E>> Decodable<D, E> for i64 {\n     }\n }\n \n-impl<'a, E, S:Encoder<E>> Encodable<S, E> for &'a str {\n+impl<E, S:Encoder<E>> Encodable<S, E> for str {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(*self)\n+        s.emit_str(self)\n     }\n }\n \n@@ -375,24 +375,31 @@ impl<E, D:Decoder<E>> Decodable<D, E> for () {\n     }\n }\n \n-impl<'a, E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for &'a T {\n+impl<'a, E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for &'a T {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Box<T> {\n+impl<E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for Box<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Box<T> {\n+impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<T> {\n     fn decode(d: &mut D) -> Result<Box<T>, E> {\n         Ok(box try!(Decodable::decode(d)))\n     }\n }\n \n+impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<[T]> {\n+    fn decode(d: &mut D) -> Result<Box<[T]>, E> {\n+        let v: Vec<T> = try!(Decodable::decode(d));\n+        Ok(v.into_boxed_slice())\n+    }\n+}\n+\n impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Rc<T> {\n     #[inline]\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n@@ -407,7 +414,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Rc<T> {\n     }\n }\n \n-impl<'a, E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for &'a [T] {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for [T] {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {"}]}