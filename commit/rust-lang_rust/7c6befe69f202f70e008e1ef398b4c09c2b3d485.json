{"sha": "7c6befe69f202f70e008e1ef398b4c09c2b3d485", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNmJlZmU2OWYyMDJmNzBlMDA4ZTFlZjM5OGI0YzA5YzJiM2Q0ODU=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-07-31T10:41:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-31T10:41:29Z"}, "message": "Merge pull request #274 from RalfJung/packed2\n\nmake force_allocation handle packed ByValPair", "tree": {"sha": "1712af9533fc408bbd7b6fa66c1046c3b177d000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1712af9533fc408bbd7b6fa66c1046c3b177d000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c6befe69f202f70e008e1ef398b4c09c2b3d485", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6befe69f202f70e008e1ef398b4c09c2b3d485", "html_url": "https://github.com/rust-lang/rust/commit/7c6befe69f202f70e008e1ef398b4c09c2b3d485", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c6befe69f202f70e008e1ef398b4c09c2b3d485/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f906c5458c43d0666dd9af37f44cd46a190f0506", "url": "https://api.github.com/repos/rust-lang/rust/commits/f906c5458c43d0666dd9af37f44cd46a190f0506", "html_url": "https://github.com/rust-lang/rust/commit/f906c5458c43d0666dd9af37f44cd46a190f0506"}, {"sha": "4458001644d084f9741ccc0227ed1afb96ca0dbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4458001644d084f9741ccc0227ed1afb96ca0dbf", "html_url": "https://github.com/rust-lang/rust/commit/4458001644d084f9741ccc0227ed1afb96ca0dbf"}], "stats": {"total": 326, "additions": 187, "deletions": 139}, "files": [{"sha": "bbaaba08a14ddd4689bd283e8a7402aded1c7f50", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 75, "deletions": 45, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -142,6 +142,12 @@ impl Default for ResourceLimits {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct TyAndPacked<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub packed: bool,\n+}\n+\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n         EvalContext {\n@@ -381,7 +387,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .expect(\"global should have been cached (static)\");\n                 match global_value.value {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    Value::ByRef(ptr, _aligned) =>\n+                    Value::ByRef { ptr, aligned: _aligned } =>\n                         // Alignment does not matter for this call\n                         self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n@@ -439,7 +445,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n-        if let Some(Value::ByRef(ptr, _aligned)) = local {\n+        if let Some(Value::ByRef { ptr, aligned: _ }) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -609,7 +615,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     let operand_ty = self.operand_ty(operand);\n                                     assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n+                                let (offset, TyAndPacked { ty, packed: _}) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n+                                // TODO: The packed flag is ignored\n \n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr()?;\n@@ -702,7 +709,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 };\n-\n                 self.write_value(val, dest, dest_ty)?;\n             }\n \n@@ -745,7 +751,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let src_ty = self.operand_ty(operand);\n                         if self.type_is_fat_ptr(src_ty) {\n                             match (src, self.type_is_fat_ptr(dest_ty)) {\n-                                (Value::ByRef(..), _) |\n+                                (Value::ByRef{..}, _) |\n                                 (Value::ByValPair(..), true) => {\n                                     self.write_value(src, dest, dest_ty)?;\n                                 },\n@@ -826,7 +832,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         nndiscr: u64,\n         discrfield: &[u32],\n-    ) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n+    ) -> EvalResult<'tcx, (Size, TyAndPacked<'tcx>)> {\n         // Skip the constant 0 at the start meant for LLVM GEP and the outer non-null variant\n         let path = discrfield.iter().skip(2).map(|&i| i as usize);\n \n@@ -849,16 +855,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         mut offset: Size,\n         mut ty: Ty<'tcx>,\n         path: I,\n-    ) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n+    ) -> EvalResult<'tcx, (Size, TyAndPacked<'tcx>)> {\n         // Skip the initial 0 intended for LLVM GEP.\n+        let mut packed = false;\n         for field_index in path {\n             let field_offset = self.get_field_offset(ty, field_index)?;\n             trace!(\"field_path_offset_and_ty: {}, {}, {:?}, {:?}\", field_index, ty, field_offset, offset);\n-            ty = self.get_field_ty(ty, field_index)?;\n+            let field_ty = self.get_field_ty(ty, field_index)?;\n+            ty = field_ty.ty;\n+            packed = packed || field_ty.packed;\n             offset = offset.checked_add(field_offset, &self.tcx.data_layout).unwrap();\n         }\n \n-        Ok((offset, ty))\n+        Ok((offset, TyAndPacked { ty, packed }))\n     }\n     fn get_fat_field(&self, pointee_ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n         match (field_index, &self.tcx.struct_tail(pointee_ty).sty) {\n@@ -870,33 +879,46 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n+    /// Returns the field type and whether the field is packed\n+    pub fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, TyAndPacked<'tcx>> {\n         match ty.sty {\n-            ty::TyAdt(adt_def, _) if adt_def.is_box() => self.get_fat_field(ty.boxed_ty(), field_index),\n+            ty::TyAdt(adt_def, _) if adt_def.is_box() =>\n+                Ok(TyAndPacked { ty: self.get_fat_field(ty.boxed_ty(), field_index)?, packed: false }),\n             ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n                 use rustc::ty::layout::Layout::*;\n                 match *self.type_layout(ty)? {\n-                    RawNullablePointer { nndiscr, .. } |\n-                    StructWrappedNullablePointer { nndiscr, .. } => Ok(adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs)),\n+                    RawNullablePointer { nndiscr, .. } =>\n+                        Ok(TyAndPacked { ty: adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs), packed: false }),\n+                    StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+                        let ty = adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs);\n+                        Ok(TyAndPacked { ty, packed: nonnull.packed })\n+                    },\n                     _ => Err(EvalError::Unimplemented(format!(\"get_field_ty can't handle enum type: {:?}, {:?}\", ty, ty.sty))),\n                 }\n             }\n             ty::TyAdt(adt_def, substs) => {\n-                Ok(adt_def.struct_variant().fields[field_index].ty(self.tcx, substs))\n+                let variant_def = adt_def.struct_variant();\n+                use rustc::ty::layout::Layout::*;\n+                match *self.type_layout(ty)? {\n+                    Univariant { ref variant, .. } =>\n+                        Ok(TyAndPacked { ty: variant_def.fields[field_index].ty(self.tcx, substs), packed: variant.packed }),\n+                    _ => Err(EvalError::Unimplemented(format!(\"get_field_ty can't handle struct type: {:?}, {:?}\", ty, ty.sty))),\n+                }\n             }\n \n-            ty::TyTuple(fields, _) => Ok(fields[field_index]),\n+            ty::TyTuple(fields, _) => Ok(TyAndPacked { ty: fields[field_index], packed: false }),\n \n             ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => self.get_fat_field(tam.ty, field_index),\n+            ty::TyRawPtr(ref tam) => Ok(TyAndPacked { ty: self.get_fat_field(tam.ty, field_index)?, packed: false }),\n \n-            ty::TyArray(ref inner, _) => Ok(inner),\n+            ty::TyArray(ref inner, _) => Ok(TyAndPacked { ty: inner, packed: false }),\n \n             _ => Err(EvalError::Unimplemented(format!(\"can't handle type: {:?}, {:?}\", ty, ty.sty))),\n         }\n     }\n \n     fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Size> {\n+        // Also see lvalue_field in lvalue.rs, which handles more cases but needs an actual value at the given type\n         let layout = self.type_layout(ty)?;\n \n         use rustc::ty::layout::Layout::*;\n@@ -1026,7 +1048,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return Err(EvalError::DeadLocal),\n-                    Some(Value::ByRef(ptr, aligned)) => {\n+                    Some(Value::ByRef { ptr, aligned }) => {\n                         Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None }\n                     },\n                     Some(val) => {\n@@ -1044,7 +1066,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Lvalue::Global(cid) => {\n                 let global_val = self.globals.get(&cid).expect(\"global not cached\").clone();\n                 match global_val.value {\n-                    Value::ByRef(ptr, aligned) =>\n+                    Value::ByRef { ptr, aligned } =>\n                         Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None },\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n@@ -1070,7 +1092,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// ensures this Value is not a ByRef\n     pub(super) fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef(ptr, aligned) => {\n+            Value::ByRef { ptr, aligned } => {\n                 self.read_maybe_aligned(aligned, |ectx| ectx.read_value(ptr, ty))\n             }\n             other => Ok(other),\n@@ -1079,7 +1101,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub(super) fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {\n-            Value::ByRef(..) => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n+            Value::ByRef{..} => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n             Value::ByVal(primval) => {\n                 self.ensure_valid_value(primval, ty)?;\n@@ -1145,7 +1167,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.write_maybe_aligned(aligned,\n+                self.write_maybe_aligned_mut(aligned,\n                     |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n             }\n \n@@ -1169,18 +1191,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        if let Value::ByRef(dest_ptr, aligned) = old_dest_val {\n+        if let Value::ByRef { ptr: dest_ptr, aligned } = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n             // other pointers into the allocation. These other pointers are logically\n             // pointers into the local variable, and must be able to observe the change.\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_maybe_aligned(aligned,\n+            self.write_maybe_aligned_mut(aligned,\n                 |ectx| ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty))?;\n \n-        } else if let Value::ByRef(src_ptr, aligned) = src_val {\n+        } else if let Value::ByRef { ptr: src_ptr, aligned } = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n             //\n@@ -1192,7 +1214,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // It is a valid optimization to attempt reading a primitive value out of the\n             // source and write that into the destination without making an allocation, so\n             // we do so here.\n-            self.read_maybe_aligned(aligned, |ectx| {\n+            self.read_maybe_aligned_mut(aligned, |ectx| {\n                 if let Ok(Some(src_val)) = ectx.try_read_value(src_ptr, dest_ty) {\n                     write_dest(ectx, src_val)?;\n                 } else {\n@@ -1218,8 +1240,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n-            Value::ByRef(ptr, aligned) => {\n-                self.read_maybe_aligned(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n+            Value::ByRef { ptr, aligned } => {\n+                self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n             },\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n@@ -1236,20 +1258,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ptr: MemoryPointer,\n         mut ty: Ty<'tcx>\n     ) -> EvalResult<'tcx> {\n+        let mut packed = false;\n         while self.get_field_count(ty)? == 1 {\n-            ty = self.get_field_ty(ty, 0)?;\n+            let field = self.get_field_ty(ty, 0)?;\n+            ty = field.ty;\n+            packed = packed || field.packed;\n         }\n         assert_eq!(self.get_field_count(ty)?, 2);\n-        let field_0 = self.get_field_offset(ty, 0)?.bytes();\n-        let field_1 = self.get_field_offset(ty, 1)?.bytes();\n+        let field_0 = self.get_field_offset(ty, 0)?;\n+        let field_1 = self.get_field_offset(ty, 1)?;\n         let field_0_ty = self.get_field_ty(ty, 0)?;\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n-        let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n-        let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        let field_0_ptr = ptr.offset(field_0, &self)?.into();\n-        let field_1_ptr = ptr.offset(field_1, &self)?.into();\n-        self.memory.write_primval(field_0_ptr, a, field_0_size)?;\n-        self.memory.write_primval(field_1_ptr, b, field_1_size)?;\n+        assert_eq!(field_0_ty.packed, field_1_ty.packed, \"the two fields must agree on being packed\");\n+        packed = packed || field_0_ty.packed;\n+        let field_0_size = self.type_size(field_0_ty.ty)?.expect(\"pair element type must be sized\");\n+        let field_1_size = self.type_size(field_1_ty.ty)?.expect(\"pair element type must be sized\");\n+        let field_0_ptr = ptr.offset(field_0.bytes(), &self)?.into();\n+        let field_1_ptr = ptr.offset(field_1.bytes(), &self)?.into();\n+        self.write_maybe_aligned_mut(!packed,\n+            |ectx| ectx.memory.write_primval(field_0_ptr, a, field_0_size))?;\n+        self.write_maybe_aligned_mut(!packed,\n+            |ectx| ectx.memory.write_primval(field_1_ptr, b, field_1_size))?;\n         Ok(())\n     }\n \n@@ -1352,7 +1381,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, ty)? {\n             Ok(val)\n         } else {\n@@ -1376,7 +1405,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn try_read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    fn try_read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n         let val = match ty.sty {\n@@ -1488,7 +1517,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                let ptr = src.into_ptr(&mut self.memory)?;\n+                let ptr = src.into_ptr(&self.memory)?;\n                 // u64 cast is from usize to u64, which is always good\n                 self.write_value(ptr.to_value_with_len(length as u64), dest, dest_ty)\n             }\n@@ -1502,7 +1531,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n-                let ptr = src.into_ptr(&mut self.memory)?;\n+                let ptr = src.into_ptr(&self.memory)?;\n                 self.write_value(ptr.to_value_with_vtable(vtable), dest, dest_ty)\n             },\n \n@@ -1529,8 +1558,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return self.unsize_into_ptr(src, src_ty, dest, dest_ty, src_ty.boxed_ty(), dest_ty.boxed_ty());\n                 }\n                 if self.ty_to_primval_kind(src_ty).is_ok() {\n-                    let sty = self.get_field_ty(src_ty, 0)?;\n-                    let dty = self.get_field_ty(dest_ty, 0)?;\n+                    // TODO: We ignore the packed flag here\n+                    let sty = self.get_field_ty(src_ty, 0)?.ty;\n+                    let dty = self.get_field_ty(dest_ty, 0)?.ty;\n                     return self.unsize_into(src, sty, dest, dty);\n                 }\n                 // unsizing of generic struct with pointer fields\n@@ -1545,7 +1575,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 //let src = adt::MaybeSizedValue::sized(src);\n                 //let dst = adt::MaybeSizedValue::sized(dst);\n                 let src_ptr = match src {\n-                    Value::ByRef(ptr, true) => ptr,\n+                    Value::ByRef { ptr, aligned: true } => ptr,\n                     // TODO: Is it possible for unaligned pointers to occur here?\n                     _ => bug!(\"expected aligned pointer, got {:?}\", src),\n                 };\n@@ -1592,7 +1622,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Err(err) => {\n                     panic!(\"Failed to access local: {:?}\", err);\n                 }\n-                Ok(Value::ByRef(ptr, aligned)) => match ptr.into_inner_primval() {\n+                Ok(Value::ByRef { ptr, aligned }) => match ptr.into_inner_primval() {\n                     PrimVal::Ptr(ptr) => {\n                         write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" }).unwrap();\n                         allocs.push(ptr.alloc_id);"}, {"sha": "a3927e2637a38948a5881fc316adeb962812bd8e", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match lvalue {\n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Ok(Value::ByRef(ptr, aligned))\n+                Ok(Value::ByRef { ptr, aligned })\n             }\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local)\n@@ -305,7 +305,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n                     return Ok(base);\n                 },\n-                Value::ByRef(..) |\n+                Value::ByRef{..} |\n                 Value::ByValPair(..) |\n                 Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n                     return Ok(base);\n                 },\n-                Value::ByRef(..) |\n+                Value::ByRef{..} |\n                 Value::ByValPair(..) |\n                 Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n@@ -349,17 +349,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n     }\n \n-    pub(super) fn val_to_lvalue(&mut self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn val_to_lvalue(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n-                let (ptr, vtable) = val.into_ptr_vtable_pair(&mut self.memory)?;\n+                let (ptr, vtable) = val.into_ptr_vtable_pair(&self.memory)?;\n                 Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: true }\n             },\n             ty::TyStr | ty::TySlice(_) => {\n-                let (ptr, len) = val.into_slice(&mut self.memory)?;\n+                let (ptr, len) = val.into_slice(&self.memory)?;\n                 Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: true }\n             },\n-            _ => Lvalue::Ptr { ptr: val.into_ptr(&mut self.memory)?, extra: LvalueExtra::None, aligned: true },\n+            _ => Lvalue::Ptr { ptr: val.into_ptr(&self.memory)?, extra: LvalueExtra::None, aligned: true },\n         })\n     }\n "}, {"sha": "2226744c6ab4b1c78251dfc3505562800b1351ca", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -1,6 +1,7 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, ptr, mem, io, ops};\n+use std::cell::Cell;\n \n use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n@@ -266,8 +267,8 @@ pub struct Memory<'a, 'tcx> {\n \n     /// To avoid having to pass flags to every single memory access, we have some global state saying whether\n     /// alignment checking is currently enforced for read and/or write accesses.\n-    reads_are_aligned: bool,\n-    writes_are_aligned: bool,\n+    reads_are_aligned: Cell<bool>,\n+    writes_are_aligned: Cell<bool>,\n \n     /// The current stack frame.  Used to check accesses against locks.\n     cur_frame: usize,\n@@ -287,8 +288,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             literal_alloc_cache: HashMap::new(),\n             thread_local: BTreeMap::new(),\n             next_thread_local: 0,\n-            reads_are_aligned: true,\n-            writes_are_aligned: true,\n+            reads_are_aligned: Cell::new(true),\n+            writes_are_aligned: Cell::new(true),\n             cur_frame: usize::max_value(),\n         }\n     }\n@@ -796,7 +797,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_unchecked(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        if self.reads_are_aligned {\n+        if self.reads_are_aligned.get() {\n             self.check_align(ptr.into(), align)?;\n         }\n         if size == 0 {\n@@ -813,7 +814,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     fn get_bytes_unchecked_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        if self.writes_are_aligned {\n+        if self.writes_are_aligned.get() {\n             self.check_align(ptr.into(), align)?;\n         }\n         if size == 0 {\n@@ -909,10 +910,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n         if size == 0 {\n             // Empty accesses don't need to be valid pointers, but they should still be aligned\n-            if self.reads_are_aligned {\n+            if self.reads_are_aligned.get() {\n                 self.check_align(src, align)?;\n             }\n-            if self.writes_are_aligned {\n+            if self.writes_are_aligned.get() {\n                 self.check_align(dest, align)?;\n             }\n             return Ok(());\n@@ -968,7 +969,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n             // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.reads_are_aligned {\n+            if self.reads_are_aligned.get() {\n                 self.check_align(ptr, 1)?;\n             }\n             return Ok(&[]);\n@@ -979,7 +980,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n         if src.is_empty() {\n             // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.writes_are_aligned {\n+            if self.writes_are_aligned.get() {\n                 self.check_align(ptr, 1)?;\n             }\n             return Ok(());\n@@ -992,7 +993,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n         if count == 0 {\n             // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.writes_are_aligned {\n+            if self.writes_are_aligned.get() {\n                 self.check_align(ptr, 1)?;\n             }\n             return Ok(());\n@@ -1399,23 +1400,36 @@ pub(crate) trait HasMemory<'a, 'tcx> {\n     fn memory(&self) -> &Memory<'a, 'tcx>;\n \n     // These are not supposed to be overriden.\n-    fn read_maybe_aligned<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+    fn read_maybe_aligned<F, T>(&self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+        where F: FnOnce(&Self) -> EvalResult<'tcx, T>\n+    {\n+        let old = self.memory().reads_are_aligned.get();\n+        // Do alignment checking if *all* nested calls say it has to be aligned.\n+        self.memory().reads_are_aligned.set(old && aligned);\n+        let t = f(self);\n+        self.memory().reads_are_aligned.set(old);\n+        t\n+    }\n+\n+    fn read_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n         where F: FnOnce(&mut Self) -> EvalResult<'tcx, T>\n     {\n-        assert!(self.memory_mut().reads_are_aligned, \"Unaligned reads must not be nested\");\n-        self.memory_mut().reads_are_aligned = aligned;\n+        let old = self.memory().reads_are_aligned.get();\n+        // Do alignment checking if *all* nested calls say it has to be aligned.\n+        self.memory().reads_are_aligned.set(old && aligned);\n         let t = f(self);\n-        self.memory_mut().reads_are_aligned = true;\n+        self.memory().reads_are_aligned.set(old);\n         t\n     }\n \n-    fn write_maybe_aligned<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+    fn write_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n         where F: FnOnce(&mut Self) -> EvalResult<'tcx, T>\n     {\n-        assert!(self.memory_mut().writes_are_aligned, \"Unaligned writes must not be nested\");\n-        self.memory_mut().writes_are_aligned = aligned;\n+        let old = self.memory().writes_are_aligned.get();\n+        // Do alignment checking if *all* nested calls say it has to be aligned.\n+        self.memory().writes_are_aligned.set(old && aligned);\n         let t = f(self);\n-        self.memory_mut().writes_are_aligned = true;\n+        self.memory().writes_are_aligned.set(old);\n         t\n     }\n }"}, {"sha": "1679688625dc6315d2cbb819152654265d7a06f1", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -11,12 +11,14 @@ use rustc::ty;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n \n+use syntax::codemap::Span;\n+use syntax::ast::Mutability;\n+\n use error::{EvalResult, EvalError};\n-use eval_context::{EvalContext, StackPopCleanup};\n+use eval_context::{EvalContext, StackPopCleanup, TyAndPacked};\n use lvalue::{Global, GlobalId, Lvalue};\n use value::{Value, PrimVal};\n-use syntax::codemap::Span;\n-use syntax::ast::Mutability;\n+use memory::HasMemory;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n@@ -101,12 +103,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                         if variant_index as u64 != nndiscr {\n-                            let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n+                            let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n                             let nonnull = self.force_allocation(dest)?.to_ptr()?.offset(offset.bytes(), &self)?;\n                             trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                             // only the pointer part of a fat pointer is used for this space optimization\n                             let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n-                            self.memory.write_uint(nonnull, 0, discr_size)?;\n+                            self.write_maybe_aligned_mut(!packed, |ectx| ectx.memory.write_uint(nonnull, 0, discr_size))?;\n                         }\n                     },\n "}, {"sha": "5c608bc163007ed57fc8cb8a6b0fe0fde5294448", "filename": "src/librustc_mir/interpret/terminator/intrinsic.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"arith_offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value(Value::by_ref(ptr), dest, ty)?;\n             }\n \n@@ -70,7 +70,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let dest = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n             }\n \n@@ -80,12 +80,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n@@ -94,13 +94,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n                 let change = self.value_to_primval(arg_vals[2], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n@@ -115,12 +115,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n             \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n@@ -148,8 +148,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n                     // Also see the write_bytes intrinsic.\n                     let elem_align = self.type_align(elem_ty)?;\n-                    let src = arg_vals[0].into_ptr(&mut self.memory)?;\n-                    let dest = arg_vals[1].into_ptr(&mut self.memory)?;\n+                    let src = arg_vals[0].into_ptr(&self.memory)?;\n+                    let dest = arg_vals[1].into_ptr(&self.memory)?;\n                     self.memory.copy(src, dest, count * elem_size, elem_align, intrinsic_name.ends_with(\"_nonoverlapping\"))?;\n                 }\n             }\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = arg_vals[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let adt_ptr = arg_vals[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n@@ -251,10 +251,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.type_size(dest_ty)?.expect(\"cannot zero unsized value\");\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n-                        Value::ByRef(ptr, aligned) => {\n+                        Value::ByRef { ptr, aligned } => {\n                             // These writes have no alignment restriction anyway.\n                             this.memory.write_repeat(ptr, 0, size)?;\n-                            Value::ByRef(ptr, aligned)\n+                            Value::ByRef { ptr, aligned }\n                         },\n                         // TODO(solson): Revisit this, it's fishy to check for Undef here.\n                         Value::ByVal(PrimVal::Undef) => match this.ty_to_primval_kind(dest_ty) {\n@@ -297,7 +297,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n             }\n \n@@ -310,7 +310,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.write_maybe_aligned(/*aligned*/false, |ectx| {\n+                self.write_maybe_aligned_mut(/*aligned*/false, |ectx| {\n                     ectx.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)\n                 })?;\n             }\n@@ -442,9 +442,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = dest_layout.size(&self.tcx.data_layout).bytes();\n                 let uninit = |this: &mut Self, val: Value| {\n                     match val {\n-                        Value::ByRef(ptr, aligned) => {\n+                        Value::ByRef { ptr, aligned } => {\n                             this.memory.mark_definedness(ptr, size, false)?;\n-                            Ok(Value::ByRef(ptr, aligned))\n+                            Ok(Value::ByRef { ptr, aligned })\n                         },\n                         _ => Ok(Value::ByVal(PrimVal::Undef)),\n                     }\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n@@ -550,15 +550,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Ok((size, align.abi()))\n                 }\n                 ty::TyDynamic(..) => {\n-                    let (_, vtable) = value.into_ptr_vtable_pair(&mut self.memory)?;\n+                    let (_, vtable) = value.into_ptr_vtable_pair(&self.memory)?;\n                     // the second entry in the vtable is the dynamic size of the object.\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n                     let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n-                    let (_, len) = value.into_slice(&mut self.memory)?;\n+                    let (_, len) = value.into_slice(&self.memory)?;\n                     let align = self.type_align(elem_ty)?;\n                     Ok((len * elem_size, align as u64))\n                 }"}, {"sha": "288409783db88fa2755c954cdcdcf0c882d51759", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -7,9 +7,9 @@ use syntax::attr;\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited, self};\n+use eval_context::{EvalContext, IntegerExt, StackPopCleanup, TyAndPacked, is_inhabited, self};\n use lvalue::Lvalue;\n-use memory::{MemoryPointer, TlsKey, Kind};\n+use memory::{MemoryPointer, TlsKey, Kind, HasMemory};\n use value::{PrimVal, Value};\n use rustc_data_structures::indexed_vec::Idx;\n use const_eval;\n@@ -313,10 +313,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             if self.frame().mir.args_iter().count() == fields.len() + 1 {\n                                 let offsets = variant.offsets.iter().map(|s| s.bytes());\n                                 match arg_val {\n-                                    Value::ByRef(ptr, aligned) => {\n+                                    Value::ByRef { ptr, aligned } => {\n                                         assert!(aligned, \"Unaligned ByRef-values cannot occur as function arguments\");\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef(ptr.offset(offset, &self)?, true);\n+                                            let arg = Value::ByRef { ptr: ptr.offset(offset, &self)?, aligned: true};\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;\n@@ -397,12 +397,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n-                let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(&mut self.memory)?;\n+                let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(&self.memory)?;\n                 let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), &self)?)?;\n                 let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n-                let ty = self.get_field_ty(ty, 0)?;\n+                let ty = self.get_field_ty(ty, 0)?.ty; // TODO: packed flag is ignored\n                 match arg_operands[0] {\n                     mir::Operand::Consume(ref mut lval) => *lval = lval.clone().field(mir::Field::new(0), ty),\n                     _ => bug!(\"virtual call first arg cannot be a constant\"),\n@@ -487,12 +487,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n-                let nonnull = adt_ptr.offset(offset.bytes(), self)?;\n+                let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n+                let nonnull = adt_ptr.offset(offset.bytes(), &*self)?;\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n-                self.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size)?\n+                self.read_maybe_aligned(!packed,\n+                    |ectx| ectx.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size))?\n             }\n \n             // The discriminant_value intrinsic returns 0 for non-sum types.\n@@ -576,7 +577,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if old_size == 0 {\n@@ -588,7 +589,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n@@ -664,7 +665,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"free\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 if !ptr.is_null()? {\n                     self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n                 }\n@@ -678,8 +679,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"dlsym\" => {\n-                let _handle = args[0].into_ptr(&mut self.memory)?;\n-                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let _handle = args[0].into_ptr(&self.memory)?;\n+                let symbol = args[1].into_ptr(&self.memory)?.to_ptr()?;\n                 let symbol_name = self.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n@@ -690,8 +691,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let data = args[1].into_ptr(&mut self.memory)?;\n+                let f = args[0].into_ptr(&self.memory)?.to_ptr()?;\n+                let data = args[1].into_ptr(&self.memory)?;\n                 let f_instance = self.memory.get_fn(f)?;\n                 self.write_null(dest, dest_ty)?;\n \n@@ -722,8 +723,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memcmp\" => {\n-                let left = args[0].into_ptr(&mut self.memory)?;\n-                let right = args[1].into_ptr(&mut self.memory)?;\n+                let left = args[0].into_ptr(&self.memory)?;\n+                let right = args[1].into_ptr(&self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n \n                 let result = {\n@@ -742,7 +743,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memrchr\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n@@ -754,7 +755,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memchr\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n@@ -767,7 +768,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"getenv\" => {\n                 let result = {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.env_vars.get(name) {\n                         Some(&var) => PrimVal::Ptr(var),\n@@ -780,7 +781,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"unsetenv\" => {\n                 let mut success = None;\n                 {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?;\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n@@ -801,8 +802,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"setenv\" => {\n                 let mut new = None;\n                 {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n-                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?;\n+                    let value_ptr = args[1].into_ptr(&self.memory)?.to_ptr()?;\n                     let value = self.memory.read_c_str(value_ptr)?;\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n@@ -828,7 +829,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"write\" => {\n                 let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let buf = args[1].into_ptr(&mut self.memory)?;\n+                let buf = args[1].into_ptr(&self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 { // stdout/stderr\n@@ -845,7 +846,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"strlen\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let n = self.memory.read_c_str(ptr)?.len();\n                 self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n             }\n@@ -888,10 +889,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n+                let key_ptr = args[0].into_ptr(&self.memory)?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n+                let dtor = match args[1].into_ptr(&self.memory)?.into_inner_primval() {\n                     PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n                     PrimVal::Bytes(0) => None,\n                     PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n@@ -933,7 +934,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n+                let new_ptr = args[1].into_ptr(&self.memory)?;\n                 self.memory.store_tls(key, new_ptr)?;\n                 \n                 // Return success (0)"}, {"sha": "8c3cc1852507888ae74adf43b24eb174de4b4ac8", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -151,7 +151,7 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n     fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, re: Option<CodeExtent>, mutbl: Mutability, mode: ValidationMode) -> EvalResult<'tcx> {\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n-        let ptr = val.into_ptr(&mut self.memory)?;\n+        let ptr = val.into_ptr(&self.memory)?;\n         self.memory.check_align(ptr, align)?;\n \n         // Recurse\n@@ -309,7 +309,7 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n                 self.validate_ptr(val, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n             }\n             TyFnPtr(_sig) => {\n-                let ptr = self.read_lvalue(query.lval)?.into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = self.read_lvalue(query.lval)?.into_ptr(&self.memory)?.to_ptr()?;\n                 self.memory.get_fn(ptr)?;\n                 // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n                 Ok(())"}, {"sha": "87b3d9f383c4e90b208441587fd3f16c2e7a2aa7", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -32,7 +32,7 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef(Pointer, bool),\n+    ByRef { ptr: Pointer, aligned: bool},\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n@@ -162,15 +162,15 @@ pub enum PrimValKind {\n impl<'a, 'tcx: 'a> Value {\n     #[inline]\n     pub(super) fn by_ref(ptr: Pointer) -> Self {\n-        Value::ByRef(ptr, true)\n+        Value::ByRef { ptr, aligned: true }\n     }\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n-    pub(super) fn into_ptr(&self, mem: &mut Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn into_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ptr, aligned) => {\n+            ByRef { ptr, aligned } => {\n                 mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?) )\n             },\n             ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n@@ -179,11 +179,11 @@ impl<'a, 'tcx: 'a> Value {\n \n     pub(super) fn into_ptr_vtable_pair(\n         &self,\n-        mem: &mut Memory<'a, 'tcx>\n+        mem: &Memory<'a, 'tcx>\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ref_ptr, aligned) => {\n+            ByRef { ptr: ref_ptr, aligned } => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n@@ -197,11 +197,11 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n \n-    pub(super) fn into_slice(&self, mem: &mut Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n+    pub(super) fn into_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ref_ptr, aligned) => {\n-                mem.write_maybe_aligned(aligned, |mem| {\n+            ByRef { ptr: ref_ptr, aligned } => {\n+                mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n                     Ok((ptr, len))"}, {"sha": "0c478119828209780e0e6d4df1f086ef6fef5a60", "filename": "tests/run-pass/packed_struct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c6befe69f202f70e008e1ef398b4c09c2b3d485/tests%2Frun-pass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6befe69f202f70e008e1ef398b4c09c2b3d485/tests%2Frun-pass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_struct.rs?ref=7c6befe69f202f70e008e1ef398b4c09c2b3d485", "patch": "@@ -40,7 +40,8 @@ fn test_unsizing() {\n \n     let arr = [1, 2, 3];\n     let arr_unaligned: UnalignedPtr<[i32; 3]> = UnalignedPtr { data: &arr };\n-    let _uns: UnalignedPtr<[i32]> = arr_unaligned;\n+    let arr_unaligned: UnalignedPtr<[i32]> = arr_unaligned;\n+    let _unused = &arr_unaligned; // forcing an allocation, which could also yield \"unaligned write\"-errors\n }\n \n fn main() {"}]}