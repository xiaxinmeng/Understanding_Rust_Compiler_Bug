{"sha": "f20c882b8b65f09701ef937b765e93e76682a298", "node_id": "C_kwDOAAsO6NoAKGYyMGM4ODJiOGI2NWYwOTcwMWVmOTM3Yjc2NWU5M2U3NjY4MmEyOTg", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-09-23T11:49:02Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-09-26T10:59:19Z"}, "message": "macros: support diagnostic derive on enums\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "df11cc9f6f39387ba6b925611f10123dc22c27be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df11cc9f6f39387ba6b925611f10123dc22c27be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f20c882b8b65f09701ef937b765e93e76682a298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f20c882b8b65f09701ef937b765e93e76682a298", "html_url": "https://github.com/rust-lang/rust/commit/f20c882b8b65f09701ef937b765e93e76682a298", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f20c882b8b65f09701ef937b765e93e76682a298/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f4923979979abb5d6b975353e9b3053d257e60", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f4923979979abb5d6b975353e9b3053d257e60", "html_url": "https://github.com/rust-lang/rust/commit/72f4923979979abb5d6b975353e9b3053d257e60"}], "stats": {"total": 679, "additions": 371, "deletions": 308}, "files": [{"sha": "b9a283552f75f75f526aab5777e17ae1069c0fc2", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 54, "deletions": 103, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/f20c882b8b65f09701ef937b765e93e76682a298/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20c882b8b65f09701ef937b765e93e76682a298/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=f20c882b8b65f09701ef937b765e93e76682a298", "patch": "@@ -2,10 +2,9 @@\n \n use crate::diagnostics::diagnostic_builder::{DiagnosticDeriveBuilder, DiagnosticDeriveKind};\n use crate::diagnostics::error::{span_err, DiagnosticDeriveError};\n-use crate::diagnostics::utils::{build_field_mapping, SetOnce};\n+use crate::diagnostics::utils::SetOnce;\n use proc_macro2::TokenStream;\n use quote::quote;\n-use syn::spanned::Spanned;\n use synstructure::Structure;\n \n /// The central struct for constructing the `into_diagnostic` method from an annotated struct.\n@@ -18,13 +17,7 @@ pub(crate) struct DiagnosticDerive<'a> {\n impl<'a> DiagnosticDerive<'a> {\n     pub(crate) fn new(diag: syn::Ident, handler: syn::Ident, structure: Structure<'a>) -> Self {\n         Self {\n-            builder: DiagnosticDeriveBuilder {\n-                diag,\n-                fields: build_field_mapping(&structure),\n-                kind: DiagnosticDeriveKind::Diagnostic,\n-                code: None,\n-                slug: None,\n-            },\n+            builder: DiagnosticDeriveBuilder { diag, kind: DiagnosticDeriveKind::Diagnostic },\n             handler,\n             structure,\n         }\n@@ -33,52 +26,35 @@ impl<'a> DiagnosticDerive<'a> {\n     pub(crate) fn into_tokens(self) -> TokenStream {\n         let DiagnosticDerive { mut structure, handler, mut builder } = self;\n \n-        let ast = structure.ast();\n-        let implementation = {\n-            if let syn::Data::Struct(..) = ast.data {\n-                let preamble = builder.preamble(&structure);\n-                let (attrs, args) = builder.body(&mut structure);\n-\n-                let span = ast.span().unwrap();\n-                let diag = &builder.diag;\n-                let init = match builder.slug.value() {\n-                    None => {\n-                        span_err(span, \"diagnostic slug not specified\")\n-                            .help(&format!(\n-                                \"specify the slug as the first argument to the `#[diag(...)]` attribute, \\\n-                                such as `#[diag(typeck::example_error)]`\",\n-                            ))\n-                            .emit();\n-                        return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n-                    }\n-                    Some(slug) => {\n-                        quote! {\n-                            let mut #diag = #handler.struct_diagnostic(rustc_errors::fluent::#slug);\n-                        }\n-                    }\n-                };\n-\n-                quote! {\n-                    #init\n-                    #preamble\n-                    match self {\n-                        #attrs\n-                    }\n-                    match self {\n-                        #args\n+        let implementation = builder.each_variant(&mut structure, |mut builder, variant| {\n+            let preamble = builder.preamble(&variant);\n+            let body = builder.body(&variant);\n+\n+            let diag = &builder.parent.diag;\n+            let init = match builder.slug.value_ref() {\n+                None => {\n+                    span_err(builder.span, \"diagnostic slug not specified\")\n+                        .help(&format!(\n+                            \"specify the slug as the first argument to the `#[diag(...)]` \\\n+                            attribute, such as `#[diag(typeck::example_error)]`\",\n+                        ))\n+                        .emit();\n+                    return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                }\n+                Some(slug) => {\n+                    quote! {\n+                        let mut #diag = #handler.struct_diagnostic(rustc_errors::fluent::#slug);\n                     }\n-                    #diag\n                 }\n-            } else {\n-                span_err(\n-                    ast.span().unwrap(),\n-                    \"`#[derive(Diagnostic)]` can only be used on structs\",\n-                )\n-                .emit();\n+            };\n \n-                DiagnosticDeriveError::ErrorHandled.to_compile_error()\n+            quote! {\n+                #init\n+                #preamble\n+                #body\n+                #diag\n             }\n-        };\n+        });\n \n         structure.gen_impl(quote! {\n             gen impl<'__diagnostic_handler_sess, G>\n@@ -107,68 +83,43 @@ pub(crate) struct LintDiagnosticDerive<'a> {\n impl<'a> LintDiagnosticDerive<'a> {\n     pub(crate) fn new(diag: syn::Ident, structure: Structure<'a>) -> Self {\n         Self {\n-            builder: DiagnosticDeriveBuilder {\n-                diag,\n-                fields: build_field_mapping(&structure),\n-                kind: DiagnosticDeriveKind::LintDiagnostic,\n-                code: None,\n-                slug: None,\n-            },\n+            builder: DiagnosticDeriveBuilder { diag, kind: DiagnosticDeriveKind::LintDiagnostic },\n             structure,\n         }\n     }\n \n     pub(crate) fn into_tokens(self) -> TokenStream {\n         let LintDiagnosticDerive { mut structure, mut builder } = self;\n \n-        let ast = structure.ast();\n-        let implementation = {\n-            if let syn::Data::Struct(..) = ast.data {\n-                let preamble = builder.preamble(&structure);\n-                let (attrs, args) = builder.body(&mut structure);\n-\n-                let diag = &builder.diag;\n-                let span = ast.span().unwrap();\n-                let init = match builder.slug.value() {\n-                    None => {\n-                        span_err(span, \"diagnostic slug not specified\")\n-                            .help(&format!(\n-                                \"specify the slug as the first argument to the attribute, such as \\\n-                                 `#[diag(typeck::example_error)]`\",\n-                            ))\n-                            .emit();\n-                        return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n-                    }\n-                    Some(slug) => {\n-                        quote! {\n-                            let mut #diag = #diag.build(rustc_errors::fluent::#slug);\n-                        }\n-                    }\n-                };\n-\n-                let implementation = quote! {\n-                    #init\n-                    #preamble\n-                    match self {\n-                        #attrs\n-                    }\n-                    match self {\n-                        #args\n+        let implementation = builder.each_variant(&mut structure, |mut builder, variant| {\n+            let preamble = builder.preamble(&variant);\n+            let body = builder.body(&variant);\n+\n+            let diag = &builder.parent.diag;\n+            let init = match builder.slug.value_ref() {\n+                None => {\n+                    span_err(builder.span, \"diagnostic slug not specified\")\n+                        .help(&format!(\n+                            \"specify the slug as the first argument to the attribute, such as \\\n+                             `#[diag(typeck::example_error)]`\",\n+                        ))\n+                        .emit();\n+                    return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                }\n+                Some(slug) => {\n+                    quote! {\n+                        let mut #diag = #diag.build(rustc_errors::fluent::#slug);\n                     }\n-                    #diag.emit();\n-                };\n-\n-                implementation\n-            } else {\n-                span_err(\n-                    ast.span().unwrap(),\n-                    \"`#[derive(LintDiagnostic)]` can only be used on structs\",\n-                )\n-                .emit();\n+                }\n+            };\n \n-                DiagnosticDeriveError::ErrorHandled.to_compile_error()\n+            quote! {\n+                #init\n+                #preamble\n+                #body\n+                #diag.emit();\n             }\n-        };\n+        });\n \n         let diag = &builder.diag;\n         structure.gen_impl(quote! {"}, {"sha": "38bd986f76fb971933d3a6199ef2666cf6cc277a", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 118, "deletions": 86, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/f20c882b8b65f09701ef937b765e93e76682a298/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20c882b8b65f09701ef937b765e93e76682a298/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=f20c882b8b65f09701ef937b765e93e76682a298", "patch": "@@ -1,22 +1,20 @@\n #![deny(unused_must_use)]\n \n-use super::error::throw_invalid_nested_attr;\n-use super::utils::{SpannedOption, SubdiagnosticKind};\n use crate::diagnostics::error::{\n-    invalid_nested_attr, span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n+    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n+    DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    report_error_if_not_applied_to_span, report_type_error, type_is_unit, type_matches_path,\n-    FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n+    bind_style_of_field, build_field_mapping, report_error_if_not_applied_to_span,\n+    report_type_error, should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo,\n+    FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n-use std::collections::HashMap;\n use syn::{\n-    parse_quote, spanned::Spanned, Attribute, Field, Meta, MetaList, MetaNameValue, NestedMeta,\n-    Path, Type,\n+    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n };\n-use synstructure::{BindingInfo, Structure};\n+use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -25,19 +23,30 @@ pub(crate) enum DiagnosticDeriveKind {\n     LintDiagnostic,\n }\n \n-/// Tracks persistent information required for building up individual calls to diagnostic methods\n-/// for generated diagnostic derives - both `Diagnostic` for fatal/errors/warnings and\n-/// `LintDiagnostic` for lints.\n+/// Tracks persistent information required for the entire type when building up individual calls to\n+/// diagnostic methods for generated diagnostic derives - both `Diagnostic` for\n+/// fatal/errors/warnings and `LintDiagnostic` for lints.\n pub(crate) struct DiagnosticDeriveBuilder {\n     /// The identifier to use for the generated `DiagnosticBuilder` instance.\n     pub diag: syn::Ident,\n+    /// Kind of diagnostic that should be derived.\n+    pub kind: DiagnosticDeriveKind,\n+}\n+\n+/// Tracks persistent information required for a specific variant when building up individual calls\n+/// to diagnostic methods for generated diagnostic derives - both `Diagnostic` for\n+/// fatal/errors/warnings and `LintDiagnostic` for lints.\n+pub(crate) struct DiagnosticDeriveVariantBuilder<'parent> {\n+    /// The parent builder for the entire type.\n+    pub parent: &'parent DiagnosticDeriveBuilder,\n+\n+    /// Span of the struct or the enum variant.\n+    pub span: proc_macro::Span,\n \n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n-    pub fields: HashMap<String, TokenStream>,\n+    pub field_map: FieldMap,\n \n-    /// Kind of diagnostic that should be derived.\n-    pub kind: DiagnosticDeriveKind,\n     /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n     /// has the actual diagnostic message.\n     pub slug: SpannedOption<Path>,\n@@ -46,15 +55,82 @@ pub(crate) struct DiagnosticDeriveBuilder {\n     pub code: SpannedOption<()>,\n }\n \n-impl HasFieldMap for DiagnosticDeriveBuilder {\n+impl<'a> HasFieldMap for DiagnosticDeriveVariantBuilder<'a> {\n     fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n-        self.fields.get(field)\n+        self.field_map.get(field)\n     }\n }\n \n impl DiagnosticDeriveBuilder {\n-    pub fn preamble<'s>(&mut self, structure: &Structure<'s>) -> TokenStream {\n+    /// Call `f` for the struct or for each variant of the enum, returning a `TokenStream` with the\n+    /// tokens from `f` wrapped in an `match` expression. Emits errors for use of derive on unions\n+    /// or attributes on the type itself when input is an enum.\n+    pub fn each_variant<'s, F>(&mut self, structure: &mut Structure<'s>, f: F) -> TokenStream\n+    where\n+        F: for<'a, 'v> Fn(DiagnosticDeriveVariantBuilder<'a>, &VariantInfo<'v>) -> TokenStream,\n+    {\n         let ast = structure.ast();\n+        let span = ast.span().unwrap();\n+        match ast.data {\n+            syn::Data::Struct(..) | syn::Data::Enum(..) => (),\n+            syn::Data::Union(..) => {\n+                span_err(span, \"diagnostic derives can only be used on structs and enums\");\n+            }\n+        }\n+\n+        if matches!(ast.data, syn::Data::Enum(..)) {\n+            for attr in &ast.attrs {\n+                span_err(\n+                    attr.span().unwrap(),\n+                    \"unsupported type attribute for diagnostic derive enum\",\n+                )\n+                .emit();\n+            }\n+        }\n+\n+        for variant in structure.variants_mut() {\n+            // First, change the binding style of each field based on the code that will be\n+            // generated for the field - e.g. `set_arg` calls needs by-move bindings, whereas\n+            // `set_primary_span` only needs by-ref.\n+            variant.bind_with(|bi| bind_style_of_field(bi.ast()).0);\n+\n+            // Then, perform a stable sort on bindings which generates code for by-ref bindings\n+            // before code generated for by-move bindings. Any code generated for the by-ref\n+            // bindings which creates a reference to the by-move fields will happen before the\n+            // by-move bindings move those fields and make them inaccessible.\n+            variant.bindings_mut().sort_by_cached_key(|bi| bind_style_of_field(bi.ast()));\n+        }\n+\n+        let variants = structure.each_variant(|variant| {\n+            let span = match structure.ast().data {\n+                syn::Data::Struct(..) => span,\n+                // There isn't a good way to get the span of the variant, so the variant's\n+                // name will need to do.\n+                _ => variant.ast().ident.span().unwrap(),\n+            };\n+            let builder = DiagnosticDeriveVariantBuilder {\n+                parent: &self,\n+                span,\n+                field_map: build_field_mapping(variant),\n+                slug: None,\n+                code: None,\n+            };\n+            f(builder, variant)\n+        });\n+\n+        quote! {\n+            match self {\n+                #variants\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n+    /// Generates calls to `code` and similar functions based on the attributes on the type or\n+    /// variant.\n+    pub fn preamble<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n+        let ast = variant.ast();\n         let attrs = &ast.attrs;\n         let preamble = attrs.iter().map(|attr| {\n             self.generate_structure_code_for_attr(attr).unwrap_or_else(|v| v.to_compile_error())\n@@ -65,68 +141,24 @@ impl DiagnosticDeriveBuilder {\n         }\n     }\n \n-    pub fn body<'s>(&mut self, structure: &mut Structure<'s>) -> (TokenStream, TokenStream) {\n-        // Keep track of which fields need to be handled with a by-move binding.\n-        let mut needs_moved = std::collections::HashSet::new();\n-\n-        // Generates calls to `span_label` and similar functions based on the attributes\n-        // on fields. Code for suggestions uses formatting machinery and the value of\n-        // other fields - because any given field can be referenced multiple times, it\n-        // should be accessed through a borrow. When passing fields to `add_subdiagnostic`\n-        // or `set_arg` (which happens below) for Fluent, we want to move the data, so that\n-        // has to happen in a separate pass over the fields.\n-        let attrs = structure\n-            .clone()\n-            .filter(|field_binding| {\n-                let ast = &field_binding.ast();\n-                !self.needs_move(ast) || {\n-                    needs_moved.insert(field_binding.binding.clone());\n-                    false\n-                }\n-            })\n-            .each(|field_binding| self.generate_field_attrs_code(field_binding));\n-\n-        structure.bind_with(|_| synstructure::BindStyle::Move);\n-        // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n-        // need to be passed as an argument to the diagnostic. But when a field has no\n-        // attributes or a `#[subdiagnostic]` attribute then it must be passed as an\n-        // argument to the diagnostic so that it can be referred to by Fluent messages.\n-        let args = structure\n-            .filter(|field_binding| needs_moved.contains(&field_binding.binding))\n-            .each(|field_binding| self.generate_field_attrs_code(field_binding));\n-\n-        (attrs, args)\n-    }\n-\n-    /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n-    /// call (like `span_label`).\n-    fn should_generate_set_arg(&self, field: &Field) -> bool {\n-        field.attrs.is_empty()\n-    }\n-\n-    /// Returns `true` if `field` needs to have code generated in the by-move branch of the\n-    /// generated derive rather than the by-ref branch.\n-    fn needs_move(&self, field: &Field) -> bool {\n-        let generates_set_arg = self.should_generate_set_arg(field);\n-        let is_multispan = type_matches_path(&field.ty, &[\"rustc_errors\", \"MultiSpan\"]);\n-        // FIXME(davidtwco): better support for one field needing to be in the by-move and\n-        // by-ref branches.\n-        let is_subdiagnostic = field\n-            .attrs\n-            .iter()\n-            .map(|attr| attr.path.segments.last().unwrap().ident.to_string())\n-            .any(|attr| attr == \"subdiagnostic\");\n-\n-        // `set_arg` calls take their argument by-move..\n-        generates_set_arg\n-            // If this is a `MultiSpan` field then it needs to be moved to be used by any\n-            // attribute..\n-            || is_multispan\n-            // If this a `#[subdiagnostic]` then it needs to be moved as the other diagnostic is\n-            // unlikely to be `Copy`..\n-            || is_subdiagnostic\n+    /// Generates calls to `span_label` and similar functions based on the attributes on fields or\n+    /// calls to `set_arg` when no attributes are present.\n+    ///\n+    /// Expects use of `Self::each_variant` which will have sorted bindings so that by-ref bindings\n+    /// (which may create references to by-move bindings) have their code generated first -\n+    /// necessary as code for suggestions uses formatting machinery and the value of other fields\n+    /// (any given field can be referenced multiple times, so must be accessed through a borrow);\n+    /// and when passing fields to `add_subdiagnostic` or `set_arg` for Fluent, fields must be\n+    /// accessed by-move.\n+    pub fn body<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n+        let mut body = quote! {};\n+        for binding in variant.bindings() {\n+            body.extend(self.generate_field_attrs_code(binding));\n+        }\n+        body\n     }\n \n+    /// Parse a `SubdiagnosticKind` from an `Attribute`.\n     fn parse_subdiag_attribute(\n         &self,\n         attr: &Attribute,\n@@ -158,7 +190,7 @@ impl DiagnosticDeriveBuilder {\n         &mut self,\n         attr: &Attribute,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let diag = &self.diag;\n+        let diag = &self.parent.diag;\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n@@ -246,8 +278,8 @@ impl DiagnosticDeriveBuilder {\n         let field = binding_info.ast();\n         let field_binding = &binding_info.binding;\n \n-        if self.should_generate_set_arg(&field) {\n-            let diag = &self.diag;\n+        if should_generate_set_arg(&field) {\n+            let diag = &self.parent.diag;\n             let ident = field.ident.as_ref().unwrap();\n             return quote! {\n                 #diag.set_arg(\n@@ -257,7 +289,7 @@ impl DiagnosticDeriveBuilder {\n             };\n         }\n \n-        let needs_move = self.needs_move(&field);\n+        let needs_move = bind_style_of_field(&field).is_move();\n         let inner_ty = FieldInnerTy::from_type(&field.ty);\n \n         field\n@@ -303,7 +335,7 @@ impl DiagnosticDeriveBuilder {\n         info: FieldInfo<'_>,\n         binding: TokenStream,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let diag = &self.diag;\n+        let diag = &self.parent.diag;\n         let meta = attr.parse_meta()?;\n \n         if let Meta::Path(_) = meta {\n@@ -316,7 +348,7 @@ impl DiagnosticDeriveBuilder {\n                     // `set_arg` call will not be generated.\n                     return Ok(quote! {});\n                 }\n-                \"primary_span\" => match self.kind {\n+                \"primary_span\" => match self.parent.kind {\n                     DiagnosticDeriveKind::Diagnostic => {\n                         report_error_if_not_applied_to_span(attr, &info)?;\n \n@@ -390,7 +422,7 @@ impl DiagnosticDeriveBuilder {\n         kind: &Ident,\n         fluent_attr_identifier: Path,\n     ) -> TokenStream {\n-        let diag = &self.diag;\n+        let diag = &self.parent.diag;\n         let fn_name = format_ident!(\"span_{}\", kind);\n         quote! {\n             #diag.#fn_name(\n@@ -403,7 +435,7 @@ impl DiagnosticDeriveBuilder {\n     /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug\n     /// and `fluent_attr_identifier`.\n     fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: Path) -> TokenStream {\n-        let diag = &self.diag;\n+        let diag = &self.parent.diag;\n         quote! {\n             #diag.#kind(rustc_errors::fluent::#fluent_attr_identifier);\n         }"}, {"sha": "adb4902ebc1724794491d9bb736d7aad761005df", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f20c882b8b65f09701ef937b765e93e76682a298/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20c882b8b65f09701ef937b765e93e76682a298/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=f20c882b8b65f09701ef937b765e93e76682a298", "patch": "@@ -1,21 +1,19 @@\n #![deny(unused_must_use)]\n \n use crate::diagnostics::error::{\n-    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n+    invalid_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n+    DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span, FieldInfo,\n-    FieldInnerTy, HasFieldMap, SetOnce,\n+    build_field_mapping, report_error_if_not_applied_to_applicability,\n+    report_error_if_not_applied_to_span, FieldInfo, FieldInnerTy, FieldMap, HasFieldMap, SetOnce,\n+    SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n-use std::collections::HashMap;\n use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n-use super::error::invalid_attr;\n-use super::utils::{SpannedOption, SubdiagnosticKind};\n-\n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDerive<'a> {\n     structure: Structure<'a>,\n@@ -55,21 +53,11 @@ impl<'a> SubdiagnosticDerive<'a> {\n \n             structure.bind_with(|_| synstructure::BindStyle::Move);\n             let variants_ = structure.each_variant(|variant| {\n-                // Build the mapping of field names to fields. This allows attributes to peek\n-                // values from other fields.\n-                let mut fields_map = HashMap::new();\n-                for binding in variant.bindings() {\n-                    let field = binding.ast();\n-                    if let Some(ident) = &field.ident {\n-                        fields_map.insert(ident.to_string(), quote! { #binding });\n-                    }\n-                }\n-\n                 let mut builder = SubdiagnosticDeriveBuilder {\n                     diag: &diag,\n                     variant,\n                     span,\n-                    fields: fields_map,\n+                    fields: build_field_mapping(variant),\n                     span_field: None,\n                     applicability: None,\n                     has_suggestion_parts: false,\n@@ -111,7 +99,7 @@ struct SubdiagnosticDeriveBuilder<'a> {\n \n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n-    fields: HashMap<String, TokenStream>,\n+    fields: FieldMap,\n \n     /// Identifier for the binding to the `#[primary_span]` field.\n     span_field: SpannedOption<proc_macro2::Ident>,"}, {"sha": "162699c286872d0fc42ee33daaf7f49eb7aed51b", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 73, "deletions": 12, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f20c882b8b65f09701ef937b765e93e76682a298/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20c882b8b65f09701ef937b765e93e76682a298/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=f20c882b8b65f09701ef937b765e93e76682a298", "patch": "@@ -4,12 +4,13 @@ use crate::diagnostics::error::{\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n+use std::cmp::Ordering;\n use std::collections::{BTreeSet, HashMap};\n use std::fmt;\n use std::str::FromStr;\n-use syn::{spanned::Spanned, Attribute, Meta, Type, TypeTuple};\n+use syn::{spanned::Spanned, Attribute, Field, Meta, Type, TypeTuple};\n use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n-use synstructure::{BindingInfo, Structure};\n+use synstructure::{BindStyle, BindingInfo, VariantInfo};\n \n use super::error::invalid_nested_attr;\n \n@@ -210,6 +211,8 @@ impl<T> SetOnce<T> for SpannedOption<T> {\n     }\n }\n \n+pub(super) type FieldMap = HashMap<String, TokenStream>;\n+\n pub(crate) trait HasFieldMap {\n     /// Returns the binding for the field with the given name, if it exists on the type.\n     fn get_field_binding(&self, field: &String) -> Option<&TokenStream>;\n@@ -360,18 +363,13 @@ impl quote::ToTokens for Applicability {\n \n /// Build the mapping of field names to fields. This allows attributes to peek values from\n /// other fields.\n-pub(crate) fn build_field_mapping<'a>(structure: &Structure<'a>) -> HashMap<String, TokenStream> {\n-    let mut fields_map = HashMap::new();\n-\n-    let ast = structure.ast();\n-    if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n-        for field in fields.iter() {\n-            if let Some(ident) = &field.ident {\n-                fields_map.insert(ident.to_string(), quote! { &self.#ident });\n-            }\n+pub(super) fn build_field_mapping<'v>(variant: &VariantInfo<'v>) -> HashMap<String, TokenStream> {\n+    let mut fields_map = FieldMap::new();\n+    for binding in variant.bindings() {\n+        if let Some(ident) = &binding.ast().ident {\n+            fields_map.insert(ident.to_string(), quote! { #binding });\n         }\n     }\n-\n     fields_map\n }\n \n@@ -621,3 +619,66 @@ impl quote::IdentFragment for SubdiagnosticKind {\n         None\n     }\n }\n+\n+/// Wrapper around `synstructure::BindStyle` which implements `Ord`.\n+#[derive(PartialEq, Eq)]\n+pub(super) struct OrderedBindStyle(pub(super) BindStyle);\n+\n+impl OrderedBindStyle {\n+    /// Is `BindStyle::Move` or `BindStyle::MoveMut`?\n+    pub(super) fn is_move(&self) -> bool {\n+        matches!(self.0, BindStyle::Move | BindStyle::MoveMut)\n+    }\n+}\n+\n+impl Ord for OrderedBindStyle {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        match (self.is_move(), other.is_move()) {\n+            // If both `self` and `other` are the same, then ordering is equal.\n+            (true, true) | (false, false) => Ordering::Equal,\n+            // If `self` is not a move then it should be considered less than `other` (so that\n+            // references are sorted first).\n+            (false, _) => Ordering::Less,\n+            // If `self` is a move then it must be greater than `other` (again, so that references\n+            // are sorted first).\n+            (true, _) => Ordering::Greater,\n+        }\n+    }\n+}\n+\n+impl PartialOrd for OrderedBindStyle {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+/// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n+/// call (like `span_label`).\n+pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n+    field.attrs.is_empty()\n+}\n+\n+/// Returns `true` if `field` needs to have code generated in the by-move branch of the\n+/// generated derive rather than the by-ref branch.\n+pub(super) fn bind_style_of_field(field: &Field) -> OrderedBindStyle {\n+    let generates_set_arg = should_generate_set_arg(field);\n+    let is_multispan = type_matches_path(&field.ty, &[\"rustc_errors\", \"MultiSpan\"]);\n+    // FIXME(davidtwco): better support for one field needing to be in the by-move and\n+    // by-ref branches.\n+    let is_subdiagnostic = field\n+        .attrs\n+        .iter()\n+        .map(|attr| attr.path.segments.last().unwrap().ident.to_string())\n+        .any(|attr| attr == \"subdiagnostic\");\n+\n+    // `set_arg` calls take their argument by-move..\n+    let needs_move = generates_set_arg\n+        // If this is a `MultiSpan` field then it needs to be moved to be used by any\n+        // attribute..\n+        || is_multispan\n+        // If this a `#[subdiagnostic]` then it needs to be moved as the other diagnostic is\n+        // unlikely to be `Copy`..\n+        || is_subdiagnostic;\n+\n+    OrderedBindStyle(if needs_move { BindStyle::Move } else { BindStyle::Ref })\n+}"}, {"sha": "cf04e05095f0ae4396f9da1915fe416663280ce2", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f20c882b8b65f09701ef937b765e93e76682a298/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20c882b8b65f09701ef937b765e93e76682a298/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=f20c882b8b65f09701ef937b765e93e76682a298", "patch": "@@ -37,10 +37,12 @@ struct HelloWarn {}\n \n #[derive(Diagnostic)]\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-//~^ ERROR `#[derive(Diagnostic)]` can only be used on structs\n+//~^ ERROR unsupported type attribute for diagnostic derive enum\n enum DiagnosticOnEnum {\n     Foo,\n+//~^ ERROR diagnostic slug not specified\n     Bar,\n+//~^ ERROR diagnostic slug not specified\n }\n \n #[derive(Diagnostic)]\n@@ -651,3 +653,21 @@ struct LabelOnStruct {\n     #[primary_span]\n     suggestion: Span,\n }\n+\n+#[derive(Diagnostic)]\n+enum ExampleEnum {\n+    #[diag(typeck::ambiguous_lifetime_bound)]\n+    Foo {\n+        #[primary_span]\n+        sp: Span,\n+        #[note]\n+        note_sp: Span,\n+    },\n+    #[diag(typeck::ambiguous_lifetime_bound)]\n+    Bar {\n+        #[primary_span]\n+        sp: Span,\n+    },\n+    #[diag(typeck::ambiguous_lifetime_bound)]\n+    Baz,\n+}"}, {"sha": "68602640a24f2c70303ffdc421e41b3bd6ae5bed", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 98, "deletions": 87, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/f20c882b8b65f09701ef937b765e93e76682a298/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f20c882b8b65f09701ef937b765e93e76682a298/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=f20c882b8b65f09701ef937b765e93e76682a298", "patch": "@@ -1,28 +1,39 @@\n-error: `#[derive(Diagnostic)]` can only be used on structs\n+error: unsupported type attribute for diagnostic derive enum\n   --> $DIR/diagnostic-derive.rs:39:1\n    |\n-LL | / #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-LL | |\n-LL | | enum DiagnosticOnEnum {\n-LL | |     Foo,\n-LL | |     Bar,\n-LL | | }\n-   | |_^\n+LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:42:5\n+   |\n+LL |     Foo,\n+   |     ^^^\n+   |\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:44:5\n+   |\n+LL |     Bar,\n+   |     ^^^\n+   |\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:48:1\n+  --> $DIR/diagnostic-derive.rs:50:1\n    |\n LL | #[diag = \"E0123\"]\n    | ^^^^^^^^^^^^^^^^^\n \n error: `#[nonsense(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:53:1\n+  --> $DIR/diagnostic-derive.rs:55:1\n    |\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:53:1\n+  --> $DIR/diagnostic-derive.rs:55:1\n    |\n LL | / #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -34,15 +45,15 @@ LL | | struct InvalidStructAttr {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(\"...\")]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:60:8\n+  --> $DIR/diagnostic-derive.rs:62:8\n    |\n LL | #[diag(\"E0123\")]\n    |        ^^^^^^^\n    |\n    = help: a diagnostic slug is required as the first argument\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:60:1\n+  --> $DIR/diagnostic-derive.rs:62:1\n    |\n LL | / #[diag(\"E0123\")]\n LL | |\n@@ -53,15 +64,15 @@ LL | | struct InvalidLitNestedAttr {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(nonsense(...))]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:71:8\n+  --> $DIR/diagnostic-derive.rs:73:8\n    |\n LL | #[diag(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^^^^\n    |\n    = help: a diagnostic slug is required as the first argument\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:71:1\n+  --> $DIR/diagnostic-derive.rs:73:1\n    |\n LL | / #[diag(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -72,23 +83,23 @@ LL | | struct InvalidNestedStructAttr1 {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:77:8\n+  --> $DIR/diagnostic-derive.rs:79:8\n    |\n LL | #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:77:42\n+  --> $DIR/diagnostic-derive.rs:79:42\n    |\n LL | #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n    |                                          ^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:77:1\n+  --> $DIR/diagnostic-derive.rs:79:1\n    |\n LL | / #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -100,21 +111,21 @@ LL | | struct InvalidNestedStructAttr2 {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:84:8\n+  --> $DIR/diagnostic-derive.rs:86:8\n    |\n LL | #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^\n \n error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:84:38\n+  --> $DIR/diagnostic-derive.rs:86:38\n    |\n LL | #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n    |                                      ^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:84:1\n+  --> $DIR/diagnostic-derive.rs:86:1\n    |\n LL | / #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -126,73 +137,73 @@ LL | | struct InvalidNestedStructAttr3 {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:91:58\n+  --> $DIR/diagnostic-derive.rs:93:58\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n    |                                                          ^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n error: `#[suggestion = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:98:5\n+  --> $DIR/diagnostic-derive.rs:100:5\n    |\n LL |     #[suggestion = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:105:8\n+  --> $DIR/diagnostic-derive.rs:107:8\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:104:8\n+  --> $DIR/diagnostic-derive.rs:106:8\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:105:49\n+  --> $DIR/diagnostic-derive.rs:107:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |                                                 ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:104:49\n+  --> $DIR/diagnostic-derive.rs:106:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |                                                 ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:111:65\n+  --> $DIR/diagnostic-derive.rs:113:65\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n    |                                                                 ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:111:49\n+  --> $DIR/diagnostic-derive.rs:113:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n    |                                                 ^^^^^^^\n \n error: `#[diag(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:116:42\n+  --> $DIR/diagnostic-derive.rs:118:42\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: diagnostic slug must be the first argument\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:121:1\n+  --> $DIR/diagnostic-derive.rs:123:1\n    |\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:124:1\n+  --> $DIR/diagnostic-derive.rs:126:1\n    |\n LL | / #[diag(code = \"E0456\")]\n LL | |\n@@ -202,31 +213,31 @@ LL | | struct SlugNotProvided {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:135:5\n+  --> $DIR/diagnostic-derive.rs:137:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: `#[nonsense]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:143:5\n+  --> $DIR/diagnostic-derive.rs:145:5\n    |\n LL |     #[nonsense]\n    |     ^^^^^^^^^^^\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:160:5\n+  --> $DIR/diagnostic-derive.rs:162:5\n    |\n LL |     #[label(typeck::label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:168:45\n+  --> $DIR/diagnostic-derive.rs:170:45\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"{name}\")]\n    |                                             ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/diagnostic-derive.rs:173:16\n+  --> $DIR/diagnostic-derive.rs:175:16\n    |\n LL | #[derive(Diagnostic)]\n    |           -    ^ expected `'}'` in format string\n@@ -237,7 +248,7 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/diagnostic-derive.rs:183:15\n+  --> $DIR/diagnostic-derive.rs:185:15\n    |\n LL | #[derive(Diagnostic)]\n    |               ^ unmatched `}` in format string\n@@ -246,47 +257,47 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:203:5\n+  --> $DIR/diagnostic-derive.rs:205:5\n    |\n LL |     #[label(typeck::label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/diagnostic-derive.rs:221:5\n+  --> $DIR/diagnostic-derive.rs:223:5\n    |\n LL |     #[suggestion(typeck::suggestion)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:229:18\n+  --> $DIR/diagnostic-derive.rs:231:18\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^^^^^^^^^\n    |\n    = help: only `code` and `applicability` are valid nested attributes\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/diagnostic-derive.rs:229:5\n+  --> $DIR/diagnostic-derive.rs:231:5\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(msg = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:238:18\n+  --> $DIR/diagnostic-derive.rs:240:18\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^^^^^^^^^\n    |\n    = help: only `code` and `applicability` are valid nested attributes\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/diagnostic-derive.rs:238:5\n+  --> $DIR/diagnostic-derive.rs:240:5\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wrong field type for suggestion\n-  --> $DIR/diagnostic-derive.rs:261:5\n+  --> $DIR/diagnostic-derive.rs:263:5\n    |\n LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n@@ -296,89 +307,89 @@ LL | |     suggestion: Applicability,\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:277:24\n+  --> $DIR/diagnostic-derive.rs:279:24\n    |\n LL |     suggestion: (Span, Span, Applicability),\n    |                        ^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:277:18\n+  --> $DIR/diagnostic-derive.rs:279:18\n    |\n LL |     suggestion: (Span, Span, Applicability),\n    |                  ^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:285:33\n+  --> $DIR/diagnostic-derive.rs:287:33\n    |\n LL |     suggestion: (Applicability, Applicability, Span),\n    |                                 ^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:285:18\n+  --> $DIR/diagnostic-derive.rs:287:18\n    |\n LL |     suggestion: (Applicability, Applicability, Span),\n    |                  ^^^^^^^^^^^^^\n \n error: `#[label = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:292:5\n+  --> $DIR/diagnostic-derive.rs:294:5\n    |\n LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:443:52\n+  --> $DIR/diagnostic-derive.rs:445:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:445:24\n+  --> $DIR/diagnostic-derive.rs:447:24\n    |\n LL |     suggestion: (Span, Applicability),\n    |                        ^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:451:52\n+  --> $DIR/diagnostic-derive.rs:453:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(foo)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:514:28\n+  --> $DIR/diagnostic-derive.rs:516:28\n    |\n LL |     #[label(typeck::label, foo)]\n    |                            ^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n error: `#[label(foo = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:522:28\n+  --> $DIR/diagnostic-derive.rs:524:28\n    |\n LL |     #[label(typeck::label, foo = \"...\")]\n    |                            ^^^^^^^^^^^\n \n error: `#[label(foo(...))]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:530:28\n+  --> $DIR/diagnostic-derive.rs:532:28\n    |\n LL |     #[label(typeck::label, foo(\"...\"))]\n    |                            ^^^^^^^^^^\n \n error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:543:5\n+  --> $DIR/diagnostic-derive.rs:545:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: the `primary_span` field attribute is not valid for lint diagnostics\n \n error: `#[error(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:563:1\n+  --> $DIR/diagnostic-derive.rs:565:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:563:1\n+  --> $DIR/diagnostic-derive.rs:565:1\n    |\n LL | / #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -390,13 +401,13 @@ LL | | struct ErrorAttribute {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[warn_(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:570:1\n+  --> $DIR/diagnostic-derive.rs:572:1\n    |\n LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:570:1\n+  --> $DIR/diagnostic-derive.rs:572:1\n    |\n LL | / #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -408,13 +419,13 @@ LL | | struct WarnAttribute {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:577:1\n+  --> $DIR/diagnostic-derive.rs:579:1\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:577:1\n+  --> $DIR/diagnostic-derive.rs:579:1\n    |\n LL | / #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -426,13 +437,13 @@ LL | | struct LintAttributeOnSessionDiag {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:584:1\n+  --> $DIR/diagnostic-derive.rs:586:1\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:584:1\n+  --> $DIR/diagnostic-derive.rs:586:1\n    |\n LL | / #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -444,141 +455,141 @@ LL | | struct LintAttributeOnLintDiag {}\n    = help: specify the slug as the first argument to the attribute, such as `#[diag(typeck::example_error)]`\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:593:52\n+  --> $DIR/diagnostic-derive.rs:595:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n    |                                                    ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:593:38\n+  --> $DIR/diagnostic-derive.rs:595:38\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n    |                                      ^^^^^^^^^^^^\n \n error: wrong types for suggestion\n-  --> $DIR/diagnostic-derive.rs:602:24\n+  --> $DIR/diagnostic-derive.rs:604:24\n    |\n LL |     suggestion: (Span, usize),\n    |                        ^^^^^\n    |\n    = help: `#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\n \n error: wrong types for suggestion\n-  --> $DIR/diagnostic-derive.rs:610:17\n+  --> $DIR/diagnostic-derive.rs:612:17\n    |\n LL |     suggestion: (Span,),\n    |                 ^^^^^^^\n    |\n    = help: `#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/diagnostic-derive.rs:617:5\n+  --> $DIR/diagnostic-derive.rs:619:5\n    |\n LL |     #[suggestion(typeck::suggestion)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[multipart_suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:624:1\n+  --> $DIR/diagnostic-derive.rs:626:1\n    |\n LL | #[multipart_suggestion(typeck::suggestion)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n error: `#[multipart_suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:627:1\n+  --> $DIR/diagnostic-derive.rs:629:1\n    |\n LL | #[multipart_suggestion()]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n error: `#[multipart_suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:631:5\n+  --> $DIR/diagnostic-derive.rs:633:5\n    |\n LL |     #[multipart_suggestion(typeck::suggestion)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n error: `#[suggestion(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:639:1\n+  --> $DIR/diagnostic-derive.rs:641:1\n    |\n LL | #[suggestion(typeck::suggestion, code = \"...\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[label]` and `#[suggestion]` can only be applied to fields\n \n error: `#[label]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:648:1\n+  --> $DIR/diagnostic-derive.rs:650:1\n    |\n LL | #[label]\n    | ^^^^^^^^\n    |\n    = help: `#[label]` and `#[suggestion]` can only be applied to fields\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:53:3\n+  --> $DIR/diagnostic-derive.rs:55:3\n    |\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:143:7\n+  --> $DIR/diagnostic-derive.rs:145:7\n    |\n LL |     #[nonsense]\n    |       ^^^^^^^^\n \n error: cannot find attribute `error` in this scope\n-  --> $DIR/diagnostic-derive.rs:563:3\n+  --> $DIR/diagnostic-derive.rs:565:3\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^\n \n error: cannot find attribute `warn_` in this scope\n-  --> $DIR/diagnostic-derive.rs:570:3\n+  --> $DIR/diagnostic-derive.rs:572:3\n    |\n LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^ help: a built-in attribute with a similar name exists: `warn`\n \n error: cannot find attribute `lint` in this scope\n-  --> $DIR/diagnostic-derive.rs:577:3\n+  --> $DIR/diagnostic-derive.rs:579:3\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `lint` in this scope\n-  --> $DIR/diagnostic-derive.rs:584:3\n+  --> $DIR/diagnostic-derive.rs:586:3\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `multipart_suggestion` in this scope\n-  --> $DIR/diagnostic-derive.rs:624:3\n+  --> $DIR/diagnostic-derive.rs:626:3\n    |\n LL | #[multipart_suggestion(typeck::suggestion)]\n    |   ^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `multipart_suggestion` in this scope\n-  --> $DIR/diagnostic-derive.rs:627:3\n+  --> $DIR/diagnostic-derive.rs:629:3\n    |\n LL | #[multipart_suggestion()]\n    |   ^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `multipart_suggestion` in this scope\n-  --> $DIR/diagnostic-derive.rs:631:7\n+  --> $DIR/diagnostic-derive.rs:633:7\n    |\n LL |     #[multipart_suggestion(typeck::suggestion)]\n    |       ^^^^^^^^^^^^^^^^^^^^\n \n error[E0425]: cannot find value `nonsense` in module `rustc_errors::fluent`\n-  --> $DIR/diagnostic-derive.rs:66:8\n+  --> $DIR/diagnostic-derive.rs:68:8\n    |\n LL | #[diag(nonsense, code = \"E0123\")]\n    |        ^^^^^^^^ not found in `rustc_errors::fluent`\n \n error[E0277]: the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-  --> $DIR/diagnostic-derive.rs:336:10\n+  --> $DIR/diagnostic-derive.rs:338:10\n    |\n LL | #[derive(Diagnostic)]\n    |          ^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n@@ -591,7 +602,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 72 previous errors\n+error: aborting due to 74 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}]}