{"sha": "c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNGZiZmFhZDM4Y2Y1ODI5ZWY1Y2ZlNzgwZGM5ZDU4NDgwYWRlYWE=", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2019-11-27T18:28:39Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2019-11-30T02:37:58Z"}, "message": "Format libstd/sys with rustfmt\n\nThis commit applies rustfmt with rust-lang/rust's default settings to\nfiles in src/libstd/sys *that are not involved in any currently open PR*\nto minimize merge conflicts. THe list of files involved in open PRs was\ndetermined by querying GitHub's GraphQL API with this script:\nhttps://gist.github.com/dtolnay/aa9c34993dc051a4f344d1b10e4487e8\n\nWith the list of files from the script in outstanding_files, the\nrelevant commands were:\n\n    $ find src/libstd/sys -name '*.rs' \\\n        | xargs rustfmt --edition=2018 --unstable-features --skip-children\n    $ rg libstd/sys outstanding_files | xargs git checkout --\n\nRepeating this process several months apart should get us coverage of\nmost of the rest of the files.\n\nTo confirm no funny business:\n\n    $ git checkout $THIS_COMMIT^\n    $ git show --pretty= --name-only $THIS_COMMIT \\\n        | xargs rustfmt --edition=2018 --unstable-features --skip-children\n    $ git diff $THIS_COMMIT  # there should be no difference", "tree": {"sha": "e57b66ed06aec18dc13ff7f14a243ca3dc3c27d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e57b66ed06aec18dc13ff7f14a243ca3dc3c27d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAl3h1gYACgkQ+boUO5X/\nbYJqtQ/8DN2+9gMHHBsEtfac8TyhhK2NOJR1XhHP+cTbx5eEymjEEeor1+ZdCVEA\nP52Vj0Fk58o80FhHfCWzKX/LQVy2lDEN2LXv0jmADkSNhoBgX+wGKF8AacZ6cjjN\ntpmMeinpfICA+NuIWOnAYFXnU9+P4C85UqbMYQZdKKe+t9Mq7qJFJlo1GwDZkkje\n9Tw+h+kKlLwVC2VsuQxdYkzefAHuWS0vfgMQN7B7sgFxsdlOhTSyFgcQ2Qc+47Ma\noUiBCWLn2MT5Y16EiTFM2p/2jTsx/CQBe275bAK2Clu/5EhChyWGVB7XpxVq2QET\nPMgTJUlmYyoMsmHEiY1EezuPNHGPgB+osc9IkmHUiEJXnmVJQqqMbIqTzZ4+138R\nAbmIV2E8bxdHBGZ1wMvfwsMv8BDdoYQK+3LURiwLZUH5jOLUjmZ3Ffg/A+U2AHj8\nph2gffhMfncir283o8P4FVTwil084pAuvT8mfoOAEG/cvVfqfMuRM5md+2arvu8E\njtP4DJNMlay3A4nznB5qlNaiQiKPkZlCGs20Gla0GhFkXpHBde3kSq3R6cRJcPmP\nUOlISTHQAFZioZxAdZ5A4saqpH1T7Bo62G2O2y0UFC+8DsDpQ0rEvRdxBwYew/uB\nJ7dfJwFHhq1jTPPDux8Su5Tg7EQYMSEEesnB16zoqwQdmt7Dnbg=\n=ch5J\n-----END PGP SIGNATURE-----", "payload": "tree e57b66ed06aec18dc13ff7f14a243ca3dc3c27d1\nparent 9081929d45f12d3f56d43b1d6db7519981580fc9\nauthor David Tolnay <dtolnay@gmail.com> 1574879319 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1575081478 -0800\n\nFormat libstd/sys with rustfmt\n\nThis commit applies rustfmt with rust-lang/rust's default settings to\nfiles in src/libstd/sys *that are not involved in any currently open PR*\nto minimize merge conflicts. THe list of files involved in open PRs was\ndetermined by querying GitHub's GraphQL API with this script:\nhttps://gist.github.com/dtolnay/aa9c34993dc051a4f344d1b10e4487e8\n\nWith the list of files from the script in outstanding_files, the\nrelevant commands were:\n\n    $ find src/libstd/sys -name '*.rs' \\\n        | xargs rustfmt --edition=2018 --unstable-features --skip-children\n    $ rg libstd/sys outstanding_files | xargs git checkout --\n\nRepeating this process several months apart should get us coverage of\nmost of the rest of the files.\n\nTo confirm no funny business:\n\n    $ git checkout $THIS_COMMIT^\n    $ git show --pretty= --name-only $THIS_COMMIT \\\n        | xargs rustfmt --edition=2018 --unstable-features --skip-children\n    $ git diff $THIS_COMMIT  # there should be no difference\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "html_url": "https://github.com/rust-lang/rust/commit/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9081929d45f12d3f56d43b1d6db7519981580fc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9081929d45f12d3f56d43b1d6db7519981580fc9", "html_url": "https://github.com/rust-lang/rust/commit/9081929d45f12d3f56d43b1d6db7519981580fc9"}], "stats": {"total": 4812, "additions": 2527, "deletions": 2285}, "files": [{"sha": "326faaa852afeceb554bd8459c5e85cfe0512c49", "filename": "src/libstd/sys/cloudabi/os.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -18,9 +18,7 @@ pub fn errno() -> i32 {\n pub fn error_string(errno: i32) -> String {\n     // cloudlibc's strerror() is guaranteed to be thread-safe. There is\n     // thus no need to use strerror_r().\n-    str::from_utf8(unsafe { CStr::from_ptr(libc::strerror(errno)) }.to_bytes())\n-        .unwrap()\n-        .to_owned()\n+    str::from_utf8(unsafe { CStr::from_ptr(libc::strerror(errno)) }.to_bytes()).unwrap().to_owned()\n }\n \n pub fn exit(code: i32) -> ! {"}, {"sha": "e6160d1457d269176ba95e96409b6eda799d4bb7", "filename": "src/libstd/sys/cloudabi/shims/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::io::{self, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sys::time::SystemTime;\n use crate::sys::{unsupported, Void};"}, {"sha": "b1b5f142f45c2cf95775324d52d1086a8aeda425", "filename": "src/libstd/sys/cloudabi/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -4,19 +4,16 @@ pub mod args;\n pub mod env;\n pub mod fs;\n pub mod net;\n+pub mod os;\n #[path = \"../../unix/path.rs\"]\n pub mod path;\n pub mod pipe;\n pub mod process;\n-pub mod os;\n \n // This enum is used as the storage for a bunch of types which can't actually exist.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub enum Void {}\n \n pub fn unsupported<T>() -> io::Result<T> {\n-    Err(io::Error::new(\n-        io::ErrorKind::Other,\n-        \"This function is not available on CloudABI.\",\n-    ))\n+    Err(io::Error::new(io::ErrorKind::Other, \"This function is not available on CloudABI.\"))\n }"}, {"sha": "67c436fa7955d5c623fbecd69e23df0d35e28a20", "filename": "src/libstd/sys/cloudabi/shims/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n+use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n-use crate::time::Duration;\n use crate::sys::{unsupported, Void};\n-use crate::convert::TryFrom;\n+use crate::time::Duration;\n \n #[allow(unused_extern_crates)]\n pub extern crate libc as netc;"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/cloudabi/shims/process.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -32,9 +32,7 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default(),\n-        }\n+        Command { env: Default::default() }\n     }\n \n     pub fn arg(&mut self, _arg: &OsStr) {}"}, {"sha": "3afcae7ae751603ab0e84fe834f197846b238725", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -58,8 +58,8 @@ impl Thread {\n     }\n \n     pub fn sleep(dur: Duration) {\n-        let timeout = checked_dur2intervals(&dur)\n-            .expect(\"overflow converting duration to nanoseconds\");\n+        let timeout =\n+            checked_dur2intervals(&dur).expect(\"overflow converting duration to nanoseconds\");\n         unsafe {\n             let subscription = abi::subscription {\n                 type_: abi::eventtype::CLOCK,\n@@ -85,11 +85,7 @@ impl Thread {\n         unsafe {\n             let ret = libc::pthread_join(self.id, ptr::null_mut());\n             mem::forget(self);\n-            assert!(\n-                ret == 0,\n-                \"failed to join thread: {}\",\n-                io::Error::from_raw_os_error(ret)\n-            );\n+            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n         }\n     }\n }"}, {"sha": "c209231cf8c0186352f5020194283d293feb46df", "filename": "src/libstd/sys/cloudabi/time.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -10,9 +10,7 @@ pub struct Instant {\n }\n \n pub fn checked_dur2intervals(dur: &Duration) -> Option<abi::timestamp> {\n-    dur.as_secs()\n-        .checked_mul(NSEC_PER_SEC)?\n-        .checked_add(dur.subsec_nanos() as abi::timestamp)\n+    dur.as_secs().checked_mul(NSEC_PER_SEC)?.checked_add(dur.subsec_nanos() as abi::timestamp)\n }\n \n impl Instant {\n@@ -39,15 +37,11 @@ impl Instant {\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant {\n-            t: self.t.checked_add(checked_dur2intervals(other)?)?,\n-        })\n+        Some(Instant { t: self.t.checked_add(checked_dur2intervals(other)?)? })\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant {\n-            t: self.t.checked_sub(checked_dur2intervals(other)?)?,\n-        })\n+        Some(Instant { t: self.t.checked_sub(checked_dur2intervals(other)?)? })\n     }\n }\n \n@@ -69,29 +63,19 @@ impl SystemTime {\n     pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n         if self.t >= other.t {\n             let diff = self.t - other.t;\n-            Ok(Duration::new(\n-                diff / NSEC_PER_SEC,\n-                (diff % NSEC_PER_SEC) as u32,\n-            ))\n+            Ok(Duration::new(diff / NSEC_PER_SEC, (diff % NSEC_PER_SEC) as u32))\n         } else {\n             let diff = other.t - self.t;\n-            Err(Duration::new(\n-                diff / NSEC_PER_SEC,\n-                (diff % NSEC_PER_SEC) as u32,\n-            ))\n+            Err(Duration::new(diff / NSEC_PER_SEC, (diff % NSEC_PER_SEC) as u32))\n         }\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime {\n-            t: self.t.checked_add(checked_dur2intervals(other)?)?,\n-        })\n+        Some(SystemTime { t: self.t.checked_add(checked_dur2intervals(other)?)? })\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime {\n-            t: self.t.checked_sub(checked_dur2intervals(other)?)?,\n-        })\n+        Some(SystemTime { t: self.t.checked_sub(checked_dur2intervals(other)?)? })\n     }\n }\n "}, {"sha": "d153914e77e10235294109f575e627882e34c926", "filename": "src/libstd/sys/hermit/alloc.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -13,11 +13,7 @@ unsafe impl GlobalAlloc for System {\n         let addr = abi::malloc(layout.size(), layout.align());\n \n         if !addr.is_null() {\n-            ptr::write_bytes(\n-                addr,\n-                0x00,\n-                layout.size()\n-            );\n+            ptr::write_bytes(addr, 0x00, layout.size());\n         }\n \n         addr"}, {"sha": "72c1b8511cac8cc25a8d196c8336572626742913", "filename": "src/libstd/sys/hermit/args.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -3,10 +3,14 @@ use crate::marker::PhantomData;\n use crate::vec;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    imp::init(argc, argv)\n+}\n \n /// One-time global cleanup.\n-pub unsafe fn cleanup() { imp::cleanup() }\n+pub unsafe fn cleanup() {\n+    imp::cleanup()\n+}\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n@@ -26,24 +30,32 @@ impl Args {\n \n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<OsString> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.iter.next_back()\n+    }\n }\n \n mod imp {\n-    use crate::sys_common::os_str_bytes::*;\n-    use crate::ptr;\n+    use super::Args;\n     use crate::ffi::{CStr, OsString};\n     use crate::marker::PhantomData;\n-    use super::Args;\n+    use crate::ptr;\n+    use crate::sys_common::os_str_bytes::*;\n \n     use crate::sys_common::mutex::Mutex;\n \n@@ -64,19 +76,18 @@ mod imp {\n     }\n \n     pub fn args() -> Args {\n-        Args {\n-            iter: clone().into_iter(),\n-            _dont_send_or_sync_me: PhantomData\n-        }\n+        Args { iter: clone().into_iter(), _dont_send_or_sync_me: PhantomData }\n     }\n \n     fn clone() -> Vec<OsString> {\n         unsafe {\n             let _guard = LOCK.lock();\n-            (0..ARGC).map(|i| {\n-                let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n-                OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-            }).collect()\n+            (0..ARGC)\n+                .map(|i| {\n+                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n+                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n+                })\n+                .collect()\n         }\n     }\n }"}, {"sha": "304cf906b2aeadba92007440bb5628e3c9ed8184", "filename": "src/libstd/sys/hermit/cmath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n // These symbols are all defined in `compiler-builtins`\n-extern {\n+extern \"C\" {\n     pub fn acos(n: f64) -> f64;\n     pub fn acosf(n: f32) -> f32;\n     pub fn asin(n: f64) -> f64;"}, {"sha": "5b7f16ce562b9b30862071a313618b6f13079df1", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -18,12 +18,12 @@ impl Condvar {\n     }\n \n     pub unsafe fn notify_one(&self) {\n-         let _ = abi::notify(self.id(), 1);\n+        let _ = abi::notify(self.id(), 1);\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n-         let _ = abi::notify(self.id(), -1 /* =all */);\n+        let _ = abi::notify(self.id(), -1 /* =all */);\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {"}, {"sha": "f2f61fdfb8cc64b00a7067ea151e430d28fbc6cf", "filename": "src/libstd/sys/hermit/fd.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,6 +1,6 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n-use crate::io::{self, Read, ErrorKind};\n+use crate::io::{self, ErrorKind, Read};\n use crate::mem;\n use crate::sys::cvt;\n use crate::sys::hermit::abi;\n@@ -16,7 +16,9 @@ impl FileDesc {\n         FileDesc { fd }\n     }\n \n-    pub fn raw(&self) -> i32 { self.fd }\n+    pub fn raw(&self) -> i32 {\n+        self.fd\n+    }\n \n     /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> i32 {\n@@ -67,7 +69,9 @@ impl<'a> Read for &'a FileDesc {\n }\n \n impl AsInner<i32> for FileDesc {\n-    fn as_inner(&self) -> &i32 { &self.fd }\n+    fn as_inner(&self) -> &i32 {\n+        &self.fd\n+    }\n }\n \n impl Drop for FileDesc {"}, {"sha": "37ac5984eeeaf4b0da7c88e71fdc1823e8c96d34", "filename": "src/libstd/sys/hermit/fs.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,14 +1,14 @@\n-use crate::ffi::{OsString, CString, CStr};\n+use crate::ffi::{CStr, CString, OsString};\n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind};\n use crate::hash::{Hash, Hasher};\n-use crate::io::{SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, Error, ErrorKind};\n+use crate::io::{IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n-use crate::sys::time::SystemTime;\n-use crate::sys::{unsupported, Void};\n+use crate::sys::cvt;\n use crate::sys::hermit::abi;\n use crate::sys::hermit::fd::FileDesc;\n-use crate::sys::cvt;\n+use crate::sys::time::SystemTime;\n+use crate::sys::{unsupported, Void};\n use crate::sys_common::os_str_bytes::OsStrExt;\n \n pub use crate::sys_common::fs::copy;\n@@ -45,15 +45,15 @@ pub struct OpenOptions {\n     create: bool,\n     create_new: bool,\n     // system-specific\n-    mode: i32\n+    mode: i32,\n }\n \n pub struct FilePermissions(Void);\n \n pub struct FileType(Void);\n \n #[derive(Debug)]\n-pub struct DirBuilder { }\n+pub struct DirBuilder {}\n \n impl FileAttr {\n     pub fn size(&self) -> u64 {\n@@ -109,8 +109,7 @@ impl PartialEq for FilePermissions {\n     }\n }\n \n-impl Eq for FilePermissions {\n-}\n+impl Eq for FilePermissions {}\n \n impl fmt::Debug for FilePermissions {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -146,8 +145,7 @@ impl PartialEq for FileType {\n     }\n }\n \n-impl Eq for FileType {\n-}\n+impl Eq for FileType {}\n \n impl Hash for FileType {\n     fn hash<H: Hasher>(&self, _h: &mut H) {\n@@ -204,50 +202,64 @@ impl OpenOptions {\n             create: false,\n             create_new: false,\n             // system-specific\n-            mode: 0x777\n+            mode: 0x777,\n         }\n     }\n \n-    pub fn read(&mut self, read: bool) { self.read = read; }\n-    pub fn write(&mut self, write: bool) { self.write = write; }\n-    pub fn append(&mut self, append: bool) { self.append = append; }\n-    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n-    pub fn create(&mut self, create: bool) { self.create = create; }\n-    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+    pub fn read(&mut self, read: bool) {\n+        self.read = read;\n+    }\n+    pub fn write(&mut self, write: bool) {\n+        self.write = write;\n+    }\n+    pub fn append(&mut self, append: bool) {\n+        self.append = append;\n+    }\n+    pub fn truncate(&mut self, truncate: bool) {\n+        self.truncate = truncate;\n+    }\n+    pub fn create(&mut self, create: bool) {\n+        self.create = create;\n+    }\n+    pub fn create_new(&mut self, create_new: bool) {\n+        self.create_new = create_new;\n+    }\n \n     fn get_access_mode(&self) -> io::Result<i32> {\n         match (self.read, self.write, self.append) {\n-            (true,  false, false) => Ok(O_RDONLY),\n-            (false, true,  false) => Ok(O_WRONLY),\n-            (true,  true,  false) => Ok(O_RDWR),\n-            (false, _,     true)  => Ok(O_WRONLY | O_APPEND),\n-            (true,  _,     true)  => Ok(O_RDWR | O_APPEND),\n+            (true, false, false) => Ok(O_RDONLY),\n+            (false, true, false) => Ok(O_WRONLY),\n+            (true, true, false) => Ok(O_RDWR),\n+            (false, _, true) => Ok(O_WRONLY | O_APPEND),\n+            (true, _, true) => Ok(O_RDWR | O_APPEND),\n             (false, false, false) => {\n                 Err(io::Error::new(ErrorKind::InvalidInput, \"invalid access mode\"))\n-            },\n+            }\n         }\n     }\n \n     fn get_creation_mode(&self) -> io::Result<i32> {\n         match (self.write, self.append) {\n             (true, false) => {}\n-            (false, false) =>\n+            (false, false) => {\n                 if self.truncate || self.create || self.create_new {\n                     return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n-                },\n-            (_, true) =>\n+                }\n+            }\n+            (_, true) => {\n                 if self.truncate && !self.create_new {\n                     return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n-                },\n+                }\n+            }\n         }\n \n         Ok(match (self.create, self.truncate, self.create_new) {\n-                (false, false, false) => 0,\n-                (true,  false, false) => O_CREAT,\n-                (false, true,  false) => O_TRUNC,\n-                (true,  true,  false) => O_CREAT | O_TRUNC,\n-                (_,      _,    true)  => O_CREAT | O_EXCL,\n-           })\n+            (false, false, false) => 0,\n+            (true, false, false) => O_CREAT,\n+            (false, true, false) => O_TRUNC,\n+            (true, true, false) => O_CREAT | O_TRUNC,\n+            (_, _, true) => O_CREAT | O_EXCL,\n+        })\n     }\n }\n \n@@ -327,7 +339,7 @@ impl File {\n \n impl DirBuilder {\n     pub fn new() -> DirBuilder {\n-        DirBuilder { }\n+        DirBuilder {}\n     }\n \n     pub fn mkdir(&self, _p: &Path) -> io::Result<()> {"}, {"sha": "1e4a53abdc7bd9ed1cbc3ed27ed20e8f02218784", "filename": "src/libstd/sys/hermit/mod.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -13,34 +13,34 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-use crate::os::raw::c_char;\n use crate::intrinsics;\n+use crate::os::raw::c_char;\n \n pub mod alloc;\n pub mod args;\n-pub mod condvar;\n-pub mod stdio;\n-pub mod memchr;\n-pub mod io;\n-pub mod mutex;\n-pub mod rwlock;\n-pub mod os;\n pub mod cmath;\n-pub mod thread;\n+pub mod condvar;\n pub mod env;\n-pub mod fs;\n+pub mod fast_thread_local;\n pub mod fd;\n+pub mod fs;\n+pub mod io;\n+pub mod memchr;\n+pub mod mutex;\n pub mod net;\n+pub mod os;\n pub mod path;\n pub mod pipe;\n pub mod process;\n+pub mod rwlock;\n pub mod stack_overflow;\n-pub mod time;\n+pub mod stdio;\n+pub mod thread;\n pub mod thread_local;\n-pub mod fast_thread_local;\n+pub mod time;\n \n-pub use crate::sys_common::os_str_bytes as os_str;\n use crate::io::ErrorKind;\n+pub use crate::sys_common::os_str_bytes as os_str;\n \n #[allow(unused_extern_crates)]\n pub extern crate hermit_abi as abi;\n@@ -50,8 +50,7 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new(crate::io::ErrorKind::Other,\n-           \"operation not supported on HermitCore yet\")\n+    crate::io::Error::new(crate::io::ErrorKind::Other, \"operation not supported on HermitCore yet\")\n }\n \n // This enum is used as the storage for a bunch of types which can't actually\n@@ -71,9 +70,7 @@ pub unsafe fn strlen(start: *const c_char) -> usize {\n \n #[no_mangle]\n pub extern \"C\" fn floor(x: f64) -> f64 {\n-    unsafe {\n-        intrinsics::floorf64(x)\n-    }\n+    unsafe { intrinsics::floorf64(x) }\n }\n \n pub unsafe fn abort_internal() -> ! {\n@@ -103,8 +100,11 @@ pub fn init() {\n \n #[cfg(not(test))]\n #[no_mangle]\n-pub unsafe extern \"C\" fn runtime_entry(argc: i32, argv: *const *const c_char,\n-                                       env: *const *const c_char) -> ! {\n+pub unsafe extern \"C\" fn runtime_entry(\n+    argc: i32,\n+    argv: *const *const c_char,\n+    env: *const *const c_char,\n+) -> ! {\n     extern \"C\" {\n         fn main(argc: isize, argv: *const *const c_char) -> i32;\n     }\n@@ -139,9 +139,5 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n }\n \n pub fn cvt(result: i32) -> crate::io::Result<usize> {\n-    if result < 0 {\n-        Err(crate::io::Error::from_raw_os_error(-result))\n-    } else {\n-        Ok(result as usize)\n-    }\n+    if result < 0 { Err(crate::io::Error::from_raw_os_error(-result)) } else { Ok(result as usize) }\n }"}, {"sha": "b5c75f738d228e170f0d07d21a7a7e0e24d353c1", "filename": "src/libstd/sys/hermit/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n-use crate::ptr;\n use crate::ffi::c_void;\n+use crate::ptr;\n use crate::sys::hermit::abi;\n \n pub struct Mutex {\n-    inner: *const c_void\n+    inner: *const c_void,\n }\n \n unsafe impl Send for Mutex {}\n@@ -42,7 +42,7 @@ impl Mutex {\n }\n \n pub struct ReentrantMutex {\n-    inner: *const c_void\n+    inner: *const c_void,\n }\n \n impl ReentrantMutex {"}, {"sha": "82917e71be1f815d5be96d84b76adb4160955e70", "filename": "src/libstd/sys/hermit/net.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n-use crate::fmt;\n use crate::convert::TryFrom;\n+use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::str;\n use crate::sys::{unsupported, Void};\n use crate::time::Duration;\n@@ -234,23 +234,19 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n@@ -357,8 +353,7 @@ pub mod netc {\n     }\n \n     #[derive(Copy, Clone)]\n-    pub struct sockaddr {\n-    }\n+    pub struct sockaddr {}\n \n     pub type socklen_t = usize;\n }"}, {"sha": "ad63b0e0c13180fa105df280606b2d381ebeef3e", "filename": "src/libstd/sys/hermit/os.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,18 +1,18 @@\n+use crate::collections::HashMap;\n use crate::error::Error as StdError;\n-use crate::ffi::{CStr, OsString, OsStr};\n+use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n use crate::memchr;\n use crate::path::{self, PathBuf};\n use crate::ptr;\n use crate::str;\n-use crate::sys::{unsupported, Void};\n-use crate::collections::HashMap;\n-use crate::vec;\n use crate::sync::Mutex;\n-use crate::sys_common::os_str_bytes::*;\n use crate::sys::hermit::abi;\n+use crate::sys::{unsupported, Void};\n+use crate::sys_common::os_str_bytes::*;\n+use crate::vec;\n \n pub fn errno() -> i32 {\n     0\n@@ -47,7 +47,9 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     Err(JoinPathsError)\n }\n@@ -77,7 +79,7 @@ pub fn init_environment(env: *const *const i8) {\n         let mut guard = ENV.as_ref().unwrap().lock().unwrap();\n         let mut environ = env;\n         while environ != ptr::null() && *environ != ptr::null() {\n-            if let Some((key,value)) = parse(CStr::from_ptr(*environ).to_bytes()) {\n+            if let Some((key, value)) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                 guard.insert(key, value);\n             }\n             environ = environ.offset(1);\n@@ -93,10 +95,12 @@ pub fn init_environment(env: *const *const i8) {\n             return None;\n         }\n         let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n-        pos.map(|p| (\n-            OsStringExt::from_vec(input[..p].to_vec()),\n-            OsStringExt::from_vec(input[p+1..].to_vec()),\n-        ))\n+        pos.map(|p| {\n+            (\n+                OsStringExt::from_vec(input[..p].to_vec()),\n+                OsStringExt::from_vec(input[p + 1..].to_vec()),\n+            )\n+        })\n     }\n }\n \n@@ -107,33 +111,34 @@ pub struct Env {\n \n impl Iterator for Env {\n     type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n-   unsafe {\n+    unsafe {\n         let guard = ENV.as_ref().unwrap().lock().unwrap();\n         let mut result = Vec::new();\n \n         for (key, value) in guard.iter() {\n             result.push((key.clone(), value.clone()));\n         }\n \n-        return Env {\n-            iter: result.into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        }\n+        return Env { iter: result.into_iter(), _dont_send_or_sync_me: PhantomData };\n     }\n }\n \n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     unsafe {\n         match ENV.as_ref().unwrap().lock().unwrap().get_mut(k) {\n-            Some(value) => { Ok(Some(value.clone())) },\n-            None => { Ok(None) },\n+            Some(value) => Ok(Some(value.clone())),\n+            None => Ok(None),\n         }\n     }\n }\n@@ -168,7 +173,5 @@ pub fn exit(code: i32) -> ! {\n }\n \n pub fn getpid() -> u32 {\n-    unsafe {\n-        abi::getpid()\n-    }\n+    unsafe { abi::getpid() }\n }"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/hermit/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "fb14dc591018116ea405550f4697f60378b2d7e8", "filename": "src/libstd/sys/hermit/pipe.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -25,9 +25,6 @@ impl AnonPipe {\n     }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             _v1: &mut Vec<u8>,\n-             _p2: AnonPipe,\n-             _v2: &mut Vec<u8>) -> io::Result<()> {\n+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n     match p1.0 {}\n }"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/hermit/process.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -32,32 +32,28 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default()\n-        }\n+        Command { env: Default::default() }\n     }\n \n-    pub fn arg(&mut self, _arg: &OsStr) {\n-    }\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n \n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n-    pub fn cwd(&mut self, _dir: &OsStr) {\n-    }\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n \n-    pub fn stdin(&mut self, _stdin: Stdio) {\n-    }\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n \n-    pub fn stdout(&mut self, _stdout: Stdio) {\n-    }\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n \n-    pub fn stderr(&mut self, _stderr: Stdio) {\n-    }\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n \n-    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n-        -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         unsupported()\n     }\n }\n@@ -106,8 +102,7 @@ impl PartialEq for ExitStatus {\n     }\n }\n \n-impl Eq for ExitStatus {\n-}\n+impl Eq for ExitStatus {}\n \n impl fmt::Debug for ExitStatus {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "c19799af3c7ee3c2d1ada043f32158aa7a062b7a", "filename": "src/libstd/sys/hermit/rwlock.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,17 +1,15 @@\n use super::mutex::Mutex;\n \n pub struct RWLock {\n-    mutex: Mutex\n+    mutex: Mutex,\n }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock {\n-            mutex: Mutex::new()\n-        }\n+        RWLock { mutex: Mutex::new() }\n     }\n \n     #[inline]"}, {"sha": "65a1b17acce9a701eea14e5fed00c3bc1569aeed", "filename": "src/libstd/sys/hermit/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -7,9 +7,7 @@ impl Handler {\n }\n \n #[inline]\n-pub unsafe fn init() {\n-}\n+pub unsafe fn init() {}\n \n #[inline]\n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}"}, {"sha": "2eb011ccb3974d311597fe83228b441d6d6ca919", "filename": "src/libstd/sys/hermit/stdio.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -20,7 +20,6 @@ impl Stdin {\n         //    .read(data)\n         Ok(0)\n     }\n-\n }\n \n impl Stdout {\n@@ -31,9 +30,7 @@ impl Stdout {\n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n         let len;\n \n-        unsafe {\n-            len = abi::write(1, data.as_ptr() as *const u8, data.len())\n-        }\n+        unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n             Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n@@ -45,9 +42,7 @@ impl Stdout {\n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n         let len;\n \n-        unsafe {\n-            len = abi::write(1, data.as_ptr() as *const u8, data.len())\n-        }\n+        unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n             Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n@@ -69,9 +64,7 @@ impl Stderr {\n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n         let len;\n \n-        unsafe {\n-            len = abi::write(2, data.as_ptr() as *const u8, data.len())\n-        }\n+        unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n             Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))\n@@ -83,9 +76,7 @@ impl Stderr {\n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n         let len;\n \n-        unsafe {\n-            len = abi::write(2, data.as_ptr() as *const u8, data.len())\n-        }\n+        unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n             Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))"}, {"sha": "c3c29c93826dedfe8ccb6f3b4c8ee5dcad9fdaec", "filename": "src/libstd/sys/hermit/thread.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,11 +1,11 @@\n #![allow(dead_code)]\n \n use crate::ffi::CStr;\n+use crate::fmt;\n use crate::io;\n+use crate::mem;\n use crate::sys::hermit::abi;\n use crate::time::Duration;\n-use crate::mem;\n-use crate::fmt;\n use core::u32;\n \n use crate::sys_common::thread::*;\n@@ -35,7 +35,7 @@ impl fmt::Display for Priority {\n pub const NORMAL_PRIO: Priority = Priority::from(2);\n \n pub struct Thread {\n-    tid: Tid\n+    tid: Tid,\n }\n \n unsafe impl Send for Thread {}\n@@ -44,14 +44,20 @@ unsafe impl Sync for Thread {}\n pub const DEFAULT_MIN_STACK_SIZE: usize = 262144;\n \n impl Thread {\n-    pub unsafe fn new_with_coreid(_stack: usize, p: Box<dyn FnOnce()>, core_id: isize)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new_with_coreid(\n+        _stack: usize,\n+        p: Box<dyn FnOnce()>,\n+        core_id: isize,\n+    ) -> io::Result<Thread> {\n         let p = box p;\n         let mut tid: Tid = u32::MAX;\n-        let ret = abi::spawn(&mut tid as *mut Tid, thread_start,\n-                            &*p as *const _ as *const u8 as usize,\n-                            Priority::into(NORMAL_PRIO), core_id);\n+        let ret = abi::spawn(\n+            &mut tid as *mut Tid,\n+            thread_start,\n+            &*p as *const _ as *const u8 as usize,\n+            Priority::into(NORMAL_PRIO),\n+            core_id,\n+        );\n \n         return if ret == 0 {\n             mem::forget(p); // ownership passed to pthread_create\n@@ -60,16 +66,14 @@ impl Thread {\n             Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n         };\n \n-        extern fn thread_start(main: usize) {\n+        extern \"C\" fn thread_start(main: usize) {\n             unsafe {\n                 start_thread(main as *mut u8);\n             }\n         }\n     }\n \n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         Thread::new_with_coreid(stack, p, -1 /* = no specific core */)\n     }\n \n@@ -99,7 +103,9 @@ impl Thread {\n     }\n \n     #[inline]\n-    pub fn id(&self) -> Tid { self.tid }\n+    pub fn id(&self) -> Tid {\n+        self.tid\n+    }\n \n     #[inline]\n     pub fn into_id(self) -> Tid {\n@@ -111,6 +117,10 @@ impl Thread {\n \n pub mod guard {\n     pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }"}, {"sha": "ba967c7676c3fd6118a9999d18735c3d5ad928ac", "filename": "src/libstd/sys/hermit/thread_local.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -7,7 +7,7 @@ use crate::sys_common::mutex::Mutex;\n \n pub type Key = usize;\n \n-type Dtor = unsafe extern fn(*mut u8);\n+type Dtor = unsafe extern \"C\" fn(*mut u8);\n \n static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n \n@@ -41,11 +41,7 @@ pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n \n #[inline]\n pub unsafe fn get(key: Key) -> *mut u8 {\n-    if let Some(&entry) = locals().get(&key) {\n-        entry\n-    } else {\n-        ptr::null_mut()\n-    }\n+    if let Some(&entry) = locals().get(&key) { entry } else { ptr::null_mut() }\n }\n \n #[inline]"}, {"sha": "c02de17c1fc3ab61688c528bfd55595bffc675cb", "filename": "src/libstd/sys/hermit/time.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,34 +1,35 @@\n #![allow(dead_code)]\n \n-use crate::time::Duration;\n use crate::cmp::Ordering;\n use crate::convert::TryInto;\n-use core::hash::{Hash, Hasher};\n use crate::sys::hermit::abi;\n-use crate::sys::hermit::abi::{CLOCK_REALTIME, CLOCK_MONOTONIC, NSEC_PER_SEC};\n use crate::sys::hermit::abi::timespec;\n+use crate::sys::hermit::abi::{CLOCK_MONOTONIC, CLOCK_REALTIME, NSEC_PER_SEC};\n+use crate::time::Duration;\n+use core::hash::{Hash, Hasher};\n \n #[derive(Copy, Clone, Debug)]\n struct Timespec {\n-    t: timespec\n+    t: timespec,\n }\n \n impl Timespec {\n     const fn zero() -> Timespec {\n-        Timespec {\n-            t: timespec { tv_sec: 0, tv_nsec: 0 },\n-        }\n+        Timespec { t: timespec { tv_sec: 0, tv_nsec: 0 } }\n     }\n \n     fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n         if self >= other {\n             Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n-                              (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+                Duration::new(\n+                    (self.t.tv_sec - other.t.tv_sec) as u64,\n+                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n+                )\n             } else {\n-                Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n-                              other.t.tv_nsec as u32)\n+                Duration::new(\n+                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n+                )\n             })\n         } else {\n             match other.sub_timespec(self) {\n@@ -52,12 +53,7 @@ impl Timespec {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n         }\n-        Some(Timespec {\n-            t: timespec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as _,\n-            },\n-        })\n+        Some(Timespec { t: timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n     }\n \n     fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n@@ -73,12 +69,7 @@ impl Timespec {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n         }\n-        Some(Timespec {\n-            t: timespec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as _,\n-            },\n-        })\n+        Some(Timespec { t: timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n     }\n }\n \n@@ -105,7 +96,7 @@ impl Ord for Timespec {\n }\n \n impl Hash for Timespec {\n-    fn hash<H : Hasher>(&self, state: &mut H) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         self.t.tv_sec.hash(state);\n         self.t.tv_nsec.hash(state);\n     }\n@@ -150,9 +141,7 @@ pub struct SystemTime {\n     t: Timespec,\n }\n \n-pub const UNIX_EPOCH: SystemTime = SystemTime {\n-    t: Timespec::zero(),\n-};\n+pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n \n impl SystemTime {\n     pub fn now() -> SystemTime {"}, {"sha": "87e7a5da2b7a9b179eaa0222305f89914fbd4efb", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,11 +1,11 @@\n #![cfg_attr(test, allow(unused))] // RT initialization logic is not compiled for test\n \n-use core::sync::atomic::{AtomicUsize, Ordering};\n use crate::io::Write;\n+use core::sync::atomic::{AtomicUsize, Ordering};\n \n // runtime features\n-mod reloc;\n pub(super) mod panic;\n+mod reloc;\n \n // library features\n pub mod mem;\n@@ -38,14 +38,16 @@ unsafe extern \"C\" fn tcs_init(secondary: bool) {\n         UNINIT => {\n             reloc::relocate_elf_rela();\n             RELOC_STATE.store(DONE, Ordering::Release);\n-        },\n+        }\n         // We need to wait until the initialization is done.\n-        BUSY => while RELOC_STATE.load(Ordering::Acquire) == BUSY  {\n-            core::arch::x86_64::_mm_pause()\n-        },\n+        BUSY => {\n+            while RELOC_STATE.load(Ordering::Acquire) == BUSY {\n+                core::arch::x86_64::_mm_pause()\n+            }\n+        }\n         // Initialization is done.\n-        DONE => {},\n-        _ => unreachable!()\n+        DONE => {}\n+        _ => unreachable!(),\n     }\n }\n "}, {"sha": "229b3b3291f63fa1a8624a304248c2875d2095e3", "filename": "src/libstd/sys/sgx/abi/panic.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -16,21 +16,13 @@ fn empty_user_slice() -> &'static mut UserRef<[u8]> {\n \n impl SgxPanicOutput {\n     pub(crate) fn new() -> Option<Self> {\n-        if unsafe { DEBUG == 0 } {\n-            None\n-        } else {\n-            Some(SgxPanicOutput(None))\n-        }\n+        if unsafe { DEBUG == 0 } { None } else { Some(SgxPanicOutput(None)) }\n     }\n \n     fn init(&mut self) -> &mut &'static mut UserRef<[u8]> {\n         self.0.get_or_insert_with(|| unsafe {\n             let ptr = take_debug_panic_buf_ptr();\n-            if ptr.is_null() {\n-                empty_user_slice()\n-            } else {\n-                UserRef::from_raw_parts_mut(ptr, 1024)\n-            }\n+            if ptr.is_null() { empty_user_slice() } else { UserRef::from_raw_parts_mut(ptr, 1024) }\n         })\n     }\n }"}, {"sha": "02dff0ad29fc3ddd821ed279787d61273155cc9a", "filename": "src/libstd/sys/sgx/abi/reloc.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::slice::from_raw_parts;\n use super::mem;\n+use crate::slice::from_raw_parts;\n \n const R_X86_64_RELATIVE: u32 = 8;\n \n@@ -11,18 +11,20 @@ struct Rela<T> {\n }\n \n pub fn relocate_elf_rela() {\n-    extern {\n+    extern \"C\" {\n         static RELA: u64;\n         static RELACOUNT: usize;\n     }\n \n-    if unsafe { RELACOUNT } == 0 { return }  // unsafe ok: link-time constant\n+    if unsafe { RELACOUNT } == 0 {\n+        return;\n+    } // unsafe ok: link-time constant\n \n     let relas = unsafe {\n-        from_raw_parts::<Rela<u64>>(mem::rel_ptr(RELA), RELACOUNT)  // unsafe ok: link-time constant\n+        from_raw_parts::<Rela<u64>>(mem::rel_ptr(RELA), RELACOUNT) // unsafe ok: link-time constant\n     };\n     for rela in relas {\n-        if rela.info != (/*0 << 32 |*/ R_X86_64_RELATIVE as u64) {\n+        if rela.info != (/*0 << 32 |*/R_X86_64_RELATIVE as u64) {\n             rtabort!(\"Invalid relocation\");\n         }\n         unsafe { *mem::rel_ptr_mut::<*const ()>(rela.offset) = mem::rel_ptr(rela.addend) };"}, {"sha": "ef55b821a2b6524e39d4d381ebba2311ad96164b", "filename": "src/libstd/sys/sgx/abi/thread.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -6,6 +6,8 @@ use fortanix_sgx_abi::Tcs;\n /// is a one-to-one correspondence of the ID to the address of the TCS.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn current() -> Tcs {\n-    extern \"C\" { fn get_tcs_addr() -> Tcs; }\n+    extern \"C\" {\n+        fn get_tcs_addr() -> Tcs;\n+    }\n     unsafe { get_tcs_addr() }\n }"}, {"sha": "81a766e367d6eb270eec84ff38b9b382eed04fe6", "filename": "src/libstd/sys/sgx/abi/tls.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,11 +1,11 @@\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-use crate::ptr;\n-use crate::mem;\n+use self::sync_bitset::*;\n use crate::cell::Cell;\n+use crate::mem;\n use crate::num::NonZeroUsize;\n-use self::sync_bitset::*;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n \n-#[cfg(target_pointer_width=\"64\")]\n+#[cfg(target_pointer_width = \"64\")]\n const USIZE_BITS: usize = 64;\n const TLS_KEYS: usize = 128; // Same as POSIX minimum\n const TLS_KEYS_BITSET_SIZE: usize = (TLS_KEYS + (USIZE_BITS - 1)) / USIZE_BITS;\n@@ -50,18 +50,18 @@ impl Key {\n \n #[repr(C)]\n pub struct Tls {\n-    data: [Cell<*mut u8>; TLS_KEYS]\n+    data: [Cell<*mut u8>; TLS_KEYS],\n }\n \n pub struct ActiveTls<'a> {\n-    tls: &'a Tls\n+    tls: &'a Tls,\n }\n \n impl<'a> Drop for ActiveTls<'a> {\n     fn drop(&mut self) {\n         let value_with_destructor = |key: usize| {\n             let ptr = TLS_DESTRUCTOR[key].load(Ordering::Relaxed);\n-            unsafe { mem::transmute::<_,Option<unsafe extern fn(*mut u8)>>(ptr) }\n+            unsafe { mem::transmute::<_, Option<unsafe extern \"C\" fn(*mut u8)>>(ptr) }\n                 .map(|dtor| (&self.tls.data[key], dtor))\n         };\n \n@@ -99,7 +99,7 @@ impl Tls {\n         &*(get_tls_ptr() as *const Tls)\n     }\n \n-    pub fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    pub fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n         let index = if let Some(index) = TLS_KEY_IN_USE.set() {\n             index\n         } else {\n@@ -127,10 +127,10 @@ impl Tls {\n }\n \n mod sync_bitset {\n-    use crate::sync::atomic::{AtomicUsize, Ordering};\n+    use super::{TLS_KEYS_BITSET_SIZE, USIZE_BITS};\n     use crate::iter::{Enumerate, Peekable};\n     use crate::slice::Iter;\n-    use super::{TLS_KEYS_BITSET_SIZE, USIZE_BITS};\n+    use crate::sync::atomic::{AtomicUsize, Ordering};\n \n     /// A bitset that can be used synchronously.\n     pub(super) struct SyncBitset([AtomicUsize; TLS_KEYS_BITSET_SIZE]);\n@@ -146,10 +146,7 @@ mod sync_bitset {\n \n         /// Not atomic.\n         pub fn iter(&self) -> SyncBitsetIter<'_> {\n-            SyncBitsetIter {\n-                iter: self.0.iter().enumerate().peekable(),\n-                elem_idx: 0,\n-            }\n+            SyncBitsetIter { iter: self.0.iter().enumerate().peekable(), elem_idx: 0 }\n         }\n \n         pub fn clear(&self, index: usize) {\n@@ -171,7 +168,7 @@ mod sync_bitset {\n                         current,\n                         current | (1 << trailing_ones),\n                         Ordering::AcqRel,\n-                        Ordering::Relaxed\n+                        Ordering::Relaxed,\n                     ) {\n                         Ok(_) => return Some(idx * USIZE_BITS + trailing_ones),\n                         Err(previous) => current = previous,"}, {"sha": "b54c115a2b6b670a7e4ea53cffe06962b6131c03", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,14 +1,14 @@\n #![allow(unused)]\n \n-use crate::ptr::{self, NonNull};\n-use crate::mem;\n use crate::cell::UnsafeCell;\n+use crate::mem;\n+use crate::ops::{CoerceUnsized, Deref, DerefMut, Index, IndexMut};\n+use crate::ptr::{self, NonNull};\n use crate::slice;\n-use crate::ops::{Deref, DerefMut, Index, IndexMut, CoerceUnsized};\n use crate::slice::SliceIndex;\n \n-use fortanix_sgx_abi::*;\n use super::super::mem::is_user_range;\n+use fortanix_sgx_abi::*;\n \n /// A type that can be safely read from or written to userspace.\n ///\n@@ -109,9 +109,7 @@ pub unsafe trait UserSafe {\n     /// * the pointer is null.\n     /// * the pointed-to range is not in user memory.\n     unsafe fn check_ptr(ptr: *const Self) {\n-        let is_aligned = |p| -> bool {\n-            0 == (p as usize) & (Self::align_of() - 1)\n-        };\n+        let is_aligned = |p| -> bool { 0 == (p as usize) & (Self::align_of() - 1) };\n \n         assert!(is_aligned(ptr as *const u8));\n         assert!(is_user_range(ptr as _, mem::size_of_val(&*ptr)));\n@@ -183,7 +181,10 @@ impl<T: ?Sized> NewUserRef<NonNull<T>> for NonNull<UserRef<T>> {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> User<T> where T: UserSafe {\n+impl<T: ?Sized> User<T>\n+where\n+    T: UserSafe,\n+{\n     // This function returns memory that is practically uninitialized, but is\n     // not considered \"unspecified\" or \"undefined\" for purposes of an\n     // optimizing compiler. This is achieved by returning a pointer from\n@@ -211,7 +212,7 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n             ptr::copy(\n                 val as *const T as *const u8,\n                 ret.0.as_ptr() as *mut u8,\n-                mem::size_of_val(val)\n+                mem::size_of_val(val),\n             );\n             ret\n         }\n@@ -244,15 +245,21 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T> User<T> where T: UserSafe {\n+impl<T> User<T>\n+where\n+    T: UserSafe,\n+{\n     /// Allocate space for `T` in user memory.\n     pub fn uninitialized() -> Self {\n         Self::new_uninit_bytes(mem::size_of::<T>())\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T> User<[T]> where [T]: UserSafe {\n+impl<T> User<[T]>\n+where\n+    [T]: UserSafe,\n+{\n     /// Allocate space for a `[T]` of `n` elements in user memory.\n     pub fn uninitialized(n: usize) -> Self {\n         Self::new_uninit_bytes(n * mem::size_of::<T>())\n@@ -278,7 +285,10 @@ impl<T> User<[T]> where [T]: UserSafe {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> UserRef<T> where T: UserSafe {\n+impl<T: ?Sized> UserRef<T>\n+where\n+    T: UserSafe,\n+{\n     /// Creates a `&UserRef<[T]>` from a raw pointer.\n     ///\n     /// # Safety\n@@ -309,7 +319,7 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_mut_ptr<'a>(ptr: *mut T) -> &'a mut Self {\n         T::check_ptr(ptr);\n-        &mut*(ptr as *mut Self)\n+        &mut *(ptr as *mut Self)\n     }\n \n     /// Copies `val` into user memory.\n@@ -319,11 +329,11 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n     /// the source. This can happen for dynamically-sized types such as slices.\n     pub fn copy_from_enclave(&mut self, val: &T) {\n         unsafe {\n-            assert_eq!(mem::size_of_val(val), mem::size_of_val( &*self.0.get() ));\n+            assert_eq!(mem::size_of_val(val), mem::size_of_val(&*self.0.get()));\n             ptr::copy(\n                 val as *const T as *const u8,\n                 self.0.get() as *mut T as *mut u8,\n-                mem::size_of_val(val)\n+                mem::size_of_val(val),\n             );\n         }\n     }\n@@ -335,11 +345,11 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n     /// the source. This can happen for dynamically-sized types such as slices.\n     pub fn copy_to_enclave(&self, dest: &mut T) {\n         unsafe {\n-            assert_eq!(mem::size_of_val(dest), mem::size_of_val( &*self.0.get() ));\n+            assert_eq!(mem::size_of_val(dest), mem::size_of_val(&*self.0.get()));\n             ptr::copy(\n                 self.0.get() as *const T as *const u8,\n                 dest as *mut T as *mut u8,\n-                mem::size_of_val(dest)\n+                mem::size_of_val(dest),\n             );\n         }\n     }\n@@ -356,15 +366,21 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T> UserRef<T> where T: UserSafe {\n+impl<T> UserRef<T>\n+where\n+    T: UserSafe,\n+{\n     /// Copies the value from user memory into enclave memory.\n     pub fn to_enclave(&self) -> T {\n         unsafe { ptr::read(self.0.get()) }\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T> UserRef<[T]> where [T]: UserSafe {\n+impl<T> UserRef<[T]>\n+where\n+    [T]: UserSafe,\n+{\n     /// Creates a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n     ///\n     /// # Safety\n@@ -396,7 +412,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n     /// * The pointed-to range does not fit in the address space\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n-        &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n+        &mut *(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n     }\n \n     /// Obtain a raw pointer to the first element of this user slice.\n@@ -439,20 +455,18 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n \n     /// Returns an iterator over the slice.\n     pub fn iter(&self) -> Iter<'_, T>\n-        where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n+    where\n+        T: UserSafe, // FIXME: should be implied by [T]: UserSafe?\n     {\n-        unsafe {\n-            Iter((&*self.as_raw_ptr()).iter())\n-        }\n+        unsafe { Iter((&*self.as_raw_ptr()).iter()) }\n     }\n \n     /// Returns an iterator that allows modifying each value.\n     pub fn iter_mut(&mut self) -> IterMut<'_, T>\n-        where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n+    where\n+        T: UserSafe, // FIXME: should be implied by [T]: UserSafe?\n     {\n-        unsafe {\n-            IterMut((&mut*self.as_raw_mut_ptr()).iter_mut())\n-        }\n+        unsafe { IterMut((&mut *self.as_raw_mut_ptr()).iter_mut()) }\n     }\n }\n \n@@ -468,9 +482,7 @@ impl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        unsafe {\n-            self.0.next().map(|e| UserRef::from_ptr(e))\n-        }\n+        unsafe { self.0.next().map(|e| UserRef::from_ptr(e)) }\n     }\n }\n \n@@ -486,14 +498,15 @@ impl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        unsafe {\n-            self.0.next().map(|e| UserRef::from_mut_ptr(e))\n-        }\n+        unsafe { self.0.next().map(|e| UserRef::from_mut_ptr(e)) }\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> Deref for User<T> where T: UserSafe {\n+impl<T: ?Sized> Deref for User<T>\n+where\n+    T: UserSafe,\n+{\n     type Target = UserRef<T>;\n \n     fn deref(&self) -> &Self::Target {\n@@ -502,18 +515,24 @@ impl<T: ?Sized> Deref for User<T> where T: UserSafe {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> DerefMut for User<T> where T: UserSafe {\n+impl<T: ?Sized> DerefMut for User<T>\n+where\n+    T: UserSafe,\n+{\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        unsafe { &mut*self.0.as_ptr() }\n+        unsafe { &mut *self.0.as_ptr() }\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> Drop for User<T> where T: UserSafe {\n+impl<T: ?Sized> Drop for User<T>\n+where\n+    T: UserSafe,\n+{\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = (*self.0.as_ptr()).0.get();\n-            super::free(ptr as _, mem::size_of_val(&mut*ptr), T::align_of());\n+            super::free(ptr as _, mem::size_of_val(&mut *ptr), T::align_of());\n         }\n     }\n }\n@@ -550,7 +569,7 @@ where\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n         unsafe {\n-            if let Some(slice) = index.get_mut(&mut*self.as_raw_mut_ptr()) {\n+            if let Some(slice) = index.get_mut(&mut *self.as_raw_mut_ptr()) {\n                 UserRef::from_mut_ptr(slice)\n             } else {\n                 rtabort!(\"index out of range for user slice\");"}, {"sha": "ae803ee47a6cb1717bd7439a6cc80322b28557ad", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n use crate::cmp;\n-use crate::io::{Error as IoError, Result as IoResult, IoSlice, IoSliceMut};\n+use crate::io::{Error as IoError, IoSlice, IoSliceMut, Result as IoResult};\n use crate::time::Duration;\n \n pub(crate) mod alloc;\n@@ -26,7 +26,7 @@ pub fn read(fd: Fd, bufs: &mut [IoSliceMut<'_>]) -> IoResult<usize> {\n                 userbuf[index..end].copy_to_enclave(&mut buf[..buflen]);\n                 index += buf.len();\n             } else {\n-                break\n+                break;\n             }\n         }\n         Ok(userbuf.len())\n@@ -60,7 +60,7 @@ pub fn write(fd: Fd, bufs: &[IoSlice<'_>]) -> IoResult<usize> {\n                 userbuf[index..end].copy_from_enclave(&buf[..buflen]);\n                 index += buf.len();\n             } else {\n-                break\n+                break;\n             }\n         }\n         raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n@@ -90,11 +90,8 @@ pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n     unsafe {\n         let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n         let mut local = alloc::User::<ByteBuffer>::uninitialized();\n-        let fd = raw::bind_stream(\n-            addr_user.as_ptr(),\n-            addr_user.len(),\n-            local.as_raw_mut_ptr()\n-        ).from_sgx_result()?;\n+        let fd = raw::bind_stream(addr_user.as_ptr(), addr_user.len(), local.as_raw_mut_ptr())\n+            .from_sgx_result()?;\n         let local = string_from_bytebuffer(&local, \"bind_stream\", \"local_addr\");\n         Ok((fd, local))\n     }\n@@ -106,13 +103,10 @@ pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n     unsafe {\n         let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n         let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n-                                                               // without forcing coercion?\n+        // without forcing coercion?\n         let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n-        let fd = raw::accept_stream(\n-            fd,\n-            local.as_raw_mut_ptr(),\n-            peer.as_raw_mut_ptr()\n-        ).from_sgx_result()?;\n+        let fd = raw::accept_stream(fd, local.as_raw_mut_ptr(), peer.as_raw_mut_ptr())\n+            .from_sgx_result()?;\n         let local = string_from_bytebuffer(&local, \"accept_stream\", \"local_addr\");\n         let peer = string_from_bytebuffer(&peer, \"accept_stream\", \"peer_addr\");\n         Ok((fd, local, peer))\n@@ -126,14 +120,15 @@ pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n         let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n         let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n         let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n-                                                               // without forcing coercion?\n+        // without forcing coercion?\n         let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n         let fd = raw::connect_stream(\n             addr_user.as_ptr(),\n             addr_user.len(),\n             local.as_raw_mut_ptr(),\n-            peer.as_raw_mut_ptr()\n-        ).from_sgx_result()?;\n+            peer.as_raw_mut_ptr(),\n+        )\n+        .from_sgx_result()?;\n         let local = string_from_bytebuffer(&local, \"connect_stream\", \"local_addr\");\n         let peer = string_from_bytebuffer(&peer, \"connect_stream\", \"peer_addr\");\n         Ok((fd, local, peer))\n@@ -183,25 +178,25 @@ pub use self::raw::free;\n \n fn check_os_error(err: Result) -> i32 {\n     // FIXME: not sure how to make sure all variants of Error are covered\n-    if err == Error::NotFound as _ ||\n-       err == Error::PermissionDenied as _ ||\n-       err == Error::ConnectionRefused as _ ||\n-       err == Error::ConnectionReset as _ ||\n-       err == Error::ConnectionAborted as _ ||\n-       err == Error::NotConnected as _ ||\n-       err == Error::AddrInUse as _ ||\n-       err == Error::AddrNotAvailable as _ ||\n-       err == Error::BrokenPipe as _ ||\n-       err == Error::AlreadyExists as _ ||\n-       err == Error::WouldBlock as _ ||\n-       err == Error::InvalidInput as _ ||\n-       err == Error::InvalidData as _ ||\n-       err == Error::TimedOut as _ ||\n-       err == Error::WriteZero as _ ||\n-       err == Error::Interrupted as _ ||\n-       err == Error::Other as _ ||\n-       err == Error::UnexpectedEof as _ ||\n-       ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&err)\n+    if err == Error::NotFound as _\n+        || err == Error::PermissionDenied as _\n+        || err == Error::ConnectionRefused as _\n+        || err == Error::ConnectionReset as _\n+        || err == Error::ConnectionAborted as _\n+        || err == Error::NotConnected as _\n+        || err == Error::AddrInUse as _\n+        || err == Error::AddrNotAvailable as _\n+        || err == Error::BrokenPipe as _\n+        || err == Error::AlreadyExists as _\n+        || err == Error::WouldBlock as _\n+        || err == Error::InvalidInput as _\n+        || err == Error::InvalidData as _\n+        || err == Error::TimedOut as _\n+        || err == Error::WriteZero as _\n+        || err == Error::Interrupted as _\n+        || err == Error::Other as _\n+        || err == Error::UnexpectedEof as _\n+        || ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&err)\n     {\n         err\n     } else {"}, {"sha": "e0ebf860618c8f14705e23628dc563517776f79e", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -3,8 +3,8 @@\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub use fortanix_sgx_abi::*;\n \n-use crate::ptr::NonNull;\n use crate::num::NonZeroU64;\n+use crate::ptr::NonNull;\n \n #[repr(C)]\n struct UsercallReturn(u64, u64);\n@@ -25,9 +25,14 @@ extern \"C\" {\n /// Panics if `nr` is `0`.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n #[inline]\n-pub unsafe fn do_usercall(nr: NonZeroU64, p1: u64, p2: u64, p3: u64, p4: u64, abort: bool)\n-    -> (u64, u64)\n-{\n+pub unsafe fn do_usercall(\n+    nr: NonZeroU64,\n+    p1: u64,\n+    p2: u64,\n+    p3: u64,\n+    p4: u64,\n+    abort: bool,\n+) -> (u64, u64) {\n     let UsercallReturn(a, b) = usercall(nr, p1, p2, abort as _, p3, p4);\n     (a, b)\n }\n@@ -109,11 +114,7 @@ define_ra!(<T> *mut T);\n \n impl RegisterArgument for bool {\n     fn from_register(a: Register) -> bool {\n-        if a != 0 {\n-            true\n-        } else {\n-            false\n-        }\n+        if a != 0 { true } else { false }\n     }\n     fn into_register(self) -> Register {\n         self as _\n@@ -152,16 +153,17 @@ impl<T: RegisterArgument> ReturnValue for T {\n \n impl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n     fn from_registers(_call: &'static str, regs: (Register, Register)) -> Self {\n-        (\n-            T::from_register(regs.0),\n-            U::from_register(regs.1)\n-        )\n+        (T::from_register(regs.0), U::from_register(regs.1))\n     }\n }\n \n macro_rules! return_type_is_abort {\n-    (!) => { true };\n-    ($r:ty) => { false };\n+    (!) => {\n+        true\n+    };\n+    ($r:ty) => {\n+        false\n+    };\n }\n \n // In this macro: using `$r:tt` because `$r:ty` doesn't match ! in `return_type_is_abort`"}, {"sha": "b47a48e752cb7859570aa9212583a9ad4a9077e1", "filename": "src/libstd/sys/sgx/args.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n use super::abi::usercalls::{alloc, raw::ByteBuffer};\n use crate::ffi::OsString;\n+use crate::slice;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::os_str::Buf;\n use crate::sys_common::FromInner;\n-use crate::slice;\n \n #[cfg_attr(test, linkage = \"available_externally\")]\n #[export_name = \"_ZN16__rust_internals3std3sys3sgx4args4ARGSE\"]\n@@ -14,8 +14,9 @@ type ArgsStore = Vec<OsString>;\n pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     if argc != 0 {\n         let args = alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _);\n-        let args = args.iter()\n-            .map( |a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }) )\n+        let args = args\n+            .iter()\n+            .map(|a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }))\n             .collect::<ArgsStore>();\n         ARGS.store(Box::into_raw(Box::new(args)) as _, Ordering::Relaxed);\n     }\n@@ -30,11 +31,7 @@ pub unsafe fn cleanup() {\n \n pub fn args() -> Args {\n     let args = unsafe { (ARGS.load(Ordering::Relaxed) as *const ArgsStore).as_ref() };\n-    if let Some(args) = args {\n-        Args(args.iter())\n-    } else {\n-        Args([].iter())\n-    }\n+    if let Some(args) = args { Args(args.iter()) } else { Args([].iter()) }\n }\n \n pub struct Args(slice::Iter<'static, OsString>);"}, {"sha": "b89238f1da8f7af7f3eada50e050eff26797e857", "filename": "src/libstd/sys/sgx/cmath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n #![cfg(not(test))]\n \n // These symbols are all defined in `compiler-builtins`\n-extern {\n+extern \"C\" {\n     pub fn acos(n: f64) -> f64;\n     pub fn acosf(n: f32) -> f32;\n     pub fn asin(n: f64) -> f64;"}, {"sha": "8aa84a550d2edfab8c98aefa4eb9b092ed1b2626", "filename": "src/libstd/sys/sgx/ext/io.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -4,8 +4,8 @@\n //! description of [`TryIntoRawFd`](trait.TryIntoRawFd.html) for more details.\n #![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n \n-pub use crate::sys::abi::usercalls::raw::Fd as RawFd;\n use crate::net;\n+pub use crate::sys::abi::usercalls::raw::Fd as RawFd;\n use crate::sys::{self, AsInner, FromInner, IntoInner, TryIntoInner};\n \n /// A trait to extract the raw SGX file descriptor from an underlying\n@@ -60,11 +60,15 @@ pub trait TryIntoRawFd: Sized {\n }\n \n impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().as_inner().as_inner().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().as_inner().as_inner().as_inner()\n+    }\n }\n \n impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().as_inner().as_inner().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().as_inner().as_inner().as_inner()\n+    }\n }\n \n impl FromRawFd for net::TcpStream {"}, {"sha": "258ad3cd2180ce6a1a3f63e66783be324a4e8dd2", "filename": "src/libstd/sys/sgx/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n #![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n \n pub mod arch;\n-pub mod io;\n pub mod ffi;\n+pub mod io;"}, {"sha": "7da2424a6426195437b0ef48c1a3b5dfbf5f875b", "filename": "src/libstd/sys/sgx/fd.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n use fortanix_sgx_abi::Fd;\n \n+use super::abi::usercalls;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::sys::{AsInner, FromInner, IntoInner};\n-use super::abi::usercalls;\n \n #[derive(Debug)]\n pub struct FileDesc {\n@@ -15,7 +15,9 @@ impl FileDesc {\n         FileDesc { fd: fd }\n     }\n \n-    pub fn raw(&self) -> Fd { self.fd }\n+    pub fn raw(&self) -> Fd {\n+        self.fd\n+    }\n \n     /// Extracts the actual filedescriptor without closing it.\n     pub fn into_raw(self) -> Fd {\n@@ -46,7 +48,9 @@ impl FileDesc {\n }\n \n impl AsInner<Fd> for FileDesc {\n-    fn as_inner(&self) -> &Fd { &self.fd }\n+    fn as_inner(&self) -> &Fd {\n+        &self.fd\n+    }\n }\n \n impl IntoInner<Fd> for FileDesc {"}, {"sha": "e6160d1457d269176ba95e96409b6eda799d4bb7", "filename": "src/libstd/sys/sgx/fs.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::io::{self, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sys::time::SystemTime;\n use crate::sys::{unsupported, Void};\n@@ -15,14 +15,14 @@ pub struct ReadDir(Void);\n pub struct DirEntry(Void);\n \n #[derive(Clone, Debug)]\n-pub struct OpenOptions { }\n+pub struct OpenOptions {}\n \n pub struct FilePermissions(Void);\n \n pub struct FileType(Void);\n \n #[derive(Debug)]\n-pub struct DirBuilder { }\n+pub struct DirBuilder {}\n \n impl FileAttr {\n     pub fn size(&self) -> u64 {\n@@ -78,8 +78,7 @@ impl PartialEq for FilePermissions {\n     }\n }\n \n-impl Eq for FilePermissions {\n-}\n+impl Eq for FilePermissions {}\n \n impl fmt::Debug for FilePermissions {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -115,8 +114,7 @@ impl PartialEq for FileType {\n     }\n }\n \n-impl Eq for FileType {\n-}\n+impl Eq for FileType {}\n \n impl Hash for FileType {\n     fn hash<H: Hasher>(&self, _h: &mut H) {\n@@ -164,15 +162,15 @@ impl DirEntry {\n \n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n-        OpenOptions { }\n+        OpenOptions {}\n     }\n \n-    pub fn read(&mut self, _read: bool) { }\n-    pub fn write(&mut self, _write: bool) { }\n-    pub fn append(&mut self, _append: bool) { }\n-    pub fn truncate(&mut self, _truncate: bool) { }\n-    pub fn create(&mut self, _create: bool) { }\n-    pub fn create_new(&mut self, _create_new: bool) { }\n+    pub fn read(&mut self, _read: bool) {}\n+    pub fn write(&mut self, _write: bool) {}\n+    pub fn append(&mut self, _append: bool) {}\n+    pub fn truncate(&mut self, _truncate: bool) {}\n+    pub fn create(&mut self, _create: bool) {}\n+    pub fn create_new(&mut self, _create_new: bool) {}\n }\n \n impl File {\n@@ -235,7 +233,7 @@ impl File {\n \n impl DirBuilder {\n     pub fn new() -> DirBuilder {\n-        DirBuilder { }\n+        DirBuilder {}\n     }\n \n     pub fn mkdir(&self, _p: &Path) -> io::Result<()> {"}, {"sha": "f36687b4d3d5855609fc742f4104f858435a625d", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,12 +1,12 @@\n-use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n-use crate::time::Duration;\n-use crate::sys::{unsupported, Void, sgx_ineffective, AsInner, FromInner, IntoInner, TryIntoInner};\n-use crate::sys::fd::FileDesc;\n use crate::convert::TryFrom;\n use crate::error;\n+use crate::fmt;\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sync::Arc;\n+use crate::sys::fd::FileDesc;\n+use crate::sys::{sgx_ineffective, unsupported, AsInner, FromInner, IntoInner, TryIntoInner, Void};\n+use crate::time::Duration;\n \n use super::abi::usercalls;\n \n@@ -25,13 +25,15 @@ impl Socket {\n }\n \n impl AsInner<FileDesc> for Socket {\n-    fn as_inner(&self) -> &FileDesc { &self.inner }\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.inner\n+    }\n }\n \n impl TryIntoInner<FileDesc> for Socket {\n     fn try_into_inner(self) -> Result<FileDesc, Socket> {\n         let Socket { inner, local_addr } = self;\n-        Arc::try_unwrap(inner).map_err(|inner| Socket { inner, local_addr } )\n+        Arc::try_unwrap(inner).map_err(|inner| Socket { inner, local_addr })\n     }\n }\n \n@@ -59,8 +61,7 @@ impl fmt::Debug for TcpStream {\n             res.field(\"peer\", peer);\n         }\n \n-        res.field(\"fd\", &self.inner.inner.as_inner())\n-            .finish()\n+        res.field(\"fd\", &self.inner.inner.as_inner()).finish()\n     }\n }\n \n@@ -69,10 +70,12 @@ fn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n         Ok(saddr) => Ok(saddr.to_string()),\n         // need to downcast twice because io::Error::into_inner doesn't return the original\n         // value if the conversion fails\n-        Err(e) => if e.get_ref().and_then(|e| e.downcast_ref::<NonIpSockAddr>()).is_some() {\n-            Ok(e.into_inner().unwrap().downcast::<NonIpSockAddr>().unwrap().host)\n-        } else {\n-            Err(e)\n+        Err(e) => {\n+            if e.get_ref().and_then(|e| e.downcast_ref::<NonIpSockAddr>()).is_some() {\n+                Ok(e.into_inner().unwrap().downcast::<NonIpSockAddr>().unwrap().host)\n+            } else {\n+                Err(e)\n+            }\n         }\n     }\n }\n@@ -94,29 +97,35 @@ impl TcpStream {\n \n     pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {\n         if dur == Duration::default() {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"cannot set a 0 duration timeout\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"cannot set a 0 duration timeout\",\n+            ));\n         }\n         Self::connect(Ok(addr)) // FIXME: ignoring timeout\n     }\n \n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                          \"cannot set a 0 duration timeout\"));\n+                return Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"cannot set a 0 duration timeout\",\n+                ));\n             }\n-            _ => sgx_ineffective(())\n+            _ => sgx_ineffective(()),\n         }\n     }\n \n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                          \"cannot set a 0 duration timeout\"));\n+                return Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"cannot set a 0 duration timeout\",\n+                ));\n             }\n-            _ => sgx_ineffective(())\n+            _ => sgx_ineffective(()),\n         }\n     }\n \n@@ -190,7 +199,9 @@ impl TcpStream {\n }\n \n impl AsInner<Socket> for TcpStream {\n-    fn as_inner(&self) -> &Socket { &self.inner }\n+    fn as_inner(&self) -> &Socket {\n+        &self.inner\n+    }\n }\n \n // `Inner` includes `peer_addr` so that a `TcpStream` maybe correctly\n@@ -220,8 +231,7 @@ impl fmt::Debug for TcpListener {\n             res.field(\"addr\", addr);\n         }\n \n-        res.field(\"fd\", &self.inner.inner.as_inner())\n-            .finish()\n+        res.field(\"fd\", &self.inner.inner.as_inner()).finish()\n     }\n }\n \n@@ -273,7 +283,9 @@ impl TcpListener {\n }\n \n impl AsInner<Socket> for TcpListener {\n-    fn as_inner(&self) -> &Socket { &self.inner }\n+    fn as_inner(&self) -> &Socket {\n+        &self.inner\n+    }\n }\n \n impl IntoInner<Socket> for TcpListener {\n@@ -367,23 +379,19 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n@@ -428,7 +436,7 @@ impl fmt::Debug for UdpSocket {\n \n #[derive(Debug)]\n pub struct NonIpSockAddr {\n-    host: String\n+    host: String,\n }\n \n impl error::Error for NonIpSockAddr {\n@@ -511,8 +519,7 @@ pub mod netc {\n     }\n \n     #[derive(Copy, Clone)]\n-    pub struct sockaddr {\n-    }\n+    pub struct sockaddr {}\n \n     pub type socklen_t = usize;\n }"}, {"sha": "2c5b31342199affa5300d6dc7fb35f069e798672", "filename": "src/libstd/sys/sgx/os.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,17 +1,17 @@\n use fortanix_sgx_abi::{Error, RESULT_SUCCESS};\n \n+use crate::collections::HashMap;\n use crate::error::Error as StdError;\n-use crate::ffi::{OsString, OsStr};\n+use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::path::{self, PathBuf};\n use crate::str;\n-use crate::sys::{unsupported, Void, sgx_ineffective, decode_error_kind};\n-use crate::collections::HashMap;\n-use crate::vec;\n-use crate::sync::Mutex;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::Mutex;\n use crate::sync::Once;\n+use crate::sys::{decode_error_kind, sgx_ineffective, unsupported, Void};\n+use crate::vec;\n \n pub fn errno() -> i32 {\n     RESULT_SUCCESS\n@@ -52,7 +52,9 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     Err(JoinPathsError)\n }\n@@ -89,26 +91,21 @@ fn create_env_store() -> &'static EnvStore {\n     ENV_INIT.call_once(|| {\n         ENV.store(Box::into_raw(Box::new(EnvStore::default())) as _, Ordering::Relaxed)\n     });\n-    unsafe {\n-        &*(ENV.load(Ordering::Relaxed) as *const EnvStore)\n-    }\n+    unsafe { &*(ENV.load(Ordering::Relaxed) as *const EnvStore) }\n }\n \n pub type Env = vec::IntoIter<(OsString, OsString)>;\n \n pub fn env() -> Env {\n     let clone_to_vec = |map: &HashMap<OsString, OsString>| -> Vec<_> {\n-        map.iter().map(|(k, v)| (k.clone(), v.clone()) ).collect()\n+        map.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n     };\n \n-    get_env_store()\n-        .map(|env| clone_to_vec(&env.lock().unwrap()) )\n-        .unwrap_or_default()\n-        .into_iter()\n+    get_env_store().map(|env| clone_to_vec(&env.lock().unwrap())).unwrap_or_default().into_iter()\n }\n \n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    Ok(get_env_store().and_then(|s| s.lock().unwrap().get(k).cloned() ))\n+    Ok(get_env_store().and_then(|s| s.lock().unwrap().get(k).cloned()))\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {"}, {"sha": "06c9df3ff5427afd68fe1fb4f9d56fab7dc98d37", "filename": "src/libstd/sys/sgx/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/sgx/process.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -32,32 +32,28 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default()\n-        }\n+        Command { env: Default::default() }\n     }\n \n-    pub fn arg(&mut self, _arg: &OsStr) {\n-    }\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n \n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n-    pub fn cwd(&mut self, _dir: &OsStr) {\n-    }\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n \n-    pub fn stdin(&mut self, _stdin: Stdio) {\n-    }\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n \n-    pub fn stdout(&mut self, _stdout: Stdio) {\n-    }\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n \n-    pub fn stderr(&mut self, _stderr: Stdio) {\n-    }\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n \n-    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n-        -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         unsupported()\n     }\n }\n@@ -106,8 +102,7 @@ impl PartialEq for ExitStatus {\n     }\n }\n \n-impl Eq for ExitStatus {\n-}\n+impl Eq for ExitStatus {}\n \n impl fmt::Debug for ExitStatus {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "a2d13d11849e790a2addf31f5b62a00ebaebb967", "filename": "src/libstd/sys/sgx/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -7,8 +7,6 @@ impl Handler {\n }\n \n #[cfg_attr(test, allow(dead_code))]\n-pub unsafe fn init() {\n-}\n+pub unsafe fn init() {}\n \n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}"}, {"sha": "716c174bd53b65a165231e2c1959603384b2a4d2", "filename": "src/libstd/sys/sgx/stdio.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,11 +1,11 @@\n use fortanix_sgx_abi as abi;\n \n use crate::io;\n-use crate::sys::fd::FileDesc;\n #[cfg(not(test))]\n use crate::slice;\n #[cfg(not(test))]\n use crate::str;\n+use crate::sys::fd::FileDesc;\n \n pub struct Stdin(());\n pub struct Stdout(());\n@@ -19,7 +19,9 @@ fn with_std_fd<F: FnOnce(&FileDesc) -> R, R>(fd: abi::Fd, f: F) -> R {\n }\n \n impl Stdin {\n-    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin(()))\n+    }\n }\n \n impl io::Read for Stdin {\n@@ -29,7 +31,9 @@ impl io::Read for Stdin {\n }\n \n impl Stdout {\n-    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout(()))\n+    }\n }\n \n impl io::Write for Stdout {\n@@ -43,7 +47,9 @@ impl io::Write for Stdout {\n }\n \n impl Stderr {\n-    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr(()))\n+    }\n }\n \n impl io::Write for Stderr {"}, {"sha": "9b515eb82de350bd5bc468d4cf626d8f0ca10c6b", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -10,8 +10,8 @@ pub struct Thread(task_queue::JoinHandle);\n pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n \n mod task_queue {\n-    use crate::sync::{Mutex, MutexGuard, Once};\n     use crate::sync::mpsc;\n+    use crate::sync::{Mutex, MutexGuard, Once};\n \n     pub type JoinHandle = mpsc::Receiver<()>;\n \n@@ -41,17 +41,15 @@ mod task_queue {\n \n     pub(super) fn lock() -> MutexGuard<'static, Vec<Task>> {\n         unsafe {\n-            TASK_QUEUE_INIT.call_once(|| TASK_QUEUE = Some(Default::default()) );\n+            TASK_QUEUE_INIT.call_once(|| TASK_QUEUE = Some(Default::default()));\n             TASK_QUEUE.as_ref().unwrap().lock().unwrap()\n         }\n     }\n }\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(_stack: usize, p: Box<dyn FnOnce()>)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new(_stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         let mut queue_lock = task_queue::lock();\n         usercalls::launch_thread()?;\n         let (task, handle) = task_queue::Task::new(p);\n@@ -86,6 +84,10 @@ impl Thread {\n \n pub mod guard {\n     pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }"}, {"sha": "b21784475f0d2d020aa4f0eb14cff31d0b1f558c", "filename": "src/libstd/sys/sgx/thread_local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n-use super::abi::tls::{Tls, Key as AbiKey};\n+use super::abi::tls::{Key as AbiKey, Tls};\n \n pub type Key = usize;\n \n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     Tls::create(dtor).as_usize()\n }\n "}, {"sha": "e2f6e6dba695d3f80c4dfd8b86c6596c0299b3ff", "filename": "src/libstd/sys/sgx/time.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::time::Duration;\n use super::abi::usercalls;\n+use crate::time::Duration;\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -40,8 +40,7 @@ impl SystemTime {\n         SystemTime(usercalls::insecure_time())\n     }\n \n-    pub fn sub_time(&self, other: &SystemTime)\n-                    -> Result<Duration, Duration> {\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n         self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n     }\n "}, {"sha": "77417e41331273182742069d918b7ce138cab182", "filename": "src/libstd/sys/unix/alloc.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Falloc.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,6 +1,6 @@\n-use crate::ptr;\n-use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ptr;\n+use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n unsafe impl GlobalAlloc for System {\n@@ -16,7 +16,7 @@ unsafe impl GlobalAlloc for System {\n             #[cfg(target_os = \"macos\")]\n             {\n                 if layout.align() > (1 << 31) {\n-                    return ptr::null_mut()\n+                    return ptr::null_mut();\n                 }\n             }\n             aligned_malloc(&layout)\n@@ -52,9 +52,7 @@ unsafe impl GlobalAlloc for System {\n     }\n }\n \n-#[cfg(any(target_os = \"android\",\n-          target_os = \"redox\",\n-          target_os = \"solaris\"))]\n+#[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n #[inline]\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     // On android we currently target API level 9 which unfortunately\n@@ -77,19 +75,13 @@ unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     libc::memalign(layout.align(), layout.size()) as *mut u8\n }\n \n-#[cfg(not(any(target_os = \"android\",\n-              target_os = \"redox\",\n-              target_os = \"solaris\")))]\n+#[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n #[inline]\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     let mut out = ptr::null_mut();\n     // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n     // Since these are all powers of 2, we can just use max.\n     let align = layout.align().max(crate::mem::size_of::<usize>());\n     let ret = libc::posix_memalign(&mut out, align, layout.size());\n-    if ret != 0 {\n-        ptr::null_mut()\n-    } else {\n-        out as *mut u8\n-    }\n+    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n }"}, {"sha": "c5e9d66e85ef9dd0e59c0898db6fccba1d19499d", "filename": "src/libstd/sys/unix/android.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -21,8 +21,8 @@\n use libc::{c_int, c_void, sighandler_t, size_t, ssize_t};\n use libc::{ftruncate, pread, pwrite};\n \n-use crate::io;\n use super::{cvt, cvt_r};\n+use crate::io;\n \n // The `log2` and `log2f` functions apparently appeared in android-18, or at\n // least you can see they're not present in the android-17 header [1] and they\n@@ -96,8 +96,7 @@ pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n             Some(f) => cvt_r(|| f(fd, size as i64)).map(|_| ()),\n             None => {\n                 if size > i32::max_value() as u64 {\n-                    Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                       \"cannot truncate >2GB\"))\n+                    Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot truncate >2GB\"))\n                 } else {\n                     cvt_r(|| ftruncate(fd, size as i32)).map(|_| ())\n                 }\n@@ -108,53 +107,61 @@ pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n \n #[cfg(target_pointer_width = \"64\")]\n pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n-    unsafe {\n-        cvt_r(|| ftruncate(fd, size as i64)).map(|_| ())\n-    }\n+    unsafe { cvt_r(|| ftruncate(fd, size as i64)).map(|_| ()) }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n+pub unsafe fn cvt_pread64(\n+    fd: c_int,\n+    buf: *mut c_void,\n+    count: size_t,\n+    offset: i64,\n+) -> io::Result<ssize_t> {\n     use crate::convert::TryInto;\n     weak!(fn pread64(c_int, *mut c_void, size_t, i64) -> ssize_t);\n     pread64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n         if let Ok(o) = offset.try_into() {\n             cvt(pread(fd, buf, count, o))\n         } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                               \"cannot pread >2GB\"))\n+            Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot pread >2GB\"))\n         }\n     })\n }\n \n #[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n+pub unsafe fn cvt_pwrite64(\n+    fd: c_int,\n+    buf: *const c_void,\n+    count: size_t,\n+    offset: i64,\n+) -> io::Result<ssize_t> {\n     use crate::convert::TryInto;\n     weak!(fn pwrite64(c_int, *const c_void, size_t, i64) -> ssize_t);\n     pwrite64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n         if let Ok(o) = offset.try_into() {\n             cvt(pwrite(fd, buf, count, o))\n         } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                               \"cannot pwrite >2GB\"))\n+            Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot pwrite >2GB\"))\n         }\n     })\n }\n \n #[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n+pub unsafe fn cvt_pread64(\n+    fd: c_int,\n+    buf: *mut c_void,\n+    count: size_t,\n+    offset: i64,\n+) -> io::Result<ssize_t> {\n     cvt(pread(fd, buf, count, offset))\n }\n \n #[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n+pub unsafe fn cvt_pwrite64(\n+    fd: c_int,\n+    buf: *const c_void,\n+    count: size_t,\n+    offset: i64,\n+) -> io::Result<ssize_t> {\n     cvt(pwrite(fd, buf, count, offset))\n }"}, {"sha": "2916ebe4440593d2e1c9b4144f5b83da0ae8a28c", "filename": "src/libstd/sys/unix/cmath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcmath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n #![cfg(not(test))]\n \n-use libc::{c_float, c_double};\n+use libc::{c_double, c_float};\n \n #[link_name = \"m\"]\n-extern {\n+extern \"C\" {\n     pub fn acos(n: c_double) -> c_double;\n     pub fn acosf(n: c_float) -> c_float;\n     pub fn asin(n: c_double) -> c_double;"}, {"sha": "732cd677a18594f495f651c13f6b5ec7688ab476", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 77, "deletions": 31, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -2,12 +2,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::fs::{self, Permissions, OpenOptions};\n+use crate::fs::{self, OpenOptions, Permissions};\n use crate::io;\n use crate::path::Path;\n use crate::sys;\n-use crate::sys_common::{FromInner, AsInner, AsInnerMut};\n use crate::sys::platform::fs::MetadataExt as UnixMetadataExt;\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n \n /// Unix-specific extensions to [`File`].\n ///\n@@ -112,8 +112,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new(io::ErrorKind::UnexpectedEof,\n-                               \"failed to fill whole buffer\"))\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -195,8 +194,12 @@ pub trait FileExt {\n     fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n-                Ok(0) => return Err(io::Error::new(io::ErrorKind::WriteZero,\n-                                                   \"failed to write whole buffer\")),\n+                Ok(0) => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::WriteZero,\n+                        \"failed to write whole buffer\",\n+                    ));\n+                }\n                 Ok(n) => {\n                     buf = &buf[n..];\n                     offset += n as u64\n@@ -356,11 +359,13 @@ pub trait OpenOptionsExt {\n #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n impl OpenOptionsExt for OpenOptions {\n     fn mode(&mut self, mode: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().mode(mode); self\n+        self.as_inner_mut().mode(mode);\n+        self\n     }\n \n     fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n-        self.as_inner_mut().custom_flags(flags); self\n+        self.as_inner_mut().custom_flags(flags);\n+        self\n     }\n }\n \n@@ -657,22 +662,54 @@ pub trait MetadataExt {\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n impl MetadataExt for fs::Metadata {\n-    fn dev(&self) -> u64 { self.st_dev() }\n-    fn ino(&self) -> u64 { self.st_ino() }\n-    fn mode(&self) -> u32 { self.st_mode() }\n-    fn nlink(&self) -> u64 { self.st_nlink() }\n-    fn uid(&self) -> u32 { self.st_uid() }\n-    fn gid(&self) -> u32 { self.st_gid() }\n-    fn rdev(&self) -> u64 { self.st_rdev() }\n-    fn size(&self) -> u64 { self.st_size() }\n-    fn atime(&self) -> i64 { self.st_atime() }\n-    fn atime_nsec(&self) -> i64 { self.st_atime_nsec() }\n-    fn mtime(&self) -> i64 { self.st_mtime() }\n-    fn mtime_nsec(&self) -> i64 { self.st_mtime_nsec() }\n-    fn ctime(&self) -> i64 { self.st_ctime() }\n-    fn ctime_nsec(&self) -> i64 { self.st_ctime_nsec() }\n-    fn blksize(&self) -> u64 { self.st_blksize() }\n-    fn blocks(&self) -> u64 { self.st_blocks() }\n+    fn dev(&self) -> u64 {\n+        self.st_dev()\n+    }\n+    fn ino(&self) -> u64 {\n+        self.st_ino()\n+    }\n+    fn mode(&self) -> u32 {\n+        self.st_mode()\n+    }\n+    fn nlink(&self) -> u64 {\n+        self.st_nlink()\n+    }\n+    fn uid(&self) -> u32 {\n+        self.st_uid()\n+    }\n+    fn gid(&self) -> u32 {\n+        self.st_gid()\n+    }\n+    fn rdev(&self) -> u64 {\n+        self.st_rdev()\n+    }\n+    fn size(&self) -> u64 {\n+        self.st_size()\n+    }\n+    fn atime(&self) -> i64 {\n+        self.st_atime()\n+    }\n+    fn atime_nsec(&self) -> i64 {\n+        self.st_atime_nsec()\n+    }\n+    fn mtime(&self) -> i64 {\n+        self.st_mtime()\n+    }\n+    fn mtime_nsec(&self) -> i64 {\n+        self.st_mtime_nsec()\n+    }\n+    fn ctime(&self) -> i64 {\n+        self.st_ctime()\n+    }\n+    fn ctime_nsec(&self) -> i64 {\n+        self.st_ctime_nsec()\n+    }\n+    fn blksize(&self) -> u64 {\n+        self.st_blksize()\n+    }\n+    fn blocks(&self) -> u64 {\n+        self.st_blocks()\n+    }\n }\n \n /// Unix-specific extensions for [`FileType`].\n@@ -759,10 +796,18 @@ pub trait FileTypeExt {\n \n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n impl FileTypeExt for fs::FileType {\n-    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }\n-    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }\n-    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }\n-    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }\n+    fn is_block_device(&self) -> bool {\n+        self.as_inner().is(libc::S_IFBLK)\n+    }\n+    fn is_char_device(&self) -> bool {\n+        self.as_inner().is(libc::S_IFCHR)\n+    }\n+    fn is_fifo(&self) -> bool {\n+        self.as_inner().is(libc::S_IFIFO)\n+    }\n+    fn is_socket(&self) -> bool {\n+        self.as_inner().is(libc::S_IFSOCK)\n+    }\n }\n \n /// Unix-specific extension methods for [`fs::DirEntry`].\n@@ -794,7 +839,9 @@ pub trait DirEntryExt {\n \n #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n impl DirEntryExt for fs::DirEntry {\n-    fn ino(&self) -> u64 { self.as_inner().ino() }\n+    fn ino(&self) -> u64 {\n+        self.as_inner().ino()\n+    }\n }\n \n /// Creates a new symbolic link on the filesystem.\n@@ -821,8 +868,7 @@ impl DirEntryExt for fs::DirEntry {\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n-{\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     sys::fs::symlink(src.as_ref(), dst.as_ref())\n }\n "}, {"sha": "5077e2e28d18b7ccb4ec96f3851119fd4abf8c69", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -3,9 +3,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fs;\n+use crate::io;\n use crate::os::raw;\n use crate::sys;\n-use crate::io;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// Raw file descriptors.\n@@ -83,30 +83,42 @@ impl IntoRawFd for fs::File {\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdin {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdout {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stderr {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StdinLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StdoutLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StderrLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO\n+    }\n }"}, {"sha": "fa8670b4aecac0caa0c06b0da07f2989385b4322", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -4,10 +4,10 @@\n \n use crate::ffi::OsStr;\n use crate::io;\n-use crate::os::unix::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n use crate::process;\n use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n /// Unix-specific extensions to the [`process::Command`] builder.\n ///\n@@ -56,7 +56,8 @@ pub trait CommandExt {\n     /// locations may not appear where intended.\n     #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n     unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n \n     /// Schedules a closure to be run just before the `exec` function is\n     /// invoked.\n@@ -68,7 +69,8 @@ pub trait CommandExt {\n     #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n     #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n     fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n     {\n         unsafe { self.pre_exec(f) }\n     }\n@@ -111,7 +113,8 @@ pub trait CommandExt {\n     /// default executable path.\n     #[unstable(feature = \"process_set_argv0\", issue = \"66510\")]\n     fn arg0<S>(&mut self, arg: S) -> &mut process::Command\n-        where S: AsRef<OsStr>;\n+    where\n+        S: AsRef<OsStr>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -127,7 +130,8 @@ impl CommandExt for process::Command {\n     }\n \n     unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n     {\n         self.as_inner_mut().pre_exec(Box::new(f));\n         self\n@@ -138,7 +142,8 @@ impl CommandExt for process::Command {\n     }\n \n     fn arg0<S>(&mut self, arg: S) -> &mut process::Command\n-        where S: AsRef<OsStr>\n+    where\n+        S: AsRef<OsStr>,\n     {\n         self.as_inner_mut().set_arg_0(arg.as_ref());\n         self"}, {"sha": "d81368a18b4522018bfdfcaff7c5d4c504eea4bc", "filename": "src/libstd/sys/unix/ext/raw.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,23 +1,28 @@\n //! Unix-specific primitives available on all unix platforms\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type uid_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type gid_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type pid_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type uid_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type gid_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type pid_t = i32;\n \n #[doc(inline)]\n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub use crate::sys::platform::raw::pthread_t;\n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use crate::sys::platform::raw::{dev_t, ino_t, mode_t, nlink_t, off_t, blksize_t};\n+pub use crate::sys::platform::raw::{blkcnt_t, time_t};\n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use crate::sys::platform::raw::{blkcnt_t, time_t};\n+pub use crate::sys::platform::raw::{blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t};"}, {"sha": "dfb9307daea9fafd363acda4e8e15b0a9ca183e2", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -10,25 +10,34 @@\n // fallback implementation to use as well.\n //\n // Due to rust-lang/rust#18804, make sure this is not generic!\n-#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"redox\",\n-          target_os = \"emscripten\"))]\n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+#[cfg(any(\n+    target_os = \"linux\",\n+    target_os = \"fuchsia\",\n+    target_os = \"redox\",\n+    target_os = \"emscripten\"\n+))]\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::mem;\n     use crate::sys_common::thread_local::register_dtor_fallback;\n \n-    extern {\n+    extern \"C\" {\n         #[linkage = \"extern_weak\"]\n         static __dso_handle: *mut u8;\n         #[linkage = \"extern_weak\"]\n         static __cxa_thread_atexit_impl: *const libc::c_void;\n     }\n     if !__cxa_thread_atexit_impl.is_null() {\n-        type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n-                                  arg: *mut u8,\n-                                  dso_handle: *mut u8) -> libc::c_int;\n-        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n-            (dtor, t, &__dso_handle as *const _ as *mut _);\n-        return\n+        type F = unsafe extern \"C\" fn(\n+            dtor: unsafe extern \"C\" fn(*mut u8),\n+            arg: *mut u8,\n+            dso_handle: *mut u8,\n+        ) -> libc::c_int;\n+        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)(\n+            dtor,\n+            t,\n+            &__dso_handle as *const _ as *mut _,\n+        );\n+        return;\n     }\n     register_dtor_fallback(t, dtor);\n }\n@@ -44,7 +53,7 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n // thread. thread_local dtors are pushed to the DTOR list without calling\n // _tlv_atexit.\n #[cfg(target_os = \"macos\")]\n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::cell::Cell;\n     use crate::ptr;\n \n@@ -55,7 +64,7 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         REGISTERED.set(true);\n     }\n \n-    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+    type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n \n     #[thread_local]\n     static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n@@ -64,15 +73,14 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         DTORS.set(Box::into_raw(v));\n     }\n \n-    extern {\n-        fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n-                       arg: *mut u8);\n+    extern \"C\" {\n+        fn _tlv_atexit(dtor: unsafe extern \"C\" fn(*mut u8), arg: *mut u8);\n     }\n \n     let list: &mut List = &mut *DTORS.get();\n     list.push((t, dtor));\n \n-    unsafe extern fn run_dtors(_: *mut u8) {\n+    unsafe extern \"C\" fn run_dtors(_: *mut u8) {\n         let mut ptr = DTORS.replace(ptr::null_mut());\n         while !ptr.is_null() {\n             let list = Box::from_raw(ptr);"}, {"sha": "53b50763fbf2ec2f4999f481829b101348a4c910", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 73, "deletions": 58, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n use crate::cmp;\n-use crate::io::{self, Read, Initializer, IoSlice, IoSliceMut};\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::cvt;\n@@ -35,7 +35,9 @@ impl FileDesc {\n         FileDesc { fd }\n     }\n \n-    pub fn raw(&self) -> c_int { self.fd }\n+    pub fn raw(&self) -> c_int {\n+        self.fd\n+    }\n \n     /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> c_int {\n@@ -46,18 +48,18 @@ impl FileDesc {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::read(self.fd,\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       cmp::min(buf.len(), max_len()))\n+            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::readv(self.fd,\n-                        bufs.as_ptr() as *const libc::iovec,\n-                        cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+            libc::readv(\n+                self.fd,\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -72,39 +74,44 @@ impl FileDesc {\n         use super::android::cvt_pread64;\n \n         #[cfg(not(target_os = \"android\"))]\n-        unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n-            #[cfg(target_os = \"linux\")]\n-            use libc::pread64;\n+        unsafe fn cvt_pread64(\n+            fd: c_int,\n+            buf: *mut c_void,\n+            count: usize,\n+            offset: i64,\n+        ) -> io::Result<isize> {\n             #[cfg(not(target_os = \"linux\"))]\n             use libc::pread as pread64;\n+            #[cfg(target_os = \"linux\")]\n+            use libc::pread64;\n             cvt(pread64(fd, buf, count, offset))\n         }\n \n         unsafe {\n-            cvt_pread64(self.fd,\n-                        buf.as_mut_ptr() as *mut c_void,\n-                        cmp::min(buf.len(), max_len()),\n-                        offset as i64)\n-                .map(|n| n as usize)\n+            cvt_pread64(\n+                self.fd,\n+                buf.as_mut_ptr() as *mut c_void,\n+                cmp::min(buf.len(), max_len()),\n+                offset as i64,\n+            )\n+            .map(|n| n as usize)\n         }\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::write(self.fd,\n-                        buf.as_ptr() as *const c_void,\n-                        cmp::min(buf.len(), max_len()))\n+            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::writev(self.fd,\n-                         bufs.as_ptr() as *const libc::iovec,\n-                         cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+            libc::writev(\n+                self.fd,\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -114,54 +121,61 @@ impl FileDesc {\n         use super::android::cvt_pwrite64;\n \n         #[cfg(not(target_os = \"android\"))]\n-        unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n-            #[cfg(target_os = \"linux\")]\n-            use libc::pwrite64;\n+        unsafe fn cvt_pwrite64(\n+            fd: c_int,\n+            buf: *const c_void,\n+            count: usize,\n+            offset: i64,\n+        ) -> io::Result<isize> {\n             #[cfg(not(target_os = \"linux\"))]\n             use libc::pwrite as pwrite64;\n+            #[cfg(target_os = \"linux\")]\n+            use libc::pwrite64;\n             cvt(pwrite64(fd, buf, count, offset))\n         }\n \n         unsafe {\n-            cvt_pwrite64(self.fd,\n-                         buf.as_ptr() as *const c_void,\n-                         cmp::min(buf.len(), max_len()),\n-                         offset as i64)\n-                .map(|n| n as usize)\n+            cvt_pwrite64(\n+                self.fd,\n+                buf.as_ptr() as *const c_void,\n+                cmp::min(buf.len(), max_len()),\n+                offset as i64,\n+            )\n+            .map(|n| n as usize)\n         }\n     }\n \n     #[cfg(target_os = \"linux\")]\n     pub fn get_cloexec(&self) -> io::Result<bool> {\n-        unsafe {\n-            Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0)\n-        }\n+        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n     }\n \n-    #[cfg(not(any(target_env = \"newlib\",\n-                  target_os = \"solaris\",\n-                  target_os = \"emscripten\",\n-                  target_os = \"fuchsia\",\n-                  target_os = \"l4re\",\n-                  target_os = \"linux\",\n-                  target_os = \"haiku\",\n-                  target_os = \"redox\")))]\n+    #[cfg(not(any(\n+        target_env = \"newlib\",\n+        target_os = \"solaris\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"l4re\",\n+        target_os = \"linux\",\n+        target_os = \"haiku\",\n+        target_os = \"redox\"\n+    )))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             cvt(libc::ioctl(self.fd, libc::FIOCLEX))?;\n             Ok(())\n         }\n     }\n-    #[cfg(any(target_env = \"newlib\",\n-              target_os = \"solaris\",\n-              target_os = \"emscripten\",\n-              target_os = \"fuchsia\",\n-              target_os = \"l4re\",\n-              target_os = \"linux\",\n-              target_os = \"haiku\",\n-              target_os = \"redox\"))]\n+    #[cfg(any(\n+        target_env = \"newlib\",\n+        target_os = \"solaris\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"l4re\",\n+        target_os = \"linux\",\n+        target_os = \"haiku\",\n+        target_os = \"redox\"\n+    ))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n@@ -216,16 +230,15 @@ impl FileDesc {\n         // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n         #[cfg(any(target_os = \"android\", target_os = \"haiku\"))]\n         use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n-        #[cfg(not(any(target_os = \"android\", target_os=\"haiku\")))]\n+        #[cfg(not(any(target_os = \"android\", target_os = \"haiku\")))]\n         use libc::F_DUPFD_CLOEXEC;\n \n         let make_filedesc = |fd| {\n             let fd = FileDesc::new(fd);\n             fd.set_cloexec()?;\n             Ok(fd)\n         };\n-        static TRY_CLOEXEC: AtomicBool =\n-            AtomicBool::new(!cfg!(target_os = \"android\"));\n+        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(!cfg!(target_os = \"android\"));\n         let fd = self.raw();\n         if TRY_CLOEXEC.load(Ordering::Relaxed) {\n             match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n@@ -237,7 +250,7 @@ impl FileDesc {\n                         make_filedesc(fd)?\n                     } else {\n                         FileDesc::new(fd)\n-                    })\n+                    });\n                 }\n                 Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n                     TRY_CLOEXEC.store(false, Ordering::Relaxed);\n@@ -261,7 +274,9 @@ impl<'a> Read for &'a FileDesc {\n }\n \n impl AsInner<c_int> for FileDesc {\n-    fn as_inner(&self) -> &c_int { &self.fd }\n+    fn as_inner(&self) -> &c_int {\n+        &self.fd\n+    }\n }\n \n impl Drop for FileDesc {"}, {"sha": "b4a64e93c842b606d31fc978bf4698cda8b39d6b", "filename": "src/libstd/sys/unix/io.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n use crate::marker::PhantomData;\n use crate::slice;\n \n-use libc::{iovec, c_void};\n+use libc::{c_void, iovec};\n \n #[repr(transparent)]\n pub struct IoSlice<'a> {\n@@ -13,10 +13,7 @@ impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice {\n-            vec: iovec {\n-                iov_base: buf.as_ptr() as *mut u8 as *mut c_void,\n-                iov_len: buf.len()\n-            },\n+            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n             _p: PhantomData,\n         }\n     }\n@@ -35,9 +32,7 @@ impl<'a> IoSlice<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }\n \n@@ -51,10 +46,7 @@ impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut {\n-            vec: iovec {\n-                iov_base: buf.as_mut_ptr() as *mut c_void,\n-                iov_len: buf.len()\n-            },\n+            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n             _p: PhantomData,\n         }\n     }\n@@ -73,15 +65,11 @@ impl<'a> IoSliceMut<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n \n     #[inline]\n     pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }"}, {"sha": "c6e4f5693ed5af4ac48eaec26ed367b46debd76c", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,16 +1,18 @@\n macro_rules! unimpl {\n-    () => (return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));)\n+    () => {\n+        return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));\n+    };\n }\n \n pub mod net {\n     #![allow(warnings)]\n+    use crate::convert::TryFrom;\n     use crate::fmt;\n     use crate::io::{self, IoSlice, IoSliceMut};\n-    use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n-    use crate::sys_common::{AsInner, FromInner, IntoInner};\n+    use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n     use crate::sys::fd::FileDesc;\n+    use crate::sys_common::{AsInner, FromInner, IntoInner};\n     use crate::time::Duration;\n-    use crate::convert::TryFrom;\n \n     #[allow(unused_extern_crates)]\n     pub extern crate libc as netc;\n@@ -33,8 +35,11 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn accept(&self, _: *mut libc::sockaddr, _: *mut libc::socklen_t)\n-                  -> io::Result<Socket> {\n+        pub fn accept(\n+            &self,\n+            _: *mut libc::sockaddr,\n+            _: *mut libc::socklen_t,\n+        ) -> io::Result<Socket> {\n             unimpl!();\n         }\n \n@@ -100,15 +105,21 @@ pub mod net {\n     }\n \n     impl AsInner<libc::c_int> for Socket {\n-        fn as_inner(&self) -> &libc::c_int { self.0.as_inner() }\n+        fn as_inner(&self) -> &libc::c_int {\n+            self.0.as_inner()\n+        }\n     }\n \n     impl FromInner<libc::c_int> for Socket {\n-        fn from_inner(fd: libc::c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+        fn from_inner(fd: libc::c_int) -> Socket {\n+            Socket(FileDesc::new(fd))\n+        }\n     }\n \n     impl IntoInner<libc::c_int> for Socket {\n-        fn into_inner(self) -> libc::c_int { self.0.into_raw() }\n+        fn into_inner(self) -> libc::c_int {\n+            self.0.into_raw()\n+        }\n     }\n \n     pub struct TcpStream {\n@@ -124,9 +135,13 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn socket(&self) -> &Socket { &self.inner }\n+        pub fn socket(&self) -> &Socket {\n+            &self.inner\n+        }\n \n-        pub fn into_socket(self) -> Socket { self.inner }\n+        pub fn into_socket(self) -> Socket {\n+            self.inner\n+        }\n \n         pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n             unimpl!();\n@@ -226,9 +241,13 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn socket(&self) -> &Socket { &self.inner }\n+        pub fn socket(&self) -> &Socket {\n+            &self.inner\n+        }\n \n-        pub fn into_socket(self) -> Socket { self.inner }\n+        pub fn into_socket(self) -> Socket {\n+            self.inner\n+        }\n \n         pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n             unimpl!();\n@@ -288,9 +307,13 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn socket(&self) -> &Socket { &self.inner }\n+        pub fn socket(&self) -> &Socket {\n+            &self.inner\n+        }\n \n-        pub fn into_socket(self) -> Socket { self.inner }\n+        pub fn into_socket(self) -> Socket {\n+            self.inner\n+        }\n \n         pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n             unimpl!();\n@@ -364,24 +387,20 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                             -> io::Result<()> {\n-                                 unimpl!();\n+        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n+            unimpl!();\n         }\n \n-        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                             -> io::Result<()> {\n-                                 unimpl!();\n+        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n+            unimpl!();\n         }\n \n-        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                              -> io::Result<()> {\n-                                  unimpl!();\n+        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n+            unimpl!();\n         }\n \n-        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                              -> io::Result<()> {\n-                                  unimpl!();\n+        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n+            unimpl!();\n         }\n \n         pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n@@ -450,7 +469,6 @@ pub mod net {\n     unsafe impl Sync for LookupHost {}\n     unsafe impl Send for LookupHost {}\n \n-\n     impl TryFrom<&str> for LookupHost {\n         type Error = io::Error;\n "}, {"sha": "a9273ea676cb3949012c4c4cc987ae5dbc0ea7f4", "filename": "src/libstd/sys/unix/memchr.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -6,32 +6,27 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n         libc::memchr(\n             haystack.as_ptr() as *const libc::c_void,\n             needle as libc::c_int,\n-            haystack.len())\n+            haystack.len(),\n+        )\n     };\n-    if p.is_null() {\n-        None\n-    } else {\n-        Some(p as usize - (haystack.as_ptr() as usize))\n-    }\n+    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n }\n \n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-\n     #[cfg(target_os = \"linux\")]\n     fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n         // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n-        if haystack.is_empty() {return None}\n+        if haystack.is_empty() {\n+            return None;\n+        }\n         let p = unsafe {\n             libc::memrchr(\n                 haystack.as_ptr() as *const libc::c_void,\n                 needle as libc::c_int,\n-                haystack.len())\n+                haystack.len(),\n+            )\n         };\n-        if p.is_null() {\n-            None\n-        } else {\n-            Some(p as usize - (haystack.as_ptr() as usize))\n-        }\n+        if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n     }\n \n     #[cfg(not(target_os = \"linux\"))]"}, {"sha": "946b2b9d8decfa1ccc04c57738b7c5756242112e", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 53, "deletions": 59, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,13 +1,13 @@\n+use crate::cmp;\n use crate::ffi::CStr;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n-use crate::net::{SocketAddr, Shutdown};\n+use crate::net::{Shutdown, SocketAddr};\n use crate::str;\n use crate::sys::fd::FileDesc;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::{Duration, Instant};\n-use crate::cmp;\n \n use libc::{c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n \n@@ -42,23 +42,23 @@ pub fn init() {}\n \n pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 {\n-        return Ok(())\n+        return Ok(());\n     }\n \n     // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n     on_resolver_failure();\n \n     if err == EAI_SYSTEM {\n-        return Err(io::Error::last_os_error())\n+        return Err(io::Error::last_os_error());\n     }\n \n     let detail = unsafe {\n-        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap()\n-            .to_owned()\n+        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n     };\n-    Err(io::Error::new(io::ErrorKind::Other,\n-                       &format!(\"failed to lookup address information: {}\",\n-                                detail)[..]))\n+    Err(io::Error::new(\n+        io::ErrorKind::Other,\n+        &format!(\"failed to lookup address information: {}\", detail)[..],\n+    ))\n }\n \n impl Socket {\n@@ -106,7 +106,7 @@ impl Socket {\n                     Ok(_) => {\n                         return Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))));\n                     }\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {},\n+                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n                     Err(e) => return Err(e),\n                 }\n             }\n@@ -135,15 +135,13 @@ impl Socket {\n             Err(e) => return Err(e),\n         }\n \n-        let mut pollfd = libc::pollfd {\n-            fd: self.0.raw(),\n-            events: libc::POLLOUT,\n-            revents: 0,\n-        };\n+        let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"cannot set a 0 duration timeout\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"cannot set a 0 duration timeout\",\n+            ));\n         }\n \n         let start = Instant::now();\n@@ -155,7 +153,8 @@ impl Socket {\n             }\n \n             let timeout = timeout - elapsed;\n-            let mut timeout = timeout.as_secs()\n+            let mut timeout = timeout\n+                .as_secs()\n                 .saturating_mul(1_000)\n                 .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n             if timeout == 0 {\n@@ -176,10 +175,9 @@ impl Socket {\n                     // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n                     // for POLLHUP rather than read readiness\n                     if pollfd.revents & libc::POLLHUP != 0 {\n-                        let e = self.take_error()?\n-                            .unwrap_or_else(|| {\n-                                io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n-                            });\n+                        let e = self.take_error()?.unwrap_or_else(|| {\n+                            io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n+                        });\n                         return Err(e);\n                     }\n \n@@ -189,8 +187,7 @@ impl Socket {\n         }\n     }\n \n-    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n-                  -> io::Result<Socket> {\n+    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n         // Unfortunately the only known way right now to accept a socket and\n         // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n         // Linux. This was added in 2.6.28, however, and because we support\n@@ -204,19 +201,15 @@ impl Socket {\n                     flags: c_int\n                 ) -> c_int\n             }\n-            let res = cvt_r(|| unsafe {\n-                accept4(self.0.raw(), storage, len, SOCK_CLOEXEC)\n-            });\n+            let res = cvt_r(|| unsafe { accept4(self.0.raw(), storage, len, SOCK_CLOEXEC) });\n             match res {\n                 Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n                 Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}\n                 Err(e) => return Err(e),\n             }\n         }\n \n-        let fd = cvt_r(|| unsafe {\n-            libc::accept(self.0.raw(), storage, len)\n-        })?;\n+        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n         let fd = FileDesc::new(fd);\n         fd.set_cloexec()?;\n         Ok(Socket(fd))\n@@ -228,10 +221,7 @@ impl Socket {\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::recv(self.0.raw(),\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       buf.len(),\n-                       flags)\n+            libc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n         })?;\n         Ok(ret as usize)\n     }\n@@ -248,18 +238,23 @@ impl Socket {\n         self.0.read_vectored(bufs)\n     }\n \n-    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n-                            -> io::Result<(usize, SocketAddr)> {\n+    fn recv_from_with_flags(\n+        &self,\n+        buf: &mut [u8],\n+        flags: c_int,\n+    ) -> io::Result<(usize, SocketAddr)> {\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n \n         let n = cvt(unsafe {\n-            libc::recvfrom(self.0.raw(),\n-                        buf.as_mut_ptr() as *mut c_void,\n-                        buf.len(),\n-                        flags,\n-                        &mut storage as *mut _ as *mut _,\n-                        &mut addrlen)\n+            libc::recvfrom(\n+                self.0.raw(),\n+                buf.as_mut_ptr() as *mut c_void,\n+                buf.len(),\n+                flags,\n+                &mut storage as *mut _ as *mut _,\n+                &mut addrlen,\n+            )\n         })?;\n         Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n     }\n@@ -284,8 +279,10 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                              \"cannot set a 0 duration timeout\"));\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::InvalidInput,\n+                        \"cannot set a 0 duration timeout\",\n+                    ));\n                 }\n \n                 let secs = if dur.as_secs() > libc::time_t::max_value() as u64 {\n@@ -302,12 +299,7 @@ impl Socket {\n                 }\n                 timeout\n             }\n-            None => {\n-                libc::timeval {\n-                    tv_sec: 0,\n-                    tv_usec: 0,\n-                }\n-            }\n+            None => libc::timeval { tv_sec: 0, tv_usec: 0 },\n         };\n         setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n     }\n@@ -349,24 +341,26 @@ impl Socket {\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n-        if raw == 0 {\n-            Ok(None)\n-        } else {\n-            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n-        }\n+        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n     }\n }\n \n impl AsInner<c_int> for Socket {\n-    fn as_inner(&self) -> &c_int { self.0.as_inner() }\n+    fn as_inner(&self) -> &c_int {\n+        self.0.as_inner()\n+    }\n }\n \n impl FromInner<c_int> for Socket {\n-    fn from_inner(fd: c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+    fn from_inner(fd: c_int) -> Socket {\n+        Socket(FileDesc::new(fd))\n+    }\n }\n \n impl IntoInner<c_int> for Socket {\n-    fn into_inner(self) -> c_int { self.0.into_raw() }\n+    fn into_inner(self) -> c_int {\n+        self.0.into_raw()\n+    }\n }\n \n // In versions of glibc prior to 2.26, there's a bug where the DNS resolver"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/unix/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "77fefef8a1802d9425e47764ea3b1c7797a34fe0", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -22,24 +22,23 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n     // 2.6.27, however, and because we support 2.6.18 we must detect this\n     // support dynamically.\n-    if cfg!(any(target_os = \"dragonfly\",\n-                target_os = \"freebsd\",\n-                target_os = \"linux\",\n-                target_os = \"netbsd\",\n-                target_os = \"openbsd\",\n-                target_os = \"redox\")) &&\n-       !INVALID.load(Ordering::SeqCst)\n+    if cfg!(any(\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"redox\"\n+    )) && !INVALID.load(Ordering::SeqCst)\n     {\n-\n         // Note that despite calling a glibc function here we may still\n         // get ENOSYS. Glibc has `pipe2` since 2.9 and doesn't try to\n         // emulate on older kernels, so if you happen to be running on\n         // an older kernel you may see `pipe2` as a symbol but still not\n         // see the syscall.\n         match cvt(unsafe { pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) }) {\n             Ok(_) => {\n-                return Ok((AnonPipe(FileDesc::new(fds[0])),\n-                            AnonPipe(FileDesc::new(fds[1]))));\n+                return Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))));\n             }\n             Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {\n                 INVALID.store(true, Ordering::SeqCst);\n@@ -73,15 +72,15 @@ impl AnonPipe {\n         self.0.write_vectored(bufs)\n     }\n \n-    pub fn fd(&self) -> &FileDesc { &self.0 }\n-    pub fn into_fd(self) -> FileDesc { self.0 }\n+    pub fn fd(&self) -> &FileDesc {\n+        &self.0\n+    }\n+    pub fn into_fd(self) -> FileDesc {\n+        self.0\n+    }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             v1: &mut Vec<u8>,\n-             p2: AnonPipe,\n-             v2: &mut Vec<u8>) -> io::Result<()> {\n-\n+pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n     // Set both pipes into nonblocking mode as we're gonna be reading from both\n     // in the `select` loop below, and we wouldn't want one to block the other!\n     let p1 = p1.into_fd();\n@@ -117,8 +116,9 @@ pub fn read2(p1: AnonPipe,\n         match fd.read_to_end(dst) {\n             Ok(_) => Ok(true),\n             Err(e) => {\n-                if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n-                   e.raw_os_error() == Some(libc::EAGAIN) {\n+                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n+                    || e.raw_os_error() == Some(libc::EAGAIN)\n+                {\n                     Ok(false)\n                 } else {\n                     Err(e)"}, {"sha": "c9109b0c9d4d7b17a5fb1eae1d4baa5539065912", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 22, "deletions": 42, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,19 +1,19 @@\n use crate::os::unix::prelude::*;\n \n-use crate::ffi::{OsString, OsStr, CString, CStr};\n+use crate::collections::BTreeMap;\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::ptr;\n use crate::sys::fd::FileDesc;\n use crate::sys::fs::File;\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys_common::process::CommandEnv;\n-use crate::collections::BTreeMap;\n \n #[cfg(not(target_os = \"fuchsia\"))]\n use crate::sys::fs::OpenOptions;\n \n-use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n+use libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n \n cfg_if::cfg_if! {\n     if #[cfg(target_os = \"fuchsia\")] {\n@@ -204,10 +204,7 @@ impl Command {\n         &mut self.closures\n     }\n \n-    pub unsafe fn pre_exec(\n-        &mut self,\n-        f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n-    ) {\n+    pub unsafe fn pre_exec(&mut self, f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n         self.closures.push(f);\n     }\n \n@@ -236,26 +233,21 @@ impl Command {\n         self.env.have_changed_path()\n     }\n \n-    pub fn setup_io(&self, default: Stdio, needs_stdin: bool)\n-                -> io::Result<(StdioPipes, ChildPipes)> {\n+    pub fn setup_io(\n+        &self,\n+        default: Stdio,\n+        needs_stdin: bool,\n+    ) -> io::Result<(StdioPipes, ChildPipes)> {\n         let null = Stdio::Null;\n-        let default_stdin = if needs_stdin {&default} else {&null};\n+        let default_stdin = if needs_stdin { &default } else { &null };\n         let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n         let stdout = self.stdout.as_ref().unwrap_or(&default);\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n         let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n         let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n         let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n-        let ours = StdioPipes {\n-            stdin: our_stdin,\n-            stdout: our_stdout,\n-            stderr: our_stderr,\n-        };\n-        let theirs = ChildPipes {\n-            stdin: their_stdin,\n-            stdout: their_stdout,\n-            stderr: their_stderr,\n-        };\n+        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n+        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n         Ok((ours, theirs))\n     }\n }\n@@ -270,21 +262,21 @@ fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n // Helper type to manage ownership of the strings within a C-style array.\n pub struct CStringArray {\n     items: Vec<CString>,\n-    ptrs: Vec<*const c_char>\n+    ptrs: Vec<*const c_char>,\n }\n \n impl CStringArray {\n     pub fn with_capacity(capacity: usize) -> Self {\n         let mut result = CStringArray {\n             items: Vec::with_capacity(capacity),\n-            ptrs: Vec::with_capacity(capacity+1)\n+            ptrs: Vec::with_capacity(capacity + 1),\n         };\n         result.ptrs.push(ptr::null());\n         result\n     }\n     pub fn push(&mut self, item: CString) {\n         let l = self.ptrs.len();\n-        self.ptrs[l-1] = item.as_ptr();\n+        self.ptrs[l - 1] = item.as_ptr();\n         self.ptrs.push(ptr::null());\n         self.items.push(item);\n     }\n@@ -315,12 +307,9 @@ fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStr\n }\n \n impl Stdio {\n-    pub fn to_child_stdio(&self, readable: bool)\n-                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n         match *self {\n-            Stdio::Inherit => {\n-                Ok((ChildStdio::Inherit, None))\n-            },\n+            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n \n             // Make sure that the source descriptors are not an stdio\n             // descriptor, otherwise the order which we set the child's\n@@ -339,11 +328,7 @@ impl Stdio {\n \n             Stdio::MakePipe => {\n                 let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if readable {\n-                    (writer, reader)\n-                } else {\n-                    (reader, writer)\n-                };\n+                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                 Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n             }\n \n@@ -352,17 +337,13 @@ impl Stdio {\n                 let mut opts = OpenOptions::new();\n                 opts.read(readable);\n                 opts.write(!readable);\n-                let path = unsafe {\n-                    CStr::from_ptr(DEV_NULL.as_ptr() as *const _)\n-                };\n+                let path = unsafe { CStr::from_ptr(DEV_NULL.as_ptr() as *const _) };\n                 let fd = File::open_c(&path, &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n \n             #[cfg(target_os = \"fuchsia\")]\n-            Stdio::Null => {\n-                Ok((ChildStdio::Null, None))\n-            }\n+            Stdio::Null => Ok((ChildStdio::Null, None)),\n         }\n     }\n }\n@@ -430,7 +411,7 @@ mod tests {\n                 Ok(t) => t,\n                 Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n             }\n-        }\n+        };\n     }\n \n     // See #14232 for more information, but it appears that signal delivery to a\n@@ -461,8 +442,7 @@ mod tests {\n             let stdin_write = pipes.stdin.take().unwrap();\n             let stdout_read = pipes.stdout.take().unwrap();\n \n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(),\n-                                         ptr::null_mut())));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(), ptr::null_mut())));\n \n             t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n             // We need to wait until SIGINT is definitely delivered. The"}, {"sha": "f0bd1cdfed52f0a2c250aeffb44284d31dda32cc", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,11 +1,11 @@\n use crate::convert::TryInto;\n-use crate::io;\n use crate::fmt;\n+use crate::io;\n use crate::mem;\n use crate::ptr;\n \n-use crate::sys::process::zircon::{Handle, zx_handle_t};\n use crate::sys::process::process_common::*;\n+use crate::sys::process::zircon::{zx_handle_t, Handle};\n \n use libc::{c_int, size_t};\n \n@@ -14,13 +14,18 @@ use libc::{c_int, size_t};\n ////////////////////////////////////////////////////////////////////////////////\n \n impl Command {\n-    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n-                 -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        default: Stdio,\n+        needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"nul byte found in provided data\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"nul byte found in provided data\",\n+            ));\n         }\n \n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n@@ -32,21 +37,23 @@ impl Command {\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         if self.saw_nul() {\n-            return io::Error::new(io::ErrorKind::InvalidInput,\n-                                  \"nul byte found in provided data\")\n+            return io::Error::new(io::ErrorKind::InvalidInput, \"nul byte found in provided data\");\n         }\n \n         match self.setup_io(default, true) {\n             Ok((_, _)) => {\n                 // FIXME: This is tough because we don't support the exec syscalls\n                 unimplemented!();\n-            },\n+            }\n             Err(e) => e,\n         }\n     }\n \n-    unsafe fn do_exec(&mut self, stdio: ChildPipes, maybe_envp: Option<&CStringArray>)\n-                      -> io::Result<zx_handle_t> {\n+    unsafe fn do_exec(\n+        &mut self,\n+        stdio: ChildPipes,\n+        maybe_envp: Option<&CStringArray>,\n+    ) -> io::Result<zx_handle_t> {\n         use crate::sys::process::zircon::*;\n \n         let envp = match maybe_envp {\n@@ -108,10 +115,15 @@ impl Command {\n         let mut process_handle: zx_handle_t = 0;\n         zx_cvt(fdio_spawn_etc(\n             ZX_HANDLE_INVALID,\n-            FDIO_SPAWN_CLONE_JOB | FDIO_SPAWN_CLONE_LDSVC | FDIO_SPAWN_CLONE_NAMESPACE\n-            | FDIO_SPAWN_CLONE_ENVIRON,  // this is ignored when envp is non-null\n-            self.get_program().as_ptr(), self.get_argv().as_ptr(), envp,\n-            actions.len() as size_t, actions.as_ptr(),\n+            FDIO_SPAWN_CLONE_JOB\n+                | FDIO_SPAWN_CLONE_LDSVC\n+                | FDIO_SPAWN_CLONE_NAMESPACE\n+                | FDIO_SPAWN_CLONE_ENVIRON, // this is ignored when envp is non-null\n+            self.get_program().as_ptr(),\n+            self.get_argv().as_ptr(),\n+            envp,\n+            actions.len() as size_t,\n+            actions.as_ptr(),\n             &mut process_handle,\n             ptr::null_mut(),\n         ))?;\n@@ -137,7 +149,9 @@ impl Process {\n     pub fn kill(&mut self) -> io::Result<()> {\n         use crate::sys::process::zircon::*;\n \n-        unsafe { zx_cvt(zx_task_kill(self.handle.raw()))?; }\n+        unsafe {\n+            zx_cvt(zx_task_kill(self.handle.raw()))?;\n+        }\n \n         Ok(())\n     }\n@@ -151,16 +165,26 @@ impl Process {\n         let mut avail: size_t = 0;\n \n         unsafe {\n-            zx_cvt(zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED,\n-                                      ZX_TIME_INFINITE, ptr::null_mut()))?;\n-            zx_cvt(zx_object_get_info(self.handle.raw(), ZX_INFO_PROCESS,\n-                                      &mut proc_info as *mut _ as *mut libc::c_void,\n-                                      mem::size_of::<zx_info_process_t>(), &mut actual,\n-                                      &mut avail))?;\n+            zx_cvt(zx_object_wait_one(\n+                self.handle.raw(),\n+                ZX_TASK_TERMINATED,\n+                ZX_TIME_INFINITE,\n+                ptr::null_mut(),\n+            ))?;\n+            zx_cvt(zx_object_get_info(\n+                self.handle.raw(),\n+                ZX_INFO_PROCESS,\n+                &mut proc_info as *mut _ as *mut libc::c_void,\n+                mem::size_of::<zx_info_process_t>(),\n+                &mut actual,\n+                &mut avail,\n+            ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidData,\n-                                      \"Failed to get exit status of process\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidData,\n+                \"Failed to get exit status of process\",\n+            ));\n         }\n         Ok(ExitStatus(proc_info.return_code))\n     }\n@@ -174,23 +198,31 @@ impl Process {\n         let mut avail: size_t = 0;\n \n         unsafe {\n-            let status = zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED,\n-                                            0, ptr::null_mut());\n+            let status =\n+                zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED, 0, ptr::null_mut());\n             match status {\n-                0 => { }, // Success\n+                0 => {} // Success\n                 x if x == ERR_TIMED_OUT => {\n                     return Ok(None);\n-                },\n-                _ => { panic!(\"Failed to wait on process handle: {}\", status); },\n+                }\n+                _ => {\n+                    panic!(\"Failed to wait on process handle: {}\", status);\n+                }\n             }\n-            zx_cvt(zx_object_get_info(self.handle.raw(), ZX_INFO_PROCESS,\n-                                      &mut proc_info as *mut _ as *mut libc::c_void,\n-                                      mem::size_of::<zx_info_process_t>(), &mut actual,\n-                                      &mut avail))?;\n+            zx_cvt(zx_object_get_info(\n+                self.handle.raw(),\n+                ZX_INFO_PROCESS,\n+                &mut proc_info as *mut _ as *mut libc::c_void,\n+                mem::size_of::<zx_info_process_t>(),\n+                &mut actual,\n+                &mut avail,\n+            ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidData,\n-                                      \"Failed to get exit status of process\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidData,\n+                \"Failed to get exit status of process\",\n+            ));\n         }\n         Ok(Some(ExitStatus(proc_info.return_code)))\n     }"}, {"sha": "750b8f0762ae51ba72e2c97a92256801ca00b046", "filename": "src/libstd/sys/unix/process/zircon.rs", "status": "modified", "additions": 111, "deletions": 62, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,8 +1,8 @@\n #![allow(non_camel_case_types, unused)]\n \n use crate::convert::TryInto;\n-use crate::io;\n use crate::i64;\n+use crate::io;\n use crate::mem::MaybeUninit;\n use crate::os::raw::c_char;\n \n@@ -16,27 +16,26 @@ pub type zx_status_t = i32;\n pub const ZX_HANDLE_INVALID: zx_handle_t = 0;\n \n pub type zx_time_t = i64;\n-pub const ZX_TIME_INFINITE : zx_time_t = i64::MAX;\n+pub const ZX_TIME_INFINITE: zx_time_t = i64::MAX;\n \n pub type zx_signals_t = u32;\n \n-pub const ZX_OBJECT_SIGNAL_3         : zx_signals_t = 1 << 3;\n+pub const ZX_OBJECT_SIGNAL_3: zx_signals_t = 1 << 3;\n \n-pub const ZX_TASK_TERMINATED        : zx_signals_t = ZX_OBJECT_SIGNAL_3;\n+pub const ZX_TASK_TERMINATED: zx_signals_t = ZX_OBJECT_SIGNAL_3;\n \n-pub const ZX_RIGHT_SAME_RIGHTS  : zx_rights_t = 1 << 31;\n+pub const ZX_RIGHT_SAME_RIGHTS: zx_rights_t = 1 << 31;\n \n pub type zx_object_info_topic_t = u32;\n \n-pub const ZX_INFO_PROCESS         : zx_object_info_topic_t = 3;\n+pub const ZX_INFO_PROCESS: zx_object_info_topic_t = 3;\n \n-pub fn zx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<zx_status_t>+Copy {\n+pub fn zx_cvt<T>(t: T) -> io::Result<T>\n+where\n+    T: TryInto<zx_status_t> + Copy,\n+{\n     if let Ok(status) = TryInto::try_into(t) {\n-        if status < 0 {\n-            Err(io::Error::from_raw_os_error(status))\n-        } else {\n-            Ok(t)\n-        }\n+        if status < 0 { Err(io::Error::from_raw_os_error(status)) } else { Ok(t) }\n     } else {\n         Err(io::Error::last_os_error())\n     }\n@@ -49,9 +48,7 @@ pub struct Handle {\n \n impl Handle {\n     pub fn new(raw: zx_handle_t) -> Handle {\n-        Handle {\n-            raw,\n-        }\n+        Handle { raw }\n     }\n \n     pub fn raw(&self) -> zx_handle_t {\n@@ -61,7 +58,9 @@ impl Handle {\n \n impl Drop for Handle {\n     fn drop(&mut self) {\n-        unsafe { zx_cvt(zx_handle_close(self.raw)).expect(\"Failed to close zx_handle_t\"); }\n+        unsafe {\n+            zx_cvt(zx_handle_close(self.raw)).expect(\"Failed to close zx_handle_t\");\n+        }\n     }\n }\n \n@@ -75,22 +74,34 @@ pub struct zx_info_process_t {\n     pub debugger_attached: bool,\n }\n \n-extern {\n+extern \"C\" {\n     pub fn zx_job_default() -> zx_handle_t;\n \n     pub fn zx_task_kill(handle: zx_handle_t) -> zx_status_t;\n \n     pub fn zx_handle_close(handle: zx_handle_t) -> zx_status_t;\n \n-    pub fn zx_handle_duplicate(handle: zx_handle_t, rights: zx_rights_t,\n-                               out: *const zx_handle_t) -> zx_handle_t;\n-\n-    pub fn zx_object_wait_one(handle: zx_handle_t, signals: zx_signals_t, timeout: zx_time_t,\n-                              pending: *mut zx_signals_t) -> zx_status_t;\n-\n-    pub fn zx_object_get_info(handle: zx_handle_t, topic: u32, buffer: *mut c_void,\n-                              buffer_size: size_t, actual_size: *mut size_t,\n-                              avail: *mut size_t) -> zx_status_t;\n+    pub fn zx_handle_duplicate(\n+        handle: zx_handle_t,\n+        rights: zx_rights_t,\n+        out: *const zx_handle_t,\n+    ) -> zx_handle_t;\n+\n+    pub fn zx_object_wait_one(\n+        handle: zx_handle_t,\n+        signals: zx_signals_t,\n+        timeout: zx_time_t,\n+        pending: *mut zx_signals_t,\n+    ) -> zx_status_t;\n+\n+    pub fn zx_object_get_info(\n+        handle: zx_handle_t,\n+        topic: u32,\n+        buffer: *mut c_void,\n+        buffer_size: size_t,\n+        actual_size: *mut size_t,\n+        avail: *mut size_t,\n+    ) -> zx_status_t;\n }\n \n #[derive(Default)]\n@@ -103,11 +114,18 @@ pub struct fdio_spawn_action_t {\n     pub reserved1: u64,\n }\n \n-extern {\n-    pub fn fdio_spawn_etc(job: zx_handle_t, flags: u32, path: *const c_char,\n-                          argv: *const *const c_char, envp: *const *const c_char,\n-                          action_count: size_t, actions: *const fdio_spawn_action_t,\n-                          process: *mut zx_handle_t, err_msg: *mut c_char) -> zx_status_t;\n+extern \"C\" {\n+    pub fn fdio_spawn_etc(\n+        job: zx_handle_t,\n+        flags: u32,\n+        path: *const c_char,\n+        argv: *const *const c_char,\n+        envp: *const *const c_char,\n+        action_count: size_t,\n+        actions: *const fdio_spawn_action_t,\n+        process: *mut zx_handle_t,\n+        err_msg: *mut c_char,\n+    ) -> zx_status_t;\n \n     pub fn fdio_fd_clone(fd: c_int, out_handle: *mut zx_handle_t) -> zx_status_t;\n     pub fn fdio_fd_create(handle: zx_handle_t, fd: *mut c_int) -> zx_status_t;\n@@ -129,60 +147,74 @@ pub const FDIO_SPAWN_ACTION_TRANSFER_FD: u32 = 0x0002;\n \n // Errors\n \n-#[allow(unused)] pub const ERR_INTERNAL: zx_status_t = -1;\n+#[allow(unused)]\n+pub const ERR_INTERNAL: zx_status_t = -1;\n \n // ERR_NOT_SUPPORTED: The operation is not implemented, supported,\n // or enabled.\n-#[allow(unused)] pub const ERR_NOT_SUPPORTED: zx_status_t = -2;\n+#[allow(unused)]\n+pub const ERR_NOT_SUPPORTED: zx_status_t = -2;\n \n // ERR_NO_RESOURCES: The system was not able to allocate some resource\n // needed for the operation.\n-#[allow(unused)] pub const ERR_NO_RESOURCES: zx_status_t = -3;\n+#[allow(unused)]\n+pub const ERR_NO_RESOURCES: zx_status_t = -3;\n \n // ERR_NO_MEMORY: The system was not able to allocate memory needed\n // for the operation.\n-#[allow(unused)] pub const ERR_NO_MEMORY: zx_status_t = -4;\n+#[allow(unused)]\n+pub const ERR_NO_MEMORY: zx_status_t = -4;\n \n // ERR_CALL_FAILED: The second phase of zx_channel_call(; did not complete\n // successfully.\n-#[allow(unused)] pub const ERR_CALL_FAILED: zx_status_t = -5;\n+#[allow(unused)]\n+pub const ERR_CALL_FAILED: zx_status_t = -5;\n \n // ERR_INTERRUPTED_RETRY: The system call was interrupted, but should be\n // retried.  This should not be seen outside of the VDSO.\n-#[allow(unused)] pub const ERR_INTERRUPTED_RETRY: zx_status_t = -6;\n+#[allow(unused)]\n+pub const ERR_INTERRUPTED_RETRY: zx_status_t = -6;\n \n // ======= Parameter errors =======\n // ERR_INVALID_ARGS: an argument is invalid, ex. null pointer\n-#[allow(unused)] pub const ERR_INVALID_ARGS: zx_status_t = -10;\n+#[allow(unused)]\n+pub const ERR_INVALID_ARGS: zx_status_t = -10;\n \n // ERR_BAD_HANDLE: A specified handle value does not refer to a handle.\n-#[allow(unused)] pub const ERR_BAD_HANDLE: zx_status_t = -11;\n+#[allow(unused)]\n+pub const ERR_BAD_HANDLE: zx_status_t = -11;\n \n // ERR_WRONG_TYPE: The subject of the operation is the wrong type to\n // perform the operation.\n // Example: Attempting a message_read on a thread handle.\n-#[allow(unused)] pub const ERR_WRONG_TYPE: zx_status_t = -12;\n+#[allow(unused)]\n+pub const ERR_WRONG_TYPE: zx_status_t = -12;\n \n // ERR_BAD_SYSCALL: The specified syscall number is invalid.\n-#[allow(unused)] pub const ERR_BAD_SYSCALL: zx_status_t = -13;\n+#[allow(unused)]\n+pub const ERR_BAD_SYSCALL: zx_status_t = -13;\n \n // ERR_OUT_OF_RANGE: An argument is outside the valid range for this\n // operation.\n-#[allow(unused)] pub const ERR_OUT_OF_RANGE: zx_status_t = -14;\n+#[allow(unused)]\n+pub const ERR_OUT_OF_RANGE: zx_status_t = -14;\n \n // ERR_BUFFER_TOO_SMALL: A caller provided buffer is too small for\n // this operation.\n-#[allow(unused)] pub const ERR_BUFFER_TOO_SMALL: zx_status_t = -15;\n+#[allow(unused)]\n+pub const ERR_BUFFER_TOO_SMALL: zx_status_t = -15;\n \n // ======= Precondition or state errors =======\n // ERR_BAD_STATE: operation failed because the current state of the\n // object does not allow it, or a precondition of the operation is\n // not satisfied\n-#[allow(unused)] pub const ERR_BAD_STATE: zx_status_t = -20;\n+#[allow(unused)]\n+pub const ERR_BAD_STATE: zx_status_t = -20;\n \n // ERR_TIMED_OUT: The time limit for the operation elapsed before\n // the operation completed.\n-#[allow(unused)] pub const ERR_TIMED_OUT: zx_status_t = -21;\n+#[allow(unused)]\n+pub const ERR_TIMED_OUT: zx_status_t = -21;\n \n // ERR_SHOULD_WAIT: The operation cannot be performed currently but\n // potentially could succeed if the caller waits for a prerequisite\n@@ -192,67 +224,84 @@ pub const FDIO_SPAWN_ACTION_TRANSFER_FD: u32 = 0x0002;\n // messages waiting but has an open remote will return ERR_SHOULD_WAIT.\n // Attempting to read from a message pipe that has no messages waiting\n // and has a closed remote end will return ERR_REMOTE_CLOSED.\n-#[allow(unused)] pub const ERR_SHOULD_WAIT: zx_status_t = -22;\n+#[allow(unused)]\n+pub const ERR_SHOULD_WAIT: zx_status_t = -22;\n \n // ERR_CANCELED: The in-progress operation (e.g., a wait) has been\n // // canceled.\n-#[allow(unused)] pub const ERR_CANCELED: zx_status_t = -23;\n+#[allow(unused)]\n+pub const ERR_CANCELED: zx_status_t = -23;\n \n // ERR_PEER_CLOSED: The operation failed because the remote end\n // of the subject of the operation was closed.\n-#[allow(unused)] pub const ERR_PEER_CLOSED: zx_status_t = -24;\n+#[allow(unused)]\n+pub const ERR_PEER_CLOSED: zx_status_t = -24;\n \n // ERR_NOT_FOUND: The requested entity is not found.\n-#[allow(unused)] pub const ERR_NOT_FOUND: zx_status_t = -25;\n+#[allow(unused)]\n+pub const ERR_NOT_FOUND: zx_status_t = -25;\n \n // ERR_ALREADY_EXISTS: An object with the specified identifier\n // already exists.\n // Example: Attempting to create a file when a file already exists\n // with that name.\n-#[allow(unused)] pub const ERR_ALREADY_EXISTS: zx_status_t = -26;\n+#[allow(unused)]\n+pub const ERR_ALREADY_EXISTS: zx_status_t = -26;\n \n // ERR_ALREADY_BOUND: The operation failed because the named entity\n // is already owned or controlled by another entity. The operation\n // could succeed later if the current owner releases the entity.\n-#[allow(unused)] pub const ERR_ALREADY_BOUND: zx_status_t = -27;\n+#[allow(unused)]\n+pub const ERR_ALREADY_BOUND: zx_status_t = -27;\n \n // ERR_UNAVAILABLE: The subject of the operation is currently unable\n // to perform the operation.\n // Note: This is used when there's no direct way for the caller to\n // observe when the subject will be able to perform the operation\n // and should thus retry.\n-#[allow(unused)] pub const ERR_UNAVAILABLE: zx_status_t = -28;\n+#[allow(unused)]\n+pub const ERR_UNAVAILABLE: zx_status_t = -28;\n \n // ======= Permission check errors =======\n // ERR_ACCESS_DENIED: The caller did not have permission to perform\n // the specified operation.\n-#[allow(unused)] pub const ERR_ACCESS_DENIED: zx_status_t = -30;\n+#[allow(unused)]\n+pub const ERR_ACCESS_DENIED: zx_status_t = -30;\n \n // ======= Input-output errors =======\n // ERR_IO: Otherwise unspecified error occurred during I/O.\n-#[allow(unused)] pub const ERR_IO: zx_status_t = -40;\n+#[allow(unused)]\n+pub const ERR_IO: zx_status_t = -40;\n \n // ERR_REFUSED: The entity the I/O operation is being performed on\n // rejected the operation.\n // Example: an I2C device NAK'ing a transaction or a disk controller\n // rejecting an invalid command.\n-#[allow(unused)] pub const ERR_IO_REFUSED: zx_status_t = -41;\n+#[allow(unused)]\n+pub const ERR_IO_REFUSED: zx_status_t = -41;\n \n // ERR_IO_DATA_INTEGRITY: The data in the operation failed an integrity\n // check and is possibly corrupted.\n // Example: CRC or Parity error.\n-#[allow(unused)] pub const ERR_IO_DATA_INTEGRITY: zx_status_t = -42;\n+#[allow(unused)]\n+pub const ERR_IO_DATA_INTEGRITY: zx_status_t = -42;\n \n // ERR_IO_DATA_LOSS: The data in the operation is currently unavailable\n // and may be permanently lost.\n // Example: A disk block is irrecoverably damaged.\n-#[allow(unused)] pub const ERR_IO_DATA_LOSS: zx_status_t = -43;\n+#[allow(unused)]\n+pub const ERR_IO_DATA_LOSS: zx_status_t = -43;\n \n // Filesystem specific errors\n-#[allow(unused)] pub const ERR_BAD_PATH: zx_status_t = -50;\n-#[allow(unused)] pub const ERR_NOT_DIR: zx_status_t = -51;\n-#[allow(unused)] pub const ERR_NOT_FILE: zx_status_t = -52;\n+#[allow(unused)]\n+pub const ERR_BAD_PATH: zx_status_t = -50;\n+#[allow(unused)]\n+pub const ERR_NOT_DIR: zx_status_t = -51;\n+#[allow(unused)]\n+pub const ERR_NOT_FILE: zx_status_t = -52;\n // ERR_FILE_BIG: A file exceeds a filesystem-specific size limit.\n-#[allow(unused)] pub const ERR_FILE_BIG: zx_status_t = -53;\n+#[allow(unused)]\n+pub const ERR_FILE_BIG: zx_status_t = -53;\n // ERR_NO_SPACE: Filesystem or device space is exhausted.\n-#[allow(unused)] pub const ERR_NO_SPACE: zx_status_t = -54;\n+#[allow(unused)]\n+pub const ERR_NO_SPACE: zx_status_t = -54;"}, {"sha": "9ce5f3d014cc1fd8ec577601765c256af01dee91", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -4,20 +4,21 @@ use crate::slice;\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut v = (0, 0);\n     unsafe {\n-        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8,\n-                                             mem::size_of_val(&v));\n+        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8, mem::size_of_val(&v));\n         imp::fill_bytes(view);\n     }\n     v\n }\n \n-#[cfg(all(unix,\n-          not(target_os = \"ios\"),\n-          not(target_os = \"openbsd\"),\n-          not(target_os = \"freebsd\"),\n-          not(target_os = \"netbsd\"),\n-          not(target_os = \"fuchsia\"),\n-          not(target_os = \"redox\")))]\n+#[cfg(all(\n+    unix,\n+    not(target_os = \"ios\"),\n+    not(target_os = \"openbsd\"),\n+    not(target_os = \"freebsd\"),\n+    not(target_os = \"netbsd\"),\n+    not(target_os = \"fuchsia\"),\n+    not(target_os = \"redox\")\n+))]\n mod imp {\n     use crate::fs::File;\n     use crate::io::Read;\n@@ -30,7 +31,9 @@ mod imp {\n     }\n \n     #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool { false }\n+    fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool {\n+        false\n+    }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n@@ -96,9 +99,7 @@ mod imp {\n     pub fn fill_bytes(v: &mut [u8]) {\n         // getentropy(2) permits a maximum buffer size of 256 bytes\n         for s in v.chunks_mut(256) {\n-            let ret = unsafe {\n-                libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len())\n-            };\n+            let ret = unsafe { libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len()) };\n             if ret == -1 {\n                 panic!(\"unexpected getentropy error: {}\", errno());\n             }\n@@ -124,21 +125,14 @@ mod imp {\n     #[allow(non_upper_case_globals)]\n     const kSecRandomDefault: *const SecRandom = ptr::null();\n \n-    extern {\n-        fn SecRandomCopyBytes(rnd: *const SecRandom,\n-                              count: size_t,\n-                              bytes: *mut u8) -> c_int;\n+    extern \"C\" {\n+        fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n     }\n \n     pub fn fill_bytes(v: &mut [u8]) {\n-        let ret = unsafe {\n-            SecRandomCopyBytes(kSecRandomDefault,\n-                               v.len(),\n-                               v.as_mut_ptr())\n-        };\n+        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n         if ret == -1 {\n-            panic!(\"couldn't generate random bytes: {}\",\n-                   io::Error::last_os_error());\n+            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n         }\n     }\n }\n@@ -153,13 +147,22 @@ mod imp {\n         for s in v.chunks_mut(256) {\n             let mut s_len = s.len();\n             let ret = unsafe {\n-                libc::sysctl(mib.as_ptr(), mib.len() as libc::c_uint,\n-                             s.as_mut_ptr() as *mut _, &mut s_len,\n-                             ptr::null(), 0)\n+                libc::sysctl(\n+                    mib.as_ptr(),\n+                    mib.len() as libc::c_uint,\n+                    s.as_mut_ptr() as *mut _,\n+                    &mut s_len,\n+                    ptr::null(),\n+                    0,\n+                )\n             };\n             if ret == -1 || s_len != s.len() {\n-                panic!(\"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n-                       ret, s.len(), s_len);\n+                panic!(\n+                    \"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n+                    ret,\n+                    s.len(),\n+                    s_len\n+                );\n             }\n         }\n     }\n@@ -168,7 +171,7 @@ mod imp {\n #[cfg(target_os = \"fuchsia\")]\n mod imp {\n     #[link(name = \"zircon\")]\n-    extern {\n+    extern \"C\" {\n         fn zx_cprng_draw(buffer: *mut u8, len: usize);\n     }\n "}, {"sha": "528fe321efbce32cb0e83500ff55dd8872caaa02", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,12 +1,12 @@\n #![cfg_attr(test, allow(dead_code))]\n \n-use self::imp::{make_handler, drop_handler};\n+use self::imp::{drop_handler, make_handler};\n \n pub use self::imp::cleanup;\n pub use self::imp::init;\n \n pub struct Handler {\n-    _data: *mut libc::c_void\n+    _data: *mut libc::c_void,\n }\n \n impl Handler {\n@@ -23,28 +23,28 @@ impl Drop for Handler {\n     }\n }\n \n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"macos\",\n-          target_os = \"dragonfly\",\n-          target_os = \"freebsd\",\n-          target_os = \"solaris\",\n-          all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-          target_os = \"openbsd\"))]\n+#[cfg(any(\n+    target_os = \"linux\",\n+    target_os = \"macos\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"solaris\",\n+    all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+    target_os = \"openbsd\"\n+))]\n mod imp {\n     use super::Handler;\n     use crate::mem;\n     use crate::ptr;\n \n-    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n-    use libc::{sigaction, SIGBUS, SIG_DFL,\n-               SA_SIGINFO, SA_ONSTACK, sighandler_t};\n-    use libc::{mmap, munmap};\n-    use libc::{SIGSEGV, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON};\n     use libc::MAP_FAILED;\n+    use libc::{mmap, munmap};\n+    use libc::{sigaction, sighandler_t, SA_ONSTACK, SA_SIGINFO, SIGBUS, SIG_DFL};\n+    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n+    use libc::{MAP_ANON, MAP_PRIVATE, PROT_READ, PROT_WRITE, SIGSEGV};\n \n     use crate::sys_common::thread_info;\n \n-\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n         #[repr(C)]\n@@ -82,9 +82,11 @@ mod imp {\n     // out many large systems and all implementations allow returning from a\n     // signal handler to work. For a more detailed explanation see the\n     // comments on #26458.\n-    unsafe extern fn signal_handler(signum: libc::c_int,\n-                                    info: *mut libc::siginfo_t,\n-                                    _data: *mut libc::c_void) {\n+    unsafe extern \"C\" fn signal_handler(\n+        signum: libc::c_int,\n+        info: *mut libc::siginfo_t,\n+        _data: *mut libc::c_void,\n+    ) {\n         use crate::sys_common::util::report_overflow;\n \n         let guard = thread_info::stack_guard().unwrap_or(0..0);\n@@ -124,24 +126,22 @@ mod imp {\n     }\n \n     unsafe fn get_stackp() -> *mut libc::c_void {\n-        let stackp = mmap(ptr::null_mut(),\n-                          SIGSTKSZ,\n-                          PROT_READ | PROT_WRITE,\n-                          MAP_PRIVATE | MAP_ANON,\n-                          -1,\n-                          0);\n+        let stackp =\n+            mmap(ptr::null_mut(), SIGSTKSZ, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n         if stackp == MAP_FAILED {\n             panic!(\"failed to allocate an alternative stack\");\n         }\n         stackp\n     }\n \n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"freebsd\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\",\n-              target_os = \"solaris\"))]\n+    #[cfg(any(\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"freebsd\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"solaris\"\n+    ))]\n     unsafe fn get_stack() -> libc::stack_t {\n         libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }\n     }\n@@ -166,7 +166,7 @@ mod imp {\n \n     pub unsafe fn drop_handler(handler: &mut Handler) {\n         if !handler._data.is_null() {\n-            let stack =  libc::stack_t {\n+            let stack = libc::stack_t {\n                 ss_sp: ptr::null_mut(),\n                 ss_flags: SS_DISABLE,\n                 // Workaround for bug in macOS implementation of sigaltstack\n@@ -181,26 +181,25 @@ mod imp {\n     }\n }\n \n-#[cfg(not(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"dragonfly\",\n-              target_os = \"freebsd\",\n-              target_os = \"solaris\",\n-              all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-              target_os = \"openbsd\")))]\n+#[cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"macos\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"solaris\",\n+    all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+    target_os = \"openbsd\"\n+)))]\n mod imp {\n     use crate::ptr;\n \n-    pub unsafe fn init() {\n-    }\n+    pub unsafe fn init() {}\n \n-    pub unsafe fn cleanup() {\n-    }\n+    pub unsafe fn cleanup() {}\n \n     pub unsafe fn make_handler() -> super::Handler {\n         super::Handler { _data: ptr::null_mut() }\n     }\n \n-    pub unsafe fn drop_handler(_handler: &mut super::Handler) {\n-    }\n+    pub unsafe fn drop_handler(_handler: &mut super::Handler) {}\n }"}, {"sha": "b9c56963885c0d6bd38f2360e4680bdb7442bff4", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,13 +1,15 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::sys::fd::FileDesc;\n use crate::mem::ManuallyDrop;\n+use crate::sys::fd::FileDesc;\n \n pub struct Stdin(());\n pub struct Stdout(());\n pub struct Stderr(());\n \n impl Stdin {\n-    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin(()))\n+    }\n }\n \n impl io::Read for Stdin {\n@@ -21,7 +23,9 @@ impl io::Read for Stdin {\n }\n \n impl Stdout {\n-    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout(()))\n+    }\n }\n \n impl io::Write for Stdout {\n@@ -39,7 +43,9 @@ impl io::Write for Stdout {\n }\n \n impl Stderr {\n-    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr(()))\n+    }\n }\n \n impl io::Write for Stderr {"}, {"sha": "a5b34eeec289ee130b7e32f18a7f3b0e17e761f1", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 96, "deletions": 76, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -25,30 +25,32 @@ unsafe impl Sync for Thread {}\n // The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n // so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n #[cfg(not(target_os = \"emscripten\"))]\n-unsafe fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                    stack_size: libc::size_t) -> libc::c_int {\n+unsafe fn pthread_attr_setstacksize(\n+    attr: *mut libc::pthread_attr_t,\n+    stack_size: libc::size_t,\n+) -> libc::c_int {\n     libc::pthread_attr_setstacksize(attr, stack_size)\n }\n \n #[cfg(target_os = \"emscripten\")]\n-unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,\n-                                    _stack_size: libc::size_t) -> libc::c_int {\n+unsafe fn pthread_attr_setstacksize(\n+    _attr: *mut libc::pthread_attr_t,\n+    _stack_size: libc::size_t,\n+) -> libc::c_int {\n     panic!()\n }\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n-                          -> io::Result<Thread> {\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         let p = box p;\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n \n-        match pthread_attr_setstacksize(&mut attr,\n-                                        stack_size) {\n+        match pthread_attr_setstacksize(&mut attr, stack_size) {\n             0 => {}\n             n => {\n                 assert_eq!(n, libc::EINVAL);\n@@ -57,15 +59,13 @@ impl Thread {\n                 // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                 // Round up to the nearest page and try again.\n                 let page_size = os::page_size();\n-                let stack_size = (stack_size + page_size - 1) &\n-                                 (-(page_size as isize - 1) as usize - 1);\n-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr,\n-                                                           stack_size), 0);\n+                let stack_size =\n+                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n+                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start,\n-                                       &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n@@ -75,8 +75,10 @@ impl Thread {\n             Ok(Thread { id: native })\n         };\n \n-        extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n-            unsafe { start_thread(main as *mut u8); }\n+        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n             ptr::null_mut()\n         }\n     }\n@@ -86,8 +88,7 @@ impl Thread {\n         debug_assert_eq!(ret, 0);\n     }\n \n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"android\"))]\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     pub fn set_name(name: &CStr) {\n         const PR_SET_NAME: libc::c_int = 15;\n         // pthread wrapper only appeared in glibc 2.12, so we use syscall\n@@ -97,9 +98,7 @@ impl Thread {\n         }\n     }\n \n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"openbsd\"))]\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"openbsd\"))]\n     pub fn set_name(name: &CStr) {\n         unsafe {\n             libc::pthread_set_name_np(libc::pthread_self(), name.as_ptr());\n@@ -118,8 +117,11 @@ impl Thread {\n         use crate::ffi::CString;\n         let cname = CString::new(&b\"%s\"[..]).unwrap();\n         unsafe {\n-            libc::pthread_setname_np(libc::pthread_self(), cname.as_ptr(),\n-                                     name.as_ptr() as *mut libc::c_void);\n+            libc::pthread_setname_np(\n+                libc::pthread_self(),\n+                cname.as_ptr(),\n+                name.as_ptr() as *mut libc::c_void,\n+            );\n         }\n     }\n \n@@ -132,15 +134,19 @@ impl Thread {\n         }\n \n         if let Some(f) = pthread_setname_np.get() {\n-            unsafe { f(libc::pthread_self(), name.as_ptr()); }\n+            unsafe {\n+                f(libc::pthread_self(), name.as_ptr());\n+            }\n         }\n     }\n \n-    #[cfg(any(target_env = \"newlib\",\n-              target_os = \"haiku\",\n-              target_os = \"l4re\",\n-              target_os = \"emscripten\",\n-              target_os = \"redox\"))]\n+    #[cfg(any(\n+        target_env = \"newlib\",\n+        target_os = \"haiku\",\n+        target_os = \"l4re\",\n+        target_os = \"emscripten\",\n+        target_os = \"redox\"\n+    ))]\n     pub fn set_name(_name: &CStr) {\n         // Newlib, Illumos, Haiku, and Emscripten have no way to set a thread name.\n     }\n@@ -177,12 +183,13 @@ impl Thread {\n         unsafe {\n             let ret = libc::pthread_join(self.id, ptr::null_mut());\n             mem::forget(self);\n-            assert!(ret == 0,\n-                    \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n+            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n         }\n     }\n \n-    pub fn id(&self) -> libc::pthread_t { self.id }\n+    pub fn id(&self) -> libc::pthread_t {\n+        self.id\n+    }\n \n     pub fn into_id(self) -> libc::pthread_t {\n         let id = self.id;\n@@ -198,31 +205,38 @@ impl Drop for Thread {\n     }\n }\n \n-#[cfg(all(not(all(target_os = \"linux\", not(target_env = \"musl\"))),\n-          not(target_os = \"freebsd\"),\n-          not(target_os = \"macos\"),\n-          not(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\"))),\n-          not(target_os = \"openbsd\"),\n-          not(target_os = \"solaris\")))]\n+#[cfg(all(\n+    not(all(target_os = \"linux\", not(target_env = \"musl\"))),\n+    not(target_os = \"freebsd\"),\n+    not(target_os = \"macos\"),\n+    not(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\"))),\n+    not(target_os = \"openbsd\"),\n+    not(target_os = \"solaris\")\n+))]\n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n     use crate::ops::Range;\n     pub type Guard = Range<usize>;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }\n \n-\n-#[cfg(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n-          target_os = \"freebsd\",\n-          target_os = \"macos\",\n-          all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-          target_os = \"openbsd\",\n-          target_os = \"solaris\"))]\n+#[cfg(any(\n+    all(target_os = \"linux\", not(target_env = \"musl\")),\n+    target_os = \"freebsd\",\n+    target_os = \"macos\",\n+    all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+    target_os = \"openbsd\",\n+    target_os = \"solaris\"\n+))]\n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n     use libc::{mmap, mprotect};\n-    use libc::{PROT_NONE, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON, MAP_FAILED, MAP_FIXED};\n+    use libc::{MAP_ANON, MAP_FAILED, MAP_FIXED, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE};\n \n     use crate::ops::Range;\n     use crate::sys::os;\n@@ -241,16 +255,15 @@ pub mod guard {\n \n     #[cfg(target_os = \"macos\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n-        let stackaddr = libc::pthread_get_stackaddr_np(libc::pthread_self()) as usize -\n-             libc::pthread_get_stacksize_np(libc::pthread_self());\n+        let stackaddr = libc::pthread_get_stackaddr_np(libc::pthread_self()) as usize\n+            - libc::pthread_get_stacksize_np(libc::pthread_self());\n         Some(stackaddr as *mut libc::c_void)\n     }\n \n     #[cfg(target_os = \"openbsd\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut current_stack: libc::stack_t = crate::mem::zeroed();\n-        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(),\n-                                             &mut current_stack), 0);\n+        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(), &mut current_stack), 0);\n \n         let stackaddr = if libc::pthread_main_np() == 1 {\n             // main thread\n@@ -262,21 +275,25 @@ pub mod guard {\n         Some(stackaddr as *mut libc::c_void)\n     }\n \n-    #[cfg(any(target_os = \"android\", target_os = \"freebsd\",\n-              target_os = \"linux\", target_os = \"netbsd\", target_os = \"l4re\"))]\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"l4re\"\n+    ))]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n         #[cfg(target_os = \"freebsd\")]\n-            let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n+        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n         #[cfg(not(target_os = \"freebsd\"))]\n-            let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n+        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n         if e == 0 {\n             let mut stackaddr = crate::ptr::null_mut();\n             let mut stacksize = 0;\n-            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr,\n-                                                   &mut stacksize), 0);\n+            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize), 0);\n             ret = Some(stackaddr);\n         }\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n@@ -329,8 +346,14 @@ pub mod guard {\n             // than the initial mmap() used, so we mmap() here with\n             // read/write permissions and only then mprotect() it to\n             // no permissions at all. See issue #50313.\n-            let result = mmap(stackaddr, PAGE_SIZE, PROT_READ | PROT_WRITE,\n-                              MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);\n+            let result = mmap(\n+                stackaddr,\n+                PAGE_SIZE,\n+                PROT_READ | PROT_WRITE,\n+                MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n+                -1,\n+                0,\n+            );\n             if result != stackaddr || result == MAP_FAILED {\n                 panic!(\"failed to allocate a guard page\");\n             }\n@@ -341,34 +364,33 @@ pub mod guard {\n             }\n \n             let guardaddr = stackaddr as usize;\n-            let offset = if cfg!(target_os = \"freebsd\") {\n-                2\n-            } else {\n-                1\n-            };\n+            let offset = if cfg!(target_os = \"freebsd\") { 2 } else { 1 };\n \n             Some(guardaddr..guardaddr + offset * PAGE_SIZE)\n         }\n     }\n \n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"openbsd\",\n-              target_os = \"solaris\"))]\n+    #[cfg(any(target_os = \"macos\", target_os = \"openbsd\", target_os = \"solaris\"))]\n     pub unsafe fn current() -> Option<Guard> {\n         let stackaddr = get_stack_start()? as usize;\n         Some(stackaddr - PAGE_SIZE..stackaddr)\n     }\n \n-    #[cfg(any(target_os = \"android\", target_os = \"freebsd\",\n-              target_os = \"linux\", target_os = \"netbsd\", target_os = \"l4re\"))]\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"l4re\"\n+    ))]\n     pub unsafe fn current() -> Option<Guard> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n         #[cfg(target_os = \"freebsd\")]\n-            let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n+        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n         #[cfg(not(target_os = \"freebsd\"))]\n-            let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n+        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n         if e == 0 {\n             let mut guardsize = 0;\n             assert_eq!(libc::pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n@@ -377,8 +399,7 @@ pub mod guard {\n             }\n             let mut stackaddr = crate::ptr::null_mut();\n             let mut size = 0;\n-            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr,\n-                                                   &mut size), 0);\n+            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n \n             let stackaddr = stackaddr as usize;\n             ret = if cfg!(target_os = \"freebsd\") {\n@@ -422,8 +443,7 @@ fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n \n // No point in looking up __pthread_get_minstack() on non-glibc\n // platforms.\n-#[cfg(all(not(target_os = \"linux\"),\n-          not(target_os = \"netbsd\")))]\n+#[cfg(all(not(target_os = \"linux\"), not(target_os = \"netbsd\")))]\n fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n     libc::PTHREAD_STACK_MIN\n }"}, {"sha": "2c5b94b1e61e5710717363d92396c6b5e1027305", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -5,7 +5,7 @@ use crate::mem;\n pub type Key = libc::pthread_key_t;\n \n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n     assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n     key"}, {"sha": "08cbe59617465731a22fdc228c84b9d5ce7e9733", "filename": "src/libstd/sys/unix/weak.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fweak.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -36,11 +36,7 @@ pub struct Weak<F> {\n \n impl<F> Weak<F> {\n     pub const fn new(name: &'static str) -> Weak<F> {\n-        Weak {\n-            name,\n-            addr: AtomicUsize::new(1),\n-            _marker: marker::PhantomData,\n-        }\n+        Weak { name, addr: AtomicUsize::new(1), _marker: marker::PhantomData }\n     }\n \n     pub fn get(&self) -> Option<F> {"}, {"sha": "97a191d7232e08837fcbac10e3862232784aa53c", "filename": "src/libstd/sys/vxworks/alloc.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,6 +1,6 @@\n-use crate::ptr;\n-use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ptr;\n+use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n unsafe impl GlobalAlloc for System {\n@@ -45,9 +45,5 @@ unsafe impl GlobalAlloc for System {\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     let mut out = ptr::null_mut();\n     let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n-    if ret != 0 {\n-        ptr::null_mut()\n-    } else {\n-        out as *mut u8\n-    }\n+    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n }"}, {"sha": "efd615f404db6b316e89c57b3fe5bbe47ef7abd2", "filename": "src/libstd/sys/vxworks/args.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -4,10 +4,14 @@ use crate::marker::PhantomData;\n use crate::vec;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    imp::init(argc, argv)\n+}\n \n /// One-time global cleanup.\n-pub unsafe fn cleanup() { imp::cleanup() }\n+pub unsafe fn cleanup() {\n+    imp::cleanup()\n+}\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n@@ -27,24 +31,32 @@ impl Args {\n \n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<OsString> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.iter.next_back()\n+    }\n }\n \n mod imp {\n-    use crate::ptr;\n+    use super::Args;\n     use crate::ffi::{CStr, OsString};\n     use crate::marker::PhantomData;\n+    use crate::ptr;\n     use libc;\n-    use super::Args;\n \n     use crate::sys_common::mutex::Mutex;\n \n@@ -65,21 +77,20 @@ mod imp {\n     }\n \n     pub fn args() -> Args {\n-        Args {\n-            iter: clone().into_iter(),\n-            _dont_send_or_sync_me: PhantomData\n-        }\n+        Args { iter: clone().into_iter(), _dont_send_or_sync_me: PhantomData }\n     }\n \n     fn clone() -> Vec<OsString> {\n         unsafe {\n             let _guard = LOCK.lock();\n-            let ret = (0..ARGC).map(|i| {\n-                let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n-                use crate::sys::vxworks::ext::ffi::OsStringExt;\n-                OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-            }).collect();\n-            return ret\n+            let ret = (0..ARGC)\n+                .map(|i| {\n+                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n+                    use crate::sys::vxworks::ext::ffi::OsStringExt;\n+                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n+                })\n+                .collect();\n+            return ret;\n         }\n     }\n }"}, {"sha": "2916ebe4440593d2e1c9b4144f5b83da0ae8a28c", "filename": "src/libstd/sys/vxworks/cmath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n #![cfg(not(test))]\n \n-use libc::{c_float, c_double};\n+use libc::{c_double, c_float};\n \n #[link_name = \"m\"]\n-extern {\n+extern \"C\" {\n     pub fn acos(n: c_double) -> c_double;\n     pub fn acosf(n: c_float) -> c_float;\n     pub fn asin(n: c_double) -> c_double;"}, {"sha": "f2a1d6815290d220879ac2f9023f842828bfbf5a", "filename": "src/libstd/sys/vxworks/condvar.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -2,15 +2,15 @@ use crate::cell::UnsafeCell;\n use crate::sys::mutex::{self, Mutex};\n use crate::time::Duration;\n \n-pub struct Condvar { inner: UnsafeCell<libc::pthread_cond_t> }\n+pub struct Condvar {\n+    inner: UnsafeCell<libc::pthread_cond_t>,\n+}\n \n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-const TIMESPEC_MAX: libc::timespec = libc::timespec {\n-    tv_sec: <libc::time_t>::max_value(),\n-    tv_nsec: 1_000_000_000 - 1,\n-};\n+const TIMESPEC_MAX: libc::timespec =\n+    libc::timespec { tv_sec: <libc::time_t>::max_value(), tv_nsec: 1_000_000_000 - 1 };\n \n fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n     if value > <libc::time_t>::max_value() as u64 {\n@@ -77,17 +77,14 @@ impl Condvar {\n             .and_then(|s| s.checked_add(now.tv_sec));\n         let nsec = nsec % 1_000_000_000;\n \n-        let timeout = sec.map(|s| {\n-            libc::timespec { tv_sec: s, tv_nsec: nsec as _}\n-        }).unwrap_or(TIMESPEC_MAX);\n+        let timeout =\n+            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n \n-        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n-                                            &timeout);\n+        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n         assert!(r == libc::ETIMEDOUT || r == 0);\n         r == 0\n     }\n \n-\n     #[inline]\n     pub unsafe fn destroy(&self) {\n         let r = libc::pthread_cond_destroy(self.inner.get());"}, {"sha": "9864a855df738ef0afc3353cfc40959f463449c3", "filename": "src/libstd/sys/vxworks/ext/fs.rs", "status": "modified", "additions": 67, "deletions": 27, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -2,11 +2,11 @@\n \n use crate::fs::{self, Permissions};\n use crate::io;\n-use libc;\n use crate::path::Path;\n use crate::sys;\n-use crate::sys_common::{FromInner, AsInner, AsInnerMut};\n use crate::sys::platform::fs::MetadataExt as UnixMetadataExt;\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n+use libc;\n \n /// Unix-specific extensions to [`File`].\n ///\n@@ -112,8 +112,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new(io::ErrorKind::UnexpectedEof,\n-                               \"failed to fill whole buffer\"))\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -196,8 +195,12 @@ pub trait FileExt {\n     fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n-                Ok(0) => return Err(io::Error::new(io::ErrorKind::WriteZero,\n-                                                   \"failed to write whole buffer\")),\n+                Ok(0) => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::WriteZero,\n+                        \"failed to write whole buffer\",\n+                    ));\n+                }\n                 Ok(n) => {\n                     buf = &buf[n..];\n                     offset += n as u64\n@@ -604,20 +607,48 @@ pub trait MetadataExt {\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n impl MetadataExt for fs::Metadata {\n-    fn dev(&self) -> u64 { self.st_dev() }\n-    fn ino(&self) -> u64 { self.st_ino() }\n-    fn mode(&self) -> u32 { self.st_mode() }\n-    fn nlink(&self) -> u64 { self.st_nlink() }\n-    fn uid(&self) -> u32 { self.st_uid() }\n-    fn gid(&self) -> u32 { self.st_gid() }\n-    fn rdev(&self) -> u64 { self.st_rdev() }\n-    fn size(&self) -> u64 { self.st_size() }\n-    fn atime(&self) -> i64 { self.st_atime() }\n-    fn mtime(&self) -> i64 { self.st_mtime() }\n-    fn ctime(&self) -> i64 { self.st_ctime() }\n-    fn blksize(&self) -> u64 { self.st_blksize() }\n-    fn blocks(&self) -> u64 { self.st_blocks() }\n-    fn attrib(&self) -> u8 {self.st_attrib() }\n+    fn dev(&self) -> u64 {\n+        self.st_dev()\n+    }\n+    fn ino(&self) -> u64 {\n+        self.st_ino()\n+    }\n+    fn mode(&self) -> u32 {\n+        self.st_mode()\n+    }\n+    fn nlink(&self) -> u64 {\n+        self.st_nlink()\n+    }\n+    fn uid(&self) -> u32 {\n+        self.st_uid()\n+    }\n+    fn gid(&self) -> u32 {\n+        self.st_gid()\n+    }\n+    fn rdev(&self) -> u64 {\n+        self.st_rdev()\n+    }\n+    fn size(&self) -> u64 {\n+        self.st_size()\n+    }\n+    fn atime(&self) -> i64 {\n+        self.st_atime()\n+    }\n+    fn mtime(&self) -> i64 {\n+        self.st_mtime()\n+    }\n+    fn ctime(&self) -> i64 {\n+        self.st_ctime()\n+    }\n+    fn blksize(&self) -> u64 {\n+        self.st_blksize()\n+    }\n+    fn blocks(&self) -> u64 {\n+        self.st_blocks()\n+    }\n+    fn attrib(&self) -> u8 {\n+        self.st_attrib()\n+    }\n }\n \n /// Unix-specific extensions for [`FileType`].\n@@ -704,10 +735,18 @@ pub trait FileTypeExt {\n \n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n impl FileTypeExt for fs::FileType {\n-    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }\n-    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }\n-    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }\n-    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }\n+    fn is_block_device(&self) -> bool {\n+        self.as_inner().is(libc::S_IFBLK)\n+    }\n+    fn is_char_device(&self) -> bool {\n+        self.as_inner().is(libc::S_IFCHR)\n+    }\n+    fn is_fifo(&self) -> bool {\n+        self.as_inner().is(libc::S_IFIFO)\n+    }\n+    fn is_socket(&self) -> bool {\n+        self.as_inner().is(libc::S_IFSOCK)\n+    }\n }\n \n /// Unix-specific extension methods for [`fs::DirEntry`].\n@@ -739,7 +778,9 @@ pub trait DirEntryExt {\n \n #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n impl DirEntryExt for fs::DirEntry {\n-    fn ino(&self) -> u64 { self.as_inner().ino() }\n+    fn ino(&self) -> u64 {\n+        self.as_inner().ino()\n+    }\n }\n \n /// Creates a new symbolic link on the filesystem.\n@@ -766,8 +807,7 @@ impl DirEntryExt for fs::DirEntry {\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n-{\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     sys::fs::symlink(src.as_ref(), dst.as_ref())\n }\n "}, {"sha": "25c6e26d96e91d1a74f6edc1594abdde3a15ff31", "filename": "src/libstd/sys/vxworks/ext/io.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -3,11 +3,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fs;\n+use crate::io;\n+use crate::net;\n use crate::os::raw;\n use crate::sys;\n-use crate::io;\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-use crate::net;\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -84,47 +84,65 @@ impl IntoRawFd for fs::File {\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdin {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdout {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stderr {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StdinLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StdoutLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StderrLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n }\n \n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]"}, {"sha": "251a198f821d6a2d56080f040bf50792769d50bd", "filename": "src/libstd/sys/vxworks/ext/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,18 +1,21 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-pub mod io;\n pub mod ffi;\n pub mod fs;\n-pub mod raw;\n+pub mod io;\n pub mod process;\n+pub mod raw;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt, FileTypeExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::fs::{FileTypeExt, MetadataExt, OpenOptionsExt, PermissionsExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n }"}, {"sha": "e535c4aa122f0fe6d034e6b833eee0cfcf6da834", "filename": "src/libstd/sys/vxworks/ext/process.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -3,10 +3,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::io;\n-use crate::sys::vxworks::ext::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n use crate::process;\n use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+use crate::sys::vxworks::ext::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n /// Unix-specific extensions to the [`process::Command`] builder.\n ///\n@@ -55,7 +55,8 @@ pub trait CommandExt {\n     /// locations may not appear where intended.\n     #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n     unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n \n     /// Schedules a closure to be run just before the `exec` function is\n     /// invoked.\n@@ -67,7 +68,8 @@ pub trait CommandExt {\n     #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n     #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n     fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n     {\n         unsafe { self.pre_exec(f) }\n     }\n@@ -118,7 +120,8 @@ impl CommandExt for process::Command {\n     }\n \n     unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n     {\n         self.as_inner_mut().pre_exec(Box::new(f));\n         self"}, {"sha": "387ebd0520a71023465dfc8e4322323da44ae526", "filename": "src/libstd/sys/vxworks/fast_thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n #![cfg(target_thread_local)]\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::sys_common::thread_local::register_dtor_fallback;\n     register_dtor_fallback(t, dtor);\n }"}, {"sha": "9b649aa7ef45f99cf553c9191d733ff8f231c1c1", "filename": "src/libstd/sys/vxworks/fd.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n use crate::cmp;\n-use crate::io::{self, Read, Initializer, IoSlice, IoSliceMut};\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::sys::cvt;\n use crate::sys_common::AsInner;\n@@ -25,7 +25,9 @@ impl FileDesc {\n         FileDesc { fd: fd }\n     }\n \n-    pub fn raw(&self) -> c_int { self.fd }\n+    pub fn raw(&self) -> c_int {\n+        self.fd\n+    }\n \n     /// Extracts the actual filedescriptor without closing it.\n     pub fn into_raw(self) -> c_int {\n@@ -36,18 +38,18 @@ impl FileDesc {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::read(self.fd,\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       cmp::min(buf.len(), max_len()))\n+            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::readv(self.fd,\n-                        bufs.as_ptr() as *const libc::iovec,\n-                        cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+            libc::readv(\n+                self.fd,\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -58,61 +60,69 @@ impl FileDesc {\n     }\n \n     pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        unsafe fn cvt_pread(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n+        unsafe fn cvt_pread(\n+            fd: c_int,\n+            buf: *mut c_void,\n+            count: usize,\n+            offset: i64,\n+        ) -> io::Result<isize> {\n             use libc::pread;\n             cvt(pread(fd, buf, count, offset))\n         }\n \n         unsafe {\n-            cvt_pread(self.fd,\n+            cvt_pread(\n+                self.fd,\n                 buf.as_mut_ptr() as *mut c_void,\n                 cmp::min(buf.len(), max_len()),\n-                offset as i64)\n+                offset as i64,\n+            )\n             .map(|n| n as usize)\n         }\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::write(self.fd,\n-            buf.as_ptr() as *const c_void,\n-            cmp::min(buf.len(), max_len()))\n+            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::writev(self.fd,\n-                         bufs.as_ptr() as *const libc::iovec,\n-                         cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+            libc::writev(\n+                self.fd,\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        unsafe fn cvt_pwrite(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n+        unsafe fn cvt_pwrite(\n+            fd: c_int,\n+            buf: *const c_void,\n+            count: usize,\n+            offset: i64,\n+        ) -> io::Result<isize> {\n             use libc::pwrite;\n             cvt(pwrite(fd, buf, count, offset))\n         }\n \n         unsafe {\n-            cvt_pwrite(self.fd,\n+            cvt_pwrite(\n+                self.fd,\n                 buf.as_ptr() as *const c_void,\n                 cmp::min(buf.len(), max_len()),\n-                offset as i64)\n-                .map(|n| n as usize)\n+                offset as i64,\n+            )\n+            .map(|n| n as usize)\n         }\n     }\n \n     pub fn get_cloexec(&self) -> io::Result<bool> {\n-        unsafe {\n-            Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0)\n-        }\n+        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n     }\n \n     pub fn set_cloexec(&self) -> io::Result<()> {\n@@ -139,23 +149,16 @@ impl FileDesc {\n     pub fn set_nonblocking_pipe(&self, nonblocking: bool) -> io::Result<()> {\n         unsafe {\n             let mut flags = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n-            flags = if nonblocking {\n-                flags | libc::O_NONBLOCK\n-            } else {\n-                flags & !libc::O_NONBLOCK\n-            };\n+            flags = if nonblocking { flags | libc::O_NONBLOCK } else { flags & !libc::O_NONBLOCK };\n             cvt(libc::fcntl(self.fd, libc::F_SETFL, flags))?;\n             Ok(())\n         }\n     }\n \n-\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n         let fd = self.raw();\n         match cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD_CLOEXEC, 0) }) {\n-            Ok(newfd) => {\n-                Ok(FileDesc::new(newfd))\n-            }\n+            Ok(newfd) => Ok(FileDesc::new(newfd)),\n             Err(e) => return Err(e),\n         }\n     }\n@@ -173,7 +176,9 @@ impl<'a> Read for &'a FileDesc {\n }\n \n impl AsInner<c_int> for FileDesc {\n-    fn as_inner(&self) -> &c_int { &self.fd }\n+    fn as_inner(&self) -> &c_int {\n+        &self.fd\n+    }\n }\n \n impl Drop for FileDesc {"}, {"sha": "6c2dfb79d6f11d874b67ac22c24867a04c03383f", "filename": "src/libstd/sys/vxworks/fs.rs", "status": "modified", "additions": 121, "deletions": 95, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,19 +1,19 @@\n // copies from linuxx\n-use crate::ffi::{CString, CStr, OsString, OsStr};\n-use crate::sys::vxworks::ext::ffi::OsStrExt;\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sync::Arc;\n use crate::sys::fd::FileDesc;\n use crate::sys::time::SystemTime;\n+use crate::sys::vxworks::ext::ffi::OsStrExt;\n+use crate::sys::vxworks::ext::ffi::OsStringExt;\n use crate::sys::{cvt, cvt_r};\n use crate::sys_common::{AsInner, FromInner};\n-use libc::{self, c_int, mode_t, stat64, off_t};\n-use libc::{ftruncate, lseek, dirent, readdir_r as readdir64_r, open};\n-use crate::sys::vxworks::ext::ffi::OsStringExt;\n+use libc::{self, c_int, mode_t, off_t, stat64};\n+use libc::{dirent, ftruncate, lseek, open, readdir_r as readdir64_r};\n pub struct File(FileDesc);\n \n #[derive(Clone)]\n@@ -58,16 +58,24 @@ pub struct OpenOptions {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FilePermissions { mode: mode_t }\n+pub struct FilePermissions {\n+    mode: mode_t,\n+}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct FileType { mode: mode_t }\n+pub struct FileType {\n+    mode: mode_t,\n+}\n \n #[derive(Debug)]\n-pub struct DirBuilder { mode: mode_t }\n+pub struct DirBuilder {\n+    mode: mode_t,\n+}\n \n impl FileAttr {\n-    pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n+    pub fn size(&self) -> u64 {\n+        self.stat.st_size as u64\n+    }\n     pub fn perm(&self) -> FilePermissions {\n         FilePermissions { mode: (self.stat.st_mode as mode_t) }\n     }\n@@ -85,20 +93,23 @@ impl FileAttr {\n \n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n-        tv_sec: self.stat.st_atime as libc::time_t,\n-        tv_nsec: 0, // hack - a proper fix would be better\n+            tv_sec: self.stat.st_atime as libc::time_t,\n+            tv_nsec: 0, // hack - a proper fix would be better\n         }))\n     }\n \n     pub fn created(&self) -> io::Result<SystemTime> {\n-        Err(io::Error::new(io::ErrorKind::Other,\n-                           \"creation time is not available on this platform currently\"))\n+        Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"creation time is not available on this platform currently\",\n+        ))\n     }\n-\n }\n \n impl AsInner<stat64> for FileAttr {\n-    fn as_inner(&self) -> &stat64 { &self.stat }\n+    fn as_inner(&self) -> &stat64 {\n+        &self.stat\n+    }\n }\n \n impl FilePermissions {\n@@ -116,15 +127,25 @@ impl FilePermissions {\n             self.mode |= 0o222;\n         }\n     }\n-    pub fn mode(&self) -> u32 { self.mode as u32 }\n+    pub fn mode(&self) -> u32 {\n+        self.mode as u32\n+    }\n }\n \n impl FileType {\n-    pub fn is_dir(&self) -> bool { self.is(libc::S_IFDIR) }\n-    pub fn is_file(&self) -> bool { self.is(libc::S_IFREG) }\n-    pub fn is_symlink(&self) -> bool { self.is(libc::S_IFLNK) }\n+    pub fn is_dir(&self) -> bool {\n+        self.is(libc::S_IFDIR)\n+    }\n+    pub fn is_file(&self) -> bool {\n+        self.is(libc::S_IFREG)\n+    }\n+    pub fn is_symlink(&self) -> bool {\n+        self.is(libc::S_IFLNK)\n+    }\n \n-    pub fn is(&self, mode: mode_t) -> bool { self.mode & libc::S_IFMT == mode }\n+    pub fn is(&self, mode: mode_t) -> bool {\n+        self.mode & libc::S_IFMT == mode\n+    }\n }\n \n impl FromInner<u32> for FilePermissions {\n@@ -149,10 +170,7 @@ impl Iterator for ReadDir {\n         }\n \n         unsafe {\n-            let mut ret = DirEntry {\n-                entry: mem::zeroed(),\n-                dir: self.clone(),\n-            };\n+            let mut ret = DirEntry { entry: mem::zeroed(), dir: self.clone() };\n             let mut entry_ptr = ptr::null_mut();\n             loop {\n                 if readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n@@ -163,13 +181,13 @@ impl Iterator for ReadDir {\n                         // (instead of looping forever)\n                         self.end_of_stream = true;\n                     }\n-                    return Some(Err(Error::last_os_error()))\n+                    return Some(Err(Error::last_os_error()));\n                 }\n                 if entry_ptr.is_null() {\n-                    return None\n+                    return None;\n                 }\n                 if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n-                    return Some(Ok(ret))\n+                    return Some(Ok(ret));\n                 }\n             }\n         }\n@@ -185,22 +203,20 @@ impl Drop for Dir {\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-            use crate::sys::vxworks::ext::ffi::OsStrExt;\n-            self.dir.inner.root.join(OsStr::from_bytes(self.name_bytes()))\n+        use crate::sys::vxworks::ext::ffi::OsStrExt;\n+        self.dir.inner.root.join(OsStr::from_bytes(self.name_bytes()))\n     }\n \n     pub fn file_name(&self) -> OsString {\n         OsStr::from_bytes(self.name_bytes()).to_os_string()\n     }\n \n-\n     pub fn metadata(&self) -> io::Result<FileAttr> {\n         lstat(&self.path())\n     }\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n-\n     }\n \n     pub fn ino(&self) -> u64 {\n@@ -231,45 +247,61 @@ impl OpenOptions {\n         }\n     }\n \n-    pub fn read(&mut self, read: bool) { self.read = read; }\n-    pub fn write(&mut self, write: bool) { self.write = write; }\n-    pub fn append(&mut self, append: bool) { self.append = append; }\n-    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n-    pub fn create(&mut self, create: bool) { self.create = create; }\n-    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n-    pub fn mode(&mut self, mode: u32) { self.mode = mode as mode_t; }\n+    pub fn read(&mut self, read: bool) {\n+        self.read = read;\n+    }\n+    pub fn write(&mut self, write: bool) {\n+        self.write = write;\n+    }\n+    pub fn append(&mut self, append: bool) {\n+        self.append = append;\n+    }\n+    pub fn truncate(&mut self, truncate: bool) {\n+        self.truncate = truncate;\n+    }\n+    pub fn create(&mut self, create: bool) {\n+        self.create = create;\n+    }\n+    pub fn create_new(&mut self, create_new: bool) {\n+        self.create_new = create_new;\n+    }\n+    pub fn mode(&mut self, mode: u32) {\n+        self.mode = mode as mode_t;\n+    }\n \n     fn get_access_mode(&self) -> io::Result<c_int> {\n         match (self.read, self.write, self.append) {\n-            (true,  false, false) => Ok(libc::O_RDONLY),\n-            (false, true,  false) => Ok(libc::O_WRONLY),\n-            (true,  true,  false) => Ok(libc::O_RDWR),\n-            (false, _,     true)  => Ok(libc::O_WRONLY | libc::O_APPEND),\n-            (true,  _,     true)  => Ok(libc::O_RDWR | libc::O_APPEND),\n+            (true, false, false) => Ok(libc::O_RDONLY),\n+            (false, true, false) => Ok(libc::O_WRONLY),\n+            (true, true, false) => Ok(libc::O_RDWR),\n+            (false, _, true) => Ok(libc::O_WRONLY | libc::O_APPEND),\n+            (true, _, true) => Ok(libc::O_RDWR | libc::O_APPEND),\n             (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n         }\n     }\n \n     fn get_creation_mode(&self) -> io::Result<c_int> {\n         match (self.write, self.append) {\n             (true, false) => {}\n-            (false, false) =>\n+            (false, false) => {\n                 if self.truncate || self.create || self.create_new {\n                     return Err(Error::from_raw_os_error(libc::EINVAL));\n-                },\n-            (_, true) =>\n+                }\n+            }\n+            (_, true) => {\n                 if self.truncate && !self.create_new {\n                     return Err(Error::from_raw_os_error(libc::EINVAL));\n-                },\n+                }\n+            }\n         }\n \n         Ok(match (self.create, self.truncate, self.create_new) {\n-                (false, false, false) => 0,\n-                (true,  false, false) => libc::O_CREAT,\n-                (false, true,  false) => libc::O_TRUNC,\n-                (true,  true,  false) => libc::O_CREAT | libc::O_TRUNC,\n-                (_,      _,    true)  => libc::O_CREAT | libc::O_EXCL,\n-           })\n+            (false, false, false) => 0,\n+            (true, false, false) => libc::O_CREAT,\n+            (false, true, false) => libc::O_TRUNC,\n+            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,\n+            (_, _, true) => libc::O_CREAT | libc::O_EXCL,\n+        })\n     }\n }\n \n@@ -280,21 +312,17 @@ impl File {\n     }\n \n     pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = libc::O_CLOEXEC |\n-                opts.get_access_mode()? |\n-                opts.get_creation_mode()? |\n-                (opts.custom_flags as c_int & !libc::O_ACCMODE);\n-        let fd = cvt_r(|| unsafe {\n-            open(path.as_ptr(), flags, opts.mode as c_int)\n-        })?;\n+        let flags = libc::O_CLOEXEC\n+            | opts.get_access_mode()?\n+            | opts.get_creation_mode()?\n+            | (opts.custom_flags as c_int & !libc::O_ACCMODE);\n+        let fd = cvt_r(|| unsafe { open(path.as_ptr(), flags, opts.mode as c_int) })?;\n         Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         let mut stat: stat64 = unsafe { mem::zeroed() };\n-        cvt(unsafe {\n-            ::libc::fstat(self.0.raw(), &mut stat)\n-        })?;\n+        cvt(unsafe { ::libc::fstat(self.0.raw(), &mut stat) })?;\n         Ok(FileAttr { stat: stat })\n     }\n \n@@ -306,13 +334,13 @@ impl File {\n     pub fn datasync(&self) -> io::Result<()> {\n         cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n         return Ok(());\n-        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) } //not supported\n+        unsafe fn os_datasync(fd: c_int) -> c_int {\n+            libc::fsync(fd)\n+        } //not supported\n     }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        return cvt_r(|| unsafe {\n-            ftruncate(self.0.raw(), size as off_t)\n-        }).map(|_| ());\n+        return cvt_r(|| unsafe { ftruncate(self.0.raw(), size as off_t) }).map(|_| ());\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -339,7 +367,9 @@ impl File {\n         self.0.write_at(buf, offset)\n     }\n \n-    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, pos) = match pos {\n@@ -357,9 +387,13 @@ impl File {\n         self.0.duplicate().map(File)\n     }\n \n-    pub fn fd(&self) -> &FileDesc { &self.0 }\n+    pub fn fd(&self) -> &FileDesc {\n+        &self.0\n+    }\n \n-    pub fn into_fd(self) -> FileDesc { self.0 }\n+    pub fn into_fd(self) -> FileDesc {\n+        self.0\n+    }\n \n     pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n         cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n@@ -401,7 +435,7 @@ impl FromInner<c_int> for File {\n impl fmt::Debug for File {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fn get_path(fd: c_int) -> Option<PathBuf> {\n-            let mut buf = vec![0;libc::PATH_MAX as usize];\n+            let mut buf = vec![0; libc::PATH_MAX as usize];\n             let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n             if n == -1 {\n                 return None;\n@@ -419,7 +453,7 @@ impl fmt::Debug for File {\n                 libc::O_RDONLY => Some((true, false)),\n                 libc::O_RDWR => Some((true, true)),\n                 libc::O_WRONLY => Some((false, true)),\n-                _ => None\n+                _ => None,\n             }\n         }\n \n@@ -445,10 +479,7 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n             Err(Error::last_os_error())\n         } else {\n             let inner = InnerReadDir { dirp: Dir(ptr), root };\n-            Ok(ReadDir{\n-                inner: Arc::new(inner),\n-                end_of_stream: false,\n-            })\n+            Ok(ReadDir { inner: Arc::new(inner), end_of_stream: false })\n         }\n     }\n }\n@@ -480,11 +511,7 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n \n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n     let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() {\n-        unlink(path)\n-    } else {\n-        remove_dir_all_recursive(path)\n-    }\n+    if filetype.is_symlink() { unlink(path) } else { remove_dir_all_recursive(path) }\n }\n \n fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n@@ -506,11 +533,12 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let mut buf = Vec::with_capacity(256);\n \n     loop {\n-        let buf_read = cvt(unsafe {\n-            libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity())\n-        })? as usize;\n+        let buf_read =\n+            cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;\n \n-        unsafe { buf.set_len(buf_read); }\n+        unsafe {\n+            buf.set_len(buf_read);\n+        }\n \n         if buf_read != buf.capacity() {\n             buf.shrink_to_fit();\n@@ -542,18 +570,14 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe {\n-        libc::stat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n-    })?;\n+    cvt(unsafe { libc::stat(p.as_ptr(), &mut stat as *mut _ as *mut _) })?;\n     Ok(FileAttr { stat })\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe {\n-        ::libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n-    })?;\n+    cvt(unsafe { ::libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _) })?;\n     Ok(FileAttr { stat })\n }\n \n@@ -564,7 +588,7 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     unsafe {\n         let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n         if r.is_null() {\n-            return Err(io::Error::last_os_error())\n+            return Err(io::Error::last_os_error());\n         }\n         buf = CStr::from_ptr(r).to_bytes().to_vec();\n         libc::free(r as *mut _);\n@@ -575,8 +599,10 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::fs::File;\n     if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n+        return Err(Error::new(\n+            ErrorKind::InvalidInput,\n+            \"the source path is not an existing regular file\",\n+        ));\n     }\n \n     let mut reader = File::open(from)?;"}, {"sha": "f1a2c8446ff8b40c7d096702746b8f78be31f128", "filename": "src/libstd/sys/vxworks/io.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n use crate::marker::PhantomData;\n use crate::slice;\n \n-use libc::{iovec, c_void};\n+use libc::{c_void, iovec};\n \n #[repr(transparent)]\n pub struct IoSlice<'a> {\n@@ -13,10 +13,7 @@ impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice {\n-            vec: iovec {\n-                iov_base: buf.as_ptr() as *mut u8 as *mut c_void,\n-                iov_len: buf.len()\n-            },\n+            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n             _p: PhantomData,\n         }\n     }\n@@ -35,9 +32,7 @@ impl<'a> IoSlice<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }\n \n@@ -50,10 +45,7 @@ impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut {\n-            vec: iovec {\n-                iov_base: buf.as_mut_ptr() as *mut c_void,\n-                iov_len: buf.len()\n-            },\n+            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n             _p: PhantomData,\n         }\n     }\n@@ -72,15 +64,11 @@ impl<'a> IoSliceMut<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n \n     #[inline]\n     pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }"}, {"sha": "928100c92ffadf57c3f018c628509bb073ccb786", "filename": "src/libstd/sys/vxworks/memchr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -6,13 +6,10 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n         libc::memchr(\n             haystack.as_ptr() as *const libc::c_void,\n             needle as libc::c_int,\n-            haystack.len())\n+            haystack.len(),\n+        )\n     };\n-    if p.is_null() {\n-        None\n-    } else {\n-        Some(p as usize - (haystack.as_ptr() as usize))\n-    }\n+    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n }\n \n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {"}, {"sha": "f102e4d6adf59250581e5b864dc95107cddb5414", "filename": "src/libstd/sys/vxworks/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -3,8 +3,8 @@\n \n use crate::io::ErrorKind;\n \n-pub use crate::os::vxworks as platform;\n pub use self::rand::hashmap_random_keys;\n+pub use crate::os::vxworks as platform;\n pub use libc::strlen;\n \n pub mod alloc;\n@@ -16,8 +16,8 @@ pub mod ext;\n pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n-pub mod memchr;\n pub mod io;\n+pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod os;\n@@ -27,10 +27,10 @@ pub mod process;\n pub mod rand;\n pub mod rwlock;\n pub mod stack_overflow;\n+pub mod stdio;\n pub mod thread;\n pub mod thread_local;\n pub mod time;\n-pub mod stdio;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n@@ -47,7 +47,7 @@ pub fn init() {\n         reset_sigpipe();\n     }\n \n-    unsafe fn reset_sigpipe() { }\n+    unsafe fn reset_sigpipe() {}\n }\n \n pub use libc::signal;\n@@ -71,8 +71,7 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n         // These two constants can have the same value on some systems,\n         // but different values on others, so we can't use a match\n         // clause\n-        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-            ErrorKind::WouldBlock,\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK => ErrorKind::WouldBlock,\n \n         _ => ErrorKind::Other,\n     }\n@@ -94,16 +93,13 @@ macro_rules! impl_is_minus_one {\n impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n pub fn cvt<T: IsMinusOne>(t: T) -> crate::io::Result<T> {\n-    if t.is_minus_one() {\n-        Err(crate::io::Error::last_os_error())\n-    } else {\n-        Ok(t)\n-    }\n+    if t.is_minus_one() { Err(crate::io::Error::last_os_error()) } else { Ok(t) }\n }\n \n pub fn cvt_r<T, F>(mut f: F) -> crate::io::Result<T>\n-    where T: IsMinusOne,\n-          F: FnMut() -> T\n+where\n+    T: IsMinusOne,\n+    F: FnMut() -> T,\n {\n     loop {\n         match cvt(f()) {"}, {"sha": "b38375a2e03c5cd4a2d016d82cfa4cdd12fee1a9", "filename": "src/libstd/sys/vxworks/mutex.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,9 @@\n use crate::cell::UnsafeCell;\n use crate::mem::MaybeUninit;\n \n-pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n+pub struct Mutex {\n+    inner: UnsafeCell<libc::pthread_mutex_t>,\n+}\n \n #[inline]\n pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n@@ -82,7 +84,9 @@ impl Mutex {\n     }\n }\n \n-pub struct ReentrantMutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n+pub struct ReentrantMutex {\n+    inner: UnsafeCell<libc::pthread_mutex_t>,\n+}\n \n unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n@@ -96,8 +100,8 @@ impl ReentrantMutex {\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n         let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_settype(attr.as_mut_ptr(),\n-                                                    libc::PTHREAD_MUTEX_RECURSIVE);\n+        let result =\n+            libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE);\n         debug_assert_eq!(result, 0);\n         let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n         debug_assert_eq!(result, 0);"}, {"sha": "85f5fcff2c259e3dd9c60d58e4761f53dc453b25", "filename": "src/libstd/sys/vxworks/net.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,15 +1,15 @@\n+use crate::cmp;\n use crate::ffi::CStr;\n use crate::io;\n use crate::io::{IoSlice, IoSliceMut};\n-use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n use crate::mem;\n-use crate::net::{SocketAddr, Shutdown};\n+use crate::net::{Shutdown, SocketAddr};\n use crate::str;\n use crate::sys::fd::FileDesc;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::{Duration, Instant};\n-use crate::cmp;\n+use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n \n pub use crate::sys::{cvt, cvt_r};\n \n@@ -18,7 +18,6 @@ pub extern crate libc as netc;\n \n pub type wrlen_t = size_t;\n \n-\n const SOCK_CLOEXEC: c_int = 0;\n const SO_NOSIGPIPE: c_int = 0;\n \n@@ -28,23 +27,23 @@ pub fn init() {}\n \n pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 {\n-        return Ok(())\n+        return Ok(());\n     }\n \n     // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n     on_resolver_failure();\n \n     if err == EAI_SYSTEM {\n-        return Err(io::Error::last_os_error())\n+        return Err(io::Error::last_os_error());\n     }\n \n     let detail = unsafe {\n-        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap()\n-            .to_owned()\n+        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n     };\n-    Err(io::Error::new(io::ErrorKind::Other,\n-                       &format!(\"failed to lookup address information: {}\",\n-                                detail)[..]))\n+    Err(io::Error::new(\n+        io::ErrorKind::Other,\n+        &format!(\"failed to lookup address information: {}\", detail)[..],\n+    ))\n }\n \n impl Socket {\n@@ -67,7 +66,7 @@ impl Socket {\n     }\n \n     pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n-            unimplemented!();\n+        unimplemented!();\n     }\n \n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n@@ -85,15 +84,13 @@ impl Socket {\n             Err(e) => return Err(e),\n         }\n \n-        let mut pollfd = libc::pollfd {\n-            fd: self.0.raw(),\n-            events: libc::POLLOUT,\n-            revents: 0,\n-        };\n+        let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"cannot set a 0 duration timeout\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"cannot set a 0 duration timeout\",\n+            ));\n         }\n \n         let start = Instant::now();\n@@ -105,7 +102,8 @@ impl Socket {\n             }\n \n             let timeout = timeout - elapsed;\n-            let mut timeout = timeout.as_secs()\n+            let mut timeout = timeout\n+                .as_secs()\n                 .saturating_mul(1_000)\n                 .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n             if timeout == 0 {\n@@ -126,10 +124,9 @@ impl Socket {\n                     // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n                     // for POLLHUP rather than read readiness\n                     if pollfd.revents & libc::POLLHUP != 0 {\n-                        let e = self.take_error()?\n-                            .unwrap_or_else(|| {\n-                                io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n-                            });\n+                        let e = self.take_error()?.unwrap_or_else(|| {\n+                            io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n+                        });\n                         return Err(e);\n                     }\n \n@@ -139,11 +136,8 @@ impl Socket {\n         }\n     }\n \n-    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n-                  -> io::Result<Socket> {\n-        let fd = cvt_r(|| unsafe {\n-            libc::accept(self.0.raw(), storage, len)\n-        })?;\n+    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n+        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n         let fd = FileDesc::new(fd);\n         fd.set_cloexec()?;\n         Ok(Socket(fd))\n@@ -155,10 +149,7 @@ impl Socket {\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::recv(self.0.raw(),\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       buf.len(),\n-                       flags)\n+            libc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n         })?;\n         Ok(ret as usize)\n     }\n@@ -175,18 +166,23 @@ impl Socket {\n         self.0.read_vectored(bufs)\n     }\n \n-    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n-                            -> io::Result<(usize, SocketAddr)> {\n+    fn recv_from_with_flags(\n+        &self,\n+        buf: &mut [u8],\n+        flags: c_int,\n+    ) -> io::Result<(usize, SocketAddr)> {\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n \n         let n = cvt(unsafe {\n-            libc::recvfrom(self.0.raw(),\n-                        buf.as_mut_ptr() as *mut c_void,\n-                        buf.len(),\n-                        flags,\n-                        &mut storage as *mut _ as *mut _,\n-                        &mut addrlen)\n+            libc::recvfrom(\n+                self.0.raw(),\n+                buf.as_mut_ptr() as *mut c_void,\n+                buf.len(),\n+                flags,\n+                &mut storage as *mut _ as *mut _,\n+                &mut addrlen,\n+            )\n         })?;\n         Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n     }\n@@ -211,8 +207,10 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                              \"cannot set a 0 duration timeout\"));\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::InvalidInput,\n+                        \"cannot set a 0 duration timeout\",\n+                    ));\n                 }\n \n                 let secs = if dur.as_secs() > libc::time_t::max_value() as u64 {\n@@ -229,12 +227,7 @@ impl Socket {\n                 }\n                 timeout\n             }\n-            None => {\n-                libc::timeval {\n-                    tv_sec: 0,\n-                    tv_usec: 0,\n-                }\n-            }\n+            None => libc::timeval { tv_sec: 0, tv_usec: 0 },\n         };\n         setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n     }\n@@ -276,24 +269,26 @@ impl Socket {\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n-        if raw == 0 {\n-            Ok(None)\n-        } else {\n-            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n-        }\n+        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n     }\n }\n \n impl AsInner<c_int> for Socket {\n-    fn as_inner(&self) -> &c_int { self.0.as_inner() }\n+    fn as_inner(&self) -> &c_int {\n+        self.0.as_inner()\n+    }\n }\n \n impl FromInner<c_int> for Socket {\n-    fn from_inner(fd: c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+    fn from_inner(fd: c_int) -> Socket {\n+        Socket(FileDesc::new(fd))\n+    }\n }\n \n impl IntoInner<c_int> for Socket {\n-    fn into_inner(self) -> c_int { self.0.into_raw() }\n+    fn into_inner(self) -> c_int {\n+        self.0.into_raw()\n+    }\n }\n \n // In versions of glibc prior to 2.26, there's a bug where the DNS resolver\n@@ -314,7 +309,7 @@ impl IntoInner<c_int> for Socket {\n // believe it's thread-safe).\n #[cfg(target_env = \"gnu\")]\n fn on_resolver_failure() {\n-/*\n+    /*\n     use crate::sys;\n \n     // If the version fails to parse, we treat it the same as \"not glibc\"."}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/vxworks/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "b72a6554551579b8dc0516ea00047205fbf9d0e2", "filename": "src/libstd/sys/vxworks/pipe.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n-use libc::{self /*, c_int apparently not used? */};\n use crate::mem;\n-use crate::sync::atomic::{AtomicBool};\n+use crate::sync::atomic::AtomicBool;\n use crate::sys::fd::FileDesc;\n use crate::sys::{cvt, cvt_r};\n+use libc::{self /*, c_int apparently not used? */};\n \n pub struct AnonPipe(FileDesc);\n \n@@ -25,29 +25,29 @@ impl AnonPipe {\n         self.0.read(buf)\n     }\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-                self.0.read_vectored(bufs)\n-        }\n+        self.0.read_vectored(bufs)\n+    }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n \n-        pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-                self.0.write_vectored(bufs)\n-        }\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n \n-    pub fn fd(&self) -> &FileDesc { &self.0 }\n-    pub fn into_fd(self) -> FileDesc { self.0 }\n+    pub fn fd(&self) -> &FileDesc {\n+        &self.0\n+    }\n+    pub fn into_fd(self) -> FileDesc {\n+        self.0\n+    }\n     pub fn diverge(&self) -> ! {\n         panic!()\n-     }\n+    }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             v1: &mut Vec<u8>,\n-             p2: AnonPipe,\n-             v2: &mut Vec<u8>) -> io::Result<()> {\n-\n+pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n     // Set both pipes into nonblocking mode as we're gonna be reading from both\n     // in the `select` loop below, and we wouldn't want one to block the other!\n     let p1 = p1.into_fd();\n@@ -83,8 +83,9 @@ pub fn read2(p1: AnonPipe,\n         match fd.read_to_end(dst) {\n             Ok(_) => Ok(true),\n             Err(e) => {\n-                if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n-                   e.raw_os_error() == Some(libc::EAGAIN) {\n+                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n+                    || e.raw_os_error() == Some(libc::EAGAIN)\n+                {\n                     Ok(false)\n                 } else {\n                     Err(e)"}, {"sha": "c59782ff44b0bc27c00e3c9b850e26d37785c142", "filename": "src/libstd/sys/vxworks/process/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,4 +1,4 @@\n-pub use self::process_common::{Command, ExitStatus, ExitCode, Stdio, StdioPipes};\n+pub use self::process_common::{Command, ExitCode, ExitStatus, Stdio, StdioPipes};\n pub use self::process_inner::Process;\n pub use crate::ffi::OsString as EnvKey;\n "}, {"sha": "a8139a27537a973611a6abe0eeea927118872b1d", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,16 +1,16 @@\n use crate::os::unix::prelude::*;\n \n-use crate::ffi::{OsString, OsStr, CString, CStr};\n+use crate::collections::BTreeMap;\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::ptr;\n use crate::sys::fd::FileDesc;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys_common::process::CommandEnv;\n-use crate::collections::BTreeMap;\n \n-use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n+use libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -150,10 +150,7 @@ impl Command {\n         &mut self.closures\n     }\n \n-    pub unsafe fn pre_exec(\n-        &mut self,\n-        _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n-    ) {\n+    pub unsafe fn pre_exec(&mut self, _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n         // Fork() is not supported in vxWorks so no way to run the closure in the new procecss.\n         unimplemented!();\n     }\n@@ -183,26 +180,21 @@ impl Command {\n         self.env.have_changed_path()\n     }\n \n-    pub fn setup_io(&self, default: Stdio, needs_stdin: bool)\n-                -> io::Result<(StdioPipes, ChildPipes)> {\n+    pub fn setup_io(\n+        &self,\n+        default: Stdio,\n+        needs_stdin: bool,\n+    ) -> io::Result<(StdioPipes, ChildPipes)> {\n         let null = Stdio::Null;\n-        let default_stdin = if needs_stdin {&default} else {&null};\n+        let default_stdin = if needs_stdin { &default } else { &null };\n         let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n         let stdout = self.stdout.as_ref().unwrap_or(&default);\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n         let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n         let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n         let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n-        let ours = StdioPipes {\n-            stdin: our_stdin,\n-            stdout: our_stdout,\n-            stderr: our_stderr,\n-        };\n-        let theirs = ChildPipes {\n-            stdin: their_stdin,\n-            stdout: their_stdout,\n-            stderr: their_stderr,\n-        };\n+        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n+        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n         Ok((ours, theirs))\n     }\n }\n@@ -217,21 +209,21 @@ fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n // Helper type to manage ownership of the strings within a C-style array.\n pub struct CStringArray {\n     items: Vec<CString>,\n-    ptrs: Vec<*const c_char>\n+    ptrs: Vec<*const c_char>,\n }\n \n impl CStringArray {\n     pub fn with_capacity(capacity: usize) -> Self {\n         let mut result = CStringArray {\n             items: Vec::with_capacity(capacity),\n-            ptrs: Vec::with_capacity(capacity+1)\n+            ptrs: Vec::with_capacity(capacity + 1),\n         };\n         result.ptrs.push(ptr::null());\n         result\n     }\n     pub fn push(&mut self, item: CString) {\n         let l = self.ptrs.len();\n-        self.ptrs[l-1] = item.as_ptr();\n+        self.ptrs[l - 1] = item.as_ptr();\n         self.ptrs.push(ptr::null());\n         self.items.push(item);\n     }\n@@ -262,12 +254,9 @@ fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStr\n }\n \n impl Stdio {\n-    pub fn to_child_stdio(&self, readable: bool)\n-                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n         match *self {\n-            Stdio::Inherit => {\n-                Ok((ChildStdio::Inherit, None))\n-            },\n+            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n \n             // Make sure that the source descriptors are not an stdio\n             // descriptor, otherwise the order which we set the child's\n@@ -286,21 +275,15 @@ impl Stdio {\n \n             Stdio::MakePipe => {\n                 let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if readable {\n-                    (writer, reader)\n-                } else {\n-                    (reader, writer)\n-                };\n+                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                 Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n             }\n \n             Stdio::Null => {\n                 let mut opts = OpenOptions::new();\n                 opts.read(readable);\n                 opts.write(!readable);\n-                let path = unsafe {\n-                    CStr::from_ptr(\"/null\\0\".as_ptr() as *const _)\n-                };\n+                let path = unsafe { CStr::from_ptr(\"/null\\0\".as_ptr() as *const _) };\n                 let fd = File::open_c(&path, &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n@@ -350,7 +333,8 @@ impl ExitStatus {\n     }\n \n     fn exited(&self) -> bool {\n-        /*unsafe*/ { libc::WIFEXITED(self.0) }\n+        /*unsafe*/\n+        { libc::WIFEXITED(self.0) }\n     }\n \n     pub fn success(&self) -> bool {"}, {"sha": "87ebd2c9593fc936a10fd699ecb3346aad22ea9d", "filename": "src/libstd/sys/vxworks/rand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -4,17 +4,16 @@ use crate::slice;\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut v = (0, 0);\n     unsafe {\n-        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8,\n-                                             mem::size_of_val(&v));\n+        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8, mem::size_of_val(&v));\n         imp::fill_bytes(view);\n     }\n-    return v\n+    return v;\n }\n \n mod imp {\n-    use libc;\n     use crate::io;\n     use core::sync::atomic::{AtomicBool, Ordering::Relaxed};\n+    use libc;\n \n     pub fn fill_bytes(v: &mut [u8]) {\n         static RNG_INIT: AtomicBool = AtomicBool::new(false);"}, {"sha": "fd2e1a6e7bcfb99311ac2d4a9d50ce1c3e8e279a", "filename": "src/libstd/sys/vxworks/rwlock.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,6 +1,6 @@\n-use libc;\n use crate::cell::UnsafeCell;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n+use libc;\n \n pub struct RWLock {\n     inner: UnsafeCell<libc::pthread_rwlock_t>,\n@@ -29,7 +29,7 @@ impl RWLock {\n             if r == 0 {\n                 self.raw_unlock();\n             }\n-        panic!(\"rwlock read lock would result in deadlock\");\n+            panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n             self.num_readers.fetch_add(1, Ordering::Relaxed);\n@@ -57,12 +57,14 @@ impl RWLock {\n         let r = libc::pthread_rwlock_wrlock(self.inner.get());\n         // See comments above for why we check for EDEADLK and write_locked. We\n         // also need to check that num_readers is 0.\n-        if r == libc::EDEADLK || *self.write_locked.get() ||\n-            self.num_readers.load(Ordering::Relaxed) != 0 {\n+        if r == libc::EDEADLK\n+            || *self.write_locked.get()\n+            || self.num_readers.load(Ordering::Relaxed) != 0\n+        {\n             if r == 0 {\n                 self.raw_unlock();\n             }\n-        panic!(\"rwlock write lock would result in deadlock\");\n+            panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n         }\n@@ -80,8 +82,8 @@ impl RWLock {\n                 *self.write_locked.get() = true;\n                 true\n             }\n-            } else {\n-                false\n+        } else {\n+            false\n         }\n     }\n \n@@ -98,7 +100,7 @@ impl RWLock {\n         self.raw_unlock();\n     }\n \n-     #[inline]\n+    #[inline]\n     pub unsafe fn write_unlock(&self) {\n         debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n         debug_assert!(*self.write_locked.get());"}, {"sha": "7b58c83193bf3579d484798a21d6c125a378d6d9", "filename": "src/libstd/sys/vxworks/stack_overflow.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,12 +1,12 @@\n #![cfg_attr(test, allow(dead_code))]\n \n-use self::imp::{make_handler, drop_handler};\n+use self::imp::{drop_handler, make_handler};\n \n pub use self::imp::cleanup;\n pub use self::imp::init;\n \n pub struct Handler {\n-    _data: *mut libc::c_void\n+    _data: *mut libc::c_void,\n }\n \n impl Handler {\n@@ -26,16 +26,13 @@ impl Drop for Handler {\n mod imp {\n     use crate::ptr;\n \n-    pub unsafe fn init() {\n-    }\n+    pub unsafe fn init() {}\n \n-    pub unsafe fn cleanup() {\n-    }\n+    pub unsafe fn cleanup() {}\n \n     pub unsafe fn make_handler() -> super::Handler {\n         super::Handler { _data: ptr::null_mut() }\n     }\n \n-    pub unsafe fn drop_handler(_handler: &mut super::Handler) {\n-    }\n+    pub unsafe fn drop_handler(_handler: &mut super::Handler) {}\n }"}, {"sha": "622444ccafd3cd0d97d4426b8e515951b82d1c77", "filename": "src/libstd/sys/vxworks/stdio.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -6,7 +6,9 @@ pub struct Stdout(());\n pub struct Stderr(());\n \n impl Stdin {\n-    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin(()))\n+    }\n }\n \n impl io::Read for Stdin {\n@@ -19,7 +21,9 @@ impl io::Read for Stdin {\n }\n \n impl Stdout {\n-    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout(()))\n+    }\n }\n \n impl io::Write for Stdout {\n@@ -36,7 +40,9 @@ impl io::Write for Stdout {\n }\n \n impl Stderr {\n-    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr(()))\n+    }\n }\n \n impl io::Write for Stderr {"}, {"sha": "e0d104b5f3ec938a6fd3c6e934c52cb09478df98", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -21,24 +21,24 @@ unsafe impl Sync for Thread {}\n \n // The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n // so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n-unsafe fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                    stack_size: libc::size_t) -> libc::c_int {\n+unsafe fn pthread_attr_setstacksize(\n+    attr: *mut libc::pthread_attr_t,\n+    stack_size: libc::size_t,\n+) -> libc::c_int {\n     libc::pthread_attr_setstacksize(attr, stack_size)\n }\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n-                          -> io::Result<Thread> {\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         let p = box p;\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n \n-        match pthread_attr_setstacksize(&mut attr,\n-                                        stack_size) {\n+        match pthread_attr_setstacksize(&mut attr, stack_size) {\n             0 => {}\n             n => {\n                 assert_eq!(n, libc::EINVAL);\n@@ -47,15 +47,13 @@ impl Thread {\n                 // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                 // Round up to the nearest page and try again.\n                 let page_size = os::page_size();\n-                let stack_size = (stack_size + page_size - 1) &\n-                                 (-(page_size as isize - 1) as usize - 1);\n-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr,\n-                                                           stack_size), 0);\n+                let stack_size =\n+                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n+                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start,\n-                                       &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n@@ -65,8 +63,10 @@ impl Thread {\n             Ok(Thread { id: native })\n         };\n \n-        extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n-            unsafe { start_thread(main as *mut u8); }\n+        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n             ptr::null_mut()\n         }\n     }\n@@ -108,12 +108,13 @@ impl Thread {\n         unsafe {\n             let ret = libc::pthread_join(self.id, ptr::null_mut());\n             mem::forget(self);\n-            assert!(ret == 0,\n-                    \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n+            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n         }\n     }\n \n-    pub fn id(&self) -> libc::pthread_t { self.id }\n+    pub fn id(&self) -> libc::pthread_t {\n+        self.id\n+    }\n \n     pub fn into_id(self) -> libc::pthread_t {\n         let id = self.id;\n@@ -133,8 +134,12 @@ impl Drop for Thread {\n pub mod guard {\n     use crate::ops::Range;\n     pub type Guard = Range<usize>;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n     pub unsafe fn deinit() {}\n }\n "}, {"sha": "2c5b94b1e61e5710717363d92396c6b5e1027305", "filename": "src/libstd/sys/vxworks/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -5,7 +5,7 @@ use crate::mem;\n pub type Key = libc::pthread_key_t;\n \n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n     assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n     key"}, {"sha": "8ebbf89213f321bfbdf27111ec4e3d86a57a0ef5", "filename": "src/libstd/sys/vxworks/time.rs", "status": "modified", "additions": 28, "deletions": 53, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n use crate::cmp::Ordering;\n-use libc;\n use crate::time::Duration;\n use ::core::hash::{Hash, Hasher};\n+use libc;\n \n pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n use crate::convert::TryInto;\n@@ -15,20 +15,21 @@ struct Timespec {\n \n impl Timespec {\n     const fn zero() -> Timespec {\n-        Timespec {\n-            t: libc::timespec { tv_sec: 0, tv_nsec: 0 },\n-        }\n+        Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } }\n     }\n     fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n         if self >= other {\n             Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n-                                (self.t.tv_nsec - other.t.tv_nsec) as u32)\n-                } else {\n-                    Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                        self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n-                        other.t.tv_nsec as u32)\n-                })\n+                Duration::new(\n+                    (self.t.tv_sec - other.t.tv_sec) as u64,\n+                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n+                )\n+            } else {\n+                Duration::new(\n+                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n+                )\n+            })\n         } else {\n             match other.sub_timespec(self) {\n                 Ok(d) => Err(d),\n@@ -51,12 +52,7 @@ impl Timespec {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n         }\n-        Some(Timespec {\n-            t: libc::timespec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as _,\n-            },\n-        })\n+        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n     }\n \n     fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n@@ -72,12 +68,7 @@ impl Timespec {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n         }\n-        Some(Timespec {\n-            t: libc::timespec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as _,\n-            },\n-        })\n+        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n     }\n }\n \n@@ -104,16 +95,16 @@ impl Ord for Timespec {\n }\n \n impl Hash for Timespec {\n-    fn hash<H : Hasher>(&self, state: &mut H) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         self.t.tv_sec.hash(state);\n         self.t.tv_nsec.hash(state);\n     }\n }\n mod inner {\n     use crate::fmt;\n-    use libc;\n     use crate::sys::cvt;\n     use crate::time::Duration;\n+    use libc;\n \n     use super::Timespec;\n \n@@ -127,24 +118,16 @@ mod inner {\n         t: Timespec,\n     }\n \n-    pub const UNIX_EPOCH: SystemTime = SystemTime {\n-        t: Timespec {\n-            t: libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 0,\n-            },\n-        },\n-    };\n+    pub const UNIX_EPOCH: SystemTime =\n+        SystemTime { t: Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } } };\n \n     impl Instant {\n         pub fn now() -> Instant {\n             Instant { t: now(libc::CLOCK_MONOTONIC) }\n         }\n \n         pub const fn zero() -> Instant {\n-            Instant {\n-                t: Timespec::zero(),\n-            }\n+            Instant { t: Timespec::zero() }\n         }\n \n         pub fn actually_monotonic() -> bool {\n@@ -167,9 +150,9 @@ mod inner {\n     impl fmt::Debug for Instant {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"Instant\")\n-             .field(\"tv_sec\", &self.t.t.tv_sec)\n-             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-             .finish()\n+                .field(\"tv_sec\", &self.t.t.tv_sec)\n+                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+                .finish()\n         }\n     }\n \n@@ -178,8 +161,7 @@ mod inner {\n             SystemTime { t: now(libc::CLOCK_REALTIME) }\n         }\n \n-        pub fn sub_time(&self, other: &SystemTime)\n-                        -> Result<Duration, Duration> {\n+        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n             self.t.sub_timespec(&other.t)\n         }\n \n@@ -201,24 +183,17 @@ mod inner {\n     impl fmt::Debug for SystemTime {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"SystemTime\")\n-             .field(\"tv_sec\", &self.t.t.tv_sec)\n-             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-             .finish()\n+                .field(\"tv_sec\", &self.t.t.tv_sec)\n+                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+                .finish()\n         }\n     }\n \n     pub type clock_t = libc::c_int;\n \n     fn now(clock: clock_t) -> Timespec {\n-        let mut t = Timespec {\n-            t: libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 0,\n-            }\n-        };\n-        cvt(unsafe {\n-            libc::clock_gettime(clock, &mut t.t)\n-        }).unwrap();\n+        let mut t = Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } };\n+        cvt(unsafe { libc::clock_gettime(clock, &mut t.t) }).unwrap();\n         t\n     }\n }"}, {"sha": "4c6fddefd3f84c938e2a1ff2a6ffad202022e421", "filename": "src/libstd/sys/vxworks/weak.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -29,11 +29,7 @@ pub struct Weak<F> {\n \n impl<F> Weak<F> {\n     pub const fn new(name: &'static str) -> Weak<F> {\n-        Weak {\n-            name,\n-            addr: AtomicUsize::new(1),\n-            _marker: marker::PhantomData,\n-        }\n+        Weak { name, addr: AtomicUsize::new(1), _marker: marker::PhantomData }\n     }\n \n     pub fn get(&self) -> Option<F> {\n@@ -56,5 +52,5 @@ unsafe fn fetch(name: &str) -> usize {\n         Err(..) => return 0,\n     };\n     assert!(false, \"FIXME: fetch\");\n-   libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n+    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n }"}, {"sha": "e9760d050e105fbe04e9d5ff315152c711607fd3", "filename": "src/libstd/sys/wasi/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,6 +1,6 @@\n use crate::alloc::{GlobalAlloc, Layout, System};\n use crate::ptr;\n-use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n use libc;\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]"}, {"sha": "5f8b1cbfa0b5314a37a4355318a52996a84ad344", "filename": "src/libstd/sys/wasi/ext/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -7,12 +7,16 @@ pub mod io;\n /// Includes all extension traits, and some important type definitions.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use crate::sys::ext::ffi::{OsStringExt, OsStrExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use crate::sys::ext::fs::{FileExt, DirEntryExt, MetadataExt, OpenOptionsExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use crate::sys::ext::fs::FileTypeExt;\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use crate::sys::ext::io::{AsRawFd, IntoRawFd, FromRawFd};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::fs::{DirEntryExt, FileExt, MetadataExt, OpenOptionsExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::io::{AsRawFd, FromRawFd, IntoRawFd};\n }"}, {"sha": "8a69028ff1dcf42e2bb01b399fb0ec5da36cb3ff", "filename": "src/libstd/sys/wasi/net.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fnet.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,11 +1,11 @@\n+use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n-use crate::time::Duration;\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n+use crate::sys::fd::WasiFd;\n use crate::sys::{unsupported, Void};\n-use crate::convert::TryFrom;\n-use crate::sys::fd::{WasiFd};\n use crate::sys_common::FromInner;\n+use crate::time::Duration;\n \n pub struct TcpStream {\n     fd: WasiFd,\n@@ -107,24 +107,18 @@ impl TcpStream {\n \n impl FromInner<u32> for TcpStream {\n     fn from_inner(fd: u32) -> TcpStream {\n-        unsafe {\n-            TcpStream {\n-                fd: WasiFd::from_raw(fd),\n-            }\n-        }\n+        unsafe { TcpStream { fd: WasiFd::from_raw(fd) } }\n     }\n }\n \n impl fmt::Debug for TcpStream {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TcpStream\")\n-            .field(\"fd\", &self.fd.as_raw())\n-            .finish()\n+        f.debug_struct(\"TcpStream\").field(\"fd\", &self.fd.as_raw()).finish()\n     }\n }\n \n pub struct TcpListener {\n-    fd: WasiFd\n+    fd: WasiFd,\n }\n \n impl TcpListener {\n@@ -179,19 +173,13 @@ impl TcpListener {\n \n impl FromInner<u32> for TcpListener {\n     fn from_inner(fd: u32) -> TcpListener {\n-        unsafe {\n-            TcpListener {\n-                fd: WasiFd::from_raw(fd),\n-            }\n-        }\n+        unsafe { TcpListener { fd: WasiFd::from_raw(fd) } }\n     }\n }\n \n impl fmt::Debug for TcpListener {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TcpListener\")\n-            .field(\"fd\", &self.fd.as_raw())\n-            .finish()\n+        f.debug_struct(\"TcpListener\").field(\"fd\", &self.fd.as_raw()).finish()\n     }\n }\n \n@@ -276,23 +264,19 @@ impl UdpSocket {\n         unsupported()\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         unsupported()\n     }\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         unsupported()\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         unsupported()\n     }\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         unsupported()\n     }\n \n@@ -339,19 +323,13 @@ impl UdpSocket {\n \n impl FromInner<u32> for UdpSocket {\n     fn from_inner(fd: u32) -> UdpSocket {\n-        unsafe {\n-            UdpSocket {\n-                fd: WasiFd::from_raw(fd),\n-            }\n-        }\n+        unsafe { UdpSocket { fd: WasiFd::from_raw(fd) } }\n     }\n }\n \n impl fmt::Debug for UdpSocket {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"UdpSocket\")\n-            .field(\"fd\", &self.fd.as_raw())\n-            .finish()\n+        f.debug_struct(\"UdpSocket\").field(\"fd\", &self.fd.as_raw()).finish()\n     }\n }\n \n@@ -419,8 +397,7 @@ pub mod netc {\n     }\n \n     #[derive(Copy, Clone)]\n-    pub struct sockaddr {\n-    }\n+    pub struct sockaddr {}\n \n     pub type socklen_t = usize;\n }"}, {"sha": "338fbe89765149636c1d6f302d742bcfea083e7c", "filename": "src/libstd/sys/wasi/os.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,6 +1,6 @@\n use crate::any::Any;\n use crate::error::Error as StdError;\n-use crate::ffi::{OsString, OsStr, CString, CStr};\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n@@ -19,7 +19,7 @@ pub unsafe fn env_lock() -> impl Any {\n }\n \n pub fn errno() -> i32 {\n-    extern {\n+    extern \"C\" {\n         #[thread_local]\n         static errno: libc::c_int;\n     }\n@@ -64,7 +64,9 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     Err(JoinPathsError)\n }\n@@ -91,11 +93,14 @@ pub struct Env {\n \n impl Iterator for Env {\n     type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n-\n pub fn env() -> Env {\n     unsafe {\n         let _guard = env_lock();\n@@ -107,10 +112,7 @@ pub fn env() -> Env {\n             }\n             environ = environ.offset(1);\n         }\n-        return Env {\n-            iter: result.into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        }\n+        return Env { iter: result.into_iter(), _dont_send_or_sync_me: PhantomData };\n     }\n \n     // See src/libstd/sys/unix/os.rs, same as that\n@@ -119,10 +121,12 @@ pub fn env() -> Env {\n             return None;\n         }\n         let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n-        pos.map(|p| (\n-            OsStringExt::from_vec(input[..p].to_vec()),\n-            OsStringExt::from_vec(input[p+1..].to_vec()),\n-        ))\n+        pos.map(|p| {\n+            (\n+                OsStringExt::from_vec(input[..p].to_vec()),\n+                OsStringExt::from_vec(input[p + 1..].to_vec()),\n+            )\n+        })\n     }\n }\n \n@@ -168,9 +172,7 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(code: i32) -> ! {\n-    unsafe {\n-        libc::exit(code)\n-    }\n+    unsafe { libc::exit(code) }\n }\n \n pub fn getpid() -> u32 {\n@@ -193,9 +195,5 @@ macro_rules! impl_is_minus_one {\n impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n-    if t.is_minus_one() {\n-        Err(io::Error::last_os_error())\n-    } else {\n-        Ok(t)\n-    }\n+    if t.is_minus_one() { Err(io::Error::last_os_error()) } else { Ok(t) }\n }"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/wasi/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fpath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "fb14dc591018116ea405550f4697f60378b2d7e8", "filename": "src/libstd/sys/wasi/pipe.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fpipe.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -25,9 +25,6 @@ impl AnonPipe {\n     }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             _v1: &mut Vec<u8>,\n-             _p2: AnonPipe,\n-             _v2: &mut Vec<u8>) -> io::Result<()> {\n+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n     match p1.0 {}\n }"}, {"sha": "7156c9ab92f2b6af3da9699a3618f76275280af1", "filename": "src/libstd/sys/wasi/process.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -13,7 +13,7 @@ pub use crate::ffi::OsString as EnvKey;\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Command {\n-    env: CommandEnv\n+    env: CommandEnv,\n }\n \n // passed back to std::process with the pipes connected to the child, if any\n@@ -32,32 +32,28 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default()\n-        }\n+        Command { env: Default::default() }\n     }\n \n-    pub fn arg(&mut self, _arg: &OsStr) {\n-    }\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n \n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n-    pub fn cwd(&mut self, _dir: &OsStr) {\n-    }\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n \n-    pub fn stdin(&mut self, _stdin: Stdio) {\n-    }\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n \n-    pub fn stdout(&mut self, _stdout: Stdio) {\n-    }\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n \n-    pub fn stderr(&mut self, _stderr: Stdio) {\n-    }\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n \n-    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n-        -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         unsupported()\n     }\n }\n@@ -106,8 +102,7 @@ impl PartialEq for ExitStatus {\n     }\n }\n \n-impl Eq for ExitStatus {\n-}\n+impl Eq for ExitStatus {}\n \n impl fmt::Debug for ExitStatus {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "3b6557ae3257f73b1497af9e1ddbd858c39664aa", "filename": "src/libstd/sys/wasm/args.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -6,14 +6,10 @@ pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n     // On wasm these should always be null, so there's nothing for us to do here\n }\n \n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}\n \n pub fn args() -> Args {\n-    Args {\n-        iter: Vec::new().into_iter(),\n-        _dont_send_or_sync_me: PhantomData,\n-    }\n+    Args { iter: Vec::new().into_iter(), _dont_send_or_sync_me: PhantomData }\n }\n \n pub struct Args {"}, {"sha": "304cf906b2aeadba92007440bb5628e3c9ed8184", "filename": "src/libstd/sys/wasm/cmath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n // These symbols are all defined in `compiler-builtins`\n-extern {\n+extern \"C\" {\n     pub fn acos(n: f64) -> f64;\n     pub fn acosf(n: f32) -> f32;\n     pub fn asin(n: f64) -> f64;"}, {"sha": "e6160d1457d269176ba95e96409b6eda799d4bb7", "filename": "src/libstd/sys/wasm/fs.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::io::{self, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sys::time::SystemTime;\n use crate::sys::{unsupported, Void};\n@@ -15,14 +15,14 @@ pub struct ReadDir(Void);\n pub struct DirEntry(Void);\n \n #[derive(Clone, Debug)]\n-pub struct OpenOptions { }\n+pub struct OpenOptions {}\n \n pub struct FilePermissions(Void);\n \n pub struct FileType(Void);\n \n #[derive(Debug)]\n-pub struct DirBuilder { }\n+pub struct DirBuilder {}\n \n impl FileAttr {\n     pub fn size(&self) -> u64 {\n@@ -78,8 +78,7 @@ impl PartialEq for FilePermissions {\n     }\n }\n \n-impl Eq for FilePermissions {\n-}\n+impl Eq for FilePermissions {}\n \n impl fmt::Debug for FilePermissions {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -115,8 +114,7 @@ impl PartialEq for FileType {\n     }\n }\n \n-impl Eq for FileType {\n-}\n+impl Eq for FileType {}\n \n impl Hash for FileType {\n     fn hash<H: Hasher>(&self, _h: &mut H) {\n@@ -164,15 +162,15 @@ impl DirEntry {\n \n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n-        OpenOptions { }\n+        OpenOptions {}\n     }\n \n-    pub fn read(&mut self, _read: bool) { }\n-    pub fn write(&mut self, _write: bool) { }\n-    pub fn append(&mut self, _append: bool) { }\n-    pub fn truncate(&mut self, _truncate: bool) { }\n-    pub fn create(&mut self, _create: bool) { }\n-    pub fn create_new(&mut self, _create_new: bool) { }\n+    pub fn read(&mut self, _read: bool) {}\n+    pub fn write(&mut self, _write: bool) {}\n+    pub fn append(&mut self, _append: bool) {}\n+    pub fn truncate(&mut self, _truncate: bool) {}\n+    pub fn create(&mut self, _create: bool) {}\n+    pub fn create_new(&mut self, _create_new: bool) {}\n }\n \n impl File {\n@@ -235,7 +233,7 @@ impl File {\n \n impl DirBuilder {\n     pub fn new() -> DirBuilder {\n-        DirBuilder { }\n+        DirBuilder {}\n     }\n \n     pub fn mkdir(&self, _p: &Path) -> io::Result<()> {"}, {"sha": "b7c3108f172f608c743b79e5c64390791b3d471d", "filename": "src/libstd/sys/wasm/net.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n+use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n-use crate::time::Duration;\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::sys::{unsupported, Void};\n-use crate::convert::TryFrom;\n+use crate::time::Duration;\n \n pub struct TcpStream(Void);\n \n@@ -228,23 +228,19 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n@@ -351,8 +347,7 @@ pub mod netc {\n     }\n \n     #[derive(Copy, Clone)]\n-    pub struct sockaddr {\n-    }\n+    pub struct sockaddr {}\n \n     pub type socklen_t = usize;\n }"}, {"sha": "193c3892743c480b53a59acefdab8b6f638fd8d4", "filename": "src/libstd/sys/wasm/os.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n use crate::error::Error as StdError;\n-use crate::ffi::{OsString, OsStr};\n+use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::path::{self, PathBuf};\n@@ -39,7 +39,9 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     Err(JoinPathsError)\n }"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/wasm/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "fb14dc591018116ea405550f4697f60378b2d7e8", "filename": "src/libstd/sys/wasm/pipe.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -25,9 +25,6 @@ impl AnonPipe {\n     }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             _v1: &mut Vec<u8>,\n-             _p2: AnonPipe,\n-             _v2: &mut Vec<u8>) -> io::Result<()> {\n+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n     match p1.0 {}\n }"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/wasm/process.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -32,32 +32,28 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default()\n-        }\n+        Command { env: Default::default() }\n     }\n \n-    pub fn arg(&mut self, _arg: &OsStr) {\n-    }\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n \n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n-    pub fn cwd(&mut self, _dir: &OsStr) {\n-    }\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n \n-    pub fn stdin(&mut self, _stdin: Stdio) {\n-    }\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n \n-    pub fn stdout(&mut self, _stdout: Stdio) {\n-    }\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n \n-    pub fn stderr(&mut self, _stderr: Stdio) {\n-    }\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n \n-    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n-        -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         unsupported()\n     }\n }\n@@ -106,8 +102,7 @@ impl PartialEq for ExitStatus {\n     }\n }\n \n-impl Eq for ExitStatus {\n-}\n+impl Eq for ExitStatus {}\n \n impl fmt::Debug for ExitStatus {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "cbf62b6e5b7e36eb108b76a699316304ae221026", "filename": "src/libstd/sys/wasm/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -6,8 +6,6 @@ impl Handler {\n     }\n }\n \n-pub unsafe fn init() {\n-}\n+pub unsafe fn init() {}\n \n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}"}, {"sha": "0e0e78a827670bfb265b13165be10a37ad94a82e", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -9,9 +9,7 @@ pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         unsupported()\n     }\n \n@@ -55,8 +53,12 @@ impl Thread {\n \n pub mod guard {\n     pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }\n \n // This is only used by atomics primitives when the `atomics` feature is\n@@ -84,9 +86,7 @@ pub fn my_id() -> u32 {\n         if MY_ID == 0 {\n             let mut cur = NEXT_ID.load(SeqCst);\n             MY_ID = loop {\n-                let next = cur.checked_add(1).unwrap_or_else(|| {\n-                    crate::arch::wasm32::unreachable()\n-                });\n+                let next = cur.checked_add(1).unwrap_or_else(|| crate::arch::wasm32::unreachable());\n                 match NEXT_ID.compare_exchange(cur, next, SeqCst, SeqCst) {\n                     Ok(_) => break next,\n                     Err(i) => cur = i,"}, {"sha": "f8be9863ed56f69713e88c98fdfd8b4a6037f2e6", "filename": "src/libstd/sys/wasm/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n pub type Key = usize;\n \n #[inline]\n-pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(_dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     panic!(\"should not be used on the wasm target\");\n }\n "}, {"sha": "d9edc7fdc44518205c86ee6d929619ffc3de7f0c", "filename": "src/libstd/sys/wasm/time.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -39,8 +39,7 @@ impl SystemTime {\n         panic!(\"time not implemented on wasm32-unknown-unknown\")\n     }\n \n-    pub fn sub_time(&self, other: &SystemTime)\n-                    -> Result<Duration, Duration> {\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n         self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n     }\n "}, {"sha": "99b4d6c72a0e3e036e78a9d83e61594df833ebe8", "filename": "src/libstd/sys/windows/alloc.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,6 +1,6 @@\n use crate::alloc::{GlobalAlloc, Layout, System};\n use crate::sys::c;\n-use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n #[repr(C)]\n struct Header(*mut u8);\n@@ -18,16 +18,12 @@ unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n #[inline]\n unsafe fn allocate_with_flags(layout: Layout, flags: c::DWORD) -> *mut u8 {\n     if layout.align() <= MIN_ALIGN {\n-        return c::HeapAlloc(c::GetProcessHeap(), flags, layout.size()) as *mut u8\n+        return c::HeapAlloc(c::GetProcessHeap(), flags, layout.size()) as *mut u8;\n     }\n \n     let size = layout.size() + layout.align();\n     let ptr = c::HeapAlloc(c::GetProcessHeap(), flags, size);\n-    if ptr.is_null() {\n-        ptr as *mut u8\n-    } else {\n-        align_ptr(ptr as *mut u8, layout.align())\n-    }\n+    if ptr.is_null() { ptr as *mut u8 } else { align_ptr(ptr as *mut u8, layout.align()) }\n }\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n@@ -46,13 +42,11 @@ unsafe impl GlobalAlloc for System {\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         if layout.align() <= MIN_ALIGN {\n             let err = c::HeapFree(c::GetProcessHeap(), 0, ptr as c::LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                          c::GetLastError());\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n         } else {\n             let header = get_header(ptr);\n             let err = c::HeapFree(c::GetProcessHeap(), 0, header.0 as c::LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                          c::GetLastError());\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n         }\n     }\n "}, {"sha": "5fbea2a2910174c32c8ab9aacb71a00abb8b4712", "filename": "src/libstd/sys/windows/args.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,26 +1,26 @@\n #![allow(dead_code)] // runtime init functions not used during testing\n \n-use crate::os::windows::prelude::*;\n-use crate::sys::windows::os::current_exe;\n-use crate::sys::c;\n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::vec;\n-use crate::slice;\n+use crate::os::windows::prelude::*;\n use crate::path::PathBuf;\n+use crate::slice;\n+use crate::sys::c;\n+use crate::sys::windows::os::current_exe;\n+use crate::vec;\n \n use core::iter;\n \n-pub unsafe fn init(_argc: isize, _argv: *const *const u8) { }\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n \n-pub unsafe fn cleanup() { }\n+pub unsafe fn cleanup() {}\n \n pub fn args() -> Args {\n     unsafe {\n         let lp_cmd_line = c::GetCommandLineW();\n-        let parsed_args_list = parse_lp_cmd_line(\n-            lp_cmd_line as *const u16,\n-            || current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new()));\n+        let parsed_args_list = parse_lp_cmd_line(lp_cmd_line as *const u16, || {\n+            current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new())\n+        });\n \n         Args { parsed_args_list: parsed_args_list.into_iter() }\n     }\n@@ -40,8 +40,10 @@ pub fn args() -> Args {\n /// Windows 10 Pro v1803, using an exhaustive test suite available at\n /// <https://gist.github.com/notriddle/dde431930c392e428055b2dc22e638f5> or\n /// <https://paste.gg/p/anonymous/47d6ed5f5bd549168b1c69c799825223>.\n-unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_name: F)\n-                                                 -> Vec<OsString> {\n+unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(\n+    lp_cmd_line: *const u16,\n+    exe_name: F,\n+) -> Vec<OsString> {\n     const BACKSLASH: u16 = '\\\\' as u16;\n     const QUOTE: u16 = '\"' as u16;\n     const TAB: u16 = '\\t' as u16;\n@@ -84,7 +86,7 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n         0..=SPACE => {\n             ret_val.push(OsString::new());\n             &cmd_line[1..]\n-        },\n+        }\n         // The executable name ends at the next whitespace,\n         // no matter what.\n         _ => {\n@@ -112,7 +114,7 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n             BACKSLASH => {\n                 backslash_count += 1;\n                 was_in_quotes = false;\n-            },\n+            }\n             QUOTE if backslash_count % 2 == 0 => {\n                 cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n                 backslash_count = 0;\n@@ -171,30 +173,36 @@ impl<'a> fmt::Debug for ArgsInnerDebug<'a> {\n \n impl Args {\n     pub fn inner_debug(&self) -> ArgsInnerDebug<'_> {\n-        ArgsInnerDebug {\n-            args: self\n-        }\n+        ArgsInnerDebug { args: self }\n     }\n }\n \n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.parsed_args_list.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.parsed_args_list.size_hint() }\n+    fn next(&mut self) -> Option<OsString> {\n+        self.parsed_args_list.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.parsed_args_list.size_hint()\n+    }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.parsed_args_list.next_back() }\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.parsed_args_list.next_back()\n+    }\n }\n \n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.parsed_args_list.len() }\n+    fn len(&self) -> usize {\n+        self.parsed_args_list.len()\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::sys::windows::args::*;\n     use crate::ffi::OsString;\n+    use crate::sys::windows::args::*;\n \n     fn chk(string: &str, parts: &[&str]) {\n         let mut wide: Vec<u16> = OsString::from(string).encode_wide().collect();\n@@ -245,14 +253,14 @@ mod tests {\n         chk(r#\"EXE \"\" \"\"\"\"#, &[\"EXE\", \"\", \"\\\"\"]);\n         chk(\n             r#\"EXE \"this is \"\"\"all\"\"\" in the same argument\"\"#,\n-            &[\"EXE\", \"this is \\\"all\\\" in the same argument\"]\n+            &[\"EXE\", \"this is \\\"all\\\" in the same argument\"],\n         );\n         chk(r#\"EXE \"a\"\"\"#, &[\"EXE\", \"a\\\"\"]);\n         chk(r#\"EXE \"a\"\" a\"#, &[\"EXE\", \"a\\\"\", \"a\"]);\n         // quotes cannot be escaped in command names\n         chk(r#\"\"EXE\" check\"#, &[\"EXE\", \"check\"]);\n         chk(r#\"\"EXE check\"\"#, &[\"EXE check\"]);\n         chk(r#\"\"EXE \"\"\"for\"\"\" check\"#, &[\"EXE \", r#\"for\"\"#, \"check\"]);\n-        chk(r#\"\"EXE \\\"for\\\" check\"#, &[r#\"EXE \\\"#, r#\"for\"\"#,  \"check\"]);\n+        chk(r#\"\"EXE \\\"for\\\" check\"#, &[r#\"EXE \\\"#, r#\"for\"\"#, \"check\"]);\n     }\n }"}, {"sha": "7c5bfa1bd06410ff6fe339689864639aec9691af", "filename": "src/libstd/sys/windows/cmath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,9 +1,9 @@\n #![cfg(not(test))]\n \n-use libc::{c_float, c_double};\n+use libc::{c_double, c_float};\n \n #[link_name = \"m\"]\n-extern {\n+extern \"C\" {\n     pub fn acos(n: c_double) -> c_double;\n     pub fn asin(n: c_double) -> c_double;\n     pub fn atan(n: c_double) -> c_double;\n@@ -32,7 +32,7 @@ pub use self::shims::*;\n mod shims {\n     use libc::c_float;\n \n-    extern {\n+    extern \"C\" {\n         pub fn acosf(n: c_float) -> c_float;\n         pub fn asinf(n: c_float) -> c_float;\n         pub fn atan2f(a: c_float, b: c_float) -> c_float;"}, {"sha": "d6d433f9d086b0992d758d940ee7c653a862daa0", "filename": "src/libstd/sys/windows/compat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -28,8 +28,7 @@ pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n     }\n }\n \n-pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n-                  fallback: usize) -> usize {\n+pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str, fallback: usize) -> usize {\n     let value = lookup(module, symbol).unwrap_or(fallback);\n     ptr.store(value, Ordering::SeqCst);\n     value"}, {"sha": "6e78119383f43fe12899be0b2537457d022058c3", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -59,10 +59,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::ffi::{OsString, OsStr};\n+use crate::ffi::{OsStr, OsString};\n use crate::sys::os_str::Buf;\n use crate::sys_common::wtf8::Wtf8Buf;\n-use crate::sys_common::{FromInner, AsInner};\n+use crate::sys_common::{AsInner, FromInner};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::sys_common::wtf8::EncodeWide;"}, {"sha": "7eaff226a7654640f0d34b6d26611a95b2701b2f", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -2,11 +2,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::fs::{self, OpenOptions, Metadata};\n+use crate::fs::{self, Metadata, OpenOptions};\n use crate::io;\n use crate::path::Path;\n use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner};\n+use crate::sys_common::{AsInner, AsInnerMut};\n \n /// Windows-specific extensions to [`File`].\n ///\n@@ -265,23 +265,28 @@ pub trait OpenOptionsExt {\n #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n impl OpenOptionsExt for OpenOptions {\n     fn access_mode(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().access_mode(access); self\n+        self.as_inner_mut().access_mode(access);\n+        self\n     }\n \n     fn share_mode(&mut self, share: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().share_mode(share); self\n+        self.as_inner_mut().share_mode(share);\n+        self\n     }\n \n     fn custom_flags(&mut self, flags: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().custom_flags(flags); self\n+        self.as_inner_mut().custom_flags(flags);\n+        self\n     }\n \n     fn attributes(&mut self, attributes: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().attributes(attributes); self\n+        self.as_inner_mut().attributes(attributes);\n+        self\n     }\n \n     fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().security_qos_flags(flags); self\n+        self.as_inner_mut().security_qos_flags(flags);\n+        self\n     }\n }\n \n@@ -468,14 +473,30 @@ pub trait MetadataExt {\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n impl MetadataExt for Metadata {\n-    fn file_attributes(&self) -> u32 { self.as_inner().attrs() }\n-    fn creation_time(&self) -> u64 { self.as_inner().created_u64() }\n-    fn last_access_time(&self) -> u64 { self.as_inner().accessed_u64() }\n-    fn last_write_time(&self) -> u64 { self.as_inner().modified_u64() }\n-    fn file_size(&self) -> u64 { self.as_inner().size() }\n-    fn volume_serial_number(&self) -> Option<u32> { self.as_inner().volume_serial_number() }\n-    fn number_of_links(&self) -> Option<u32> { self.as_inner().number_of_links() }\n-    fn file_index(&self) -> Option<u64> { self.as_inner().file_index() }\n+    fn file_attributes(&self) -> u32 {\n+        self.as_inner().attrs()\n+    }\n+    fn creation_time(&self) -> u64 {\n+        self.as_inner().created_u64()\n+    }\n+    fn last_access_time(&self) -> u64 {\n+        self.as_inner().accessed_u64()\n+    }\n+    fn last_write_time(&self) -> u64 {\n+        self.as_inner().modified_u64()\n+    }\n+    fn file_size(&self) -> u64 {\n+        self.as_inner().size()\n+    }\n+    fn volume_serial_number(&self) -> Option<u32> {\n+        self.as_inner().volume_serial_number()\n+    }\n+    fn number_of_links(&self) -> Option<u32> {\n+        self.as_inner().number_of_links()\n+    }\n+    fn file_index(&self) -> Option<u64> {\n+        self.as_inner().file_index()\n+    }\n }\n \n /// Windows-specific extensions to [`FileType`].\n@@ -495,8 +516,12 @@ pub trait FileTypeExt {\n \n #[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n impl FileTypeExt for fs::FileType {\n-    fn is_symlink_dir(&self) -> bool { self.as_inner().is_symlink_dir() }\n-    fn is_symlink_file(&self) -> bool { self.as_inner().is_symlink_file() }\n+    fn is_symlink_dir(&self) -> bool {\n+        self.as_inner().is_symlink_dir()\n+    }\n+    fn is_symlink_file(&self) -> bool {\n+        self.as_inner().is_symlink_file()\n+    }\n }\n \n /// Creates a new file symbolic link on the filesystem.\n@@ -515,8 +540,7 @@ impl FileTypeExt for fs::FileType {\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n-                                                    -> io::Result<()> {\n+pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), false)\n }\n \n@@ -536,7 +560,6 @@ pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n-                                                   -> io::Result<()> {\n+pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), true)\n }"}, {"sha": "4573ee589321dd488b8d5695b91d9ef9b586331f", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,12 +1,12 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fs;\n-use crate::os::windows::raw;\n+use crate::io;\n use crate::net;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::os::windows::raw;\n use crate::sys;\n use crate::sys::c;\n-use crate::io;\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n \n /// Raw HANDLEs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "613d3dc189a437f9bdb79f38253b8123171ca57d", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -13,23 +13,28 @@\n pub mod ffi;\n pub mod fs;\n pub mod io;\n-pub mod raw;\n pub mod process;\n+pub mod raw;\n pub mod thread;\n \n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{RawSocket, RawHandle, AsRawSocket, AsRawHandle};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{FromRawSocket, FromRawHandle, IntoRawSocket, IntoRawHandle};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{OpenOptionsExt, MetadataExt};\n-    #[doc(no_inline)] #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n+    #[doc(no_inline)]\n+    #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     pub use super::fs::FileExt;\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::fs::{MetadataExt, OpenOptionsExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{AsRawHandle, AsRawSocket, RawHandle, RawSocket};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{FromRawHandle, FromRawSocket, IntoRawHandle, IntoRawSocket};\n }"}, {"sha": "ed35c5ff19446e93ebe9317ff7823ab72eaf7227", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -2,10 +2,10 @@\n \n #![stable(feature = \"process_extensions\", since = \"1.2.0\")]\n \n-use crate::os::windows::io::{FromRawHandle, RawHandle, AsRawHandle, IntoRawHandle};\n+use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n use crate::process;\n use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl FromRawHandle for process::Stdio {"}, {"sha": "7f2a2877828cfe4f3d657a7b69ebab73060ffe45", "filename": "src/libstd/sys/windows/ext/raw.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -4,8 +4,11 @@\n \n use crate::os::raw::c_void;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type HANDLE = *mut c_void;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type HANDLE = *mut c_void;\n #[cfg(target_pointer_width = \"32\")]\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type SOCKET = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type SOCKET = u32;\n #[cfg(target_pointer_width = \"64\")]\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type SOCKET = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type SOCKET = u64;"}, {"sha": "41c29f5b950ef537ca78039eb3609112b16f5461", "filename": "src/libstd/sys/windows/ext/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -2,9 +2,9 @@\n \n #![stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n \n-use crate::os::windows::io::{RawHandle, AsRawHandle, IntoRawHandle};\n-use crate::thread;\n+use crate::os::windows::io::{AsRawHandle, IntoRawHandle, RawHandle};\n use crate::sys_common::{AsInner, IntoInner};\n+use crate::thread;\n \n #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n impl<T> AsRawHandle for thread::JoinHandle<T> {\n@@ -14,7 +14,7 @@ impl<T> AsRawHandle for thread::JoinHandle<T> {\n }\n \n #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n-impl<T> IntoRawHandle for thread::JoinHandle<T>  {\n+impl<T> IntoRawHandle for thread::JoinHandle<T> {\n     fn into_raw_handle(self) -> RawHandle {\n         self.into_inner().into_handle().into_raw() as *mut _\n     }"}, {"sha": "e9c84c4e7c9cb654414f120920e06a7d299c70be", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 205, "deletions": 156, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -2,7 +2,7 @@ use crate::os::windows::prelude::*;\n \n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::io::{self, Error, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n@@ -15,7 +15,9 @@ use crate::sys_common::FromInner;\n \n use super::to_u16s;\n \n-pub struct File { handle: Handle }\n+pub struct File {\n+    handle: Handle,\n+}\n \n #[derive(Clone)]\n pub struct FileAttr {\n@@ -71,7 +73,9 @@ pub struct OpenOptions {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FilePermissions { attrs: c::DWORD }\n+pub struct FilePermissions {\n+    attrs: c::DWORD,\n+}\n \n #[derive(Debug)]\n pub struct DirBuilder;\n@@ -97,13 +101,13 @@ impl Iterator for ReadDir {\n             loop {\n                 if c::FindNextFileW(self.handle.0, &mut wfd) == 0 {\n                     if c::GetLastError() == c::ERROR_NO_MORE_FILES {\n-                        return None\n+                        return None;\n                     } else {\n-                        return Some(Err(Error::last_os_error()))\n+                        return Some(Err(Error::last_os_error()));\n                     }\n                 }\n                 if let Some(e) = DirEntry::new(&self.root, &wfd) {\n-                    return Some(Ok(e))\n+                    return Some(Ok(e));\n                 }\n             }\n         }\n@@ -121,15 +125,11 @@ impl DirEntry {\n     fn new(root: &Arc<PathBuf>, wfd: &c::WIN32_FIND_DATAW) -> Option<DirEntry> {\n         match &wfd.cFileName[0..3] {\n             // check for '.' and '..'\n-            &[46, 0, ..] |\n-            &[46, 46, 0, ..] => return None,\n+            &[46, 0, ..] | &[46, 46, 0, ..] => return None,\n             _ => {}\n         }\n \n-        Some(DirEntry {\n-            root: root.clone(),\n-            data: *wfd,\n-        })\n+        Some(DirEntry { root: root.clone(), data: *wfd })\n     }\n \n     pub fn path(&self) -> PathBuf {\n@@ -142,8 +142,10 @@ impl DirEntry {\n     }\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n-        Ok(FileType::new(self.data.dwFileAttributes,\n-                         /* reparse_tag = */ self.data.dwReserved0))\n+        Ok(FileType::new(\n+            self.data.dwFileAttributes,\n+            /* reparse_tag = */ self.data.dwReserved0,\n+        ))\n     }\n \n     pub fn metadata(&self) -> io::Result<FileAttr> {\n@@ -154,11 +156,11 @@ impl DirEntry {\n             last_write_time: self.data.ftLastWriteTime,\n             file_size: ((self.data.nFileSizeHigh as u64) << 32) | (self.data.nFileSizeLow as u64),\n             reparse_tag: if self.data.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                    // reserved unless this is a reparse point\n-                    self.data.dwReserved0\n-                } else {\n-                    0\n-                },\n+                // reserved unless this is a reparse point\n+                self.data.dwReserved0\n+            } else {\n+                0\n+            },\n             volume_serial_number: None,\n             number_of_links: None,\n             file_index: None,\n@@ -186,17 +188,37 @@ impl OpenOptions {\n         }\n     }\n \n-    pub fn read(&mut self, read: bool) { self.read = read; }\n-    pub fn write(&mut self, write: bool) { self.write = write; }\n-    pub fn append(&mut self, append: bool) { self.append = append; }\n-    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n-    pub fn create(&mut self, create: bool) { self.create = create; }\n-    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+    pub fn read(&mut self, read: bool) {\n+        self.read = read;\n+    }\n+    pub fn write(&mut self, write: bool) {\n+        self.write = write;\n+    }\n+    pub fn append(&mut self, append: bool) {\n+        self.append = append;\n+    }\n+    pub fn truncate(&mut self, truncate: bool) {\n+        self.truncate = truncate;\n+    }\n+    pub fn create(&mut self, create: bool) {\n+        self.create = create;\n+    }\n+    pub fn create_new(&mut self, create_new: bool) {\n+        self.create_new = create_new;\n+    }\n \n-    pub fn custom_flags(&mut self, flags: u32) { self.custom_flags = flags; }\n-    pub fn access_mode(&mut self, access_mode: u32) { self.access_mode = Some(access_mode); }\n-    pub fn share_mode(&mut self, share_mode: u32) { self.share_mode = share_mode; }\n-    pub fn attributes(&mut self, attrs: u32) { self.attributes = attrs; }\n+    pub fn custom_flags(&mut self, flags: u32) {\n+        self.custom_flags = flags;\n+    }\n+    pub fn access_mode(&mut self, access_mode: u32) {\n+        self.access_mode = Some(access_mode);\n+    }\n+    pub fn share_mode(&mut self, share_mode: u32) {\n+        self.share_mode = share_mode;\n+    }\n+    pub fn attributes(&mut self, attrs: u32) {\n+        self.attributes = attrs;\n+    }\n     pub fn security_qos_flags(&mut self, flags: u32) {\n         // We have to set `SECURITY_SQOS_PRESENT` here, because one of the valid flags we can\n         // receive is `SECURITY_ANONYMOUS = 0x0`, which we can't check for later on.\n@@ -211,12 +233,13 @@ impl OpenOptions {\n \n         match (self.read, self.write, self.append, self.access_mode) {\n             (.., Some(mode)) => Ok(mode),\n-            (true,  false, false, None) => Ok(c::GENERIC_READ),\n-            (false, true,  false, None) => Ok(c::GENERIC_WRITE),\n-            (true,  true,  false, None) => Ok(c::GENERIC_READ | c::GENERIC_WRITE),\n-            (false, _,     true,  None) => Ok(c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA),\n-            (true,  _,     true,  None) => Ok(c::GENERIC_READ |\n-                                              (c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA)),\n+            (true, false, false, None) => Ok(c::GENERIC_READ),\n+            (false, true, false, None) => Ok(c::GENERIC_WRITE),\n+            (true, true, false, None) => Ok(c::GENERIC_READ | c::GENERIC_WRITE),\n+            (false, _, true, None) => Ok(c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA),\n+            (true, _, true, None) => {\n+                Ok(c::GENERIC_READ | (c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA))\n+            }\n             (false, false, false, None) => Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER)),\n         }\n     }\n@@ -226,44 +249,48 @@ impl OpenOptions {\n \n         match (self.write, self.append) {\n             (true, false) => {}\n-            (false, false) =>\n+            (false, false) => {\n                 if self.truncate || self.create || self.create_new {\n                     return Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n-                },\n-            (_, true) =>\n+                }\n+            }\n+            (_, true) => {\n                 if self.truncate && !self.create_new {\n                     return Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n-                },\n+                }\n+            }\n         }\n \n         Ok(match (self.create, self.truncate, self.create_new) {\n-                (false, false, false) => c::OPEN_EXISTING,\n-                (true,  false, false) => c::OPEN_ALWAYS,\n-                (false, true,  false) => c::TRUNCATE_EXISTING,\n-                (true,  true,  false) => c::CREATE_ALWAYS,\n-                (_,      _,    true)  => c::CREATE_NEW,\n-           })\n+            (false, false, false) => c::OPEN_EXISTING,\n+            (true, false, false) => c::OPEN_ALWAYS,\n+            (false, true, false) => c::TRUNCATE_EXISTING,\n+            (true, true, false) => c::CREATE_ALWAYS,\n+            (_, _, true) => c::CREATE_NEW,\n+        })\n     }\n \n     fn get_flags_and_attributes(&self) -> c::DWORD {\n-        self.custom_flags |\n-        self.attributes |\n-        self.security_qos_flags |\n-        if self.create_new { c::FILE_FLAG_OPEN_REPARSE_POINT } else { 0 }\n+        self.custom_flags\n+            | self.attributes\n+            | self.security_qos_flags\n+            | if self.create_new { c::FILE_FLAG_OPEN_REPARSE_POINT } else { 0 }\n     }\n }\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n         let path = to_u16s(path)?;\n         let handle = unsafe {\n-            c::CreateFileW(path.as_ptr(),\n-                           opts.get_access_mode()?,\n-                           opts.share_mode,\n-                           opts.security_attributes as *mut _,\n-                           opts.get_creation_mode()?,\n-                           opts.get_flags_and_attributes(),\n-                           ptr::null_mut())\n+            c::CreateFileW(\n+                path.as_ptr(),\n+                opts.get_access_mode()?,\n+                opts.share_mode,\n+                opts.security_attributes as *mut _,\n+                opts.get_creation_mode()?,\n+                opts.get_flags_and_attributes(),\n+                ptr::null_mut(),\n+            )\n         };\n         if handle == c::INVALID_HANDLE_VALUE {\n             Err(Error::last_os_error())\n@@ -277,18 +304,20 @@ impl File {\n         Ok(())\n     }\n \n-    pub fn datasync(&self) -> io::Result<()> { self.fsync() }\n+    pub fn datasync(&self) -> io::Result<()> {\n+        self.fsync()\n+    }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        let mut info = c::FILE_END_OF_FILE_INFO {\n-            EndOfFile: size as c::LARGE_INTEGER,\n-        };\n+        let mut info = c::FILE_END_OF_FILE_INFO { EndOfFile: size as c::LARGE_INTEGER };\n         let size = mem::size_of_val(&info);\n         cvt(unsafe {\n-            c::SetFileInformationByHandle(self.handle.raw(),\n-                                          c::FileEndOfFileInfo,\n-                                          &mut info as *mut _ as *mut _,\n-                                          size as c::DWORD)\n+            c::SetFileInformationByHandle(\n+                self.handle.raw(),\n+                c::FileEndOfFileInfo,\n+                &mut info as *mut _ as *mut _,\n+                size as c::DWORD,\n+            )\n         })?;\n         Ok(())\n     }\n@@ -314,8 +343,9 @@ impl File {\n                 reparse_tag,\n                 volume_serial_number: Some(info.dwVolumeSerialNumber),\n                 number_of_links: Some(info.nNumberOfLinks),\n-                file_index: Some((info.nFileIndexLow as u64) |\n-                                 ((info.nFileIndexHigh as u64) << 32)),\n+                file_index: Some(\n+                    (info.nFileIndexLow as u64) | ((info.nFileIndexHigh as u64) << 32),\n+                ),\n             })\n         }\n     }\n@@ -325,10 +355,12 @@ impl File {\n         unsafe {\n             let mut info: c::FILE_BASIC_INFO = mem::zeroed();\n             let size = mem::size_of_val(&info);\n-            cvt(c::GetFileInformationByHandleEx(self.handle.raw(),\n-                                              c::FileBasicInfo,\n-                                              &mut info as *mut _ as *mut libc::c_void,\n-                                              size as c::DWORD))?;\n+            cvt(c::GetFileInformationByHandleEx(\n+                self.handle.raw(),\n+                c::FileBasicInfo,\n+                &mut info as *mut _ as *mut libc::c_void,\n+                size as c::DWORD,\n+            ))?;\n             let mut attr = FileAttr {\n                 attributes: info.FileAttributes,\n                 creation_time: c::FILETIME {\n@@ -351,10 +383,12 @@ impl File {\n             };\n             let mut info: c::FILE_STANDARD_INFO = mem::zeroed();\n             let size = mem::size_of_val(&info);\n-            cvt(c::GetFileInformationByHandleEx(self.handle.raw(),\n-                                                c::FileStandardInfo,\n-                                                &mut info as *mut _ as *mut libc::c_void,\n-                                                size as c::DWORD))?;\n+            cvt(c::GetFileInformationByHandleEx(\n+                self.handle.raw(),\n+                c::FileStandardInfo,\n+                &mut info as *mut _ as *mut libc::c_void,\n+                size as c::DWORD,\n+            ))?;\n             attr.file_size = info.AllocationSize as u64;\n             attr.number_of_links = Some(info.NumberOfLinks);\n             if attr.file_type().is_reparse_point() {\n@@ -391,7 +425,9 @@ impl File {\n         self.handle.write_at(buf, offset)\n     }\n \n-    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, pos) = match pos {\n@@ -403,37 +439,39 @@ impl File {\n         };\n         let pos = pos as c::LARGE_INTEGER;\n         let mut newpos = 0;\n-        cvt(unsafe {\n-            c::SetFilePointerEx(self.handle.raw(), pos,\n-                                &mut newpos, whence)\n-        })?;\n+        cvt(unsafe { c::SetFilePointerEx(self.handle.raw(), pos, &mut newpos, whence) })?;\n         Ok(newpos as u64)\n     }\n \n     pub fn duplicate(&self) -> io::Result<File> {\n-        Ok(File {\n-            handle: self.handle.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)?,\n-        })\n+        Ok(File { handle: self.handle.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)? })\n     }\n \n-    pub fn handle(&self) -> &Handle { &self.handle }\n+    pub fn handle(&self) -> &Handle {\n+        &self.handle\n+    }\n \n-    pub fn into_handle(self) -> Handle { self.handle }\n+    pub fn into_handle(self) -> Handle {\n+        self.handle\n+    }\n \n-    fn reparse_point<'a>(&self,\n-                         space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE])\n-                         -> io::Result<(c::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n+    fn reparse_point<'a>(\n+        &self,\n+        space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n+    ) -> io::Result<(c::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n         unsafe {\n             let mut bytes = 0;\n             cvt({\n-                c::DeviceIoControl(self.handle.raw(),\n-                                   c::FSCTL_GET_REPARSE_POINT,\n-                                   ptr::null_mut(),\n-                                   0,\n-                                   space.as_mut_ptr() as *mut _,\n-                                   space.len() as c::DWORD,\n-                                   &mut bytes,\n-                                   ptr::null_mut())\n+                c::DeviceIoControl(\n+                    self.handle.raw(),\n+                    c::FSCTL_GET_REPARSE_POINT,\n+                    ptr::null_mut(),\n+                    0,\n+                    space.as_mut_ptr() as *mut _,\n+                    space.len() as c::DWORD,\n+                    &mut bytes,\n+                    ptr::null_mut(),\n+                )\n             })?;\n             Ok((bytes, &*(space.as_ptr() as *const c::REPARSE_DATA_BUFFER)))\n         }\n@@ -447,21 +485,29 @@ impl File {\n                 c::IO_REPARSE_TAG_SYMLINK => {\n                     let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n                         &buf.rest as *const _ as *const _;\n-                    (&(*info).PathBuffer as *const _ as *const u16,\n-                     (*info).SubstituteNameOffset / 2,\n-                     (*info).SubstituteNameLength / 2,\n-                     (*info).Flags & c::SYMLINK_FLAG_RELATIVE != 0)\n-                },\n+                    (\n+                        &(*info).PathBuffer as *const _ as *const u16,\n+                        (*info).SubstituteNameOffset / 2,\n+                        (*info).SubstituteNameLength / 2,\n+                        (*info).Flags & c::SYMLINK_FLAG_RELATIVE != 0,\n+                    )\n+                }\n                 c::IO_REPARSE_TAG_MOUNT_POINT => {\n                     let info: *const c::MOUNT_POINT_REPARSE_BUFFER =\n                         &buf.rest as *const _ as *const _;\n-                    (&(*info).PathBuffer as *const _ as *const u16,\n-                     (*info).SubstituteNameOffset / 2,\n-                     (*info).SubstituteNameLength / 2,\n-                     false)\n-                },\n-                _ => return Err(io::Error::new(io::ErrorKind::Other,\n-                                               \"Unsupported reparse point type\"))\n+                    (\n+                        &(*info).PathBuffer as *const _ as *const u16,\n+                        (*info).SubstituteNameOffset / 2,\n+                        (*info).SubstituteNameLength / 2,\n+                        false,\n+                    )\n+                }\n+                _ => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::Other,\n+                        \"Unsupported reparse point type\",\n+                    ));\n+                }\n             };\n             let subst_ptr = path_buffer.offset(subst_off as isize);\n             let mut subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n@@ -484,10 +530,12 @@ impl File {\n         };\n         let size = mem::size_of_val(&info);\n         cvt(unsafe {\n-            c::SetFileInformationByHandle(self.handle.raw(),\n-                                          c::FileBasicInfo,\n-                                          &mut info as *mut _ as *mut _,\n-                                          size as c::DWORD)\n+            c::SetFileInformationByHandle(\n+                self.handle.raw(),\n+                c::FileBasicInfo,\n+                &mut info as *mut _ as *mut _,\n+                size as c::DWORD,\n+            )\n         })?;\n         Ok(())\n     }\n@@ -585,10 +633,7 @@ impl FilePermissions {\n \n impl FileType {\n     fn new(attrs: c::DWORD, reparse_tag: c::DWORD) -> FileType {\n-        FileType {\n-            attributes: attrs,\n-            reparse_tag: reparse_tag,\n-        }\n+        FileType { attributes: attrs, reparse_tag: reparse_tag }\n     }\n     pub fn is_dir(&self) -> bool {\n         !self.is_symlink() && self.is_directory()\n@@ -617,13 +662,13 @@ impl FileType {\n }\n \n impl DirBuilder {\n-    pub fn new() -> DirBuilder { DirBuilder }\n+    pub fn new() -> DirBuilder {\n+        DirBuilder\n+    }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n         let p = to_u16s(p)?;\n-        cvt(unsafe {\n-            c::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n-        })?;\n+        cvt(unsafe { c::CreateDirectoryW(p.as_ptr(), ptr::null_mut()) })?;\n         Ok(())\n     }\n }\n@@ -657,9 +702,7 @@ pub fn unlink(p: &Path) -> io::Result<()> {\n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n     let old = to_u16s(old)?;\n     let new = to_u16s(new)?;\n-    cvt(unsafe {\n-        c::MoveFileExW(old.as_ptr(), new.as_ptr(), c::MOVEFILE_REPLACE_EXISTING)\n-    })?;\n+    cvt(unsafe { c::MoveFileExW(old.as_ptr(), new.as_ptr(), c::MOVEFILE_REPLACE_EXISTING) })?;\n     Ok(())\n }\n \n@@ -701,8 +744,7 @@ pub fn readlink(path: &Path) -> io::Result<PathBuf> {\n     // this is needed for a common case.\n     let mut opts = OpenOptions::new();\n     opts.access_mode(0);\n-    opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT |\n-                      c::FILE_FLAG_BACKUP_SEMANTICS);\n+    opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);\n     let file = File::open(&path, &opts)?;\n     file.readlink()\n }\n@@ -720,16 +762,17 @@ pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n     // computer is in Developer Mode, but SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE must be\n     // added to dwFlags to opt into this behaviour.\n     let result = cvt(unsafe {\n-        c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(),\n-                               flags | c::SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE) as c::BOOL\n+        c::CreateSymbolicLinkW(\n+            dst.as_ptr(),\n+            src.as_ptr(),\n+            flags | c::SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE,\n+        ) as c::BOOL\n     });\n     if let Err(err) = result {\n         if err.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) {\n             // Older Windows objects to SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE,\n             // so if we encounter ERROR_INVALID_PARAMETER, retry without that flag.\n-            cvt(unsafe {\n-                c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as c::BOOL\n-            })?;\n+            cvt(unsafe { c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as c::BOOL })?;\n         } else {\n             return Err(err);\n         }\n@@ -741,16 +784,13 @@ pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n     let src = to_u16s(src)?;\n     let dst = to_u16s(dst)?;\n-    cvt(unsafe {\n-        c::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut())\n-    })?;\n+    cvt(unsafe { c::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut()) })?;\n     Ok(())\n }\n \n #[cfg(target_vendor = \"uwp\")]\n pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    return Err(io::Error::new(io::ErrorKind::Other,\n-                            \"hard link are not supported on UWP\"));\n+    return Err(io::Error::new(io::ErrorKind::Other, \"hard link are not supported on UWP\"));\n }\n \n pub fn stat(path: &Path) -> io::Result<FileAttr> {\n@@ -781,12 +821,12 @@ pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n }\n \n fn get_path(f: &File) -> io::Result<PathBuf> {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n-        c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,\n-                                     c::VOLUME_NAME_DOS)\n-    }, |buf| {\n-        PathBuf::from(OsString::from_wide(buf))\n-    })\n+    super::fill_utf16_buf(\n+        |buf, sz| unsafe {\n+            c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz, c::VOLUME_NAME_DOS)\n+        },\n+        |buf| PathBuf::from(OsString::from_wide(buf)),\n+    )\n }\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n@@ -811,15 +851,23 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         _hDestinationFile: c::HANDLE,\n         lpData: c::LPVOID,\n     ) -> c::DWORD {\n-        if dwStreamNumber == 1 {*(lpData as *mut i64) = StreamBytesTransferred;}\n+        if dwStreamNumber == 1 {\n+            *(lpData as *mut i64) = StreamBytesTransferred;\n+        }\n         c::PROGRESS_CONTINUE\n     }\n     let pfrom = to_u16s(from)?;\n     let pto = to_u16s(to)?;\n     let mut size = 0i64;\n     cvt(unsafe {\n-        c::CopyFileExW(pfrom.as_ptr(), pto.as_ptr(), Some(callback),\n-                       &mut size as *mut _ as *mut _, ptr::null_mut(), 0)\n+        c::CopyFileExW(\n+            pfrom.as_ptr(),\n+            pto.as_ptr(),\n+            Some(callback),\n+            &mut size as *mut _ as *mut _,\n+            ptr::null_mut(),\n+            0,\n+        )\n     })?;\n     Ok(size as u64)\n }\n@@ -841,15 +889,13 @@ fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> {\n \n     let mut opts = OpenOptions::new();\n     opts.write(true);\n-    opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT |\n-                      c::FILE_FLAG_BACKUP_SEMANTICS);\n+    opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);\n     let f = File::open(junction, &opts)?;\n     let h = f.handle().raw();\n \n     unsafe {\n         let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-        let db = data.as_mut_ptr()\n-                    as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n+        let db = data.as_mut_ptr() as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n         let buf = &mut (*db).ReparseTarget as *mut c::WCHAR;\n         let mut i = 0;\n         // FIXME: this conversion is very hacky\n@@ -864,16 +910,19 @@ fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> {\n         (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n         (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n         (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;\n-        (*db).ReparseDataLength =\n-                (*db).ReparseTargetLength as c::DWORD + 12;\n+        (*db).ReparseDataLength = (*db).ReparseTargetLength as c::DWORD + 12;\n \n         let mut ret = 0;\n-        cvt(c::DeviceIoControl(h as *mut _,\n-                               c::FSCTL_SET_REPARSE_POINT,\n-                               data.as_ptr() as *mut _,\n-                               (*db).ReparseDataLength + 8,\n-                               ptr::null_mut(), 0,\n-                               &mut ret,\n-                               ptr::null_mut())).map(|_| ())\n+        cvt(c::DeviceIoControl(\n+            h as *mut _,\n+            c::FSCTL_SET_REPARSE_POINT,\n+            data.as_ptr() as *mut _,\n+            (*db).ReparseDataLength + 8,\n+            ptr::null_mut(),\n+            0,\n+            &mut ret,\n+            ptr::null_mut(),\n+        ))\n+        .map(|_| ())\n     }\n }"}, {"sha": "ebaa0783d603d6138a44e684ffbf02d6eae903da", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 57, "deletions": 47, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n #![unstable(issue = \"0\", feature = \"windows_handle\")]\n \n use crate::cmp;\n-use crate::io::{self, ErrorKind, Read, IoSlice, IoSliceMut};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::ops::Deref;\n use crate::ptr;\n@@ -31,15 +31,9 @@ impl Handle {\n \n     pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> {\n         unsafe {\n-            let event = c::CreateEventW(ptr::null_mut(),\n-                                        manual as c::BOOL,\n-                                        init as c::BOOL,\n-                                        ptr::null());\n-            if event.is_null() {\n-                Err(io::Error::last_os_error())\n-            } else {\n-                Ok(Handle::new(event))\n-            }\n+            let event =\n+                c::CreateEventW(ptr::null_mut(), manual as c::BOOL, init as c::BOOL, ptr::null());\n+            if event.is_null() { Err(io::Error::last_os_error()) } else { Ok(Handle::new(event)) }\n         }\n     }\n \n@@ -52,12 +46,16 @@ impl Handle {\n \n impl Deref for Handle {\n     type Target = RawHandle;\n-    fn deref(&self) -> &RawHandle { &self.0 }\n+    fn deref(&self) -> &RawHandle {\n+        &self.0\n+    }\n }\n \n impl Drop for Handle {\n     fn drop(&mut self) {\n-        unsafe { let _ = c::CloseHandle(self.raw()); }\n+        unsafe {\n+            let _ = c::CloseHandle(self.raw());\n+        }\n     }\n }\n \n@@ -66,14 +64,15 @@ impl RawHandle {\n         RawHandle(handle)\n     }\n \n-    pub fn raw(&self) -> c::HANDLE { self.0 }\n+    pub fn raw(&self) -> c::HANDLE {\n+        self.0\n+    }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let mut read = 0;\n         let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         let res = cvt(unsafe {\n-            c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID,\n-                        len, &mut read, ptr::null_mut())\n+            c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID, len, &mut read, ptr::null_mut())\n         });\n \n         match res {\n@@ -85,7 +84,7 @@ impl RawHandle {\n             // EOF on the pipe.\n             Err(ref e) if e.kind() == ErrorKind::BrokenPipe => Ok(0),\n \n-            Err(e) => Err(e)\n+            Err(e) => Err(e),\n         }\n     }\n \n@@ -100,8 +99,7 @@ impl RawHandle {\n             let mut overlapped: c::OVERLAPPED = mem::zeroed();\n             overlapped.Offset = offset as u32;\n             overlapped.OffsetHigh = (offset >> 32) as u32;\n-            cvt(c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID,\n-                            len, &mut read, &mut overlapped))\n+            cvt(c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID, len, &mut read, &mut overlapped))\n         };\n         match res {\n             Ok(_) => Ok(read as usize),\n@@ -110,16 +108,15 @@ impl RawHandle {\n         }\n     }\n \n-    pub unsafe fn read_overlapped(&self,\n-                                  buf: &mut [u8],\n-                                  overlapped: *mut c::OVERLAPPED)\n-                                  -> io::Result<Option<usize>> {\n+    pub unsafe fn read_overlapped(\n+        &self,\n+        buf: &mut [u8],\n+        overlapped: *mut c::OVERLAPPED,\n+    ) -> io::Result<Option<usize>> {\n         let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         let mut amt = 0;\n-        let res = cvt({\n-            c::ReadFile(self.0, buf.as_ptr() as c::LPVOID,\n-                        len, &mut amt, overlapped)\n-        });\n+        let res =\n+            cvt({ c::ReadFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, overlapped) });\n         match res {\n             Ok(_) => Ok(Some(amt as usize)),\n             Err(e) => {\n@@ -134,20 +131,21 @@ impl RawHandle {\n         }\n     }\n \n-    pub fn overlapped_result(&self,\n-                             overlapped: *mut c::OVERLAPPED,\n-                             wait: bool) -> io::Result<usize> {\n+    pub fn overlapped_result(\n+        &self,\n+        overlapped: *mut c::OVERLAPPED,\n+        wait: bool,\n+    ) -> io::Result<usize> {\n         unsafe {\n             let mut bytes = 0;\n-            let wait = if wait {c::TRUE} else {c::FALSE};\n-            let res = cvt({\n-                c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait)\n-            });\n+            let wait = if wait { c::TRUE } else { c::FALSE };\n+            let res = cvt({ c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait) });\n             match res {\n                 Ok(_) => Ok(bytes as usize),\n                 Err(e) => {\n-                    if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32) ||\n-                       e.raw_os_error() == Some(c::ERROR_BROKEN_PIPE as i32) {\n+                    if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32)\n+                        || e.raw_os_error() == Some(c::ERROR_BROKEN_PIPE as i32)\n+                    {\n                         Ok(0)\n                     } else {\n                         Err(e)\n@@ -158,17 +156,14 @@ impl RawHandle {\n     }\n \n     pub fn cancel_io(&self) -> io::Result<()> {\n-        unsafe {\n-            cvt(c::CancelIo(self.raw())).map(|_| ())\n-        }\n+        unsafe { cvt(c::CancelIo(self.raw())).map(|_| ()) }\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n         let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         cvt(unsafe {\n-            c::WriteFile(self.0, buf.as_ptr() as c::LPVOID,\n-                         len, &mut amt, ptr::null_mut())\n+            c::WriteFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, ptr::null_mut())\n         })?;\n         Ok(amt as usize)\n     }\n@@ -184,20 +179,35 @@ impl RawHandle {\n             let mut overlapped: c::OVERLAPPED = mem::zeroed();\n             overlapped.Offset = offset as u32;\n             overlapped.OffsetHigh = (offset >> 32) as u32;\n-            cvt(c::WriteFile(self.0, buf.as_ptr() as c::LPVOID,\n-                             len, &mut written, &mut overlapped))?;\n+            cvt(c::WriteFile(\n+                self.0,\n+                buf.as_ptr() as c::LPVOID,\n+                len,\n+                &mut written,\n+                &mut overlapped,\n+            ))?;\n         }\n         Ok(written as usize)\n     }\n \n-    pub fn duplicate(&self, access: c::DWORD, inherit: bool,\n-                     options: c::DWORD) -> io::Result<Handle> {\n+    pub fn duplicate(\n+        &self,\n+        access: c::DWORD,\n+        inherit: bool,\n+        options: c::DWORD,\n+    ) -> io::Result<Handle> {\n         let mut ret = 0 as c::HANDLE;\n         cvt(unsafe {\n             let cur_proc = c::GetCurrentProcess();\n-            c::DuplicateHandle(cur_proc, self.0, cur_proc, &mut ret,\n-                            access, inherit as c::BOOL,\n-                            options)\n+            c::DuplicateHandle(\n+                cur_proc,\n+                self.0,\n+                cur_proc,\n+                &mut ret,\n+                access,\n+                inherit as c::BOOL,\n+                options,\n+            )\n         })?;\n         Ok(Handle::new(ret))\n     }"}, {"sha": "9d8018fd5e864acb9c2c46a1d599e96d353e412c", "filename": "src/libstd/sys/windows/io.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -35,9 +35,7 @@ impl<'a> IoSlice<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize) }\n     }\n }\n \n@@ -52,10 +50,7 @@ impl<'a> IoSliceMut<'a> {\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         assert!(buf.len() <= c::ULONG::max_value() as usize);\n         IoSliceMut {\n-            vec: c::WSABUF {\n-                len: buf.len() as c::ULONG,\n-                buf: buf.as_mut_ptr() as *mut c::CHAR,\n-            },\n+            vec: c::WSABUF { len: buf.len() as c::ULONG, buf: buf.as_mut_ptr() as *mut c::CHAR },\n             _p: PhantomData,\n         }\n     }\n@@ -74,15 +69,11 @@ impl<'a> IoSliceMut<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize) }\n     }\n \n     #[inline]\n     pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(self.vec.buf as *mut u8, self.vec.len as usize)\n-        }\n+        unsafe { slice::from_raw_parts_mut(self.vec.buf as *mut u8, self.vec.len as usize) }\n     }\n }"}, {"sha": "8631e50cf3888833110278ca2baccbc94be70c85", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 76, "deletions": 68, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -5,7 +5,7 @@\n use crate::os::windows::prelude::*;\n \n use crate::error::Error as StdError;\n-use crate::ffi::{OsString, OsStr};\n+use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::os::windows::ffi::EncodeWide;\n@@ -37,8 +37,10 @@ pub fn error_string(mut errnum: i32) -> String {\n         // `[MS-ERREF]`: https://msdn.microsoft.com/en-us/library/cc231198.aspx\n         if (errnum & c::FACILITY_NT_BIT as i32) != 0 {\n             // format according to https://support.microsoft.com/en-us/help/259693\n-            const NTDLL_DLL: &[u16] = &['N' as _, 'T' as _, 'D' as _, 'L' as _, 'L' as _,\n-                                        '.' as _, 'D' as _, 'L' as _, 'L' as _, 0];\n+            const NTDLL_DLL: &[u16] = &[\n+                'N' as _, 'T' as _, 'D' as _, 'L' as _, 'L' as _, '.' as _, 'D' as _, 'L' as _,\n+                'L' as _, 0,\n+            ];\n             module = c::GetModuleHandleW(NTDLL_DLL.as_ptr());\n \n             if module != ptr::null_mut() {\n@@ -47,19 +49,19 @@ pub fn error_string(mut errnum: i32) -> String {\n             }\n         }\n \n-        let res = c::FormatMessageW(flags | c::FORMAT_MESSAGE_FROM_SYSTEM |\n-                                        c::FORMAT_MESSAGE_IGNORE_INSERTS,\n-                                    module,\n-                                    errnum as c::DWORD,\n-                                    langId,\n-                                    buf.as_mut_ptr(),\n-                                    buf.len() as c::DWORD,\n-                                    ptr::null()) as usize;\n+        let res = c::FormatMessageW(\n+            flags | c::FORMAT_MESSAGE_FROM_SYSTEM | c::FORMAT_MESSAGE_IGNORE_INSERTS,\n+            module,\n+            errnum as c::DWORD,\n+            langId,\n+            buf.as_mut_ptr(),\n+            buf.len() as c::DWORD,\n+            ptr::null(),\n+        ) as usize;\n         if res == 0 {\n             // Sometimes FormatMessageW can fail e.g., system doesn't like langId,\n             let fm_err = errno();\n-            return format!(\"OS Error {} (FormatMessageW() returned error {})\",\n-                           errnum, fm_err);\n+            return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n         }\n \n         match String::from_utf16(&buf[..res]) {\n@@ -68,9 +70,12 @@ pub fn error_string(mut errnum: i32) -> String {\n                 let len = msg.trim_end().len();\n                 msg.truncate(len);\n                 msg\n-            },\n-            Err(..) => format!(\"OS Error {} (FormatMessageW() returned \\\n-                                invalid UTF-16)\", errnum),\n+            }\n+            Err(..) => format!(\n+                \"OS Error {} (FormatMessageW() returned \\\n+                 invalid UTF-16)\",\n+                errnum\n+            ),\n         }\n     }\n }\n@@ -86,7 +91,9 @@ impl Iterator for Env {\n     fn next(&mut self) -> Option<(OsString, OsString)> {\n         loop {\n             unsafe {\n-                if *self.cur == 0 { return None }\n+                if *self.cur == 0 {\n+                    return None;\n+                }\n                 let p = &*self.cur as *const u16;\n                 let mut len = 0;\n                 while *p.offset(len) != 0 {\n@@ -106,25 +113,26 @@ impl Iterator for Env {\n                 };\n                 return Some((\n                     OsStringExt::from_wide(&s[..pos]),\n-                    OsStringExt::from_wide(&s[pos+1..]),\n-                ))\n+                    OsStringExt::from_wide(&s[pos + 1..]),\n+                ));\n             }\n         }\n     }\n }\n \n impl Drop for Env {\n     fn drop(&mut self) {\n-        unsafe { c::FreeEnvironmentStringsW(self.base); }\n+        unsafe {\n+            c::FreeEnvironmentStringsW(self.base);\n+        }\n     }\n }\n \n pub fn env() -> Env {\n     unsafe {\n         let ch = c::GetEnvironmentStringsW();\n         if ch as usize == 0 {\n-            panic!(\"failure getting env string from OS: {}\",\n-                   io::Error::last_os_error());\n+            panic!(\"failure getting env string from OS: {}\", io::Error::last_os_error());\n         }\n         Env { base: ch, cur: ch }\n     }\n@@ -136,10 +144,7 @@ pub struct SplitPaths<'a> {\n }\n \n pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n-    SplitPaths {\n-        data: unparsed.encode_wide(),\n-        must_yield: true,\n-    }\n+    SplitPaths { data: unparsed.encode_wide(), must_yield: true }\n }\n \n impl<'a> Iterator for SplitPaths<'a> {\n@@ -158,7 +163,6 @@ impl<'a> Iterator for SplitPaths<'a> {\n         // (The above is based on testing; there is no clear reference available\n         // for the grammar.)\n \n-\n         let must_yield = self.must_yield;\n         self.must_yield = false;\n \n@@ -169,7 +173,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n                 in_quote = !in_quote;\n             } else if b == ';' as u16 && !in_quote {\n                 self.must_yield = true;\n-                break\n+                break;\n             } else {\n                 in_progress.push(b)\n             }\n@@ -187,17 +191,21 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     let mut joined = Vec::new();\n     let sep = b';' as u16;\n \n     for (i, path) in paths.enumerate() {\n         let path = path.as_ref();\n-        if i > 0 { joined.push(sep) }\n+        if i > 0 {\n+            joined.push(sep)\n+        }\n         let v = path.encode_wide().collect::<Vec<u16>>();\n         if v.contains(&(b'\"' as u16)) {\n-            return Err(JoinPathsError)\n+            return Err(JoinPathsError);\n         } else if v.contains(&sep) {\n             joined.push(b'\"' as u16);\n             joined.extend_from_slice(&v[..]);\n@@ -217,38 +225,36 @@ impl fmt::Display for JoinPathsError {\n }\n \n impl StdError for JoinPathsError {\n-    fn description(&self) -> &str { \"failed to join paths\" }\n+    fn description(&self) -> &str {\n+        \"failed to join paths\"\n+    }\n }\n \n pub fn current_exe() -> io::Result<PathBuf> {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n-        c::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n-    }, super::os2path)\n+    super::fill_utf16_buf(\n+        |buf, sz| unsafe { c::GetModuleFileNameW(ptr::null_mut(), buf, sz) },\n+        super::os2path,\n+    )\n }\n \n pub fn getcwd() -> io::Result<PathBuf> {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n-        c::GetCurrentDirectoryW(sz, buf)\n-    }, super::os2path)\n+    super::fill_utf16_buf(|buf, sz| unsafe { c::GetCurrentDirectoryW(sz, buf) }, super::os2path)\n }\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n     let p: &OsStr = p.as_ref();\n     let mut p = p.encode_wide().collect::<Vec<_>>();\n     p.push(0);\n \n-    cvt(unsafe {\n-        c::SetCurrentDirectoryW(p.as_ptr())\n-    }).map(|_| ())\n+    cvt(unsafe { c::SetCurrentDirectoryW(p.as_ptr()) }).map(|_| ())\n }\n \n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     let k = to_u16s(k)?;\n-    let res = super::fill_utf16_buf(|buf, sz| unsafe {\n-        c::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n-    }, |buf| {\n-        OsStringExt::from_wide(buf)\n-    });\n+    let res = super::fill_utf16_buf(\n+        |buf, sz| unsafe { c::GetEnvironmentVariableW(k.as_ptr(), buf, sz) },\n+        |buf| OsStringExt::from_wide(buf),\n+    );\n     match res {\n         Ok(value) => Ok(Some(value)),\n         Err(e) => {\n@@ -265,22 +271,16 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let k = to_u16s(k)?;\n     let v = to_u16s(v)?;\n \n-    cvt(unsafe {\n-        c::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr())\n-    }).map(|_| ())\n+    cvt(unsafe { c::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr()) }).map(|_| ())\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let v = to_u16s(n)?;\n-    cvt(unsafe {\n-        c::SetEnvironmentVariableW(v.as_ptr(), ptr::null())\n-    }).map(|_| ())\n+    cvt(unsafe { c::SetEnvironmentVariableW(v.as_ptr(), ptr::null()) }).map(|_| ())\n }\n \n pub fn temp_dir() -> PathBuf {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n-        c::GetTempPathW(sz, buf)\n-    }, super::os2path).unwrap()\n+    super::fill_utf16_buf(|buf, sz| unsafe { c::GetTempPathW(sz, buf) }, super::os2path).unwrap()\n }\n \n #[cfg(not(target_vendor = \"uwp\"))]\n@@ -291,16 +291,20 @@ fn home_dir_crt() -> Option<PathBuf> {\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();\n         if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n-            return None\n+            return None;\n         }\n         let _handle = Handle::new(token);\n-        super::fill_utf16_buf(|buf, mut sz| {\n-            match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n-                0 if c::GetLastError() != c::ERROR_INSUFFICIENT_BUFFER => 0,\n-                0 => sz,\n-                _ => sz - 1, // sz includes the null terminator\n-            }\n-        }, super::os2path).ok()\n+        super::fill_utf16_buf(\n+            |buf, mut sz| {\n+                match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n+                    0 if c::GetLastError() != c::ERROR_INSUFFICIENT_BUFFER => 0,\n+                    0 => sz,\n+                    _ => sz - 1, // sz includes the null terminator\n+                }\n+            },\n+            super::os2path,\n+        )\n+        .ok()\n     }\n }\n \n@@ -310,9 +314,10 @@ fn home_dir_crt() -> Option<PathBuf> {\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n-    crate::env::var_os(\"HOME\").or_else(|| {\n-        crate::env::var_os(\"USERPROFILE\")\n-    }).map(PathBuf::from).or_else(|| home_dir_crt())\n+    crate::env::var_os(\"HOME\")\n+        .or_else(|| crate::env::var_os(\"USERPROFILE\"))\n+        .map(PathBuf::from)\n+        .or_else(|| home_dir_crt())\n }\n \n pub fn exit(code: i32) -> ! {\n@@ -332,7 +337,10 @@ mod tests {\n     #[test]\n     fn ntstatus_error() {\n         const STATUS_UNSUCCESSFUL: u32 = 0xc000_0001;\n-        assert!(!Error::from_raw_os_error((STATUS_UNSUCCESSFUL | c::FACILITY_NT_BIT) as _)\n-            .to_string().contains(\"FormatMessageW() returned error\"));\n+        assert!(\n+            !Error::from_raw_os_error((STATUS_UNSUCCESSFUL | c::FACILITY_NT_BIT) as _)\n+                .to_string()\n+                .contains(\"FormatMessageW() returned error\")\n+        );\n     }\n }"}, {"sha": "e451e0cfb5bc4f1ccb13cab922a92ec9ed0add98", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,17 +1,16 @@\n /// The underlying OsString/OsStr implementation on Windows is a\n /// wrapper around the \"WTF-8\" encoding; see the `wtf8` module for more.\n-\n use crate::borrow::Cow;\n use crate::fmt;\n-use crate::sys_common::wtf8::{Wtf8, Wtf8Buf};\n use crate::mem;\n use crate::rc::Rc;\n use crate::sync::Arc;\n-use crate::sys_common::{AsInner, IntoInner, FromInner};\n+use crate::sys_common::wtf8::{Wtf8, Wtf8Buf};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n #[derive(Clone, Hash)]\n pub struct Buf {\n-    pub inner: Wtf8Buf\n+    pub inner: Wtf8Buf,\n }\n \n impl IntoInner<Wtf8Buf> for Buf {\n@@ -45,7 +44,7 @@ impl fmt::Display for Buf {\n }\n \n pub struct Slice {\n-    pub inner: Wtf8\n+    pub inner: Wtf8,\n }\n \n impl fmt::Debug for Slice {\n@@ -62,9 +61,7 @@ impl fmt::Display for Slice {\n \n impl Buf {\n     pub fn with_capacity(capacity: usize) -> Buf {\n-        Buf {\n-            inner: Wtf8Buf::with_capacity(capacity)\n-        }\n+        Buf { inner: Wtf8Buf::with_capacity(capacity) }\n     }\n \n     pub fn clear(&mut self) {"}, {"sha": "524f21f889bc2c492fe69c92e35b8b56f26a79c7", "filename": "src/libstd/sys/windows/path.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,6 +1,6 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n use crate::mem;\n+use crate::path::Prefix;\n \n fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n     unsafe { mem::transmute(s) }\n@@ -38,8 +38,9 @@ pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n                     // \\\\?\\UNC\\server\\share\n                     path = &path[4..];\n                     let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n-                        Some((server, share)) =>\n-                            (u8_slice_as_os_str(server), u8_slice_as_os_str(share)),\n+                        Some((server, share)) => {\n+                            (u8_slice_as_os_str(server), u8_slice_as_os_str(share))\n+                        }\n                         None => (u8_slice_as_os_str(path), u8_slice_as_os_str(&[])),\n                     };\n                     return Some(VerbatimUNC(server, share));\n@@ -70,7 +71,7 @@ pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n                 }\n                 _ => (),\n             }\n-        } else if path.get(1) == Some(& b':') {\n+        } else if path.get(1) == Some(&b':') {\n             // C:\n             let c = path[0];\n             if c.is_ascii() && (c as char).is_alphabetic() {"}, {"sha": "992e634dea510f6e852d40fbddd6003c4a35c34e", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 44, "deletions": 55, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -6,8 +6,8 @@ use crate::mem;\n use crate::path::Path;\n use crate::ptr;\n use crate::slice;\n-use crate::sync::atomic::Ordering::SeqCst;\n use crate::sync::atomic::AtomicUsize;\n+use crate::sync::atomic::Ordering::SeqCst;\n use crate::sys::c;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n@@ -63,32 +63,32 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n         let mut reject_remote_clients_flag = c::PIPE_REJECT_REMOTE_CLIENTS;\n         loop {\n             tries += 1;\n-            name = format!(r\"\\\\.\\pipe\\__rust_anonymous_pipe1__.{}.{}\",\n-                           c::GetCurrentProcessId(),\n-                           random_number());\n-            let wide_name = OsStr::new(&name)\n-                                  .encode_wide()\n-                                  .chain(Some(0))\n-                                  .collect::<Vec<_>>();\n-            let mut flags = c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n-                c::FILE_FLAG_OVERLAPPED;\n+            name = format!(\n+                r\"\\\\.\\pipe\\__rust_anonymous_pipe1__.{}.{}\",\n+                c::GetCurrentProcessId(),\n+                random_number()\n+            );\n+            let wide_name = OsStr::new(&name).encode_wide().chain(Some(0)).collect::<Vec<_>>();\n+            let mut flags = c::FILE_FLAG_FIRST_PIPE_INSTANCE | c::FILE_FLAG_OVERLAPPED;\n             if ours_readable {\n                 flags |= c::PIPE_ACCESS_INBOUND;\n             } else {\n                 flags |= c::PIPE_ACCESS_OUTBOUND;\n             }\n \n-            let handle = c::CreateNamedPipeW(wide_name.as_ptr(),\n-                                             flags,\n-                                             c::PIPE_TYPE_BYTE |\n-                                             c::PIPE_READMODE_BYTE |\n-                                             c::PIPE_WAIT |\n-                                             reject_remote_clients_flag,\n-                                             1,\n-                                             4096,\n-                                             4096,\n-                                             0,\n-                                             ptr::null_mut());\n+            let handle = c::CreateNamedPipeW(\n+                wide_name.as_ptr(),\n+                flags,\n+                c::PIPE_TYPE_BYTE\n+                    | c::PIPE_READMODE_BYTE\n+                    | c::PIPE_WAIT\n+                    | reject_remote_clients_flag,\n+                1,\n+                4096,\n+                4096,\n+                0,\n+                ptr::null_mut(),\n+            );\n \n             // We pass the `FILE_FLAG_FIRST_PIPE_INSTANCE` flag above, and we're\n             // also just doing a best effort at selecting a unique name. If\n@@ -112,18 +112,19 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n                 let raw_os_err = err.raw_os_error();\n                 if tries < 10 {\n                     if raw_os_err == Some(c::ERROR_ACCESS_DENIED as i32) {\n-                        continue\n-                    } else if reject_remote_clients_flag != 0 &&\n-                        raw_os_err == Some(c::ERROR_INVALID_PARAMETER as i32) {\n+                        continue;\n+                    } else if reject_remote_clients_flag != 0\n+                        && raw_os_err == Some(c::ERROR_INVALID_PARAMETER as i32)\n+                    {\n                         reject_remote_clients_flag = 0;\n                         tries -= 1;\n-                        continue\n+                        continue;\n                     }\n                 }\n-                return Err(err)\n+                return Err(err);\n             }\n             ours = Handle::new(handle);\n-            break\n+            break;\n         }\n \n         // Connect to the named pipe we just created. This handle is going to be\n@@ -158,16 +159,20 @@ fn random_number() -> usize {\n     static N: AtomicUsize = AtomicUsize::new(0);\n     loop {\n         if N.load(SeqCst) != 0 {\n-            return N.fetch_add(1, SeqCst)\n+            return N.fetch_add(1, SeqCst);\n         }\n \n         N.store(hashmap_random_keys().0 as usize, SeqCst);\n     }\n }\n \n impl AnonPipe {\n-    pub fn handle(&self) -> &Handle { &self.inner }\n-    pub fn into_handle(self) -> Handle { self.inner }\n+    pub fn handle(&self) -> &Handle {\n+        &self.inner\n+    }\n+    pub fn into_handle(self) -> Handle {\n+        self.inner\n+    }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n@@ -186,10 +191,7 @@ impl AnonPipe {\n     }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             v1: &mut Vec<u8>,\n-             p2: AnonPipe,\n-             v2: &mut Vec<u8>) -> io::Result<()> {\n+pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n     let p1 = p1.into_handle();\n     let p2 = p2.into_handle();\n \n@@ -206,19 +208,17 @@ pub fn read2(p1: AnonPipe,\n     // duration of the I/O operation (where tons of operations can also fail).\n     // The destructor for `AsyncPipe` ends up taking care of most of this.\n     loop {\n-        let res = unsafe {\n-            c::WaitForMultipleObjects(2, objs.as_ptr(), c::FALSE, c::INFINITE)\n-        };\n+        let res = unsafe { c::WaitForMultipleObjects(2, objs.as_ptr(), c::FALSE, c::INFINITE) };\n         if res == c::WAIT_OBJECT_0 {\n             if !p1.result()? || !p1.schedule_read()? {\n-                return p2.finish()\n+                return p2.finish();\n             }\n         } else if res == c::WAIT_OBJECT_0 + 1 {\n             if !p2.result()? || !p2.schedule_read()? {\n-                return p1.finish()\n+                return p1.finish();\n             }\n         } else {\n-            return Err(io::Error::last_os_error())\n+            return Err(io::Error::last_os_error());\n         }\n     }\n }\n@@ -251,17 +251,9 @@ impl<'a> AsyncPipe<'a> {\n         // and the only time an even will go back to \"unset\" will be once an\n         // I/O operation is successfully scheduled (what we want).\n         let event = Handle::new_event(true, true)?;\n-        let mut overlapped: Box<c::OVERLAPPED> = unsafe {\n-            Box::new(mem::zeroed())\n-        };\n+        let mut overlapped: Box<c::OVERLAPPED> = unsafe { Box::new(mem::zeroed()) };\n         overlapped.hEvent = event.raw();\n-        Ok(AsyncPipe {\n-            pipe,\n-            overlapped,\n-            event,\n-            dst,\n-            state: State::NotReading,\n-        })\n+        Ok(AsyncPipe { pipe, overlapped, event, dst, state: State::NotReading })\n     }\n \n     /// Executes an overlapped read operation.\n@@ -306,9 +298,7 @@ impl<'a> AsyncPipe<'a> {\n     fn result(&mut self) -> io::Result<bool> {\n         let amt = match self.state {\n             State::NotReading => return Ok(true),\n-            State::Reading => {\n-                self.pipe.overlapped_result(&mut *self.overlapped, true)?\n-            }\n+            State::Reading => self.pipe.overlapped_result(&mut *self.overlapped, true)?,\n             State::Read(amt) => amt,\n         };\n         self.state = State::NotReading;\n@@ -364,6 +354,5 @@ unsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] {\n     if v.capacity() == v.len() {\n         v.reserve(1);\n     }\n-    slice::from_raw_parts_mut(v.as_mut_ptr().add(v.len()),\n-                              v.capacity() - v.len())\n+    slice::from_raw_parts_mut(v.as_mut_ptr().add(v.len()), v.capacity() - v.len())\n }"}, {"sha": "87ea416bf675af590f119be2438c3d291c6ecb7e", "filename": "src/libstd/sys/windows/rand.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -5,13 +5,10 @@ use crate::sys::c;\n #[cfg(not(target_vendor = \"uwp\"))]\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut v = (0, 0);\n-    let ret = unsafe {\n-        c::RtlGenRandom(&mut v as *mut _ as *mut u8,\n-                        mem::size_of_val(&v) as c::ULONG)\n-    };\n+    let ret =\n+        unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n     if ret == 0 {\n-        panic!(\"couldn't generate random bytes: {}\",\n-               io::Error::last_os_error());\n+        panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n     }\n     v\n }\n@@ -22,13 +19,15 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n \n     let mut v = (0, 0);\n     let ret = unsafe {\n-        c::BCryptGenRandom(ptr::null_mut(), &mut v as *mut _ as *mut u8,\n-                           mem::size_of_val(&v) as c::ULONG,\n-                           c::BCRYPT_USE_SYSTEM_PREFERRED_RNG)\n+        c::BCryptGenRandom(\n+            ptr::null_mut(),\n+            &mut v as *mut _ as *mut u8,\n+            mem::size_of_val(&v) as c::ULONG,\n+            c::BCRYPT_USE_SYSTEM_PREFERRED_RNG,\n+        )\n     };\n     if ret != 0 {\n-        panic!(\"couldn't generate random bytes: {}\",\n-               io::Error::last_os_error());\n+        panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n     }\n-    return v\n+    return v;\n }"}, {"sha": "187ad4e66c3efcaedf613623ac714e2eccd5fdd4", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,7 +1,7 @@\n #![cfg_attr(test, allow(dead_code))]\n \n-use crate::sys_common::util::report_overflow;\n use crate::sys::c;\n+use crate::sys_common::util::report_overflow;\n \n pub struct Handler;\n \n@@ -18,8 +18,7 @@ impl Handler {\n     }\n }\n \n-extern \"system\" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS)\n-                                    -> c::LONG {\n+extern \"system\" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS) -> c::LONG {\n     unsafe {\n         let rec = &(*(*ExceptionInfo).ExceptionRecord);\n         let code = rec.ExceptionCode;"}, {"sha": "f322c2b1d96c96779b9d5153d49ba741b645d77e", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -68,9 +68,11 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n     let utf8 = match str::from_utf8(&data[..len]) {\n         Ok(s) => s,\n         Err(ref e) if e.valid_up_to() == 0 => {\n-            return Err(io::Error::new(io::ErrorKind::InvalidData,\n-                \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\"))\n-        },\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidData,\n+                \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+            ));\n+        }\n         Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n     };\n     let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n@@ -93,18 +95,19 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n         // write the missing surrogate out now.\n         // Buffering it would mean we have to lie about the number of bytes written.\n         let first_char_remaining = utf16[written];\n-        if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF { // low surrogate\n+        if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF {\n+            // low surrogate\n             // We just hope this works, and give up otherwise\n-            let _ = write_u16s(handle, &utf16[written..written+1]);\n+            let _ = write_u16s(handle, &utf16[written..written + 1]);\n             written += 1;\n         }\n         // Calculate the number of bytes of `utf8` that were actually written.\n         let mut count = 0;\n         for ch in utf16[..written].iter() {\n             count += match ch {\n-                0x0000 ..= 0x007F => 1,\n-                0x0080 ..= 0x07FF => 2,\n-                0xDCEE ..= 0xDFFF => 1, // Low surrogate. We already counted 3 bytes for the other.\n+                0x0000..=0x007F => 1,\n+                0x0080..=0x07FF => 2,\n+                0xDCEE..=0xDFFF => 1, // Low surrogate. We already counted 3 bytes for the other.\n                 _ => 3,\n             };\n         }\n@@ -116,11 +119,13 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n fn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n     let mut written = 0;\n     cvt(unsafe {\n-        c::WriteConsoleW(handle,\n-                         data.as_ptr() as c::LPCVOID,\n-                         data.len() as u32,\n-                         &mut written,\n-                         ptr::null_mut())\n+        c::WriteConsoleW(\n+            handle,\n+            data.as_ptr() as c::LPCVOID,\n+            data.len() as u32,\n+            &mut written,\n+            ptr::null_mut(),\n+        )\n     })?;\n     Ok(written as usize)\n }\n@@ -144,9 +149,11 @@ impl io::Read for Stdin {\n         if buf.len() == 0 {\n             return Ok(0);\n         } else if buf.len() < 4 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                        \"Windows stdin in console mode does not support a buffer too small to \\\n-                        guarantee holding one arbitrary UTF-8 character (4 bytes)\"))\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Windows stdin in console mode does not support a buffer too small to \\\n+                 guarantee holding one arbitrary UTF-8 character (4 bytes)\",\n+            ));\n         }\n \n         let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n@@ -160,15 +167,15 @@ impl io::Read for Stdin {\n     }\n }\n \n-\n // We assume that if the last `u16` is an unpaired surrogate they got sliced apart by our\n // buffer size, and keep it around for the next read hoping to put them together.\n // This is a best effort, and may not work if we are not the only reader on Stdin.\n-fn read_u16s_fixup_surrogates(handle: c::HANDLE,\n-                              buf: &mut [u16],\n-                              mut amount: usize,\n-                              surrogate: &mut u16) -> io::Result<usize>\n-{\n+fn read_u16s_fixup_surrogates(\n+    handle: c::HANDLE,\n+    buf: &mut [u16],\n+    mut amount: usize,\n+    surrogate: &mut u16,\n+) -> io::Result<usize> {\n     // Insert possibly remaining unpaired surrogate from last read.\n     let mut start = 0;\n     if *surrogate != 0 {\n@@ -186,7 +193,8 @@ fn read_u16s_fixup_surrogates(handle: c::HANDLE,\n \n     if amount > 0 {\n         let last_char = buf[amount - 1];\n-        if last_char >= 0xD800 && last_char <= 0xDBFF { // high surrogate\n+        if last_char >= 0xD800 && last_char <= 0xDBFF {\n+            // high surrogate\n             *surrogate = last_char;\n             amount -= 1;\n         }\n@@ -209,11 +217,13 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n \n     let mut amount = 0;\n     cvt(unsafe {\n-        c::ReadConsoleW(handle,\n-                        buf.as_mut_ptr() as c::LPVOID,\n-                        buf.len() as u32,\n-                        &mut amount,\n-                        &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL)\n+        c::ReadConsoleW(\n+            handle,\n+            buf.as_mut_ptr() as c::LPVOID,\n+            buf.len() as u32,\n+            &mut amount,\n+            &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL,\n+        )\n     })?;\n \n     if amount > 0 && buf[amount as usize - 1] == CTRL_Z {\n@@ -233,9 +243,11 @@ fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n             }\n             Err(_) => {\n                 // We can't really do any better than forget all data and return an error.\n-                return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                return Err(io::Error::new(\n+                    io::ErrorKind::InvalidData,\n                     \"Windows stdin in console mode does not support non-UTF-16 input; \\\n-                    encountered unpaired surrogate\"))\n+                     encountered unpaired surrogate\",\n+                ));\n             }\n         }\n     }"}, {"sha": "0f2178f73532feda05eaf93c47c7a0511fbe7cc7", "filename": "src/libstd/sys/windows/stdio_uwp.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,12 +1,11 @@\n #![unstable(issue = \"0\", feature = \"windows_stdio\")]\n \n use crate::io;\n+use crate::mem::ManuallyDrop;\n use crate::sys::c;\n use crate::sys::handle::Handle;\n-use crate::mem::ManuallyDrop;\n \n-pub struct Stdin {\n-}\n+pub struct Stdin {}\n pub struct Stdout;\n pub struct Stderr;\n \n@@ -32,7 +31,7 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n-        Ok(Stdin { })\n+        Ok(Stdin {})\n     }\n }\n "}, {"sha": "c828243a59b1190a6ec6fc2b1b4a667611640943", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -1,5 +1,5 @@\n-use crate::io;\n use crate::ffi::CStr;\n+use crate::io;\n use crate::mem;\n use crate::ptr;\n use crate::sys::c;\n@@ -14,13 +14,12 @@ use super::to_u16s;\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n \n pub struct Thread {\n-    handle: Handle\n+    handle: Handle,\n }\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n-                          -> io::Result<Thread> {\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         let p = box p;\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n@@ -31,10 +30,14 @@ impl Thread {\n         // Round up to the next 64 kB because that's what the NT kernel does,\n         // might as well make it explicit.\n         let stack_size = (stack + 0xfffe) & (!0xfffe);\n-        let ret = c::CreateThread(ptr::null_mut(), stack_size,\n-                                  thread_start, &*p as *const _ as *mut _,\n-                                  c::STACK_SIZE_PARAM_IS_A_RESERVATION,\n-                                  ptr::null_mut());\n+        let ret = c::CreateThread(\n+            ptr::null_mut(),\n+            stack_size,\n+            thread_start,\n+            &*p as *const _ as *mut _,\n+            c::STACK_SIZE_PARAM_IS_A_RESERVATION,\n+            ptr::null_mut(),\n+        );\n \n         return if ret as usize == 0 {\n             Err(io::Error::last_os_error())\n@@ -44,48 +47,59 @@ impl Thread {\n         };\n \n         extern \"system\" fn thread_start(main: *mut c_void) -> c::DWORD {\n-            unsafe { start_thread(main as *mut u8); }\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n             0\n         }\n     }\n \n     pub fn set_name(name: &CStr) {\n         if let Ok(utf8) = name.to_str() {\n             if let Ok(utf16) = to_u16s(utf8) {\n-                unsafe { c::SetThreadDescription(c::GetCurrentThread(), utf16.as_ptr()); };\n+                unsafe {\n+                    c::SetThreadDescription(c::GetCurrentThread(), utf16.as_ptr());\n+                };\n             };\n         };\n     }\n \n     pub fn join(self) {\n         let rc = unsafe { c::WaitForSingleObject(self.handle.raw(), c::INFINITE) };\n         if rc == c::WAIT_FAILED {\n-            panic!(\"failed to join on thread: {}\",\n-                   io::Error::last_os_error());\n+            panic!(\"failed to join on thread: {}\", io::Error::last_os_error());\n         }\n     }\n \n     pub fn yield_now() {\n         // This function will return 0 if there are no other threads to execute,\n         // but this also means that the yield was useless so this isn't really a\n         // case that needs to be worried about.\n-        unsafe { c::SwitchToThread(); }\n+        unsafe {\n+            c::SwitchToThread();\n+        }\n     }\n \n     pub fn sleep(dur: Duration) {\n-        unsafe {\n-            c::Sleep(super::dur2timeout(dur))\n-        }\n+        unsafe { c::Sleep(super::dur2timeout(dur)) }\n     }\n \n-    pub fn handle(&self) -> &Handle { &self.handle }\n+    pub fn handle(&self) -> &Handle {\n+        &self.handle\n+    }\n \n-    pub fn into_handle(self) -> Handle { self.handle }\n+    pub fn into_handle(self) -> Handle {\n+        self.handle\n+    }\n }\n \n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n     pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }"}, {"sha": "e0bb102b3afe5b8e746ea51d420466e41b8112bb", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34fbfaad38cf5829ef5cfe780dc9d58480adeaa/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=c34fbfaad38cf5829ef5cfe780dc9d58480adeaa", "patch": "@@ -5,7 +5,7 @@ use crate::sync::atomic::Ordering::SeqCst;\n use crate::sys::c;\n \n pub type Key = c::DWORD;\n-pub type Dtor = unsafe extern fn(*mut u8);\n+pub type Dtor = unsafe extern \"C\" fn(*mut u8);\n \n // Turns out, like pretty much everything, Windows is pretty close the\n // functionality that Unix provides, but slightly different! In the case of\n@@ -111,11 +111,7 @@ struct Node {\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n-    let mut node = Box::new(Node {\n-        key,\n-        dtor,\n-        next: ptr::null_mut(),\n-    });\n+    let mut node = Box::new(Node { key, dtor, next: ptr::null_mut() });\n \n     let mut head = DTORS.load(SeqCst);\n     loop {\n@@ -192,15 +188,12 @@ unsafe fn register_dtor(key: Key, dtor: Dtor) {\n #[link_section = \".CRT$XLB\"]\n #[allow(dead_code, unused_variables)]\n #[used] // we don't want LLVM eliminating this symbol for any reason, and\n-        // when the symbol makes it to the linker the linker will take over\n-pub static p_thread_callback: unsafe extern \"system\" fn(c::LPVOID, c::DWORD,\n-                                                        c::LPVOID) =\n-        on_tls_callback;\n+// when the symbol makes it to the linker the linker will take over\n+pub static p_thread_callback: unsafe extern \"system\" fn(c::LPVOID, c::DWORD, c::LPVOID) =\n+    on_tls_callback;\n \n #[allow(dead_code, unused_variables)]\n-unsafe extern \"system\" fn on_tls_callback(h: c::LPVOID,\n-                                          dwReason: c::DWORD,\n-                                          pv: c::LPVOID) {\n+unsafe extern \"system\" fn on_tls_callback(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID) {\n     if dwReason == c::DLL_THREAD_DETACH || dwReason == c::DLL_PROCESS_DETACH {\n         run_dtors();\n     }\n@@ -210,7 +203,9 @@ unsafe extern \"system\" fn on_tls_callback(h: c::LPVOID,\n     reference_tls_used();\n     #[cfg(target_env = \"msvc\")]\n     unsafe fn reference_tls_used() {\n-        extern { static _tls_used: u8; }\n+        extern \"C\" {\n+            static _tls_used: u8;\n+        }\n         crate::intrinsics::volatile_load(&_tls_used);\n     }\n     #[cfg(not(target_env = \"msvc\"))]\n@@ -222,7 +217,7 @@ unsafe fn run_dtors() {\n     let mut any_run = true;\n     for _ in 0..5 {\n         if !any_run {\n-            break\n+            break;\n         }\n         any_run = false;\n         let mut cur = DTORS.load(SeqCst);"}]}