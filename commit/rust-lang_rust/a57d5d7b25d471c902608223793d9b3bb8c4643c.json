{"sha": "a57d5d7b25d471c902608223793d9b3bb8c4643c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1N2Q1ZDdiMjVkNDcxYzkwMjYwODIyMzc5M2Q5YjNiYjhjNDY0M2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-22T02:43:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-22T02:43:57Z"}, "message": "Auto merge of #52250 - nnethercote:no-SparseBitMatrix, r=nikomatsakis\n\nSpeed up `SparseBitMatrix` use in `RegionValues`.\n\nIn practice, these matrices range from 10% to 90%+ full once they are\nfilled in, so the dense representation is better.\n\nThis reduces the runtime of Check Nll builds of `inflate` by 32%, and\nseveral other benchmarks by 1--5%.\n\nIt also increases max-rss of `clap-rs` by 30% and a couple of others by\nup to 5%, while decreasing max-rss of `coercions` by 14%. I think the\nspeed-ups justify the max-rss increases.\n\nr? @nikomatsakis", "tree": {"sha": "32b660414066a1c5cd1af1e3a1a95ae921a7cc60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32b660414066a1c5cd1af1e3a1a95ae921a7cc60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a57d5d7b25d471c902608223793d9b3bb8c4643c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a57d5d7b25d471c902608223793d9b3bb8c4643c", "html_url": "https://github.com/rust-lang/rust/commit/a57d5d7b25d471c902608223793d9b3bb8c4643c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a57d5d7b25d471c902608223793d9b3bb8c4643c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ad6179d3b50101cd7530e24eca9995a730ac8d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad6179d3b50101cd7530e24eca9995a730ac8d9", "html_url": "https://github.com/rust-lang/rust/commit/0ad6179d3b50101cd7530e24eca9995a730ac8d9"}, {"sha": "798209e78b90b83a3742f713b70473b6ab799aca", "url": "https://api.github.com/repos/rust-lang/rust/commits/798209e78b90b83a3742f713b70473b6ab799aca", "html_url": "https://github.com/rust-lang/rust/commit/798209e78b90b83a3742f713b70473b6ab799aca"}], "stats": {"total": 249, "additions": 37, "deletions": 212}, "files": [{"sha": "ee903e49642fc42cd17be1ab32e6d3d5196897b7", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 28, "deletions": 208, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/a57d5d7b25d471c902608223793d9b3bb8c4643c/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57d5d7b25d471c902608223793d9b3bb8c4643c/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=a57d5d7b25d471c902608223793d9b3bb8c4643c", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n use indexed_vec::{Idx, IndexVec};\n-use std::collections::btree_map::Entry;\n-use std::collections::BTreeMap;\n use std::iter::FromIterator;\n use std::marker::PhantomData;\n \n@@ -72,7 +70,7 @@ impl BitVector {\n     }\n \n     #[inline]\n-    pub fn insert_all(&mut self, all: &BitVector) -> bool {\n+    pub fn merge(&mut self, all: &BitVector) -> bool {\n         assert!(self.data.len() == all.data.len());\n         let mut changed = false;\n         for (i, j) in self.data.iter_mut().zip(&all.data) {\n@@ -271,20 +269,26 @@ impl BitMatrix {\n     }\n }\n \n+/// A moderately sparse bit matrix: rows are appended lazily, but columns\n+/// within appended rows are instantiated fully upon creation.\n #[derive(Clone, Debug)]\n pub struct SparseBitMatrix<R, C>\n where\n     R: Idx,\n     C: Idx,\n {\n-    vector: IndexVec<R, SparseBitSet<C>>,\n+    columns: usize,\n+    vector: IndexVec<R, BitVector>,\n+    marker: PhantomData<C>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// Create a new empty sparse bit matrix with no rows or columns.\n-    pub fn new() -> Self {\n+    pub fn new(columns: usize) -> Self {\n         Self {\n+            columns,\n             vector: IndexVec::new(),\n+            marker: PhantomData,\n         }\n     }\n \n@@ -293,23 +297,18 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n     pub fn add(&mut self, row: R, column: C) -> bool {\n-        debug!(\n-            \"add(row={:?}, column={:?}, current_len={})\",\n-            row,\n-            column,\n-            self.vector.len()\n-        );\n+        let columns = self.columns;\n         self.vector\n-            .ensure_contains_elem(row, || SparseBitSet::new());\n-        self.vector[row].insert(column)\n+            .ensure_contains_elem(row, || BitVector::new(columns));\n+        self.vector[row].insert(column.index())\n     }\n \n     /// Do the bits from `row` contain `column`? Put another way, is\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.vector.get(row).map_or(false, |r| r.contains(column))\n+        self.vector.get(row).map_or(false, |r| r.contains(column.index()))\n     }\n \n     /// Add the bits from row `read` to the bits from row `write`,\n@@ -320,39 +319,23 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// `write` can reach everything that `read` can (and\n     /// potentially more).\n     pub fn merge(&mut self, read: R, write: R) -> bool {\n-        let mut changed = false;\n-\n-        if read != write {\n-            if self.vector.get(read).is_some() {\n-                self.vector\n-                    .ensure_contains_elem(write, || SparseBitSet::new());\n-                let (bit_set_read, bit_set_write) = self.vector.pick2_mut(read, write);\n-\n-                for read_chunk in bit_set_read.chunks() {\n-                    changed = changed | bit_set_write.insert_chunk(read_chunk).any();\n-                }\n-            }\n+        if read == write || self.vector.get(read).is_none() {\n+            return false;\n         }\n \n-        changed\n+        let columns = self.columns;\n+        self.vector\n+            .ensure_contains_elem(write, || BitVector::new(columns));\n+        let (bitvec_read, bitvec_write) = self.vector.pick2_mut(read, write);\n+        bitvec_write.merge(bitvec_read)\n     }\n \n     /// Merge a row, `from`, into the `into` row.\n-    pub fn merge_into(&mut self, into: R, from: &SparseBitSet<C>) -> bool {\n+    pub fn merge_into(&mut self, into: R, from: &BitVector) -> bool {\n+        let columns = self.columns;\n         self.vector\n-            .ensure_contains_elem(into, || SparseBitSet::new());\n-        self.vector[into].insert_from(from)\n-    }\n-\n-    /// True if `sub` is a subset of `sup`\n-    pub fn is_subset(&self, sub: R, sup: R) -> bool {\n-        sub == sup || {\n-            let bit_set_sub = &self.vector[sub];\n-            let bit_set_sup = &self.vector[sup];\n-            bit_set_sub\n-                .chunks()\n-                .all(|read_chunk| read_chunk.bits_eq(bit_set_sup.contains_chunk(read_chunk)))\n-        }\n+            .ensure_contains_elem(into, || BitVector::new(columns));\n+        self.vector[into].merge(from)\n     }\n \n     /// Number of elements in the matrix.\n@@ -363,178 +346,15 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n-        self.vector.get(row).into_iter().flat_map(|r| r.iter())\n+        self.vector.get(row).into_iter().flat_map(|r| r.iter().map(|n| C::new(n)))\n     }\n \n     /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a SparseBitSet<C>)> + 'a {\n+    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitVector)> + 'a {\n         self.vector.iter_enumerated()\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct SparseBitSet<I: Idx> {\n-    chunk_bits: BTreeMap<u32, Word>,\n-    _marker: PhantomData<I>,\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct SparseChunk<I> {\n-    key: u32,\n-    bits: Word,\n-    _marker: PhantomData<I>,\n-}\n-\n-impl<I: Idx> SparseChunk<I> {\n-    #[inline]\n-    pub fn one(index: I) -> Self {\n-        let index = index.index();\n-        let key_usize = index / 128;\n-        let key = key_usize as u32;\n-        assert_eq!(key as usize, key_usize);\n-        SparseChunk {\n-            key,\n-            bits: 1 << (index % 128),\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn any(&self) -> bool {\n-        self.bits != 0\n-    }\n-\n-    #[inline]\n-    pub fn bits_eq(&self, other: SparseChunk<I>) -> bool {\n-        self.bits == other.bits\n-    }\n-\n-    pub fn iter(&self) -> impl Iterator<Item = I> {\n-        let base = self.key as usize * 128;\n-        let mut bits = self.bits;\n-        (0..128)\n-            .map(move |i| {\n-                let current_bits = bits;\n-                bits >>= 1;\n-                (i, current_bits)\n-            })\n-            .take_while(|&(_, bits)| bits != 0)\n-            .filter_map(move |(i, bits)| {\n-                if (bits & 1) != 0 {\n-                    Some(I::new(base + i))\n-                } else {\n-                    None\n-                }\n-            })\n-    }\n-}\n-\n-impl<I: Idx> SparseBitSet<I> {\n-    pub fn new() -> Self {\n-        SparseBitSet {\n-            chunk_bits: BTreeMap::new(),\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    pub fn capacity(&self) -> usize {\n-        self.chunk_bits.len() * 128\n-    }\n-\n-    /// Returns a chunk containing only those bits that are already\n-    /// present. You can test therefore if `self` contains all the\n-    /// bits in chunk already by doing `chunk ==\n-    /// self.contains_chunk(chunk)`.\n-    pub fn contains_chunk(&self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n-        SparseChunk {\n-            bits: self.chunk_bits\n-                .get(&chunk.key)\n-                .map_or(0, |bits| bits & chunk.bits),\n-            ..chunk\n-        }\n-    }\n-\n-    /// Modifies `self` to contain all the bits from `chunk` (in\n-    /// addition to any pre-existing bits); returns a new chunk that\n-    /// contains only those bits that were newly added. You can test\n-    /// if anything was inserted by invoking `any()` on the returned\n-    /// value.\n-    pub fn insert_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n-        if chunk.bits == 0 {\n-            return chunk;\n-        }\n-        let bits = self.chunk_bits.entry(chunk.key).or_insert(0);\n-        let old_bits = *bits;\n-        let new_bits = old_bits | chunk.bits;\n-        *bits = new_bits;\n-        let changed = new_bits ^ old_bits;\n-        SparseChunk {\n-            bits: changed,\n-            ..chunk\n-        }\n-    }\n-\n-    /// Insert into bit set from another bit set.\n-    pub fn insert_from(&mut self, from: &SparseBitSet<I>) -> bool {\n-        let mut changed = false;\n-        for read_chunk in from.chunks() {\n-            changed = changed | self.insert_chunk(read_chunk).any();\n-        }\n-        changed\n-    }\n-\n-    pub fn remove_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n-        if chunk.bits == 0 {\n-            return chunk;\n-        }\n-        let changed = match self.chunk_bits.entry(chunk.key) {\n-            Entry::Occupied(mut bits) => {\n-                let old_bits = *bits.get();\n-                let new_bits = old_bits & !chunk.bits;\n-                if new_bits == 0 {\n-                    bits.remove();\n-                } else {\n-                    bits.insert(new_bits);\n-                }\n-                new_bits ^ old_bits\n-            }\n-            Entry::Vacant(_) => 0,\n-        };\n-        SparseChunk {\n-            bits: changed,\n-            ..chunk\n-        }\n-    }\n-\n-    pub fn clear(&mut self) {\n-        self.chunk_bits.clear();\n-    }\n-\n-    pub fn chunks<'a>(&'a self) -> impl Iterator<Item = SparseChunk<I>> + 'a {\n-        self.chunk_bits.iter().map(|(&key, &bits)| SparseChunk {\n-            key,\n-            bits,\n-            _marker: PhantomData,\n-        })\n-    }\n-\n-    pub fn contains(&self, index: I) -> bool {\n-        self.contains_chunk(SparseChunk::one(index)).any()\n-    }\n-\n-    pub fn insert(&mut self, index: I) -> bool {\n-        self.insert_chunk(SparseChunk::one(index)).any()\n-    }\n-\n-    pub fn remove(&mut self, index: I) -> bool {\n-        self.remove_chunk(SparseChunk::one(index)).any()\n-    }\n-\n-    pub fn iter<'a>(&'a self) -> impl Iterator<Item = I> + 'a {\n-        self.chunks().flat_map(|chunk| chunk.iter())\n-    }\n-}\n-\n #[inline]\n fn words(elements: usize) -> usize {\n     (elements + WORD_BITS - 1) / WORD_BITS\n@@ -584,8 +404,8 @@ fn union_two_vecs() {\n     assert!(!vec1.insert(3));\n     assert!(vec2.insert(5));\n     assert!(vec2.insert(64));\n-    assert!(vec1.insert_all(&vec2));\n-    assert!(!vec1.insert_all(&vec2));\n+    assert!(vec1.merge(&vec2));\n+    assert!(!vec1.merge(&vec2));\n     assert!(vec1.contains(3));\n     assert!(!vec1.contains(4));\n     assert!(vec1.contains(5));"}, {"sha": "20b188424f9f3ef050edd24fa84fd0ddfd212f95", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a57d5d7b25d471c902608223793d9b3bb8c4643c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57d5d7b25d471c902608223793d9b3bb8c4643c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=a57d5d7b25d471c902608223793d9b3bb8c4643c", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::bitvec::{SparseBitMatrix, SparseBitSet};\n+use rustc_data_structures::bitvec::{BitVector, SparseBitMatrix};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -55,6 +55,11 @@ impl RegionValueElements {\n         }\n     }\n \n+    /// Total number of element indices that exist.\n+    crate fn num_elements(&self) -> usize {\n+        self.num_points + self.num_universal_regions\n+    }\n+\n     /// Converts an element of a region value into a `RegionElementIndex`.\n     crate fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n         elem.to_element_index(self)\n@@ -186,7 +191,7 @@ impl<N: Idx> RegionValues<N> {\n     crate fn new(elements: &Rc<RegionValueElements>) -> Self {\n         Self {\n             elements: elements.clone(),\n-            matrix: SparseBitMatrix::new(),\n+            matrix: SparseBitMatrix::new(elements.num_elements()),\n         }\n     }\n \n@@ -217,12 +222,12 @@ impl<N: Idx> RegionValues<N> {\n     /// Iterates through each row and the accompanying bit set.\n     pub fn iter_enumerated<'a>(\n         &'a self\n-    ) -> impl Iterator<Item = (N, &'a SparseBitSet<RegionElementIndex>)> + 'a {\n+    ) -> impl Iterator<Item = (N, &'a BitVector)> + 'a {\n         self.matrix.iter_enumerated()\n     }\n \n     /// Merge a row, `from`, originating in another `RegionValues` into the `into` row.\n-    pub fn merge_into(&mut self, into: N, from: &SparseBitSet<RegionElementIndex>) -> bool {\n+    pub fn merge_into(&mut self, into: N, from: &BitVector) -> bool {\n         self.matrix.merge_into(into, from)\n     }\n "}]}