{"sha": "7bb5b3eb3228df648a08b02c85eddcd9b9cc85bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYjViM2ViMzIyOGRmNjQ4YTA4YjAyYzg1ZWRkY2Q5YjljYzg1YmQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-08-19T13:51:35Z"}, "committer": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-09-22T19:01:21Z"}, "message": "add MaybeUninit and deprecate mem::{uninitialized,zeroed}", "tree": {"sha": "4e4850f64c5f199af91a6cabcbcac9282626bb83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e4850f64c5f199af91a6cabcbcac9282626bb83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bb5b3eb3228df648a08b02c85eddcd9b9cc85bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bb5b3eb3228df648a08b02c85eddcd9b9cc85bd", "html_url": "https://github.com/rust-lang/rust/commit/7bb5b3eb3228df648a08b02c85eddcd9b9cc85bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bb5b3eb3228df648a08b02c85eddcd9b9cc85bd/comments", "author": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "url": "https://api.github.com/repos/rust-lang/rust/commits/af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "html_url": "https://github.com/rust-lang/rust/commit/af50e3822c4ceda60445c4a2adbb3bfa480ebd39"}], "stats": {"total": 95, "additions": 95, "deletions": 0}, "files": [{"sha": "91522885b598b615261aacf4de973ce29dc5269c", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7bb5b3eb3228df648a08b02c85eddcd9b9cc85bd/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb5b3eb3228df648a08b02c85eddcd9b9cc85bd/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=7bb5b3eb3228df648a08b02c85eddcd9b9cc85bd", "patch": "@@ -514,6 +514,7 @@ pub fn needs_drop<T>() -> bool {\n /// assert_eq!(0, x);\n /// ```\n #[inline]\n+#[rustc_deprecated(since = \"1.30.0\", reason = \"use `mem::MaybeUninit::zeroed` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n@@ -608,6 +609,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n /// [`Drop`]: ../ops/trait.Drop.html\n #[inline]\n+#[rustc_deprecated(since = \"1.30.0\", reason = \"use `mem::MaybeUninit::uninitialized` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n@@ -1024,3 +1026,96 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n         &mut self.value\n     }\n }\n+\n+/// A newtype to construct uninitialized instances of `T`\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+pub union MaybeUninit<T> {\n+    uninit: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+impl<T> MaybeUninit<T> {\n+    /// Create a new `MaybeUninit` in an uninitialized state.\n+    ///\n+    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub const fn uninitialized() -> MaybeUninit<T> {\n+        MaybeUninit { uninit: () }\n+    }\n+\n+    /// Create a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// filled with `0` bytes.  It depends on `T` whether that already makes for\n+    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n+    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n+    /// be null.\n+    ///\n+    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub fn zeroed() -> MaybeUninit<T> {\n+        let mut u = MaybeUninit::<T>::uninitialized();\n+        unsafe {\n+            u.as_mut_ptr().write_bytes(0u8, 1);\n+        }\n+        u\n+    }\n+\n+    /// Set the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub fn set(&mut self, val: T) {\n+        unsafe {\n+            self.value = ManuallyDrop::new(val);\n+        }\n+    }\n+\n+    /// Extract the value from the `MaybeUninit` container.  This is a great way\n+    /// to ensure that the data will get dropped, because the resulting `T` is\n+    /// subject to the usual drop handling.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// state, otherwise this will immediately cause undefined behavior.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub unsafe fn into_inner(self) -> T {\n+        ManuallyDrop::into_inner(self.value)\n+    }\n+\n+    /// Get a reference to the contained value.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// state, otherwise this will immediately cause undefined behavior.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub unsafe fn get_ref(&self) -> &T {\n+        &*self.value\n+    }\n+\n+    /// Get a mutable reference to the contained value.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// state, otherwise this will immediately cause undefined behavior.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub unsafe fn get_mut(&mut self) -> &mut T {\n+        &mut *self.value\n+    }\n+\n+    /// Get a pointer to the contained value. Reading from this pointer will be undefined\n+    /// behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Get a mutable pointer to the contained value. Reading from this pointer will be undefined\n+    /// behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+}"}]}