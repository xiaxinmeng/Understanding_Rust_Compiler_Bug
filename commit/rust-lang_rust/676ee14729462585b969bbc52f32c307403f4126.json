{"sha": "676ee14729462585b969bbc52f32c307403f4126", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NmVlMTQ3Mjk0NjI1ODViOTY5YmJjNTJmMzJjMzA3NDAzZjQxMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-06T20:04:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-06T20:04:32Z"}, "message": "Auto merge of #79930 - tgnottingham:bufwriter_performance, r=m-ou-se\n\nOptimize BufWriter", "tree": {"sha": "ef4803610848404685b3d0df9b4c410e03d27a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef4803610848404685b3d0df9b4c410e03d27a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/676ee14729462585b969bbc52f32c307403f4126", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/676ee14729462585b969bbc52f32c307403f4126", "html_url": "https://github.com/rust-lang/rust/commit/676ee14729462585b969bbc52f32c307403f4126", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/676ee14729462585b969bbc52f32c307403f4126/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "377d1a984cd2a53327092b90aa1d8b7e22d1e347", "url": "https://api.github.com/repos/rust-lang/rust/commits/377d1a984cd2a53327092b90aa1d8b7e22d1e347", "html_url": "https://github.com/rust-lang/rust/commit/377d1a984cd2a53327092b90aa1d8b7e22d1e347"}, {"sha": "01e701828c6010873def5d79191319a6b37a6b32", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e701828c6010873def5d79191319a6b37a6b32", "html_url": "https://github.com/rust-lang/rust/commit/01e701828c6010873def5d79191319a6b37a6b32"}], "stats": {"total": 217, "additions": 178, "deletions": 39}, "files": [{"sha": "ef2769d431fbbbd9bba5246059d3d3918cc7303d", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 178, "deletions": 39, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/676ee14729462585b969bbc52f32c307403f4126/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/676ee14729462585b969bbc52f32c307403f4126/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=676ee14729462585b969bbc52f32c307403f4126", "patch": "@@ -4,6 +4,7 @@ use crate::io::{\n     self, Error, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n };\n use crate::mem;\n+use crate::ptr;\n \n /// Wraps a writer and buffers its output.\n ///\n@@ -68,6 +69,10 @@ use crate::mem;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W: Write> {\n     inner: Option<W>,\n+    // The buffer. Avoid using this like a normal `Vec` in common code paths.\n+    // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n+    // methods that require bounds checking or the like. This makes an enormous\n+    // difference to performance (we may want to stop using a `Vec` entirely).\n     buf: Vec<u8>,\n     // #30888: If the inner writer panics in a call to write, we don't want to\n     // write the buffered data a second time in BufWriter's destructor. This\n@@ -181,9 +186,14 @@ impl<W: Write> BufWriter<W> {\n     /// data. Writes as much as possible without exceeding capacity. Returns\n     /// the number of bytes written.\n     pub(super) fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n-        let available = self.buf.capacity() - self.buf.len();\n+        let available = self.spare_capacity();\n         let amt_to_buffer = available.min(buf.len());\n-        self.buf.extend_from_slice(&buf[..amt_to_buffer]);\n+\n+        // SAFETY: `amt_to_buffer` is <= buffer's spare capacity by construction.\n+        unsafe {\n+            self.write_to_buffer_unchecked(&buf[..amt_to_buffer]);\n+        }\n+\n         amt_to_buffer\n     }\n \n@@ -331,6 +341,103 @@ impl<W: Write> BufWriter<W> {\n         let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n         (self.inner.take().unwrap(), buf)\n     }\n+\n+    // Ensure this function does not get inlined into `write`, so that it\n+    // remains inlineable and its common path remains as short as possible.\n+    // If this function ends up being called frequently relative to `write`,\n+    // it's likely a sign that the client is using an improperly sized buffer\n+    // or their write patterns are somewhat pathological.\n+    #[cold]\n+    #[inline(never)]\n+    fn write_cold(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        if buf.len() > self.spare_capacity() {\n+            self.flush_buf()?;\n+        }\n+\n+        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n+        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            // Write to the buffer. In this case, we write to the buffer even if it fills it\n+            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n+            // input to the inner writer, which in many cases would be a worse strategy.\n+\n+            // SAFETY: There was either enough spare capacity already, or there wasn't and we\n+            // flushed the buffer to ensure that there is. In the latter case, we know that there\n+            // is because flushing ensured that our entire buffer is spare capacity, and we entered\n+            // this block because the input buffer length is less than that capacity. In either\n+            // case, it's safe to write the input buffer to our buffer.\n+            unsafe {\n+                self.write_to_buffer_unchecked(buf);\n+            }\n+\n+            Ok(buf.len())\n+        }\n+    }\n+\n+    // Ensure this function does not get inlined into `write_all`, so that it\n+    // remains inlineable and its common path remains as short as possible.\n+    // If this function ends up being called frequently relative to `write_all`,\n+    // it's likely a sign that the client is using an improperly sized buffer\n+    // or their write patterns are somewhat pathological.\n+    #[cold]\n+    #[inline(never)]\n+    fn write_all_cold(&mut self, buf: &[u8]) -> io::Result<()> {\n+        // Normally, `write_all` just calls `write` in a loop. We can do better\n+        // by calling `self.get_mut().write_all()` directly, which avoids\n+        // round trips through the buffer in the event of a series of partial\n+        // writes in some circumstances.\n+\n+        if buf.len() > self.spare_capacity() {\n+            self.flush_buf()?;\n+        }\n+\n+        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n+        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write_all(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            // Write to the buffer. In this case, we write to the buffer even if it fills it\n+            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n+            // input to the inner writer, which in many cases would be a worse strategy.\n+\n+            // SAFETY: There was either enough spare capacity already, or there wasn't and we\n+            // flushed the buffer to ensure that there is. In the latter case, we know that there\n+            // is because flushing ensured that our entire buffer is spare capacity, and we entered\n+            // this block because the input buffer length is less than that capacity. In either\n+            // case, it's safe to write the input buffer to our buffer.\n+            unsafe {\n+                self.write_to_buffer_unchecked(buf);\n+            }\n+\n+            Ok(())\n+        }\n+    }\n+\n+    // SAFETY: Requires `buf.len() <= self.buf.capacity() - self.buf.len()`,\n+    // i.e., that input buffer length is less than or equal to spare capacity.\n+    #[inline]\n+    unsafe fn write_to_buffer_unchecked(&mut self, buf: &[u8]) {\n+        debug_assert!(buf.len() <= self.spare_capacity());\n+        let old_len = self.buf.len();\n+        let buf_len = buf.len();\n+        let src = buf.as_ptr();\n+        let dst = self.buf.as_mut_ptr().add(old_len);\n+        ptr::copy_nonoverlapping(src, dst, buf_len);\n+        self.buf.set_len(old_len + buf_len);\n+    }\n+\n+    #[inline]\n+    fn spare_capacity(&self) -> usize {\n+        self.buf.capacity() - self.buf.len()\n+    }\n }\n \n #[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n@@ -402,63 +509,82 @@ impl fmt::Debug for WriterPanicked {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Write for BufWriter<W> {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if buf.len() >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write(buf);\n-            self.panicked = false;\n-            r\n-        } else {\n-            self.buf.extend_from_slice(buf);\n+        // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n+        // See `write_cold` for details.\n+        if buf.len() < self.spare_capacity() {\n+            // SAFETY: safe by above conditional.\n+            unsafe {\n+                self.write_to_buffer_unchecked(buf);\n+            }\n+\n             Ok(buf.len())\n+        } else {\n+            self.write_cold(buf)\n         }\n     }\n \n+    #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        // Normally, `write_all` just calls `write` in a loop. We can do better\n-        // by calling `self.get_mut().write_all()` directly, which avoids\n-        // round trips through the buffer in the event of a series of partial\n-        // writes in some circumstances.\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if buf.len() >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write_all(buf);\n-            self.panicked = false;\n-            r\n-        } else {\n-            self.buf.extend_from_slice(buf);\n+        // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n+        // See `write_all_cold` for details.\n+        if buf.len() < self.spare_capacity() {\n+            // SAFETY: safe by above conditional.\n+            unsafe {\n+                self.write_to_buffer_unchecked(buf);\n+            }\n+\n             Ok(())\n+        } else {\n+            self.write_all_cold(buf)\n         }\n     }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        // FIXME: Consider applying `#[inline]` / `#[inline(never)]` optimizations already applied\n+        // to `write` and `write_all`. The performance benefits can be significant. See #79930.\n         if self.get_ref().is_write_vectored() {\n-            let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-            if self.buf.len() + total_len > self.buf.capacity() {\n+            // We have to handle the possibility that the total length of the buffers overflows\n+            // `usize` (even though this can only happen if multiple `IoSlice`s reference the\n+            // same underlying buffer, as otherwise the buffers wouldn't fit in memory). If the\n+            // computation overflows, then surely the input cannot fit in our buffer, so we forward\n+            // to the inner writer's `write_vectored` method to let it handle it appropriately.\n+            let saturated_total_len =\n+                bufs.iter().fold(0usize, |acc, b| acc.saturating_add(b.len()));\n+\n+            if saturated_total_len > self.spare_capacity() {\n+                // Flush if the total length of the input exceeds our buffer's spare capacity.\n+                // If we would have overflowed, this condition also holds, and we need to flush.\n                 self.flush_buf()?;\n             }\n-            if total_len >= self.buf.capacity() {\n+\n+            if saturated_total_len >= self.buf.capacity() {\n+                // Forward to our inner writer if the total length of the input is greater than or\n+                // equal to our buffer capacity. If we would have overflowed, this condition also\n+                // holds, and we punt to the inner writer.\n                 self.panicked = true;\n                 let r = self.get_mut().write_vectored(bufs);\n                 self.panicked = false;\n                 r\n             } else {\n-                bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n-                Ok(total_len)\n+                // `saturated_total_len < self.buf.capacity()` implies that we did not saturate.\n+\n+                // SAFETY: We checked whether or not the spare capacity was large enough above. If\n+                // it was, then we're safe already. If it wasn't, we flushed, making sufficient\n+                // room for any input <= the buffer size, which includes this input.\n+                unsafe {\n+                    bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));\n+                };\n+\n+                Ok(saturated_total_len)\n             }\n         } else {\n             let mut iter = bufs.iter();\n             let mut total_written = if let Some(buf) = iter.by_ref().find(|&buf| !buf.is_empty()) {\n                 // This is the first non-empty slice to write, so if it does\n                 // not fit in the buffer, we still get to flush and proceed.\n-                if self.buf.len() + buf.len() > self.buf.capacity() {\n+                if buf.len() > self.spare_capacity() {\n                     self.flush_buf()?;\n                 }\n                 if buf.len() >= self.buf.capacity() {\n@@ -469,19 +595,32 @@ impl<W: Write> Write for BufWriter<W> {\n                     self.panicked = false;\n                     return r;\n                 } else {\n-                    self.buf.extend_from_slice(buf);\n+                    // SAFETY: We checked whether or not the spare capacity was large enough above.\n+                    // If it was, then we're safe already. If it wasn't, we flushed, making\n+                    // sufficient room for any input <= the buffer size, which includes this input.\n+                    unsafe {\n+                        self.write_to_buffer_unchecked(buf);\n+                    }\n+\n                     buf.len()\n                 }\n             } else {\n                 return Ok(0);\n             };\n             debug_assert!(total_written != 0);\n             for buf in iter {\n-                if self.buf.len() + buf.len() > self.buf.capacity() {\n-                    break;\n-                } else {\n-                    self.buf.extend_from_slice(buf);\n+                if buf.len() <= self.spare_capacity() {\n+                    // SAFETY: safe by above conditional.\n+                    unsafe {\n+                        self.write_to_buffer_unchecked(buf);\n+                    }\n+\n+                    // This cannot overflow `usize`. If we are here, we've written all of the bytes\n+                    // so far to our buffer, and we've ensured that we never exceed the buffer's\n+                    // capacity. Therefore, `total_written` <= `self.buf.capacity()` <= `usize::MAX`.\n                     total_written += buf.len();\n+                } else {\n+                    break;\n                 }\n             }\n             Ok(total_written)"}]}