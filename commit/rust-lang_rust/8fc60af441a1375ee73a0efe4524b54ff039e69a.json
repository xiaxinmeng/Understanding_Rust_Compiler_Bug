{"sha": "8fc60af441a1375ee73a0efe4524b54ff039e69a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYzYwYWY0NDFhMTM3NWVlNzNhMGVmZTQ1MjRiNTRmZjAzOWU2OWE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-05T02:58:31Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-05T02:59:47Z"}, "message": "Remove by-copy mode from std, mostly\n\nOne instance remains in net_tcp due to a foreign fn. Lots of\ninstances remain in serialization.rs, but IIRC that is being removed.\n\nI had to do unholy things to task-perf-word-count-generic to get it\nto compile after demoding pipes. I may well have messed up its\nperformance, but it passes.", "tree": {"sha": "df2e886ac825f6f95b35a72f2767f20f2ea72741", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df2e886ac825f6f95b35a72f2767f20f2ea72741"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fc60af441a1375ee73a0efe4524b54ff039e69a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc60af441a1375ee73a0efe4524b54ff039e69a", "html_url": "https://github.com/rust-lang/rust/commit/8fc60af441a1375ee73a0efe4524b54ff039e69a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fc60af441a1375ee73a0efe4524b54ff039e69a/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5dfd9b3ce5dd6fbe567ba07e89c70a4db2c4cd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5dfd9b3ce5dd6fbe567ba07e89c70a4db2c4cd4", "html_url": "https://github.com/rust-lang/rust/commit/f5dfd9b3ce5dd6fbe567ba07e89c70a4db2c4cd4"}], "stats": {"total": 297, "additions": 146, "deletions": 151}, "files": [{"sha": "efd5ff65aa5f1cee5ff5ff0ec2c98a9047a53553", "filename": "src/libcore/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -87,7 +87,7 @@ pub fn from_port<A:Send>(port: future_pipe::client::waiting<A>) ->\n     }\n }\n \n-pub fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n+pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n     /*!\n      * Create a future from a function.\n      *\n@@ -99,7 +99,7 @@ pub fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n     Future {state: Pending(move f)}\n }\n \n-pub fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n+pub fn spawn<A:Send>(blk: fn~() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *"}, {"sha": "791c6bccde8c49b9f63ebc6cc78ecdf61fe37e64", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -860,7 +860,7 @@ endpoint is passed to the new task.\n pub fn spawn_service<T: Send, Tb: Send>(\n     init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                           RecvPacketBuffered<T, Tb>),\n-    +service: fn~(v: RecvPacketBuffered<T, Tb>))\n+    service: fn~(v: RecvPacketBuffered<T, Tb>))\n     -> SendPacketBuffered<T, Tb>\n {\n     let (client, server) = init();\n@@ -884,7 +884,7 @@ receive state.\n pub fn spawn_service_recv<T: Send, Tb: Send>(\n     init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                           SendPacketBuffered<T, Tb>),\n-    +service: fn~(v: SendPacketBuffered<T, Tb>))\n+    service: fn~(v: SendPacketBuffered<T, Tb>))\n     -> RecvPacketBuffered<T, Tb>\n {\n     let (client, server) = init();"}, {"sha": "c4ef136a592e68893a6d76408626e088f9e6a680", "filename": "src/libcore/private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -46,7 +46,7 @@ type GlobalPtr = *libc::uintptr_t;\n pub unsafe fn chan_from_global_ptr<T: Send>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n-    +f: fn~(comm::Port<T>)\n+    f: fn~(comm::Port<T>)\n ) -> comm::Chan<T> {\n \n     enum Msg {"}, {"sha": "8d7791d18d90658344da2af94912b132fca13643", "filename": "src/libcore/task.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -220,7 +220,7 @@ pub type TaskOpts = {\n // FIXME (#2585): Replace the 'consumed' bit with move mode on self\n pub enum TaskBuilder = {\n     opts: TaskOpts,\n-    gen_body: fn@(+v: fn~()) -> fn~(),\n+    gen_body: fn@(v: fn~()) -> fn~(),\n     can_not_copy: Option<util::NonCopyable>,\n     mut consumed: bool,\n };\n@@ -233,7 +233,7 @@ pub enum TaskBuilder = {\n pub fn task() -> TaskBuilder {\n     TaskBuilder({\n         opts: default_task_opts(),\n-        gen_body: |+body| move body, // Identity function\n+        gen_body: |body| move body, // Identity function\n         can_not_copy: None,\n         mut consumed: false,\n     })\n@@ -410,7 +410,7 @@ impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(wrapper: fn@(+v: fn~()) -> fn~()) -> TaskBuilder {\n+    fn add_wrapper(wrapper: fn@(v: fn~()) -> fn~()) -> TaskBuilder {\n         let prev_gen_body = self.gen_body;\n         let notify_chan = if self.opts.notify_chan.is_none() {\n             None\n@@ -442,7 +442,7 @@ impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    fn spawn(+f: fn~()) {\n+    fn spawn(f: fn~()) {\n         let notify_chan = if self.opts.notify_chan.is_none() {\n             None\n         } else {\n@@ -460,7 +460,7 @@ impl TaskBuilder {\n         spawn::spawn_raw(move opts, x.gen_body(move f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A: Send>(arg: A, +f: fn~(+v: A)) {\n+    fn spawn_with<A: Send>(arg: A, f: fn~(v: A)) {\n         let arg = ~mut Some(move arg);\n         do self.spawn |move arg, move f| {\n             f(option::swap_unwrap(arg))\n@@ -478,7 +478,7 @@ impl TaskBuilder {\n      * otherwise be required to establish communication from the parent\n      * to the child.\n      */\n-    fn spawn_listener<A: Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+    fn spawn_listener<A: Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n         let setup_po = comm::Port();\n         let setup_ch = comm::Chan(&setup_po);\n         do self.spawn |move f| {\n@@ -494,7 +494,7 @@ impl TaskBuilder {\n      * Runs a new task, setting up communication in both directions\n      */\n     fn spawn_conversation<A: Send, B: Send>\n-        (+f: fn~(comm::Port<A>, comm::Chan<B>))\n+        (f: fn~(comm::Port<A>, comm::Chan<B>))\n         -> (comm::Port<B>, comm::Chan<A>) {\n         let from_child = comm::Port();\n         let to_parent = comm::Chan(&from_child);\n@@ -517,7 +517,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T: Send>(+f: fn~() -> T) -> Result<T,()> {\n+    fn try<T: Send>(f: fn~() -> T) -> Result<T,()> {\n         let po = comm::Port();\n         let ch = comm::Chan(&po);\n         let mut result = None;\n@@ -556,7 +556,7 @@ pub fn default_task_opts() -> TaskOpts {\n \n /* Spawn convenience functions */\n \n-pub fn spawn(+f: fn~()) {\n+pub fn spawn(f: fn~()) {\n     /*!\n      * Creates and executes a new child task\n      *\n@@ -569,7 +569,7 @@ pub fn spawn(+f: fn~()) {\n     task().spawn(move f)\n }\n \n-pub fn spawn_unlinked(+f: fn~()) {\n+pub fn spawn_unlinked(f: fn~()) {\n     /*!\n      * Creates a child task unlinked from the current one. If either this\n      * task or the child task fails, the other will not be killed.\n@@ -578,7 +578,7 @@ pub fn spawn_unlinked(+f: fn~()) {\n     task().unlinked().spawn(move f)\n }\n \n-pub fn spawn_supervised(+f: fn~()) {\n+pub fn spawn_supervised(f: fn~()) {\n     /*!\n      * Creates a child task unlinked from the current one. If either this\n      * task or the child task fails, the other will not be killed.\n@@ -587,7 +587,7 @@ pub fn spawn_supervised(+f: fn~()) {\n     task().supervised().spawn(move f)\n }\n \n-pub fn spawn_with<A:Send>(+arg: A, +f: fn~(+v: A)) {\n+pub fn spawn_with<A:Send>(arg: A, f: fn~(v: A)) {\n     /*!\n      * Runs a task, while transfering ownership of one argument to the\n      * child.\n@@ -601,7 +601,7 @@ pub fn spawn_with<A:Send>(+arg: A, +f: fn~(+v: A)) {\n     task().spawn_with(move arg, move f)\n }\n \n-pub fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+pub fn spawn_listener<A:Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     /*!\n      * Runs a new task while providing a channel from the parent to the child\n      *\n@@ -612,7 +612,7 @@ pub fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n }\n \n pub fn spawn_conversation<A: Send, B: Send>\n-    (+f: fn~(comm::Port<A>, comm::Chan<B>))\n+    (f: fn~(comm::Port<A>, comm::Chan<B>))\n     -> (comm::Port<B>, comm::Chan<A>) {\n     /*!\n      * Runs a new task, setting up communication in both directions\n@@ -623,7 +623,7 @@ pub fn spawn_conversation<A: Send, B: Send>\n     task().spawn_conversation(move f)\n }\n \n-pub fn spawn_sched(mode: SchedMode, +f: fn~()) {\n+pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n     /*!\n      * Creates a new scheduler and executes a task on it\n      *\n@@ -640,7 +640,7 @@ pub fn spawn_sched(mode: SchedMode, +f: fn~()) {\n     task().sched_mode(mode).spawn(move f)\n }\n \n-pub fn try<T:Send>(+f: fn~() -> T) -> Result<T,()> {\n+pub fn try<T:Send>(f: fn~() -> T) -> Result<T,()> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -1127,7 +1127,7 @@ fn test_spawn_sched_blocking() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: fn(+v: fn~())) {\n+fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n     let p = comm::Port::<uint>();\n     let ch = comm::Chan(&p);\n \n@@ -1150,7 +1150,7 @@ fn test_avoid_copying_the_body_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener() {\n-    do avoid_copying_the_body |+f| {\n+    do avoid_copying_the_body |f| {\n         spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });\n@@ -1168,7 +1168,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener_1() {\n-    do avoid_copying_the_body |+f| {\n+    do avoid_copying_the_body |f| {\n         task().spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });"}, {"sha": "6eaace1fa1a1d54df33761a8a5fbba97611e4088", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -488,7 +488,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-pub fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n+pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n@@ -533,7 +533,7 @@ pub fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n     fn make_child_wrapper(child: *rust_task, child_arc: TaskGroupArc,\n                           ancestors: AncestorList, is_main: bool,\n                           notify_chan: Option<Chan<Notification>>,\n-                          +f: fn~()) -> fn~() {\n+                          f: fn~()) -> fn~() {\n         let child_data = ~mut Some((move child_arc, move ancestors));\n         return fn~(move notify_chan, move child_data, move f) {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)"}, {"sha": "addabb2ddb9b3558af47441d00e7b471a5ed02d9", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n /**\n  * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n  * between tasks."}, {"sha": "91af4a3d653187e1e31d72fcfc76e33b08148506", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,4 +1,4 @@\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use vec::{to_mut, from_elem};\n \n@@ -553,7 +553,7 @@ pure fn land(w0: uint, w1: uint) -> uint { return w0 & w1; }\n pure fn right(_w0: uint, w1: uint) -> uint { return w1; }\n \n impl Bitv: ops::Index<uint,bool> {\n-    pure fn index(+i: uint) -> bool {\n+    pure fn index(i: uint) -> bool {\n         self.get(i)\n     }\n }"}, {"sha": "06d56ed1ae529c5d2322c5d23971ba5506b49b63", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -25,6 +25,7 @@\n  * great care must be taken to ensure that a reference to the c_vec::t is\n  * still held if needed.\n  */\n+#[forbid(deprecated_mode)];\n \n /**\n  * The type representing a foreign chunk of memory\n@@ -111,7 +112,7 @@ pub fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-pub fn set<T: Copy>(t: CVec<T>, ofs: uint, +v: T) {\n+pub fn set<T: Copy>(t: CVec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n }"}, {"sha": "c888957728a33dc221505ed612fd33167d3ae810", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,4 +1,4 @@\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n /// A dynamic, mutable location.\n ///\n /// Similar to a mutable option type, but friendlier."}, {"sha": "1a897a2c2fa9a6af3c3e6b0bfc40da40c6500180", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -16,11 +16,11 @@ pub struct DuplexStream<T: Send, U: Send> {\n }\n \n impl<T: Send, U: Send> DuplexStream<T, U> : Channel<T> {\n-    fn send(+x: T) {\n+    fn send(x: T) {\n         self.chan.send(move x)\n     }\n \n-    fn try_send(+x: T) -> bool {\n+    fn try_send(x: T) -> bool {\n         self.chan.try_send(move x)\n     }\n }"}, {"sha": "f141a028e652001f840b73076c99a275de78af3a", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,4 +1,4 @@\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n //! Unsafe debugging functions for inspecting values.\n \n use cast::reinterpret_cast;"}, {"sha": "37798d9a6273362f2e74629960569b0278ba7744", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,5 +1,5 @@\n //! A deque. Untested as of yet. Likely buggy\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n use option::{Some, None};\n@@ -200,7 +200,7 @@ mod tests {\n         assert (deq.get(3) == d);\n     }\n \n-    fn test_parameterized<T: Copy Eq Owned>(a: T, +b: T, +c: T, +d: T) {\n+    fn test_parameterized<T: Copy Eq Owned>(a: T, b: T, c: T, d: T) {\n         let deq: deque::Deque<T> = deque::create::<T>();\n         assert (deq.size() == 0u);\n         deq.add_front(a);"}, {"sha": "3df5a70a0c1f9d9dd13aa41f418abd4b3ddd5cde", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,3 +1,4 @@\n+#[forbid(deprecated_mode)];\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n@@ -17,7 +18,7 @@ pub type Doc = {data: @~[u8], start: uint, end: uint};\n type TaggedDoc = {tag: uint, doc: Doc};\n \n impl Doc: ops::Index<uint,Doc> {\n-    pure fn index(+tag: uint) -> Doc {\n+    pure fn index(tag: uint) -> Doc {\n         unsafe {\n             get_doc(self, tag)\n         }\n@@ -563,11 +564,11 @@ impl EbmlDeserializer: serialization::Deserializer {\n \n #[test]\n fn test_option_int() {\n-    fn serialize_1<S: serialization::Serializer>(&&s: S, v: int) {\n+    fn serialize_1<S: serialization::Serializer>(s: &S, v: int) {\n         s.emit_i64(v as i64);\n     }\n \n-    fn serialize_0<S: serialization::Serializer>(&&s: S, v: Option<int>) {\n+    fn serialize_0<S: serialization::Serializer>(s: &S, v: Option<int>) {\n         do s.emit_enum(~\"core::option::t\") {\n             match v {\n               None => s.emit_enum_variant(\n@@ -581,11 +582,11 @@ fn test_option_int() {\n         }\n     }\n \n-    fn deserialize_1<S: serialization::Deserializer>(&&s: S) -> int {\n+    fn deserialize_1<S: serialization::Deserializer>(s: &S) -> int {\n         s.read_i64() as int\n     }\n \n-    fn deserialize_0<S: serialization::Deserializer>(&&s: S) -> Option<int> {\n+    fn deserialize_0<S: serialization::Deserializer>(s: &S) -> Option<int> {\n         do s.read_enum(~\"core::option::t\") {\n             do s.read_enum_variant |i| {\n                 match i {\n@@ -608,11 +609,11 @@ fn test_option_int() {\n         debug!(\"v == %?\", v);\n         let bytes = do io::with_bytes_writer |wr| {\n             let ebml_w = ebml::Writer(wr);\n-            serialize_0(ebml_w, v);\n+            serialize_0(&ebml_w, v);\n         };\n         let ebml_doc = ebml::Doc(@bytes);\n         let deser = ebml_deserializer(ebml_doc);\n-        let v1 = deserialize_0(deser);\n+        let v1 = deserialize_0(&deser);\n         debug!(\"v1 == %?\", v1);\n         assert v == v1;\n     }"}, {"sha": "f88aad1ac633afdbe51f01fb999f2f21d5f73213", "filename": "src/libstd/ebml2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,3 +1,4 @@\n+#[forbid(deprecated_mode)];\n use serialization2;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n@@ -31,7 +32,7 @@ struct TaggedDoc {\n }\n \n impl Doc: ops::Index<uint,Doc> {\n-    pure fn index(+tag: uint) -> Doc {\n+    pure fn index(tag: uint) -> Doc {\n         unsafe {\n             get_doc(self, tag)\n         }"}, {"sha": "a1e29b03b4559e1c9772213fc5708566178ecef8", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,4 +1,4 @@\n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n \n /*!\n  * A functional key,value store that works on anything.\n@@ -26,7 +26,7 @@ enum TreeNode<K, V> {\n pub fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K, +v: V)\n+pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, k: K, v: V)\n   -> Treemap<K, V> {\n     @match m {\n        @Empty => Node(@k, @v, @Empty, @Empty),\n@@ -41,7 +41,7 @@ pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K, +v: V)\n }\n \n /// Find a value based on the key\n-pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n+pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n       Empty => None,\n       Node(@ref kk, @copy v, left, right) => {"}, {"sha": "6da51571e34a21cedea89c608ec53ac1f4778b09", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -61,8 +61,7 @@\n  *         do_work(input, output);\n  *     }\n  */\n-\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::result::{Err, Ok};\n@@ -162,7 +161,7 @@ fn name_str(nm: &Name) -> ~str {\n     };\n }\n \n-fn find_opt(opts: &[Opt], +nm: Name) -> Option<uint> {\n+fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n     vec::position(opts, |opt| opt.name == nm)\n }\n \n@@ -214,7 +213,7 @@ pub type Result = result::Result<Matches, Fail_>;\n  */\n pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n     let n_opts = vec::len::<Opt>(opts);\n-    fn f(+_x: uint) -> ~[Optval] { return ~[]; }\n+    fn f(_x: uint) -> ~[Optval] { return ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n     let mut free: ~[~str] = ~[];\n     let l = vec::len(args);"}, {"sha": "09d00216209383fa90abe08c7dff15f57a41b3d5", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,6 +1,6 @@\n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n //! json serialization\n@@ -399,7 +399,7 @@ priv impl Parser {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(ident: &str, +value: Json) -> Result<Json, Error> {\n+    fn parse_ident(ident: &str, value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n             Ok(move value)"}, {"sha": "396edb548850d590b827224685d577fe97fa54ef", "filename": "src/libstd/list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,5 +1,5 @@\n //! A standard linked list\n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::option;\n@@ -56,7 +56,7 @@ pub fn find<T: Copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n }\n \n /// Returns true if a list contains an element with the given value\n-pub fn has<T: Copy Eq>(ls: @List<T>, +elt: T) -> bool {\n+pub fn has<T: Copy Eq>(ls: @List<T>, elt: T) -> bool {\n     for each(ls) |e| {\n         if *e == elt { return true; }\n     }\n@@ -114,7 +114,7 @@ pub pure fn append<T: Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n /*\n /// Push one element into the front of a list, returning a new list\n /// THIS VERSION DOESN'T ACTUALLY WORK\n-pure fn push<T: Copy>(ll: &mut @list<T>, +vv: T) {\n+pure fn push<T: Copy>(ll: &mut @list<T>, vv: T) {\n     ll = &mut @cons(vv, *ll)\n }\n */"}, {"sha": "765d40339d3c0fdb57e7e6374ee2af31414cf9d4", "filename": "src/libstd/map.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,6 +1,5 @@\n //! A map type\n-\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use io::WriterUtil;\n use to_str::ToStr;\n@@ -28,7 +27,7 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n      *\n      * Returns true if the key did not already exist in the map\n      */\n-    fn insert(v: K, +v: V) -> bool;\n+    fn insert(v: K, v: V) -> bool;\n \n     /// Returns true if the map contains a value for the specified key\n     fn contains_key(key: K) -> bool;\n@@ -59,7 +58,7 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n     fn clear();\n \n     /// Iterate over all the key/value pairs in the map by value\n-    pure fn each(fn(key: K, +value: V) -> bool);\n+    pure fn each(fn(key: K, value: V) -> bool);\n \n     /// Iterate over all the keys in the map by value\n     pure fn each_key(fn(key: K) -> bool);\n@@ -213,7 +212,7 @@ pub mod chained {\n             }\n         }\n \n-        fn insert(k: K, +v: V) -> bool {\n+        fn insert(k: K, v: V) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(&k, hash) {\n               NotFound => {\n@@ -294,7 +293,7 @@ pub mod chained {\n             self.chains = chains(initial_capacity);\n         }\n \n-        pure fn each(blk: fn(key: K, +value: V) -> bool) {\n+        pure fn each(blk: fn(key: K, value: V) -> bool) {\n             self.each_ref(|k, v| blk(*k, *v))\n         }\n \n@@ -348,7 +347,7 @@ pub mod chained {\n     }\n \n     impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: ops::Index<K, V> {\n-        pure fn index(+k: K) -> V {\n+        pure fn index(k: K) -> V {\n             unsafe {\n                 self.get(k)\n             }\n@@ -459,7 +458,7 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n         }\n     }\n \n-    pure fn each(op: fn(key: K, +value: V) -> bool) {\n+    pure fn each(op: fn(key: K, value: V) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n                 p.each(|k, v| op(*k, *v))"}, {"sha": "1027acfb569c50d4ec8d3f4d8fbe52388cd3db5a", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,4 +1,5 @@\n //! High-level interface to libuv's TCP functionality\n+#[warn(deprecated_mode)];\n \n use ip = net_ip;\n use uv::iotask;\n@@ -324,7 +325,7 @@ pub fn read_start(sock: &TcpSocket)\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n pub fn read_stop(sock: &TcpSocket,\n-             +read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n+             read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n     result::Result<(), TcpErrData> unsafe {\n     log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n     let socket_data = ptr::addr_of(&(*sock.socket_data));\n@@ -558,8 +559,8 @@ pub fn accept(new_conn: TcpNewConnection)\n  */\n pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n-          +new_connect_cb: fn~(TcpNewConnection,\n+          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          new_connect_cb: fn~(TcpNewConnection,\n                                comm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> unsafe {\n     do listen_common(move host_ip, port, backlog, iotask, on_establish_cb)\n@@ -575,8 +576,8 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n \n fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n-          +on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n+          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::Result<(), TcpListenErrData> unsafe {\n     let stream_closed_po = core::comm::Port::<()>();\n     let kill_po = core::comm::Port::<Option<TcpErrData>>();\n@@ -749,7 +750,7 @@ impl TcpSocket {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Reader {\n-    fn read(buf: &[mut u8], +len: uint) -> uint {\n+    fn read(buf: &[mut u8], len: uint) -> uint {\n         // Loop until our buffer has enough data in it for us to read from.\n         while self.data.buf.len() < len {\n             let read_result = read(&self.data.sock, 0u);\n@@ -785,13 +786,13 @@ impl TcpSocketBuf: io::Reader {\n         let mut bytes = ~[0];\n         if self.read(bytes, 1u) == 0 { fail } else { bytes[0] as int }\n     }\n-    fn unread_byte(+amt: int) {\n+    fn unread_byte(amt: int) {\n         self.data.buf.unshift(amt as u8);\n     }\n     fn eof() -> bool {\n         false // noop\n     }\n-    fn seek(+dist: int, +seek: io::SeekStyle) {\n+    fn seek(dist: int, seek: io::SeekStyle) {\n         log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n@@ -813,7 +814,7 @@ impl TcpSocketBuf: io::Writer {\n                              err_data.err_name, err_data.err_msg));\n         }\n     }\n-    fn seek(+dist: int, +seek: io::SeekStyle) {\n+    fn seek(dist: int, seek: io::SeekStyle) {\n       log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n@@ -1474,7 +1475,7 @@ mod test {\n         str::from_bytes(new_bytes)\n     }\n \n-    fn run_tcp_test_server(server_ip: &str, server_port: uint, +resp: ~str,\n+    fn run_tcp_test_server(server_ip: &str, server_port: uint, resp: ~str,\n                           server_ch: comm::Chan<~str>,\n                           cont_ch: comm::Chan<()>,\n                           iotask: IoTask) -> ~str {"}, {"sha": "0ab4d89f363598c1c890fc5be5f31ca8e27efaef", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,5 +1,5 @@\n //! Types/fns concerning URLs (see RFC 3986)\n-// tjc: forbid deprecated modes again after a snapshot\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use map::HashMap;\n@@ -27,15 +27,15 @@ type UserInfo = {\n \n pub type Query = ~[(~str, ~str)];\n \n-pub fn Url(scheme: ~str, +user: Option<UserInfo>, +host: ~str,\n-       +port: Option<~str>, +path: ~str, +query: Query,\n-       +fragment: Option<~str>) -> Url {\n+pub fn Url(scheme: ~str, user: Option<UserInfo>, host: ~str,\n+       port: Option<~str>, path: ~str, query: Query,\n+       fragment: Option<~str>) -> Url {\n     Url { scheme: move scheme, user: move user, host: move host,\n          port: move port, path: move path, query: move query,\n          fragment: move fragment }\n }\n \n-fn UserInfo(user: ~str, +pass: Option<~str>) -> UserInfo {\n+fn UserInfo(user: ~str, pass: Option<~str>) -> UserInfo {\n     {user: move user, pass: move pass}\n }\n \n@@ -726,7 +726,7 @@ impl Url : Eq {\n }\n \n impl Url: IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         unsafe { self.to_str() }.iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "e5336b7204d2977863bfa1aa442682146c9d9e16", "filename": "src/libstd/par.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,3 +1,5 @@\n+#[forbid(deprecated_mode)];\n+\n use future_spawn = future::spawn;\n \n \n@@ -72,7 +74,7 @@ fn map_slices<A: Copy Send, B: Copy Send>(\n }\n \n /// A parallel version of map.\n-pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], +f: fn~((&A)) -> B) -> ~[B] {\n+pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], f: fn~((&A)) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::map(slice, |x| f(x))\n@@ -82,7 +84,7 @@ pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], +f: fn~((&A)) -> B) -> ~[B] {\n \n /// A parallel version of mapi.\n pub fn mapi<A: Copy Send, B: Copy Send>(xs: &[A],\n-                                    +f: fn~(uint, (&A)) -> B) -> ~[B] {\n+                                    f: fn~(uint, (&A)) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::mapi(slice, |i, x| {\n@@ -119,7 +121,7 @@ pub fn mapi_factory<A: Copy Send, B: Copy Send>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A: Copy Send>(xs: &[A], +f: fn~(uint, (&A)) -> bool) -> bool {\n+pub fn alli<A: Copy Send>(xs: &[A], f: fn~(uint, (&A)) -> bool) -> bool {\n     do vec::all(map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n@@ -130,7 +132,7 @@ pub fn alli<A: Copy Send>(xs: &[A], +f: fn~(uint, (&A)) -> bool) -> bool {\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A: Copy Send>(xs: &[A], +f: fn~(&(A)) -> bool) -> bool {\n+pub fn any<A: Copy Send>(xs: &[A], f: fn~(&(A)) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, |x| f(x))"}, {"sha": "1582d90ce2d629037c2f8c7cb70a6c7ca763aad1", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -2,7 +2,7 @@\n  * A simple map based on a vector for small integer keys. Space requirements\n  * are O(highest integer key).\n  */\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use core::option;\n use core::option::{Some, None};\n@@ -103,7 +103,7 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n     pure fn find(key: uint) -> Option<V> { find(self, key) }\n     fn rehash() { fail }\n \n-    pure fn each(it: fn(key: uint, +value: V) -> bool) {\n+    pure fn each(it: fn(key: uint, value: V) -> bool) {\n         self.each_ref(|k, v| it(*k, *v))\n     }\n     pure fn each_key(it: fn(key: uint) -> bool) {\n@@ -131,7 +131,7 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n }\n \n impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n-    pure fn index(+key: uint) -> V {\n+    pure fn index(key: uint) -> V {\n         unsafe {\n             get(self, key)\n         }"}, {"sha": "cc076772e6eb983d02ef73c4d6b3465574113310", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -20,6 +20,7 @@ not required in or otherwise suitable for the core library.\n \n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n+#[warn(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n extern mod core(vers = \"0.4\");"}, {"sha": "908f3936f4e1f1bed3fcb4e991b8cc8bcc20d572", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n /**\n  * The concurrency primitives you know and love.\n  *"}, {"sha": "162a5ecc5fcf88d38718f6b5927998a7d5b3dbef", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -5,7 +5,7 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use either::Either;"}, {"sha": "627a3b8eeae02c71ad2c20134c791ea62655affd", "filename": "src/libstd/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,4 +1,4 @@\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use libc::{c_char, c_int, c_long, size_t, time_t};"}, {"sha": "c9c28c4e1f0888f49a681bb954757d1c0fb7d13b", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -1,6 +1,6 @@\n //! Utilities that leverage libuv's `uv_timer_*` API\n \n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use uv = uv;\n use uv::iotask;"}, {"sha": "8ab0dc7f2e7da5c4101b5b3c75d97d0912f6b833", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -5,7 +5,7 @@\n  * very naive algorithm, but it will probably be updated to be a\n  * red-black tree or something else.\n  */\n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n \n use core::cmp::{Eq, Ord};\n use core::option::{Some, None};\n@@ -26,7 +26,7 @@ enum TreeNode<K, V> = {\n pub fn TreeMap<K, V>() -> TreeMap<K, V> { @mut None }\n \n /// Insert a value into the map\n-pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n+pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, k: K, v: V) {\n     match copy *m {\n       None => {\n         *m = Some(@TreeNode({key: k,\n@@ -48,7 +48,7 @@ pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n }\n \n /// Find a value based on the key\n-pub fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, +k: K)\n+pub fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, k: K)\n                               -> Option<V> {\n     match copy *m {\n       None => None,\n@@ -121,7 +121,7 @@ mod tests {\n         insert(m, 1, ());\n \n         let n = @mut 0;\n-        fn t(n: @mut int, +k: int, +_v: ()) {\n+        fn t(n: @mut int, k: int, _v: ()) {\n             assert (*n == k); *n += 1;\n         }\n         traverse(m, |x,y| t(n, *x, *y));"}, {"sha": "ad40d96e4f77b28ed32290f721be492526071188", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -4,8 +4,7 @@\n  * The I/O task runs in its own single-threaded scheduler.  By using the\n  * `interact` function you can execute code in a uv callback.\n  */\n-\n-// tjc: forbid deprecated modes again after a snapshot\n+#[forbid(deprecated_mode)];\n \n use libc::c_void;\n use ptr::addr_of;\n@@ -60,7 +59,7 @@ pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n  * via ports/chans.\n  */\n pub unsafe fn interact(iotask: IoTask,\n-                   +cb: fn~(*c_void)) {\n+                   cb: fn~(*c_void)) {\n     send_msg(iotask, Interaction(move cb));\n }\n \n@@ -125,7 +124,7 @@ type IoTaskLoopData = {\n };\n \n fn send_msg(iotask: IoTask,\n-            +msg: IoTaskMsg) unsafe {\n+            msg: IoTaskMsg) unsafe {\n     iotask.op_chan.send(move msg);\n     ll::async_send(iotask.async_handle);\n }"}, {"sha": "8b428d8d6d8a2275fea8e548f89cb1de1fdf86a6", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -19,7 +19,7 @@\n  * This module's implementation will hopefully be, eventually, replaced\n  * with per-platform, generated source files from rust-bindgen.\n  */\n-\n+#[warn(deprecated_mode)];\n #[allow(non_camel_case_types)]; // C types\n \n use libc::size_t;\n@@ -642,7 +642,7 @@ extern mod rustrt {\n     fn rust_uv_addrinfo_as_sockaddr_in(input: *addrinfo) -> *sockaddr_in;\n     fn rust_uv_addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6;\n     fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n-    fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+    fn rust_uv_free_base_of_buf(+buf: uv_buf_t);\n     fn rust_uv_get_stream_handle_from_connect_req(\n         connect_req: *uv_connect_t)\n         -> *uv_stream_t;\n@@ -661,8 +661,8 @@ extern mod rustrt {\n     fn rust_uv_get_data_for_req(req: *libc::c_void) -> *libc::c_void;\n     fn rust_uv_set_data_for_req(req: *libc::c_void,\n                                 data: *libc::c_void);\n-    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n-    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> libc::size_t;\n+    fn rust_uv_get_base_from_buf(+buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(+buf: uv_buf_t) -> libc::size_t;\n \n     // sizeof testing helpers\n     fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n@@ -1357,8 +1357,8 @@ pub mod test {\n \n     fn impl_uv_tcp_server(server_ip: &str,\n                           server_port: int,\n-                          +kill_server_msg: ~str,\n-                          +server_resp_msg: ~str,\n+                          kill_server_msg: ~str,\n+                          server_resp_msg: ~str,\n                           server_chan: *comm::Chan<~str>,\n                           continue_chan: *comm::Chan<bool>) unsafe {\n         let test_loop = loop_new();"}, {"sha": "4da9992b0dd36916396fa5677c53409d8e3b9fa8", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -48,7 +48,6 @@ trait ext_ctxt_ast_builder {\n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param;\n     fn arg(name: ident, ty: @ast::ty) -> ast::arg;\n-    fn arg_mode(name: ident, ty: @ast::ty, mode: ast::rmode) -> ast::arg;\n     fn expr_block(e: @ast::expr) -> ast::blk;\n     fn fn_decl(+inputs: ~[ast::arg], output: @ast::ty) -> ast::fn_decl;\n     fn item(name: ident, span: span, +node: ast::item_) -> @ast::item;\n@@ -177,13 +176,6 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n          id: self.next_id()}\n     }\n \n-    fn arg_mode(name: ident, ty: @ast::ty, mode: ast::rmode) -> ast::arg {\n-        {mode: ast::expl(mode),\n-         ty: ty,\n-         ident: name,\n-         id: self.next_id()}\n-    }\n-\n     fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n         let blk = {view_items: ~[],\n                    stmts: stmts,"}, {"sha": "874ea01e9b01d1a2d4fe444b82751e20a40e7ae9", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -47,16 +47,15 @@ impl message: gen_send {\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n \n             let args_ast = (arg_names, tys).map(\n-                |n, t| cx.arg_mode(*n, *t, ast::by_copy)\n+                |n, t| cx.arg(*n, *t)\n             );\n \n             let pipe_ty = cx.ty_path_ast_builder(\n                 path(~[this.data_name()], span)\n                 .add_tys(cx.ty_vars(this.ty_params)));\n             let args_ast = vec::append(\n-                ~[cx.arg_mode(cx.ident_of(~\"pipe\"),\n-                              pipe_ty,\n-                              ast::by_copy)],\n+                ~[cx.arg(cx.ident_of(~\"pipe\"),\n+                              pipe_ty)],\n                 args_ast);\n \n             let mut body = ~\"{\\n\";\n@@ -129,15 +128,14 @@ impl message: gen_send {\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n                 let args_ast = (arg_names, tys).map(\n-                    |n, t| cx.arg_mode(cx.ident_of(*n), *t, ast::by_copy)\n+                    |n, t| cx.arg(cx.ident_of(*n), *t)\n                 );\n \n                 let args_ast = vec::append(\n-                    ~[cx.arg_mode(cx.ident_of(~\"pipe\"),\n+                    ~[cx.arg(cx.ident_of(~\"pipe\"),\n                                   cx.ty_path_ast_builder(\n                                       path(~[this.data_name()], span)\n-                                      .add_tys(cx.ty_vars(this.ty_params))),\n-                                  ast::by_copy)],\n+                                      .add_tys(cx.ty_vars(this.ty_params))))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {"}, {"sha": "c60904419d5f390f755032e17f5cb693f80da8dd", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -22,15 +22,15 @@ use syntax::diagnostic;\n use rustc::driver::session;\n use rustc::middle::lint;\n \n-fn version(argv0: ~str) {\n+fn version(argv0: &str) {\n     let mut vers = ~\"unknown version\";\n     let env_vers = env!(\"CFG_VERSION\");\n-    if str::len(env_vers) != 0u { vers = env_vers; }\n+    if env_vers.len() != 0 { vers = env_vers; }\n     io::println(fmt!(\"%s %s\", argv0, vers));\n     io::println(fmt!(\"host: %s\", host_triple()));\n }\n \n-fn usage(argv0: ~str) {\n+fn usage(argv0: &str) {\n     io::println(fmt!(\"Usage: %s [options] <input>\\n\", argv0) +\n                  ~\"\n Options:\n@@ -86,7 +86,7 @@ fn describe_warnings() {\n     let lint_dict = lint::get_lint_dict();\n     let mut max_key = 0;\n     for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n-    fn padded(max: uint, s: ~str) -> ~str {\n+    fn padded(max: uint, s: &str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n     io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n@@ -117,14 +117,14 @@ fn describe_debug_flags() {\n     }\n }\n \n-fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n+fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     logging::console_off();\n \n-    let mut args = args;\n+    let mut args = *args;\n     let binary = args.shift();\n \n-    if vec::len(args) == 0u { usage(binary); return; }\n+    if args.is_empty() { usage(binary); return; }\n \n     let matches =\n         match getopts::getopts(args, opts()) {\n@@ -278,9 +278,9 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n }\n \n fn main() {\n-    let args = os::args();\n-    do monitor |demitter| {\n-        run_compiler(args, demitter);\n+    let mut args = os::args();\n+    do monitor |move args, demitter| {\n+        run_compiler(&args, demitter);\n     }\n }\n "}, {"sha": "97b031c6024aa6e7724145ca2579d5b71e6f5448", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc60af441a1375ee73a0efe4524b54ff039e69a/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=8fc60af441a1375ee73a0efe4524b54ff039e69a", "patch": "@@ -10,8 +10,6 @@\n \n // xfail-pretty\n \n-#[legacy_modes];\n-\n extern mod std;\n \n use option = option;\n@@ -70,18 +68,18 @@ fn map(f: fn~() -> word_reader, emit: map_reduce::putter<~str, int>) {\n     let f = f();\n     loop {\n         match f.read_word() {\n-          Some(w) => { emit(w, 1); }\n+          Some(w) => { emit(&w, 1); }\n           None => { break; }\n         }\n     }\n }\n \n-fn reduce(&&word: ~str, get: map_reduce::getter<int>) {\n+fn reduce(word: &~str, get: map_reduce::getter<int>) {\n     let mut count = 0;\n \n     loop { match get() { Some(_) => { count += 1; } None => { break; } } }\n \n-    io::println(fmt!(\"%s\\t%?\", word, count));\n+    io::println(fmt!(\"%s\\t%?\", *word, count));\n }\n \n struct box<T> {\n@@ -116,13 +114,13 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter<K: Send, V: Send> = fn(K, V);\n+    type putter<K: Send, V: Send> = fn(&K, V);\n \n     type mapper<K1: Send, K2: Send, V: Send> = fn~(K1, putter<K2, V>);\n \n     type getter<V: Send> = fn() -> Option<V>;\n \n-    type reducer<K: Copy Send, V: Copy Send> = fn~(K, getter<V>);\n+    type reducer<K: Copy Send, V: Copy Send> = fn~(&K, getter<V>);\n \n     enum ctrl_proto<K: Copy Send, V: Copy Send> {\n         find_reducer(K, Chan<Chan<reduce_proto<V>>>),\n@@ -145,46 +143,49 @@ mod map_reduce {\n \n     fn start_mappers<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send,\n                      V: Copy Send>(\n-        map: mapper<K1, K2, V>,\n+        map: &mapper<K1, K2, V>,\n         &ctrls: ~[ctrl_proto::server::open<K2, V>],\n-        inputs: ~[K1])\n+        inputs: &~[K1])\n         -> ~[joinable_task]\n     {\n         let mut tasks = ~[];\n         for inputs.each |i| {\n             let (ctrl, ctrl_server) = ctrl_proto::init();\n             let ctrl = box(ctrl);\n             let i = copy *i;\n-            tasks.push(spawn_joinable(|move i| map_task(map, ctrl, i)));\n+            let m = copy *map;\n+            tasks.push(spawn_joinable(|move i| map_task(m, &ctrl, i)));\n             ctrls.push(ctrl_server);\n         }\n         return tasks;\n     }\n \n     fn map_task<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send, V: Copy Send>(\n         map: mapper<K1, K2, V>,\n-        ctrl: box<ctrl_proto::client::open<K2, V>>,\n+        ctrl: &box<ctrl_proto::client::open<K2, V>>,\n         input: K1)\n     {\n         // log(error, \"map_task \" + input);\n-        let intermediates = map::HashMap();\n+        let intermediates: HashMap<K2, Chan<reduce_proto<V>>>\n+            = map::HashMap();\n \n-        do map(input) |key, val| {\n+        do map(input) |key: &K2, val| {\n             let mut c = None;\n-            let found = intermediates.find(key);\n+            let found: Option<Chan<reduce_proto<V>>>\n+                = intermediates.find(*key);\n             match found {\n               Some(_c) => { c = Some(_c); }\n               None => {\n                 do ctrl.swap |ctrl| {\n-                    let ctrl = ctrl_proto::client::find_reducer(ctrl, key);\n+                    let ctrl = ctrl_proto::client::find_reducer(ctrl, *key);\n                     match pipes::recv(ctrl) {\n                       ctrl_proto::reducer(c_, ctrl) => {\n                         c = Some(c_);\n                         move_out!(ctrl)\n                       }\n                     }\n                 }\n-                intermediates.insert(key, c.get());\n+                intermediates.insert(*key, c.get());\n                 send(c.get(), addref);\n               }\n             }\n@@ -200,7 +201,7 @@ mod map_reduce {\n     }\n \n     fn reduce_task<K: Copy Send, V: Copy Send>(\n-        reduce: reducer<K, V>, \n+        reduce: ~reducer<K, V>, \n         key: K,\n         out: Chan<Chan<reduce_proto<V>>>)\n     {\n@@ -231,7 +232,7 @@ mod map_reduce {\n             return None;\n         }\n \n-        reduce(key, || get(p, ref_count, is_done) );\n+        (*reduce)(&key, || get(p, ref_count, is_done) );\n     }\n \n     fn map_reduce<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send, V: Copy Send>(\n@@ -245,7 +246,7 @@ mod map_reduce {\n         // to do the rest.\n \n         let reducers = map::HashMap();\n-        let mut tasks = start_mappers(map, ctrl, inputs);\n+        let mut tasks = start_mappers(&map, ctrl, &inputs);\n         let mut num_mappers = vec::len(inputs) as int;\n \n         while num_mappers > 0 {\n@@ -270,7 +271,7 @@ mod map_reduce {\n                     let p = Port();\n                     let ch = Chan(&p);\n                     let r = reduce, kk = k;\n-                    tasks.push(spawn_joinable(|| reduce_task(r, kk, ch) ));\n+                    tasks.push(spawn_joinable(|| reduce_task(~r, kk, ch) ));\n                     c = recv(p);\n                     reducers.insert(k, c);\n                   }"}]}