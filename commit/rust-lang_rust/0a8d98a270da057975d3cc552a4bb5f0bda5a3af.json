{"sha": "0a8d98a270da057975d3cc552a4bb5f0bda5a3af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhOGQ5OGEyNzBkYTA1Nzk3NWQzY2M1NTJhNGJiNWYwYmRhNWEzYWY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-05T15:49:38Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-07T14:02:16Z"}, "message": "Parse const generics\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "d8fb828a74b91a124f4a08bb4522ba1e9274ec60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8fb828a74b91a124f4a08bb4522ba1e9274ec60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a8d98a270da057975d3cc552a4bb5f0bda5a3af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8d98a270da057975d3cc552a4bb5f0bda5a3af", "html_url": "https://github.com/rust-lang/rust/commit/0a8d98a270da057975d3cc552a4bb5f0bda5a3af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a8d98a270da057975d3cc552a4bb5f0bda5a3af/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d83521f0b1c842e42f87dd59dbca9c98b456cbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d83521f0b1c842e42f87dd59dbca9c98b456cbd", "html_url": "https://github.com/rust-lang/rust/commit/8d83521f0b1c842e42f87dd59dbca9c98b456cbd"}], "stats": {"total": 290, "additions": 112, "deletions": 178}, "files": [{"sha": "2ff450af42381948e03e7aa3e8f05209bad29946", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 98, "deletions": 178, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/0a8d98a270da057975d3cc552a4bb5f0bda5a3af/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8d98a270da057975d3cc552a4bb5f0bda5a3af/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0a8d98a270da057975d3cc552a4bb5f0bda5a3af", "patch": "@@ -397,6 +397,7 @@ crate enum TokenType {\n     Ident,\n     Path,\n     Type,\n+    Const,\n }\n \n impl TokenType {\n@@ -409,6 +410,7 @@ impl TokenType {\n             TokenType::Ident => \"identifier\".to_string(),\n             TokenType::Path => \"path\".to_string(),\n             TokenType::Type => \"type\".to_string(),\n+            TokenType::Const => \"const\".to_string(),\n         }\n     }\n }\n@@ -946,6 +948,19 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn check_const_param(&mut self) -> bool {\n+        self.check_keyword(keywords::Const)\n+    }\n+\n+    fn check_const_arg(&mut self) -> bool {\n+        if self.token.can_begin_const_arg() {\n+            true\n+        } else {\n+            self.expected_tokens.push(TokenType::Const);\n+            false\n+        }\n+    }\n+\n     /// Expect and consume a `+`. if `+=` is seen, replace it with a `=`\n     /// and continue. If a `+` is not seen, return false.\n     ///\n@@ -5482,15 +5497,28 @@ impl<'a> Parser<'a> {\n         Ok((ident, TraitItemKind::Type(bounds, default), generics))\n     }\n \n+    fn parse_const_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n+        self.expect_keyword(keywords::Const)?;\n+        let ident = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+\n+        Ok(GenericParam {\n+            ident,\n+            id: ast::DUMMY_NODE_ID,\n+            attrs: preceding_attrs.into(),\n+            bounds: Vec::new(),\n+            kind: GenericParamKind::Const {\n+                ty,\n+            }\n+        })\n+    }\n+\n     /// Parses (possibly empty) list of lifetime and type parameters, possibly including\n     /// trailing comma and erroneous trailing attributes.\n     crate fn parse_generic_params(&mut self) -> PResult<'a, Vec<ast::GenericParam>> {\n-        let mut lifetimes = Vec::new();\n         let mut params = Vec::new();\n-        let mut seen_ty_param: Option<Span> = None;\n-        let mut last_comma_span = None;\n-        let mut bad_lifetime_pos = vec![];\n-        let mut suggestions = vec![];\n+        let mut prev_param: Option<ParamKindOrd> = None;\n         loop {\n             let attrs = self.parse_outer_attributes()?;\n             if self.check_lifetime() {\n@@ -5501,64 +5529,45 @@ impl<'a> Parser<'a> {\n                 } else {\n                     Vec::new()\n                 };\n-                lifetimes.push(ast::GenericParam {\n+                params.push(ast::GenericParam {\n                     ident: lifetime.ident,\n                     id: lifetime.id,\n                     attrs: attrs.into(),\n                     bounds,\n                     kind: ast::GenericParamKind::Lifetime,\n                 });\n-                if let Some(sp) = seen_ty_param {\n-                    let remove_sp = last_comma_span.unwrap_or(self.prev_span).to(self.prev_span);\n-                    bad_lifetime_pos.push(self.prev_span);\n-                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.prev_span) {\n-                        suggestions.push((remove_sp, String::new()));\n-                        suggestions.push((\n-                            sp.shrink_to_lo(),\n-                            format!(\"{}, \", snippet)));\n-                    }\n-                }\n+                prev_param = Some(ParamKindOrd::Lifetime);\n+            } else if self.check_const_param() {\n+                // Parse const parameter.\n+                params.push(self.parse_const_param(attrs)?);\n+                prev_param = Some(ParamKindOrd::Const);\n             } else if self.check_ident() {\n                 // Parse type parameter.\n                 params.push(self.parse_ty_param(attrs)?);\n-                if seen_ty_param.is_none() {\n-                    seen_ty_param = Some(self.prev_span);\n-                }\n+                prev_param = Some(ParamKindOrd::Type);\n             } else {\n                 // Check for trailing attributes and stop parsing.\n                 if !attrs.is_empty() {\n-                    let param_kind = if seen_ty_param.is_some() { \"type\" } else { \"lifetime\" };\n-                    self.struct_span_err(\n-                        attrs[0].span,\n-                        &format!(\"trailing attribute after {} parameters\", param_kind),\n-                    )\n-                    .span_label(attrs[0].span, \"attributes must go before parameters\")\n-                    .emit();\n+                    if let Some(prev_param) = prev_param {\n+                        self.struct_span_err(\n+                            attrs[0].span,\n+                            &format!(\n+                                \"trailing attribute after {} parameter\",\n+                                prev_param,\n+                            ),\n+                        )\n+                        .span_label(attrs[0].span, \"attributes must go before parameters\")\n+                        .emit();\n+                    }\n                 }\n                 break\n             }\n \n             if !self.eat(&token::Comma) {\n                 break\n             }\n-            last_comma_span = Some(self.prev_span);\n-        }\n-        if !bad_lifetime_pos.is_empty() {\n-            let mut err = self.struct_span_err(\n-                bad_lifetime_pos,\n-                \"lifetime parameters must be declared prior to type parameters\",\n-            );\n-            if !suggestions.is_empty() {\n-                err.multipart_suggestion(\n-                    \"move the lifetime parameter prior to the first type parameter\",\n-                    suggestions,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            err.emit();\n         }\n-        lifetimes.extend(params);  // ensure the correct order of lifetimes and type params\n-        Ok(lifetimes)\n+        Ok(params)\n     }\n \n     /// Parse a set of optional generic type parameter declarations. Where\n@@ -5740,35 +5749,16 @@ impl<'a> Parser<'a> {\n     fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n         let mut args = Vec::new();\n         let mut bindings = Vec::new();\n+        let mut misplaced_assoc_ty_bindings: Vec<Span> = Vec::new();\n+        let mut assoc_ty_bindings: Vec<Span> = Vec::new();\n \n-        let mut seen_type = false;\n-        let mut seen_binding = false;\n+        let args_lo = self.span;\n \n-        let mut last_comma_span = None;\n-        let mut first_type_or_binding_span: Option<Span> = None;\n-        let mut first_binding_span: Option<Span> = None;\n-\n-        let mut bad_lifetime_pos = vec![];\n-        let mut bad_type_pos = vec![];\n-\n-        let mut lifetime_suggestions = vec![];\n-        let mut type_suggestions = vec![];\n         loop {\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 // Parse lifetime argument.\n                 args.push(GenericArg::Lifetime(self.expect_lifetime()));\n-\n-                if seen_type || seen_binding {\n-                    let remove_sp = last_comma_span.unwrap_or(self.prev_span).to(self.prev_span);\n-                    bad_lifetime_pos.push(self.prev_span);\n-\n-                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.prev_span) {\n-                        lifetime_suggestions.push((remove_sp, String::new()));\n-                        lifetime_suggestions.push((\n-                            first_type_or_binding_span.unwrap().shrink_to_lo(),\n-                            format!(\"{}, \", snippet)));\n-                    }\n-                }\n+                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n             } else if self.check_ident() && self.look_ahead(1, |t| t == &token::Eq) {\n                 // Parse associated type binding.\n                 let lo = self.span;\n@@ -5782,131 +5772,59 @@ impl<'a> Parser<'a> {\n                     ty,\n                     span,\n                 });\n-\n-                seen_binding = true;\n-                if first_type_or_binding_span.is_none() {\n-                    first_type_or_binding_span = Some(span);\n-                }\n-                if first_binding_span.is_none() {\n-                    first_binding_span = Some(span);\n-                }\n+                assoc_ty_bindings.push(span);\n+            } else if self.check_const_arg() {\n+                // Parse const argument.\n+                let expr = if let token::OpenDelim(token::Brace) = self.token {\n+                    self.parse_block_expr(None, self.span, BlockCheckMode::Default, ThinVec::new())?\n+                } else if self.token.can_begin_literal_or_bool() {\n+                    let lit = self.parse_lit()?;\n+                    self.mk_expr(lit.span, ExprKind::Lit(lit), ThinVec::new())\n+                } else {\n+                    // FIXME(const_generics): to distinguish between idents for types and consts,\n+                    // we should introduce a GenericArg::Ident in the AST and distinguish when\n+                    // lowering to the HIR. For now, idents for const args are not permitted.\n+                    return Err(\n+                        self.fatal(\"identifiers may currently not be used for const generics\")\n+                    );\n+                };\n+                let value = AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: expr,\n+                };\n+                args.push(GenericArg::Const(value));\n+                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n             } else if self.check_type() {\n                 // Parse type argument.\n-                let ty_param = self.parse_ty()?;\n-                if seen_binding {\n-                    let remove_sp = last_comma_span.unwrap_or(self.prev_span).to(self.prev_span);\n-                    bad_type_pos.push(self.prev_span);\n-\n-                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.prev_span) {\n-                        type_suggestions.push((remove_sp, String::new()));\n-                        type_suggestions.push((\n-                            first_binding_span.unwrap().shrink_to_lo(),\n-                            format!(\"{}, \", snippet)));\n-                    }\n-                }\n-\n-                if first_type_or_binding_span.is_none() {\n-                    first_type_or_binding_span = Some(ty_param.span);\n-                }\n-                args.push(GenericArg::Type(ty_param));\n-                seen_type = true;\n+                args.push(GenericArg::Type(self.parse_ty()?));\n+                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n             } else {\n                 break\n             }\n \n             if !self.eat(&token::Comma) {\n                 break\n-            } else {\n-                last_comma_span = Some(self.prev_span);\n-            }\n-        }\n-\n-        self.maybe_report_incorrect_generic_argument_order(\n-            bad_lifetime_pos, bad_type_pos, lifetime_suggestions, type_suggestions\n-        );\n-\n-        Ok((args, bindings))\n-    }\n-\n-    /// Maybe report an error about incorrect generic argument order - \"lifetime parameters\n-    /// must be declared before type parameters\", \"type parameters must be declared before\n-    /// associated type bindings\" or both.\n-    fn maybe_report_incorrect_generic_argument_order(\n-        &self,\n-        bad_lifetime_pos: Vec<Span>,\n-        bad_type_pos: Vec<Span>,\n-        lifetime_suggestions: Vec<(Span, String)>,\n-        type_suggestions: Vec<(Span, String)>,\n-    ) {\n-        let mut err = if !bad_lifetime_pos.is_empty() && !bad_type_pos.is_empty() {\n-            let mut positions = bad_lifetime_pos.clone();\n-            positions.extend_from_slice(&bad_type_pos);\n-\n-            self.struct_span_err(\n-                positions,\n-                \"generic arguments must declare lifetimes, types and associated type bindings in \\\n-                 that order\",\n-            )\n-        } else if !bad_lifetime_pos.is_empty() {\n-            self.struct_span_err(\n-                bad_lifetime_pos.clone(),\n-                \"lifetime parameters must be declared prior to type parameters\"\n-            )\n-        } else if !bad_type_pos.is_empty() {\n-            self.struct_span_err(\n-                bad_type_pos.clone(),\n-                \"type parameters must be declared prior to associated type bindings\"\n-            )\n-        } else {\n-            return;\n-        };\n-\n-        if !bad_lifetime_pos.is_empty() {\n-            for sp in &bad_lifetime_pos {\n-                err.span_label(*sp, \"must be declared prior to type parameters\");\n-            }\n-        }\n-\n-        if !bad_type_pos.is_empty() {\n-            for sp in &bad_type_pos {\n-                err.span_label(*sp, \"must be declared prior to associated type bindings\");\n             }\n         }\n \n-        if !lifetime_suggestions.is_empty() && !type_suggestions.is_empty() {\n-            let mut suggestions = lifetime_suggestions;\n-            suggestions.extend_from_slice(&type_suggestions);\n-\n-            let plural = bad_lifetime_pos.len() + bad_type_pos.len() > 1;\n-            err.multipart_suggestion(\n-                &format!(\n-                    \"move the parameter{}\",\n-                    if plural { \"s\" } else { \"\" },\n-                ),\n-                suggestions,\n-                Applicability::MachineApplicable,\n-            );\n-        } else if !lifetime_suggestions.is_empty() {\n-            err.multipart_suggestion(\n-                &format!(\n-                    \"move the lifetime parameter{} prior to the first type parameter\",\n-                    if bad_lifetime_pos.len() > 1 { \"s\" } else { \"\" },\n-                ),\n-                lifetime_suggestions,\n-                Applicability::MachineApplicable,\n-            );\n-        } else if !type_suggestions.is_empty() {\n-            err.multipart_suggestion(\n-                &format!(\n-                    \"move the type parameter{} prior to the first associated type binding\",\n-                    if bad_type_pos.len() > 1 { \"s\" } else { \"\" },\n-                ),\n-                type_suggestions,\n-                Applicability::MachineApplicable,\n+        // FIXME: we would like to report this in ast_validation instead, but we currently do not\n+        // preserve ordering of generic parameters with respect to associated type binding, so we\n+        // lose that information after parsing.\n+        if misplaced_assoc_ty_bindings.len() > 0 {\n+            let mut err = self.struct_span_err(\n+                args_lo.to(self.prev_span),\n+                \"associated type bindings must be declared after generic parameters\",\n             );\n+            for span in misplaced_assoc_ty_bindings {\n+                err.span_label(\n+                    span,\n+                    \"this associated type binding should be moved after the generic parameters\",\n+                );\n+            }\n+            err.emit();\n         }\n \n-        err.emit();\n+        Ok((args, bindings))\n     }\n \n     /// Parses an optional `where` clause and places it in `generics`.\n@@ -6526,6 +6444,7 @@ impl<'a> Parser<'a> {\n         //     `<` (LIFETIME|IDENT) `,` - first generic parameter in a list\n         //     `<` (LIFETIME|IDENT) `:` - generic parameter with bounds\n         //     `<` (LIFETIME|IDENT) `=` - generic parameter with a default\n+        //     `<` const IDENT          - generic const parameter\n         // The only truly ambiguous case is\n         //     `<` IDENT `>` `::` IDENT ...\n         // we disambiguate it in favor of generics (`impl<T> ::absolute::Path<T> { ... }`)\n@@ -6535,7 +6454,8 @@ impl<'a> Parser<'a> {\n             (self.look_ahead(1, |t| t == &token::Pound || t == &token::Gt) ||\n              self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n                 self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n-                                       t == &token::Colon || t == &token::Eq))\n+                                       t == &token::Colon || t == &token::Eq) ||\n+             self.look_ahead(1, |t| t.is_keyword(keywords::Const)))\n     }\n \n     fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {"}, {"sha": "dad32072739685848bc80c7b6409a0fb90e0d8be", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a8d98a270da057975d3cc552a4bb5f0bda5a3af/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8d98a270da057975d3cc552a4bb5f0bda5a3af/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0a8d98a270da057975d3cc552a4bb5f0bda5a3af", "patch": "@@ -279,6 +279,20 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token can appear at the start of a const param.\n+    pub fn can_begin_const_arg(&self) -> bool {\n+        match self {\n+            OpenDelim(Brace) => true,\n+            Interpolated(ref nt) => match nt.0 {\n+                NtExpr(..) => true,\n+                NtBlock(..) => true,\n+                NtLiteral(..) => true,\n+                _ => false,\n+            }\n+            _ => self.can_begin_literal_or_bool(),\n+        }\n+    }\n+\n     /// Returns `true` if the token can appear at the start of a generic bound.\n     crate fn can_begin_bound(&self) -> bool {\n         self.is_path_start() || self.is_lifetime() || self.is_keyword(keywords::For) ||"}]}