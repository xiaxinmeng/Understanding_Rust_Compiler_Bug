{"sha": "bc335d6c16bc7bb9df1e1e2b982aa13963e8ae7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMzM1ZDZjMTZiYzdiYjlkZjFlMWUyYjk4MmFhMTM5NjNlOGFlN2M=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-27T21:01:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-27T21:01:07Z"}, "message": "Rollup merge of #62124 - matklad:without-with, r=petrochenkov\n\nrefactor lexer to use idiomatic borrowing", "tree": {"sha": "5b76105ce8555580a702074ed2564bc37f2831e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b76105ce8555580a702074ed2564bc37f2831e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc335d6c16bc7bb9df1e1e2b982aa13963e8ae7c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdFS6TCRBK7hj4Ov3rIwAAdHIIAKdbNV1LVuFo9da3MgBnXvZp\nG092EsIfjDZdwrT7cne5HnUwKTlIWqnw2g9w1X+UnEUck+RNZ9B9oay1PkOnXaBR\nm2x/iI6OKcnVIy1gXx7Xw2GPMPA2nj3fXXg9xn2qg4r+A1eXNlRyFzrDrylublIF\nIH78MW9qg1WnICIXbYoKtXM0dAUmFYn3bC4xyyqk+DYp+LESFemk/NXiC5T28GNz\n9TaCcI1oyZqGZYpoHEm92O/pqZZ9YiE602jmhKuRsbYIx14LK+BZXkvUidElLz6/\noCEEhnTT2eMH6AkoKwk4jsk/4FUhINkWlVBImTXgwR4fLrisv3SSNqLrVfkXBH8=\n=RExq\n-----END PGP SIGNATURE-----\n", "payload": "tree 5b76105ce8555580a702074ed2564bc37f2831e7\nparent e8f398623e1eea678f41f89a94300c23d0510ac2\nparent 57db25e614dfc3ea3c407374a562501471eb1c5d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1561669267 +0200\ncommitter GitHub <noreply@github.com> 1561669267 +0200\n\nRollup merge of #62124 - matklad:without-with, r=petrochenkov\n\nrefactor lexer to use idiomatic borrowing\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc335d6c16bc7bb9df1e1e2b982aa13963e8ae7c", "html_url": "https://github.com/rust-lang/rust/commit/bc335d6c16bc7bb9df1e1e2b982aa13963e8ae7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc335d6c16bc7bb9df1e1e2b982aa13963e8ae7c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f398623e1eea678f41f89a94300c23d0510ac2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f398623e1eea678f41f89a94300c23d0510ac2", "html_url": "https://github.com/rust-lang/rust/commit/e8f398623e1eea678f41f89a94300c23d0510ac2"}, {"sha": "57db25e614dfc3ea3c407374a562501471eb1c5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/57db25e614dfc3ea3c407374a562501471eb1c5d", "html_url": "https://github.com/rust-lang/rust/commit/57db25e614dfc3ea3c407374a562501471eb1c5d"}], "stats": {"total": 260, "additions": 121, "deletions": 139}, "files": [{"sha": "4e4fe4256c9b0a521834cbc283fcc956736e658b", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 121, "deletions": 139, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/bc335d6c16bc7bb9df1e1e2b982aa13963e8ae7c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc335d6c16bc7bb9df1e1e2b982aa13963e8ae7c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=bc335d6c16bc7bb9df1e1e2b982aa13963e8ae7c", "patch": "@@ -1,4 +1,3 @@\n-use crate::ast;\n use crate::parse::ParseSess;\n use crate::parse::token::{self, Token, TokenKind};\n use crate::symbol::{sym, Symbol};\n@@ -321,33 +320,29 @@ impl<'a> StringReader<'a> {\n         (pos - self.source_file.start_pos).to_usize()\n     }\n \n-    /// Calls `f` with a string slice of the source text spanning from `start`\n-    /// up to but excluding `self.pos`, meaning the slice does not include\n-    /// the character `self.ch`.\n-    fn with_str_from<T, F>(&self, start: BytePos, f: F) -> T\n-        where F: FnOnce(&str) -> T\n+    /// Slice of the source text from `start` up to but excluding `self.pos`,\n+    /// meaning the slice does not include the character `self.ch`.\n+    fn str_from(&self, start: BytePos) -> &str\n     {\n-        self.with_str_from_to(start, self.pos, f)\n+        self.str_from_to(start, self.pos)\n     }\n \n-    /// Creates a Name from a given offset to the current offset.\n-    fn name_from(&self, start: BytePos) -> ast::Name {\n+    /// Creates a Symbol from a given offset to the current offset.\n+    fn symbol_from(&self, start: BytePos) -> Symbol {\n         debug!(\"taking an ident from {:?} to {:?}\", start, self.pos);\n-        self.with_str_from(start, Symbol::intern)\n+        Symbol::intern(self.str_from(start))\n     }\n \n-    /// As name_from, with an explicit endpoint.\n-    fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n+    /// As symbol_from, with an explicit endpoint.\n+    fn symbol_from_to(&self, start: BytePos, end: BytePos) -> Symbol {\n         debug!(\"taking an ident from {:?} to {:?}\", start, end);\n-        self.with_str_from_to(start, end, Symbol::intern)\n+        Symbol::intern(self.str_from_to(start, end))\n     }\n \n-    /// Calls `f` with a string slice of the source text spanning from `start`\n-    /// up to but excluding `end`.\n-    fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T\n-        where F: FnOnce(&str) -> T\n+    /// Slice of the source text spanning from `start` up to but excluding `end`.\n+    fn str_from_to(&self, start: BytePos, end: BytePos) -> &str\n     {\n-        f(&self.src[self.src_index(start)..self.src_index(end)])\n+        &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n@@ -444,7 +439,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Eats <XID_start><XID_continue>*, if possible.\n-    fn scan_optional_raw_name(&mut self) -> Option<ast::Name> {\n+    fn scan_optional_raw_name(&mut self) -> Option<Symbol> {\n         if !ident_start(self.ch) {\n             return None;\n         }\n@@ -456,8 +451,8 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n \n-        self.with_str_from(start, |string| {\n-            if string == \"_\" {\n+        match self.str_from(start) {\n+            \"_\" => {\n                 self.sess.span_diagnostic\n                     .struct_span_warn(self.mk_sp(start, self.pos),\n                                       \"underscore literal suffix is not allowed\")\n@@ -468,10 +463,9 @@ impl<'a> StringReader<'a> {\n                           <https://github.com/rust-lang/rust/issues/42326>\")\n                     .emit();\n                 None\n-            } else {\n-                Some(Symbol::intern(string))\n             }\n-        })\n+            name => Some(Symbol::intern(name))\n+        }\n     }\n \n     /// PRECONDITION: self.ch is not whitespace\n@@ -513,9 +507,7 @@ impl<'a> StringReader<'a> {\n                     }\n \n                     let kind = if doc_comment {\n-                        self.with_str_from(start_bpos, |string| {\n-                            token::DocComment(Symbol::intern(string))\n-                        })\n+                        token::DocComment(self.symbol_from(start_bpos))\n                     } else {\n                         token::Comment\n                     };\n@@ -544,7 +536,7 @@ impl<'a> StringReader<'a> {\n                         self.bump();\n                     }\n                     return Some(Token::new(\n-                        token::Shebang(self.name_from(start)),\n+                        token::Shebang(self.symbol_from(start)),\n                         self.mk_sp(start, self.pos),\n                     ));\n                 }\n@@ -615,23 +607,22 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n \n-        self.with_str_from(start_bpos, |string| {\n-            // but comments with only \"*\"s between two \"/\"s are not\n-            let kind = if is_block_doc_comment(string) {\n-                let string = if has_cr {\n-                    self.translate_crlf(start_bpos,\n-                                        string,\n-                                        \"bare CR not allowed in block doc-comment\")\n-                } else {\n-                    string.into()\n-                };\n-                token::DocComment(Symbol::intern(&string[..]))\n+        let string = self.str_from(start_bpos);\n+        // but comments with only \"*\"s between two \"/\"s are not\n+        let kind = if is_block_doc_comment(string) {\n+            let string = if has_cr {\n+                self.translate_crlf(start_bpos,\n+                                    string,\n+                                    \"bare CR not allowed in block doc-comment\")\n             } else {\n-                token::Comment\n+                string.into()\n             };\n+            token::DocComment(Symbol::intern(&string[..]))\n+        } else {\n+            token::Comment\n+        };\n \n-            Some(Token::new(kind, self.mk_sp(start_bpos, self.pos)))\n-        })\n+        Some(Token::new(kind, self.mk_sp(start_bpos, self.pos)))\n     }\n \n     /// Scan through any digits (base `scan_radix`) or underscores,\n@@ -727,17 +718,17 @@ impl<'a> StringReader<'a> {\n             let pos = self.pos;\n             self.check_float_base(start_bpos, pos, base);\n \n-            (token::Float, self.name_from(start_bpos))\n+            (token::Float, self.symbol_from(start_bpos))\n         } else {\n             // it might be a float if it has an exponent\n             if self.ch_is('e') || self.ch_is('E') {\n                 self.scan_float_exponent();\n                 let pos = self.pos;\n                 self.check_float_base(start_bpos, pos, base);\n-                return (token::Float, self.name_from(start_bpos));\n+                return (token::Float, self.symbol_from(start_bpos));\n             }\n             // but we certainly have an integer!\n-            (token::Integer, self.name_from(start_bpos))\n+            (token::Integer, self.symbol_from(start_bpos))\n         }\n     }\n \n@@ -838,20 +829,17 @@ impl<'a> StringReader<'a> {\n                     self.bump();\n                 }\n \n-                return Ok(self.with_str_from(start, |string| {\n-                    // FIXME: perform NFKC normalization here. (Issue #2253)\n-                    let name = ast::Name::intern(string);\n-\n-                    if is_raw_ident {\n-                        let span = self.mk_sp(raw_start, self.pos);\n-                        if !name.can_be_raw() {\n-                            self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", name));\n-                        }\n-                        self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                // FIXME: perform NFKC normalization here. (Issue #2253)\n+                let name = self.symbol_from(start);\n+                if is_raw_ident {\n+                    let span = self.mk_sp(raw_start, self.pos);\n+                    if !name.can_be_raw() {\n+                        self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", name));\n                     }\n+                    self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                }\n \n-                    token::Ident(name, is_raw_ident)\n-                }));\n+                return Ok(token::Ident(name, is_raw_ident));\n             }\n         }\n \n@@ -1017,7 +1005,7 @@ impl<'a> StringReader<'a> {\n                     // lifetimes shouldn't end with a single quote\n                     // if we find one, then this is an invalid character literal\n                     if self.ch_is('\\'') {\n-                        let symbol = self.name_from(start);\n+                        let symbol = self.symbol_from(start);\n                         self.bump();\n                         self.validate_char_escape(start_with_quote);\n                         return Ok(TokenKind::lit(token::Char, symbol, None));\n@@ -1035,7 +1023,7 @@ impl<'a> StringReader<'a> {\n                     // Include the leading `'` in the real identifier, for macro\n                     // expansion purposes. See #12512 for the gory details of why\n                     // this is necessary.\n-                    return Ok(token::Lifetime(self.name_from(start_with_quote)));\n+                    return Ok(token::Lifetime(self.symbol_from(start_with_quote)));\n                 }\n                 let msg = \"unterminated character literal\";\n                 let symbol = self.scan_single_quoted_string(start_with_quote, msg);\n@@ -1063,7 +1051,7 @@ impl<'a> StringReader<'a> {\n                     },\n                     Some('r') => {\n                         let (start, end, hash_count) = self.scan_raw_string();\n-                        let symbol = self.name_from_to(start, end);\n+                        let symbol = self.symbol_from_to(start, end);\n                         self.validate_raw_byte_str_escape(start, end);\n \n                         (token::ByteStrRaw(hash_count), symbol)\n@@ -1084,7 +1072,7 @@ impl<'a> StringReader<'a> {\n             }\n             'r' => {\n                 let (start, end, hash_count) = self.scan_raw_string();\n-                let symbol = self.name_from_to(start, end);\n+                let symbol = self.symbol_from_to(start, end);\n                 self.validate_raw_str_escape(start, end);\n                 let suffix = self.scan_optional_raw_name();\n \n@@ -1185,7 +1173,7 @@ impl<'a> StringReader<'a> {\n \n     fn scan_single_quoted_string(&mut self,\n                                  start_with_quote: BytePos,\n-                                 unterminated_msg: &str) -> ast::Name {\n+                                 unterminated_msg: &str) -> Symbol {\n         // assumes that first `'` is consumed\n         let start = self.pos;\n         // lex `'''` as a single char, for recovery\n@@ -1217,12 +1205,12 @@ impl<'a> StringReader<'a> {\n             }\n         }\n \n-        let id = self.name_from(start);\n+        let id = self.symbol_from(start);\n         self.bump();\n         id\n     }\n \n-    fn scan_double_quoted_string(&mut self, unterminated_msg: &str) -> ast::Name {\n+    fn scan_double_quoted_string(&mut self, unterminated_msg: &str) -> Symbol {\n         debug_assert!(self.ch_is('\\\"'));\n         let start_with_quote = self.pos;\n         self.bump();\n@@ -1237,7 +1225,7 @@ impl<'a> StringReader<'a> {\n             }\n             self.bump();\n         }\n-        let id = self.name_from(start);\n+        let id = self.symbol_from(start);\n         self.bump();\n         id\n     }\n@@ -1300,101 +1288,95 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn validate_char_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            if let Err((off, err)) = unescape::unescape_char(lit) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        if let Err((off, err)) = unescape::unescape_char(lit) {\n+            emit_unescape_error(\n+                &self.sess.span_diagnostic,\n+                lit,\n+                self.mk_sp(start_with_quote, self.pos),\n+                unescape::Mode::Char,\n+                0..off,\n+                err,\n+            )\n+        }\n+    }\n+\n+    fn validate_byte_escape(&self, start_with_quote: BytePos) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        if let Err((off, err)) = unescape::unescape_byte(lit) {\n+            emit_unescape_error(\n+                &self.sess.span_diagnostic,\n+                lit,\n+                self.mk_sp(start_with_quote, self.pos),\n+                unescape::Mode::Byte,\n+                0..off,\n+                err,\n+            )\n+        }\n+    }\n+\n+    fn validate_str_escape(&self, start_with_quote: BytePos) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        unescape::unescape_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n                     lit,\n                     self.mk_sp(start_with_quote, self.pos),\n-                    unescape::Mode::Char,\n-                    0..off,\n+                    unescape::Mode::Str,\n+                    range,\n                     err,\n                 )\n             }\n-        });\n+        })\n     }\n \n-    fn validate_byte_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            if let Err((off, err)) = unescape::unescape_byte(lit) {\n+    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n+        let lit = self.str_from_to(content_start, content_end);\n+        unescape::unescape_raw_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n                     lit,\n-                    self.mk_sp(start_with_quote, self.pos),\n-                    unescape::Mode::Byte,\n-                    0..off,\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                    unescape::Mode::Str,\n+                    range,\n                     err,\n                 )\n             }\n-        });\n-    }\n-\n-    fn validate_str_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            unescape::unescape_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(start_with_quote, self.pos),\n-                        unescape::Mode::Str,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n-    }\n-\n-    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        self.with_str_from_to(content_start, content_end, |lit: &str| {\n-            unescape::unescape_raw_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                        unescape::Mode::Str,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        })\n     }\n \n     fn validate_raw_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        self.with_str_from_to(content_start, content_end, |lit: &str| {\n-            unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                        unescape::Mode::ByteStr,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        let lit = self.str_from_to(content_start, content_end);\n+        unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit,\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                    unescape::Mode::ByteStr,\n+                    range,\n+                    err,\n+                )\n+            }\n+        })\n     }\n \n     fn validate_byte_str_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            unescape::unescape_byte_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(start_with_quote, self.pos),\n-                        unescape::Mode::ByteStr,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        unescape::unescape_byte_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit,\n+                    self.mk_sp(start_with_quote, self.pos),\n+                    unescape::Mode::ByteStr,\n+                    range,\n+                    err,\n+                )\n+            }\n+        })\n     }\n }\n "}]}