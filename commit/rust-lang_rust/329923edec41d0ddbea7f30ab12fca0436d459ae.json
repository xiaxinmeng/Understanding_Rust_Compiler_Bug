{"sha": "329923edec41d0ddbea7f30ab12fca0436d459ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOTkyM2VkZWM0MWQwZGRiZWE3ZjMwYWIxMmZjYTA0MzZkNDU5YWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-04T16:11:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-04T16:11:40Z"}, "message": "Auto merge of #5257 - mlegner:cast_hex_fp, r=flip1995\n\nResolve false positives of unnecessary_cast for non-decimal integers\n\nThis PR resolves false positives of `unnecessary_cast` for hexadecimal integers to floats and adds a corresponding test case.\n\nFixes: #5220\n\nchangelog: none", "tree": {"sha": "d3ed93bb2fd4b4bbf9e3c41301c65380f5b0b6d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3ed93bb2fd4b4bbf9e3c41301c65380f5b0b6d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/329923edec41d0ddbea7f30ab12fca0436d459ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/329923edec41d0ddbea7f30ab12fca0436d459ae", "html_url": "https://github.com/rust-lang/rust/commit/329923edec41d0ddbea7f30ab12fca0436d459ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/329923edec41d0ddbea7f30ab12fca0436d459ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af", "html_url": "https://github.com/rust-lang/rust/commit/8c7b3ad3fafbe4a3338c38c5ea391c2495dfe0af"}, {"sha": "185fa0d1b1ea7ba9677c7f3d6e2c3d5968f26539", "url": "https://api.github.com/repos/rust-lang/rust/commits/185fa0d1b1ea7ba9677c7f3d6e2c3d5968f26539", "html_url": "https://github.com/rust-lang/rust/commit/185fa0d1b1ea7ba9677c7f3d6e2c3d5968f26539"}], "stats": {"total": 522, "additions": 274, "deletions": 248}, "files": [{"sha": "55a9f61242b4366449d1576716f44c542b28081e", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -1,5 +1,4 @@\n-use crate::utils::span_lint_and_sugg;\n-use crate::utils::sugg::format_numeric_literal;\n+use crate::utils::{numeric_literal, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc::ty;\n use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n@@ -109,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatLiteral {\n                             expr.span,\n                             \"literal cannot be represented as the underlying type without loss of precision\",\n                             \"consider changing the type or replacing it with\",\n-                            format_numeric_literal(&float_str, type_suffix, true),\n+                            numeric_literal::format(&float_str, type_suffix, true),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n@@ -120,7 +119,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatLiteral {\n                         expr.span,\n                         \"float has excessive precision\",\n                         \"consider changing the type or truncating it to\",\n-                        format_numeric_literal(&float_str, type_suffix, true),\n+                        numeric_literal::format(&float_str, type_suffix, true),\n                         Applicability::MachineApplicable,\n                     );\n                 }"}, {"sha": "cee14dc893b53d2f3d91ea635cbd2d13c1df40d5", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -2,7 +2,7 @@ use crate::consts::{\n     constant, constant_simple, Constant,\n     Constant::{F32, F64},\n };\n-use crate::utils::{higher, span_lint_and_sugg, sugg, SpanlessEq};\n+use crate::utils::{higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc::ty;\n use rustc_errors::Applicability;\n@@ -14,7 +14,7 @@ use rustc_span::source_map::Spanned;\n use rustc_ast::ast;\n use std::f32::consts as f32_consts;\n use std::f64::consts as f64_consts;\n-use sugg::{format_numeric_literal, Sugg};\n+use sugg::Sugg;\n \n declare_clippy_lint! {\n     /// **What it does:** Looks for floating-point expressions that\n@@ -276,7 +276,7 @@ fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                 format!(\n                     \"{}.powi({})\",\n                     Sugg::hir(cx, &args[0], \"..\"),\n-                    format_numeric_literal(&exponent.to_string(), None, false)\n+                    numeric_literal::format(&exponent.to_string(), None, false)\n                 ),\n             )\n         } else {"}, {"sha": "9e6b63fafd094d5c532ed02bf7d753c571084c06", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 6, "deletions": 220, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -1,10 +1,14 @@\n //! Lints concerned with the grouping of digits with underscores in integral or\n //! floating-point literal expressions.\n \n-use crate::utils::{in_macro, snippet_opt, span_lint_and_sugg};\n+use crate::utils::{\n+    in_macro,\n+    numeric_literal::{NumericLiteral, Radix},\n+    snippet_opt, span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n use rustc::lint::in_external_macro;\n-use rustc_ast::ast::{Expr, ExprKind, Lit, LitFloatType, LitIntType, LitKind};\n+use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n@@ -103,224 +107,6 @@ declare_clippy_lint! {\n     \"using decimal representation when hexadecimal would be better\"\n }\n \n-#[derive(Debug, PartialEq)]\n-pub(super) enum Radix {\n-    Binary,\n-    Octal,\n-    Decimal,\n-    Hexadecimal,\n-}\n-\n-impl Radix {\n-    /// Returns a reasonable digit group size for this radix.\n-    #[must_use]\n-    fn suggest_grouping(&self) -> usize {\n-        match *self {\n-            Self::Binary | Self::Hexadecimal => 4,\n-            Self::Octal | Self::Decimal => 3,\n-        }\n-    }\n-}\n-\n-/// A helper method to format numeric literals with digit grouping.\n-/// `lit` must be a valid numeric literal without suffix.\n-pub fn format_numeric_literal(lit: &str, type_suffix: Option<&str>, float: bool) -> String {\n-    NumericLiteral::new(lit, type_suffix, float).format()\n-}\n-\n-#[derive(Debug)]\n-pub(super) struct NumericLiteral<'a> {\n-    /// Which radix the literal was represented in.\n-    radix: Radix,\n-    /// The radix prefix, if present.\n-    prefix: Option<&'a str>,\n-\n-    /// The integer part of the number.\n-    integer: &'a str,\n-    /// The fraction part of the number.\n-    fraction: Option<&'a str>,\n-    /// The character used as exponent seperator (b'e' or b'E') and the exponent part.\n-    exponent: Option<(char, &'a str)>,\n-\n-    /// The type suffix, including preceding underscore if present.\n-    suffix: Option<&'a str>,\n-}\n-\n-impl<'a> NumericLiteral<'a> {\n-    fn from_lit(src: &'a str, lit: &Lit) -> Option<NumericLiteral<'a>> {\n-        if lit.kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n-            let (unsuffixed, suffix) = split_suffix(&src, &lit.kind);\n-            let float = if let LitKind::Float(..) = lit.kind { true } else { false };\n-            Some(NumericLiteral::new(unsuffixed, suffix, float))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[must_use]\n-    fn new(lit: &'a str, suffix: Option<&'a str>, float: bool) -> Self {\n-        // Determine delimiter for radix prefix, if present, and radix.\n-        let radix = if lit.starts_with(\"0x\") {\n-            Radix::Hexadecimal\n-        } else if lit.starts_with(\"0b\") {\n-            Radix::Binary\n-        } else if lit.starts_with(\"0o\") {\n-            Radix::Octal\n-        } else {\n-            Radix::Decimal\n-        };\n-\n-        // Grab part of the literal after prefix, if present.\n-        let (prefix, mut sans_prefix) = if let Radix::Decimal = radix {\n-            (None, lit)\n-        } else {\n-            let (p, s) = lit.split_at(2);\n-            (Some(p), s)\n-        };\n-\n-        if suffix.is_some() && sans_prefix.ends_with('_') {\n-            // The '_' before the suffix isn't part of the digits\n-            sans_prefix = &sans_prefix[..sans_prefix.len() - 1];\n-        }\n-\n-        let (integer, fraction, exponent) = Self::split_digit_parts(sans_prefix, float);\n-\n-        Self {\n-            radix,\n-            prefix,\n-            integer,\n-            fraction,\n-            exponent,\n-            suffix,\n-        }\n-    }\n-\n-    fn split_digit_parts(digits: &str, float: bool) -> (&str, Option<&str>, Option<(char, &str)>) {\n-        let mut integer = digits;\n-        let mut fraction = None;\n-        let mut exponent = None;\n-\n-        if float {\n-            for (i, c) in digits.char_indices() {\n-                match c {\n-                    '.' => {\n-                        integer = &digits[..i];\n-                        fraction = Some(&digits[i + 1..]);\n-                    },\n-                    'e' | 'E' => {\n-                        if integer.len() > i {\n-                            integer = &digits[..i];\n-                        } else {\n-                            fraction = Some(&digits[integer.len() + 1..i]);\n-                        };\n-                        exponent = Some((c, &digits[i + 1..]));\n-                        break;\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-\n-        (integer, fraction, exponent)\n-    }\n-\n-    /// Returns literal formatted in a sensible way.\n-    fn format(&self) -> String {\n-        let mut output = String::new();\n-\n-        if let Some(prefix) = self.prefix {\n-            output.push_str(prefix);\n-        }\n-\n-        let group_size = self.radix.suggest_grouping();\n-\n-        Self::group_digits(\n-            &mut output,\n-            self.integer,\n-            group_size,\n-            true,\n-            self.radix == Radix::Hexadecimal,\n-        );\n-\n-        if let Some(fraction) = self.fraction {\n-            output.push('.');\n-            Self::group_digits(&mut output, fraction, group_size, false, false);\n-        }\n-\n-        if let Some((separator, exponent)) = self.exponent {\n-            output.push(separator);\n-            Self::group_digits(&mut output, exponent, group_size, true, false);\n-        }\n-\n-        if let Some(suffix) = self.suffix {\n-            output.push('_');\n-            output.push_str(suffix);\n-        }\n-\n-        output\n-    }\n-\n-    fn group_digits(output: &mut String, input: &str, group_size: usize, partial_group_first: bool, pad: bool) {\n-        debug_assert!(group_size > 0);\n-\n-        let mut digits = input.chars().filter(|&c| c != '_');\n-\n-        let first_group_size;\n-\n-        if partial_group_first {\n-            first_group_size = (digits.clone().count() - 1) % group_size + 1;\n-            if pad {\n-                for _ in 0..group_size - first_group_size {\n-                    output.push('0');\n-                }\n-            }\n-        } else {\n-            first_group_size = group_size;\n-        }\n-\n-        for _ in 0..first_group_size {\n-            if let Some(digit) = digits.next() {\n-                output.push(digit);\n-            }\n-        }\n-\n-        for (c, i) in digits.zip((0..group_size).cycle()) {\n-            if i == 0 {\n-                output.push('_');\n-            }\n-            output.push(c);\n-        }\n-    }\n-}\n-\n-fn split_suffix<'a>(src: &'a str, lit_kind: &LitKind) -> (&'a str, Option<&'a str>) {\n-    debug_assert!(lit_kind.is_numeric());\n-    if let Some(suffix_length) = lit_suffix_length(lit_kind) {\n-        let (unsuffixed, suffix) = src.split_at(src.len() - suffix_length);\n-        (unsuffixed, Some(suffix))\n-    } else {\n-        (src, None)\n-    }\n-}\n-\n-fn lit_suffix_length(lit_kind: &LitKind) -> Option<usize> {\n-    debug_assert!(lit_kind.is_numeric());\n-    let suffix = match lit_kind {\n-        LitKind::Int(_, int_lit_kind) => match int_lit_kind {\n-            LitIntType::Signed(int_ty) => Some(int_ty.name_str()),\n-            LitIntType::Unsigned(uint_ty) => Some(uint_ty.name_str()),\n-            LitIntType::Unsuffixed => None,\n-        },\n-        LitKind::Float(_, float_lit_kind) => match float_lit_kind {\n-            LitFloatType::Suffixed(float_ty) => Some(float_ty.name_str()),\n-            LitFloatType::Unsuffixed => None,\n-        },\n-        _ => None,\n-    };\n-\n-    suffix.map(str::len)\n-}\n-\n enum WarningType {\n     UnreadableLiteral,\n     InconsistentDigitGrouping,"}, {"sha": "e1685c97a065d53bd7a6008c902ea180571914b0", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -30,9 +30,9 @@ use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, int_bits, last_path_segment, match_def_path,\n-    match_path, method_chain_args, multispan_sugg, qpath_res, same_tys, sext, snippet, snippet_opt,\n-    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n-    span_lint_and_then, unsext,\n+    match_path, method_chain_args, multispan_sugg, numeric_literal::NumericLiteral, qpath_res, same_tys, sext, snippet,\n+    snippet_opt, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help,\n+    span_lint_and_sugg, span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -1210,22 +1210,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n             let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n             if let ExprKind::Lit(ref lit) = ex.kind {\n-                if let LitKind::Int(n, _) = lit.node {\n-                    if cast_to.is_floating_point() {\n-                        let from_nbits = 128 - n.leading_zeros();\n-                        let to_nbits = fp_ty_mantissa_nbits(cast_to);\n-                        if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                UNNECESSARY_CAST,\n-                                expr.span,\n-                                &format!(\"casting integer literal to `{}` is unnecessary\", cast_to),\n-                                \"try\",\n-                                format!(\"{}_{}\", n, cast_to),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return;\n-                        }\n+                if_chain! {\n+                    if let LitKind::Int(n, _) = lit.node;\n+                    if let Some(src) = snippet_opt(cx, lit.span);\n+                    if cast_to.is_floating_point();\n+                    if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node);\n+                    let from_nbits = 128 - n.leading_zeros();\n+                    let to_nbits = fp_ty_mantissa_nbits(cast_to);\n+                    if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n+                    then {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_CAST,\n+                            expr.span,\n+                            &format!(\"casting integer literal to `{}` is unnecessary\", cast_to),\n+                            \"try\",\n+                            format!(\"{}_{}\", n, cast_to),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        return;\n                     }\n                 }\n                 match lit.node {"}, {"sha": "dc8775b43b19f53094f3c89eb7b3ebcb97dd49e4", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -12,6 +12,7 @@ pub mod higher;\n mod hir_utils;\n pub mod inspector;\n pub mod internal_lints;\n+pub mod numeric_literal;\n pub mod paths;\n pub mod ptr;\n pub mod sugg;"}, {"sha": "8b3492724e1013b437a6dc8562a4c0ce422e861b", "filename": "clippy_lints/src/utils/numeric_literal.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -0,0 +1,227 @@\n+use rustc_ast::ast::{Lit, LitFloatType, LitIntType, LitKind};\n+\n+#[derive(Debug, PartialEq)]\n+pub(crate) enum Radix {\n+    Binary,\n+    Octal,\n+    Decimal,\n+    Hexadecimal,\n+}\n+\n+impl Radix {\n+    /// Returns a reasonable digit group size for this radix.\n+    #[must_use]\n+    fn suggest_grouping(&self) -> usize {\n+        match *self {\n+            Self::Binary | Self::Hexadecimal => 4,\n+            Self::Octal | Self::Decimal => 3,\n+        }\n+    }\n+}\n+\n+/// A helper method to format numeric literals with digit grouping.\n+/// `lit` must be a valid numeric literal without suffix.\n+pub fn format(lit: &str, type_suffix: Option<&str>, float: bool) -> String {\n+    NumericLiteral::new(lit, type_suffix, float).format()\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct NumericLiteral<'a> {\n+    /// Which radix the literal was represented in.\n+    pub radix: Radix,\n+    /// The radix prefix, if present.\n+    pub prefix: Option<&'a str>,\n+\n+    /// The integer part of the number.\n+    pub integer: &'a str,\n+    /// The fraction part of the number.\n+    pub fraction: Option<&'a str>,\n+    /// The character used as exponent seperator (b'e' or b'E') and the exponent part.\n+    pub exponent: Option<(char, &'a str)>,\n+\n+    /// The type suffix, including preceding underscore if present.\n+    pub suffix: Option<&'a str>,\n+}\n+\n+impl<'a> NumericLiteral<'a> {\n+    pub fn from_lit(src: &'a str, lit: &Lit) -> Option<NumericLiteral<'a>> {\n+        NumericLiteral::from_lit_kind(src, &lit.kind)\n+    }\n+\n+    pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n+        if lit_kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n+            let (unsuffixed, suffix) = split_suffix(&src, lit_kind);\n+            let float = if let LitKind::Float(..) = lit_kind { true } else { false };\n+            Some(NumericLiteral::new(unsuffixed, suffix, float))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[must_use]\n+    pub fn new(lit: &'a str, suffix: Option<&'a str>, float: bool) -> Self {\n+        // Determine delimiter for radix prefix, if present, and radix.\n+        let radix = if lit.starts_with(\"0x\") {\n+            Radix::Hexadecimal\n+        } else if lit.starts_with(\"0b\") {\n+            Radix::Binary\n+        } else if lit.starts_with(\"0o\") {\n+            Radix::Octal\n+        } else {\n+            Radix::Decimal\n+        };\n+\n+        // Grab part of the literal after prefix, if present.\n+        let (prefix, mut sans_prefix) = if let Radix::Decimal = radix {\n+            (None, lit)\n+        } else {\n+            let (p, s) = lit.split_at(2);\n+            (Some(p), s)\n+        };\n+\n+        if suffix.is_some() && sans_prefix.ends_with('_') {\n+            // The '_' before the suffix isn't part of the digits\n+            sans_prefix = &sans_prefix[..sans_prefix.len() - 1];\n+        }\n+\n+        let (integer, fraction, exponent) = Self::split_digit_parts(sans_prefix, float);\n+\n+        Self {\n+            radix,\n+            prefix,\n+            integer,\n+            fraction,\n+            exponent,\n+            suffix,\n+        }\n+    }\n+\n+    pub fn is_decimal(&self) -> bool {\n+        self.radix == Radix::Decimal\n+    }\n+\n+    pub fn split_digit_parts(digits: &str, float: bool) -> (&str, Option<&str>, Option<(char, &str)>) {\n+        let mut integer = digits;\n+        let mut fraction = None;\n+        let mut exponent = None;\n+\n+        if float {\n+            for (i, c) in digits.char_indices() {\n+                match c {\n+                    '.' => {\n+                        integer = &digits[..i];\n+                        fraction = Some(&digits[i + 1..]);\n+                    },\n+                    'e' | 'E' => {\n+                        if integer.len() > i {\n+                            integer = &digits[..i];\n+                        } else {\n+                            fraction = Some(&digits[integer.len() + 1..i]);\n+                        };\n+                        exponent = Some((c, &digits[i + 1..]));\n+                        break;\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+\n+        (integer, fraction, exponent)\n+    }\n+\n+    /// Returns literal formatted in a sensible way.\n+    pub fn format(&self) -> String {\n+        let mut output = String::new();\n+\n+        if let Some(prefix) = self.prefix {\n+            output.push_str(prefix);\n+        }\n+\n+        let group_size = self.radix.suggest_grouping();\n+\n+        Self::group_digits(\n+            &mut output,\n+            self.integer,\n+            group_size,\n+            true,\n+            self.radix == Radix::Hexadecimal,\n+        );\n+\n+        if let Some(fraction) = self.fraction {\n+            output.push('.');\n+            Self::group_digits(&mut output, fraction, group_size, false, false);\n+        }\n+\n+        if let Some((separator, exponent)) = self.exponent {\n+            output.push(separator);\n+            Self::group_digits(&mut output, exponent, group_size, true, false);\n+        }\n+\n+        if let Some(suffix) = self.suffix {\n+            output.push('_');\n+            output.push_str(suffix);\n+        }\n+\n+        output\n+    }\n+\n+    pub fn group_digits(output: &mut String, input: &str, group_size: usize, partial_group_first: bool, pad: bool) {\n+        debug_assert!(group_size > 0);\n+\n+        let mut digits = input.chars().filter(|&c| c != '_');\n+\n+        let first_group_size;\n+\n+        if partial_group_first {\n+            first_group_size = (digits.clone().count() - 1) % group_size + 1;\n+            if pad {\n+                for _ in 0..group_size - first_group_size {\n+                    output.push('0');\n+                }\n+            }\n+        } else {\n+            first_group_size = group_size;\n+        }\n+\n+        for _ in 0..first_group_size {\n+            if let Some(digit) = digits.next() {\n+                output.push(digit);\n+            }\n+        }\n+\n+        for (c, i) in digits.zip((0..group_size).cycle()) {\n+            if i == 0 {\n+                output.push('_');\n+            }\n+            output.push(c);\n+        }\n+    }\n+}\n+\n+fn split_suffix<'a>(src: &'a str, lit_kind: &LitKind) -> (&'a str, Option<&'a str>) {\n+    debug_assert!(lit_kind.is_numeric());\n+    if let Some(suffix_length) = lit_suffix_length(lit_kind) {\n+        let (unsuffixed, suffix) = src.split_at(src.len() - suffix_length);\n+        (unsuffixed, Some(suffix))\n+    } else {\n+        (src, None)\n+    }\n+}\n+\n+fn lit_suffix_length(lit_kind: &LitKind) -> Option<usize> {\n+    debug_assert!(lit_kind.is_numeric());\n+    let suffix = match lit_kind {\n+        LitKind::Int(_, int_lit_kind) => match int_lit_kind {\n+            LitIntType::Signed(int_ty) => Some(int_ty.name_str()),\n+            LitIntType::Unsigned(uint_ty) => Some(uint_ty.name_str()),\n+            LitIntType::Unsuffixed => None,\n+        },\n+        LitKind::Float(_, float_lit_kind) => match float_lit_kind {\n+            LitFloatType::Suffixed(float_ty) => Some(float_ty.name_str()),\n+            LitFloatType::Unsuffixed => None,\n+        },\n+        _ => None,\n+    };\n+\n+    suffix.map(str::len)\n+}"}, {"sha": "8cf3c07a2d42745a90d2e35975bc01685d7d2f26", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -15,8 +15,6 @@ use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::Display;\n \n-pub use crate::literal_representation::format_numeric_literal;\n-\n /// A helper type to build suggestion correctly handling parenthesis.\n pub enum Sugg<'a> {\n     /// An expression that never needs parenthesis such as `1337` or `[0; 42]`."}, {"sha": "fb89a9fce3d5bf91a9ced4dbbd7d5014533c26b1", "filename": "tests/ui/unnecessary_cast_fixable.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/tests%2Fui%2Funnecessary_cast_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/tests%2Fui%2Funnecessary_cast_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast_fixable.fixed?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -14,4 +14,10 @@ fn main() {\n     &v as &[i32];\n     1.0 as f64;\n     1 as u64;\n+    0x10 as f32;\n+    0o10 as f32;\n+    0b10 as f32;\n+    0x11 as f64;\n+    0o11 as f64;\n+    0b11 as f64;\n }"}, {"sha": "4a0c8620dc134acfd26c35a535c126653c3ac998", "filename": "tests/ui/unnecessary_cast_fixable.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329923edec41d0ddbea7f30ab12fca0436d459ae/tests%2Fui%2Funnecessary_cast_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329923edec41d0ddbea7f30ab12fca0436d459ae/tests%2Fui%2Funnecessary_cast_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast_fixable.rs?ref=329923edec41d0ddbea7f30ab12fca0436d459ae", "patch": "@@ -14,4 +14,10 @@ fn main() {\n     &v as &[i32];\n     1.0 as f64;\n     1 as u64;\n+    0x10 as f32;\n+    0o10 as f32;\n+    0b10 as f32;\n+    0x11 as f64;\n+    0o11 as f64;\n+    0b11 as f64;\n }"}]}