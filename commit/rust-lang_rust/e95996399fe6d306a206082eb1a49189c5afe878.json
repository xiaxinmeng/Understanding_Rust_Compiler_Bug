{"sha": "e95996399fe6d306a206082eb1a49189c5afe878", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NTk5NjM5OWZlNmQzMDZhMjA2MDgyZWIxYTQ5MTg5YzVhZmU4Nzg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-30T21:40:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-24T01:23:21Z"}, "message": "libsyntax: Remove some more `@fn`s from the macro expander", "tree": {"sha": "98d045bbdcff2897d53a0e1e064ff17277058b8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98d045bbdcff2897d53a0e1e064ff17277058b8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e95996399fe6d306a206082eb1a49189c5afe878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e95996399fe6d306a206082eb1a49189c5afe878", "html_url": "https://github.com/rust-lang/rust/commit/e95996399fe6d306a206082eb1a49189c5afe878", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e95996399fe6d306a206082eb1a49189c5afe878/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a8169db0a201b9fc2fbf581f507e143f0482aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8169db0a201b9fc2fbf581f507e143f0482aae", "html_url": "https://github.com/rust-lang/rust/commit/6a8169db0a201b9fc2fbf581f507e143f0482aae"}], "stats": {"total": 409, "additions": 300, "deletions": 109}, "files": [{"sha": "63816072c291486251a1e27548f19a67206fbcb6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 159, "deletions": 79, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/e95996399fe6d306a206082eb1a49189c5afe878/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95996399fe6d306a206082eb1a49189c5afe878/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e95996399fe6d306a206082eb1a49189c5afe878", "patch": "@@ -33,62 +33,120 @@ pub struct MacroDef {\n     ext: SyntaxExtension\n }\n \n-// No context arg for an Item Decorator macro, simply because\n-// adding it would require adding a ctxt field to all items.\n-// we could do this if it turns out to be useful.\n-\n-pub type ItemDecoratorFun = @fn(@ExtCtxt,\n-                             Span,\n-                             @ast::MetaItem,\n-                             ~[@ast::item])\n-                          -> ~[@ast::item];\n-\n-pub type SyntaxExpanderTTFun = @fn(@ExtCtxt,\n-                                   Span,\n-                                   &[ast::token_tree],\n-                                   ast::SyntaxContext)\n-                                -> MacResult;\n-\n-pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n-                                       Span,\n-                                       ast::Ident,\n-                                       ~[ast::token_tree],\n-                                       ast::SyntaxContext)\n-                                    -> MacResult;\n-\n-// oog... in order to make the presentation of builtin_normal_tt_no_ctxt\n-// and builtin_ident_tt_no_ctxt palatable, we need one-off types for\n-// functions that don't consume a ctxt:\n-\n-pub type SyntaxExpanderTTFunNoCtxt = @fn(@ExtCtxt,\n-                                   Span,\n-                                   &[ast::token_tree])\n-                                -> MacResult;\n-\n-pub type SyntaxExpanderTTItemFunNoCtxt = @fn(@ExtCtxt,\n-                                       Span,\n-                                       ast::Ident,\n-                                       ~[ast::token_tree])\n-                                    -> MacResult;\n+pub type ItemDecorator = extern \"Rust\" fn(@ExtCtxt,\n+                                          Span,\n+                                          @ast::MetaItem,\n+                                          ~[@ast::item])\n+                                          -> ~[@ast::item];\n+\n+pub struct SyntaxExpanderTT {\n+    expander: SyntaxExpanderTTExpander,\n+    span: Option<Span>\n+}\n+\n+pub trait SyntaxExpanderTTTrait {\n+    fn expand(&self,\n+              ecx: @ExtCtxt,\n+              span: Span,\n+              token_tree: &[ast::token_tree],\n+              context: ast::SyntaxContext)\n+              -> MacResult;\n+}\n+\n+pub type SyntaxExpanderTTFunNoCtxt =\n+    extern \"Rust\" fn(ecx: @ExtCtxt,\n+                     span: codemap::Span,\n+                     token_tree: &[ast::token_tree])\n+                     -> MacResult;\n+\n+enum SyntaxExpanderTTExpander {\n+    SyntaxExpanderTTExpanderWithoutContext(SyntaxExpanderTTFunNoCtxt),\n+}\n+\n+impl SyntaxExpanderTTTrait for SyntaxExpanderTT {\n+    fn expand(&self,\n+              ecx: @ExtCtxt,\n+              span: Span,\n+              token_tree: &[ast::token_tree],\n+              _: ast::SyntaxContext)\n+              -> MacResult {\n+        match self.expander {\n+            SyntaxExpanderTTExpanderWithoutContext(f) => {\n+                f(ecx, span, token_tree)\n+            }\n+        }\n+    }\n+}\n \n+enum SyntaxExpanderTTItemExpander {\n+    SyntaxExpanderTTItemExpanderWithContext(SyntaxExpanderTTItemFun),\n+    SyntaxExpanderTTItemExpanderWithoutContext(SyntaxExpanderTTItemFunNoCtxt),\n+}\n \n+pub struct SyntaxExpanderTTItem {\n+    expander: SyntaxExpanderTTItemExpander,\n+    span: Option<Span>\n+}\n+\n+pub trait SyntaxExpanderTTItemTrait {\n+    fn expand(&self,\n+              cx: @ExtCtxt,\n+              sp: Span,\n+              ident: ast::Ident,\n+              token_tree: ~[ast::token_tree],\n+              context: ast::SyntaxContext)\n+              -> MacResult;\n+}\n+\n+impl SyntaxExpanderTTItemTrait for SyntaxExpanderTTItem {\n+    fn expand(&self,\n+              cx: @ExtCtxt,\n+              sp: Span,\n+              ident: ast::Ident,\n+              token_tree: ~[ast::token_tree],\n+              context: ast::SyntaxContext)\n+              -> MacResult {\n+        match self.expander {\n+            SyntaxExpanderTTItemExpanderWithContext(fun) => {\n+                fun(cx, sp, ident, token_tree, context)\n+            }\n+            SyntaxExpanderTTItemExpanderWithoutContext(fun) => {\n+                fun(cx, sp, ident, token_tree)\n+            }\n+        }\n+    }\n+}\n+\n+pub type SyntaxExpanderTTItemFun = extern \"Rust\" fn(@ExtCtxt,\n+                                                    Span,\n+                                                    ast::Ident,\n+                                                    ~[ast::token_tree],\n+                                                    ast::SyntaxContext)\n+                                                    -> MacResult;\n+\n+pub type SyntaxExpanderTTItemFunNoCtxt =\n+    extern \"Rust\" fn(@ExtCtxt, Span, ast::Ident, ~[ast::token_tree])\n+                     -> MacResult;\n+\n+pub trait AnyMacro {\n+    fn make_expr(&self) -> @ast::Expr;\n+    fn make_item(&self) -> Option<@ast::item>;\n+    fn make_stmt(&self) -> @ast::Stmt;\n+}\n \n pub enum MacResult {\n     MRExpr(@ast::Expr),\n     MRItem(@ast::item),\n-    MRAny(@fn() -> @ast::Expr,\n-          @fn() -> Option<@ast::item>,\n-          @fn() -> @ast::Stmt),\n-    MRDef(MacroDef)\n+    MRAny(@AnyMacro),\n+    MRDef(MacroDef),\n }\n \n pub enum SyntaxExtension {\n-\n     // #[auto_encode] and such\n-    ItemDecorator(ItemDecoratorFun),\n+    ItemDecorator(ItemDecorator),\n \n     // Token-tree expanders\n-    NormalTT(SyntaxExpanderTTFun, Option<Span>),\n+    NormalTT(@SyntaxExpanderTTTrait, Option<Span>),\n \n     // An IdentTT is a macro that has an\n     // identifier in between the name of the\n@@ -98,7 +156,7 @@ pub enum SyntaxExtension {\n \n     // perhaps macro_rules! will lose its odd special identifier argument,\n     // and this can go away also\n-    IdentTT(SyntaxExpanderTTItemFun, Option<Span>),\n+    IdentTT(@SyntaxExpanderTTItemTrait, Option<Span>),\n }\n \n \n@@ -133,16 +191,22 @@ type RenameList = ~[(ast::Ident,Name)];\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n-    // that ignore their contexts\n-    fn builtin_normal_tt_no_ctxt(f: SyntaxExpanderTTFunNoCtxt) -> @Transformer {\n-        let wrapped_expander : SyntaxExpanderTTFun = |a,b,c,_d|{f(a,b,c)};\n-        @SE(NormalTT(wrapped_expander, None))\n+    fn builtin_normal_tt_no_ctxt(f: SyntaxExpanderTTFunNoCtxt)\n+                                 -> @Transformer {\n+        @SE(NormalTT(@SyntaxExpanderTT{\n+            expander: SyntaxExpanderTTExpanderWithoutContext(f),\n+            span: None,\n+        } as @SyntaxExpanderTTTrait,\n+        None))\n     }\n     // utility function to simplify creating IdentTT syntax extensions\n     // that ignore their contexts\n     fn builtin_item_tt_no_ctxt(f: SyntaxExpanderTTItemFunNoCtxt) -> @Transformer {\n-        let wrapped_expander : SyntaxExpanderTTItemFun = |a,b,c,d,_e|{f(a,b,c,d)};\n-        @SE(IdentTT(wrapped_expander, None))\n+        @SE(IdentTT(@SyntaxExpanderTTItem {\n+            expander: SyntaxExpanderTTItemExpanderWithoutContext(f),\n+            span: None,\n+        } as @SyntaxExpanderTTItemTrait,\n+        None))\n     }\n     let mut syntax_expanders = HashMap::new();\n     // NB identifier starts with space, and can't conflict with legal idents\n@@ -152,79 +216,95 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 pending_renames : @mut ~[]\n                             }));\n     syntax_expanders.insert(intern(&\"macro_rules\"),\n-                            @SE(IdentTT(ext::tt::macro_rules::add_new_extension, None)));\n+                            @SE(IdentTT(@SyntaxExpanderTTItem {\n+                                expander: SyntaxExpanderTTItemExpanderWithContext(ext::tt::macro_rules::add_new_extension),\n+                                span: None,\n+                            } as @SyntaxExpanderTTItemTrait,\n+                            None)));\n     syntax_expanders.insert(intern(&\"fmt\"),\n-                            builtin_normal_tt_no_ctxt(ext::fmt::expand_syntax_ext));\n+                            builtin_normal_tt_no_ctxt(\n+                                ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"format_args\"),\n-                            builtin_normal_tt_no_ctxt(ext::format::expand_args));\n+                            builtin_normal_tt_no_ctxt(\n+                                ext::format::expand_args));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n     syntax_expanders.insert(\n         intern(&\"auto_decode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n     syntax_expanders.insert(intern(&\"env\"),\n-                            builtin_normal_tt_no_ctxt(ext::env::expand_env));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::env::expand_env));\n     syntax_expanders.insert(intern(&\"option_env\"),\n-                            builtin_normal_tt_no_ctxt(ext::env::expand_option_env));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::env::expand_option_env));\n     syntax_expanders.insert(intern(\"bytes\"),\n-                            builtin_normal_tt_no_ctxt(ext::bytes::expand_syntax_ext));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::bytes::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"concat_idents\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::concat_idents::expand_syntax_ext));\n+                                    ext::concat_idents::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"log_syntax\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::log_syntax::expand_syntax_ext));\n+                                    ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"deriving\"),\n                             @SE(ItemDecorator(\n                                 ext::deriving::expand_meta_deriving)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(intern(&\"quote_tokens\"),\n-                            builtin_normal_tt_no_ctxt(\n-                                ext::quote::expand_quote_tokens));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_tokens));\n     syntax_expanders.insert(intern(&\"quote_expr\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_expr));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_expr));\n     syntax_expanders.insert(intern(&\"quote_ty\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_ty));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_ty));\n     syntax_expanders.insert(intern(&\"quote_item\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_item));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_item));\n     syntax_expanders.insert(intern(&\"quote_pat\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_pat));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_pat));\n     syntax_expanders.insert(intern(&\"quote_stmt\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_stmt));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_stmt));\n \n     syntax_expanders.insert(intern(&\"line\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_line));\n+                                    ext::source_util::expand_line));\n     syntax_expanders.insert(intern(&\"col\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_col));\n+                                    ext::source_util::expand_col));\n     syntax_expanders.insert(intern(&\"file\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_file));\n+                                    ext::source_util::expand_file));\n     syntax_expanders.insert(intern(&\"stringify\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_stringify));\n+                                    ext::source_util::expand_stringify));\n     syntax_expanders.insert(intern(&\"include\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_include));\n+                                    ext::source_util::expand_include));\n     syntax_expanders.insert(intern(&\"include_str\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_include_str));\n+                                    ext::source_util::expand_include_str));\n     syntax_expanders.insert(intern(&\"include_bin\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_include_bin));\n+                                    ext::source_util::expand_include_bin));\n     syntax_expanders.insert(intern(&\"module_path\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_mod));\n+                                    ext::source_util::expand_mod));\n     syntax_expanders.insert(intern(&\"asm\"),\n-                            builtin_normal_tt_no_ctxt(ext::asm::expand_asm));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::asm::expand_asm));\n     syntax_expanders.insert(intern(&\"cfg\"),\n-                            builtin_normal_tt_no_ctxt(ext::cfg::expand_cfg));\n-    syntax_expanders.insert(\n-        intern(&\"trace_macros\"),\n-        builtin_normal_tt_no_ctxt(ext::trace_macros::expand_trace_macros));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::cfg::expand_cfg));\n+    syntax_expanders.insert(intern(&\"trace_macros\"),\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::trace_macros::expand_trace_macros));\n     MapChain::new(~syntax_expanders)\n }\n "}, {"sha": "60aa7cc5f9292bc9f1956d308042018cfe1d419b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e95996399fe6d306a206082eb1a49189c5afe878/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95996399fe6d306a206082eb1a49189c5afe878/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e95996399fe6d306a206082eb1a49189c5afe878", "patch": "@@ -83,10 +83,12 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             let mac_span = original_span(cx);\n \n                             let expanded =\n-                                match expandfun(cx, mac_span.call_site,\n-                                                marked_before, marked_ctxt) {\n+                                match expandfun.expand(cx,\n+                                                       mac_span.call_site,\n+                                                       marked_before,\n+                                                       marked_ctxt) {\n                                     MRExpr(e) => e,\n-                                    MRAny(expr_maker,_,_) => expr_maker(),\n+                                    MRAny(any_macro) => any_macro.make_expr(),\n                                     _ => {\n                                         cx.span_fatal(\n                                             pth.span,\n@@ -370,7 +372,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_before = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            expander(cx, it.span, marked_before, marked_ctxt)\n+            expander.expand(cx, it.span, marked_before, marked_ctxt)\n         }\n         Some(@SE(IdentTT(expander, span))) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n@@ -388,7 +390,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_tts = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            expander(cx, it.span, it.ident, marked_tts, marked_ctxt)\n+            expander.expand(cx, it.span, it.ident, marked_tts, marked_ctxt)\n         }\n         _ => cx.span_fatal(\n             it.span, fmt!(\"%s! is not legal in item position\", extnamestr))\n@@ -402,10 +404,10 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         MRExpr(_) => {\n             cx.span_fatal(pth.span, fmt!(\"expr macro in item position: %s\", extnamestr))\n         }\n-        MRAny(_, item_maker, _) => {\n-            item_maker()\n-                .and_then(|i| mark_item(i,fm))\n-                .and_then(|i| fld.fold_item(i))\n+        MRAny(any_macro) => {\n+            any_macro.make_item()\n+                     .and_then(|i| mark_item(i,fm))\n+                     .and_then(|i| fld.fold_item(i))\n         }\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n@@ -481,17 +483,17 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             // not the current mac.span.\n             let mac_span = original_span(cx);\n \n-            let expanded = match expandfun(cx,\n-                                           mac_span.call_site,\n-                                           marked_tts,\n-                                           marked_ctxt) {\n+            let expanded = match expandfun.expand(cx,\n+                                                  mac_span.call_site,\n+                                                  marked_tts,\n+                                                  marked_ctxt) {\n                 MRExpr(e) => {\n                     @codemap::Spanned {\n                         node: StmtExpr(e, ast::DUMMY_NODE_ID),\n                         span: e.span,\n                     }\n                 }\n-                MRAny(_,_,stmt_mkr) => stmt_mkr(),\n+                MRAny(any_macro) => any_macro.make_stmt(),\n                 _ => cx.span_fatal(\n                     pth.span,\n                     fmt!(\"non-stmt macro in stmt pos: %s\", extnamestr))"}, {"sha": "3fd394b3652a3674483ffd14ff1e6e3629a67541", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 125, "deletions": 16, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/e95996399fe6d306a206082eb1a49189c5afe878/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95996399fe6d306a206082eb1a49189c5afe878/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e95996399fe6d306a206082eb1a49189c5afe878", "patch": "@@ -12,9 +12,9 @@ use ast::{Ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n use codemap::{Span, Spanned, dummy_sp};\n-use ext::base::{ExtCtxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n+use ext::base::{AnyMacro, ExtCtxt, MacResult, MRAny, MRDef, MacroDef};\n+use ext::base::{NormalTT, SyntaxExpanderTTTrait};\n use ext::base;\n-use ext::expand;\n use ext::tt::macro_parser::{error};\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else, success, failure};\n@@ -24,17 +24,121 @@ use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_st\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n+struct ParserAnyMacro {\n+    parser: @Parser,\n+}\n+\n+impl AnyMacro for ParserAnyMacro {\n+    fn make_expr(&self) -> @ast::Expr {\n+        self.parser.parse_expr()\n+    }\n+    fn make_item(&self) -> Option<@ast::item> {\n+        self.parser.parse_item(~[])     // no attrs\n+    }\n+    fn make_stmt(&self) -> @ast::Stmt {\n+        self.parser.parse_stmt(~[])     // no attrs\n+    }\n+}\n+\n+struct MacroRulesSyntaxExpanderTTFun {\n+    name: Ident,\n+    lhses: @~[@named_match],\n+    rhses: @~[@named_match],\n+}\n+\n+impl SyntaxExpanderTTTrait for MacroRulesSyntaxExpanderTTFun {\n+    fn expand(&self,\n+              cx: @ExtCtxt,\n+              sp: Span,\n+              arg: &[ast::token_tree],\n+              _: ast::SyntaxContext)\n+              -> MacResult {\n+        generic_extension(cx, sp, self.name, arg, *self.lhses, *self.rhses)\n+    }\n+}\n+\n+// Given `lhses` and `rhses`, this is the new macro we create\n+fn generic_extension(cx: @ExtCtxt,\n+                     sp: Span,\n+                     name: Ident,\n+                     arg: &[ast::token_tree],\n+                     lhses: &[@named_match],\n+                     rhses: &[@named_match])\n+                     -> MacResult {\n+    if cx.trace_macros() {\n+        printfln!(\"%s! { %s }\",\n+                  cx.str_of(name),\n+                  print::pprust::tt_to_str(\n+                      &ast::tt_delim(@mut arg.to_owned()),\n+                      get_ident_interner()));\n+    }\n+\n+    // Which arm's failure should we report? (the one furthest along)\n+    let mut best_fail_spot = dummy_sp();\n+    let mut best_fail_msg = ~\"internal error: ran no matchers\";\n+\n+    let s_d = cx.parse_sess().span_diagnostic;\n+\n+    for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n+        match *lhs {\n+          @matched_nonterminal(nt_matchers(ref mtcs)) => {\n+            // `none` is because we're not interpolating\n+            let arg_rdr = new_tt_reader(\n+                s_d,\n+                None,\n+                arg.to_owned()\n+            ) as @mut reader;\n+            match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n+              success(named_matches) => {\n+                let rhs = match rhses[i] {\n+                    // okay, what's your transcriber?\n+                    @matched_nonterminal(nt_tt(@ref tt)) => {\n+                        match (*tt) {\n+                            // cut off delimiters; don't parse 'em\n+                            tt_delim(ref tts) => {\n+                                (*tts).slice(1u,(*tts).len()-1u).to_owned()\n+                            }\n+                            _ => cx.span_fatal(\n+                                sp, \"macro rhs must be delimited\")\n+                        }\n+                    },\n+                    _ => cx.span_bug(sp, \"bad thing in rhs\")\n+                };\n+                // rhs has holes ( `$id` and `$(...)` that need filled)\n+                let trncbr = new_tt_reader(s_d, Some(named_matches),\n+                                           rhs);\n+                let p = @Parser(cx.parse_sess(),\n+                                cx.cfg(),\n+                                trncbr as @mut reader);\n+\n+                // Let the context choose how to interpret the result.\n+                // Weird, but useful for X-macros.\n+                return MRAny(@ParserAnyMacro {\n+                    parser: p,\n+                } as @AnyMacro)\n+              }\n+              failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n+                best_fail_spot = sp;\n+                best_fail_msg = (*msg).clone();\n+              },\n+              error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n+            }\n+          }\n+          _ => cx.bug(\"non-matcher found in parsed lhses\")\n+        }\n+    }\n+    cx.span_fatal(best_fail_spot, best_fail_msg);\n+}\n+\n // this procedure performs the expansion of the\n // macro_rules! macro. It parses the RHS and adds\n // an extension to the current context.\n pub fn add_new_extension(cx: @ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n                          arg: ~[ast::token_tree],\n-                         stx_ctxt: ast::SyntaxContext)\n-                      -> base::MacResult {\n-    let arg = expand::mtwt_cancel_outer_mark(arg,stx_ctxt);\n-    // Wrap a matcher_ in a spanned to produce a matcher.\n+                         _: ast::SyntaxContext)\n+                         -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n         Spanned {\n@@ -82,11 +186,13 @@ pub fn add_new_extension(cx: @ExtCtxt,\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: @ExtCtxt, sp: Span, name: Ident,\n+    fn generic_extension(cx: @ExtCtxt,\n+                         sp: Span,\n+                         name: Ident,\n                          arg: &[ast::token_tree],\n-                         lhses: &[@named_match], rhses: &[@named_match])\n-    -> MacResult {\n-\n+                         lhses: &[@named_match],\n+                         rhses: &[@named_match])\n+                         -> MacResult {\n         if cx.trace_macros() {\n             printfln!(\"%s! { %s }\",\n                       cx.str_of(name),\n@@ -135,9 +241,9 @@ pub fn add_new_extension(cx: @ExtCtxt,\n \n                     // Let the context choose how to interpret the result.\n                     // Weird, but useful for X-macros.\n-                    return MRAny(|| p.parse_expr(),\n-                                  || p.parse_item(~[/* no attrs*/]),\n-                                  || p.parse_stmt(~[/* no attrs*/]));\n+                    return MRAny(@ParserAnyMacro {\n+                        parser: p\n+                    } as @AnyMacro);\n                   }\n                   failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                     best_fail_spot = sp;\n@@ -152,10 +258,13 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(@ExtCtxt, Span, &[ast::token_tree], ctxt: ast::SyntaxContext) -> MacResult =\n-        |cx, sp, arg, _ctxt| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n+    let exp = @MacroRulesSyntaxExpanderTTFun {\n+        name: name,\n+        lhses: lhses,\n+        rhses: rhses,\n+    } as @SyntaxExpanderTTTrait;\n \n-    return MRDef(MacroDef{\n+    return MRDef(MacroDef {\n         name: ident_to_str(&name),\n         ext: NormalTT(exp, Some(sp))\n     });"}]}