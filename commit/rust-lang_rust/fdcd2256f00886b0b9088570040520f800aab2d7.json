{"sha": "fdcd2256f00886b0b9088570040520f800aab2d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkY2QyMjU2ZjAwODg2YjBiOTA4ODU3MDA0MDUyMGY4MDBhYWIyZDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-31T17:21:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-02T14:34:25Z"}, "message": "trace span info for constraints and report errors", "tree": {"sha": "eb1e3753776a0d8cc339a639e5613518b81dac78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb1e3753776a0d8cc339a639e5613518b81dac78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdcd2256f00886b0b9088570040520f800aab2d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdcd2256f00886b0b9088570040520f800aab2d7", "html_url": "https://github.com/rust-lang/rust/commit/fdcd2256f00886b0b9088570040520f800aab2d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdcd2256f00886b0b9088570040520f800aab2d7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53e4bd44dedc6bbff84a5bfe564867362c320f49", "url": "https://api.github.com/repos/rust-lang/rust/commits/53e4bd44dedc6bbff84a5bfe564867362c320f49", "html_url": "https://github.com/rust-lang/rust/commit/53e4bd44dedc6bbff84a5bfe564867362c320f49"}], "stats": {"total": 186, "additions": 155, "deletions": 31}, "files": [{"sha": "a2f9bbb174eb737b2b6a91e8a51615b350650c0e", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd2256f00886b0b9088570040520f800aab2d7/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd2256f00886b0b9088570040520f800aab2d7/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=fdcd2256f00886b0b9088570040520f800aab2d7", "patch": "@@ -191,14 +191,16 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n         _borrowed_lv: &Lvalue<'tcx>,\n     ) {\n         let tcx = self.infcx.tcx;\n+        let span = self.mir.source_info(location).span;\n         let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n \n         let destination_region = match destination_ty.sty {\n             ty::TyRef(r, _) => r,\n             _ => bug!()\n         };\n \n-        self.regioncx.add_outlives(borrow_region.to_region_index(),\n+        self.regioncx.add_outlives(span,\n+                                   borrow_region.to_region_index(),\n                                    destination_region.to_region_index(),\n                                    location.successor_within_block());\n     }\n@@ -226,7 +228,9 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n                         },\n                     }\n \n-                    self.regioncx.add_outlives(base_region.to_region_index(),\n+                    let span = self.mir.source_info(location).span;\n+                    self.regioncx.add_outlives(span,\n+                                               base_region.to_region_index(),\n                                                borrow_region.to_region_index(),\n                                                location.successor_within_block());\n                 }\n@@ -259,8 +263,9 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cx, 'gcx, 'tcx> {\n             let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n             let rv_ty = rv.ty(self.mir, tcx);\n \n+            let span = self.mir.source_info(location).span;\n             for (a, b) in subtype::outlives_pairs(tcx, rv_ty, destination_ty) {\n-                self.regioncx.add_outlives(a, b, location.successor_within_block());\n+                self.regioncx.add_outlives(span, a, b, location.successor_within_block());\n             }\n         }\n "}, {"sha": "553d5ad4a320ab687aea1c9d8f6a115b2914f7a2", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 96, "deletions": 23, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd2256f00886b0b9088570040520f800aab2d7/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd2256f00886b0b9088570040520f800aab2d7/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=fdcd2256f00886b0b9088570040520f800aab2d7", "patch": "@@ -17,6 +17,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n use std::collections::BTreeSet;\n use std::fmt;\n+use syntax_pos::Span;\n \n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n@@ -70,10 +71,11 @@ struct Region {\n \n impl fmt::Debug for Region {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        formatter.debug_set()\n-                 .entries(&self.points)\n-                 .entries(&self.free_regions)\n-                 .finish()\n+        formatter\n+            .debug_set()\n+            .entries(&self.points)\n+            .entries(&self.free_regions)\n+            .finish()\n     }\n }\n \n@@ -93,8 +95,16 @@ impl Region {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Constraint {\n-    sub: RegionIndex,\n+    /// Where did this constraint arise?\n+    span: Span,\n+\n+    /// The region SUP must outlive SUB...\n     sup: RegionIndex,\n+\n+    /// Region that must be outlived.\n+    sub: RegionIndex,\n+\n+    /// At this location.\n     point: Location,\n }\n \n@@ -210,56 +220,116 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         let definition = &mut self.definitions[v];\n-        definition.value.add_point(point);\n+        if !definition.constant {\n+            definition.value.add_point(point);\n+        } else {\n+            // Constants are used for free regions, which already\n+            // contain all the points in the control-flow graph.\n+            assert!(definition.value.contains_point(point));\n+        }\n     }\n \n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n-    pub(super) fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n+    pub(super) fn add_outlives(\n+        &mut self,\n+        span: Span,\n+        sup: RegionIndex,\n+        sub: RegionIndex,\n+        point: Location,\n+    ) {\n         debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n-        self.constraints.push(Constraint { sup, sub, point });\n+        self.constraints.push(Constraint {\n+            span,\n+            sup,\n+            sub,\n+            point,\n+        });\n     }\n \n     /// Perform region inference.\n     pub(super) fn solve(&mut self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &Mir<'tcx>) {\n-        self.propagate_constraints(infcx, mir);\n+        let errors = self.propagate_constraints(mir);\n+\n+        // worst error msg ever\n+        for (fr1, span, fr2) in errors {\n+            infcx.tcx.sess.span_err(\n+                span,\n+                &format!(\n+                    \"free region `{}` does not outlive `{}`\",\n+                    self.definitions[fr1].name.unwrap(),\n+                    self.definitions[fr2].name.unwrap()\n+                ),\n+            );\n+        }\n     }\n \n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &Mir<'tcx>) {\n+    fn propagate_constraints(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+    ) -> Vec<(RegionIndex, Span, RegionIndex)> {\n         let mut changed = true;\n-        let mut dfs = Dfs::new(infcx, mir);\n+        let mut dfs = Dfs::new(mir);\n+        let mut error_regions = FxHashSet();\n+        let mut errors = vec![];\n         while changed {\n             changed = false;\n             for constraint in &self.constraints {\n+                debug!(\"constraint: {:?}\", constraint);\n                 let sub = &self.definitions[constraint.sub].value.clone();\n                 let sup_def = &mut self.definitions[constraint.sup];\n-                debug!(\"constraint: {:?}\", constraint);\n+\n                 debug!(\"    sub (before): {:?}\", sub);\n                 debug!(\"    sup (before): {:?}\", sup_def.value);\n \n-                if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n-                    changed = true;\n+                if !sup_def.constant {\n+                    // If this is not a constant, then grow the value as needed to\n+                    // accommodate the outlives constraint.\n+\n+                    if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n+                        changed = true;\n+                    }\n+\n+                    debug!(\"    sup (after) : {:?}\", sup_def.value);\n+                    debug!(\"    changed     : {:?}\", changed);\n+                } else {\n+                    // If this is a constant, check whether it *would\n+                    // have* to grow in order for the constraint to be\n+                    // satisfied. If so, create an error.\n+\n+                    let mut sup_value = sup_def.value.clone();\n+                    if dfs.copy(sub, &mut sup_value, constraint.point) {\n+                        // Constant values start out with the entire\n+                        // CFG, so it must be some new free region\n+                        // that was added. Find one.\n+                        let &new_region = sup_value\n+                            .free_regions\n+                            .difference(&sup_def.value.free_regions)\n+                            .next()\n+                            .unwrap();\n+                        debug!(\"    new_region : {:?}\", new_region);\n+                        if error_regions.insert(constraint.sup) {\n+                            errors.push((constraint.sup, constraint.span, new_region));\n+                        }\n+                    }\n                 }\n-\n-                debug!(\"    sup (after) : {:?}\", sup_def.value);\n-                debug!(\"    changed     : {:?}\", changed);\n             }\n             debug!(\"\\n\");\n         }\n+        errors\n     }\n }\n \n-struct Dfs<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n-    #[allow(dead_code)] infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+struct Dfs<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n-        Self { infcx, mir }\n+impl<'a, 'tcx> Dfs<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>) -> Self {\n+        Self { mir }\n     }\n \n     fn copy(\n@@ -316,7 +386,10 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n                 // over any skolemized end points in the `from_region`\n                 // and make sure they are included in the `to_region`.\n \n-                to_region.free_regions.extend(&from_region.free_regions);\n+                debug!(\"        dfs: free_regions={:?}\", from_region.free_regions);\n+                for &fr in &from_region.free_regions {\n+                    changed |= to_region.free_regions.insert(fr);\n+                }\n             } else {\n                 stack.extend(successor_points);\n             }"}, {"sha": "4a3e838beb34829d4958cfd5c38eb9599003188d", "filename": "src/test/compile-fail/nll/region-error.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53e4bd44dedc6bbff84a5bfe564867362c320f49/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e4bd44dedc6bbff84a5bfe564867362c320f49/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-error.rs?ref=53e4bd44dedc6bbff84a5bfe564867362c320f49", "patch": "@@ -1,5 +0,0 @@\n-fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n-    &*x\n-}\n-\n-fn main() { }"}, {"sha": "539c2017ea6c03ce91acb1c3fae9108064512fdb", "filename": "src/test/ui/nll/named-region-basic.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd2256f00886b0b9088570040520f800aab2d7/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd2256f00886b0b9088570040520f800aab2d7/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.rs?ref=fdcd2256f00886b0b9088570040520f800aab2d7", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for free regions in the NLL code. This test ought to\n+// report an error due to a reborrowing constraint. Right now, we get\n+// a variety of errors from the older, AST-based machinery (notably\n+// borrowck), and then we get the NLL error at the end.\n+\n+// compile-flags:-Znll\n+\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n+    &*x\n+}\n+\n+fn main() { }"}, {"sha": "6b789465670b3d9ff40ada94e556062d5e560d3e", "filename": "src/test/ui/nll/named-region-basic.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd2256f00886b0b9088570040520f800aab2d7/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd2256f00886b0b9088570040520f800aab2d7/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr?ref=fdcd2256f00886b0b9088570040520f800aab2d7", "patch": "@@ -0,0 +1,29 @@\n+warning: not reporting region error due to -Znll: SubSupConflict(AddrOfRegion($DIR/named-region-basic.rs:19:5: 19:8), Reborrow($DIR/named-region-basic.rs:19:5: 19:8), ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:3) => named_region_basic[317d]::foo[0] }, BrNamed(CrateNum(0):DefIndex(1:10), 'b(88))), Reborrow($DIR/named-region-basic.rs:19:5: 19:8), ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:3) => named_region_basic[317d]::foo[0] }, BrNamed(CrateNum(0):DefIndex(1:9), 'a(86))))\n+  --> $DIR/named-region-basic.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error[E0597]: `*x` does not live long enough\n+  --> $DIR/named-region-basic.rs:19:6\n+   |\n+19 |     &*x\n+   |      ^^ does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+note: ...but borrowed value is only valid for the lifetime 'a as defined on the function body at 18:1\n+  --> $DIR/named-region-basic.rs:18:1\n+   |\n+18 | / fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n+19 | |     &*x\n+20 | | }\n+   | |_^\n+\n+error: free region `'a` does not outlive `'b`\n+  --> $DIR/named-region-basic.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}