{"sha": "d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZDdjMmZjZTI4ZjBmZTM5ZWVjMTI5ZmMyOWIwZTc4ZjNmYjIzMTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-29T02:36:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-29T02:36:02Z"}, "message": "Rollup merge of #64824 - Mark-Simulacrum:no-stable-hasher-result-everywhere, r=michaelwoerister\n\nNo StableHasherResult everywhere\n\nThis removes the generic parameter on `StableHasher`, instead moving it to the call to `finish`. This has the side-effect of making all `HashStable` impls nicer, since we no longer need the verbose `<W: StableHasherResult>` that previously existed -- often forcing line wrapping.\n\nThis is done for two reasons:\n * we should avoid false \"generic\" dependency on the result of StableHasher\n     * we don't need to codegen two/three copies of all the HashStable impls when they're transitively used to produce a fingerprint, u64, or u128. I haven't measured, but this might actually make our artifacts somewhat smaller too.\n * Easier to understand/read/write code -- the result of the stable hasher is irrelevant when writing a hash impl.", "tree": {"sha": "90da203e88601999c1dc1e4b5852774f02e51fbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90da203e88601999c1dc1e4b5852774f02e51fbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdkBiSCRBK7hj4Ov3rIwAAdHIIAIHXd7aN3hPZwuqthhAM+FJ1\n8E6AM3MG+cgharqLZawhnrD5TYGceA8QzvIIIx1vlgdt303wZ5ExibeM18QzDaNS\n37g5XMB0AqG7qDQ913ZoIaazbFZuf8Z4bfOSfLFVXXhq0H7lnI2eB2AOD/FXR/LQ\nr2cvu/+5p/fVGCU6eq1pso7InFO/48JLfeQ8qFsAYA0+3KM0ljbKgf/nS8qy1hnL\nV/+edBcTFGhWbctvWDKQ9J+6pbxK/s1q4KbrHjfMjr+q4ob+Tw1s8tUE59Pfk+Tp\njuJ8h83ChRqP/zBiBMDnEBqVQ+/zYufPCz7KBCpvw4qcrUuqZaEiypyLIVy1m7g=\n=aCLI\n-----END PGP SIGNATURE-----\n", "payload": "tree 90da203e88601999c1dc1e4b5852774f02e51fbd\nparent b30d9beafbedb898253a3103ff6afd9f034149f4\nparent 14a5aefb01bb4f18749ab56cd9fd37bf93c86a37\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569724562 +0200\ncommitter GitHub <noreply@github.com> 1569724562 +0200\n\nRollup merge of #64824 - Mark-Simulacrum:no-stable-hasher-result-everywhere, r=michaelwoerister\n\nNo StableHasherResult everywhere\n\nThis removes the generic parameter on `StableHasher`, instead moving it to the call to `finish`. This has the side-effect of making all `HashStable` impls nicer, since we no longer need the verbose `<W: StableHasherResult>` that previously existed -- often forcing line wrapping.\n\nThis is done for two reasons:\n * we should avoid false \"generic\" dependency on the result of StableHasher\n     * we don't need to codegen two/three copies of all the HashStable impls when they're transitively used to produce a fingerprint, u64, or u128. I haven't measured, but this might actually make our artifacts somewhat smaller too.\n * Easier to understand/read/write code -- the result of the stable hasher is irrelevant when writing a hash impl.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "html_url": "https://github.com/rust-lang/rust/commit/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b30d9beafbedb898253a3103ff6afd9f034149f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b30d9beafbedb898253a3103ff6afd9f034149f4", "html_url": "https://github.com/rust-lang/rust/commit/b30d9beafbedb898253a3103ff6afd9f034149f4"}, {"sha": "14a5aefb01bb4f18749ab56cd9fd37bf93c86a37", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a5aefb01bb4f18749ab56cd9fd37bf93c86a37", "html_url": "https://github.com/rust-lang/rust/commit/14a5aefb01bb4f18749ab56cd9fd37bf93c86a37"}], "stats": {"total": 663, "additions": 191, "deletions": 472}, "files": [{"sha": "540d456daf3d39b5879669674a08c202e97e6c08", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -17,7 +17,7 @@ use syntax_pos::Span;\n use std::iter::repeat;\n \n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n@@ -602,9 +602,7 @@ impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n where\n     T: HashStable<StableHashingContext<'hir>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(self.hash_bodies, |hcx| {\n             self.item_like.hash_stable(hcx, hasher);\n         });"}, {"sha": "8cdcf5202fcda3d9b79869c57f4b1c0d63c3700c", "filename": "src/librustc/hir/ptr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -9,8 +9,7 @@ use std::{slice, vec};\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n #[derive(Hash, PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n@@ -133,9 +132,7 @@ impl<T: Decodable> Decodable for P<[T]> {\n impl<CTX, T> HashStable<CTX> for P<T>\n     where T: ?Sized + HashStable<CTX>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "3e6b271b8349754575b72578c7bde5123fd55f59", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::hygiene;\n \n use rustc_data_structures::stable_hasher::{\n-    HashStable, StableHasher, StableHasherResult, ToStableHashKey,\n+    HashStable, StableHasher, ToStableHashKey,\n };\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use smallvec::SmallVec;\n@@ -219,9 +219,7 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {}\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         if hcx.hash_bodies() {\n             hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n         }\n@@ -230,9 +228,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::HirId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n@@ -263,9 +259,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::HirId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n@@ -298,9 +292,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n     /// codepoint offsets. For the purpose of the hash that's sufficient.\n     /// Also, hashing filenames is expensive so we avoid doing it twice when the\n     /// span starts and ends in the same file, which is almost always the case.\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         const TAG_VALID_SPAN: u8 = 0;\n         const TAG_INVALID_SPAN: u8 = 1;\n         const TAG_EXPANSION: u8 = 0;\n@@ -379,24 +371,18 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for DelimSpan {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.open.hash_stable(hcx, hasher);\n         self.close.hash_stable(hcx, hasher);\n     }\n }\n \n-pub fn hash_stable_trait_impls<'a, W>(\n+pub fn hash_stable_trait_impls<'a>(\n     hcx: &mut StableHashingContext<'a>,\n-    hasher: &mut StableHasher<W>,\n+    hasher: &mut StableHasher,\n     blanket_impls: &[DefId],\n     non_blanket_impls: &FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n-) where\n-    W: StableHasherResult,\n-{\n+) {\n     {\n         let mut blanket_impls: SmallVec<[_; 8]> = blanket_impls\n             .iter()"}, {"sha": "c0255e5b8a48165b585d8c381322ac288bf2cbd6", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 20, "deletions": 60, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -6,19 +6,15 @@ use crate::hir::map::DefPathHash;\n use crate::hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n use crate::ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n \n-use rustc_data_structures::stable_hasher::{\n-    HashStable, ToStableHashKey, StableHasher, StableHasherResult,\n-};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n use smallvec::SmallVec;\n use std::mem;\n use syntax::ast;\n use syntax::attr;\n \n impl<'a> HashStable<StableHashingContext<'a>> for DefId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n@@ -34,9 +30,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for DefId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for LocalDefId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.def_path_hash(self.to_def_id()).hash_stable(hcx, hasher);\n     }\n }\n@@ -52,9 +46,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalDefId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for CrateNum {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.def_path_hash(DefId {\n             krate: *self,\n             index: CRATE_DEF_INDEX\n@@ -92,9 +84,7 @@ for hir::ItemLocalId {\n // in \"DefPath Mode\".\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::ItemId {\n             id\n         } = *self;\n@@ -106,9 +96,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::TraitItemId {\n             hir_id\n         } = * self;\n@@ -120,9 +108,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::ImplItemId {\n             hir_id\n         } = * self;\n@@ -138,9 +124,7 @@ impl_stable_hash_for!(struct ast::Label {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n                 hir_id: _,\n@@ -166,9 +150,7 @@ impl_stable_hash_for!(struct hir::Stmt {\n impl_stable_hash_for_spanned!(ast::Name);\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n                 hir_id: _,\n@@ -192,9 +174,7 @@ impl_stable_hash_for!(struct ast::Ident {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::TraitItem {\n             hir_id: _,\n             ident,\n@@ -216,9 +196,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::ImplItem {\n             hir_id: _,\n             ident,\n@@ -248,9 +226,7 @@ impl_stable_hash_for!(enum ast::CrateSugar {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             hir::VisibilityKind::Public |\n@@ -273,9 +249,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n impl_stable_hash_for_spanned!(hir::VisibilityKind);\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Mod {\n             inner: ref inner_span,\n             ref item_ids,\n@@ -305,9 +279,7 @@ impl_stable_hash_for_spanned!(hir::Variant);\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Item {\n             ident,\n             ref attrs,\n@@ -328,9 +300,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Body {\n             params,\n             value,\n@@ -359,9 +329,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n \n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.local_def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n@@ -376,17 +344,13 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let hir::TraitCandidate {\n                 def_id,\n@@ -418,17 +382,13 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n }\n \n impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n     }\n }\n \n impl<'hir> HashStable<StableHashingContext<'hir>> for attr::OptimizeAttr {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "bdcf9e42ac2a88ae5cbeecb77537af5bed3f7fc4", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -16,14 +16,11 @@ use syntax_pos::SourceFile;\n use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use smallvec::SmallVec;\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n \n impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.with(|s| s.hash_stable(hcx, hasher))\n     }\n }\n@@ -41,9 +38,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n }\n@@ -110,9 +105,7 @@ impl_stable_hash_for!(enum ::syntax::edition::Edition {\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for ::syntax::attr::StabilityLevel {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue, ref is_soft } => {\n@@ -172,9 +165,7 @@ impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         if self.len() == 0 {\n             self.len().hash_stable(hcx, hasher);\n             return\n@@ -197,9 +188,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.segments.len().hash_stable(hcx, hasher);\n         for segment in &self.segments {\n             segment.ident.name.hash_stable(hcx, hasher);\n@@ -208,9 +197,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n         debug_assert!(!self.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name)));\n         debug_assert!(!self.is_sugared_doc);\n@@ -235,9 +222,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenTree {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             tokenstream::TokenTree::Token(ref token) => {\n@@ -256,9 +241,7 @@ for tokenstream::TokenTree {\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenStream {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n@@ -285,9 +268,7 @@ impl_stable_hash_for!(struct token::Lit {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for token::TokenKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             token::Eq |\n@@ -426,9 +407,7 @@ impl_stable_hash_for!(enum ::syntax_pos::FileName {\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let SourceFile {\n             name: _, // We hash the smaller name_hash instead of this\n             name_hash,\n@@ -502,11 +481,7 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for feature_gate::Features {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'tcx>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         // Unfortunately we cannot exhaustively list fields here, since the\n         // struct is macro generated.\n         self.declared_lang_features.hash_stable(hcx, hasher);"}, {"sha": "c643baf11254c8178a9edee5d39e41edbc755576", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 15, "deletions": 52, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -3,8 +3,7 @@\n \n use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n use std::cell::RefCell;\n use std::mem;\n use crate::middle::region;\n@@ -15,9 +14,7 @@ impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for &'tcx ty::List<T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<(usize, usize), Fingerprint>> =\n                 RefCell::new(Default::default());\n@@ -57,18 +54,14 @@ where\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArg<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.unpack().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             ty::ReErased |\n@@ -112,31 +105,21 @@ for ty::RegionKind {\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::ConstVid<'tcx> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.index.hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for ty::BoundVar {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'tcx>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n@@ -145,20 +128,14 @@ impl<'a, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.skip_binder().hash_stable(hcx, hasher);\n     }\n }\n \n // AllocIds get resolved to whatever they point to (to be stable)\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n@@ -174,11 +151,7 @@ for mir::interpret::Relocations<Tag>\n where\n     Tag: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.len().hash_stable(hcx, hasher);\n         for reloc in self.iter() {\n             reloc.hash_stable(hcx, hasher);\n@@ -201,29 +174,23 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::TyVid {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _hcx: &mut StableHashingContext<'a>,\n-                                          _hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _hcx: &mut StableHashingContext<'a>, _hasher: &mut StableHasher) {\n         // `TyVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a TyVid {:?}.\", *self)\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::IntVid {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _hcx: &mut StableHashingContext<'a>,\n-                                          _hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _hcx: &mut StableHashingContext<'a>, _hasher: &mut StableHasher) {\n         // `IntVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash an IntVid {:?}.\", *self)\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::FloatVid {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _hcx: &mut StableHashingContext<'a>,\n-                                          _hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _hcx: &mut StableHashingContext<'a>, _hasher: &mut StableHasher) {\n         // `FloatVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a FloatVid {:?}.\", *self)\n@@ -234,18 +201,14 @@ impl<'a, T> HashStable<StableHashingContext<'a>> for ty::steal::Steal<T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.borrow().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for crate::middle::privacy::AccessLevels {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let crate::middle::privacy::AccessLevels {\n                 ref map"}, {"sha": "28afe9730a0344659660e1f28d35e3e078af549d", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -8,8 +8,7 @@ use crate::lint::{self, Lint, LintId, Level, LintSource};\n use crate::session::Session;\n use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey, StableHasher};\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n@@ -526,9 +525,7 @@ impl LintLevelMap {\n \n impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let LintLevelMap {\n             ref sets,\n             ref id_to_set,\n@@ -567,9 +564,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n \n impl<HCX> HashStable<HCX> for LintId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         self.lint_name_raw().hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "256a08d7e90c34dcaef83589afa345ba8fa9b036", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -97,9 +97,9 @@ macro_rules! impl_stable_hash_for {\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n-            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+            fn hash_stable(&self,\n+                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n+                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n                 use $enum_path::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n \n@@ -128,9 +128,9 @@ macro_rules! impl_stable_hash_for {\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n-            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+            fn hash_stable(&self,\n+                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n+                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n                 let $struct_name {\n                     $(ref $field),*\n                 } = *self;\n@@ -153,9 +153,9 @@ macro_rules! impl_stable_hash_for {\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n-            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+            fn hash_stable(&self,\n+                           __ctx: &mut $crate::ich::StableHashingContext<'a>,\n+                           __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n                 let $struct_name (\n                     $(ref $field),*\n                 ) = *self;\n@@ -173,9 +173,9 @@ macro_rules! impl_stable_hash_for_spanned {\n         impl HashStable<StableHashingContext<'a>> for ::syntax::source_map::Spanned<$T>\n         {\n             #[inline]\n-            fn hash_stable<W: StableHasherResult>(&self,\n-                                                  hcx: &mut StableHashingContext<'a>,\n-                                                  hasher: &mut StableHasher<W>) {\n+            fn hash_stable(&self,\n+                           hcx: &mut StableHashingContext<'a>,\n+                           hasher: &mut StableHasher) {\n                 self.node.hash_stable(hcx, hasher);\n                 self.span.hash_stable(hcx, hasher);\n             }"}, {"sha": "4d14299751c3d177ade6f19f3381fb8092806c04", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -1,7 +1,6 @@\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::cmp;\n use std::mem;\n use crate::ty::{self, TyCtxt};\n@@ -94,9 +93,7 @@ pub fn metadata_symbol_name(tcx: TyCtxt<'_>) -> String {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ExportedSymbol<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             ExportedSymbol::NonGeneric(def_id) => {"}, {"sha": "05e4d11c3f99004432beed9521899c3f28a843fe", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -17,7 +17,7 @@ use crate::ty::{self, DefIdTree, TyCtxt};\n use crate::ty::query::Providers;\n \n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -1491,9 +1491,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ScopeTree {\n             root_body,\n             root_parent,"}, {"sha": "d8d3383903d4b5c93843e0db724984ffab573548", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::{RwLock, MappedReadGuard, ReadGuard};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use crate::ich::StableHashingContext;\n use crate::mir::{Body, BasicBlock};\n@@ -24,9 +24,7 @@ impl rustc_serialize::Decodable for Cache {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a>,\n-                                          _: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n         // Do nothing.\n     }\n }"}, {"sha": "5e12c4dfe75a53f0da7022d8ba85a9d20acc3671", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -682,14 +682,10 @@ impl_stable_hash_for!(enum self::MirPhase {\n \n mod binding_form_impl {\n     use crate::ich::StableHashingContext;\n-    use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+    use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n     impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for super::BindingForm<'tcx> {\n-        fn hash_stable<W: StableHasherResult>(\n-            &self,\n-            hcx: &mut StableHashingContext<'a>,\n-            hasher: &mut StableHasher<W>,\n-        ) {\n+        fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n             use super::BindingForm::*;\n             ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n "}, {"sha": "313b2a5d50a305784df2deacd9fdc395c99b42ec", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -8,8 +8,7 @@ use crate::util::nodemap::FxHashMap;\n use crate::ty::print::obsolete::DefPathBasedNames;\n use crate::dep_graph::{WorkProductId, DepNode, WorkProduct, DepConstructor};\n use rustc_data_structures::base_n;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n-                                           StableHasher};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n use crate::session::config::OptLevel;\n use std::fmt;\n@@ -223,9 +222,7 @@ impl<'tcx> MonoItem<'tcx> {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                           hcx: &mut StableHashingContext<'a>,\n-                                           hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n@@ -419,9 +416,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                           hcx: &mut StableHashingContext<'a>,\n-                                           hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let CodegenUnit {\n             ref items,\n             name,"}, {"sha": "eee084b78963cf1cfb27b8425b063ca846001493", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -7,8 +7,7 @@ use crate::traits::query::NoSolution;\n use crate::ty::{self, Ty, TyCtxt};\n \n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use std::mem;\n \n /// Outlives bounds are relationships between generic parameters,\n@@ -43,9 +42,7 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             OutlivesBound::RegionSubRegion(ref a, ref b) => {"}, {"sha": "43f558d64430e2f94e50c67510da7ae0c4db690f", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -2,8 +2,7 @@ use super::OverlapError;\n \n use crate::hir::def_id::DefId;\n use crate::ich::{self, StableHashingContext};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use crate::traits;\n use crate::ty::{self, TyCtxt, TypeFoldable};\n use crate::ty::fast_reject::{self, SimplifiedType};\n@@ -512,9 +511,7 @@ pub fn ancestors(\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Children {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let Children {\n             ref nonblanket_impls,\n             ref blanket_impls,"}, {"sha": "6c5d9a6dfdf22b73d92408a86c549f0157c61ec2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -50,7 +50,7 @@ use errors::DiagnosticBuilder;\n use arena::SyncDroplessArena;\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{\n-    HashStable, StableHasher, StableHasherResult, StableVec, hash_stable_hashmap,\n+    HashStable, StableHasher, StableVec, hash_stable_hashmap,\n };\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sharded::ShardedHashMap;\n@@ -705,9 +705,7 @@ impl<'tcx> TypeckTables<'tcx> {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TypeckTables {\n             local_id_root,\n             ref type_dependent_defs,"}, {"sha": "038b54f1f26dd0e57912c8b46d76d4b8a05db408", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -1,7 +1,6 @@\n use crate::hir::def_id::DefId;\n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n@@ -158,9 +157,7 @@ impl<'a, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n where\n     D: Copy + Debug + Ord + Eq + Hash + HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             BoolSimplifiedType |"}, {"sha": "6ab4f4c6112f779b23b2da2f8ab331aa48595a02", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -19,8 +19,7 @@ use crate::ty::GeneratorSubsts;\n use crate::ty::subst::Subst;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n pub use rustc_target::abi::*;\n use rustc_target::spec::{HasTargetSpec, abi::Abi as SpecAbi};\n@@ -2323,9 +2322,7 @@ where\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::Variants::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2349,9 +2346,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for DiscriminantKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::DiscriminantKind::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2372,9 +2367,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for DiscriminantKind {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::FieldPlacement::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2395,19 +2388,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for VariantIdx {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.as_u32().hash_stable(hcx, hasher)\n     }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::Abi::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -2432,9 +2419,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let Scalar { value, ref valid_range } = *self;\n         value.hash_stable(hcx, hasher);\n         valid_range.start().hash_stable(hcx, hasher);\n@@ -2476,29 +2461,19 @@ impl_stable_hash_for!(struct crate::ty::layout::AbiAndPrefAlign {\n });\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for Align {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'tcx>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         self.bytes().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx> HashStable<StableHashingContext<'tcx>> for Size {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'tcx>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         self.bytes().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::LayoutError::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n "}, {"sha": "731aca854a4227a4e7944d1a84fd7f843d0fd7aa", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -52,8 +52,7 @@ use syntax_pos::Span;\n use smallvec;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n \n use crate::hir;\n \n@@ -577,9 +576,7 @@ impl<'tcx> TyS<'tcx> {\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TyS {\n             ref kind,\n \n@@ -1633,11 +1630,7 @@ impl<'a, T> HashStable<StableHashingContext<'a>> for Placeholder<T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.universe.hash_stable(hcx, hasher);\n         self.name.hash_stable(hcx, hasher);\n     }\n@@ -1774,9 +1767,7 @@ impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'tcx, T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ParamEnvAnd {\n             ref param_env,\n             ref value\n@@ -2010,9 +2001,7 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<usize, Fingerprint>> = Default::default();\n         }"}, {"sha": "391ea762a083b003f3b71442b9694e2599aeb75b", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -334,13 +334,13 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n     let mut hcx = tcx.create_stable_hashing_context();\n     queries.iter().min_by_key(|v| {\n         let (span, query) = f(v);\n-        let mut stable_hasher = StableHasher::<u64>::new();\n+        let mut stable_hasher = StableHasher::new();\n         query.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n         // Prefer entry points which have valid spans for nicer error messages\n         // We add an integer to the tuple ensuring that entry points\n         // with valid spans are picked first\n         let span_cmp = if span == DUMMY_SP { 1 } else { 0 };\n-        (span_cmp, stable_hasher.finish())\n+        (span_cmp, stable_hasher.finish::<u64>())\n     }).unwrap()\n }\n "}, {"sha": "32858d30b0cc4e4e50bbfdff9d47054fbdc6571a", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -720,7 +720,6 @@ macro_rules! define_queries_inner {\n         use rustc_data_structures::sharded::Sharded;\n         use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n-            rustc_data_structures::stable_hasher::StableHasherResult,\n             rustc_data_structures::stable_hasher::StableHasher,\n             ich::StableHashingContext\n         };\n@@ -929,9 +928,7 @@ macro_rules! define_queries_inner {\n         }\n \n         impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n-            fn hash_stable<W: StableHasherResult>(&self,\n-                                                hcx: &mut StableHashingContext<'a>,\n-                                                hasher: &mut StableHasher<W>) {\n+            fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n                 mem::discriminant(self).hash_stable(hcx, hasher);\n                 match *self {\n                     $(Query::$name(key) => key.hash_stable(hcx, hasher),)*"}, {"sha": "49ec908231548de6f6b6e123a7814323f6b52304", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -8,8 +8,7 @@ use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ty, TyCtxt};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n \n /// A trait's definition with type information.\n@@ -194,9 +193,7 @@ pub(super) fn trait_impls_of_provider(\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for TraitImpls {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let TraitImpls {\n             ref blanket_impls,\n             ref non_blanket_impls,"}, {"sha": "544d6794e2191988524d4267374f7c82b793f671", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -187,15 +187,15 @@ impl TypeMap<'ll, 'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-        let mut hasher = StableHasher::<Fingerprint>::new();\n+        let mut hasher = StableHasher::new();\n         let mut hcx = cx.tcx.create_stable_hashing_context();\n         let type_ = cx.tcx.erase_regions(&type_);\n         hcx.while_hashing_spans(false, |hcx| {\n             hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                 type_.hash_stable(hcx, &mut hasher);\n             });\n         });\n-        let unique_type_id = hasher.finish().to_hex();\n+        let unique_type_id = hasher.finish::<Fingerprint>().to_hex();\n \n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));"}, {"sha": "e3aa35ef4eb5e5f5b16925cdf8405b4fb9503950", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -109,14 +109,11 @@ pub enum TypeKind {\n //            for now we content ourselves with providing a no-op HashStable\n //            implementation for CGUs.\n mod temp_stable_hash_impls {\n-    use rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher,\n-                                               HashStable};\n+    use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n     use crate::ModuleCodegen;\n \n     impl<HCX, M> HashStable<HCX> for ModuleCodegen<M> {\n-        fn hash_stable<W: StableHasherResult>(&self,\n-                                              _: &mut HCX,\n-                                              _: &mut StableHasher<W>) {\n+        fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n             // do nothing\n         }\n     }"}, {"sha": "a9866c8c0b28225ea5532493266f4bd04dd46d7b", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -89,7 +89,7 @@ fn get_symbol_hash<'tcx>(\n         def_id, substs\n     );\n \n-    let mut hasher = StableHasher::<u64>::new();\n+    let mut hasher = StableHasher::new();\n     let mut hcx = tcx.create_stable_hashing_context();\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n@@ -132,7 +132,7 @@ fn get_symbol_hash<'tcx>(\n     });\n \n     // 64 bits should be enough to avoid collisions.\n-    hasher.finish()\n+    hasher.finish::<u64>()\n }\n \n // Follow C++ namespace-mangling style, see"}, {"sha": "b43df6045d6aa03b8ab5ffee337766701dcbe2bc", "filename": "src/librustc_data_structures/fingerprint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffingerprint.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -76,7 +76,7 @@ impl ::std::fmt::Display for Fingerprint {\n \n impl stable_hasher::StableHasherResult for Fingerprint {\n     #[inline]\n-    fn finish(hasher: stable_hasher::StableHasher<Self>) -> Self {\n+    fn finish(hasher: stable_hasher::StableHasher) -> Self {\n         let (_0, _1) = hasher.finalize();\n         Fingerprint(_0, _1)\n     }"}, {"sha": "53dff794ff0ae6893c28f40c1455a15cbf523a0a", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 45, "deletions": 113, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -1,5 +1,4 @@\n use std::hash::{Hash, Hasher, BuildHasher};\n-use std::marker::PhantomData;\n use std::mem;\n use smallvec::SmallVec;\n use crate::sip128::SipHasher128;\n@@ -13,55 +12,53 @@ use crate::bit_set;\n /// To that end we always convert integers to little-endian format before\n /// hashing and the architecture dependent `isize` and `usize` types are\n /// extended to 64 bits if needed.\n-pub struct StableHasher<W> {\n+pub struct StableHasher {\n     state: SipHasher128,\n-    width: PhantomData<W>,\n }\n \n-impl<W: StableHasherResult> ::std::fmt::Debug for StableHasher<W> {\n+impl ::std::fmt::Debug for StableHasher {\n     fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n         write!(f, \"{:?}\", self.state)\n     }\n }\n \n pub trait StableHasherResult: Sized {\n-    fn finish(hasher: StableHasher<Self>) -> Self;\n+    fn finish(hasher: StableHasher) -> Self;\n }\n \n-impl<W: StableHasherResult> StableHasher<W> {\n+impl StableHasher {\n     pub fn new() -> Self {\n         StableHasher {\n             state: SipHasher128::new_with_keys(0, 0),\n-            width: PhantomData,\n         }\n     }\n \n-    pub fn finish(self) -> W {\n+    pub fn finish<W: StableHasherResult>(self) -> W {\n         W::finish(self)\n     }\n }\n \n impl StableHasherResult for u128 {\n-    fn finish(hasher: StableHasher<Self>) -> Self {\n+    fn finish(hasher: StableHasher) -> Self {\n         let (_0, _1) = hasher.finalize();\n         u128::from(_0) | (u128::from(_1) << 64)\n     }\n }\n \n impl StableHasherResult for u64 {\n-    fn finish(hasher: StableHasher<Self>) -> Self {\n+    fn finish(hasher: StableHasher) -> Self {\n         hasher.finalize().0\n     }\n }\n \n-impl<W> StableHasher<W> {\n+impl StableHasher {\n     #[inline]\n     pub fn finalize(self) -> (u64, u64) {\n         self.state.finish128()\n     }\n }\n \n-impl<W> Hasher for StableHasher<W> {\n+impl Hasher for StableHasher {\n     fn finish(&self) -> u64 {\n         panic!(\"use StableHasher::finalize instead\");\n     }\n@@ -165,9 +162,7 @@ impl<W> Hasher for StableHasher<W> {\n ///   `StableHasher` takes care of endianness and `isize`/`usize` platform\n ///   differences.\n pub trait HashStable<CTX> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>);\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher);\n }\n \n /// Implement this for types that can be turned into stable keys like, for\n@@ -185,10 +180,10 @@ macro_rules! impl_stable_hash_via_hash {\n     ($t:ty) => (\n         impl<CTX> $crate::stable_hasher::HashStable<CTX> for $t {\n             #[inline]\n-            fn hash_stable<W: $crate::stable_hasher::StableHasherResult>(\n+            fn hash_stable(\n                 &self,\n                 _: &mut CTX,\n-                hasher: &mut $crate::stable_hasher::StableHasher<W>\n+                hasher: &mut $crate::stable_hasher::StableHasher\n             ) {\n                 ::std::hash::Hash::hash(self, hasher);\n             }\n@@ -215,17 +210,13 @@ impl_stable_hash_via_hash!(char);\n impl_stable_hash_via_hash!(());\n \n impl<CTX> HashStable<CTX> for ::std::num::NonZeroU32 {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.get().hash_stable(ctx, hasher)\n     }\n }\n \n impl<CTX> HashStable<CTX> for f32 {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let val: u32 = unsafe {\n             ::std::mem::transmute(*self)\n         };\n@@ -234,9 +225,7 @@ impl<CTX> HashStable<CTX> for f32 {\n }\n \n impl<CTX> HashStable<CTX> for f64 {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let val: u64 = unsafe {\n             ::std::mem::transmute(*self)\n         };\n@@ -245,26 +234,20 @@ impl<CTX> HashStable<CTX> for f64 {\n }\n \n impl<CTX> HashStable<CTX> for ::std::cmp::Ordering {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (*self as i8).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T1: HashStable<CTX>, CTX> HashStable<CTX> for (T1,) {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let (ref _0,) = *self;\n         _0.hash_stable(ctx, hasher);\n     }\n }\n \n impl<T1: HashStable<CTX>, T2: HashStable<CTX>, CTX> HashStable<CTX> for (T1, T2) {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let (ref _0, ref _1) = *self;\n         _0.hash_stable(ctx, hasher);\n         _1.hash_stable(ctx, hasher);\n@@ -276,9 +259,7 @@ impl<T1, T2, T3, CTX> HashStable<CTX> for (T1, T2, T3)\n            T2: HashStable<CTX>,\n            T3: HashStable<CTX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let (ref _0, ref _1, ref _2) = *self;\n         _0.hash_stable(ctx, hasher);\n         _1.hash_stable(ctx, hasher);\n@@ -292,9 +273,7 @@ impl<T1, T2, T3, T4, CTX> HashStable<CTX> for (T1, T2, T3, T4)\n            T3: HashStable<CTX>,\n            T4: HashStable<CTX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         let (ref _0, ref _1, ref _2, ref _3) = *self;\n         _0.hash_stable(ctx, hasher);\n         _1.hash_stable(ctx, hasher);\n@@ -304,9 +283,7 @@ impl<T1, T2, T3, T4, CTX> HashStable<CTX> for (T1, T2, T3, T4)\n }\n \n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n-    default fn hash_stable<W: StableHasherResult>(&self,\n-                                                  ctx: &mut CTX,\n-                                                  hasher: &mut StableHasher<W>) {\n+    default fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash_stable(ctx, hasher);\n         for item in self {\n             item.hash_stable(ctx, hasher);\n@@ -316,9 +293,7 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n \n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (&self[..]).hash_stable(ctx, hasher);\n     }\n }\n@@ -329,9 +304,7 @@ impl<K, V, R, CTX> HashStable<CTX> for indexmap::IndexMap<K, V, R>\n           R: BuildHasher,\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash_stable(ctx, hasher);\n         for kv in self {\n             kv.hash_stable(ctx, hasher);\n@@ -344,9 +317,7 @@ impl<K, R, CTX> HashStable<CTX> for indexmap::IndexSet<K, R>\n           R: BuildHasher,\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash_stable(ctx, hasher);\n         for key in self {\n             key.hash_stable(ctx, hasher);\n@@ -356,45 +327,35 @@ impl<K, R, CTX> HashStable<CTX> for indexmap::IndexSet<K, R>\n \n impl<A, CTX> HashStable<CTX> for SmallVec<[A; 1]> where A: HashStable<CTX> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (&self[..]).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for Box<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for ::std::rc::Rc<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for ::std::sync::Arc<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(ctx, hasher);\n     }\n }\n \n impl<CTX> HashStable<CTX> for str {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash(hasher);\n         self.as_bytes().hash(hasher);\n     }\n@@ -403,9 +364,7 @@ impl<CTX> HashStable<CTX> for str {\n \n impl<CTX> HashStable<CTX> for String {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n@@ -420,9 +379,7 @@ impl<HCX> ToStableHashKey<HCX> for String {\n \n impl<CTX> HashStable<CTX> for bool {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (if *self { 1u8 } else { 0u8 }).hash_stable(ctx, hasher);\n     }\n }\n@@ -432,9 +389,7 @@ impl<T, CTX> HashStable<CTX> for Option<T>\n     where T: HashStable<CTX>\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         if let Some(ref value) = *self {\n             1u8.hash_stable(ctx, hasher);\n             value.hash_stable(ctx, hasher);\n@@ -449,9 +404,7 @@ impl<T1, T2, CTX> HashStable<CTX> for Result<T1, T2>\n           T2: HashStable<CTX>,\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(ctx, hasher);\n         match *self {\n             Ok(ref x) => x.hash_stable(ctx, hasher),\n@@ -464,28 +417,22 @@ impl<'a, T, CTX> HashStable<CTX> for &'a T\n     where T: HashStable<CTX> + ?Sized\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(ctx, hasher);\n     }\n }\n \n impl<T, CTX> HashStable<CTX> for ::std::mem::Discriminant<T> {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, _: &mut CTX, hasher: &mut StableHasher) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n \n impl<I: indexed_vec::Idx, T, CTX> HashStable<CTX> for indexed_vec::IndexVec<I, T>\n     where T: HashStable<CTX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.len().hash_stable(ctx, hasher);\n         for v in &self.raw {\n             v.hash_stable(ctx, hasher);\n@@ -496,19 +443,15 @@ impl<I: indexed_vec::Idx, T, CTX> HashStable<CTX> for indexed_vec::IndexVec<I, T\n \n impl<I: indexed_vec::Idx, CTX> HashStable<CTX> for bit_set::BitSet<I>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.words().hash_stable(ctx, hasher);\n     }\n }\n \n impl<R: indexed_vec::Idx, C: indexed_vec::Idx, CTX> HashStable<CTX>\n for bit_set::BitMatrix<R, C>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.words().hash_stable(ctx, hasher);\n     }\n }\n@@ -522,9 +465,7 @@ impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n           R: BuildHasher,\n {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         hash_stable_hashmap(hcx, hasher, self, ToStableHashKey::to_stable_hash_key);\n     }\n }\n@@ -533,9 +474,7 @@ impl<K, R, HCX> HashStable<HCX> for ::std::collections::HashSet<K, R>\n     where K: ToStableHashKey<HCX> + Eq + Hash,\n           R: BuildHasher,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         let mut keys: Vec<_> = self.iter()\n                                    .map(|k| k.to_stable_hash_key(hcx))\n                                    .collect();\n@@ -548,9 +487,7 @@ impl<K, V, HCX> HashStable<HCX> for ::std::collections::BTreeMap<K, V>\n     where K: ToStableHashKey<HCX>,\n           V: HashStable<HCX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         let mut entries: Vec<_> = self.iter()\n                                       .map(|(k, v)| (k.to_stable_hash_key(hcx), v))\n                                       .collect();\n@@ -562,9 +499,7 @@ impl<K, V, HCX> HashStable<HCX> for ::std::collections::BTreeMap<K, V>\n impl<K, HCX> HashStable<HCX> for ::std::collections::BTreeSet<K>\n     where K: ToStableHashKey<HCX>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         let mut keys: Vec<_> = self.iter()\n                                    .map(|k| k.to_stable_hash_key(hcx))\n                                    .collect();\n@@ -573,17 +508,16 @@ impl<K, HCX> HashStable<HCX> for ::std::collections::BTreeSet<K>\n     }\n }\n \n-pub fn hash_stable_hashmap<HCX, K, V, R, SK, F, W>(\n+pub fn hash_stable_hashmap<HCX, K, V, R, SK, F>(\n     hcx: &mut HCX,\n-    hasher: &mut StableHasher<W>,\n+    hasher: &mut StableHasher,\n     map: &::std::collections::HashMap<K, V, R>,\n     to_stable_hash_key: F)\n     where K: Eq + Hash,\n           V: HashStable<HCX>,\n           R: BuildHasher,\n           SK: HashStable<HCX> + Ord + Clone,\n           F: Fn(&K, &HCX) -> SK,\n-          W: StableHasherResult,\n {\n     let mut entries: Vec<_> = map.iter()\n                                   .map(|(k, v)| (to_stable_hash_key(k, hcx), v))\n@@ -614,9 +548,7 @@ impl<T> ::std::ops::Deref for StableVec<T> {\n impl<T, HCX> HashStable<HCX> for StableVec<T>\n     where T: HashStable<HCX> + ToStableHashKey<HCX>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         let StableVec(ref v) = *self;\n \n         let mut sorted: Vec<_> = v.iter()"}, {"sha": "64042264d794f02d62d22145cf7f3dfd3053ff0d", "filename": "src/librustc_data_structures/svh.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsvh.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -61,11 +61,7 @@ impl Decodable for Svh {\n \n impl<T> stable_hasher::HashStable<T> for Svh {\n     #[inline]\n-    fn hash_stable<W: stable_hasher::StableHasherResult>(\n-        &self,\n-        ctx: &mut T,\n-        hasher: &mut stable_hasher::StableHasher<W>\n-    ) {\n+    fn hash_stable(&self, ctx: &mut T, hasher: &mut stable_hasher::StableHasher) {\n         let Svh {\n             hash\n         } = *self;"}, {"sha": "93a8b7f525fffff540afb00792b30ed6819fc9b7", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -1,4 +1,4 @@\n-use crate::stable_hasher::{StableHasher, StableHasherResult, HashStable};\n+use crate::stable_hasher::{StableHasher, HashStable};\n \n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n@@ -60,9 +60,7 @@ impl<T> Extend<T> for ThinVec<T> {\n }\n \n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ThinVec<T> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(hcx, hasher)\n     }\n }"}, {"sha": "9c5447f3f5a44a406162267ab8d0aab3de61a038", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -1,6 +1,6 @@\n use crate::bit_set::BitMatrix;\n use crate::fx::FxHashMap;\n-use crate::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use crate::stable_hasher::{HashStable, StableHasher};\n use crate::sync::Lock;\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::fmt::Debug;\n@@ -442,9 +442,7 @@ impl<T> Decodable for TransitiveRelation<T>\n impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n     where T: HashStable<CTX> + Eq + Debug + Clone + Hash\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         // We are assuming here that the relation graph has been built in a\n         // deterministic way and we can just hash it the way it is.\n         let TransitiveRelation {\n@@ -462,9 +460,7 @@ impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n }\n \n impl<CTX> HashStable<CTX> for Edge {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         let Edge {\n             ref source,\n             ref target,\n@@ -476,9 +472,7 @@ impl<CTX> HashStable<CTX> for Edge {\n }\n \n impl<CTX> HashStable<CTX> for Index {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         let Index(idx) = *self;\n         idx.hash_stable(hcx, hasher);\n     }"}, {"sha": "e73195fbb8c2da9abc2e88eedccee02c1397a728", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -502,7 +502,7 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n     // into various other hashes quite a bit (symbol hashes, incr. comp. hashes,\n     // debuginfo type IDs, etc), so we don't want it to be too wide. 128 bits\n     // should still be safe enough to avoid collisions in practice.\n-    let mut hasher = StableHasher::<Fingerprint>::new();\n+    let mut hasher = StableHasher::new();\n \n     let mut metadata = session.opts.cg.metadata.clone();\n     // We don't want the crate_disambiguator to dependent on the order\n@@ -528,7 +528,7 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n         .contains(&config::CrateType::Executable);\n     hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n \n-    CrateDisambiguator::from(hasher.finish())\n+    CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n }\n \n pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {"}, {"sha": "a708f3191dcf84e4bb427a107542e3a0b8992b96", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -76,10 +76,10 @@ pub fn hash_stable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::To\n \n     s.bound_impl(quote!(::rustc_data_structures::stable_hasher::HashStable\n                         <::rustc::ich::StableHashingContext<'__ctx>>), quote!{\n-        fn hash_stable<__W: ::rustc_data_structures::stable_hasher::StableHasherResult>(\n+        fn hash_stable(\n             &self,\n             __hcx: &mut ::rustc::ich::StableHashingContext<'__ctx>,\n-            __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<__W>) {\n+            __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher) {\n             #discriminant\n             match *self { #body }\n         }"}, {"sha": "9beeacbe72d80199e5ad0ca202102b465f3f0413", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -368,9 +368,9 @@ impl<'tcx> EncodeContext<'tcx> {\n                         let mut adapted = (**source_file).clone();\n                         adapted.name = Path::new(&working_dir).join(name).into();\n                         adapted.name_hash = {\n-                            let mut hasher: StableHasher<u128> = StableHasher::new();\n+                            let mut hasher: StableHasher = StableHasher::new();\n                             adapted.name.hash(&mut hasher);\n-                            hasher.finish()\n+                            hasher.finish::<u128>()\n                         };\n                         Lrc::new(adapted)\n                     },"}, {"sha": "4c7d0dcb697211d72e0227299793664b2fc1f43d", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -52,9 +52,9 @@ impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, ()> {\n         // Compute stack's hash before copying anything\n         let mut hcx = tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::<u64>::new();\n+        let mut hasher = StableHasher::new();\n         stack.hash_stable(&mut hcx, &mut hasher);\n-        let hash = hasher.finish();\n+        let hash = hasher.finish::<u64>();\n \n         // Check if we know that hash already\n         if self.hashes.is_empty() {\n@@ -428,9 +428,9 @@ impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n         let mut hcx = self.memory.tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::<u64>::new();\n+        let mut hasher = StableHasher::new();\n         self.hash_stable(&mut hcx, &mut hasher);\n-        hasher.finish().hash(state)\n+        hasher.finish::<u64>().hash(state)\n     }\n }\n "}, {"sha": "7300ce249548b3afccb03f285dfd5ef91ce6e72b", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -33,8 +33,7 @@ use std::{slice, vec};\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n #[derive(Hash, PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n@@ -218,9 +217,7 @@ impl<T: Decodable> Decodable for P<[T]> {\n impl<CTX, T> HashStable<CTX> for P<T>\n     where T: ?Sized + HashStable<CTX>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "674f17de618e9e6d517511ce2f582fa5f586b537", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=d7d7c2fce28f0fe39eec129fc29b0e78f3fb2317", "patch": "@@ -1067,14 +1067,14 @@ impl SourceFile {\n         normalize_newlines(&mut src);\n \n         let src_hash = {\n-            let mut hasher: StableHasher<u128> = StableHasher::new();\n+            let mut hasher: StableHasher = StableHasher::new();\n             hasher.write(src.as_bytes());\n-            hasher.finish()\n+            hasher.finish::<u128>()\n         };\n         let name_hash = {\n-            let mut hasher: StableHasher<u128> = StableHasher::new();\n+            let mut hasher: StableHasher = StableHasher::new();\n             name.hash(&mut hasher);\n-            hasher.finish()\n+            hasher.finish::<u128>()\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n         if end_pos > u32::max_value() as usize {\n@@ -1120,10 +1120,10 @@ impl SourceFile {\n             // Check that no-one else have provided the source while we were getting it\n             if *external_src == ExternalSource::AbsentOk {\n                 if let Some(src) = src {\n-                    let mut hasher: StableHasher<u128> = StableHasher::new();\n+                    let mut hasher: StableHasher = StableHasher::new();\n                     hasher.write(src.as_bytes());\n \n-                    if hasher.finish() == self.src_hash {\n+                    if hasher.finish::<u128>() == self.src_hash {\n                         *external_src = ExternalSource::Present(src);\n                         return true;\n                     }"}]}