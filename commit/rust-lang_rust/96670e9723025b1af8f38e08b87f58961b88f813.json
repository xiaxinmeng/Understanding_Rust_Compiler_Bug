{"sha": "96670e9723025b1af8f38e08b87f58961b88f813", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NjcwZTk3MjMwMjViMWFmOGYzOGUwOGI4N2Y1ODk2MWI4OGY4MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-21T16:46:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-21T16:46:27Z"}, "message": "auto merge of #14320 : kballard/rust/fix_stdlib_inject_attrs, r=alexcrichton\n\nThe #[phase(syntax,link)] attribute on `extern crate std` needs to be an\r\nouter attribute so it can pretty-print properly.\r\n\r\nAlso add `#![no_std]` and `#[feature(phase)]` so compiling the\r\npretty-printed source will work.", "tree": {"sha": "6d5f531f8eae35459d783eb10e70f613d2d0905d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d5f531f8eae35459d783eb10e70f613d2d0905d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96670e9723025b1af8f38e08b87f58961b88f813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96670e9723025b1af8f38e08b87f58961b88f813", "html_url": "https://github.com/rust-lang/rust/commit/96670e9723025b1af8f38e08b87f58961b88f813", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96670e9723025b1af8f38e08b87f58961b88f813/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "803e92de89def55197244269a5d1feffa00c93d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/803e92de89def55197244269a5d1feffa00c93d9", "html_url": "https://github.com/rust-lang/rust/commit/803e92de89def55197244269a5d1feffa00c93d9"}, {"sha": "23ca66ecd2e10d0c6de2e3a657f58f6db35d0a9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/23ca66ecd2e10d0c6de2e3a657f58f6db35d0a9a", "html_url": "https://github.com/rust-lang/rust/commit/23ca66ecd2e10d0c6de2e3a657f58f6db35d0a9a"}], "stats": {"total": 76, "additions": 48, "deletions": 28}, "files": [{"sha": "92bd81a40f2460017a1807becff4424a6a469235", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=96670e9723025b1af8f38e08b87f58961b88f813", "patch": "@@ -22,6 +22,8 @@ use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::util::small_vector::SmallVector;\n \n+use std::mem;\n+\n pub static VERSION: &'static str = \"0.11.0-pre\";\n \n pub fn maybe_inject_crates_ref(sess: &Session, krate: ast::Crate)\n@@ -70,13 +72,13 @@ pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n }\n \n impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n-    fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n+    fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let mut vis = vec!(ast::ViewItem {\n             node: ast::ViewItemExternCrate(token::str_to_ident(\"std\"),\n                                          with_version(\"std\"),\n                                          ast::DUMMY_NODE_ID),\n             attrs: vec!(\n-                attr::mk_attr(attr::mk_list_item(\n+                attr::mk_attr_outer(attr::mk_list_item(\n                         InternedString::new(\"phase\"),\n                         vec!(\n                             attr::mk_word_item(InternedString::new(\"syntax\")),\n@@ -101,16 +103,20 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n         }\n \n         // `extern crate` must be precede `use` items\n-        vis.push_all_move(krate.module.view_items.clone());\n-        let new_module = ast::Mod {\n-            view_items: vis,\n-            ..krate.module.clone()\n-        };\n+        mem::swap(&mut vis, &mut krate.module.view_items);\n+        krate.module.view_items.push_all_move(vis);\n \n-        ast::Crate {\n-            module: new_module,\n-            ..krate\n-        }\n+        // don't add #![no_std] here, that will block the prelude injection later.\n+        // Add it during the prelude injection instead.\n+\n+        // Add #![feature(phase)] here, because we use #[phase] on extern crate std.\n+        let feat_phase_attr = attr::mk_attr_inner(attr::mk_list_item(\n+                                  InternedString::new(\"feature\"),\n+                                  vec![attr::mk_word_item(InternedString::new(\"phase\"))],\n+                              ));\n+        krate.attrs.push(feat_phase_attr);\n+\n+        krate\n     }\n }\n \n@@ -127,29 +133,29 @@ struct PreludeInjector<'a> {\n \n \n impl<'a> fold::Folder for PreludeInjector<'a> {\n-    fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n+    fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n+        // Add #![no_std] here, so we don't re-inject when compiling pretty-printed source.\n+        // This must happen here and not in StandardLibraryInjector because this\n+        // fold happens second.\n+\n+        let no_std_attr = attr::mk_attr_inner(attr::mk_word_item(InternedString::new(\"no_std\")));\n+        krate.attrs.push(no_std_attr);\n+\n         if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#![no_implicit_prelude]` at the crate level.\n \n-            let mut attrs = krate.attrs.clone();\n-\n             // fold_mod() will insert glob path.\n-            let globs_attr = attr::mk_attr(attr::mk_list_item(\n+            let globs_attr = attr::mk_attr_inner(attr::mk_list_item(\n                 InternedString::new(\"feature\"),\n                 vec!(\n                     attr::mk_word_item(InternedString::new(\"globs\")),\n                 )));\n-            attrs.push(globs_attr);\n+            krate.attrs.push(globs_attr);\n \n-            ast::Crate {\n-                module: self.fold_mod(&krate.module),\n-                attrs: attrs,\n-                ..krate\n-            }\n-        } else {\n-            krate\n+            krate.module = self.fold_mod(&krate.module);\n         }\n+        krate\n     }\n \n     fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {"}, {"sha": "0ebd392e582fd9d7da939dba410247552480578a", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=96670e9723025b1af8f38e08b87f58961b88f813", "patch": "@@ -341,7 +341,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_str = InternedString::new(\"!resolve_unexported\");\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(resolve_unexported_str));\n+        attr::mk_attr_inner(attr::mk_word_item(resolve_unexported_str));\n \n     let item = ast::Item {\n         ident: token::str_to_ident(\"__test\"),"}, {"sha": "2e478419e77a92508994de825fd580f8de5faede", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=96670e9723025b1af8f38e08b87f58961b88f813", "patch": "@@ -1436,7 +1436,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n     fn synthesize_crateid_attr(ecx: &EncodeContext) -> Attribute {\n         assert!(!ecx.link_meta.crateid.name.is_empty());\n \n-        attr::mk_attr(\n+        attr::mk_attr_inner(\n             attr::mk_name_value_item_str(\n                 InternedString::new(\"crate_id\"),\n                 token::intern_and_get_ident(ecx.link_meta.crateid.to_str())))"}, {"sha": "fc5fcd98ef6f4d8c65b0544ee06e96c9e506fa8c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=96670e9723025b1af8f38e08b87f58961b88f813", "patch": "@@ -232,7 +232,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n \n     let f = decl_rust_fn(ccx, false, inputs, output, name);\n     csearch::get_item_attrs(&ccx.sess().cstore, did, |meta_items| {\n-        set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x))\n+        set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr_outer(x))\n                                     .collect::<Vec<_>>().as_slice(), f)\n     });\n "}, {"sha": "5a57c2d6cc62d684039becea2a631da5834e1551", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96670e9723025b1af8f38e08b87f58961b88f813/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=96670e9723025b1af8f38e08b87f58961b88f813", "patch": "@@ -126,7 +126,11 @@ impl AttributeMethods for Attribute {\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(strip_doc_comment_decoration(\n                         comment.get()).as_slice()));\n-            mk_attr(meta)\n+            if self.node.style == ast::AttrOuter {\n+                mk_attr_outer(meta)\n+            } else {\n+                mk_attr_inner(meta)\n+            }\n         } else {\n             *self\n         }\n@@ -154,14 +158,24 @@ pub fn mk_word_item(name: InternedString) -> @MetaItem {\n     @dummy_spanned(MetaWord(name))\n }\n \n-pub fn mk_attr(item: @MetaItem) -> Attribute {\n+/// Returns an inner attribute with the given value.\n+pub fn mk_attr_inner(item: @MetaItem) -> Attribute {\n     dummy_spanned(Attribute_ {\n         style: ast::AttrInner,\n         value: item,\n         is_sugared_doc: false,\n     })\n }\n \n+/// Returns an outer attribute with the given value.\n+pub fn mk_attr_outer(item: @MetaItem) -> Attribute {\n+    dummy_spanned(Attribute_ {\n+        style: ast::AttrOuter,\n+        value: item,\n+        is_sugared_doc: false,\n+    })\n+}\n+\n pub fn mk_sugared_doc_attr(text: InternedString, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n     let style = doc_comment_style(text.get());"}]}