{"sha": "fd6b5376b723e22e3d98542e2e693d2717700900", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNmI1Mzc2YjcyM2UyMmUzZDk4NTQyZTJlNjkzZDI3MTc3MDA5MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-27T22:34:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-27T22:34:59Z"}, "message": "Auto merge of #79284 - Nadrieril:constructor-module, r=varkor\n\nSplit match exhaustiveness into two files\n\nI feel the constructor-related things in the `_match` module make enough sense on their own so I split them off. It makes `_match` feel less like a complicated mess. I'm not aware of PRs in progress against this module apart from my own so hopefully I'm not annoying too many people.\nI have a lot of questions about the conventions in naming and modules around the compiler. Like, why is the module named `_match`? Could I rename it to `usefulness` maybe? Should `deconstruct_pat` be a submodule of `_match` since only `_match` uses it? Is it ok to move big piles of code around even if it makes git blame more difficult?\n\nr? `@varkor`\n`@rustbot` modify labels: +A-exhaustiveness-checking", "tree": {"sha": "462f3e93b54fb4f045e34612e90531585a2985e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/462f3e93b54fb4f045e34612e90531585a2985e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd6b5376b723e22e3d98542e2e693d2717700900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6b5376b723e22e3d98542e2e693d2717700900", "html_url": "https://github.com/rust-lang/rust/commit/fd6b5376b723e22e3d98542e2e693d2717700900", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd6b5376b723e22e3d98542e2e693d2717700900/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a889570e46c03d7b156ec08f3f4cb4d145924a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a889570e46c03d7b156ec08f3f4cb4d145924a3", "html_url": "https://github.com/rust-lang/rust/commit/6a889570e46c03d7b156ec08f3f4cb4d145924a3"}, {"sha": "941c6ac1a26b6cc572279b0ac22d89fefb63c086", "url": "https://api.github.com/repos/rust-lang/rust/commits/941c6ac1a26b6cc572279b0ac22d89fefb63c086", "html_url": "https://github.com/rust-lang/rust/commit/941c6ac1a26b6cc572279b0ac22d89fefb63c086"}], "stats": {"total": 3449, "additions": 1737, "deletions": 1712}, "files": [{"sha": "97edbd83b89cece6bcc8654445c785c376ee8dc3", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd6b5376b723e22e3d98542e2e693d2717700900/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6b5376b723e22e3d98542e2e693d2717700900/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=fd6b5376b723e22e3d98542e2e693d2717700900", "patch": "@@ -1,5 +1,5 @@\n-use super::_match::Usefulness::*;\n-use super::_match::{\n+use super::usefulness::Usefulness::*;\n+use super::usefulness::{\n     compute_match_usefulness, expand_pattern, MatchArm, MatchCheckCtxt, UsefulnessReport,\n };\n use super::{PatCtxt, PatKind, PatternError};"}, {"sha": "62b4468eeb3549dbfd8b89d901429d01be7169af", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "renamed", "additions": 741, "deletions": 1709, "changes": 2450, "blob_url": "https://github.com/rust-lang/rust/blob/fd6b5376b723e22e3d98542e2e693d2717700900/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6b5376b723e22e3d98542e2e693d2717700900/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=fd6b5376b723e22e3d98542e2e693d2717700900", "previous_filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs"}, {"sha": "7e9a3a37278b7641544cdd2085ed41e0a73ddb61", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd6b5376b723e22e3d98542e2e693d2717700900/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6b5376b723e22e3d98542e2e693d2717700900/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=fd6b5376b723e22e3d98542e2e693d2717700900", "patch": "@@ -1,8 +1,9 @@\n //! Validation of patterns/matches.\n \n-mod _match;\n mod check_match;\n mod const_to_pat;\n+mod deconstruct_pat;\n+mod usefulness;\n \n pub(crate) use self::check_match::check_match;\n "}, {"sha": "be96d5ae816849d5f6840f3d3e7af2ec832d9e59", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "added", "additions": 992, "deletions": 0, "changes": 992, "blob_url": "https://github.com/rust-lang/rust/blob/fd6b5376b723e22e3d98542e2e693d2717700900/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6b5376b723e22e3d98542e2e693d2717700900/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=fd6b5376b723e22e3d98542e2e693d2717700900", "patch": "@@ -0,0 +1,992 @@\n+//! Note: tests specific to this file can be found in:\n+//!\n+//!   - `ui/pattern/usefulness`\n+//!   - `ui/or-patterns`\n+//!   - `ui/consts/const_in_pattern`\n+//!   - `ui/rfc-2008-non-exhaustive`\n+//!   - `ui/half-open-range-patterns`\n+//!   - probably many others\n+//!\n+//! I (Nadrieril) prefer to put new tests in `ui/pattern/usefulness` unless there's a specific\n+//! reason not to, for example if they depend on a particular feature like `or_patterns`.\n+//!\n+//! -----\n+//!\n+//! This file includes the logic for exhaustiveness and usefulness checking for\n+//! pattern-matching. Specifically, given a list of patterns for a type, we can\n+//! tell whether:\n+//! (a) the patterns cover every possible constructor for the type (exhaustiveness)\n+//! (b) each pattern is necessary (usefulness)\n+//!\n+//! The algorithm implemented here is a modified version of the one described in\n+//! [this paper](http://moscova.inria.fr/~maranget/papers/warn/index.html).\n+//! However, to save future implementors from reading the original paper, we\n+//! summarise the algorithm here to hopefully save time and be a little clearer\n+//! (without being so rigorous).\n+//!\n+//! # Premise\n+//!\n+//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n+//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n+//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n+//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n+//! uncovered values of the type).\n+//!\n+//! If we have this predicate, then we can easily compute both exhaustiveness of an\n+//! entire set of patterns and the individual usefulness of each one.\n+//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n+//! match doesn't increase the number of values we're matching)\n+//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n+//! pattern to those that have come before it doesn't increase the number of values\n+//! we're matching).\n+//!\n+//! # Core concept\n+//!\n+//! The idea that powers everything that is done in this file is the following: a value is made\n+//! from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n+//! (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n+//! constructor for the number `2`). Fields are just a (possibly empty) list of values.\n+//!\n+//! Some of the constructors listed above might feel weird: `None` and `2` don't take any\n+//! arguments. This is part of what makes constructors so general: we will consider plain values\n+//! like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n+//! constructors\"; they are the simplest case of constructors. This allows us to see any value as\n+//! made up from a tree of constructors, each having a given number of children. For example:\n+//! `(None, Ok(0))` is made from 4 different constructors.\n+//!\n+//! This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n+//! describe this set using constructors. For example, `Err(_)` captures all values of the type\n+//! `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n+//! wildcard `_` captures all values of the given type starting with any of the constructors for\n+//! that type.\n+//!\n+//! We use this to compute whether different patterns might capture a same value. Do the patterns\n+//! `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n+//! captures only values starting with the `Ok` constructor and the second only values starting\n+//! with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n+//! since they both capture values starting with `Some`. To be certain, we need to dig under the\n+//! `Some` constructor and continue asking the question. This is the main idea behind the\n+//! exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n+//! figure out if some new pattern might capture a value that hadn't been captured by previous\n+//! patterns.\n+//!\n+//! Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n+//! Most of the complexity of this file resides in transforming between patterns and\n+//! (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n+//!\n+//! Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n+//! a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n+//! However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n+//!\n+//!\n+//! # Algorithm\n+//!\n+//! Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n+//! adding a new pattern `p` will cover previously-uncovered values of the type.\n+//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n+//! but rather partially-deconstructed patterns in the form of a list of fields. The paper\n+//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n+//! new pattern `p`.\n+//!\n+//! For example, say we have the following:\n+//!\n+//! ```\n+//! // x: (Option<bool>, Result<()>)\n+//! match x {\n+//!     (Some(true), _) => {}\n+//!     (None, Err(())) => {}\n+//!     (None, Err(_)) => {}\n+//! }\n+//! ```\n+//!\n+//! Here, the matrix `P` starts as:\n+//!\n+//! ```\n+//! [\n+//!     [(Some(true), _)],\n+//!     [(None, Err(()))],\n+//!     [(None, Err(_))],\n+//! ]\n+//! ```\n+//!\n+//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n+//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n+//! all the values it covers are already covered by row 2.\n+//!\n+//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n+//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n+//! To match the paper, the top of the stack is at the beginning / on the left.\n+//!\n+//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n+//!\n+//! 1. We can pop a given constructor off the top of a stack. This operation is called\n+//!    `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!    `None`) and `p` a pattern-stack.\n+//!    If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!    pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!    Otherwise the pattern-stack is discarded.\n+//!    This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!    discards the others.\n+//!\n+//!    For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!    pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!    `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!    nothing back.\n+//!\n+//!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!    on top of the stack, and we have four cases:\n+//!\n+//!      1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!           push onto the stack the arguments of this constructor, and return the result:\n+//!              `r_1, .., r_a, p_2, .., p_n`\n+//!\n+//!      1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!           return nothing.\n+//!\n+//!         1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!              arguments (its arity), and return the resulting stack:\n+//!                 `_, .., _, p_2, .., p_n`\n+//!\n+//!         1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!              stack:\n+//!                 - `S(c, (r_1, p_2, .., p_n))`\n+//!                 - `S(c, (r_2, p_2, .., p_n))`\n+//!\n+//! 2. We can pop a wildcard off the top of the stack. This is called `S(_, p)`, where `p` is\n+//!    a pattern-stack. Note: the paper calls this `D(p)`.\n+//!    This is used when we know there are missing constructor cases, but there might be\n+//!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!    all its *other* components.\n+//!\n+//!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!    and we have three cases:\n+//!         2.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!         2.2. `p_1 = _`. We return the rest of the stack:\n+//!                 p_2, .., p_n\n+//!         2.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!           stack.\n+//!                 - `S(_, (r_1, p_2, .., p_n))`\n+//!                 - `S(_, (r_2, p_2, .., p_n))`\n+//!\n+//! Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//! exhaustive integer matching rules, so they're written here for posterity.\n+//!\n+//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n+//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n+//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n+//!\n+//!\n+//! The algorithm for computing `U`\n+//! -------------------------------\n+//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n+//! That means we're going to check the components from left-to-right, so the algorithm\n+//! operates principally on the first component of the matrix and new pattern-stack `p`.\n+//! This algorithm is realised in the `is_useful` function.\n+//!\n+//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n+//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n+//!       then `U(P, p)` is false.\n+//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//!\n+//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n+//!                  [which may then be expanded into further columns later])\n+//! We're going to match on the top of the new pattern-stack, `p_1`.\n+//!     - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//! Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//! we ignore all the patterns in the first column of `P` that involve other constructors.\n+//! This is where `S(c, P)` comes in:\n+//! `U(P, p) := U(S(c, P), S(c, p))`\n+//!\n+//! For example, if `P` is:\n+//!\n+//! ```\n+//! [\n+//!     [Some(true), _],\n+//!     [None, 0],\n+//! ]\n+//! ```\n+//!\n+//! and `p` is `[Some(false), 0]`, then we don't care about row 2 since we know `p` only\n+//! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//! arguments of `Some` to know whether some new value is covered. So we compute\n+//! `U([[true, _]], [false, 0])`.\n+//!\n+//!   - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+//! component of the rows of `P`:\n+//!   + If there are some constructors that aren't present, then we might think that the\n+//! wildcard `_` is useful, since it covers those constructors that weren't covered\n+//! before.\n+//! That's almost correct, but only works if there were no wildcards in those first\n+//! components. So we need to check that `p` is useful with respect to the rows that\n+//! start with a wildcard, if there are any. This is where `S(_, x)` comes in:\n+//! `U(P, p) := U(S(_, P), S(_, p))`\n+//!\n+//! For example, if `P` is:\n+//!\n+//! ```\n+//! [\n+//!     [_, true, _],\n+//!     [None, false, 1],\n+//! ]\n+//! ```\n+//!\n+//! and `p` is `[_, false, _]`, the `Some` constructor doesn't appear in `P`. So if we\n+//! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//!\n+//!   + Otherwise, all possible constructors (for the relevant type) are present. In this\n+//! case we must check whether the wildcard pattern covers any unmatched value. For\n+//! that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//! possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//! example. The wildcard pattern is useful in this case if it is useful when\n+//! specialized to one of the possible constructors. So we compute:\n+//! `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!\n+//! For example, if `P` is:\n+//!\n+//! ```\n+//! [\n+//!     [Some(true), _],\n+//!     [None, false],\n+//! ]\n+//! ```\n+//!\n+//! and `p` is `[_, false]`, both `None` and `Some` constructors appear in the first\n+//! components of `P`. We will therefore try popping both constructors in turn: we\n+//! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n+//! [false])` for the `None` constructor. The first case returns true, so we know that\n+//! `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//! before.\n+//!\n+//!   - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+//! `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!  || U(P, (r_2, p_2, .., p_n))`\n+//!\n+//! Modifications to the algorithm\n+//! ------------------------------\n+//! The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n+//! example uninhabited types and variable-length slice patterns. These are drawn attention to\n+//! throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n+//! accounted for, though.\n+//!\n+//! Exhaustive integer matching\n+//! ---------------------------\n+//! An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n+//! So to support exhaustive integer matching, we can make use of the logic in the paper for\n+//! OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n+//! they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n+//! that we have a constructor *of* constructors (the integers themselves). We then need to work\n+//! through all the inductive step rules above, deriving how the ranges would be treated as\n+//! OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n+//! There are really only four special cases here:\n+//! - When we match on a constructor that's actually a range, we have to treat it as if we would\n+//!   an OR-pattern.\n+//!     + It turns out that we can simply extend the case for single-value patterns in\n+//!      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n+//!      constructor.\n+//!     + When the pattern itself is a range, you just want to tell whether any of the values in\n+//!       the pattern range coincide with values in the constructor range, which is precisely\n+//!       intersection.\n+//!   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n+//!   means that whenever the constructor is a value/range and the pattern is also a value/range,\n+//!   we can simply use intersection to test usefulness.\n+//! - When we're testing for usefulness of a pattern and the pattern's first component is a\n+//!   wildcard.\n+//!     + If all the constructors appear in the matrix, we have a slight complication. By default,\n+//!       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n+//!       invalid, because we want a disjunction over every *integer* in each range, not just a\n+//!       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n+//!       to form equivalence classes of subranges of the constructor range for which the behaviour\n+//!       of the matrix `P` and new pattern `p` are the same. This is described in more\n+//!       detail in `Constructor::split`.\n+//!     + If some constructors are missing from the matrix, it turns out we don't need to do\n+//!       anything special (because we know none of the integers are actually wildcards: i.e., we\n+//!       can't span wildcards using ranges).\n+\n+use self::Usefulness::*;\n+use self::WitnessPreference::*;\n+\n+use super::deconstruct_pat::{Constructor, Fields, MissingConstructors};\n+use super::{Pat, PatKind};\n+use super::{PatternFoldable, PatternFolder};\n+\n+use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::OnceCell;\n+\n+use rustc_arena::TypedArena;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::Span;\n+\n+use smallvec::{smallvec, SmallVec};\n+use std::fmt;\n+use std::iter::{FromIterator, IntoIterator};\n+\n+crate struct MatchCheckCtxt<'a, 'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n+    /// The module in which the match occurs. This is necessary for\n+    /// checking inhabited-ness of types because whether a type is (visibly)\n+    /// inhabited can depend on whether it was defined in the current module or\n+    /// not. E.g., `struct Foo { _private: ! }` cannot be seen to be empty\n+    /// outside its module and should not be matchable with an empty match statement.\n+    crate module: DefId,\n+    crate param_env: ty::ParamEnv<'tcx>,\n+    crate pattern_arena: &'a TypedArena<Pat<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n+    pub(super) fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n+        if self.tcx.features().exhaustive_patterns {\n+            self.tcx.is_ty_uninhabited_from(self.module, ty, self.param_env)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n+    pub(super) fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.kind() {\n+            ty::Adt(def, ..) => {\n+                def.is_enum() && def.is_variant_list_non_exhaustive() && !def.did.is_local()\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub(super) struct PatCtxt<'a, 'p, 'tcx> {\n+    pub(super) cx: &'a MatchCheckCtxt<'p, 'tcx>,\n+    /// Current state of the matrix.\n+    pub(super) matrix: &'a Matrix<'p, 'tcx>,\n+    /// Type of the current column under investigation.\n+    pub(super) ty: Ty<'tcx>,\n+    /// Span of the current pattern under investigation.\n+    pub(super) span: Span,\n+    /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n+    /// subpattern.\n+    pub(super) is_top_level: bool,\n+}\n+\n+crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n+    LiteralExpander.fold_pattern(&pat)\n+}\n+\n+struct LiteralExpander;\n+\n+impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n+    fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n+        debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n+        match (pat.ty.kind(), pat.kind.as_ref()) {\n+            (_, PatKind::Binding { subpattern: Some(s), .. }) => s.fold_with(self),\n+            (_, PatKind::AscribeUserType { subpattern: s, .. }) => s.fold_with(self),\n+            (ty::Ref(_, t, _), PatKind::Constant { .. }) if t.is_str() => {\n+                // Treat string literal patterns as deref patterns to a `str` constant, i.e.\n+                // `&CONST`. This expands them like other const patterns. This could have been done\n+                // in `const_to_pat`, but that causes issues with the rest of the matching code.\n+                let mut new_pat = pat.super_fold_with(self);\n+                // Make a fake const pattern of type `str` (instead of `&str`). That the carried\n+                // constant value still knows it is of type `&str`.\n+                new_pat.ty = t;\n+                Pat {\n+                    kind: Box::new(PatKind::Deref { subpattern: new_pat }),\n+                    span: pat.span,\n+                    ty: pat.ty,\n+                }\n+            }\n+            _ => pat.super_fold_with(self),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Pat<'tcx> {\n+    pub(super) fn is_wildcard(&self) -> bool {\n+        matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n+    }\n+}\n+\n+/// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n+/// works well.\n+#[derive(Debug, Clone)]\n+struct PatStack<'p, 'tcx> {\n+    pats: SmallVec<[&'p Pat<'tcx>; 2]>,\n+    /// Cache for the constructor of the head\n+    head_ctor: OnceCell<Constructor<'tcx>>,\n+}\n+\n+impl<'p, 'tcx> PatStack<'p, 'tcx> {\n+    fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n+        Self::from_vec(smallvec![pat])\n+    }\n+\n+    fn from_vec(vec: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n+        PatStack { pats: vec, head_ctor: OnceCell::new() }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.pats.is_empty()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.pats.len()\n+    }\n+\n+    fn head(&self) -> &'p Pat<'tcx> {\n+        self.pats[0]\n+    }\n+\n+    fn head_ctor<'a>(&'a self, cx: &MatchCheckCtxt<'p, 'tcx>) -> &'a Constructor<'tcx> {\n+        self.head_ctor.get_or_init(|| Constructor::from_pat(cx, self.head()))\n+    }\n+\n+    fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n+        self.pats.iter().copied()\n+    }\n+\n+    // If the first pattern is an or-pattern, expand this pattern. Otherwise, return `None`.\n+    fn expand_or_pat(&self) -> Option<Vec<Self>> {\n+        if self.is_empty() {\n+            None\n+        } else if let PatKind::Or { pats } = &*self.head().kind {\n+            Some(\n+                pats.iter()\n+                    .map(|pat| {\n+                        let mut new_patstack = PatStack::from_pattern(pat);\n+                        new_patstack.pats.extend_from_slice(&self.pats[1..]);\n+                        new_patstack\n+                    })\n+                    .collect(),\n+            )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// This computes `S(self.head_ctor(), self)`. See top of the file for explanations.\n+    ///\n+    /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n+    /// fields filled with wild patterns.\n+    ///\n+    /// This is roughly the inverse of `Constructor::apply`.\n+    fn pop_head_constructor(&self, ctor_wild_subpatterns: &Fields<'p, 'tcx>) -> PatStack<'p, 'tcx> {\n+        // We pop the head pattern and push the new fields extracted from the arguments of\n+        // `self.head()`.\n+        let mut new_fields =\n+            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head()).filtered_patterns();\n+        new_fields.extend_from_slice(&self.pats[1..]);\n+        PatStack::from_vec(new_fields)\n+    }\n+}\n+\n+impl<'p, 'tcx> Default for PatStack<'p, 'tcx> {\n+    fn default() -> Self {\n+        Self::from_vec(smallvec![])\n+    }\n+}\n+\n+impl<'p, 'tcx> PartialEq for PatStack<'p, 'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.pats == other.pats\n+    }\n+}\n+\n+impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n+    fn from_iter<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<Item = &'p Pat<'tcx>>,\n+    {\n+        Self::from_vec(iter.into_iter().collect())\n+    }\n+}\n+\n+/// A 2D matrix.\n+#[derive(Clone, PartialEq)]\n+pub(super) struct Matrix<'p, 'tcx> {\n+    patterns: Vec<PatStack<'p, 'tcx>>,\n+}\n+\n+impl<'p, 'tcx> Matrix<'p, 'tcx> {\n+    fn empty() -> Self {\n+        Matrix { patterns: vec![] }\n+    }\n+\n+    /// Number of columns of this matrix. `None` is the matrix is empty.\n+    pub(super) fn column_count(&self) -> Option<usize> {\n+        self.patterns.get(0).map(|r| r.len())\n+    }\n+\n+    /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n+    fn push(&mut self, row: PatStack<'p, 'tcx>) {\n+        if let Some(rows) = row.expand_or_pat() {\n+            for row in rows {\n+                // We recursively expand the or-patterns of the new rows.\n+                // This is necessary as we might have `0 | (1 | 2)` or e.g., `x @ 0 | x @ (1 | 2)`.\n+                self.push(row)\n+            }\n+        } else {\n+            self.patterns.push(row);\n+        }\n+    }\n+\n+    /// Iterate over the first component of each row\n+    fn heads<'a>(&'a self) -> impl Iterator<Item = &'a Pat<'tcx>> + Captures<'p> {\n+        self.patterns.iter().map(|r| r.head())\n+    }\n+\n+    /// Iterate over the first constructor of each row\n+    pub(super) fn head_ctors<'a>(\n+        &'a self,\n+        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n+    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'a> + Captures<'p> {\n+        self.patterns.iter().map(move |r| r.head_ctor(cx))\n+    }\n+\n+    /// This computes `S(constructor, self)`. See top of the file for explanations.\n+    fn specialize_constructor(\n+        &self,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        ctor: &Constructor<'tcx>,\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+    ) -> Matrix<'p, 'tcx> {\n+        self.patterns\n+            .iter()\n+            .filter(|r| ctor.is_covered_by(pcx, r.head_ctor(pcx.cx)))\n+            .map(|r| r.pop_head_constructor(ctor_wild_subpatterns))\n+            .collect()\n+    }\n+}\n+\n+/// Pretty-printer for matrices of patterns, example:\n+///\n+/// ```text\n+/// +++++++++++++++++++++++++++++\n+/// + _     + []                +\n+/// +++++++++++++++++++++++++++++\n+/// + true  + [First]           +\n+/// +++++++++++++++++++++++++++++\n+/// + true  + [Second(true)]    +\n+/// +++++++++++++++++++++++++++++\n+/// + false + [_]               +\n+/// +++++++++++++++++++++++++++++\n+/// + _     + [_, _, tail @ ..] +\n+/// +++++++++++++++++++++++++++++\n+/// ```\n+impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"\\n\")?;\n+\n+        let Matrix { patterns: m, .. } = self;\n+        let pretty_printed_matrix: Vec<Vec<String>> =\n+            m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n+\n+        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n+        assert!(m.iter().all(|row| row.len() == column_count));\n+        let column_widths: Vec<usize> = (0..column_count)\n+            .map(|col| pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0))\n+            .collect();\n+\n+        let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n+        let br = \"+\".repeat(total_width);\n+        write!(f, \"{}\\n\", br)?;\n+        for row in pretty_printed_matrix {\n+            write!(f, \"+\")?;\n+            for (column, pat_str) in row.into_iter().enumerate() {\n+                write!(f, \" \")?;\n+                write!(f, \"{:1$}\", pat_str, column_widths[column])?;\n+                write!(f, \" +\")?;\n+            }\n+            write!(f, \"\\n\")?;\n+            write!(f, \"{}\\n\", br)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n+    fn from_iter<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<Item = PatStack<'p, 'tcx>>,\n+    {\n+        let mut matrix = Matrix::empty();\n+        for x in iter {\n+            // Using `push` ensures we correctly expand or-patterns.\n+            matrix.push(x);\n+        }\n+        matrix\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+crate enum Usefulness<'tcx> {\n+    /// Carries, for each column in the matrix, a set of sub-branches that have been found to be\n+    /// unreachable. Used only in the presence of or-patterns, otherwise it stays empty.\n+    Useful(Vec<FxHashSet<Span>>),\n+    /// Carries a list of witnesses of non-exhaustiveness.\n+    UsefulWithWitness(Vec<Witness<'tcx>>),\n+    NotUseful,\n+}\n+\n+impl<'tcx> Usefulness<'tcx> {\n+    fn new_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n+            LeaveOutWitness => Useful(vec![]),\n+        }\n+    }\n+\n+    fn is_useful(&self) -> bool {\n+        !matches!(*self, NotUseful)\n+    }\n+\n+    fn apply_constructor<'p>(\n+        self,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        ctor: &Constructor<'tcx>,\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+    ) -> Self {\n+        match self {\n+            UsefulWithWitness(witnesses) => {\n+                let new_witnesses = if ctor.is_wildcard() {\n+                    let missing_ctors = MissingConstructors::new(pcx);\n+                    let new_patterns = missing_ctors.report_patterns(pcx);\n+                    witnesses\n+                        .into_iter()\n+                        .flat_map(|witness| {\n+                            new_patterns.iter().map(move |pat| {\n+                                let mut witness = witness.clone();\n+                                witness.0.push(pat.clone());\n+                                witness\n+                            })\n+                        })\n+                        .collect()\n+                } else {\n+                    witnesses\n+                        .into_iter()\n+                        .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n+                        .collect()\n+                };\n+                UsefulWithWitness(new_witnesses)\n+            }\n+            Useful(mut unreachables) => {\n+                if !unreachables.is_empty() {\n+                    // When we apply a constructor, there are `arity` columns of the matrix that\n+                    // corresponded to its arguments. All the unreachables found in these columns\n+                    // will, after `apply`, come from the first column. So we take the union of all\n+                    // the corresponding sets and put them in the first column.\n+                    // Note that `arity` may be 0, in which case we just push a new empty set.\n+                    let len = unreachables.len();\n+                    let arity = ctor_wild_subpatterns.len();\n+                    let mut unioned = FxHashSet::default();\n+                    for set in unreachables.drain((len - arity)..) {\n+                        unioned.extend(set)\n+                    }\n+                    unreachables.push(unioned);\n+                }\n+                Useful(unreachables)\n+            }\n+            x => x,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum WitnessPreference {\n+    ConstructWitness,\n+    LeaveOutWitness,\n+}\n+\n+/// A witness of non-exhaustiveness for error reporting, represented\n+/// as a list of patterns (in reverse order of construction) with\n+/// wildcards inside to represent elements that can take any inhabitant\n+/// of the type as a value.\n+///\n+/// A witness against a list of patterns should have the same types\n+/// and length as the pattern matched against. Because Rust `match`\n+/// is always against a single pattern, at the end the witness will\n+/// have length 1, but in the middle of the algorithm, it can contain\n+/// multiple patterns.\n+///\n+/// For example, if we are constructing a witness for the match against\n+///\n+/// ```\n+/// struct Pair(Option<(u32, u32)>, bool);\n+///\n+/// match (p: Pair) {\n+///    Pair(None, _) => {}\n+///    Pair(_, false) => {}\n+/// }\n+/// ```\n+///\n+/// We'll perform the following steps:\n+/// 1. Start with an empty witness\n+///     `Witness(vec![])`\n+/// 2. Push a witness `Some(_)` against the `None`\n+///     `Witness(vec![Some(_)])`\n+/// 3. Push a witness `true` against the `false`\n+///     `Witness(vec![Some(_), true])`\n+/// 4. Apply the `Pair` constructor to the witnesses\n+///     `Witness(vec![Pair(Some(_), true)])`\n+///\n+/// The final `Pair(Some(_), true)` is then the resulting witness.\n+#[derive(Clone, Debug)]\n+crate struct Witness<'tcx>(Vec<Pat<'tcx>>);\n+\n+impl<'tcx> Witness<'tcx> {\n+    /// Asserts that the witness contains a single pattern, and returns it.\n+    fn single_pattern(self) -> Pat<'tcx> {\n+        assert_eq!(self.0.len(), 1);\n+        self.0.into_iter().next().unwrap()\n+    }\n+\n+    /// Constructs a partial witness for a pattern given a list of\n+    /// patterns expanded by the specialization step.\n+    ///\n+    /// When a pattern P is discovered to be useful, this function is used bottom-up\n+    /// to reconstruct a complete witness, e.g., a pattern P' that covers a subset\n+    /// of values, V, where each value in that set is not covered by any previously\n+    /// used patterns and is covered by the pattern P'. Examples:\n+    ///\n+    /// left_ty: tuple of 3 elements\n+    /// pats: [10, 20, _]           => (10, 20, _)\n+    ///\n+    /// left_ty: struct X { a: (bool, &'static str), b: usize}\n+    /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n+    fn apply_constructor<'p>(\n+        mut self,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        ctor: &Constructor<'tcx>,\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+    ) -> Self {\n+        let pat = {\n+            let len = self.0.len();\n+            let arity = ctor_wild_subpatterns.len();\n+            let pats = self.0.drain((len - arity)..).rev();\n+            ctor_wild_subpatterns.replace_fields(pcx.cx, pats).apply(pcx, ctor)\n+        };\n+\n+        self.0.push(pat);\n+\n+        self\n+    }\n+}\n+\n+/// Algorithm from <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n+/// The algorithm from the paper has been modified to correctly handle empty\n+/// types. The changes are:\n+///   (0) We don't exit early if the pattern matrix has zero rows. We just\n+///       continue to recurse over columns.\n+///   (1) all_constructors will only return constructors that are statically\n+///       possible. E.g., it will only return `Ok` for `Result<T, !>`.\n+///\n+/// This finds whether a (row) vector `v` of patterns is 'useful' in relation\n+/// to a set of such vectors `m` - this is defined as there being a set of\n+/// inputs that will match `v` but not any of the sets in `m`.\n+///\n+/// All the patterns at each column of the `matrix ++ v` matrix must have the same type.\n+///\n+/// This is used both for reachability checking (if a pattern isn't useful in\n+/// relation to preceding patterns, it is not reachable) and exhaustiveness\n+/// checking (if a wildcard pattern is useful in relation to a matrix, the\n+/// matrix isn't exhaustive).\n+///\n+/// `is_under_guard` is used to inform if the pattern has a guard. If it\n+/// has one it must not be inserted into the matrix. This shouldn't be\n+/// relied on for soundness.\n+fn is_useful<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n+    v: &PatStack<'p, 'tcx>,\n+    witness_preference: WitnessPreference,\n+    hir_id: HirId,\n+    is_under_guard: bool,\n+    is_top_level: bool,\n+) -> Usefulness<'tcx> {\n+    let Matrix { patterns: rows, .. } = matrix;\n+    debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n+\n+    // The base case. We are pattern-matching on () and the return value is\n+    // based on whether our matrix has a row or not.\n+    // NOTE: This could potentially be optimized by checking rows.is_empty()\n+    // first and then, if v is non-empty, the return value is based on whether\n+    // the type of the tuple we're checking is inhabited or not.\n+    if v.is_empty() {\n+        return if rows.is_empty() {\n+            Usefulness::new_useful(witness_preference)\n+        } else {\n+            NotUseful\n+        };\n+    };\n+\n+    assert!(rows.iter().all(|r| r.len() == v.len()));\n+\n+    // If the first pattern is an or-pattern, expand it.\n+    if let Some(vs) = v.expand_or_pat() {\n+        // We expand the or pattern, trying each of its branches in turn and keeping careful track\n+        // of possible unreachable sub-branches.\n+        //\n+        // If two branches have detected some unreachable sub-branches, we need to be careful. If\n+        // they were detected in columns that are not the current one, we want to keep only the\n+        // sub-branches that were unreachable in _all_ branches. Eg. in the following, the last\n+        // `true` is unreachable in the second branch of the first or-pattern, but not otherwise.\n+        // Therefore we don't want to lint that it is unreachable.\n+        //\n+        // ```\n+        // match (true, true) {\n+        //     (true, true) => {}\n+        //     (false | true, false | true) => {}\n+        // }\n+        // ```\n+        // If however the sub-branches come from the current column, they come from the inside of\n+        // the current or-pattern, and we want to keep them all. Eg. in the following, we _do_ want\n+        // to lint that the last `false` is unreachable.\n+        // ```\n+        // match None {\n+        //     Some(false) => {}\n+        //     None | Some(true | false) => {}\n+        // }\n+        // ```\n+\n+        let mut matrix = matrix.clone();\n+        // We keep track of sub-branches separately depending on whether they come from this column\n+        // or from others.\n+        let mut unreachables_this_column: FxHashSet<Span> = FxHashSet::default();\n+        let mut unreachables_other_columns: Vec<FxHashSet<Span>> = Vec::default();\n+        // Whether at least one branch is reachable.\n+        let mut any_is_useful = false;\n+\n+        for v in vs {\n+            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+            match res {\n+                Useful(unreachables) => {\n+                    if let Some((this_column, other_columns)) = unreachables.split_last() {\n+                        // We keep the union of unreachables found in the first column.\n+                        unreachables_this_column.extend(this_column);\n+                        // We keep the intersection of unreachables found in other columns.\n+                        if unreachables_other_columns.is_empty() {\n+                            unreachables_other_columns = other_columns.to_vec();\n+                        } else {\n+                            unreachables_other_columns = unreachables_other_columns\n+                                .into_iter()\n+                                .zip(other_columns)\n+                                .map(|(x, y)| x.intersection(&y).copied().collect())\n+                                .collect();\n+                        }\n+                    }\n+                    any_is_useful = true;\n+                }\n+                NotUseful => {\n+                    unreachables_this_column.insert(v.head().span);\n+                }\n+                UsefulWithWitness(_) => bug!(\n+                    \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n+                ),\n+            }\n+\n+            // If pattern has a guard don't add it to the matrix.\n+            if !is_under_guard {\n+                // We push the already-seen patterns into the matrix in order to detect redundant\n+                // branches like `Some(_) | Some(0)`.\n+                matrix.push(v);\n+            }\n+        }\n+\n+        return if any_is_useful {\n+            let mut unreachables = if unreachables_other_columns.is_empty() {\n+                let n_columns = v.len();\n+                (0..n_columns - 1).map(|_| FxHashSet::default()).collect()\n+            } else {\n+                unreachables_other_columns\n+            };\n+            unreachables.push(unreachables_this_column);\n+            Useful(unreachables)\n+        } else {\n+            NotUseful\n+        };\n+    }\n+\n+    // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n+    let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n+    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span, is_top_level };\n+\n+    debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n+\n+    let ret = v\n+        .head_ctor(cx)\n+        .split(pcx, Some(hir_id))\n+        .into_iter()\n+        .map(|ctor| {\n+            // We cache the result of `Fields::wildcards` because it is used a lot.\n+            let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n+            let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n+            let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n+            let usefulness =\n+                is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+            usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns)\n+        })\n+        .find(|result| result.is_useful())\n+        .unwrap_or(NotUseful);\n+    debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n+    ret\n+}\n+\n+/// The arm of a match expression.\n+#[derive(Clone, Copy)]\n+crate struct MatchArm<'p, 'tcx> {\n+    /// The pattern must have been lowered through `MatchVisitor::lower_pattern`.\n+    crate pat: &'p super::Pat<'tcx>,\n+    crate hir_id: HirId,\n+    crate has_guard: bool,\n+}\n+\n+/// The output of checking a match for exhaustiveness and arm reachability.\n+crate struct UsefulnessReport<'p, 'tcx> {\n+    /// For each arm of the input, whether that arm is reachable after the arms above it.\n+    crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Usefulness<'tcx>)>,\n+    /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n+    /// exhaustiveness.\n+    crate non_exhaustiveness_witnesses: Vec<super::Pat<'tcx>>,\n+}\n+\n+/// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n+/// of its arms are reachable.\n+///\n+/// Note: the input patterns must have been lowered through `MatchVisitor::lower_pattern`.\n+crate fn compute_match_usefulness<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    arms: &[MatchArm<'p, 'tcx>],\n+    scrut_hir_id: HirId,\n+    scrut_ty: Ty<'tcx>,\n+) -> UsefulnessReport<'p, 'tcx> {\n+    let mut matrix = Matrix::empty();\n+    let arm_usefulness: Vec<_> = arms\n+        .iter()\n+        .copied()\n+        .map(|arm| {\n+            let v = PatStack::from_pattern(arm.pat);\n+            let usefulness =\n+                is_useful(cx, &matrix, &v, LeaveOutWitness, arm.hir_id, arm.has_guard, true);\n+            if !arm.has_guard {\n+                matrix.push(v);\n+            }\n+            (arm, usefulness)\n+        })\n+        .collect();\n+\n+    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(scrut_ty));\n+    let v = PatStack::from_pattern(wild_pattern);\n+    let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, scrut_hir_id, false, true);\n+    let non_exhaustiveness_witnesses = match usefulness {\n+        NotUseful => vec![], // Wildcard pattern isn't useful, so the match is exhaustive.\n+        UsefulWithWitness(pats) => {\n+            if pats.is_empty() {\n+                bug!(\"Exhaustiveness check returned no witnesses\")\n+            } else {\n+                pats.into_iter().map(|w| w.single_pattern()).collect()\n+            }\n+        }\n+        Useful(_) => bug!(),\n+    };\n+    UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n+}"}]}