{"sha": "a3520bf01dd4709ea1c9694f91cbb72d1eac3924", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNTIwYmYwMWRkNDcwOWVhMWM5Njk0ZjkxY2JiNzJkMWVhYzM5MjQ=", "commit": {"author": {"name": "gfreezy", "email": "gfreezy@gmail.com", "date": "2018-12-30T13:31:01Z"}, "committer": {"name": "gfreezy", "email": "gfreezy@gmail.com", "date": "2018-12-30T14:26:59Z"}, "message": "implement struct shorthand initialization diagnostic", "tree": {"sha": "c2422f89d57a46e213760835638f97107f73f2e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2422f89d57a46e213760835638f97107f73f2e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3520bf01dd4709ea1c9694f91cbb72d1eac3924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3520bf01dd4709ea1c9694f91cbb72d1eac3924", "html_url": "https://github.com/rust-lang/rust/commit/a3520bf01dd4709ea1c9694f91cbb72d1eac3924", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3520bf01dd4709ea1c9694f91cbb72d1eac3924/comments", "author": {"login": "gfreezy", "id": 510012, "node_id": "MDQ6VXNlcjUxMDAxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/510012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gfreezy", "html_url": "https://github.com/gfreezy", "followers_url": "https://api.github.com/users/gfreezy/followers", "following_url": "https://api.github.com/users/gfreezy/following{/other_user}", "gists_url": "https://api.github.com/users/gfreezy/gists{/gist_id}", "starred_url": "https://api.github.com/users/gfreezy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gfreezy/subscriptions", "organizations_url": "https://api.github.com/users/gfreezy/orgs", "repos_url": "https://api.github.com/users/gfreezy/repos", "events_url": "https://api.github.com/users/gfreezy/events{/privacy}", "received_events_url": "https://api.github.com/users/gfreezy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gfreezy", "id": 510012, "node_id": "MDQ6VXNlcjUxMDAxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/510012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gfreezy", "html_url": "https://github.com/gfreezy", "followers_url": "https://api.github.com/users/gfreezy/followers", "following_url": "https://api.github.com/users/gfreezy/following{/other_user}", "gists_url": "https://api.github.com/users/gfreezy/gists{/gist_id}", "starred_url": "https://api.github.com/users/gfreezy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gfreezy/subscriptions", "organizations_url": "https://api.github.com/users/gfreezy/orgs", "repos_url": "https://api.github.com/users/gfreezy/repos", "events_url": "https://api.github.com/users/gfreezy/events{/privacy}", "received_events_url": "https://api.github.com/users/gfreezy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a3d6aa26a1c71dadc91f37f9d5f8662b51c138a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3d6aa26a1c71dadc91f37f9d5f8662b51c138a", "html_url": "https://github.com/rust-lang/rust/commit/4a3d6aa26a1c71dadc91f37f9d5f8662b51c138a"}], "stats": {"total": 380, "additions": 268, "deletions": 112}, "files": [{"sha": "d1667fd7c0f066d1f63e76b9079e1c036fa00023", "filename": "crates/ra_editor/src/diagnostics.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/a3520bf01dd4709ea1c9694f91cbb72d1eac3924/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3520bf01dd4709ea1c9694f91cbb72d1eac3924/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs?ref=a3520bf01dd4709ea1c9694f91cbb72d1eac3924", "patch": "@@ -0,0 +1,266 @@\n+use itertools::Itertools;\n+\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    Location,\n+    SourceFileNode,\n+    SyntaxKind,\n+    TextRange,\n+};\n+use ra_text_edit::{\n+    TextEdit,\n+    TextEditBuilder,\n+};\n+\n+use crate::{\n+    Diagnostic,\n+    LocalEdit,\n+    Severity,\n+};\n+\n+pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n+    fn location_to_range(location: Location) -> TextRange {\n+        match location {\n+            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n+            Location::Range(range) => range,\n+        }\n+    }\n+\n+    let mut errors: Vec<Diagnostic> = file\n+        .errors()\n+        .into_iter()\n+        .map(|err| Diagnostic {\n+            range: location_to_range(err.location()),\n+            msg: format!(\"Syntax Error: {}\", err),\n+            severity: Severity::Error,\n+            fix: None,\n+        })\n+        .collect();\n+\n+    errors.extend(check_unnecessary_braces_in_use_statement(file));\n+    errors.extend(check_struct_shorthand_initialization(file));\n+    errors\n+}\n+\n+fn check_unnecessary_braces_in_use_statement(file: &SourceFileNode) -> Vec<Diagnostic> {\n+    let mut diagnostics = Vec::new();\n+    for use_tree_list in file\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::UseTreeList::cast)\n+    {\n+        if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n+            let range = use_tree_list.syntax().range();\n+            let edit =\n+                text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n+                    .unwrap_or_else(|| {\n+                        let to_replace = single_use_tree.syntax().text().to_string();\n+                        let mut edit_builder = TextEditBuilder::new();\n+                        edit_builder.delete(range);\n+                        edit_builder.insert(range.start(), to_replace);\n+                        edit_builder.finish()\n+                    });\n+\n+            diagnostics.push(Diagnostic {\n+                range,\n+                msg: format!(\"Unnecessary braces in use statement\"),\n+                severity: Severity::WeakWarning,\n+                fix: Some(LocalEdit {\n+                    label: \"Remove unnecessary braces\".to_string(),\n+                    edit,\n+                    cursor_position: None,\n+                }),\n+            })\n+        }\n+    }\n+\n+    diagnostics\n+}\n+\n+fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n+    single_use_tree: ast::UseTree,\n+) -> Option<TextEdit> {\n+    let use_tree_list_node = single_use_tree.syntax().parent()?;\n+    if single_use_tree\n+        .path()?\n+        .segment()?\n+        .syntax()\n+        .first_child()?\n+        .kind()\n+        == SyntaxKind::SELF_KW\n+    {\n+        let start = use_tree_list_node.prev_sibling()?.range().start();\n+        let end = use_tree_list_node.range().end();\n+        let range = TextRange::from_to(start, end);\n+        let mut edit_builder = TextEditBuilder::new();\n+        edit_builder.delete(range);\n+        return Some(edit_builder.finish());\n+    }\n+    None\n+}\n+\n+fn check_struct_shorthand_initialization(file: &SourceFileNode) -> Vec<Diagnostic> {\n+    let mut diagnostics = Vec::new();\n+    for struct_lit in file.syntax().descendants().filter_map(ast::StructLit::cast) {\n+        if let Some(named_field_list) = struct_lit.named_field_list() {\n+            for named_field in named_field_list.fields() {\n+                if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n+                    let field_name = name_ref.syntax().text().to_string();\n+                    let field_expr = expr.syntax().text().to_string();\n+                    if field_name == field_expr {\n+                        let mut edit_builder = TextEditBuilder::new();\n+                        edit_builder.delete(named_field.syntax().range());\n+                        edit_builder.insert(named_field.syntax().range().start(), field_name);\n+                        let edit = edit_builder.finish();\n+\n+                        diagnostics.push(Diagnostic {\n+                            range: named_field.syntax().range(),\n+                            msg: format!(\"Shorthand struct initialization\"),\n+                            severity: Severity::WeakWarning,\n+                            fix: Some(LocalEdit {\n+                                label: \"use struct shorthand initialization\".to_string(),\n+                                edit,\n+                                cursor_position: None,\n+                            }),\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    diagnostics\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::test_utils::assert_eq_text;\n+\n+    use super::*;\n+\n+    fn check_not_applicable(code: &str, func: fn(file: &SourceFileNode) -> Vec<Diagnostic>) {\n+        let file = SourceFileNode::parse(code);\n+        let diagnostics = func(&file);\n+        assert!(diagnostics.is_empty());\n+    }\n+\n+    fn check_apply(before: &str, after: &str, func: fn(file: &SourceFileNode) -> Vec<Diagnostic>) {\n+        let file = SourceFileNode::parse(before);\n+        let diagnostic = func(&file)\n+            .pop()\n+            .unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n+        let fix = diagnostic.fix.unwrap();\n+        let actual = fix.edit.apply(&before);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    #[test]\n+    fn test_check_unnecessary_braces_in_use_statement() {\n+        check_not_applicable(\n+            \"\n+            use a;\n+            use a::{c, d::e};\n+        \",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\n+            \"use {b};\",\n+            \"use b;\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\n+            \"use a::{c};\",\n+            \"use a::c;\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\n+            \"use a::{self};\",\n+            \"use a;\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\n+            \"use a::{c, d::{e}};\",\n+            \"use a::{c, d::e};\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_check_struct_shorthand_initialization() {\n+        check_not_applicable(\n+            r#\"\n+            struct A {\n+                a: &'static str\n+            }\n+\n+            fn main() {\n+                A {\n+                    a: \"hello\"\n+                }\n+            }\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+\n+        check_apply(\n+            r#\"\n+struct A {\n+    a: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    A {\n+        a: a\n+    }\n+}\n+        \"#,\n+            r#\"\n+struct A {\n+    a: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    A {\n+        a\n+    }\n+}\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+\n+        check_apply(\n+            r#\"\n+struct A {\n+    a: &'static str,\n+    b: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    let b = \"bb\";\n+    A {\n+        a: a,\n+        b\n+    }\n+}\n+        \"#,\n+            r#\"\n+struct A {\n+    a: &'static str,\n+    b: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    let b = \"bb\";\n+    A {\n+        a,\n+        b\n+    }\n+}\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+    }\n+}"}, {"sha": "a65637d52e8b165640000bbee38abbd7c5dacc0c", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 2, "deletions": 112, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a3520bf01dd4709ea1c9694f91cbb72d1eac3924/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3520bf01dd4709ea1c9694f91cbb72d1eac3924/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=a3520bf01dd4709ea1c9694f91cbb72d1eac3924", "patch": "@@ -7,6 +7,7 @@ mod symbols;\n #[cfg(test)]\n mod test_utils;\n mod typing;\n+mod diagnostics;\n \n pub use self::{\n     code_actions::{add_derive, add_impl, flip_comma, introduce_variable, make_pub_crate, LocalEdit},\n@@ -16,17 +17,16 @@ pub use self::{\n     line_index_utils::translate_offset_with_edit,\n     symbols::{file_structure, file_symbols, FileSymbol, StructureNode},\n     typing::{join_lines, on_enter, on_eq_typed},\n+    diagnostics::diagnostics\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use ra_syntax::{\n     algo::find_leaf_at_offset,\n     ast::{self, AstNode, NameOwner},\n     SourceFileNode,\n-    Location,\n     SyntaxKind::{self, *},\n     SyntaxNodeRef, TextRange, TextUnit, Direction,\n };\n-use itertools::Itertools;\n use rustc_hash::FxHashSet;\n \n #[derive(Debug)]\n@@ -129,87 +129,6 @@ pub fn highlight(file: &SourceFileNode) -> Vec<HighlightedRange> {\n     res\n }\n \n-pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n-    fn location_to_range(location: Location) -> TextRange {\n-        match location {\n-            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n-            Location::Range(range) => range,\n-        }\n-    }\n-\n-    let mut errors: Vec<Diagnostic> = file\n-        .errors()\n-        .into_iter()\n-        .map(|err| Diagnostic {\n-            range: location_to_range(err.location()),\n-            msg: format!(\"Syntax Error: {}\", err),\n-            severity: Severity::Error,\n-            fix: None,\n-        })\n-        .collect();\n-\n-    let warnings = check_unnecessary_braces_in_use_statement(file);\n-\n-    errors.extend(warnings);\n-    errors\n-}\n-\n-fn check_unnecessary_braces_in_use_statement(file: &SourceFileNode) -> Vec<Diagnostic> {\n-    let mut diagnostics = Vec::new();\n-    for node in file.syntax().descendants() {\n-        if let Some(use_tree_list) = ast::UseTreeList::cast(node) {\n-            if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n-                let range = use_tree_list.syntax().range();\n-                let edit = text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-                    single_use_tree,\n-                )\n-                .unwrap_or_else(|| {\n-                    let to_replace = single_use_tree.syntax().text().to_string();\n-                    let mut edit_builder = TextEditBuilder::new();\n-                    edit_builder.delete(range);\n-                    edit_builder.insert(range.start(), to_replace);\n-                    edit_builder.finish()\n-                });\n-\n-                diagnostics.push(Diagnostic {\n-                    range: range,\n-                    msg: format!(\"Unnecessary braces in use statement\"),\n-                    severity: Severity::WeakWarning,\n-                    fix: Some(LocalEdit {\n-                        label: \"Remove unnecessary braces\".to_string(),\n-                        edit: edit,\n-                        cursor_position: None,\n-                    }),\n-                })\n-            }\n-        }\n-    }\n-\n-    diagnostics\n-}\n-\n-fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-    single_use_tree: ast::UseTree,\n-) -> Option<TextEdit> {\n-    let use_tree_list_node = single_use_tree.syntax().parent()?;\n-    if single_use_tree\n-        .path()?\n-        .segment()?\n-        .syntax()\n-        .first_child()?\n-        .kind()\n-        == SyntaxKind::SELF_KW\n-    {\n-        let start = use_tree_list_node.prev_sibling()?.range().start();\n-        let end = use_tree_list_node.range().end();\n-        let range = TextRange::from_to(start, end);\n-        let mut edit_builder = TextEditBuilder::new();\n-        edit_builder.delete(range);\n-        return Some(edit_builder.finish());\n-    }\n-    None\n-}\n-\n pub fn syntax_tree(file: &SourceFileNode) -> String {\n     ::ra_syntax::utils::dump_tree(file.syntax())\n }\n@@ -310,33 +229,4 @@ fn test_foo() {}\n         do_check(\"struct Foo { a: i32, }<|>\", \"struct Foo <|>{ a: i32, }\");\n     }\n \n-    #[test]\n-    fn test_check_unnecessary_braces_in_use_statement() {\n-        fn check_not_applicable(code: &str) {\n-            let file = SourceFileNode::parse(code);\n-            let diagnostics = check_unnecessary_braces_in_use_statement(&file);\n-            assert!(diagnostics.is_empty());\n-        }\n-\n-        fn check_apply(before: &str, after: &str) {\n-            let file = SourceFileNode::parse(before);\n-            let diagnostic = check_unnecessary_braces_in_use_statement(&file)\n-                .pop()\n-                .unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n-            let fix = diagnostic.fix.unwrap();\n-            let actual = fix.edit.apply(&before);\n-            assert_eq_text!(after, &actual);\n-        }\n-\n-        check_not_applicable(\n-            \"\n-            use a;\n-            use a::{c, d::e};\n-        \",\n-        );\n-        check_apply(\"use {b};\", \"use b;\");\n-        check_apply(\"use a::{c};\", \"use a::c;\");\n-        check_apply(\"use a::{self};\", \"use a;\");\n-        check_apply(\"use a::{c, d::{e}};\", \"use a::{c, d::e};\");\n-    }\n }"}]}