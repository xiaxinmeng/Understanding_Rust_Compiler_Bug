{"sha": "8c050fc805e601783765d0a58b2dbe3d948b6cd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMDUwZmM4MDVlNjAxNzgzNzY1ZDBhNThiMmRiZTNkOTQ4YjZjZDY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-07-11T17:01:29Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-07-15T15:41:23Z"}, "message": "rustc: compute `ty::layout::Niche`'s `available` on the fly.", "tree": {"sha": "028cbc836d9fbd7fe627a4e56388cb02d8abede9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/028cbc836d9fbd7fe627a4e56388cb02d8abede9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c050fc805e601783765d0a58b2dbe3d948b6cd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c050fc805e601783765d0a58b2dbe3d948b6cd6", "html_url": "https://github.com/rust-lang/rust/commit/8c050fc805e601783765d0a58b2dbe3d948b6cd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c050fc805e601783765d0a58b2dbe3d948b6cd6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5480b47d7f9e708300d3ba319869f21cd1ffd487", "url": "https://api.github.com/repos/rust-lang/rust/commits/5480b47d7f9e708300d3ba319869f21cd1ffd487", "html_url": "https://github.com/rust-lang/rust/commit/5480b47d7f9e708300d3ba319869f21cd1ffd487"}], "stats": {"total": 72, "additions": 43, "deletions": 29}, "files": [{"sha": "bf48b9ead05d7f9eee293690f27235140fad9a4c", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8c050fc805e601783765d0a58b2dbe3d948b6cd6/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c050fc805e601783765d0a58b2dbe3d948b6cd6/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8c050fc805e601783765d0a58b2dbe3d948b6cd6", "patch": "@@ -2225,24 +2225,50 @@ where\n struct Niche {\n     offset: Size,\n     scalar: Scalar,\n-    available: u128,\n }\n \n impl Niche {\n-    fn reserve<'tcx>(\n-        &self,\n-        cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n-        count: u128,\n-    ) -> Option<(u128, Scalar)> {\n-        if count > self.available {\n-            return None;\n-        }\n+    fn available<C: HasDataLayout>(&self, cx: &C) -> u128 {\n+        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let bits = value.size(cx).bits();\n+        assert!(bits <= 128);\n+        let max_value = !0u128 >> (128 - bits);\n+\n+        // Find out how many values are outside the valid range.\n+        let niche = v.end().wrapping_add(1)..*v.start();\n+        niche.end.wrapping_sub(niche.start) & max_value\n+    }\n+\n+    fn reserve<C: HasDataLayout>(&self, cx: &C, count: u128) -> Option<(u128, Scalar)> {\n+        assert!(count > 0);\n+\n         let Scalar { value, valid_range: ref v } = self.scalar;\n         let bits = value.size(cx).bits();\n         assert!(bits <= 128);\n         let max_value = !0u128 >> (128 - bits);\n+\n+        if count > max_value {\n+            return None;\n+        }\n+\n+        // Compute the range of invalid values being reserved.\n         let start = v.end().wrapping_add(1) & max_value;\n         let end = v.end().wrapping_add(count) & max_value;\n+\n+        // If the `end` of our range is inside the valid range,\n+        // then we ran out of invalid values.\n+        // FIXME(eddyb) abstract this with a wraparound range type.\n+        let valid_range_contains = |x| {\n+            if v.start() <= v.end() {\n+                *v.start() <= x && x <= *v.end()\n+            } else {\n+                *v.start() <= x || x <= *v.end()\n+            }\n+        };\n+        if valid_range_contains(end) {\n+            return None;\n+        }\n+\n         Some((start, Scalar { value, valid_range: *v.start()..=end }))\n     }\n }\n@@ -2253,25 +2279,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n     // FIXME(eddyb) traverse already optimized enums.\n     fn find_niche(&self, layout: TyLayout<'tcx>) -> Result<Option<Niche>, LayoutError<'tcx>> {\n         let scalar_niche = |scalar: &Scalar, offset| {\n-            let Scalar { value, valid_range: ref v } = *scalar;\n-\n-            let bits = value.size(self).bits();\n-            assert!(bits <= 128);\n-            let max_value = !0u128 >> (128 - bits);\n-\n-            // Find out how many values are outside the valid range.\n-            let available = if v.start() <= v.end() {\n-                v.start() + (max_value - v.end())\n+            let niche = Niche { offset, scalar: scalar.clone() };\n+            if niche.available(self) > 0 {\n+                Some(niche)\n             } else {\n-                v.start() - v.end() - 1\n-            };\n-\n-            // Give up if there is no niche value available.\n-            if available == 0 {\n-                return None;\n+                None\n             }\n-\n-            Some(Niche { offset, scalar: scalar.clone(), available })\n         };\n \n         // Locals variables which live across yields are stored\n@@ -2293,7 +2306,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 )\n                     .chain(iter::once((a, Size::ZERO)))\n                     .filter_map(|(scalar, offset)| scalar_niche(scalar, offset))\n-                    .max_by_key(|niche| niche.available);\n+                    .max_by_key(|niche| niche.available(self));\n                 return Ok(niche);\n             }\n             Abi::Vector { ref element, .. } => {\n@@ -2325,8 +2338,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let mut available = 0;\n         for i in 0..layout.fields.count() {\n             if let Some(mut c) = self.find_niche(layout.field(self, i)?)? {\n-                if c.available > available {\n-                    available = c.available;\n+                let c_available = c.available(self);\n+                if c_available > available {\n+                    available = c_available;\n                     c.offset += layout.fields.offset(i);\n                     niche = Some(c);\n                 }"}]}