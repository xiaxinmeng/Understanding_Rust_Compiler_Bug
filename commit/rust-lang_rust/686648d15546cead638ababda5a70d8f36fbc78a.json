{"sha": "686648d15546cead638ababda5a70d8f36fbc78a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NjY0OGQxNTU0NmNlYWQ2MzhhYmFiZGE1YTcwZDhmMzZmYmM3OGE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-21T20:46:12Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-21T20:46:12Z"}, "message": "Rollup merge of #22584 - alexcrichton:snapshots, r=Gankro", "tree": {"sha": "038fef94f8b208553ce2bc0409d9f051bc88693d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038fef94f8b208553ce2bc0409d9f051bc88693d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/686648d15546cead638ababda5a70d8f36fbc78a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/686648d15546cead638ababda5a70d8f36fbc78a", "html_url": "https://github.com/rust-lang/rust/commit/686648d15546cead638ababda5a70d8f36fbc78a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/686648d15546cead638ababda5a70d8f36fbc78a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d7b216f40d13750a31a22ecc20498494f76cbc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d7b216f40d13750a31a22ecc20498494f76cbc6", "html_url": "https://github.com/rust-lang/rust/commit/5d7b216f40d13750a31a22ecc20498494f76cbc6"}, {"sha": "6686f7aa471f162697d08a78ad4d04d3c0e9612c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6686f7aa471f162697d08a78ad4d04d3c0e9612c", "html_url": "https://github.com/rust-lang/rust/commit/6686f7aa471f162697d08a78ad4d04d3c0e9612c"}], "stats": {"total": 5262, "additions": 20, "deletions": 5242}, "files": [{"sha": "cc49164ef91b349f78e716bf3b7c6962392ad9c8", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -598,13 +598,6 @@ impl<T: Default + Sync + Send> Default for Arc<T> {\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n-#[cfg(stage0)]\n-impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n-    fn hash(&self, state: &mut H) {\n-        (**self).hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash> Hash for Arc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "ce889c796012cb4c065d03e205c021796caac6b1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -220,14 +220,6 @@ impl<T: ?Sized + Ord> Ord for Box<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Hash> Hash for Box<T> {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {"}, {"sha": "ed7d34de7a68847d9a5bbb5a0d0acc83b33d7150", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -592,14 +592,6 @@ impl<T: Ord> Ord for Rc<T> {\n }\n \n // FIXME (#18248) Make `T` `Sized?`\n-#[cfg(stage0)]\n-impl<S: Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash> Hash for Rc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "21218201182f988f5635a98b078c124d968e6240", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -985,17 +985,6 @@ impl fmt::Debug for BitVec {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitVec {\n-    fn hash(&self, state: &mut S) {\n-        self.nbits.hash(state);\n-        for elem in self.blocks() {\n-            elem.hash(state);\n-        }\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl hash::Hash for BitVec {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         self.nbits.hash(state);\n@@ -1776,16 +1765,7 @@ impl fmt::Debug for BitSet {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitSet {\n-    fn hash(&self, state: &mut S) {\n-        for pos in self {\n-            pos.hash(state);\n-        }\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl hash::Hash for BitSet {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         for pos in self {"}, {"sha": "e92f38741c9a0bd3abab4b3378e7b354b57f383d", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -282,16 +282,6 @@ impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<'a, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, B> where B: Hash<S> + ToOwned\n-{\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n {\n     #[inline]"}, {"sha": "c1d74b16ce6bcacff795ef172f31283a17ec04fb", "filename": "src/libcollections/borrow_stage0.rs", "status": "removed", "additions": 0, "deletions": 313, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/5d7b216f40d13750a31a22ecc20498494f76cbc6/src%2Flibcollections%2Fborrow_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d7b216f40d13750a31a22ecc20498494f76cbc6/src%2Flibcollections%2Fborrow_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow_stage0.rs?ref=5d7b216f40d13750a31a22ecc20498494f76cbc6", "patch": "@@ -1,313 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A module for working with borrowed data.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use core::clone::Clone;\n-use core::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n-use core::hash::{Hash, Hasher};\n-use core::marker::Sized;\n-use core::ops::Deref;\n-use core::option::Option;\n-\n-use fmt;\n-use alloc::{rc, arc};\n-\n-use self::Cow::*;\n-\n-/// A trait for borrowing data.\n-///\n-/// In general, there may be several ways to \"borrow\" a piece of data.  The\n-/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n-/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n-/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n-///\n-/// When writing generic code, it is often desirable to abstract over all ways\n-/// of borrowing data from a given type. That is the role of the `Borrow`\n-/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n-/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n-/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Borrow<Borrowed: ?Sized> {\n-    /// Immutably borrow from an owned value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn borrow(&self) -> &Borrowed;\n-}\n-\n-/// A trait for mutably borrowing data.\n-///\n-/// Similar to `Borrow`, but for mutable borrows.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n-    /// Mutably borrow from an owned value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn borrow_mut(&mut self) -> &mut Borrowed;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Borrow<T> for T {\n-    fn borrow(&self) -> &T { self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> BorrowMut<T> for T {\n-    fn borrow_mut(&mut self) -> &mut T { self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> Borrow<T> for &'a T {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> Borrow<T> for &'a mut T {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n-    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n-}\n-\n-impl<T> Borrow<T> for rc::Rc<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-impl<T> Borrow<T> for arc::Arc<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n-    fn borrow(&self) -> &B {\n-        &**self\n-    }\n-}\n-\n-/// A generalization of Clone to borrowed data.\n-///\n-/// Some types make it possible to go from borrowed to owned, usually by\n-/// implementing the `Clone` trait. But `Clone` works only for going from `&T`\n-/// to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n-/// from any borrow of a given type.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait ToOwned {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Owned: Borrow<Self>;\n-\n-    /// Create owned data from borrowed data, usually by copying.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_owned(&self) -> Self::Owned;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ToOwned for T where T: Clone {\n-    type Owned = T;\n-    fn to_owned(&self) -> T { self.clone() }\n-}\n-\n-/// A clone-on-write smart pointer.\n-///\n-/// The type `Cow` is a smart pointer providing clone-on-write functionality: it\n-/// can enclose and provide immutable access to borrowed data, and clone the\n-/// data lazily when mutation or ownership is required. The type is designed to\n-/// work with general borrowed data via the `Borrow` trait.\n-///\n-/// `Cow` implements both `Deref`, which means that you can call\n-/// non-mutating methods directly on the data it encloses. If mutation\n-/// is desired, `to_mut` will obtain a mutable references to an owned\n-/// value, cloning if necessary.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::borrow::Cow;\n-///\n-/// fn abs_all(input: &mut Cow<[int]>) {\n-///     for i in 0..input.len() {\n-///         let v = input[i];\n-///         if v < 0 {\n-///             // clones into a vector the first time (if not already owned)\n-///             input.to_mut()[i] = -v;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {\n-    /// Borrowed data.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Borrowed(&'a B),\n-\n-    /// Owned data.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Owned(<B as ToOwned>::Owned)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n-    fn clone(&self) -> Cow<'a, B> {\n-        match *self {\n-            Borrowed(b) => Borrowed(b),\n-            Owned(ref o) => {\n-                let b: &B = o.borrow();\n-                Owned(b.to_owned())\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n-    /// Acquire a mutable reference to the owned form of the data.\n-    ///\n-    /// Copies the data if it is not already owned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned where <B as ToOwned>::Owned: 'a {\n-        match *self {\n-            Borrowed(borrowed) => {\n-                *self = Owned(borrowed.to_owned());\n-                self.to_mut()\n-            }\n-            Owned(ref mut owned) => owned\n-        }\n-    }\n-\n-    /// Extract the owned data.\n-    ///\n-    /// Copies the data if it is not already owned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_owned(self) -> <B as ToOwned>::Owned {\n-        match self {\n-            Borrowed(borrowed) => borrowed.to_owned(),\n-            Owned(owned) => owned\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps a borrowed value\n-    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_borrowed(&self) -> bool {\n-        match *self {\n-            Borrowed(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps an owned value\n-    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            Owned(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Deref for Cow<'a, B> where\n-    B: ToOwned, <B as ToOwned>::Owned: 'a\n-{\n-    type Target = B;\n-\n-    fn deref(&self) -> &B {\n-        match *self {\n-            Borrowed(borrowed) => borrowed,\n-            Owned(ref owned) => owned.borrow()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned, <B as ToOwned>::Owned: 'a {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Ord for Cow<'a, B> where\n-    B: Ord + ToOwned, <B as ToOwned>::Owned: 'a\n-{\n-    #[inline]\n-    fn cmp(&self, other: &Cow<'a, B>) -> Ordering {\n-        Ord::cmp(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n-    B: PartialEq<C> + ToOwned, C: ToOwned,\n-    <B as ToOwned>::Owned: 'a, <C as ToOwned>::Owned: 'b,\n-{\n-    #[inline]\n-    fn eq(&self, other: &Cow<'b, C>) -> bool {\n-        PartialEq::eq(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where\n-    B: PartialOrd + ToOwned, <B as ToOwned>::Owned: 'a\n-{\n-    #[inline]\n-    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n-        PartialOrd::partial_cmp(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n-    B: fmt::Debug + ToOwned,\n-    <B as ToOwned>::Owned: fmt::Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n-            Owned(ref o) => fmt::Debug::fmt(o, f),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n-    B: fmt::Display + ToOwned,\n-    <B as ToOwned>::Owned: fmt::Display,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Borrowed(ref b) => fmt::Display::fmt(b, f),\n-            Owned(ref o) => fmt::Display::fmt(o, f),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, B> where\n-    B: Hash<S> + ToOwned, <B as ToOwned>::Owned: 'a\n-{\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n-    }\n-}\n-\n-/// Trait for moving into a `Cow`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n-    /// Moves `self` into `Cow`\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn into_cow(self) -> Cow<'a, B>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n-    fn into_cow(self) -> Cow<'a, B> {\n-        self\n-    }\n-}"}, {"sha": "1b456eec830b14d84015d392cd8cc397ea6c40ee", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -852,16 +852,6 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n-    fn hash(&self, state: &mut S) {\n-        for elt in self {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "1f3c54a4cb53fd496fa8b58df7d98f020989e16f", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -86,23 +86,17 @@ mod macros;\n pub mod binary_heap;\n mod bit;\n mod btree;\n-pub mod linked_list;\n+pub mod borrow;\n pub mod enum_set;\n pub mod fmt;\n-pub mod vec_deque;\n+pub mod linked_list;\n pub mod slice;\n pub mod str;\n pub mod string;\n pub mod vec;\n+pub mod vec_deque;\n pub mod vec_map;\n \n-#[cfg(stage0)]\n-#[path = \"borrow_stage0.rs\"]\n-pub mod borrow;\n-\n-#[cfg(not(stage0))]\n-pub mod borrow;\n-\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub mod bit_vec {"}, {"sha": "3c61fc3da90e3dd706a83ed0d73bcae9ace17880", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -28,8 +28,6 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-#[cfg(stage0)]\n-use core::hash::Writer;\n use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n@@ -932,17 +930,6 @@ impl<A: fmt::Debug> fmt::Debug for LinkedList<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for LinkedList<A> {\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<A: Hash> Hash for LinkedList<A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);"}, {"sha": "6c2624cd204de1711879cc5b78a16c345e4bdc84", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -834,16 +834,7 @@ impl fmt::Debug for String {\n     }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Hash stabilization\")]\n-#[cfg(stage0)]\n-impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n-    #[inline]\n-    fn hash(&self, hasher: &mut H) {\n-        (**self).hash(hasher)\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl hash::Hash for String {\n     #[inline]\n     fn hash<H: hash::Hasher>(&self, hasher: &mut H) {"}, {"sha": "2f9577c08deba502cda273242582f08568e28af7", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -1303,15 +1303,7 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: Hash> Hash for Vec<T> {\n     #[inline]\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n@@ -1599,9 +1591,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     fn as_slice(&self) -> &[T] {\n         unsafe {\n             let p = *self.ptr;\n-            if cfg!(not(stage0)) { // NOTE remove cfg after next snapshot\n-                assume(p != 0 as *mut T);\n-            }\n+            assume(p != 0 as *mut T);\n             mem::transmute(RawSlice {\n                 data: p,\n                 len: self.len"}, {"sha": "f65e644fa52842f7325ee1d0ac3a1bf76a53af20", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -32,7 +32,6 @@ use core::ptr::{self, Unique};\n use core::raw::Slice as RawSlice;\n \n use core::hash::{Hash, Hasher};\n-#[cfg(stage0)] use core::hash::Writer;\n use core::cmp;\n \n use alloc::heap;\n@@ -1675,17 +1674,6 @@ impl<A: Ord> Ord for VecDeque<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for VecDeque<A> {\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<A: Hash> Hash for VecDeque<A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);"}, {"sha": "d59e3c70c39ba6d7fbcfba8fd5cf74e5e8935399", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -21,7 +21,6 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-#[cfg(stage0)] use core::hash::Writer;\n use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n use core::mem::replace;\n@@ -113,21 +112,7 @@ impl<V:Clone> Clone for VecMap<V> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n-    fn hash(&self, state: &mut S) {\n-        // In order to not traverse the `VecMap` twice, count the elements\n-        // during iteration.\n-        let mut count: usize = 0;\n-        for elt in self {\n-            elt.hash(state);\n-            count += 1;\n-        }\n-        count.hash(state);\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<V: Hash> Hash for VecMap<V> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // In order to not traverse the `VecMap` twice, count the elements"}, {"sha": "e8f6e31756df99cbba394853bafc1365effd9a85", "filename": "src/libcore/array.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -35,13 +35,6 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[cfg(stage0)]\n-            impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for [T; $N] {\n-                fn hash(&self, state: &mut S) {\n-                    Hash::hash(&self[..], state)\n-                }\n-            }\n-            #[cfg(not(stage0))]\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: Hash> Hash for [T; $N] {\n                 fn hash<H: hash::Hasher>(&self, state: &mut H) {"}, {"sha": "ed48903a7c2550ab31b5c415f71b389f331bb9f7", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -73,7 +73,6 @@ mod sip;\n /// to compute the hash. Specific implementations of this trait may specialize\n /// for particular instances of `H` in order to be able to optimize the hashing\n /// behavior.\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n     /// Feeds this value into the state given, updating the hasher as necessary.\n@@ -89,72 +88,40 @@ pub trait Hash {\n     }\n }\n \n-/// A hashable type.\n-///\n-/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n-/// to compute the hash. Specific implementations of this trait may specialize\n-/// for particular instances of `H` in order to be able to optimize the hashing\n-/// behavior.\n-#[cfg(stage0)]\n-pub trait Hash<H: Hasher> {\n-    /// Feeds this value into the state given, updating the hasher as necessary.\n-    fn hash(&self, state: &mut H);\n-}\n-\n /// A trait which represents the ability to hash an arbitrary stream of bytes.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n-    /// Result type of one run of hashing generated by this hasher.\n-    #[cfg(stage0)]\n-    type Output;\n-\n-    /// Resets this hasher back to its initial state (as if it were just\n-    /// created).\n-    #[cfg(stage0)]\n-    fn reset(&mut self);\n-\n-    /// Completes a round of hashing, producing the output hash generated.\n-    #[cfg(stage0)]\n-    fn finish(&self) -> Self::Output;\n-\n     /// Completes a round of hashing, producing the output hash generated.\n-    #[cfg(not(stage0))]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn finish(&self) -> u64;\n \n     /// Writes some data into this `Hasher`\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, bytes: &[u8]);\n \n     /// Write a single `u8` into this hasher\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n     /// Write a single `u16` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_u16(&mut self, i: u16) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i) })\n     }\n     /// Write a single `u32` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_u32(&mut self, i: u32) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i) })\n     }\n     /// Write a single `u64` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n     /// Write a single `usize` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_usize(&mut self, i: usize) {\n@@ -166,58 +133,31 @@ pub trait Hasher {\n     }\n \n     /// Write a single `i8` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n     /// Write a single `i16` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n     /// Write a single `i32` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n     /// Write a single `i64` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n     /// Write a single `isize` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n }\n \n-/// A common bound on the `Hasher` parameter to `Hash` implementations in order\n-/// to generically hash an aggregate.\n-#[unstable(feature = \"hash\",\n-           reason = \"this trait will likely be replaced by io::Writer\")]\n-#[allow(missing_docs)]\n-#[cfg(stage0)]\n-pub trait Writer {\n-    fn write(&mut self, bytes: &[u8]);\n-}\n-\n /// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n ///\n /// The specified value will be hashed with this hasher and then the resulting\n /// hash will be returned.\n-#[cfg(stage0)]\n-pub fn hash<T: Hash<H>, H: Hasher + Default>(value: &T) -> H::Output {\n-    let mut h: H = Default::default();\n-    value.hash(&mut h);\n-    h.finish()\n-}\n-\n-/// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n-///\n-/// The specified value will be hashed with this hasher and then the resulting\n-/// hash will be returned.\n-#[cfg(not(stage0))]\n #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n     let mut h: H = Default::default();\n@@ -227,145 +167,6 @@ pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n \n //////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(stage0)]\n-mod impls {\n-    use prelude::*;\n-\n-    use mem;\n-    use num::Int;\n-    use super::*;\n-\n-    macro_rules! impl_hash {\n-        ($ty:ident, $uty:ident) => {\n-            impl<S: Writer + Hasher> Hash<S> for $ty {\n-                #[inline]\n-                fn hash(&self, state: &mut S) {\n-                    let a: [u8; ::$ty::BYTES] = unsafe {\n-                        mem::transmute(*self)\n-                    };\n-                    state.write(&a)\n-                }\n-            }\n-        }\n-    }\n-\n-    impl_hash! { u8, u8 }\n-    impl_hash! { u16, u16 }\n-    impl_hash! { u32, u32 }\n-    impl_hash! { u64, u64 }\n-    impl_hash! { uint, uint }\n-    impl_hash! { i8, u8 }\n-    impl_hash! { i16, u16 }\n-    impl_hash! { i32, u32 }\n-    impl_hash! { i64, u64 }\n-    impl_hash! { int, uint }\n-\n-    impl<S: Writer + Hasher> Hash<S> for bool {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (*self as u8).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer + Hasher> Hash<S> for char {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (*self as u32).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer + Hasher> Hash<S> for str {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            state.write(self.as_bytes());\n-            0xffu8.hash(state)\n-        }\n-    }\n-\n-    macro_rules! impl_hash_tuple {\n-        () => (\n-            impl<S: Hasher> Hash<S> for () {\n-                #[inline]\n-                fn hash(&self, _state: &mut S) {}\n-            }\n-        );\n-\n-        ( $($name:ident)+) => (\n-            impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-                #[inline]\n-                #[allow(non_snake_case)]\n-                fn hash(&self, state: &mut S) {\n-                    match *self {\n-                        ($(ref $name,)*) => {\n-                            $(\n-                                $name.hash(state);\n-                            )*\n-                        }\n-                    }\n-                }\n-            }\n-        );\n-    }\n-\n-    impl_hash_tuple! {}\n-    impl_hash_tuple! { A }\n-    impl_hash_tuple! { A B }\n-    impl_hash_tuple! { A B C }\n-    impl_hash_tuple! { A B C D }\n-    impl_hash_tuple! { A B C D E }\n-    impl_hash_tuple! { A B C D E F }\n-    impl_hash_tuple! { A B C D E F G }\n-    impl_hash_tuple! { A B C D E F G H }\n-    impl_hash_tuple! { A B C D E F G H I }\n-    impl_hash_tuple! { A B C D E F G H I J }\n-    impl_hash_tuple! { A B C D E F G H I J K }\n-    impl_hash_tuple! { A B C D E F G H I J K L }\n-\n-    impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            self.len().hash(state);\n-            for elt in self {\n-                elt.hash(state);\n-            }\n-        }\n-    }\n-\n-\n-    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (**self).hash(state);\n-        }\n-    }\n-\n-    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (**self).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer + Hasher, T> Hash<S> for *const T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            // NB: raw-pointer Hash does _not_ dereference\n-            // to the target; it just gives you the pointer-bytes.\n-            (*self as uint).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            // NB: raw-pointer Hash does _not_ dereference\n-            // to the target; it just gives you the pointer-bytes.\n-            (*self as uint).hash(state);\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n mod impls {\n     use prelude::*;\n "}, {"sha": "6f24fc7067344c3cb848a0f645142f90c4d9a24f", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -16,8 +16,6 @@ use prelude::*;\n use default::Default;\n \n use super::Hasher;\n-#[cfg(stage0)]\n-use super::Writer;\n \n /// An implementation of SipHash 2-4.\n ///\n@@ -175,26 +173,9 @@ impl SipHasher {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Writer for SipHasher {\n-    #[inline]\n-    fn write(&mut self, msg: &[u8]) {\n-        self.write(msg)\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hasher for SipHasher {\n-    #[cfg(stage0)]\n-    type Output = u64;\n-\n-    #[cfg(stage0)]\n-    fn reset(&mut self) {\n-        self.reset();\n-    }\n-\n     #[inline]\n-    #[cfg(not(stage0))]\n     fn write(&mut self, msg: &[u8]) {\n         self.write(msg)\n     }"}, {"sha": "99385725a99a1f3ced716dac07f4b7eb9eb8bfa4", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -31,20 +31,10 @@ use option::Option;\n use hash::Hash;\n use hash::Hasher;\n \n-/// Types able to be transferred across thread boundaries.\n-#[unstable(feature = \"core\",\n-           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n-#[lang=\"send\"]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[cfg(stage0)]\n-pub unsafe trait Send: 'static {\n-    // empty.\n-}\n /// Types able to be transferred across thread boundaries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[cfg(not(stage0))]\n pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n@@ -233,13 +223,6 @@ pub struct Managed;\n \n macro_rules! impls{\n     ($t: ident) => (\n-        #[cfg(stage0)]\n-        impl<T:?Sized, S: Hasher> Hash<S> for $t<T> {\n-            #[inline]\n-            fn hash(&self, _: &mut S) {\n-            }\n-        }\n-        #[cfg(not(stage0))]\n         impl<T:?Sized> Hash for $t<T> {\n             #[inline]\n             fn hash<H: Hasher>(&self, _: &mut H) {\n@@ -348,14 +331,6 @@ impl<T:?Sized> MarkerTrait for T { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n \n-#[cfg(stage0)] // built into the trait matching system after stage0\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n-\n-/// Specific to stage0. You should not be seeing these docs!\n-#[cfg(stage0)]\n-#[lang=\"covariant_type\"] // only relevant to stage0\n-pub struct PhantomData<T:?Sized>;\n-\n /// `PhantomData` is a way to tell the compiler about fake fields.\n /// Phantom data is required whenever type parameters are not used.\n /// The idea is that if the compiler encounters a `PhantomData<T>`\n@@ -374,14 +349,12 @@ pub struct PhantomData<T:?Sized>;\n /// here! For now, please see [RFC 738][738] for more information.\n ///\n /// [738]: https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\n-#[cfg(not(stage0))]\n #[lang=\"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n \n impls! { PhantomData }\n \n-#[cfg(not(stage0))]\n mod impls {\n     use super::{Send, Sync, Sized};\n \n@@ -417,7 +390,6 @@ pub struct ContravariantType<T>;\n #[unstable(feature = \"core\", reason = \"deprecated\")]\n #[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<T>`\")]\n #[lang=\"covariant_type\"]\n-#[cfg(not(stage0))]\n pub struct CovariantType<T>;\n \n /// Old-style marker trait. Deprecated."}, {"sha": "021827b0101c81f7dee8caf04ab20ca6bcc9cac5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -185,14 +185,6 @@ impl PartialEq for LintId {\n \n impl Eq for LintId { }\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for LintId {\n-    fn hash(&self, state: &mut S) {\n-        let ptr = self.lint as *const Lint;\n-        ptr.hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl hash::Hash for LintId {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         let ptr = self.lint as *const Lint;"}, {"sha": "629b19300e62ce6fc4c8c897a004758b9a46d13b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -1588,48 +1588,6 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n // Path and definition ID indexing\n \n-#[cfg(stage0)]\n-fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n-    F: FnMut(&mut SeekableMemWriter, &T),\n-    T: Hash<SipHasher>,\n-{\n-    let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n-    for elt in index {\n-        let mut s = SipHasher::new();\n-        elt.val.hash(&mut s);\n-        let h = s.finish() as uint;\n-        (&mut buckets[h % 256]).push(elt);\n-    }\n-\n-    rbml_w.start_tag(tag_index);\n-    let mut bucket_locs = Vec::new();\n-    rbml_w.start_tag(tag_index_buckets);\n-    for bucket in &buckets {\n-        bucket_locs.push(rbml_w.writer.tell().unwrap());\n-        rbml_w.start_tag(tag_index_buckets_bucket);\n-        for elt in bucket {\n-            rbml_w.start_tag(tag_index_buckets_bucket_elt);\n-            assert!(elt.pos < 0xffff_ffff);\n-            {\n-                let wr: &mut SeekableMemWriter = rbml_w.writer;\n-                wr.write_be_u32(elt.pos as u32);\n-            }\n-            write_fn(rbml_w.writer, &elt.val);\n-            rbml_w.end_tag();\n-        }\n-        rbml_w.end_tag();\n-    }\n-    rbml_w.end_tag();\n-    rbml_w.start_tag(tag_index_table);\n-    for pos in &bucket_locs {\n-        assert!(*pos < 0xffff_ffff);\n-        let wr: &mut SeekableMemWriter = rbml_w.writer;\n-        wr.write_be_u32(*pos as u32);\n-    }\n-    rbml_w.end_tag();\n-    rbml_w.end_tag();\n-}\n-#[cfg(not(stage0))]\n fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash,"}, {"sha": "1206424550f951a36414149410de25e23ed188a7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -73,7 +73,6 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n-#[cfg(stage0)] use std::hash::Writer;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -959,13 +958,6 @@ impl<'tcx> PartialEq for TyS<'tcx> {\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n \n-#[cfg(stage0)]\n-impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n-    fn hash(&self, s: &mut S) {\n-        (self as *const _).hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'tcx> Hash for TyS<'tcx> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         (self as *const _).hash(s)\n@@ -988,13 +980,6 @@ impl<'tcx> PartialEq for InternedTy<'tcx> {\n \n impl<'tcx> Eq for InternedTy<'tcx> {}\n \n-#[cfg(stage0)]\n-impl<'tcx, S: Writer + Hasher> Hash<S> for InternedTy<'tcx> {\n-    fn hash(&self, s: &mut S) {\n-        self.ty.sty.hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'tcx> Hash for InternedTy<'tcx> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         self.ty.sty.hash(s)"}, {"sha": "a3cc23b7bba839d9ee2ed0ffdd705e11ba1ce1cc", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 6, "deletions": 97, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -14,7 +14,6 @@ use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt::Debug;\n use std::hash::Hash;\n-#[cfg(stage0)] use std::hash::Hasher;\n use std::iter::repeat;\n use std::time::Duration;\n use std::collections::hash_state::HashState;\n@@ -139,57 +138,13 @@ pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -\n \n /// K: Eq + Hash<S>, V, S, H: Hasher<S>\n ///\n-/// Determines whether there exists a path from `source` to `destination`.  The graph is defined by\n-/// the `edges_map`, which maps from a node `S` to a list of its adjacent nodes `T`.\n+/// Determines whether there exists a path from `source` to `destination`.  The\n+/// graph is defined by the `edges_map`, which maps from a node `S` to a list of\n+/// its adjacent nodes `T`.\n ///\n-/// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n-/// very small graphs. If the graphs become larger, a more efficient graph representation and\n-/// algorithm would probably be advised.\n-#[cfg(stage0)]\n-pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n-                       destination: T) -> bool\n-    where S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>,\n-          T: Hash<<S as HashState>::Hasher> + Eq + Clone,\n-{\n-    if source == destination {\n-        return true;\n-    }\n-\n-    // Do a little breadth-first-search here.  The `queue` list\n-    // doubles as a way to detect if we've seen a particular FR\n-    // before.  Note that we expect this graph to be an *extremely\n-    // shallow* tree.\n-    let mut queue = vec!(source);\n-    let mut i = 0;\n-    while i < queue.len() {\n-        match edges_map.get(&queue[i]) {\n-            Some(edges) => {\n-                for target in edges {\n-                    if *target == destination {\n-                        return true;\n-                    }\n-\n-                    if !queue.iter().any(|x| x == target) {\n-                        queue.push((*target).clone());\n-                    }\n-                }\n-            }\n-            None => {}\n-        }\n-        i += 1;\n-    }\n-    return false;\n-}\n-/// K: Eq + Hash<S>, V, S, H: Hasher<S>\n-///\n-/// Determines whether there exists a path from `source` to `destination`.  The graph is defined by\n-/// the `edges_map`, which maps from a node `S` to a list of its adjacent nodes `T`.\n-///\n-/// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n-/// very small graphs. If the graphs become larger, a more efficient graph representation and\n-/// algorithm would probably be advised.\n-#[cfg(not(stage0))]\n+/// Efficiency note: This is implemented in an inefficient way because it is\n+/// typically invoked on very small graphs. If the graphs become larger, a more\n+/// efficient graph representation and algorithm would probably be advised.\n pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n                        destination: T) -> bool\n     where S: HashState, T: Hash + Eq + Clone,\n@@ -250,52 +205,6 @@ pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n /// }\n /// ```\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n-    where T: Clone + Hash<<S as HashState>::Hasher> + Eq,\n-          U: Clone,\n-          S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>,\n-          F: FnOnce(T) -> U,\n-{\n-    let key = arg.clone();\n-    let result = cache.borrow().get(&key).cloned();\n-    match result {\n-        Some(result) => result,\n-        None => {\n-            let result = f(arg);\n-            cache.borrow_mut().insert(key, result.clone());\n-            result\n-        }\n-    }\n-}\n-/// Memoizes a one-argument closure using the given RefCell containing\n-/// a type implementing MutableMap to serve as a cache.\n-///\n-/// In the future the signature of this function is expected to be:\n-/// ```\n-/// pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n-///    cache: &RefCell<M>,\n-///    f: &|T| -> U\n-/// ) -> impl |T| -> U {\n-/// ```\n-/// but currently it is not possible.\n-///\n-/// # Example\n-/// ```\n-/// struct Context {\n-///    cache: RefCell<HashMap<uint, uint>>\n-/// }\n-///\n-/// fn factorial(ctxt: &Context, n: uint) -> uint {\n-///     memoized(&ctxt.cache, n, |n| match n {\n-///         0 | 1 => n,\n-///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)\n-///     })\n-/// }\n-/// ```\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n     where T: Clone + Hash + Eq,\n           U: Clone,"}, {"sha": "b15da7dab3ee606627f78d4d53618fa47e55dfd8", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -16,7 +16,6 @@ use std::collections::hash_state::{DefaultState};\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n use std::hash::{Hasher, Hash};\n-#[cfg(stage0)] use std::hash::Writer;\n use syntax::ast;\n \n pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n@@ -28,19 +27,9 @@ pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n pub type NodeSet = FnvHashSet<ast::NodeId>;\n pub type DefIdSet = FnvHashSet<ast::DefId>;\n \n-#[cfg(stage0)]\n-pub fn FnvHashMap<K: Hash<FnvHasher> + Eq, V>() -> FnvHashMap<K, V> {\n-    Default::default()\n-}\n-#[cfg(stage0)]\n-pub fn FnvHashSet<V: Hash<FnvHasher> + Eq>() -> FnvHashSet<V> {\n-    Default::default()\n-}\n-#[cfg(not(stage0))]\n pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n     Default::default()\n }\n-#[cfg(not(stage0))]\n pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n     Default::default()\n }\n@@ -63,26 +52,6 @@ impl Default for FnvHasher {\n     fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n }\n \n-#[cfg(stage0)]\n-impl Hasher for FnvHasher {\n-    type Output = u64;\n-    fn reset(&mut self) { *self = Default::default(); }\n-    fn finish(&self) -> u64 { self.0 }\n-}\n-\n-#[cfg(stage0)]\n-impl Writer for FnvHasher {\n-    fn write(&mut self, bytes: &[u8]) {\n-        let FnvHasher(mut hash) = *self;\n-        for byte in bytes {\n-            hash = hash ^ (*byte as u64);\n-            hash = hash * 0x100000001b3;\n-        }\n-        *self = FnvHasher(hash);\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Hasher for FnvHasher {\n     fn write(&mut self, bytes: &[u8]) {\n         let FnvHasher(mut hash) = *self;"}, {"sha": "23b63bc26657c6519e0ed39b295ec09f0d33e019", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -29,7 +29,6 @@ use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use std::collections::hash_state::HashState;\n use std::hash::Hash;\n-#[cfg(stage0)] use std::hash::Hasher;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast_map;\n@@ -1434,23 +1433,6 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n-    where K: Hash<<S as HashState>::Hasher> + Eq + Repr<'tcx>,\n-          V: Repr<'tcx>,\n-          S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>,\n-{\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"HashMap({})\",\n-                self.iter()\n-                    .map(|(k,v)| format!(\"{} => {}\", k.repr(tcx), v.repr(tcx)))\n-                    .collect::<Vec<String>>()\n-                    .connect(\", \"))\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n     where K: Hash + Eq + Repr<'tcx>,\n           V: Repr<'tcx>,"}, {"sha": "e7430f698e9c962e5bdec559d7a18ec3ba70004b", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -13,7 +13,6 @@\n use std::usize;\n use std::default::Default;\n use std::hash::Hash;\n-#[cfg(stage0)] use std::hash::Hasher;\n use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n@@ -158,26 +157,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<K, V, S> Encodable for HashMap<K, V, S>\n-    where K: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n-          V: Encodable,\n-          S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>\n-{\n-    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self {\n-                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n-                i += 1;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<K, V, S> Encodable for HashMap<K, V, S>\n     where K: Encodable + Hash + Eq,\n           V: Encodable,\n@@ -196,27 +175,6 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n     }\n }\n \n-#[cfg(stage0)]\n-impl<K, V, S> Decodable for HashMap<K, V, S>\n-    where K: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n-          V: Decodable,\n-          S: HashState + Default,\n-          <S as HashState>::Hasher: Hasher<Output=u64>\n-{\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n-        d.read_map(|d, len| {\n-            let state = Default::default();\n-            let mut map = HashMap::with_capacity_and_hash_state(len, state);\n-            for i in 0..len {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n-                map.insert(key, val);\n-            }\n-            Ok(map)\n-        })\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<K, V, S> Decodable for HashMap<K, V, S>\n     where K: Decodable + Hash + Eq,\n           V: Decodable,\n@@ -236,24 +194,6 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T, S> Encodable for HashSet<T, S>\n-    where T: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n-          S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>\n-{\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n-                i += 1;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T, S> Encodable for HashSet<T, S>\n     where T: Encodable + Hash + Eq,\n           S: HashState,\n@@ -270,24 +210,6 @@ impl<T, S> Encodable for HashSet<T, S>\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T, S> Decodable for HashSet<T, S>\n-    where T: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n-          S: HashState + Default,\n-          <S as HashState>::Hasher: Hasher<Output=u64>\n-{\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n-        d.read_seq(|d, len| {\n-            let state = Default::default();\n-            let mut set = HashSet::with_capacity_and_hash_state(len, state);\n-            for i in 0..len {\n-                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            Ok(set)\n-        })\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T, S> Decodable for HashSet<T, S>\n     where T: Decodable + Hash + Eq,\n           S: HashState + Default,"}, {"sha": "f9e5044c597616a129a687e25e0f3a35d8e7f786", "filename": "src/libstd/collections/hash/map_stage0.rs", "status": "removed", "additions": 0, "deletions": 2330, "changes": 2330, "blob_url": "https://github.com/rust-lang/rust/blob/5d7b216f40d13750a31a22ecc20498494f76cbc6/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d7b216f40d13750a31a22ecc20498494f76cbc6/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs?ref=5d7b216f40d13750a31a22ecc20498494f76cbc6", "patch": "@@ -1,2330 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-use self::Entry::*;\n-use self::SearchResult::*;\n-use self::VacantEntryState::*;\n-\n-use borrow::Borrow;\n-use clone::Clone;\n-use cmp::{max, Eq, PartialEq};\n-use default::Default;\n-use fmt::{self, Debug};\n-use hash::{self, Hash, SipHasher};\n-use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n-use marker::Sized;\n-use mem::{self, replace};\n-use num::{Int, UnsignedInt};\n-use ops::{Deref, FnMut, Index, IndexMut};\n-use option::Option::{self, Some, None};\n-use rand::{self, Rng};\n-use result::Result::{self, Ok, Err};\n-\n-use super::table::{\n-    self,\n-    Bucket,\n-    EmptyBucket,\n-    FullBucket,\n-    FullBucketImm,\n-    FullBucketMut,\n-    RawTable,\n-    SafeHash\n-};\n-use super::table::BucketState::{\n-    Empty,\n-    Full,\n-};\n-use super::state::HashState;\n-\n-const INITIAL_LOG2_CAP: usize = 5;\n-#[unstable(feature = \"std_misc\")]\n-pub const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n-\n-/// The default behavior of HashMap implements a load factor of 90.9%.\n-/// This behavior is characterized by the following condition:\n-///\n-/// - if size > 0.909 * capacity: grow the map\n-#[derive(Clone)]\n-struct DefaultResizePolicy;\n-\n-impl DefaultResizePolicy {\n-    fn new() -> DefaultResizePolicy {\n-        DefaultResizePolicy\n-    }\n-\n-    #[inline]\n-    fn min_capacity(&self, usable_size: usize) -> usize {\n-        // Here, we are rephrasing the logic by specifying the lower limit\n-        // on capacity:\n-        //\n-        // - if `cap < size * 1.1`: grow the map\n-        usable_size * 11 / 10\n-    }\n-\n-    /// An inverse of `min_capacity`, approximately.\n-    #[inline]\n-    fn usable_capacity(&self, cap: usize) -> usize {\n-        // As the number of entries approaches usable capacity,\n-        // min_capacity(size) must be smaller than the internal capacity,\n-        // so that the map is not resized:\n-        // `min_capacity(usable_capacity(x)) <= x`.\n-        // The left-hand side can only be smaller due to flooring by integer\n-        // division.\n-        //\n-        // This doesn't have to be checked for overflow since allocation size\n-        // in bytes will overflow earlier than multiplication by 10.\n-        cap * 10 / 11\n-    }\n-}\n-\n-#[test]\n-fn test_resize_policy() {\n-    use prelude::v1::*;\n-    let rp = DefaultResizePolicy;\n-    for n in 0..1000 {\n-        assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n-        assert!(rp.usable_capacity(rp.min_capacity(n)) <= n);\n-    }\n-}\n-\n-// The main performance trick in this hashmap is called Robin Hood Hashing.\n-// It gains its excellent performance from one essential operation:\n-//\n-//    If an insertion collides with an existing element, and that element's\n-//    \"probe distance\" (how far away the element is from its ideal location)\n-//    is higher than how far we've already probed, swap the elements.\n-//\n-// This massively lowers variance in probe distance, and allows us to get very\n-// high load factors with good performance. The 90% load factor I use is rather\n-// conservative.\n-//\n-// > Why a load factor of approximately 90%?\n-//\n-// In general, all the distances to initial buckets will converge on the mean.\n-// At a load factor of \u03b1, the odds of finding the target bucket after k\n-// probes is approximately 1-\u03b1^k. If we set this equal to 50% (since we converge\n-// on the mean) and set k=8 (64-byte cache line / 8-byte hash), \u03b1=0.92. I round\n-// this down to make the math easier on the CPU and avoid its FPU.\n-// Since on average we start the probing in the middle of a cache line, this\n-// strategy pulls in two cache lines of hashes on every lookup. I think that's\n-// pretty good, but if you want to trade off some space, it could go down to one\n-// cache line on average with an \u03b1 of 0.84.\n-//\n-// > Wait, what? Where did you get 1-\u03b1^k from?\n-//\n-// On the first probe, your odds of a collision with an existing element is \u03b1.\n-// The odds of doing this twice in a row is approximately \u03b1^2. For three times,\n-// \u03b1^3, etc. Therefore, the odds of colliding k times is \u03b1^k. The odds of NOT\n-// colliding after k tries is 1-\u03b1^k.\n-//\n-// The paper from 1986 cited below mentions an implementation which keeps track\n-// of the distance-to-initial-bucket histogram. This approach is not suitable\n-// for modern architectures because it requires maintaining an internal data\n-// structure. This allows very good first guesses, but we are most concerned\n-// with guessing entire cache lines, not individual indexes. Furthermore, array\n-// accesses are no longer linear and in one direction, as we have now. There\n-// is also memory and cache pressure that this would entail that would be very\n-// difficult to properly see in a microbenchmark.\n-//\n-// ## Future Improvements (FIXME!)\n-//\n-// Allow the load factor to be changed dynamically and/or at initialization.\n-//\n-// Also, would it be possible for us to reuse storage when growing the\n-// underlying table? This is exactly the use case for 'realloc', and may\n-// be worth exploring.\n-//\n-// ## Future Optimizations (FIXME!)\n-//\n-// Another possible design choice that I made without any real reason is\n-// parameterizing the raw table over keys and values. Technically, all we need\n-// is the size and alignment of keys and values, and the code should be just as\n-// efficient (well, we might need one for power-of-two size and one for not...).\n-// This has the potential to reduce code bloat in rust executables, without\n-// really losing anything except 4 words (key size, key alignment, val size,\n-// val alignment) which can be passed in to every call of a `RawTable` function.\n-// This would definitely be an avenue worth exploring if people start complaining\n-// about the size of rust executables.\n-//\n-// Annotate exceedingly likely branches in `table::make_hash`\n-// and `search_hashed` to reduce instruction cache pressure\n-// and mispredictions once it becomes possible (blocked on issue #11092).\n-//\n-// Shrinking the table could simply reallocate in place after moving buckets\n-// to the first half.\n-//\n-// The growth algorithm (fragment of the Proof of Correctness)\n-// --------------------\n-//\n-// The growth algorithm is basically a fast path of the naive reinsertion-\n-// during-resize algorithm. Other paths should never be taken.\n-//\n-// Consider growing a robin hood hashtable of capacity n. Normally, we do this\n-// by allocating a new table of capacity `2n`, and then individually reinsert\n-// each element in the old table into the new one. This guarantees that the\n-// new table is a valid robin hood hashtable with all the desired statistical\n-// properties. Remark that the order we reinsert the elements in should not\n-// matter. For simplicity and efficiency, we will consider only linear\n-// reinsertions, which consist of reinserting all elements in the old table\n-// into the new one by increasing order of index. However we will not be\n-// starting our reinsertions from index 0 in general. If we start from index\n-// i, for the purpose of reinsertion we will consider all elements with real\n-// index j < i to have virtual index n + j.\n-//\n-// Our hash generation scheme consists of generating a 64-bit hash and\n-// truncating the most significant bits. When moving to the new table, we\n-// simply introduce a new bit to the front of the hash. Therefore, if an\n-// elements has ideal index i in the old table, it can have one of two ideal\n-// locations in the new table. If the new bit is 0, then the new ideal index\n-// is i. If the new bit is 1, then the new ideal index is n + i. Intuitively,\n-// we are producing two independent tables of size n, and for each element we\n-// independently choose which table to insert it into with equal probability.\n-// However the rather than wrapping around themselves on overflowing their\n-// indexes, the first table overflows into the first, and the first into the\n-// second. Visually, our new table will look something like:\n-//\n-// [yy_xxx_xxxx_xxx|xx_yyy_yyyy_yyy]\n-//\n-// Where x's are elements inserted into the first table, y's are elements\n-// inserted into the second, and _'s are empty sections. We now define a few\n-// key concepts that we will use later. Note that this is a very abstract\n-// perspective of the table. A real resized table would be at least half\n-// empty.\n-//\n-// Theorem: A linear robin hood reinsertion from the first ideal element\n-// produces identical results to a linear naive reinsertion from the same\n-// element.\n-//\n-// FIXME(Gankro, pczarn): review the proof and put it all in a separate doc.rs\n-\n-/// A hash map implementation which uses linear probing with Robin\n-/// Hood bucket stealing.\n-///\n-/// The hashes are all keyed by the task-local random number generator\n-/// on creation by default. This means that the ordering of the keys is\n-/// randomized, but makes the tables more resistant to\n-/// denial-of-service attacks (Hash DoS). This behaviour can be\n-/// overridden with one of the constructors.\n-///\n-/// It is required that the keys implement the `Eq` and `Hash` traits, although\n-/// this can frequently be achieved by using `#[derive(Eq, Hash)]`.\n-///\n-/// Relevant papers/articles:\n-///\n-/// 1. Pedro Celis. [\"Robin Hood Hashing\"](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)\n-/// 2. Emmanuel Goossaert. [\"Robin Hood\n-///    hashing\"](http://codecapsule.com/2013/11/11/robin-hood-hashing/)\n-/// 3. Emmanuel Goossaert. [\"Robin Hood hashing: backward shift\n-///    deletion\"](http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/)\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::collections::HashMap;\n-///\n-/// // type inference lets us omit an explicit type signature (which\n-/// // would be `HashMap<&str, &str>` in this example).\n-/// let mut book_reviews = HashMap::new();\n-///\n-/// // review some books.\n-/// book_reviews.insert(\"Adventures of Huckleberry Finn\",    \"My favorite book.\");\n-/// book_reviews.insert(\"Grimms' Fairy Tales\",               \"Masterpiece.\");\n-/// book_reviews.insert(\"Pride and Prejudice\",               \"Very enjoyable.\");\n-/// book_reviews.insert(\"The Adventures of Sherlock Holmes\", \"Eye lyked it alot.\");\n-///\n-/// // check for a specific one.\n-/// if !book_reviews.contains_key(&(\"Les Mis\u00e9rables\")) {\n-///     println!(\"We've got {} reviews, but Les Mis\u00e9rables ain't one.\",\n-///              book_reviews.len());\n-/// }\n-///\n-/// // oops, this review has a lot of spelling mistakes, let's delete it.\n-/// book_reviews.remove(&(\"The Adventures of Sherlock Holmes\"));\n-///\n-/// // look up the values associated with some keys.\n-/// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n-/// for book in to_find.iter() {\n-///     match book_reviews.get(book) {\n-///         Some(review) => println!(\"{}: {}\", *book, *review),\n-///         None => println!(\"{} is unreviewed.\", *book)\n-///     }\n-/// }\n-///\n-/// // iterate over everything.\n-/// for (book, review) in book_reviews.iter() {\n-///     println!(\"{}: \\\"{}\\\"\", *book, *review);\n-/// }\n-/// ```\n-///\n-/// The easiest way to use `HashMap` with a custom type as key is to derive `Eq` and `Hash`.\n-/// We must also derive `PartialEq`.\n-///\n-/// ```\n-/// use std::collections::HashMap;\n-///\n-/// #[derive(Hash, Eq, PartialEq, Debug)]\n-/// struct Viking {\n-///     name: String,\n-///     country: String,\n-/// }\n-///\n-/// impl Viking {\n-///     /// Create a new Viking.\n-///     fn new(name: &str, country: &str) -> Viking {\n-///         Viking { name: name.to_string(), country: country.to_string() }\n-///     }\n-/// }\n-///\n-/// // Use a HashMap to store the vikings' health points.\n-/// let mut vikings = HashMap::new();\n-///\n-/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n-/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n-/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n-///\n-/// // Use derived implementation to print the status of the vikings.\n-/// for (viking, health) in vikings.iter() {\n-///     println!(\"{:?} has {} hp\", viking, health);\n-/// }\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct HashMap<K, V, S = RandomState> {\n-    // All hashes are keyed on these values, to prevent hash collision attacks.\n-    hash_state: S,\n-\n-    table: RawTable<K, V>,\n-\n-    resize_policy: DefaultResizePolicy,\n-}\n-\n-/// Search for a pre-hashed key.\n-fn search_hashed<K, V, M, F>(table: M,\n-                             hash: SafeHash,\n-                             mut is_match: F)\n-                             -> SearchResult<K, V, M> where\n-    M: Deref<Target=RawTable<K, V>>,\n-    F: FnMut(&K) -> bool,\n-{\n-    let size = table.size();\n-    let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index();\n-\n-    while probe.index() != ib + size {\n-        let full = match probe.peek() {\n-            Empty(b) => return TableRef(b.into_table()), // hit an empty bucket\n-            Full(b) => b\n-        };\n-\n-        if full.distance() + ib < full.index() {\n-            // We can finish the search early if we hit any bucket\n-            // with a lower distance to initial bucket than we've probed.\n-            return TableRef(full.into_table());\n-        }\n-\n-        // If the hash doesn't match, it can't be this one..\n-        if hash == full.hash() {\n-            // If the key doesn't match, it can't be this one..\n-            if is_match(full.read().0) {\n-                return FoundExisting(full);\n-            }\n-        }\n-\n-        probe = full.next();\n-    }\n-\n-    TableRef(probe.into_table())\n-}\n-\n-fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n-    let (empty, retkey, retval) = starting_bucket.take();\n-    let mut gap = match empty.gap_peek() {\n-        Some(b) => b,\n-        None => return (retkey, retval)\n-    };\n-\n-    while gap.full().distance() != 0 {\n-        gap = match gap.shift() {\n-            Some(b) => b,\n-            None => break\n-        };\n-    }\n-\n-    // Now we've done all our shifting. Return the value we grabbed earlier.\n-    (retkey, retval)\n-}\n-\n-/// Perform robin hood bucket stealing at the given `bucket`. You must\n-/// also pass the position of that bucket's initial bucket so we don't have\n-/// to recalculate it.\n-///\n-/// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n-fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n-                        mut ib: usize,\n-                        mut hash: SafeHash,\n-                        mut k: K,\n-                        mut v: V)\n-                        -> &'a mut V {\n-    let starting_index = bucket.index();\n-    let size = {\n-        let table = bucket.table(); // FIXME \"lifetime too short\".\n-        table.size()\n-    };\n-    // There can be at most `size - dib` buckets to displace, because\n-    // in the worst case, there are `size` elements and we already are\n-    // `distance` buckets away from the initial one.\n-    let idx_end = starting_index + size - bucket.distance();\n-\n-    loop {\n-        let (old_hash, old_key, old_val) = bucket.replace(hash, k, v);\n-        loop {\n-            let probe = bucket.next();\n-            assert!(probe.index() != idx_end);\n-\n-            let full_bucket = match probe.peek() {\n-                Empty(bucket) => {\n-                    // Found a hole!\n-                    let b = bucket.put(old_hash, old_key, old_val);\n-                    // Now that it's stolen, just read the value's pointer\n-                    // right out of the table!\n-                    return Bucket::at_index(b.into_table(), starting_index)\n-                               .peek()\n-                               .expect_full()\n-                               .into_mut_refs()\n-                               .1;\n-                },\n-                Full(bucket) => bucket\n-            };\n-\n-            let probe_ib = full_bucket.index() - full_bucket.distance();\n-\n-            bucket = full_bucket;\n-\n-            // Robin hood! Steal the spot.\n-            if ib < probe_ib {\n-                ib = probe_ib;\n-                hash = old_hash;\n-                k = old_key;\n-                v = old_val;\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-/// A result that works like Option<FullBucket<..>> but preserves\n-/// the reference that grants us access to the table in any case.\n-enum SearchResult<K, V, M> {\n-    // This is an entry that holds the given key:\n-    FoundExisting(FullBucket<K, V, M>),\n-\n-    // There was no such entry. The reference is given back:\n-    TableRef(M)\n-}\n-\n-impl<K, V, M> SearchResult<K, V, M> {\n-    fn into_option(self) -> Option<FullBucket<K, V, M>> {\n-        match self {\n-            FoundExisting(bucket) => Some(bucket),\n-            TableRef(_) => None\n-        }\n-    }\n-}\n-\n-impl<K, V, S, H> HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash<H> {\n-        table::make_hash(&self.hash_state, x)\n-    }\n-\n-    /// Search for a key, yielding the index if it's found in the hashtable.\n-    /// If you already have the hash for the key lying around, use\n-    /// search_hashed.\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n-        where K: Borrow<Q>, Q: Eq + Hash<H>\n-    {\n-        let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n-            .into_option()\n-    }\n-\n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n-        where K: Borrow<Q>, Q: Eq + Hash<H>\n-    {\n-        let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n-            .into_option()\n-    }\n-\n-    // The caller should ensure that invariants by Robin Hood Hashing hold.\n-    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n-        let cap = self.table.capacity();\n-        let mut buckets = Bucket::new(&mut self.table, hash);\n-        let ib = buckets.index();\n-\n-        while buckets.index() != ib + cap {\n-            // We don't need to compare hashes for value swap.\n-            // Not even DIBs for Robin Hood.\n-            buckets = match buckets.peek() {\n-                Empty(empty) => {\n-                    empty.put(hash, k, v);\n-                    return;\n-                }\n-                Full(b) => b.into_bucket()\n-            };\n-            buckets.next();\n-        }\n-        panic!(\"Internal HashMap error: Out of space.\");\n-    }\n-}\n-\n-impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n-    /// Create an empty HashMap.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> HashMap<K, V, RandomState> {\n-        Default::default()\n-    }\n-\n-    /// Creates an empty hash map with the given initial capacity.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n-        HashMap::with_capacity_and_hash_state(capacity, Default::default())\n-    }\n-}\n-\n-impl<K, V, S, H> HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    /// Creates an empty hashmap which will use the given hasher to hash keys.\n-    ///\n-    /// The creates map has the default initial capacity.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut map = HashMap::with_hash_state(s);\n-    /// map.insert(1, 2);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n-        HashMap {\n-            hash_state:    hash_state,\n-            resize_policy: DefaultResizePolicy::new(),\n-            table:         RawTable::new(0),\n-        }\n-    }\n-\n-    /// Create an empty HashMap with space for at least `capacity`\n-    /// elements, using `hasher` to hash the keys.\n-    ///\n-    /// Warning: `hasher` is normally randomly generated, and\n-    /// is designed to allow HashMaps to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting it\n-    /// manually using this function can expose a DoS attack vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n-    /// map.insert(1, 2);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n-                                        -> HashMap<K, V, S> {\n-        let resize_policy = DefaultResizePolicy::new();\n-        let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n-        let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n-        assert!(internal_cap >= capacity, \"capacity overflow\");\n-        HashMap {\n-            hash_state:    hash_state,\n-            resize_policy: resize_policy,\n-            table:         RawTable::new(internal_cap),\n-        }\n-    }\n-\n-    /// Returns the number of elements the map can hold without reallocating.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let map: HashMap<int, int> = HashMap::with_capacity(100);\n-    /// assert!(map.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.resize_policy.usable_capacity(self.table.capacity())\n-    }\n-\n-    /// Reserves capacity for at least `additional` more elements to be inserted\n-    /// in the `HashMap`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new allocation size overflows `usize`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n-    /// map.reserve(10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: usize) {\n-        let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n-        let min_cap = self.resize_policy.min_capacity(new_size);\n-\n-        // An invalid value shouldn't make us run out of space. This includes\n-        // an overflow check.\n-        assert!(new_size <= min_cap);\n-\n-        if self.table.capacity() < min_cap {\n-            let new_capacity = max(min_cap.next_power_of_two(), INITIAL_CAPACITY);\n-            self.resize(new_capacity);\n-        }\n-    }\n-\n-    /// Resizes the internal vectors to a new capacity. It's your responsibility to:\n-    ///   1) Make sure the new capacity is enough for all the elements, accounting\n-    ///      for the load factor.\n-    ///   2) Ensure new_capacity is a power of two or zero.\n-    fn resize(&mut self, new_capacity: usize) {\n-        assert!(self.table.size() <= new_capacity);\n-        assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n-\n-        let mut old_table = replace(&mut self.table, RawTable::new(new_capacity));\n-        let old_size = old_table.size();\n-\n-        if old_table.capacity() == 0 || old_table.size() == 0 {\n-            return;\n-        }\n-\n-        // Grow the table.\n-        // Specialization of the other branch.\n-        let mut bucket = Bucket::first(&mut old_table);\n-\n-        // \"So a few of the first shall be last: for many be called,\n-        // but few chosen.\"\n-        //\n-        // We'll most likely encounter a few buckets at the beginning that\n-        // have their initial buckets near the end of the table. They were\n-        // placed at the beginning as the probe wrapped around the table\n-        // during insertion. We must skip forward to a bucket that won't\n-        // get reinserted too early and won't unfairly steal others spot.\n-        // This eliminates the need for robin hood.\n-        loop {\n-            bucket = match bucket.peek() {\n-                Full(full) => {\n-                    if full.distance() == 0 {\n-                        // This bucket occupies its ideal spot.\n-                        // It indicates the start of another \"cluster\".\n-                        bucket = full.into_bucket();\n-                        break;\n-                    }\n-                    // Leaving this bucket in the last cluster for later.\n-                    full.into_bucket()\n-                }\n-                Empty(b) => {\n-                    // Encountered a hole between clusters.\n-                    b.into_bucket()\n-                }\n-            };\n-            bucket.next();\n-        }\n-\n-        // This is how the buckets might be laid out in memory:\n-        // ($ marks an initialized bucket)\n-        //  ________________\n-        // |$$$_$$$$$$_$$$$$|\n-        //\n-        // But we've skipped the entire initial cluster of buckets\n-        // and will continue iteration in this order:\n-        //  ________________\n-        //     |$$$$$$_$$$$$\n-        //                  ^ wrap around once end is reached\n-        //  ________________\n-        //  $$$_____________|\n-        //    ^ exit once table.size == 0\n-        loop {\n-            bucket = match bucket.peek() {\n-                Full(bucket) => {\n-                    let h = bucket.hash();\n-                    let (b, k, v) = bucket.take();\n-                    self.insert_hashed_ordered(h, k, v);\n-                    {\n-                        let t = b.table(); // FIXME \"lifetime too short\".\n-                        if t.size() == 0 { break }\n-                    };\n-                    b.into_bucket()\n-                }\n-                Empty(b) => b.into_bucket()\n-            };\n-            bucket.next();\n-        }\n-\n-        assert_eq!(self.table.size(), old_size);\n-    }\n-\n-    /// Shrinks the capacity of the map as much as possible. It will drop\n-    /// down as much as possible while maintaining the internal rules\n-    /// and possibly leaving some space in accordance with the resize policy.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map: HashMap<int, int> = HashMap::with_capacity(100);\n-    /// map.insert(1, 2);\n-    /// map.insert(3, 4);\n-    /// assert!(map.capacity() >= 100);\n-    /// map.shrink_to_fit();\n-    /// assert!(map.capacity() >= 2);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn shrink_to_fit(&mut self) {\n-        let min_capacity = self.resize_policy.min_capacity(self.len());\n-        let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n-\n-        // An invalid value shouldn't make us run out of space.\n-        debug_assert!(self.len() <= min_capacity);\n-\n-        if self.table.capacity() != min_capacity {\n-            let old_table = replace(&mut self.table, RawTable::new(min_capacity));\n-            let old_size = old_table.size();\n-\n-            // Shrink the table. Naive algorithm for resizing:\n-            for (h, k, v) in old_table.into_iter() {\n-                self.insert_hashed_nocheck(h, k, v);\n-            }\n-\n-            debug_assert_eq!(self.table.size(), old_size);\n-        }\n-    }\n-\n-    /// Insert a pre-hashed key-value pair, without first checking\n-    /// that there's enough room in the buckets. Returns a reference to the\n-    /// newly insert value.\n-    ///\n-    /// If the key already exists, the hashtable will be returned untouched\n-    /// and a reference to the existing element will be returned.\n-    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V {\n-        self.insert_or_replace_with(hash, k, v, |_, _, _| ())\n-    }\n-\n-    fn insert_or_replace_with<'a, F>(&'a mut self,\n-                                     hash: SafeHash,\n-                                     k: K,\n-                                     v: V,\n-                                     mut found_existing: F)\n-                                     -> &'a mut V where\n-        F: FnMut(&mut K, &mut V, V),\n-    {\n-        // Worst case, we'll find one empty bucket among `size + 1` buckets.\n-        let size = self.table.size();\n-        let mut probe = Bucket::new(&mut self.table, hash);\n-        let ib = probe.index();\n-\n-        loop {\n-            let mut bucket = match probe.peek() {\n-                Empty(bucket) => {\n-                    // Found a hole!\n-                    return bucket.put(hash, k, v).into_mut_refs().1;\n-                }\n-                Full(bucket) => bucket\n-            };\n-\n-            // hash matches?\n-            if bucket.hash() == hash {\n-                // key matches?\n-                if k == *bucket.read_mut().0 {\n-                    let (bucket_k, bucket_v) = bucket.into_mut_refs();\n-                    debug_assert!(k == *bucket_k);\n-                    // Key already exists. Get its reference.\n-                    found_existing(bucket_k, bucket_v, v);\n-                    return bucket_v;\n-                }\n-            }\n-\n-            let robin_ib = bucket.index() as int - bucket.distance() as int;\n-\n-            if (ib as int) < robin_ib {\n-                // Found a luckier bucket than me. Better steal his spot.\n-                return robin_hood(bucket, robin_ib as usize, hash, k, v);\n-            }\n-\n-            probe = bucket.next();\n-            assert!(probe.index() != ib + size + 1);\n-        }\n-    }\n-\n-    /// An iterator visiting all keys in arbitrary order.\n-    /// Iterator element type is `&'a K`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for key in map.keys() {\n-    ///     println!(\"{}\", key);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n-\n-        Keys { inner: self.iter().map(first) }\n-    }\n-\n-    /// An iterator visiting all values in arbitrary order.\n-    /// Iterator element type is `&'a V`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for val in map.values() {\n-    ///     println!(\"{}\", val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        fn second<A, B>((_, b): (A, B)) -> B { b }\n-        let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n-\n-        Values { inner: self.iter().map(second) }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order.\n-    /// Iterator element type is `(&'a K, &'a V)`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for (key, val) in map.iter() {\n-    ///     println!(\"key: {} val: {}\", key, val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<K, V> {\n-        Iter { inner: self.table.iter() }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order,\n-    /// with mutable references to the values.\n-    /// Iterator element type is `(&'a K, &'a mut V)`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// // Update all values\n-    /// for (_, val) in map.iter_mut() {\n-    ///     *val *= 2;\n-    /// }\n-    ///\n-    /// for (key, val) in map.iter() {\n-    ///     println!(\"key: {} val: {}\", key, val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n-        IterMut { inner: self.table.iter_mut() }\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each key-value\n-    /// pair out of the map in arbitrary order. The map cannot be used after\n-    /// calling this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// // Not possible with .iter()\n-    /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<K, V> {\n-        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n-        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n-\n-        IntoIter {\n-            inner: self.table.into_iter().map(last_two)\n-        }\n-    }\n-\n-    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, key: K) -> Entry<K, V> {\n-        // Gotta resize now.\n-        self.reserve(1);\n-\n-        let hash = self.make_hash(&key);\n-        search_entry_hashed(&mut self.table, hash, key)\n-    }\n-\n-    /// Returns the number of elements in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// assert_eq!(a.len(), 0);\n-    /// a.insert(1, \"a\");\n-    /// assert_eq!(a.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.table.size() }\n-\n-    /// Returns true if the map contains no elements.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// assert!(a.is_empty());\n-    /// a.insert(1, \"a\");\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n-    /// allocated memory for reuse.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.insert(2, \"b\");\n-    ///\n-    /// for (k, v) in a.drain().take(1) {\n-    ///     assert!(k == 1 || k == 2);\n-    ///     assert!(v == \"a\" || v == \"b\");\n-    /// }\n-    ///\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn drain(&mut self) -> Drain<K, V> {\n-        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n-        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two; // coerce to fn pointer\n-\n-        Drain {\n-            inner: self.table.drain().map(last_two),\n-        }\n-    }\n-\n-    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n-    /// for reuse.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.clear();\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn clear(&mut self) {\n-        self.drain();\n-    }\n-\n-    /// Returns a reference to the value corresponding to the key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the key type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.get(&1), Some(&\"a\"));\n-    /// assert_eq!(map.get(&2), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where K: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.search(k).map(|bucket| bucket.into_refs().1)\n-    }\n-\n-    /// Returns true if the map contains a value for the specified key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the key type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.contains_key(&1), true);\n-    /// assert_eq!(map.contains_key(&2), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where K: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.search(k).is_some()\n-    }\n-\n-    /// Returns a mutable reference to the value corresponding to the key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the key type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(1, \"a\");\n-    /// match map.get_mut(&1) {\n-    ///     Some(x) => *x = \"b\",\n-    ///     None => (),\n-    /// }\n-    /// assert_eq!(map[1], \"b\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where K: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n-    }\n-\n-    /// Inserts a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.insert(37, \"a\"), None);\n-    /// assert_eq!(map.is_empty(), false);\n-    ///\n-    /// map.insert(37, \"b\");\n-    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        let hash = self.make_hash(&k);\n-        self.reserve(1);\n-\n-        let mut retval = None;\n-        self.insert_or_replace_with(hash, k, v, |_, val_ref, val| {\n-            retval = Some(replace(val_ref, val));\n-        });\n-        retval\n-    }\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the key type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), Some(\"a\"));\n-    /// assert_eq!(map.remove(&1), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where K: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        if self.table.size() == 0 {\n-            return None\n-        }\n-\n-        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n-    }\n-}\n-\n-fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n-        -> Entry<'a, K, V>\n-{\n-    // Worst case, we'll find one empty bucket among `size + 1` buckets.\n-    let size = table.size();\n-    let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index();\n-\n-    loop {\n-        let bucket = match probe.peek() {\n-            Empty(bucket) => {\n-                // Found a hole!\n-                return Vacant(VacantEntry {\n-                    hash: hash,\n-                    key: k,\n-                    elem: NoElem(bucket),\n-                });\n-            },\n-            Full(bucket) => bucket\n-        };\n-\n-        // hash matches?\n-        if bucket.hash() == hash {\n-            // key matches?\n-            if k == *bucket.read().0 {\n-                return Occupied(OccupiedEntry{\n-                    elem: bucket,\n-                });\n-            }\n-        }\n-\n-        let robin_ib = bucket.index() as int - bucket.distance() as int;\n-\n-        if (ib as int) < robin_ib {\n-            // Found a luckier bucket than me. Better steal his spot.\n-            return Vacant(VacantEntry {\n-                hash: hash,\n-                key: k,\n-                elem: NeqElem(bucket, robin_ib as usize),\n-            });\n-        }\n-\n-        probe = bucket.next();\n-        assert!(probe.index() != ib + size + 1);\n-    }\n-}\n-\n-impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n-    where K: Eq + Hash<H>, V: PartialEq,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n-        if self.len() != other.len() { return false; }\n-\n-        self.iter().all(|(key, value)|\n-            other.get(key).map_or(false, |v| *value == *v)\n-        )\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Eq for HashMap<K, V, S>\n-    where K: Eq + Hash<H>, V: Eq,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Debug for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Debug, V: Debug,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"HashMap {{\"));\n-\n-        for (i, (k, v)) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{:?}: {:?}\", *k, *v));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Default for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn default() -> HashMap<K, V, S> {\n-        HashMap::with_hash_state(Default::default())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Borrow<Q>,\n-          Q: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = V;\n-\n-    #[inline]\n-    fn index<'a>(&'a self, index: &Q) -> &'a V {\n-        self.get(index).expect(\"no entry found for key\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Borrow<Q>,\n-          Q: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n-        self.get_mut(index).expect(\"no entry found for key\")\n-    }\n-}\n-\n-/// HashMap iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, K: 'a, V: 'a> {\n-    inner: table::Iter<'a, K, V>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, K, V> Clone for Iter<'a, K, V> {\n-    fn clone(&self) -> Iter<'a, K, V> {\n-        Iter {\n-            inner: self.inner.clone()\n-        }\n-    }\n-}\n-\n-/// HashMap mutable values iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, K: 'a, V: 'a> {\n-    inner: table::IterMut<'a, K, V>\n-}\n-\n-/// HashMap move iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<K, V> {\n-    inner: iter::Map<table::IntoIter<K, V>, fn((SafeHash, K, V)) -> (K, V)>\n-}\n-\n-/// HashMap keys iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, K, V> Clone for Keys<'a, K, V> {\n-    fn clone(&self) -> Keys<'a, K, V> {\n-        Keys {\n-            inner: self.inner.clone()\n-        }\n-    }\n-}\n-\n-/// HashMap values iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, K, V> Clone for Values<'a, K, V> {\n-    fn clone(&self) -> Values<'a, K, V> {\n-        Values {\n-            inner: self.inner.clone()\n-        }\n-    }\n-}\n-\n-/// HashMap drain iterator.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"matches collection reform specification, waiting for dust to settle\")]\n-pub struct Drain<'a, K: 'a, V: 'a> {\n-    inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n-}\n-\n-/// A view into a single occupied location in a HashMap.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n-pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n-}\n-\n-/// A view into a single empty location in a HashMap.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n-pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    hash: SafeHash,\n-    key: K,\n-    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n-}\n-\n-/// A view into a single location in a map, which may be vacant or occupied.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n-pub enum Entry<'a, K: 'a, V: 'a> {\n-    /// An occupied Entry.\n-    Occupied(OccupiedEntry<'a, K, V>),\n-    /// A vacant Entry.\n-    Vacant(VacantEntry<'a, K, V>),\n-}\n-\n-/// Possible states of a VacantEntry.\n-enum VacantEntryState<K, V, M> {\n-    /// The index is occupied, but the key to insert has precedence,\n-    /// and will kick the current one out on insertion.\n-    NeqElem(FullBucket<K, V, M>, usize),\n-    /// The index is genuinely vacant.\n-    NoElem(EmptyBucket<K, V, M>),\n-}\n-\n-impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = (&'a K, &'a V);\n-    type IntoIter = Iter<'a, K, V>;\n-\n-    fn into_iter(self) -> Iter<'a, K, V> {\n-        self.iter()\n-    }\n-}\n-\n-impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = (&'a K, &'a mut V);\n-    type IntoIter = IterMut<'a, K, V>;\n-\n-    fn into_iter(mut self) -> IterMut<'a, K, V> {\n-        self.iter_mut()\n-    }\n-}\n-\n-impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = (K, V);\n-    type IntoIter = IntoIter<K, V>;\n-\n-    fn into_iter(self) -> IntoIter<K, V> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Iter<'a, K, V> {\n-    type Item = (&'a K, &'a V);\n-\n-    #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n-    type Item = (&'a K, &'a mut V);\n-\n-    #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> Iterator for IntoIter<K, V> {\n-    type Item = (K, V);\n-\n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Keys<'a, K, V> {\n-    type Item = &'a K;\n-\n-    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Values<'a, K, V> {\n-    type Item = &'a V;\n-\n-    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Drain<'a, K, V> {\n-    type Item = (K, V);\n-\n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[unstable(feature = \"std_misc\",\n-           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n-impl<'a, K, V> Entry<'a, K, V> {\n-    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant.\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n-        match self {\n-            Occupied(entry) => Ok(entry.into_mut()),\n-            Vacant(entry) => Err(entry),\n-        }\n-    }\n-}\n-\n-impl<'a, K, V> OccupiedEntry<'a, K, V> {\n-    /// Gets a reference to the value in the entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> &V {\n-        self.elem.read().1\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut V {\n-        self.elem.read_mut().1\n-    }\n-\n-    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n-    /// with a lifetime bound to the map itself\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_mut(self) -> &'a mut V {\n-        self.elem.into_mut_refs().1\n-    }\n-\n-    /// Sets the value of the entry, and returns the entry's old value\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, mut value: V) -> V {\n-        let old_value = self.get_mut();\n-        mem::swap(&mut value, old_value);\n-        value\n-    }\n-\n-    /// Takes the value out of the entry, and returns it\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(self) -> V {\n-        pop_internal(self.elem).1\n-    }\n-}\n-\n-impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n-    /// Sets the value of the entry with the VacantEntry's key,\n-    /// and returns a mutable reference to it\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n-        match self.elem {\n-            NeqElem(bucket, ib) => {\n-                robin_hood(bucket, ib, self.hash, self.key, value)\n-            }\n-            NoElem(bucket) => {\n-                bucket.put(self.hash, self.key, value).into_mut_refs().1\n-            }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n-        let iter = iter.into_iter();\n-        let lower = iter.size_hint().0;\n-        let mut map = HashMap::with_capacity_and_hash_state(lower,\n-                                                            Default::default());\n-        map.extend(iter);\n-        map\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n-    }\n-}\n-\n-\n-/// `RandomState` is the default state for `HashMap` types.\n-///\n-/// A particular instance `RandomState` will create the same instances of\n-/// `Hasher`, but the hashers created by two different `RandomState`\n-/// instances are unlikely to produce the same result for the same values.\n-#[derive(Clone)]\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-pub struct RandomState {\n-    k0: u64,\n-    k1: u64,\n-}\n-\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-impl RandomState {\n-    /// Construct a new `RandomState` that is initialized with random keys.\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn new() -> RandomState {\n-        let mut r = rand::thread_rng();\n-        RandomState { k0: r.gen(), k1: r.gen() }\n-    }\n-}\n-\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-impl HashState for RandomState {\n-    type Hasher = Hasher;\n-    fn hasher(&self) -> Hasher {\n-        Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n-    }\n-}\n-\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-impl Default for RandomState {\n-    #[inline]\n-    fn default() -> RandomState {\n-        RandomState::new()\n-    }\n-}\n-\n-/// A hasher implementation which is generated from `RandomState` instances.\n-///\n-/// This is the default hasher used in a `HashMap` to hash keys. Types do not\n-/// typically declare an ability to explicitly hash into this particular type,\n-/// but rather in a `H: hash::Writer` type parameter.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-pub struct Hasher { inner: SipHasher }\n-\n-impl hash::Writer for Hasher {\n-    fn write(&mut self, data: &[u8]) {\n-        hash::Writer::write(&mut self.inner, data)\n-    }\n-}\n-\n-impl hash::Hasher for Hasher {\n-    type Output = u64;\n-    fn reset(&mut self) { hash::Hasher::reset(&mut self.inner) }\n-    fn finish(&self) -> u64 { self.inner.finish() }\n-}\n-\n-#[cfg(test)]\n-mod test_map {\n-    use prelude::v1::*;\n-\n-    use super::HashMap;\n-    use super::Entry::{Occupied, Vacant};\n-    use iter::{range_inclusive, range_step_inclusive, repeat};\n-    use cell::RefCell;\n-    use rand::{weak_rng, Rng};\n-\n-    #[test]\n-    fn test_create_capacity_zero() {\n-        let mut m = HashMap::with_capacity(0);\n-\n-        assert!(m.insert(1, 1).is_none());\n-\n-        assert!(m.contains_key(&1));\n-        assert!(!m.contains_key(&0));\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut m = HashMap::new();\n-        assert_eq!(m.len(), 0);\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(m.len(), 1);\n-        assert!(m.insert(2, 4).is_none());\n-        assert_eq!(m.len(), 2);\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&2).unwrap(), 4);\n-    }\n-\n-    thread_local! { static DROP_VECTOR: RefCell<Vec<int>> = RefCell::new(Vec::new()) }\n-\n-    #[derive(Hash, PartialEq, Eq)]\n-    struct Dropable {\n-        k: usize\n-    }\n-\n-    impl Dropable {\n-        fn new(k: usize) -> Dropable {\n-            DROP_VECTOR.with(|slot| {\n-                slot.borrow_mut()[k] += 1;\n-            });\n-\n-            Dropable { k: k }\n-        }\n-    }\n-\n-    impl Drop for Dropable {\n-        fn drop(&mut self) {\n-            DROP_VECTOR.with(|slot| {\n-                slot.borrow_mut()[self.k] -= 1;\n-            });\n-        }\n-    }\n-\n-    impl Clone for Dropable {\n-        fn clone(&self) -> Dropable {\n-            Dropable::new(self.k)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drops() {\n-        DROP_VECTOR.with(|slot| {\n-            *slot.borrow_mut() = repeat(0).take(200).collect();\n-        });\n-\n-        {\n-            let mut m = HashMap::new();\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                }\n-            });\n-\n-            for i in 0..100 {\n-                let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i+100);\n-                m.insert(d1, d2);\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            for i in 0..50 {\n-                let k = Dropable::new(i);\n-                let v = m.remove(&k);\n-\n-                assert!(v.is_some());\n-\n-                DROP_VECTOR.with(|v| {\n-                    assert_eq!(v.borrow()[i], 1);\n-                    assert_eq!(v.borrow()[i+100], 1);\n-                });\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..50 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                    assert_eq!(v.borrow()[i+100], 0);\n-                }\n-\n-                for i in 50..100 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                    assert_eq!(v.borrow()[i+100], 1);\n-                }\n-            });\n-        }\n-\n-        DROP_VECTOR.with(|v| {\n-            for i in 0..200 {\n-                assert_eq!(v.borrow()[i], 0);\n-            }\n-        });\n-    }\n-\n-    #[test]\n-    fn test_move_iter_drops() {\n-        DROP_VECTOR.with(|v| {\n-            *v.borrow_mut() = repeat(0).take(200).collect();\n-        });\n-\n-        let hm = {\n-            let mut hm = HashMap::new();\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                }\n-            });\n-\n-            for i in 0..100 {\n-                let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i+100);\n-                hm.insert(d1, d2);\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            hm\n-        };\n-\n-        // By the way, ensure that cloning doesn't screw up the dropping.\n-        drop(hm.clone());\n-\n-        {\n-            let mut half = hm.into_iter().take(50);\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            for _ in half.by_ref() {}\n-\n-            DROP_VECTOR.with(|v| {\n-                let nk = (0..100).filter(|&i| {\n-                    v.borrow()[i] == 1\n-                }).count();\n-\n-                let nv = (0..100).filter(|&i| {\n-                    v.borrow()[i+100] == 1\n-                }).count();\n-\n-                assert_eq!(nk, 50);\n-                assert_eq!(nv, 50);\n-            });\n-        };\n-\n-        DROP_VECTOR.with(|v| {\n-            for i in 0..200 {\n-                assert_eq!(v.borrow()[i], 0);\n-            }\n-        });\n-    }\n-\n-    #[test]\n-    fn test_empty_pop() {\n-        let mut m: HashMap<int, bool> = HashMap::new();\n-        assert_eq!(m.remove(&0), None);\n-    }\n-\n-    #[test]\n-    fn test_lots_of_insertions() {\n-        let mut m = HashMap::new();\n-\n-        // Try this a few times to make sure we never screw up the hashmap's\n-        // internal state.\n-        for _ in 0..10 {\n-            assert!(m.is_empty());\n-\n-            for i in range_inclusive(1, 1000) {\n-                assert!(m.insert(i, i).is_none());\n-\n-                for j in range_inclusive(1, i) {\n-                    let r = m.get(&j);\n-                    assert_eq!(r, Some(&j));\n-                }\n-\n-                for j in range_inclusive(i+1, 1000) {\n-                    let r = m.get(&j);\n-                    assert_eq!(r, None);\n-                }\n-            }\n-\n-            for i in range_inclusive(1001, 2000) {\n-                assert!(!m.contains_key(&i));\n-            }\n-\n-            // remove forwards\n-            for i in range_inclusive(1, 1000) {\n-                assert!(m.remove(&i).is_some());\n-\n-                for j in range_inclusive(1, i) {\n-                    assert!(!m.contains_key(&j));\n-                }\n-\n-                for j in range_inclusive(i+1, 1000) {\n-                    assert!(m.contains_key(&j));\n-                }\n-            }\n-\n-            for i in range_inclusive(1, 1000) {\n-                assert!(!m.contains_key(&i));\n-            }\n-\n-            for i in range_inclusive(1, 1000) {\n-                assert!(m.insert(i, i).is_none());\n-            }\n-\n-            // remove backwards\n-            for i in range_step_inclusive(1000, 1, -1) {\n-                assert!(m.remove(&i).is_some());\n-\n-                for j in range_inclusive(i, 1000) {\n-                    assert!(!m.contains_key(&j));\n-                }\n-\n-                for j in range_inclusive(1, i-1) {\n-                    assert!(m.contains_key(&j));\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_find_mut() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 12).is_none());\n-        assert!(m.insert(2, 8).is_none());\n-        assert!(m.insert(5, 14).is_none());\n-        let new = 100;\n-        match m.get_mut(&5) {\n-            None => panic!(), Some(x) => *x = new\n-        }\n-        assert_eq!(m.get(&5), Some(&new));\n-    }\n-\n-    #[test]\n-    fn test_insert_overwrite() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert!(!m.insert(1, 3).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 3);\n-    }\n-\n-    #[test]\n-    fn test_insert_conflicts() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(m.insert(5, 3).is_none());\n-        assert!(m.insert(9, 4).is_none());\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-    }\n-\n-    #[test]\n-    fn test_conflict_remove() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert!(m.insert(5, 3).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert!(m.insert(9, 4).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert!(m.remove(&1).is_some());\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(!m.is_empty());\n-        assert!(m.remove(&1).is_some());\n-        assert!(m.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut m = HashMap::new();\n-        m.insert(1, 2);\n-        assert_eq!(m.remove(&1), Some(2));\n-        assert_eq!(m.remove(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_iterate() {\n-        let mut m = HashMap::with_capacity(4);\n-        for i in 0..32 {\n-            assert!(m.insert(i, i*2).is_none());\n-        }\n-        assert_eq!(m.len(), 32);\n-\n-        let mut observed: u32 = 0;\n-\n-        for (k, v) in &m {\n-            assert_eq!(*v, *k * 2);\n-            observed |= 1 << *k;\n-        }\n-        assert_eq!(observed, 0xFFFF_FFFF);\n-    }\n-\n-    #[test]\n-    fn test_keys() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map: HashMap<_, _> = vec.into_iter().collect();\n-        let keys: Vec<_> = map.keys().cloned().collect();\n-        assert_eq!(keys.len(), 3);\n-        assert!(keys.contains(&1));\n-        assert!(keys.contains(&2));\n-        assert!(keys.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_values() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map: HashMap<_, _> = vec.into_iter().collect();\n-        let values: Vec<_> = map.values().cloned().collect();\n-        assert_eq!(values.len(), 3);\n-        assert!(values.contains(&'a'));\n-        assert!(values.contains(&'b'));\n-        assert!(values.contains(&'c'));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let mut m = HashMap::new();\n-        assert!(m.get(&1).is_none());\n-        m.insert(1, 2);\n-        match m.get(&1) {\n-            None => panic!(),\n-            Some(v) => assert_eq!(*v, 2)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut m1 = HashMap::new();\n-        m1.insert(1, 2);\n-        m1.insert(2, 3);\n-        m1.insert(3, 4);\n-\n-        let mut m2 = HashMap::new();\n-        m2.insert(1, 2);\n-        m2.insert(2, 3);\n-\n-        assert!(m1 != m2);\n-\n-        m2.insert(3, 4);\n-\n-        assert_eq!(m1, m2);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut map = HashMap::new();\n-        let empty: HashMap<i32, i32> = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(3, 4);\n-\n-        let map_str = format!(\"{:?}\", map);\n-\n-        assert!(map_str == \"HashMap {1: 2, 3: 4}\" ||\n-                map_str == \"HashMap {3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"HashMap {}\");\n-    }\n-\n-    #[test]\n-    fn test_expand() {\n-        let mut m = HashMap::new();\n-\n-        assert_eq!(m.len(), 0);\n-        assert!(m.is_empty());\n-\n-        let mut i = 0;\n-        let old_cap = m.table.capacity();\n-        while old_cap == m.table.capacity() {\n-            m.insert(i, i);\n-            i += 1;\n-        }\n-\n-        assert_eq!(m.len(), i);\n-        assert!(!m.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_behavior_resize_policy() {\n-        let mut m = HashMap::new();\n-\n-        assert_eq!(m.len(), 0);\n-        assert_eq!(m.table.capacity(), 0);\n-        assert!(m.is_empty());\n-\n-        m.insert(0, 0);\n-        m.remove(&0);\n-        assert!(m.is_empty());\n-        let initial_cap = m.table.capacity();\n-        m.reserve(initial_cap);\n-        let cap = m.table.capacity();\n-\n-        assert_eq!(cap, initial_cap * 2);\n-\n-        let mut i = 0;\n-        for _ in 0..cap * 3 / 4 {\n-            m.insert(i, i);\n-            i += 1;\n-        }\n-        // three quarters full\n-\n-        assert_eq!(m.len(), i);\n-        assert_eq!(m.table.capacity(), cap);\n-\n-        for _ in 0..cap / 4 {\n-            m.insert(i, i);\n-            i += 1;\n-        }\n-        // half full\n-\n-        let new_cap = m.table.capacity();\n-        assert_eq!(new_cap, cap * 2);\n-\n-        for _ in 0..cap / 2 - 1 {\n-            i -= 1;\n-            m.remove(&i);\n-            assert_eq!(m.table.capacity(), new_cap);\n-        }\n-        // A little more than one quarter full.\n-        m.shrink_to_fit();\n-        assert_eq!(m.table.capacity(), cap);\n-        // again, a little more than half full\n-        for _ in 0..cap / 2 - 1 {\n-            i -= 1;\n-            m.remove(&i);\n-        }\n-        m.shrink_to_fit();\n-\n-        assert_eq!(m.len(), i);\n-        assert!(!m.is_empty());\n-        assert_eq!(m.table.capacity(), initial_cap);\n-    }\n-\n-    #[test]\n-    fn test_reserve_shrink_to_fit() {\n-        let mut m = HashMap::new();\n-        m.insert(0, 0);\n-        m.remove(&0);\n-        assert!(m.capacity() >= m.len());\n-        for i in 0..128 {\n-            m.insert(i, i);\n-        }\n-        m.reserve(256);\n-\n-        let usable_cap = m.capacity();\n-        for i in 128..(128 + 256) {\n-            m.insert(i, i);\n-            assert_eq!(m.capacity(), usable_cap);\n-        }\n-\n-        for i in 100..(128 + 256) {\n-            assert_eq!(m.remove(&i), Some(i));\n-        }\n-        m.shrink_to_fit();\n-\n-        assert_eq!(m.len(), 100);\n-        assert!(!m.is_empty());\n-        assert!(m.capacity() >= m.len());\n-\n-        for i in 0..100 {\n-            assert_eq!(m.remove(&i), Some(i));\n-        }\n-        m.shrink_to_fit();\n-        m.insert(0, 0);\n-\n-        assert_eq!(m.len(), 1);\n-        assert!(m.capacity() >= m.len());\n-        assert_eq!(m.remove(&0), Some(0));\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        for &(k, v) in &xs {\n-            assert_eq!(map.get(&k), Some(&v));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_size_hint() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.size_hint(), (3, Some(3)));\n-    }\n-\n-    #[test]\n-    fn test_iter_len() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_mut_size_hint() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter_mut();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.size_hint(), (3, Some(3)));\n-    }\n-\n-    #[test]\n-    fn test_iter_mut_len() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter_mut();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_index() {\n-        let mut map = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        assert_eq!(map[2], 1);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_index_nonexistent() {\n-        let mut map = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        map[4];\n-    }\n-\n-    #[test]\n-    fn test_entry(){\n-        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n-\n-        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        // Existing key (insert)\n-        match map.entry(1) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                assert_eq!(view.get(), &10);\n-                assert_eq!(view.insert(100), 10);\n-            }\n-        }\n-        assert_eq!(map.get(&1).unwrap(), &100);\n-        assert_eq!(map.len(), 6);\n-\n-\n-        // Existing key (update)\n-        match map.entry(2) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                let v = view.get_mut();\n-                let new_v = (*v) * 10;\n-                *v = new_v;\n-            }\n-        }\n-        assert_eq!(map.get(&2).unwrap(), &200);\n-        assert_eq!(map.len(), 6);\n-\n-        // Existing key (take)\n-        match map.entry(3) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(view) => {\n-                assert_eq!(view.remove(), 30);\n-            }\n-        }\n-        assert_eq!(map.get(&3), None);\n-        assert_eq!(map.len(), 5);\n-\n-\n-        // Inexistent key (insert)\n-        match map.entry(10) {\n-            Occupied(_) => unreachable!(),\n-            Vacant(view) => {\n-                assert_eq!(*view.insert(1000), 1000);\n-            }\n-        }\n-        assert_eq!(map.get(&10).unwrap(), &1000);\n-        assert_eq!(map.len(), 6);\n-    }\n-\n-    #[test]\n-    fn test_entry_take_doesnt_corrupt() {\n-        // Test for #19292\n-        fn check(m: &HashMap<isize, ()>) {\n-            for k in m.keys() {\n-                assert!(m.contains_key(k),\n-                        \"{} is in keys() but not in the map?\", k);\n-            }\n-        }\n-\n-        let mut m = HashMap::new();\n-        let mut rng = weak_rng();\n-\n-        // Populate the map with some items.\n-        for _ in 0..50 {\n-            let x = rng.gen_range(-10, 10);\n-            m.insert(x, ());\n-        }\n-\n-        for i in 0..1000 {\n-            let x = rng.gen_range(-10, 10);\n-            match m.entry(x) {\n-                Vacant(_) => {},\n-                Occupied(e) => {\n-                    println!(\"{}: remove {}\", i, x);\n-                    e.remove();\n-                },\n-            }\n-\n-            check(&m);\n-        }\n-    }\n-}"}, {"sha": "47e300af26981da7cd395a6b361bf63704358cb6", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -12,14 +12,6 @@\n \n mod bench;\n mod table;\n-#[cfg(stage0)]\n-#[path = \"map_stage0.rs\"]\n pub mod map;\n-#[cfg(not(stage0))]\n-pub mod map;\n-#[cfg(stage0)]\n-#[path = \"set_stage0.rs\"]\n-pub mod set;\n-#[cfg(not(stage0))]\n pub mod set;\n pub mod state;"}, {"sha": "68c9e02d8ad7205483c7e577506fab2c4f3299a6", "filename": "src/libstd/collections/hash/set_stage0.rs", "status": "removed", "additions": 0, "deletions": 1252, "changes": 1252, "blob_url": "https://github.com/rust-lang/rust/blob/5d7b216f40d13750a31a22ecc20498494f76cbc6/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d7b216f40d13750a31a22ecc20498494f76cbc6/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs?ref=5d7b216f40d13750a31a22ecc20498494f76cbc6", "patch": "@@ -1,1252 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-use borrow::Borrow;\n-use clone::Clone;\n-use cmp::{Eq, PartialEq};\n-use core::marker::Sized;\n-use default::Default;\n-use fmt::Debug;\n-use fmt;\n-use hash::{self, Hash};\n-use iter::{\n-    Iterator, IntoIterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend,\n-};\n-use ops::{BitOr, BitAnd, BitXor, Sub};\n-use option::Option::{Some, None, self};\n-\n-use super::map::{self, HashMap, Keys, INITIAL_CAPACITY, RandomState, Hasher};\n-use super::state::HashState;\n-\n-// Future Optimization (FIXME!)\n-// =============================\n-//\n-// Iteration over zero sized values is a noop. There is no need\n-// for `bucket.val` in the case of HashSet. I suppose we would need HKT\n-// to get rid of it properly.\n-\n-/// An implementation of a hash set using the underlying representation of a\n-/// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n-/// requires that the elements implement the `Eq` and `Hash` traits.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::collections::HashSet;\n-/// // Type inference lets us omit an explicit type signature (which\n-/// // would be `HashSet<&str>` in this example).\n-/// let mut books = HashSet::new();\n-///\n-/// // Add some books.\n-/// books.insert(\"A Dance With Dragons\");\n-/// books.insert(\"To Kill a Mockingbird\");\n-/// books.insert(\"The Odyssey\");\n-/// books.insert(\"The Great Gatsby\");\n-///\n-/// // Check for a specific one.\n-/// if !books.contains(&(\"The Winds of Winter\")) {\n-///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n-///              books.len());\n-/// }\n-///\n-/// // Remove a book.\n-/// books.remove(&\"The Odyssey\");\n-///\n-/// // Iterate over everything.\n-/// for book in books.iter() {\n-///     println!(\"{}\", *book);\n-/// }\n-/// ```\n-///\n-/// The easiest way to use `HashSet` with a custom type is to derive\n-/// `Eq` and `Hash`. We must also derive `PartialEq`, this will in the\n-/// future be implied by `Eq`.\n-///\n-/// ```\n-/// use std::collections::HashSet;\n-/// #[derive(Hash, Eq, PartialEq, Debug)]\n-/// struct Viking<'a> {\n-///     name: &'a str,\n-///     power: usize,\n-/// }\n-///\n-/// let mut vikings = HashSet::new();\n-///\n-/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n-/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n-/// vikings.insert(Viking { name: \"Olaf\", power: 4 });\n-/// vikings.insert(Viking { name: \"Harald\", power: 8 });\n-///\n-/// // Use derived implementation to print the vikings.\n-/// for x in vikings.iter() {\n-///     println!(\"{:?}\", x);\n-/// }\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct HashSet<T, S = RandomState> {\n-    map: HashMap<T, (), S>\n-}\n-\n-impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n-    /// Create an empty HashSet.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::new();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> HashSet<T, RandomState> {\n-        HashSet::with_capacity(INITIAL_CAPACITY)\n-    }\n-\n-    /// Create an empty HashSet with space for at least `n` elements in\n-    /// the hash table.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n-        HashSet { map: HashMap::with_capacity(capacity) }\n-    }\n-}\n-\n-impl<T, S, H> HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    /// Creates a new empty hash set which will use the given hasher to hash\n-    /// keys.\n-    ///\n-    /// The hash set is also created with the default initial capacity.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut set = HashSet::with_hash_state(s);\n-    /// set.insert(2);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n-        HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n-    }\n-\n-    /// Create an empty HashSet with space for at least `capacity`\n-    /// elements in the hash table, using `hasher` to hash the keys.\n-    ///\n-    /// Warning: `hasher` is normally randomly generated, and\n-    /// is designed to allow `HashSet`s to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting it\n-    /// manually using this function can expose a DoS attack vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut set = HashSet::with_capacity_and_hash_state(10, s);\n-    /// set.insert(1);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n-                                        -> HashSet<T, S> {\n-        HashSet {\n-            map: HashMap::with_capacity_and_hash_state(capacity, hash_state),\n-        }\n-    }\n-\n-    /// Returns the number of elements the set can hold without reallocating.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let set: HashSet<int> = HashSet::with_capacity(100);\n-    /// assert!(set.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.map.capacity()\n-    }\n-\n-    /// Reserves capacity for at least `additional` more elements to be inserted\n-    /// in the `HashSet`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new allocation size overflows `usize`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::new();\n-    /// set.reserve(10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: usize) {\n-        self.map.reserve(additional)\n-    }\n-\n-    /// Shrinks the capacity of the set as much as possible. It will drop\n-    /// down as much as possible while maintaining the internal rules\n-    /// and possibly leaving some space in accordance with the resize policy.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set: HashSet<int> = HashSet::with_capacity(100);\n-    /// set.insert(1);\n-    /// set.insert(2);\n-    /// assert!(set.capacity() >= 100);\n-    /// set.shrink_to_fit();\n-    /// assert!(set.capacity() >= 2);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn shrink_to_fit(&mut self) {\n-        self.map.shrink_to_fit()\n-    }\n-\n-    /// An iterator visiting all elements in arbitrary order.\n-    /// Iterator element type is &'a T.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set = HashSet::new();\n-    /// set.insert(\"a\");\n-    /// set.insert(\"b\");\n-    ///\n-    /// // Will print in an arbitrary order.\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<T> {\n-        Iter { iter: self.map.keys() }\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each value out\n-    /// of the set in arbitrary order. The set cannot be used after calling\n-    /// this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set = HashSet::new();\n-    /// set.insert(\"a\".to_string());\n-    /// set.insert(\"b\".to_string());\n-    ///\n-    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n-    /// let v: Vec<String> = set.into_iter().collect();\n-    ///\n-    /// // Will print in an arbitrary order.\n-    /// for x in v.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((T, ())) -> T = first;\n-\n-        IntoIter { iter: self.map.into_iter().map(first) }\n-    }\n-\n-    /// Visit the values representing the difference.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Can be seen as `a - b`.\n-    /// for x in a.difference(&b) {\n-    ///     println!(\"{}\", x); // Print 1\n-    /// }\n-    ///\n-    /// let diff: HashSet<int> = a.difference(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1].iter().map(|&x| x).collect());\n-    ///\n-    /// // Note that difference is not symmetric,\n-    /// // and `b - a` means something else:\n-    /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n-    /// assert_eq!(diff, [4].iter().map(|&x| x).collect());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n-        Difference {\n-            iter: self.iter(),\n-            other: other,\n-        }\n-    }\n-\n-    /// Visit the values representing the symmetric difference.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 4 in arbitrary order.\n-    /// for x in a.symmetric_difference(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff1: HashSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n-    /// let diff2: HashSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1, 4].iter().map(|&x| x).collect());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n-        -> SymmetricDifference<'a, T, S> {\n-        SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n-    }\n-\n-    /// Visit the values representing the intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 2, 3 in arbitrary order.\n-    /// for x in a.intersection(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n-        Intersection {\n-            iter: self.iter(),\n-            other: other,\n-        }\n-    }\n-\n-    /// Visit the values representing the union.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 3, 4 in arbitrary order.\n-    /// for x in a.union(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2, 3, 4].iter().map(|&x| x).collect());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n-        Union { iter: self.iter().chain(other.difference(self)) }\n-    }\n-\n-    /// Return the number of elements in the set\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.map.len() }\n-\n-    /// Returns true if the set contains no elements\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n-\n-    /// Clears the set, returning all elements in an iterator.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n-\n-        Drain { iter: self.map.drain().map(first) }\n-    }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// v.insert(1);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) { self.map.clear() }\n-\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// The value may be any borrowed form of the set's value type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the value type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where T: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.map.contains_key(value)\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// let mut b = HashSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n-        self.iter().all(|v| !other.contains(v))\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n-        self.iter().all(|v| other.contains(v))\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2), true);\n-    /// assert_eq!(set.insert(2), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// The value may be any borrowed form of the set's value type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the value type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where T: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.map.remove(value).is_some()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> PartialEq for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn eq(&self, other: &HashSet<T, S>) -> bool {\n-        if self.len() != other.len() { return false; }\n-\n-        self.iter().all(|key| other.contains(key))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Eq for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> fmt::Debug for HashSet<T, S>\n-    where T: Eq + Hash<H> + fmt::Debug,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"HashSet {{\"));\n-\n-        for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{:?}\", *x));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> FromIterator<T> for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> HashSet<T, S> {\n-        let iter = iter.into_iter();\n-        let lower = iter.size_hint().0;\n-        let mut set = HashSet::with_capacity_and_hash_state(lower, Default::default());\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Extend<T> for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n-        for k in iter {\n-            self.insert(k);\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Default for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> HashSet<T, S> {\n-        HashSet::with_hash_state(Default::default())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = HashSet<T, S>;\n-\n-    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set = &a | &b;\n-    ///\n-    /// let mut i = 0;\n-    /// let expected = [1, 2, 3, 4, 5];\n-    /// for x in set.iter() {\n-    ///     assert!(expected.contains(x));\n-    ///     i += 1;\n-    /// }\n-    /// assert_eq!(i, expected.len());\n-    /// ```\n-    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n-        self.union(rhs).cloned().collect()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = HashSet<T, S>;\n-\n-    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n-    ///\n-    /// let set = &a & &b;\n-    ///\n-    /// let mut i = 0;\n-    /// let expected = [2, 3];\n-    /// for x in set.iter() {\n-    ///     assert!(expected.contains(x));\n-    ///     i += 1;\n-    /// }\n-    /// assert_eq!(i, expected.len());\n-    /// ```\n-    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n-        self.intersection(rhs).cloned().collect()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = HashSet<T, S>;\n-\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set = &a ^ &b;\n-    ///\n-    /// let mut i = 0;\n-    /// let expected = [1, 2, 4, 5];\n-    /// for x in set.iter() {\n-    ///     assert!(expected.contains(x));\n-    ///     i += 1;\n-    /// }\n-    /// assert_eq!(i, expected.len());\n-    /// ```\n-    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n-        self.symmetric_difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = HashSet<T, S>;\n-\n-    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set = &a - &b;\n-    ///\n-    /// let mut i = 0;\n-    /// let expected = [1, 2];\n-    /// for x in set.iter() {\n-    ///     assert!(expected.contains(x));\n-    ///     i += 1;\n-    /// }\n-    /// assert_eq!(i, expected.len());\n-    /// ```\n-    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n-        self.difference(rhs).cloned().collect()\n-    }\n-}\n-\n-/// HashSet iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, K: 'a> {\n-    iter: Keys<'a, K, ()>\n-}\n-\n-/// HashSet move iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<K> {\n-    iter: Map<map::IntoIter<K, ()>, fn((K, ())) -> K>\n-}\n-\n-/// HashSet drain iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Drain<'a, K: 'a> {\n-    iter: Map<map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n-}\n-\n-/// Intersection iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Intersection<'a, T: 'a, S: 'a> {\n-    // iterator of the first set\n-    iter: Iter<'a, T>,\n-    // the second set\n-    other: &'a HashSet<T, S>,\n-}\n-\n-/// Difference iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Difference<'a, T: 'a, S: 'a> {\n-    // iterator of the first set\n-    iter: Iter<'a, T>,\n-    // the second set\n-    other: &'a HashSet<T, S>,\n-}\n-\n-/// Symmetric difference iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n-    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n-}\n-\n-/// Set union iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T: 'a, S: 'a> {\n-    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n-}\n-\n-impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-impl<T, S, H> IntoIterator for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = T;\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K> Iterator for Iter<'a, K> {\n-    type Item = &'a K;\n-\n-    fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K> Iterator for IntoIter<K> {\n-    type Item = K;\n-\n-    fn next(&mut self) -> Option<K> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K> ExactSizeIterator for IntoIter<K> {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K> Iterator for Drain<'a, K> {\n-    type Item = K;\n-\n-    fn next(&mut self) -> Option<K> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match self.iter.next() {\n-                None => return None,\n-                Some(elt) => if self.other.contains(elt) {\n-                    return Some(elt)\n-                },\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match self.iter.next() {\n-                None => return None,\n-                Some(elt) => if !self.other.contains(elt) {\n-                    return Some(elt)\n-                },\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Union<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-#[cfg(test)]\n-mod test_set {\n-    use prelude::v1::*;\n-\n-    use super::HashSet;\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = HashSet::new();\n-        let mut ys = HashSet::new();\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5));\n-        assert!(ys.insert(11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(7));\n-        assert!(xs.insert(19));\n-        assert!(xs.insert(4));\n-        assert!(ys.insert(2));\n-        assert!(ys.insert(-11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(ys.insert(7));\n-        assert!(!xs.is_disjoint(&ys));\n-        assert!(!ys.is_disjoint(&xs));\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = HashSet::new();\n-        assert!(a.insert(0));\n-        assert!(a.insert(5));\n-        assert!(a.insert(11));\n-        assert!(a.insert(7));\n-\n-        let mut b = HashSet::new();\n-        assert!(b.insert(0));\n-        assert!(b.insert(7));\n-        assert!(b.insert(19));\n-        assert!(b.insert(250));\n-        assert!(b.insert(11));\n-        assert!(b.insert(200));\n-\n-        assert!(!a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(!b.is_superset(&a));\n-\n-        assert!(b.insert(5));\n-\n-        assert!(a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(b.is_superset(&a));\n-    }\n-\n-    #[test]\n-    fn test_iterate() {\n-        let mut a = HashSet::new();\n-        for i in 0..32 {\n-            assert!(a.insert(i));\n-        }\n-        let mut observed: u32 = 0;\n-        for k in &a {\n-            observed |= 1 << *k;\n-        }\n-        assert_eq!(observed, 0xFFFF_FFFF);\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(11));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(77));\n-        assert!(a.insert(103));\n-        assert!(a.insert(5));\n-        assert!(a.insert(-5));\n-\n-        assert!(b.insert(2));\n-        assert!(b.insert(11));\n-        assert!(b.insert(77));\n-        assert!(b.insert(-9));\n-        assert!(b.insert(-42));\n-        assert!(b.insert(5));\n-        assert!(b.insert(3));\n-\n-        let mut i = 0;\n-        let expected = [3, 5, 11, 77];\n-        for x in a.intersection(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-\n-        let mut i = 0;\n-        let expected = [1, 5, 11];\n-        for x in a.difference(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(-2));\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-        assert!(b.insert(14));\n-        assert!(b.insert(22));\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 5, 11, 14, 22];\n-        for x in a.symmetric_difference(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-        assert!(a.insert(16));\n-        assert!(a.insert(19));\n-        assert!(a.insert(24));\n-\n-        assert!(b.insert(-2));\n-        assert!(b.insert(1));\n-        assert!(b.insert(5));\n-        assert!(b.insert(9));\n-        assert!(b.insert(13));\n-        assert!(b.insert(19));\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        for x in a.union(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n-\n-        let set: HashSet<_> = xs.iter().cloned().collect();\n-\n-        for x in &xs {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let hs = {\n-            let mut hs = HashSet::new();\n-\n-            hs.insert('a');\n-            hs.insert('b');\n-\n-            hs\n-        };\n-\n-        let v = hs.into_iter().collect::<Vec<char>>();\n-        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        // These constants once happened to expose a bug in insert().\n-        // I'm keeping them around to prevent a regression.\n-        let mut s1 = HashSet::new();\n-\n-        s1.insert(1);\n-        s1.insert(2);\n-        s1.insert(3);\n-\n-        let mut s2 = HashSet::new();\n-\n-        s2.insert(1);\n-        s2.insert(2);\n-\n-        assert!(s1 != s2);\n-\n-        s2.insert(3);\n-\n-        assert_eq!(s1, s2);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set = HashSet::new();\n-        let empty = HashSet::<i32>::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{:?}\", set);\n-\n-        assert!(set_str == \"HashSet {1, 2}\" || set_str == \"HashSet {2, 1}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"HashSet {}\");\n-    }\n-\n-    #[test]\n-    fn test_trivial_drain() {\n-        let mut s = HashSet::<i32>::new();\n-        for _ in s.drain() {}\n-        assert!(s.is_empty());\n-        drop(s);\n-\n-        let mut s = HashSet::<i32>::new();\n-        drop(s.drain());\n-        assert!(s.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-        let mut s: HashSet<_> = (1..100).collect();\n-\n-        // try this a bunch of times to make sure we don't screw up internal state.\n-        for _ in 0..20 {\n-            assert_eq!(s.len(), 99);\n-\n-            {\n-                let mut last_i = 0;\n-                let mut d = s.drain();\n-                for (i, x) in d.by_ref().take(50).enumerate() {\n-                    last_i = i;\n-                    assert!(x != 0);\n-                }\n-                assert_eq!(last_i, 49);\n-            }\n-\n-            for _ in &s { panic!(\"s should be empty!\"); }\n-\n-            // reset to try again.\n-            s.extend(1..100);\n-        }\n-    }\n-}"}, {"sha": "7513cb8a61c7c63f77f20c7f2bb813f5b049b786", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -143,25 +143,6 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n-#[cfg(stage0)]\n-pub fn make_hash<T: ?Sized, S, H>(hash_state: &S, t: &T) -> SafeHash\n-    where T: Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: Hasher<Output=u64>\n-{\n-    let mut state = hash_state.hasher();\n-    t.hash(&mut state);\n-    // We need to avoid 0u64 in order to prevent collisions with\n-    // EMPTY_HASH. We can maintain our precious uniform distribution\n-    // of initial indexes by unconditionally setting the MSB,\n-    // effectively reducing 64-bits hashes to 63 bits.\n-    SafeHash { hash: 0x8000_0000_0000_0000 | state.finish() }\n-}\n-\n-/// We need to remove hashes of 0. That's reserved for empty buckets.\n-/// This function wraps up `hash_keyed` to be the only way outside this\n-/// module to generate a SafeHash.\n-#[cfg(not(stage0))]\n pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash\n     where T: Hash, S: HashState\n {"}, {"sha": "fe0df1728efc0bd34559941d394346acc3d0a63d", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -41,7 +41,6 @@ use string::{String, CowString};\n use ops;\n use cmp;\n use hash::{Hash, Hasher};\n-#[cfg(stage0)] use hash::Writer;\n use old_path::{Path, GenericPath};\n \n use sys::os_str::{Buf, Slice};\n@@ -163,14 +162,6 @@ impl Ord for OsString {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'a, S: Hasher + Writer> Hash<S> for OsString {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (&**self).hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hash for OsString {\n     #[inline]\n@@ -263,14 +254,6 @@ impl Ord for OsStr {\n     fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }\n }\n \n-#[cfg(stage0)]\n-impl<'a, S: Hasher + Writer> Hash<S> for OsStr {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.bytes().hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hash for OsStr {\n     #[inline]"}, {"sha": "f16f501c46a19006ff789b01839a71f054684528", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -147,21 +147,6 @@ impl PartialEq for Repr {\n }\n impl Eq for Repr {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Repr {\n-    fn hash(&self, s: &mut S) {\n-        match *self {\n-            Repr::V4(ref a) => {\n-                (a.sin_family, a.sin_port, a.sin_addr.s_addr).hash(s)\n-            }\n-            Repr::V6(ref a) => {\n-                (a.sin6_family, a.sin6_port, &a.sin6_addr.s6_addr,\n-                 a.sin6_flowinfo, a.sin6_scope_id).hash(s)\n-            }\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Repr {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {"}, {"sha": "d699886e57747dbbf2ca041d9f94271564f6a72c", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -189,13 +189,6 @@ impl PartialEq for Ipv4Addr {\n }\n impl Eq for Ipv4Addr {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv4Addr {\n-    fn hash(&self, s: &mut S) {\n-        self.inner.s_addr.hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Ipv4Addr {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {\n@@ -429,13 +422,6 @@ impl PartialEq for Ipv6Addr {\n }\n impl Eq for Ipv6Addr {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv6Addr {\n-    fn hash(&self, s: &mut S) {\n-        self.inner.s6_addr.hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Ipv6Addr {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {"}, {"sha": "a13295b1ccb5014ea8137156559b628cca769547", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -104,19 +104,7 @@ struct EnvKey(CString);\n #[derive(Eq, Clone, Debug)]\n struct EnvKey(CString);\n \n-#[cfg(all(windows, stage0))]\n-impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for EnvKey {\n-    fn hash(&self, state: &mut H) {\n-        let &EnvKey(ref x) = self;\n-        match str::from_utf8(x.as_bytes()) {\n-            Ok(s) => for ch in s.chars() {\n-                (ch as u8 as char).to_lowercase().hash(state);\n-            },\n-            Err(..) => x.hash(state)\n-        }\n-    }\n-}\n-#[cfg(all(windows, not(stage0)))]\n+#[cfg(windows)]\n impl hash::Hash for EnvKey {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         let &EnvKey(ref x) = self;"}, {"sha": "8d5765e1ffe5e929f3c386e62d54d11d97fc053e", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -100,14 +100,6 @@ impl FromStr for Path {\n #[derive(Debug, Clone, PartialEq, Copy)]\n pub struct ParsePathError;\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.repr.hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Path {\n     #[inline]"}, {"sha": "31a2be1daf3594146b6721f7001bc87d235aaa21", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -127,21 +127,6 @@ impl FromStr for Path {\n #[derive(Debug, Clone, PartialEq, Copy)]\n pub struct ParsePathError;\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n-    #[cfg(not(test))]\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.repr.hash(state)\n-    }\n-\n-    #[cfg(test)]\n-    #[inline]\n-    fn hash(&self, _: &mut S) {\n-        // No-op because the `hash` implementation will be wrong.\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Path {\n     #[cfg(not(test))]"}, {"sha": "9119a3c60d855a3d2b0e2b87b1ad9e006b698259", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -32,7 +32,6 @@ use borrow::Cow;\n use cmp;\n use fmt;\n use hash::{Hash, Hasher};\n-#[cfg(stage0)] use hash::Writer;\n use iter::{FromIterator, IntoIterator};\n use mem;\n use num::Int;\n@@ -796,30 +795,13 @@ impl<'a> Iterator for EncodeWide<'a> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Writer + Hasher> Hash<S> for CodePoint {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.value.hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl Hash for CodePoint {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.value.hash(state)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Writer + Hasher> Hash<S> for Wtf8Buf {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(&self.bytes);\n-        0xfeu8.hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl Hash for Wtf8Buf {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n@@ -828,15 +810,6 @@ impl Hash for Wtf8Buf {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'a, S: Writer + Hasher> Hash<S> for Wtf8 {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(&self.bytes);\n-        0xfeu8.hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl Hash for Wtf8 {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "2be841989e6b355b02676f04cd5a04112c9f2446", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -12,8 +12,6 @@ use prelude::v1::*;\n use self::Req::*;\n \n use collections::HashMap;\n-#[cfg(stage0)]\n-use collections::hash_map::Hasher;\n use ffi::CString;\n use hash::Hash;\n use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n@@ -64,223 +62,6 @@ impl Process {\n         mkerr_libc(r)\n     }\n \n-    #[cfg(stage0)]\n-    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n-                              out_fd: Option<P>, err_fd: Option<P>)\n-                              -> IoResult<Process>\n-        where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n-              K: BytesContainer + Eq + Hash<Hasher>, V: BytesContainer\n-    {\n-        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-\n-        mod rustrt {\n-            extern {\n-                pub fn rust_unset_sigprocmask();\n-            }\n-        }\n-\n-        #[cfg(all(target_os = \"android\", target_arch = \"aarch64\"))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::sysconf(libc::consts::os::sysconf::_SC_OPEN_MAX) as c_int\n-        }\n-        #[cfg(not(all(target_os = \"android\", target_arch = \"aarch64\")))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::funcs::bsd44::getdtablesize()\n-        }\n-\n-        unsafe fn set_cloexec(fd: c_int) {\n-            let ret = c::ioctl(fd, c::FIOCLEX);\n-            assert_eq!(ret, 0);\n-        }\n-\n-        let dirp = cfg.cwd().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n-\n-        // temporary until unboxed closures land\n-        let cfg = unsafe {\n-            mem::transmute::<&ProcessConfig<K,V>,&'static ProcessConfig<K,V>>(cfg)\n-        };\n-\n-        with_envp(cfg.env(), move|envp: *const c_void| {\n-            with_argv(cfg.program(), cfg.args(), move|argv: *const *const libc::c_char| unsafe {\n-                let (input, mut output) = try!(sys::os::pipe());\n-\n-                // We may use this in the child, so perform allocations before the\n-                // fork\n-                let devnull = b\"/dev/null\\0\";\n-\n-                set_cloexec(output.fd());\n-\n-                let pid = fork();\n-                if pid < 0 {\n-                    return Err(super::last_error())\n-                } else if pid > 0 {\n-                    #[inline]\n-                    fn combine(arr: &[u8]) -> i32 {\n-                        let a = arr[0] as u32;\n-                        let b = arr[1] as u32;\n-                        let c = arr[2] as u32;\n-                        let d = arr[3] as u32;\n-\n-                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n-                    }\n-\n-                    let p = Process{ pid: pid };\n-                    drop(output);\n-                    let mut bytes = [0; 8];\n-                    return match input.read(&mut bytes) {\n-                        Ok(8) => {\n-                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                                \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                            let errno = combine(&bytes[0.. 4]);\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            Err(super::decode_error(errno))\n-                        }\n-                        Err(ref e) if e.kind == EndOfFile => Ok(p),\n-                        Err(e) => {\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                        },\n-                        Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            panic!(\"short read on the CLOEXEC pipe\")\n-                        }\n-                    };\n-                }\n-\n-                // And at this point we've reached a special time in the life of the\n-                // child. The child must now be considered hamstrung and unable to\n-                // do anything other than syscalls really. Consider the following\n-                // scenario:\n-                //\n-                //      1. Thread A of process 1 grabs the malloc() mutex\n-                //      2. Thread B of process 1 forks(), creating thread C\n-                //      3. Thread C of process 2 then attempts to malloc()\n-                //      4. The memory of process 2 is the same as the memory of\n-                //         process 1, so the mutex is locked.\n-                //\n-                // This situation looks a lot like deadlock, right? It turns out\n-                // that this is what pthread_atfork() takes care of, which is\n-                // presumably implemented across platforms. The first thing that\n-                // threads to *before* forking is to do things like grab the malloc\n-                // mutex, and then after the fork they unlock it.\n-                //\n-                // Despite this information, libnative's spawn has been witnessed to\n-                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n-                // all collected backtraces point at malloc/free traffic in the\n-                // child spawned process.\n-                //\n-                // For this reason, the block of code below should contain 0\n-                // invocations of either malloc of free (or their related friends).\n-                //\n-                // As an example of not having malloc/free traffic, we don't close\n-                // this file descriptor by dropping the FileDesc (which contains an\n-                // allocation). Instead we just close it manually. This will never\n-                // have the drop glue anyway because this code never returns (the\n-                // child will either exec() or invoke libc::exit)\n-                let _ = libc::close(input.fd());\n-\n-                fn fail(output: &mut FileDesc) -> ! {\n-                    let errno = sys::os::errno() as u32;\n-                    let bytes = [\n-                        (errno >> 24) as u8,\n-                        (errno >> 16) as u8,\n-                        (errno >>  8) as u8,\n-                        (errno >>  0) as u8,\n-                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                    ];\n-                    // pipe I/O up to PIPE_BUF bytes should be atomic\n-                    assert!(output.write(&bytes).is_ok());\n-                    unsafe { libc::_exit(1) }\n-                }\n-\n-                rustrt::rust_unset_sigprocmask();\n-\n-                // If a stdio file descriptor is set to be ignored (via a -1 file\n-                // descriptor), then we don't actually close it, but rather open\n-                // up /dev/null into that file descriptor. Otherwise, the first file\n-                // descriptor opened up in the child would be numbered as one of the\n-                // stdio file descriptors, which is likely to wreak havoc.\n-                let setup = |src: Option<P>, dst: c_int| {\n-                    let src = match src {\n-                        None => {\n-                            let flags = if dst == libc::STDIN_FILENO {\n-                                libc::O_RDONLY\n-                            } else {\n-                                libc::O_RDWR\n-                            };\n-                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n-                        }\n-                        Some(obj) => {\n-                            let fd = obj.as_inner().fd();\n-                            // Leak the memory and the file descriptor. We're in the\n-                            // child now an all our resources are going to be\n-                            // cleaned up very soon\n-                            mem::forget(obj);\n-                            fd\n-                        }\n-                    };\n-                    src != -1 && retry(|| dup2(src, dst)) != -1\n-                };\n-\n-                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n-                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n-                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n-\n-                // close all other fds\n-                for fd in (3..getdtablesize()).rev() {\n-                    if fd != output.fd() {\n-                        let _ = close(fd as c_int);\n-                    }\n-                }\n-\n-                match cfg.gid() {\n-                    Some(u) => {\n-                        if libc::setgid(u as libc::gid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                match cfg.uid() {\n-                    Some(u) => {\n-                        // When dropping privileges from root, the `setgroups` call\n-                        // will remove any extraneous groups. If we don't call this,\n-                        // then even though our uid has dropped, we may still have\n-                        // groups that enable us to do super-user things. This will\n-                        // fail if we aren't root, so don't bother checking the\n-                        // return value, this is just done as an optimistic\n-                        // privilege dropping function.\n-                        extern {\n-                            fn setgroups(ngroups: libc::c_int,\n-                                         ptr: *const libc::c_void) -> libc::c_int;\n-                        }\n-                        let _ = setgroups(0, ptr::null());\n-\n-                        if libc::setuid(u as libc::uid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                if cfg.detach() {\n-                    // Don't check the error of setsid because it fails if we're the\n-                    // process leader already. We just forked so it shouldn't return\n-                    // error, but ignore it anyway.\n-                    let _ = libc::setsid();\n-                }\n-                if !dirp.is_null() && chdir(dirp) == -1 {\n-                    fail(&mut output);\n-                }\n-                if !envp.is_null() {\n-                    *sys::os::environ() = envp as *const _;\n-                }\n-                let _ = execvp(*argv, argv as *mut _);\n-                fail(&mut output);\n-            })\n-        })\n-    }\n-    #[cfg(not(stage0))]\n     pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n@@ -766,45 +547,6 @@ fn with_argv<T,F>(prog: &CString, args: &[CString],\n     cb(ptrs.as_ptr())\n }\n \n-#[cfg(stage0)]\n-fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n-                      cb: F)\n-                      -> T\n-    where F : FnOnce(*const c_void) -> T,\n-          K : BytesContainer + Eq + Hash<Hasher>,\n-          V : BytesContainer\n-{\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\0\" strings. Since we must create\n-    // these strings locally, yet expose a raw pointer to them, we\n-    // create a temporary vector to own the CStrings that outlives the\n-    // call to cb.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = Vec::with_capacity(env.len());\n-\n-            for pair in env {\n-                let mut kv = Vec::new();\n-                kv.push_all(pair.0.container_as_bytes());\n-                kv.push('=' as u8);\n-                kv.push_all(pair.1.container_as_bytes());\n-                kv.push(0); // terminating null\n-                tmps.push(kv);\n-            }\n-\n-            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*const libc::c_char> =\n-                tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                    .collect();\n-            ptrs.push(ptr::null());\n-\n-            cb(ptrs.as_ptr() as *const c_void)\n-        }\n-        _ => cb(ptr::null())\n-    }\n-}\n-#[cfg(not(stage0))]\n fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n                       cb: F)\n                       -> T"}, {"sha": "334cafd3eb1136767fa4cc355360e44aafa50183", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -10,7 +10,6 @@\n \n use prelude::v1::*;\n \n-#[cfg(stage0)] use collections::hash_map::Hasher;\n use collections;\n use env;\n use ffi::CString;\n@@ -106,170 +105,6 @@ impl Process {\n     }\n \n     #[allow(deprecated)]\n-    #[cfg(stage0)]\n-    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n-                              out_fd: Option<P>, err_fd: Option<P>)\n-                              -> IoResult<Process>\n-        where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n-              K: BytesContainer + Eq + Hash<Hasher>, V: BytesContainer\n-    {\n-        use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-        use libc::consts::os::extra::{\n-            TRUE, FALSE,\n-            STARTF_USESTDHANDLES,\n-            INVALID_HANDLE_VALUE,\n-            DUPLICATE_SAME_ACCESS\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            GetCurrentProcess,\n-            DuplicateHandle,\n-            CloseHandle,\n-            CreateProcessW\n-        };\n-        use libc::funcs::extra::msvcrt::get_osfhandle;\n-\n-        use mem;\n-        use iter::IteratorExt;\n-        use str::StrExt;\n-\n-        if cfg.gid().is_some() || cfg.uid().is_some() {\n-            return Err(IoError {\n-                kind: old_io::IoUnavailable,\n-                desc: \"unsupported gid/uid requested on windows\",\n-                detail: None,\n-            })\n-        }\n-\n-        // To have the spawning semantics of unix/windows stay the same, we need to\n-        // read the *child's* PATH if one is provided. See #15149 for more details.\n-        let program = cfg.env().and_then(|env| {\n-            for (key, v) in env {\n-                if b\"PATH\" != key.container_as_bytes() { continue }\n-\n-                // Split the value and test each path to see if the\n-                // program exists.\n-                for path in os::split_paths(v.container_as_bytes()) {\n-                    let path = path.join(cfg.program().as_bytes())\n-                                   .with_extension(env::consts::EXE_EXTENSION);\n-                    if path.exists() {\n-                        return Some(CString::from_slice(path.as_vec()))\n-                    }\n-                }\n-                break\n-            }\n-            None\n-        });\n-\n-        unsafe {\n-            let mut si = zeroed_startupinfo();\n-            si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n-            si.dwFlags = STARTF_USESTDHANDLES;\n-\n-            let cur_proc = GetCurrentProcess();\n-\n-            // Similarly to unix, we don't actually leave holes for the stdio file\n-            // descriptors, but rather open up /dev/null equivalents. These\n-            // equivalents are drawn from libuv's windows process spawning.\n-            let set_fd = |fd: &Option<P>, slot: &mut HANDLE,\n-                          is_stdin: bool| {\n-                match *fd {\n-                    None => {\n-                        let access = if is_stdin {\n-                            libc::FILE_GENERIC_READ\n-                        } else {\n-                            libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n-                        };\n-                        let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n-                        let mut sa = libc::SECURITY_ATTRIBUTES {\n-                            nLength: size as libc::DWORD,\n-                            lpSecurityDescriptor: ptr::null_mut(),\n-                            bInheritHandle: 1,\n-                        };\n-                        let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n-                        filename.push(0);\n-                        *slot = libc::CreateFileW(filename.as_ptr(),\n-                                                  access,\n-                                                  libc::FILE_SHARE_READ |\n-                                                      libc::FILE_SHARE_WRITE,\n-                                                  &mut sa,\n-                                                  libc::OPEN_EXISTING,\n-                                                  0,\n-                                                  ptr::null_mut());\n-                        if *slot == INVALID_HANDLE_VALUE {\n-                            return Err(super::last_error())\n-                        }\n-                    }\n-                    Some(ref fd) => {\n-                        let orig = get_osfhandle(fd.as_inner().fd()) as HANDLE;\n-                        if orig == INVALID_HANDLE_VALUE {\n-                            return Err(super::last_error())\n-                        }\n-                        if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n-                                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                            return Err(super::last_error())\n-                        }\n-                    }\n-                }\n-                Ok(())\n-            };\n-\n-            try!(set_fd(&in_fd, &mut si.hStdInput, true));\n-            try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n-            try!(set_fd(&err_fd, &mut si.hStdError, false));\n-\n-            let cmd_str = make_command_line(program.as_ref().unwrap_or(cfg.program()),\n-                                            cfg.args());\n-            let mut pi = zeroed_process_information();\n-            let mut create_err = None;\n-\n-            // stolen from the libuv code.\n-            let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n-            if cfg.detach() {\n-                flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n-            }\n-\n-            with_envp(cfg.env(), |envp| {\n-                with_dirp(cfg.cwd(), |dirp| {\n-                    let mut cmd_str: Vec<u16> = cmd_str.utf16_units().collect();\n-                    cmd_str.push(0);\n-                    let _lock = CREATE_PROCESS_LOCK.lock().unwrap();\n-                    let created = CreateProcessW(ptr::null(),\n-                                                 cmd_str.as_mut_ptr(),\n-                                                 ptr::null_mut(),\n-                                                 ptr::null_mut(),\n-                                                 TRUE,\n-                                                 flags, envp, dirp,\n-                                                 &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(super::last_error());\n-                    }\n-                })\n-            });\n-\n-            assert!(CloseHandle(si.hStdInput) != 0);\n-            assert!(CloseHandle(si.hStdOutput) != 0);\n-            assert!(CloseHandle(si.hStdError) != 0);\n-\n-            match create_err {\n-                Some(err) => return Err(err),\n-                None => {}\n-            }\n-\n-            // We close the thread handle because we don't care about keeping the\n-            // thread id valid, and we aren't keeping the thread handle around to be\n-            // able to close it later. We don't close the process handle however\n-            // because std::we want the process id to stay valid at least until the\n-            // calling code closes the process handle.\n-            assert!(CloseHandle(pi.hThread) != 0);\n-\n-            Ok(Process {\n-                pid: pi.dwProcessId as pid_t,\n-                handle: pi.hProcess as *mut ()\n-            })\n-        }\n-    }\n-    #[allow(deprecated)]\n-    #[cfg(not(stage0))]\n     pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n@@ -589,35 +424,6 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     }\n }\n \n-#[cfg(stage0)]\n-fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T\n-    where K: BytesContainer + Eq + Hash<Hasher>,\n-          V: BytesContainer,\n-          F: FnOnce(*mut c_void) -> T,\n-{\n-    // On Windows we pass an \"environment block\" which is not a char**, but\n-    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n-    // \\0 to terminate.\n-    match env {\n-        Some(env) => {\n-            let mut blk = Vec::new();\n-\n-            for pair in env {\n-                let kv = format!(\"{}={}\",\n-                                 pair.0.container_as_str().unwrap(),\n-                                 pair.1.container_as_str().unwrap());\n-                blk.extend(kv.utf16_units());\n-                blk.push(0);\n-            }\n-\n-            blk.push(0);\n-\n-            cb(blk.as_mut_ptr() as *mut c_void)\n-        }\n-        _ => cb(ptr::null_mut())\n-    }\n-}\n-#[cfg(not(stage0))]\n fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T\n     where K: BytesContainer + Eq + Hash,\n           V: BytesContainer,"}, {"sha": "5bede984f13c7bc37bdb9bb00ccc443419664340", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -17,9 +17,6 @@ use core::marker::Send;\n use core::ops::FnOnce;\n \n pub struct Thunk<'a, A=(),R=()> {\n-    #[cfg(stage0)]\n-    invoke: Box<Invoke<A,R>+Send>,\n-    #[cfg(not(stage0))]\n     invoke: Box<Invoke<A,R>+Send + 'a>,\n }\n "}, {"sha": "ca3a1848c3a6161313590be914a2b5d1a2756302", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -111,13 +111,6 @@ impl<T: Display> Display for P<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Hasher, T: Hash<S>> Hash<S> for P<T> {\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T: Hash> Hash for P<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);"}, {"sha": "5be45a2698f40ae34c295c3e2e892994d465fc2a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -18,7 +18,6 @@ use std::borrow::Borrow;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::HashMap;\n-#[cfg(stage0)] use std::collections::hash_map::Hasher;\n use std::fmt;\n use std::hash::Hash;\n use std::ops::Deref;\n@@ -30,71 +29,6 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n-#[cfg(stage0)]\n-impl<T: Eq + Hash<Hasher> + Clone + 'static> Interner<T> {\n-    pub fn new() -> Interner<T> {\n-        Interner {\n-            map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(Vec::new()),\n-        }\n-    }\n-\n-    pub fn prefill(init: &[T]) -> Interner<T> {\n-        let rv = Interner::new();\n-        for v in init {\n-            rv.intern((*v).clone());\n-        }\n-        rv\n-    }\n-\n-    pub fn intern(&self, val: T) -> Name {\n-        let mut map = self.map.borrow_mut();\n-        match (*map).get(&val) {\n-            Some(&idx) => return idx,\n-            None => (),\n-        }\n-\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        (*map).insert(val.clone(), new_idx);\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn gensym(&self, val: T) -> Name {\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        // leave out of .map to avoid colliding\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn get(&self, idx: Name) -> T {\n-        let vect = self.vect.borrow();\n-        (*vect)[idx.usize()].clone()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        let vect = self.vect.borrow();\n-        (*vect).len()\n-    }\n-\n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where T: Borrow<Q>, Q: Eq + Hash<Hasher> {\n-        let map = self.map.borrow();\n-        match (*map).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n-    }\n-\n-    pub fn clear(&self) {\n-        *self.map.borrow_mut() = HashMap::new();\n-        *self.vect.borrow_mut() = Vec::new();\n-    }\n-}\n-// when traits can extend traits, we should extend index<Name,T> to get []\n-#[cfg(not(stage0))]\n impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n@@ -275,15 +209,6 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n-    #[cfg(stage0)]\n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where RcStr: Borrow<Q>, Q: Eq + Hash<Hasher> {\n-        match (*self.map.borrow()).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where RcStr: Borrow<Q>, Q: Eq + Hash {\n         match (*self.map.borrow()).get(val) {"}, {"sha": "46a942b6eeb86a24f1345dbe733a2dc1b0279e55", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/686648d15546cead638ababda5a70d8f36fbc78a/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/686648d15546cead638ababda5a70d8f36fbc78a/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=686648d15546cead638ababda5a70d8f36fbc78a", "patch": "@@ -1,3 +1,12 @@\n+S 2015-02-19 522d09d\n+  freebsd-x86_64 7ea14ef85a25bca70a310a2cd660b356cf61abc7\n+  linux-i386 26e3caa1ce1c482b9941a6bdc64b3e65d036c200\n+  linux-x86_64 44f514aabb4e4049e4db9a4e1fdeb16f6cee60f2\n+  macos-i386 157910592224083df56f5f31ced3e6f3dc9b1de0\n+  macos-x86_64 56c28aa0e14ec6991ad6ca213568f1155561105d\n+  winnt-i386 da0f7a3fbc913fbb177917f2850bb41501affb5c\n+  winnt-x86_64 22bd816ccd2690fc9804b27ca525f603be8aeaa5\n+\n S 2015-02-17 f1bb6c2\n   freebsd-x86_64 59f3a2c6350c170804fb65838e1b504eeab89105\n   linux-i386 191ed5ec4f17e32d36abeade55a1c6085e51245c"}]}