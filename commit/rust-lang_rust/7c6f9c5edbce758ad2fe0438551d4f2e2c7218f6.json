{"sha": "7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNmY5YzVlZGJjZTc1OGFkMmZlMDQzODU1MWQ0ZjJlMmM3MjE4ZjY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-09-16T22:46:19Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-09-16T22:46:19Z"}, "message": "Merge pull request #324 from marcusklaas/macro-uses\n\nFormat macro invocations", "tree": {"sha": "2d0f343eb2a1f2a7174b2fd548aec2a2f1afe902", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d0f343eb2a1f2a7174b2fd548aec2a2f1afe902"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "html_url": "https://github.com/rust-lang/rust/commit/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d8a8cc876fafc7b66403bd43123bd20a190125", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d8a8cc876fafc7b66403bd43123bd20a190125", "html_url": "https://github.com/rust-lang/rust/commit/d4d8a8cc876fafc7b66403bd43123bd20a190125"}, {"sha": "f7513569102f18c65d13de3530b9ca879ec05e18", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7513569102f18c65d13de3530b9ca879ec05e18", "html_url": "https://github.com/rust-lang/rust/commit/f7513569102f18c65d13de3530b9ca879ec05e18"}], "stats": {"total": 337, "additions": 278, "deletions": 59}, "files": [{"sha": "42aaaa4f8c9e6dc623ea122f48c2d842d53eec3e", "filename": "src/comment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -288,6 +288,7 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n mod test {\n     use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented};\n \n+    // TODO(#217): prevent string literal from going over the limit.\n     #[test]\n     fn format_comments() {\n         assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, 100));"}, {"sha": "e0ad66ba34fefe1fae7e2cfff6a4c227d33f111b", "filename": "src/expr.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -23,6 +23,7 @@ use comment::{FindUncommented, rewrite_comment, contains_comment};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg};\n use chains::rewrite_chain;\n+use macros::rewrite_macro;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos, mk_sp};\n@@ -150,20 +151,23 @@ impl Rewrite for ast::Expr {\n             ast::Expr_::ExprMethodCall(..) => {\n                 rewrite_chain(self, context, width, offset)\n             }\n+            ast::Expr_::ExprMac(ref mac) => {\n+                rewrite_macro(mac, context, width, offset)\n+            }\n             // We do not format these expressions yet, but they should still\n             // satisfy our width restrictions.\n             _ => wrap_str(context.snippet(self.span), context.config.max_width, width, offset),\n         }\n     }\n }\n \n-fn rewrite_array<'a, I>(expr_iter: I,\n-                        span: Span,\n-                        context: &RewriteContext,\n-                        width: usize,\n-                        offset: usize)\n-                        -> Option<String>\n-    where I: Iterator<Item = &'a ast::Expr> + ExactSizeIterator\n+pub fn rewrite_array<'a, I>(expr_iter: I,\n+                            span: Span,\n+                            context: &RewriteContext,\n+                            width: usize,\n+                            offset: usize)\n+                            -> Option<String>\n+    where I: Iterator<Item = &'a ast::Expr>\n {\n     // 2 for brackets;\n     let max_item_width = try_opt!(width.checked_sub(2));\n@@ -727,12 +731,13 @@ impl Rewrite for ast::Arm {\n         // Patterns\n         // 5 = ` => {`\n         let pat_budget = try_opt!(width.checked_sub(5));\n-        let pat_strs = try_opt!(pats.iter().map(|p| {\n-                                               p.rewrite(context,\n-                                                         pat_budget,\n-                                                         offset + context.config.tab_spaces)\n-                                           })\n-                                           .collect::<Option<Vec<_>>>());\n+        let pat_strs = try_opt!(pats.iter()\n+                                    .map(|p| {\n+                                        p.rewrite(context,\n+                                                  pat_budget,\n+                                                  offset + context.config.tab_spaces)\n+                                    })\n+                                    .collect::<Option<Vec<_>>>());\n \n         let mut total_width = pat_strs.iter().fold(0, |a, p| a + p.len());\n         // Add ` | `.len().\n@@ -802,9 +807,7 @@ impl Rewrite for ast::Arm {\n         }\n \n         let body_budget = try_opt!(width.checked_sub(context.config.tab_spaces));\n-        let body_str = try_opt!(body.rewrite(context,\n-                                             body_budget,\n-                                             context.block_indent));\n+        let body_str = try_opt!(body.rewrite(context, body_budget, context.block_indent));\n         Some(format!(\"{}{} =>\\n{}{},\",\n                      attr_str.trim_left(),\n                      pats_str,"}, {"sha": "6b35add20bfdcfb9610bf7b12adbe5f472d164e2", "filename": "src/issues.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -256,17 +256,11 @@ fn find_issue() {\n                          ReportTactic::Always,\n                          ReportTactic::Never));\n \n-    assert!(! is_bad_issue(\"TODO: no number\\n\",\n-                           ReportTactic::Never,\n-                           ReportTactic::Always));\n+    assert!(!is_bad_issue(\"TODO: no number\\n\", ReportTactic::Never, ReportTactic::Always));\n \n-    assert!(is_bad_issue(\"This is a FIXME(#1)\\n\",\n-                         ReportTactic::Never,\n-                         ReportTactic::Always));\n+    assert!(is_bad_issue(\"This is a FIXME(#1)\\n\", ReportTactic::Never, ReportTactic::Always));\n \n-    assert!(! is_bad_issue(\"bad FIXME\\n\",\n-                           ReportTactic::Always,\n-                           ReportTactic::Never));\n+    assert!(!is_bad_issue(\"bad FIXME\\n\", ReportTactic::Always, ReportTactic::Never));\n }\n \n #[test]\n@@ -275,17 +269,19 @@ fn issue_type() {\n     let expected = Some(Issue { issue_type: IssueType::Todo, missing_number: false });\n \n     assert_eq!(expected,\n-               \"TODO(#100): more awesomeness\".chars()\n-                                       .map(|c| seeker.inspect(c))\n-                                       .find(Option::is_some)\n-                                       .unwrap());\n+               \"TODO(#100): more awesomeness\"\n+                   .chars()\n+                   .map(|c| seeker.inspect(c))\n+                   .find(Option::is_some)\n+                   .unwrap());\n \n     let mut seeker = BadIssueSeeker::new(ReportTactic::Never, ReportTactic::Unnumbered);\n     let expected = Some(Issue { issue_type: IssueType::Fixme, missing_number: true });\n \n     assert_eq!(expected,\n-               \"Test. FIXME: bad, bad, not good\".chars()\n-                                                .map(|c| seeker.inspect(c))\n-                                                .find(Option::is_some)\n-                                                .unwrap());\n+               \"Test. FIXME: bad, bad, not good\"\n+                   .chars()\n+                   .map(|c| seeker.inspect(c))\n+                   .find(Option::is_some)\n+                   .unwrap());\n }"}, {"sha": "6351813f996440409b94034f48bfc705b3941427", "filename": "src/items.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -215,7 +215,9 @@ impl<'a> FmtVisitor<'a> {\n             self.compute_budgets_for_args(&result, indent, ret_str.len(), newline_brace);\n \n         debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {}\",\n-               one_line_budget, multi_line_budget, arg_indent);\n+               one_line_budget,\n+               multi_line_budget,\n+               arg_indent);\n \n         // Check if vertical layout was forced by compute_budget_for_args.\n         if one_line_budget <= 0 {\n@@ -426,7 +428,8 @@ impl<'a> FmtVisitor<'a> {\n             let used_space = indent + result.len() + 2;\n             let max_space = self.config.ideal_width + self.config.leeway;\n             debug!(\"compute_budgets_for_args: used_space: {}, max_space: {}\",\n-                   used_space, max_space);\n+                   used_space,\n+                   max_space);\n             if used_space < max_space {\n                 budgets = Some((one_line_budget,\n                                 max_space - used_space,\n@@ -563,9 +566,9 @@ impl<'a> FmtVisitor<'a> {\n \n                     // Make sure we do not exceed column limit\n                     // 4 = \" = ,\"\n-                    assert!(\n-                        self.config.max_width >= vis.len() + name.len() + expr_snippet.len() + 4,\n-                        \"Enum variant exceeded column limit\");\n+                    assert!(self.config.max_width >=\n+                            vis.len() + name.len() + expr_snippet.len() + 4,\n+                            \"Enum variant exceeded column limit\");\n                 }\n \n                 result\n@@ -903,9 +906,7 @@ impl<'a> FmtVisitor<'a> {\n         // 9 = \" where \".len() + \" {\".len()\n         if density == Density::Tall || preds_str.contains('\\n') ||\n            indent + 9 + preds_str.len() > self.config.max_width {\n-            Some(format!(\"\\n{}where {}\",\n-                         make_indent(indent + extra_indent),\n-                         preds_str))\n+            Some(format!(\"\\n{}where {}\", make_indent(indent + extra_indent), preds_str))\n         } else {\n             Some(format!(\" where {}\", preds_str))\n         }"}, {"sha": "4ab1782700d5e44d87ad7751d076cf3713b33afe", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -11,6 +11,7 @@\n #![feature(rustc_private)]\n #![feature(custom_attribute)]\n #![feature(slice_splits)]\n+#![feature(catch_panic)]\n #![allow(unused_attributes)]\n \n // TODO we're going to allocate a whole bunch of temp Strings, is it worth\n@@ -72,6 +73,7 @@ mod comment;\n mod modules;\n pub mod rustfmt_diff;\n mod chains;\n+mod macros;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip.\n@@ -323,8 +325,6 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n         panic!(\"No input supplied to RustFmt\");\n     }\n \n-    #[rustfmt_skip]\n-    // FIXME(#195): closure is formatted poorly.\n     fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n         let write_mode = self.write_mode;\n \n@@ -338,8 +338,8 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n             let krate = state.krate.unwrap();\n             let codemap = state.session.codemap();\n             let mut file_map = fmt_ast(krate, codemap, &*config);\n-            // For some reason, the codemap does not include terminating newlines\n-            // so we must add one on for each file. This is sad.\n+            // For some reason, the codemap does not include terminating\n+            // newlines so we must add one on for each file. This is sad.\n             filemap::append_newlines(&mut file_map);\n             println!(\"{}\", fmt_lines(&mut file_map, &*config));\n "}, {"sha": "2b85c994581a78ac855b0ecfed7882c1da45c6fb", "filename": "src/lists.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -116,7 +116,9 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n     // Check if we need to fallback from horizontal listing, if possible.\n     if tactic == ListTactic::HorizontalVertical {\n         debug!(\"write_list: total_width: {}, total_sep_len: {}, h_width: {}\",\n-               total_width, total_sep_len, formatting.h_width);\n+               total_width,\n+               total_sep_len,\n+               formatting.h_width);\n         tactic = if fits_single && !items.iter().any(ListItem::is_multiline) {\n             ListTactic::Horizontal\n         } else {"}, {"sha": "dd742ad46c8cc9d472162a302b4eb575818bc286", "filename": "src/macros.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Format list-like macro invocations. These are invocations whose token trees\n+// can be interpreted as expressions and separated by commas.\n+// Note that these token trees do not actually have to be interpreted as\n+// expressions by the compiler. An example of an invocation we would reformat is\n+// foo!( x, y, z ). The token x may represent an identifier in the code, but we\n+// interpreted as an expression.\n+// Macro uses which are not-list like, such as bar!(key => val), will not be\n+// reformated.\n+// List-like invocations with parentheses will be formatted as function calls,\n+// and those with brackets will be formatted as array literals.\n+\n+use std::thread;\n+\n+use syntax::ast;\n+use syntax::parse::token::{Eof, Comma, Token};\n+use syntax::parse::{ParseSess, tts_to_parser};\n+\n+use rewrite::RewriteContext;\n+use expr::{rewrite_call, rewrite_array};\n+use comment::FindUncommented;\n+use utils::wrap_str;\n+\n+// We need to pass `TokenTree`s to our expression parsing thread, but they are\n+// not `Send`. We wrap them in a `Send` container to force our will.\n+// FIXME: this is a pretty terrible hack. Any other solution would be preferred.\n+struct ForceSend<T>(pub T);\n+unsafe impl<T> Send for ForceSend<T> {}\n+\n+// FIXME: use the enum from libsyntax?\n+enum MacroStyle {\n+    Parens,\n+    Brackets,\n+    Braces,\n+}\n+\n+pub fn rewrite_macro(mac: &ast::Mac,\n+                     context: &RewriteContext,\n+                     width: usize,\n+                     offset: usize)\n+                     -> Option<String> {\n+    let ast::Mac_::MacInvocTT(ref path, ref tt_vec, _) = mac.node;\n+    let style = macro_style(mac, context);\n+    let macro_name = format!(\"{}!\", path);\n+\n+    if let MacroStyle::Braces = style {\n+        return None;\n+    } else if tt_vec.is_empty() {\n+        return if let MacroStyle::Parens = style {\n+            Some(format!(\"{}()\", macro_name))\n+        } else {\n+            Some(format!(\"{}[]\", macro_name))\n+        };\n+    }\n+\n+    let wrapped_tt_vec = ForceSend((*tt_vec).clone());\n+    // Wrap expression parsing logic in a thread since the libsyntax parser\n+    // panicks on failure, which we do not want to propagate.\n+    let expr_vec_result = thread::catch_panic(move || {\n+        let parse_session = ParseSess::new();\n+        let mut parser = tts_to_parser(&parse_session, wrapped_tt_vec.0, vec![]);\n+        let mut expr_vec = vec![];\n+\n+        loop {\n+            expr_vec.push(parser.parse_expr());\n+\n+            match parser.token {\n+                Token::Eof => break,\n+                Token::Comma => (),\n+                _ => panic!(\"Macro not list-like, skiping...\"),\n+            }\n+\n+            let _ = parser.bump();\n+        }\n+\n+        expr_vec\n+    });\n+    let expr_vec = try_opt!(expr_vec_result.ok());\n+\n+    match style {\n+        MacroStyle::Parens => {\n+            // Format macro invocation as function call.\n+            rewrite_call(context, &macro_name, &expr_vec, mac.span, width, offset)\n+        }\n+        MacroStyle::Brackets => {\n+            // Format macro invocation as array literal.\n+            let extra_offset = macro_name.len();\n+            let rewrite = try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n+                                                 mac.span,\n+                                                 context,\n+                                                 try_opt!(width.checked_sub(extra_offset)),\n+                                                 offset + extra_offset));\n+            Some(format!(\"{}{}\", macro_name, rewrite))\n+        }\n+        MacroStyle::Braces => {\n+            // Skip macro invocations with braces, for now.\n+            wrap_str(context.snippet(mac.span), context.config.max_width, width, offset)\n+        }\n+    }\n+}\n+\n+fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> MacroStyle {\n+    let snippet = context.snippet(mac.span);\n+    let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());\n+    let bracket_pos = snippet.find_uncommented(\"[\").unwrap_or(usize::max_value());\n+    let brace_pos = snippet.find_uncommented(\"{\").unwrap_or(usize::max_value());\n+\n+    if paren_pos < bracket_pos && paren_pos < brace_pos {\n+        MacroStyle::Parens\n+    } else if bracket_pos < brace_pos {\n+        MacroStyle::Brackets\n+    } else {\n+        MacroStyle::Braces\n+    }\n+}"}, {"sha": "1f5e667c6faf8b9acef43d04c85c556d4b9c4687", "filename": "src/types.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -137,7 +137,9 @@ impl<'a> Rewrite for SegmentParam<'a> {\n                 try_opt!(ty.rewrite(context, width, offset))\n             }\n             SegmentParam::Binding(ref binding) => {\n-                format!(\"{} = {}\", binding.ident, try_opt!(binding.ty.rewrite(context, width, offset)))\n+                format!(\"{} = {}\",\n+                        binding.ident,\n+                        try_opt!(binding.ty.rewrite(context, width, offset)))\n             }\n         })\n     }\n@@ -319,8 +321,10 @@ impl Rewrite for ast::WherePredicate {\n                                                                              .. }) => {\n                 format!(\"{}: {}\",\n                         pprust::lifetime_to_string(lifetime),\n-                        bounds.iter().map(pprust::lifetime_to_string)\n-                              .collect::<Vec<_>>().join(\" + \"))\n+                        bounds.iter()\n+                              .map(pprust::lifetime_to_string)\n+                              .collect::<Vec<_>>()\n+                              .join(\" + \"))\n             }\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { ref path, ref ty, .. }) => {\n                 let ty_str = pprust::ty_to_string(ty);\n@@ -342,8 +346,11 @@ impl Rewrite for ast::LifetimeDef {\n         } else {\n             Some(format!(\"{}: {}\",\n                          pprust::lifetime_to_string(&self.lifetime),\n-                         self.bounds.iter().map(pprust::lifetime_to_string)\n-                                    .collect::<Vec<_>>().join(\" + \")))\n+                         self.bounds\n+                             .iter()\n+                             .map(pprust::lifetime_to_string)\n+                             .collect::<Vec<_>>()\n+                             .join(\" + \")))\n         }\n     }\n }\n@@ -410,9 +417,9 @@ impl Rewrite for ast::PolyTraitRef {\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(width.checked_sub(extra_offset));\n-            let path_str = try_opt!(self.trait_ref.path.rewrite(context,\n-                                                                max_path_width,\n-                                                                offset + extra_offset));\n+            let path_str = try_opt!(self.trait_ref\n+                                        .path\n+                                        .rewrite(context, max_path_width, offset + extra_offset));\n \n             Some(format!(\"for<{}> {}\", lifetime_str, path_str))\n         } else {"}, {"sha": "f09c198ca331fdcaf39c6c4d355a5f248203545b", "filename": "src/visitor.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -18,6 +18,7 @@ use utils;\n use config::Config;\n use rewrite::{Rewrite, RewriteContext};\n use comment::rewrite_comment;\n+use macros::rewrite_macro;\n \n pub struct FmtVisitor<'a> {\n     pub codemap: &'a CodeMap,\n@@ -73,7 +74,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                     self.last_pos = stmt.span.hi;\n                 }\n             }\n-            ast::Stmt_::StmtMac(..) => {\n+            ast::Stmt_::StmtMac(ref _mac, _macro_style) => {\n                 self.format_missing_with_indent(stmt.span.lo);\n                 visit::walk_stmt(self, stmt);\n             }\n@@ -213,6 +214,12 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.format_mod(module, item.span, item.ident);\n             }\n+            ast::Item_::ItemMac(..) => {\n+                self.format_missing_with_indent(item.span.lo);\n+                // TODO: we cannot format these yet, because of a bad span.\n+                // See rust lang issue #28424.\n+                // visit::walk_item(self, item);\n+            }\n             _ => {\n                 visit::walk_item(self, item);\n             }\n@@ -249,7 +256,14 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     }\n \n     fn visit_mac(&mut self, mac: &'v ast::Mac) {\n-        visit::walk_mac(self, mac)\n+        // 1 = ;\n+        let width = self.config.max_width - self.block_indent - 1;\n+        let rewrite = rewrite_macro(mac, &self.get_context(), width, self.block_indent);\n+\n+        if let Some(res) = rewrite {\n+            self.buffer.push_str(&res);\n+            self.last_pos = mac.span.hi;\n+        }\n     }\n }\n "}, {"sha": "8487e0c5deb9dbac629242d6f2e5d2f5a6526b8e", "filename": "tests/source/macros.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/tests%2Fsource%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/tests%2Fsource%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacros.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -0,0 +1,30 @@\n+itemmacro!(this, is.not() .formatted(yet));\n+\n+fn main() {\n+    foo! ( );\n+\n+    bar!( a , b , c );\n+\n+    baz!(1+2+3, quux. kaas());\n+\n+    quux!(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB);\n+\n+    kaas!(/* comments */ a /* post macro */, b /* another */);\n+\n+    trailingcomma!( a , b , c , );\n+\n+    noexpr!( i am not an expression, OK? );\n+\n+    vec! [ a , b , c];\n+\n+    vec! [AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA,\n+          BBBBB, 5, 100-30, 1.33, b, b, b];\n+\n+    vec! [a /* comment */];\n+\n+    foo(makro!(1,   3));\n+\n+    hamkaas!{ () };\n+\n+    macrowithbraces! {dont,    format, me}\n+}"}, {"sha": "ac87b693246f084a527397082376f6017802ce2b", "filename": "tests/target/macros.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/tests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/tests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacros.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -0,0 +1,33 @@\n+itemmacro!(this, is.not() .formatted(yet));\n+\n+fn main() {\n+    foo!();\n+\n+    bar!(a, b, c);\n+\n+    baz!(1 + 2 + 3, quux.kaas());\n+\n+    quux!(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n+          BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB);\n+\n+    kaas!(// comments\n+          a, // post macro\n+          b /* another */);\n+\n+    trailingcomma!( a , b , c , );\n+\n+    noexpr!( i am not an expression, OK? );\n+\n+    vec![a, b, c];\n+\n+    vec![AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, AAAAAA, BBBBB, 5,\n+         100 - 30, 1.33, b, b, b];\n+\n+    vec![a /* comment */];\n+\n+    foo(makro!(1, 3));\n+\n+    hamkaas!{ () };\n+\n+    macrowithbraces! {dont,    format, me}\n+}"}, {"sha": "e18c04bf02a61ac6247180f85e624a5d5c79729f", "filename": "tests/target/match.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=7c6f9c5edbce758ad2fe0438551d4f2e2c7218f6", "patch": "@@ -67,12 +67,20 @@ fn main() {\n fn main() {\n     match r {\n         Variableeeeeeeeeeeeeeeeee => (\"variable\",\n-                                      vec!(\"id\",\"name\",\"qualname\",\"value\",\"type\",\"scopeid\"),\n+                                      vec!(\"id\", \"name\", \"qualname\", \"value\", \"type\", \"scopeid\"),\n                                       true,\n                                       true),\n-        Enummmmmmmmmmmmmmmmmmmmm => (\"enum\", vec!(\"id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n+        Enummmmmmmmmmmmmmmmmmmmm => (\"enum\",\n+                                     vec!(\"id\", \"qualname\", \"scopeid\", \"value\"),\n+                                     true,\n+                                     true),\n         Variantttttttttttttttttttttttt => (\"variant\",\n-                                           vec!(\"id\",\"name\",\"qualname\",\"type\",\"value\",\"scopeid\"),\n+                                           vec!(\"id\",\n+                                                \"name\",\n+                                                \"qualname\",\n+                                                \"type\",\n+                                                \"value\",\n+                                                \"scopeid\"),\n                                            true,\n                                            true),\n     }"}]}