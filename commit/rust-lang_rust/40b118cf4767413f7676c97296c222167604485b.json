{"sha": "40b118cf4767413f7676c97296c222167604485b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYjExOGNmNDc2NzQxM2Y3Njc2Yzk3Mjk2YzIyMjE2NzYwNDQ4NWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "public.oliver.schneider@kit.edu", "date": "2018-04-25T13:26:12Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-04-30T16:18:33Z"}, "message": "Remove ConstFloat", "tree": {"sha": "f4c83e369500d378c6c6dfd3ce4770dc8922193b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4c83e369500d378c6c6dfd3ce4770dc8922193b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40b118cf4767413f7676c97296c222167604485b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJgBAABCgBKFiEEvpMjxK4/cnPNfesJHVy0/Fl8MAQFAlrnQdksHGdpdC1uby1y\nZXBseS05ODc5MTY1NzE2NDc5NDEzMTMxQG9saS1vYmsuZGUACgkQHVy0/Fl8MASv\nmA/5AfONetFvTv8v5IHgn9+tk8H6/TZYeerQVZ623qd8OFAD2PWdiO4/KEZHjkiO\nS6+ZnUC+gAKpQ7dD/V4vmdA79Kz6h/jGqDGApgLWGfGQ/KmvMn1kbK6LbaGUgaDp\nd3D21oOOfNMrpEWwSHwWPSgmmi1QfBcumoav9T4wqX9Ie0Ffu+gNKLXdD/TtyHv+\nfglNggMX5luU7itwwGz4sQfo4dUPHzXLFwPrfBPm774GQXpKd183p96Y3mXI5Yj2\n4GdGnF6S06gS54y9cBXqxX2V0xWSmRYZFsozEksK5V58JW+2q0pvLTPhTG5nUfcc\nxJMUZ1n4jW6GopIa/9UcssYDXFeZAiDVaj0WbP6eYw+kESumIXgJn0C723UNiN07\nCgKJ4ntyliJS+Sn1eYFO4DV/s+m3INSdV4bQZtEZIfG87jBFOQVfqMzUEJOR1/EU\no/oMWKOk53HQeuyzsM3EXks041pU2rstffM8Z/+XJbg5jJER4AcaD+8fFk3SlBY5\nLVT30PzAmuwe3TlmSOHmw5F17jAV8Th/n3ZA214x+dYgCe+xQ88wclCUEPw5/hlT\na6sXJSnYk1ZDbUPluHC4uMspzrtmgyBLQHibXB0c1s8bgUy0kxEeCrf2tbF05wuo\njTQ00kpvreIXfNRTmtVn4q3/eVTIfPKkN+gkBv9mZlnePdg=\n=x5mx\n-----END PGP SIGNATURE-----", "payload": "tree f4c83e369500d378c6c6dfd3ce4770dc8922193b\nparent f45d0f3783ec2a03a34712392d9d5e42067690dc\nauthor Oliver Schneider <public.oliver.schneider@kit.edu> 1524662772 +0200\ncommitter Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1525105113 +0200\n\nRemove ConstFloat\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40b118cf4767413f7676c97296c222167604485b", "html_url": "https://github.com/rust-lang/rust/commit/40b118cf4767413f7676c97296c222167604485b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40b118cf4767413f7676c97296c222167604485b/comments", "author": null, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f45d0f3783ec2a03a34712392d9d5e42067690dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f45d0f3783ec2a03a34712392d9d5e42067690dc", "html_url": "https://github.com/rust-lang/rust/commit/f45d0f3783ec2a03a34712392d9d5e42067690dc"}], "stats": {"total": 394, "additions": 85, "deletions": 309}, "files": [{"sha": "bbc43987c99de7cffa354b0ab971ce24f7360cf6", "filename": "src/librustc/ich/impls_const_math.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=40b118cf4767413f7676c97296c222167604485b", "patch": "@@ -11,11 +11,6 @@\n //! This module contains `HashStable` implementations for various data types\n //! from `rustc_const_math` in no particular order.\n \n-impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n-    ty,\n-    bits\n-});\n-\n impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n     Overflow(op),\n     DivisionByZero,"}, {"sha": "d1e515b2c7767b08a3fdd5e378ec098b299d7f8a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=40b118cf4767413f7676c97296c222167604485b", "patch": "@@ -43,6 +43,8 @@ use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n+use rustc_apfloat::ieee::{Single, Double};\n+use rustc_apfloat::Float;\n \n mod cache;\n pub mod tcx;\n@@ -1915,12 +1917,13 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n \n pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n-    use rustc_const_math::ConstFloat;\n     match (value, &ty.sty) {\n         (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n         (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(fty)) =>\n-            write!(f, \"{}\", ConstFloat { bits, ty: fty }),\n+        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n+            write!(f, \"{}\", Single::from_bits(bits)),\n+        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n+            write!(f, \"{}\", Double::from_bits(bits)),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>"}, {"sha": "35cfe466c8a735574a3157872974474e44cbdd84", "filename": "src/librustc_const_math/float.rs", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/f45d0f3783ec2a03a34712392d9d5e42067690dc/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45d0f3783ec2a03a34712392d9d5e42067690dc/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=f45d0f3783ec2a03a34712392d9d5e42067690dc", "patch": "@@ -1,217 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cmp::Ordering;\n-use std::num::ParseFloatError;\n-\n-use syntax::ast;\n-\n-use rustc_apfloat::{Float, FloatConvert, Status};\n-use rustc_apfloat::ieee::{Single, Double};\n-\n-// Note that equality for `ConstFloat` means that the it is the same\n-// constant, not that the rust values are equal. In particular, `NaN\n-// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n-// are considering unequal).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct ConstFloat {\n-    pub ty: ast::FloatTy,\n-\n-    // This is a bit inefficient but it makes conversions below more\n-    // ergonomic, and all of this will go away once `miri` is merged.\n-    pub bits: u128,\n-}\n-\n-impl PartialOrd<ConstFloat> for ConstFloat {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.try_cmp(*other)\n-    }\n-}\n-\n-impl ConstFloat {\n-    /// Description of the type, not the value\n-    pub fn description(&self) -> &'static str {\n-        self.ty.ty_to_string()\n-    }\n-\n-    /// Compares the values if they are of the same type\n-    fn try_cmp(self, rhs: Self) -> Option<Ordering> {\n-        match (self.ty, rhs.ty) {\n-            (ast::FloatTy::F64, ast::FloatTy::F64)  => {\n-                let a = Double::from_bits(self.bits);\n-                let b = Double::from_bits(rhs.bits);\n-                // This is pretty bad but it is the existing behavior.\n-                Some(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n-            }\n-\n-            (ast::FloatTy::F32, ast::FloatTy::F32) => {\n-                let a = Single::from_bits(self.bits);\n-                let b = Single::from_bits(rhs.bits);\n-                Some(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n-            }\n-\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn from_i128(input: i128, ty: ast::FloatTy) -> Self {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => Single::from_i128(input).value.to_bits(),\n-            ast::FloatTy::F64 => Double::from_i128(input).value.to_bits()\n-        };\n-        ConstFloat { bits, ty }\n-    }\n-\n-    pub fn from_u128(input: u128, ty: ast::FloatTy) -> Self {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => Single::from_u128(input).value.to_bits(),\n-            ast::FloatTy::F64 => Double::from_u128(input).value.to_bits()\n-        };\n-        ConstFloat { bits, ty }\n-    }\n-\n-    pub fn from_str(num: &str, ty: ast::FloatTy) -> Result<Self, ParseFloatError> {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => {\n-                let rust_bits = num.parse::<f32>()?.to_bits() as u128;\n-                let apfloat = num.parse::<Single>().unwrap_or_else(|e| {\n-                    panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e);\n-                });\n-                let apfloat_bits = apfloat.to_bits();\n-                assert!(rust_bits == apfloat_bits,\n-                    \"apfloat::ieee::Single gave different result for `{}`: \\\n-                     {}({:#x}) vs Rust's {}({:#x})\",\n-                    num, apfloat, apfloat_bits,\n-                    Single::from_bits(rust_bits), rust_bits);\n-                apfloat_bits\n-            }\n-            ast::FloatTy::F64 => {\n-                let rust_bits = num.parse::<f64>()?.to_bits() as u128;\n-                let apfloat = num.parse::<Double>().unwrap_or_else(|e| {\n-                    panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e);\n-                });\n-                let apfloat_bits = apfloat.to_bits();\n-                assert!(rust_bits == apfloat_bits,\n-                    \"apfloat::ieee::Double gave different result for `{}`: \\\n-                     {}({:#x}) vs Rust's {}({:#x})\",\n-                    num, apfloat, apfloat_bits,\n-                    Double::from_bits(rust_bits), rust_bits);\n-                apfloat_bits\n-            }\n-        };\n-        Ok(ConstFloat { bits, ty })\n-    }\n-\n-    pub fn to_i128(self, width: usize) -> Option<i128> {\n-        assert!(width <= 128);\n-        let r = match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).to_i128(width),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).to_i128(width)\n-        };\n-        if r.status.intersects(Status::INVALID_OP) {\n-            None\n-        } else {\n-            Some(r.value)\n-        }\n-    }\n-\n-    pub fn to_u128(self, width: usize) -> Option<u128> {\n-        assert!(width <= 128);\n-        let r = match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).to_u128(width),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).to_u128(width)\n-        };\n-        if r.status.intersects(Status::INVALID_OP) {\n-            None\n-        } else {\n-            Some(r.value)\n-        }\n-    }\n-\n-    pub fn convert(self, to: ast::FloatTy) -> Self {\n-        let bits = match (self.ty, to) {\n-            (ast::FloatTy::F32, ast::FloatTy::F32) |\n-            (ast::FloatTy::F64, ast::FloatTy::F64) => return self,\n-\n-            (ast::FloatTy::F32, ast::FloatTy::F64) => {\n-                Double::to_bits(Single::from_bits(self.bits).convert(&mut false).value)\n-            }\n-            (ast::FloatTy::F64, ast::FloatTy::F32) => {\n-                Single::to_bits(Double::from_bits(self.bits).convert(&mut false).value)\n-            }\n-        };\n-        ConstFloat { bits, ty: to }\n-    }\n-}\n-\n-impl ::std::fmt::Display for ConstFloat {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        match self.ty {\n-            ast::FloatTy::F32 => write!(fmt, \"{:#}\", Single::from_bits(self.bits))?,\n-            ast::FloatTy::F64 => write!(fmt, \"{:#}\", Double::from_bits(self.bits))?,\n-        }\n-        write!(fmt, \"{}\", self.ty)\n-    }\n-}\n-\n-impl ::std::fmt::Debug for ConstFloat {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        ::std::fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-macro_rules! derive_binop {\n-    ($op:ident, $func:ident) => {\n-        impl ::std::ops::$op for ConstFloat {\n-            type Output = Option<Self>;\n-            fn $func(self, rhs: Self) -> Option<Self> {\n-                let bits = match (self.ty, rhs.ty) {\n-                    (ast::FloatTy::F32, ast::FloatTy::F32) =>{\n-                        let a = Single::from_bits(self.bits);\n-                        let b = Single::from_bits(rhs.bits);\n-                        a.$func(b).value.to_bits()\n-                    }\n-                    (ast::FloatTy::F64, ast::FloatTy::F64) => {\n-                        let a = Double::from_bits(self.bits);\n-                        let b = Double::from_bits(rhs.bits);\n-                        a.$func(b).value.to_bits()\n-                    }\n-                    _ => return None,\n-                };\n-                Some(ConstFloat { bits, ty: self.ty })\n-            }\n-        }\n-    }\n-}\n-\n-derive_binop!(Add, add);\n-derive_binop!(Sub, sub);\n-derive_binop!(Mul, mul);\n-derive_binop!(Div, div);\n-derive_binop!(Rem, rem);\n-\n-impl ::std::ops::Neg for ConstFloat {\n-    type Output = Self;\n-    fn neg(self) -> Self {\n-        let bits = match self.ty {\n-            ast::FloatTy::F32 => (-Single::from_bits(self.bits)).to_bits(),\n-            ast::FloatTy::F64 => (-Double::from_bits(self.bits)).to_bits(),\n-        };\n-        ConstFloat { bits, ty: self.ty }\n-    }\n-}\n-\n-/// This is `f32::MAX + (0.5 ULP)` as an integer. Numbers greater or equal to this\n-/// are rounded to infinity when converted to `f32`.\n-///\n-/// NB: Computed as maximum significand with an extra 1 bit added (for the half ULP)\n-/// shifted by the maximum exponent (accounting for normalization).\n-pub const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n-                                        << (Single::MAX_EXP - Single::PRECISION as i16);"}, {"sha": "08996b892f9a62cd66c30d117b752843879bf073", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=40b118cf4767413f7676c97296c222167604485b", "patch": "@@ -18,14 +18,9 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n-extern crate rustc_apfloat;\n-\n-extern crate syntax;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-mod float;\n mod err;\n \n-pub use float::*;\n pub use err::{ConstMathErr, Op};"}, {"sha": "ff5c80845919093ad167c219d483bdbb42a9aebe", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=40b118cf4767413f7676c97296c222167604485b", "patch": "@@ -30,9 +30,9 @@ use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n-use rustc_const_math::ConstFloat;\n use rustc_data_structures::sync::Lrc;\n use rustc::mir::interpret::{Value, PrimVal};\n+use hair::pattern::parse_float;\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -170,14 +170,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         neg: bool,\n     ) -> Literal<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n-        let tcx = self.tcx.global_tcx();\n-\n-        let parse_float = |num: &str, fty| -> ConstFloat {\n-            ConstFloat::from_str(num, fty).unwrap_or_else(|_| {\n-                // FIXME(#31407) this is only necessary because float parsing is buggy\n-                tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n-            })\n-        };\n \n         let clamp = |n| {\n             let size = self.integer_bit_width(ty);\n@@ -214,25 +206,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(clamp(n))),\n             LitKind::Float(n, fty) => {\n                 let n = n.as_str();\n-                let mut f = parse_float(&n, fty);\n-                if neg {\n-                    f = -f;\n-                }\n-                let bits = f.bits;\n-                Value::ByVal(PrimVal::Bytes(bits))\n+                parse_float(&n, fty, neg).expect(\"apfloat parsing failed\")\n             }\n             LitKind::FloatUnsuffixed(n) => {\n                 let fty = match ty.sty {\n                     ty::TyFloat(fty) => fty,\n                     _ => bug!()\n                 };\n                 let n = n.as_str();\n-                let mut f = parse_float(&n, fty);\n-                if neg {\n-                    f = -f;\n-                }\n-                let bits = f.bits;\n-                Value::ByVal(PrimVal::Bytes(bits))\n+                parse_float(&n, fty, neg).expect(\"apfloat parsing failed\")\n             }\n             LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n             LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),"}, {"sha": "590cc77c46d7786fe6e5ab428a4d4a0c2e7b3a04", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=40b118cf4767413f7676c97296c222167604485b", "patch": "@@ -28,7 +28,6 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_const_math::ConstFloat;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -1053,22 +1052,21 @@ pub fn compare_const_vals<'a, 'tcx>(\n     b: &ConstVal,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n-    use rustc_const_math::ConstFloat;\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n     use rustc::mir::interpret::{Value, PrimVal};\n     match (a, b) {\n         (&ConstVal::Value(Value::ByVal(PrimVal::Bytes(a))),\n          &ConstVal::Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n+            use ::rustc_apfloat::Float;\n             match ty.sty {\n-                ty::TyFloat(ty) => {\n-                    let l = ConstFloat {\n-                        bits: a,\n-                        ty,\n-                    };\n-                    let r = ConstFloat {\n-                        bits: b,\n-                        ty,\n-                    };\n+                ty::TyFloat(ast::FloatTy::F32) => {\n+                    let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n+                    let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n+                    l.partial_cmp(&r)\n+                },\n+                ty::TyFloat(ast::FloatTy::F64) => {\n+                    let l = ::rustc_apfloat::ieee::Double::from_bits(a);\n+                    let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n                     l.partial_cmp(&r)\n                 },\n                 ty::TyInt(_) => {\n@@ -1148,33 +1146,49 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         },\n         LitKind::Float(n, fty) => {\n             let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n+            parse_float(&n, fty, neg).map_err(|_| ())?\n         }\n         LitKind::FloatUnsuffixed(n) => {\n             let fty = match ty.sty {\n                 ty::TyFloat(fty) => fty,\n                 _ => bug!()\n             };\n             let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n+            parse_float(&n, fty, neg).map_err(|_| ())?\n         }\n         LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n         LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n     };\n     Ok(ConstVal::Value(lit))\n }\n \n-fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n-                     -> Result<ConstFloat, ()> {\n-    ConstFloat::from_str(num, fty).map_err(|_| ())\n+pub fn parse_float(\n+    num: &str,\n+    fty: ast::FloatTy,\n+    neg: bool,\n+) -> Result<Value, String> {\n+    use rustc_apfloat::ieee::{Single, Double};\n+    use rustc_apfloat::Float;\n+    let bits = match fty {\n+        ast::FloatTy::F32 => {\n+            let mut f = num.parse::<Single>().map_err(|e| {\n+                format!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            })?;\n+            if neg {\n+                f = -f;\n+            }\n+            f.to_bits()\n+        }\n+        ast::FloatTy::F64 => {\n+            let mut f = num.parse::<Double>().map_err(|e| {\n+                format!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            })?;\n+            if neg {\n+                f = -f;\n+            }\n+            f.to_bits()\n+        }\n+    };\n+\n+    Ok(Value::ByVal(PrimVal::Bytes(bits)))\n }"}, {"sha": "002b5eb187db31ce36c2467687574938bb39b7d2", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=40b118cf4767413f7676c97296c222167604485b", "patch": "@@ -2,10 +2,9 @@ use rustc::ty::Ty;\n use rustc::ty::layout::LayoutOf;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n-use rustc_const_math::ConstFloat;\n+use rustc_apfloat::ieee::{Single, Double};\n use super::{EvalContext, Machine};\n use rustc::mir::interpret::{PrimVal, EvalResult, MemoryPointer, PointerArithmetic};\n-use rustc_apfloat::ieee::{Single, Double};\n use rustc_apfloat::Float;\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -50,8 +49,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 Ok(PrimVal::Bytes(v))\n             }\n \n-            TyFloat(fty) if signed => Ok(PrimVal::Bytes(ConstFloat::from_i128(v as i128, fty).bits)),\n-            TyFloat(fty) => Ok(PrimVal::Bytes(ConstFloat::from_u128(v, fty).bits)),\n+            TyFloat(FloatTy::F32) if signed => Ok(PrimVal::Bytes(Single::from_i128(v as i128).value.to_bits())),\n+            TyFloat(FloatTy::F64) if signed => Ok(PrimVal::Bytes(Double::from_i128(v as i128).value.to_bits())),\n+            TyFloat(FloatTy::F32) => Ok(PrimVal::Bytes(Single::from_u128(v).value.to_bits())),\n+            TyFloat(FloatTy::F64) => Ok(PrimVal::Bytes(Double::from_u128(v).value.to_bits())),\n \n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => err!(InvalidChar(v)),"}, {"sha": "5a815e0dc67ef43623106f0da1d757dec0ded28e", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=40b118cf4767413f7676c97296c222167604485b", "patch": "@@ -1,9 +1,10 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc_const_math::ConstFloat;\n use syntax::ast::FloatTy;\n use std::cmp::Ordering;\n use rustc::ty::layout::LayoutOf;\n+use rustc_apfloat::ieee::{Double, Single};\n+use rustc_apfloat::Float;\n \n use super::{EvalContext, Place, Machine, ValTy};\n \n@@ -125,31 +126,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return err!(Unimplemented(msg));\n         }\n \n-        let float_op = |op, l, r, ty| {\n-            let l = ConstFloat {\n-                bits: l,\n-                ty,\n-            };\n-            let r = ConstFloat {\n-                bits: r,\n-                ty,\n-            };\n-            match op {\n-                Eq => PrimVal::from_bool(l.partial_cmp(&r).unwrap() == Ordering::Equal),\n-                Ne => PrimVal::from_bool(l.partial_cmp(&r).unwrap() != Ordering::Equal),\n-                Lt => PrimVal::from_bool(l.partial_cmp(&r).unwrap() == Ordering::Less),\n-                Le => PrimVal::from_bool(l.partial_cmp(&r).unwrap() != Ordering::Greater),\n-                Gt => PrimVal::from_bool(l.partial_cmp(&r).unwrap() == Ordering::Greater),\n-                Ge => PrimVal::from_bool(l.partial_cmp(&r).unwrap() != Ordering::Less),\n-                Add => PrimVal::Bytes((l + r).unwrap().bits),\n-                Sub => PrimVal::Bytes((l - r).unwrap().bits),\n-                Mul => PrimVal::Bytes((l * r).unwrap().bits),\n-                Div => PrimVal::Bytes((l / r).unwrap().bits),\n-                Rem => PrimVal::Bytes((l % r).unwrap().bits),\n-                _ => bug!(\"invalid float op: `{:?}`\", op),\n-            }\n-        };\n-\n         if left_layout.abi.is_signed() {\n             let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n                 Lt => Some(i128::lt),\n@@ -199,7 +175,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n \n         if let ty::TyFloat(fty) = left_ty.sty {\n-            return Ok((float_op(bin_op, l, r, fty), false));\n+            macro_rules! float_math {\n+                ($ty:path) => {{\n+                    let l = <$ty>::from_bits(l);\n+                    let r = <$ty>::from_bits(r);\n+                    let val = match bin_op {\n+                        Eq => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Equal),\n+                        Ne => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Equal),\n+                        Lt => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Less),\n+                        Le => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Greater),\n+                        Gt => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Greater),\n+                        Ge => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Less),\n+                        Add => PrimVal::Bytes((l + r).value.to_bits()),\n+                        Sub => PrimVal::Bytes((l - r).value.to_bits()),\n+                        Mul => PrimVal::Bytes((l * r).value.to_bits()),\n+                        Div => PrimVal::Bytes((l / r).value.to_bits()),\n+                        Rem => PrimVal::Bytes((l % r).value.to_bits()),\n+                        _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n+                    };\n+                    return Ok((val, false));\n+                }};\n+            }\n+            match fty {\n+                FloatTy::F32 => float_math!(Single),\n+                FloatTy::F64 => float_math!(Double),\n+            }\n         }\n \n         // only ints left"}, {"sha": "6e16590bf35a33112c676cd5a79c2af07a615310", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b118cf4767413f7676c97296c222167604485b/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=40b118cf4767413f7676c97296c222167604485b", "patch": "@@ -15,7 +15,6 @@ use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n-use rustc_const_math::MAX_F32_PLUS_HALF_ULP;\n use std::{u128, i128};\n \n use base;\n@@ -805,6 +804,10 @@ fn cast_int_to_float(bx: &Builder,\n     if is_u128_to_f32 {\n         // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n         // and for everything else LLVM's uitofp works just fine.\n+        use rustc_apfloat::ieee::Single;\n+        use rustc_apfloat::Float;\n+        const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n+                                            << (Single::MAX_EXP - Single::PRECISION as i16);\n         let max = C_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bx.icmp(llvm::IntUGE, x, max);\n         let infinity_bits = C_u32(bx.cx, ieee::Single::INFINITY.to_bits() as u32);"}]}