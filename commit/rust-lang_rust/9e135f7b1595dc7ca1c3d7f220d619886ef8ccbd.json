{"sha": "9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMTM1ZjdiMTU5NWRjN2NhMWMzZDdmMjIwZDYxOTg4NmVmOGNjYmQ=", "commit": {"author": {"name": "Ms2ger", "email": "Ms2ger@gmail.com", "date": "2015-10-03T19:36:16Z"}, "committer": {"name": "Ms2ger", "email": "Ms2ger@gmail.com", "date": "2015-10-29T08:38:11Z"}, "message": "Rename categorization and stop re-exporting its variants.", "tree": {"sha": "45520f0dd121c540be3cd353eb53064442012b25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45520f0dd121c540be3cd353eb53064442012b25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "html_url": "https://github.com/rust-lang/rust/commit/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/comments", "author": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3896a005360fe818bef89c26ea1204597be6ae03", "url": "https://api.github.com/repos/rust-lang/rust/commits/3896a005360fe818bef89c26ea1204597be6ae03", "html_url": "https://github.com/rust-lang/rust/commit/3896a005360fe818bef89c26ea1204597be6ae03"}], "stats": {"total": 396, "additions": 203, "deletions": 193}, "files": [{"sha": "7dff882817e30bbe5f6687a3458da9df37203a00", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -32,6 +32,7 @@ use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::Categorization;\n use middle::traits;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n@@ -855,7 +856,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let mut cur = &cmt;\n         loop {\n             match cur.cat {\n-                mc::cat_static_item => {\n+                Categorization::StaticItem => {\n                     if self.mode != Mode::Var {\n                         // statics cannot be consumed by value at any time, that would imply\n                         // that they're an initializer (what a const is for) or kept in sync\n@@ -866,13 +867,13 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     }\n                     break;\n                 }\n-                mc::cat_deref(ref cmt, _, _) |\n-                mc::cat_downcast(ref cmt, _) |\n-                mc::cat_interior(ref cmt, _) => cur = cmt,\n+                Categorization::Deref(ref cmt, _, _) |\n+                Categorization::Downcast(ref cmt, _) |\n+                Categorization::Interior(ref cmt, _) => cur = cmt,\n \n-                mc::cat_rvalue(..) |\n-                mc::cat_upvar(..) |\n-                mc::cat_local(..) => break\n+                Categorization::Rvalue(..) |\n+                Categorization::Upvar(..) |\n+                Categorization::Local(..) => break\n             }\n         }\n     }\n@@ -899,7 +900,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let mut is_interior = false;\n         loop {\n             match cur.cat {\n-                mc::cat_rvalue(..) => {\n+                Categorization::Rvalue(..) => {\n                     if loan_cause == euv::MatchDiscriminant {\n                         // Ignore the dummy immutable borrow created by EUV.\n                         break;\n@@ -920,7 +921,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     self.record_borrow(borrow_id, mutbl);\n                     break;\n                 }\n-                mc::cat_static_item => {\n+                Categorization::StaticItem => {\n                     if is_interior && self.mode != Mode::Var {\n                         // Borrowed statics can specifically *only* have their address taken,\n                         // not any number of other borrows such as borrowing fields, reading\n@@ -931,15 +932,15 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     }\n                     break;\n                 }\n-                mc::cat_deref(ref cmt, _, _) |\n-                mc::cat_downcast(ref cmt, _) |\n-                mc::cat_interior(ref cmt, _) => {\n+                Categorization::Deref(ref cmt, _, _) |\n+                Categorization::Downcast(ref cmt, _) |\n+                Categorization::Interior(ref cmt, _) => {\n                     is_interior = true;\n                     cur = cmt;\n                 }\n \n-                mc::cat_upvar(..) |\n-                mc::cat_local(..) => break\n+                Categorization::Upvar(..) |\n+                Categorization::Local(..) => break\n             }\n         }\n     }"}, {"sha": "3197f57c17a10dc2d6fe281fd8f6f563319bcafe", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -55,7 +55,7 @@\n //!     let inc = || x += y;\n //!\n //! Then when we categorize `x` (*within* the closure) we would yield a\n-//! result of `*x'`, effectively, where `x'` is a `cat_upvar` reference\n+//! result of `*x'`, effectively, where `x'` is a `Categorization::Upvar` reference\n //! tied to `x`. The type of `x'` will be a borrowed pointer.\n \n #![allow(non_camel_case_types)]\n@@ -68,7 +68,6 @@ pub use self::MutabilityCategory::*;\n pub use self::AliasableReason::*;\n pub use self::Note::*;\n pub use self::deref_kind::*;\n-pub use self::categorization::*;\n \n use self::Aliasability::*;\n \n@@ -89,14 +88,14 @@ use std::fmt;\n use std::rc::Rc;\n \n #[derive(Clone, PartialEq)]\n-pub enum categorization<'tcx> {\n-    cat_rvalue(ty::Region),                    // temporary val, argument is its scope\n-    cat_static_item,\n-    cat_upvar(Upvar),                          // upvar referenced by closure env\n-    cat_local(ast::NodeId),                    // local variable\n-    cat_deref(cmt<'tcx>, usize, PointerKind),   // deref of a ptr\n-    cat_interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n-    cat_downcast(cmt<'tcx>, DefId),       // selects a particular enum variant (*1)\n+pub enum Categorization<'tcx> {\n+    Rvalue(ty::Region),                    // temporary val, argument is its scope\n+    StaticItem,\n+    Upvar(Upvar),                          // upvar referenced by closure env\n+    Local(ast::NodeId),                    // local variable\n+    Deref(cmt<'tcx>, usize, PointerKind),  // deref of a ptr\n+    Interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n+    Downcast(cmt<'tcx>, DefId),            // selects a particular enum variant (*1)\n \n     // (*1) downcast is only required if the enum has more than one variant\n }\n@@ -187,7 +186,7 @@ pub enum Note {\n pub struct cmt_<'tcx> {\n     pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n-    pub cat: categorization<'tcx>, // categorization of expr\n+    pub cat: Categorization<'tcx>, // categorization of expr\n     pub mutbl: MutabilityCategory, // mutability of expr as lvalue\n     pub ty: Ty<'tcx>,              // type of the expr (*see WARNING above*)\n     pub note: Note,                // Note about the provenance of this cmt\n@@ -557,7 +556,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n-                  cat:cat_static_item,\n+                  cat:Categorization::StaticItem,\n                   mutbl: McImmutable,\n                   ty:expr_ty,\n                   note: NoteNone\n@@ -568,7 +567,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n-                  cat:cat_static_item,\n+                  cat:Categorization::StaticItem,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty,\n                   note: NoteNone\n@@ -604,7 +603,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n-                cat: cat_local(vid),\n+                cat: Categorization::Local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n                 ty: expr_ty,\n                 note: NoteNone\n@@ -624,10 +623,10 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                  -> McResult<cmt<'tcx>>\n     {\n         // An upvar can have up to 3 components. We translate first to a\n-        // `cat_upvar`, which is itself a fiction -- it represents the reference to the\n+        // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n         // field from the environment.\n         //\n-        // `cat_upvar`.  Next, we add a deref through the implicit\n+        // `Categorization::Upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n         // appropriate borrow kind for closure kinds that take self by\n         // reference.  Finally, if the upvar was captured\n@@ -659,7 +658,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let cmt_result = cmt_ {\n             id: id,\n             span: span,\n-            cat: cat_upvar(Upvar {id: upvar_id, kind: kind}),\n+            cat: Categorization::Upvar(Upvar {id: upvar_id, kind: kind}),\n             mutbl: var_mutbl,\n             ty: var_ty,\n             note: NoteNone\n@@ -695,7 +694,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 cmt_ {\n                     id: id,\n                     span: span,\n-                    cat: cat_deref(Rc::new(cmt_result), 0, ptr),\n+                    cat: Categorization::Deref(Rc::new(cmt_result), 0, ptr),\n                     mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n                     ty: var_ty,\n                     note: NoteUpvarRef(upvar_id)\n@@ -769,7 +768,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let ret = cmt_ {\n             id: id,\n             span: span,\n-            cat: cat_deref(Rc::new(cmt_result), 0, env_ptr),\n+            cat: Categorization::Deref(Rc::new(cmt_result), 0, env_ptr),\n             mutbl: deref_mutbl,\n             ty: var_ty,\n             note: NoteClosureEnv(upvar_id)\n@@ -825,7 +824,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let ret = Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n-            cat:cat_rvalue(temp_scope),\n+            cat:Categorization::Rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n@@ -844,7 +843,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name))),\n+            cat: Categorization::Interior(base_cmt, InteriorField(NamedField(f_name))),\n             ty: f_ty,\n             note: NoteNone\n         });\n@@ -862,7 +861,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: cat_interior(base_cmt, InteriorField(PositionalField(f_idx))),\n+            cat: Categorization::Interior(base_cmt, InteriorField(PositionalField(f_idx))),\n             ty: f_ty,\n             note: NoteNone\n         });\n@@ -934,10 +933,10 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 (MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n-                 cat_deref(base_cmt, deref_cnt, ptr))\n+                 Categorization::Deref(base_cmt, deref_cnt, ptr))\n             }\n             deref_interior(interior) => {\n-                (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n+                (base_cmt.mutbl.inherit(), Categorization::Interior(base_cmt, interior))\n             }\n         };\n         let ret = Rc::new(cmt_ {\n@@ -1013,7 +1012,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             Rc::new(cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_interior(of_cmt, interior_elem),\n+                cat:Categorization::Interior(of_cmt, interior_elem),\n                 mutbl:mutbl,\n                 ty:element_ty,\n                 note: NoteNone\n@@ -1039,7 +1038,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 Rc::new(cmt_ {\n                     id:elt.id(),\n                     span:elt.span(),\n-                    cat:cat_deref(base_cmt.clone(), 0, ptr),\n+                    cat:Categorization::Deref(base_cmt.clone(), 0, ptr),\n                     mutbl:m,\n                     ty: match base_cmt.ty.builtin_deref(false, ty::NoPreference) {\n                         Some(mt) => mt.ty,\n@@ -1108,7 +1107,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: cat_interior(base_cmt, interior),\n+            cat: Categorization::Interior(base_cmt, interior),\n             ty: interior_ty,\n             note: NoteNone\n         });\n@@ -1126,7 +1125,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: cat_downcast(base_cmt, variant_did),\n+            cat: Categorization::Downcast(base_cmt, variant_did),\n             ty: downcast_ty,\n             note: NoteNone\n         });\n@@ -1361,18 +1360,18 @@ impl<'tcx> cmt_<'tcx> {\n         //! determines how long the value in `self` remains live.\n \n         match self.cat {\n-            cat_rvalue(..) |\n-            cat_static_item |\n-            cat_local(..) |\n-            cat_deref(_, _, UnsafePtr(..)) |\n-            cat_deref(_, _, BorrowedPtr(..)) |\n-            cat_deref(_, _, Implicit(..)) |\n-            cat_upvar(..) => {\n+            Categorization::Rvalue(..) |\n+            Categorization::StaticItem |\n+            Categorization::Local(..) |\n+            Categorization::Deref(_, _, UnsafePtr(..)) |\n+            Categorization::Deref(_, _, BorrowedPtr(..)) |\n+            Categorization::Deref(_, _, Implicit(..)) |\n+            Categorization::Upvar(..) => {\n                 Rc::new((*self).clone())\n             }\n-            cat_downcast(ref b, _) |\n-            cat_interior(ref b, _) |\n-            cat_deref(ref b, _, Unique) => {\n+            Categorization::Downcast(ref b, _) |\n+            Categorization::Interior(ref b, _) |\n+            Categorization::Deref(ref b, _, Unique) => {\n                 b.guarantor()\n             }\n         }\n@@ -1386,17 +1385,17 @@ impl<'tcx> cmt_<'tcx> {\n         // aliased and eventually recused.\n \n         match self.cat {\n-            cat_deref(ref b, _, BorrowedPtr(ty::MutBorrow, _)) |\n-            cat_deref(ref b, _, Implicit(ty::MutBorrow, _)) |\n-            cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n-            cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n-            cat_downcast(ref b, _) |\n-            cat_interior(ref b, _) => {\n+            Categorization::Deref(ref b, _, BorrowedPtr(ty::MutBorrow, _)) |\n+            Categorization::Deref(ref b, _, Implicit(ty::MutBorrow, _)) |\n+            Categorization::Deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n+            Categorization::Deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n+            Categorization::Downcast(ref b, _) |\n+            Categorization::Interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable(ctxt)\n             }\n \n-            cat_deref(ref b, _, Unique) => {\n+            Categorization::Deref(ref b, _, Unique) => {\n                 let sub = b.freely_aliasable(ctxt);\n                 if b.mutbl.is_mutable() {\n                     // Aliasability depends on base cmt alone\n@@ -1407,25 +1406,25 @@ impl<'tcx> cmt_<'tcx> {\n                 }\n             }\n \n-            cat_rvalue(..) |\n-            cat_local(..) |\n-            cat_upvar(..) |\n-            cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n+            Categorization::Rvalue(..) |\n+            Categorization::Local(..) |\n+            Categorization::Upvar(..) |\n+            Categorization::Deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 NonAliasable\n             }\n \n-            cat_static_item(..) => {\n+            Categorization::StaticItem(..) => {\n                 if self.mutbl.is_mutable() {\n                     FreelyAliasable(AliasableStaticMut)\n                 } else {\n                     FreelyAliasable(AliasableStatic)\n                 }\n             }\n \n-            cat_deref(ref base, _, BorrowedPtr(ty::ImmBorrow, _)) |\n-            cat_deref(ref base, _, Implicit(ty::ImmBorrow, _)) => {\n+            Categorization::Deref(ref base, _, BorrowedPtr(ty::ImmBorrow, _)) |\n+            Categorization::Deref(ref base, _, Implicit(ty::ImmBorrow, _)) => {\n                 match base.cat {\n-                    cat_upvar(Upvar{ id, .. }) =>\n+                    Categorization::Upvar(Upvar{ id, .. }) =>\n                         FreelyAliasable(AliasableClosure(id.closure_expr_id)),\n                     _ => FreelyAliasable(AliasableBorrowed)\n                 }\n@@ -1439,10 +1438,10 @@ impl<'tcx> cmt_<'tcx> {\n         match self.note {\n             NoteClosureEnv(..) | NoteUpvarRef(..) => {\n                 Some(match self.cat {\n-                    cat_deref(ref inner, _, _) => {\n+                    Categorization::Deref(ref inner, _, _) => {\n                         match inner.cat {\n-                            cat_deref(ref inner, _, _) => inner.clone(),\n-                            cat_upvar(..) => inner.clone(),\n+                            Categorization::Deref(ref inner, _, _) => inner.clone(),\n+                            Categorization::Upvar(..) => inner.clone(),\n                             _ => unreachable!()\n                         }\n                     }\n@@ -1456,23 +1455,23 @@ impl<'tcx> cmt_<'tcx> {\n \n     pub fn descriptive_string(&self, tcx: &ty::ctxt) -> String {\n         match self.cat {\n-            cat_static_item => {\n+            Categorization::StaticItem => {\n                 \"static item\".to_string()\n             }\n-            cat_rvalue(..) => {\n+            Categorization::Rvalue(..) => {\n                 \"non-lvalue\".to_string()\n             }\n-            cat_local(vid) => {\n+            Categorization::Local(vid) => {\n                 if tcx.map.is_argument(vid) {\n                     \"argument\".to_string()\n                 } else {\n                     \"local variable\".to_string()\n                 }\n             }\n-            cat_deref(_, _, pk) => {\n+            Categorization::Deref(_, _, pk) => {\n                 let upvar = self.upvar();\n                 match upvar.as_ref().map(|i| &i.cat) {\n-                    Some(&cat_upvar(ref var)) => {\n+                    Some(&Categorization::Upvar(ref var)) => {\n                         var.to_string()\n                     }\n                     Some(_) => unreachable!(),\n@@ -1494,28 +1493,28 @@ impl<'tcx> cmt_<'tcx> {\n                     }\n                 }\n             }\n-            cat_interior(_, InteriorField(NamedField(_))) => {\n+            Categorization::Interior(_, InteriorField(NamedField(_))) => {\n                 \"field\".to_string()\n             }\n-            cat_interior(_, InteriorField(PositionalField(_))) => {\n+            Categorization::Interior(_, InteriorField(PositionalField(_))) => {\n                 \"anonymous field\".to_string()\n             }\n-            cat_interior(_, InteriorElement(InteriorOffsetKind::Index,\n-                                            VecElement)) |\n-            cat_interior(_, InteriorElement(InteriorOffsetKind::Index,\n-                                            OtherElement)) => {\n+            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index,\n+                                                        VecElement)) |\n+            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index,\n+                                                        OtherElement)) => {\n                 \"indexed content\".to_string()\n             }\n-            cat_interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n-                                            VecElement)) |\n-            cat_interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n-                                            OtherElement)) => {\n+            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n+                                                        VecElement)) |\n+            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n+                                                        OtherElement)) => {\n                 \"pattern-bound indexed content\".to_string()\n             }\n-            cat_upvar(ref var) => {\n+            Categorization::Upvar(ref var) => {\n                 var.to_string()\n             }\n-            cat_downcast(ref cmt, _) => {\n+            Categorization::Downcast(ref cmt, _) => {\n                 cmt.descriptive_string(tcx)\n             }\n         }\n@@ -1532,25 +1531,25 @@ impl<'tcx> fmt::Debug for cmt_<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for categorization<'tcx> {\n+impl<'tcx> fmt::Debug for Categorization<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            cat_static_item => write!(f, \"static\"),\n-            cat_rvalue(r) => write!(f, \"rvalue({:?})\", r),\n-            cat_local(id) => {\n+            Categorization::StaticItem => write!(f, \"static\"),\n+            Categorization::Rvalue(r) => write!(f, \"rvalue({:?})\", r),\n+            Categorization::Local(id) => {\n                let name = ty::tls::with(|tcx| tcx.local_var_name_str(id));\n                write!(f, \"local({})\", name)\n             }\n-            cat_upvar(upvar) => {\n+            Categorization::Upvar(upvar) => {\n                 write!(f, \"upvar({:?})\", upvar)\n             }\n-            cat_deref(ref cmt, derefs, ptr) => {\n+            Categorization::Deref(ref cmt, derefs, ptr) => {\n                 write!(f, \"{:?}-{:?}{}->\", cmt.cat, ptr, derefs)\n             }\n-            cat_interior(ref cmt, interior) => {\n+            Categorization::Interior(ref cmt, interior) => {\n                 write!(f, \"{:?}.{:?}\", cmt.cat, interior)\n             }\n-            cat_downcast(ref cmt, _) => {\n+            Categorization::Downcast(ref cmt, _) => {\n                 write!(f, \"{:?}->(enum)\", cmt.cat)\n             }\n         }"}, {"sha": "cec0cf18fb72a7fa4d59f41b73e8531686cef505", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -23,6 +23,7 @@ use borrowck::InteriorKind::{InteriorElement, InteriorField};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::middle::ty;\n use syntax::ast;\n@@ -796,7 +797,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // Check for reassignments to (immutable) local variables. This\n         // needs to be done here instead of in check_loans because we\n         // depend on move data.\n-        if let mc::cat_local(local_id) = assignee_cmt.cat {\n+        if let Categorization::Local(local_id) = assignee_cmt.cat {\n             let lp = opt_loan_path(&assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {"}, {"sha": "cf9de56c8dbf707bbe848be733c9c25f9f0dbcd5", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -16,6 +16,7 @@ use borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use borrowck::move_data::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n \n@@ -163,22 +164,22 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                cmt: &mc::cmt<'tcx>)\n                                                -> Option<mc::cmt<'tcx>> {\n     match cmt.cat {\n-        mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n-        mc::cat_deref(_, _, mc::Implicit(..)) |\n-        mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-        mc::cat_static_item => {\n+        Categorization::Deref(_, _, mc::BorrowedPtr(..)) |\n+        Categorization::Deref(_, _, mc::Implicit(..)) |\n+        Categorization::Deref(_, _, mc::UnsafePtr(..)) |\n+        Categorization::StaticItem => {\n             Some(cmt.clone())\n         }\n \n-        mc::cat_rvalue(..) |\n-        mc::cat_local(..) |\n-        mc::cat_upvar(..) => {\n+        Categorization::Rvalue(..) |\n+        Categorization::Local(..) |\n+        Categorization::Upvar(..) => {\n             None\n         }\n \n-        mc::cat_downcast(ref b, _) |\n-        mc::cat_interior(ref b, mc::InteriorField(_)) |\n-        mc::cat_interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n+        Categorization::Downcast(ref b, _) |\n+        Categorization::Interior(ref b, mc::InteriorField(_)) |\n+        Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n                 ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n                     if def.has_dtor() {\n@@ -193,12 +194,12 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             }\n         }\n \n-        mc::cat_interior(_, mc::InteriorElement(Kind::Index, _)) => {\n+        Categorization::Interior(_, mc::InteriorElement(Kind::Index, _)) => {\n             // Forbid move of arr[i] for arr: [T; 3]; see RFC 533.\n             Some(cmt.clone())\n         }\n \n-        mc::cat_deref(ref b, _, mc::Unique) => {\n+        Categorization::Deref(ref b, _, mc::Unique) => {\n             check_and_get_illegal_move_origin(bccx, b)\n         }\n     }"}, {"sha": "84dce6d35702afce454775d061da3c44a71a8f77", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -14,6 +14,7 @@\n use borrowck::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::middle::ty;\n \n@@ -70,22 +71,22 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                self.loan_region);\n \n         match cmt.cat {\n-            mc::cat_rvalue(..) |\n-            mc::cat_local(..) |                         // L-Local\n-            mc::cat_upvar(..) |\n-            mc::cat_deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n-            mc::cat_deref(_, _, mc::Implicit(..)) |\n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n+            Categorization::Rvalue(..) |\n+            Categorization::Local(..) |                         // L-Local\n+            Categorization::Upvar(..) |\n+            Categorization::Deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n+            Categorization::Deref(_, _, mc::Implicit(..)) |\n+            Categorization::Deref(_, _, mc::UnsafePtr(..)) => {\n                 self.check_scope(self.scope(cmt))\n             }\n \n-            mc::cat_static_item => {\n+            Categorization::StaticItem => {\n                 Ok(())\n             }\n \n-            mc::cat_downcast(ref base, _) |\n-            mc::cat_deref(ref base, _, mc::Unique) |     // L-Deref-Send\n-            mc::cat_interior(ref base, _) => {             // L-Field\n+            Categorization::Downcast(ref base, _) |\n+            Categorization::Deref(ref base, _, mc::Unique) |     // L-Deref-Send\n+            Categorization::Interior(ref base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n         }\n@@ -107,28 +108,28 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! rooting etc, and presuming `cmt` is not mutated.\n \n         match cmt.cat {\n-            mc::cat_rvalue(temp_scope) => {\n+            Categorization::Rvalue(temp_scope) => {\n                 temp_scope\n             }\n-            mc::cat_upvar(..) => {\n+            Categorization::Upvar(..) => {\n                 ty::ReScope(self.item_scope)\n             }\n-            mc::cat_static_item => {\n+            Categorization::StaticItem => {\n                 ty::ReStatic\n             }\n-            mc::cat_local(local_id) => {\n+            Categorization::Local(local_id) => {\n                 ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n             }\n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n+            Categorization::Deref(_, _, mc::UnsafePtr(..)) => {\n                 ty::ReStatic\n             }\n-            mc::cat_deref(_, _, mc::BorrowedPtr(_, r)) |\n-            mc::cat_deref(_, _, mc::Implicit(_, r)) => {\n+            Categorization::Deref(_, _, mc::BorrowedPtr(_, r)) |\n+            Categorization::Deref(_, _, mc::Implicit(_, r)) => {\n                 r\n             }\n-            mc::cat_downcast(ref cmt, _) |\n-            mc::cat_deref(ref cmt, _, mc::Unique) |\n-            mc::cat_interior(ref cmt, _) => {\n+            Categorization::Downcast(ref cmt, _) |\n+            Categorization::Deref(ref cmt, _, mc::Unique) |\n+            Categorization::Interior(ref cmt, _) => {\n                 self.scope(cmt)\n             }\n         }"}, {"sha": "99e4bb60aff28ba711544e1d2cf058c060abee3d", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -21,6 +21,7 @@ use borrowck::move_data::MoveData;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::middle::ty;\n \n@@ -101,7 +102,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                cmt,\n                mode);\n \n-        if let mc::cat_downcast(..) = cmt.cat {\n+        if let Categorization::Downcast(..) = cmt.cat {\n             gather_moves::gather_match_variant(\n                 self.bccx, &self.move_data, &self.move_error_collector,\n                 matched_pat, cmt, mode);\n@@ -263,7 +264,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         debug!(\"guarantee_assignment_valid(assignment_id={}, cmt={:?}) opt_lp={:?}\",\n                assignment_id, cmt, opt_lp);\n \n-        if let mc::cat_local(..) = cmt.cat {\n+        if let Categorization::Local(..) = cmt.cat {\n             // Only re-assignments to locals require it to be\n             // mutable - this is checked in check_loans.\n         } else {\n@@ -282,7 +283,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n         match opt_lp {\n             Some(lp) => {\n-                if let mc::cat_local(..) = cmt.cat {\n+                if let Categorization::Local(..) = cmt.cat {\n                     // Only re-assignments to locals require it to be\n                     // mutable - this is checked in check_loans.\n                 } else {"}, {"sha": "fb703a9f9bca58930a629b970bce9268d290e586", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -10,6 +10,7 @@\n \n use borrowck::BorrowckCtxt;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n use std::cell::RefCell;\n@@ -114,16 +115,16 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_from: mc::cmt<'tcx>) {\n     match move_from.cat {\n-        mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n-        mc::cat_deref(_, _, mc::Implicit(..)) |\n-        mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-        mc::cat_static_item => {\n+        Categorization::Deref(_, _, mc::BorrowedPtr(..)) |\n+        Categorization::Deref(_, _, mc::Implicit(..)) |\n+        Categorization::Deref(_, _, mc::UnsafePtr(..)) |\n+        Categorization::StaticItem => {\n             span_err!(bccx, move_from.span, E0507,\n                       \"cannot move out of {}\",\n                       move_from.descriptive_string(bccx.tcx));\n         }\n \n-        mc::cat_interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n+        Categorization::Interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n             let expr = bccx.tcx.map.expect_expr(move_from.id);\n             if let hir::ExprIndex(..) = expr.node {\n                 span_err!(bccx, move_from.span, E0508,\n@@ -133,8 +134,8 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             }\n         }\n \n-        mc::cat_downcast(ref b, _) |\n-        mc::cat_interior(ref b, mc::InteriorField(_)) => {\n+        Categorization::Downcast(ref b, _) |\n+        Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n                 ty::TyStruct(def, _) |\n                 ty::TyEnum(def, _) if def.has_dtor() => {"}, {"sha": "426da7809d843dff755d653c16c26f3aeb8f7982", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -15,6 +15,7 @@ pub use self::RestrictionResult::*;\n use borrowck::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::ty;\n use syntax::codemap::Span;\n \n@@ -62,7 +63,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n         let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n \n         match cmt.cat.clone() {\n-            mc::cat_rvalue(..) => {\n+            Categorization::Rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n                 // non-aliasable temporary on the stack. Since they\n                 // are inherently non-aliasable, they can only be\n@@ -71,26 +72,26 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 Safe\n             }\n \n-            mc::cat_local(local_id) => {\n+            Categorization::Local(local_id) => {\n                 // R-Variable, locally declared\n                 let lp = new_lp(LpVar(local_id));\n                 SafeIf(lp.clone(), vec![lp])\n             }\n \n-            mc::cat_upvar(mc::Upvar { id, .. }) => {\n+            Categorization::Upvar(mc::Upvar { id, .. }) => {\n                 // R-Variable, captured into closure\n                 let lp = new_lp(LpUpvar(id));\n                 SafeIf(lp.clone(), vec![lp])\n             }\n \n-            mc::cat_downcast(cmt_base, _) => {\n+            Categorization::Downcast(cmt_base, _) => {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n                 // could cause the type of the memory to change.\n                 self.restrict(cmt_base)\n             }\n \n-            mc::cat_interior(cmt_base, i) => {\n+            Categorization::Interior(cmt_base, i) => {\n                 // R-Field\n                 //\n                 // Overwriting the base would not change the type of\n@@ -100,11 +101,11 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 self.extend(result, &cmt, LpInterior(i.cleaned()))\n             }\n \n-            mc::cat_static_item(..) => {\n+            Categorization::StaticItem(..) => {\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, pk) => {\n+            Categorization::Deref(cmt_base, _, pk) => {\n                 match pk {\n                     mc::Unique => {\n                         // R-Deref-Send-Pointer"}, {"sha": "e8179a8cee0cc33a0f7ca59345dd81dc0e60920c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -31,6 +31,7 @@ use rustc::middle::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n \n@@ -502,32 +503,32 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n     let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n \n     match cmt.cat {\n-        mc::cat_rvalue(..) |\n-        mc::cat_static_item => {\n+        Categorization::Rvalue(..) |\n+        Categorization::StaticItem => {\n             None\n         }\n \n-        mc::cat_local(id) => {\n+        Categorization::Local(id) => {\n             Some(new_lp(LpVar(id)))\n         }\n \n-        mc::cat_upvar(mc::Upvar { id, .. }) => {\n+        Categorization::Upvar(mc::Upvar { id, .. }) => {\n             Some(new_lp(LpUpvar(id)))\n         }\n \n-        mc::cat_deref(ref cmt_base, _, pk) => {\n+        Categorization::Deref(ref cmt_base, _, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n                 new_lp(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n             })\n         }\n \n-        mc::cat_interior(ref cmt_base, ik) => {\n+        Categorization::Interior(ref cmt_base, ik) => {\n             opt_loan_path(cmt_base).map(|lp| {\n                 new_lp(LpExtend(lp, cmt.mutbl, LpInterior(ik.cleaned())))\n             })\n         }\n \n-        mc::cat_downcast(ref cmt_base, variant_def_id) =>\n+        Categorization::Downcast(ref cmt_base, variant_def_id) =>\n             opt_loan_path(cmt_base)\n             .map(|lp| {\n                 new_lp(LpDowncast(lp, variant_def_id))\n@@ -1004,7 +1005,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         // If it's an `FnMut` closure, the original variable was declared immutable.\n                         // We need to determine which is the case here.\n                         let kind = match err.cmt.upvar().unwrap().cat {\n-                            mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n+                            Categorization::Upvar(mc::Upvar { kind, .. }) => kind,\n                             _ => unreachable!()\n                         };\n                         if kind == ty::FnClosureKind {"}, {"sha": "01d182bda370866f144150d6627a511545f0fcd4", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -198,6 +198,7 @@ use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::lang_items::StrEqFnLangItem;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::Categorization;\n use middle::pat_util::*;\n use trans::adt;\n use trans::base::*;\n@@ -1496,12 +1497,12 @@ impl<'tcx> euv::Delegate<'tcx> for ReassignmentChecker {\n \n     fn mutate(&mut self, _: ast::NodeId, _: Span, cmt: mc::cmt, _: euv::MutateMode) {\n         match cmt.cat {\n-            mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, .. }, .. }) |\n-            mc::cat_local(vid) => self.reassigned |= self.node == vid,\n-            mc::cat_interior(ref base_cmt, mc::InteriorField(field)) => {\n+            Categorization::Upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, .. }, .. }) |\n+            Categorization::Local(vid) => self.reassigned |= self.node == vid,\n+            Categorization::Interior(ref base_cmt, mc::InteriorField(field)) => {\n                 match base_cmt.cat {\n-                    mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, .. }, .. }) |\n-                    mc::cat_local(vid) => {\n+                    Categorization::Upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, .. }, .. }) |\n+                    Categorization::Local(vid) => {\n                         self.reassigned |= self.node == vid &&\n                             (self.field.is_none() || Some(field) == self.field)\n                     },"}, {"sha": "0949244f9459c07f6f56ca19929a08bef8d99a55", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -88,6 +88,7 @@ use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n use middle::implicator::{self, Implication};\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::Categorization;\n use middle::region::CodeExtent;\n use middle::subst::Substs;\n use middle::traits;\n@@ -1058,7 +1059,7 @@ fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 't\n                                                             cmt: mc::cmt<'tcx>,\n                                                             span: Span) {\n     match cmt.cat {\n-        mc::cat_rvalue(region) => {\n+        Categorization::Rvalue(region) => {\n             match region {\n                 ty::ReScope(rvalue_scope) => {\n                     let typ = rcx.resolve_type(cmt.ty);\n@@ -1299,10 +1300,10 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                borrow_kind,\n                borrow_cmt);\n         match borrow_cmt.cat.clone() {\n-            mc::cat_deref(ref_cmt, _,\n-                          mc::Implicit(ref_kind, ref_region)) |\n-            mc::cat_deref(ref_cmt, _,\n-                          mc::BorrowedPtr(ref_kind, ref_region)) => {\n+            Categorization::Deref(ref_cmt, _,\n+                                  mc::Implicit(ref_kind, ref_region)) |\n+            Categorization::Deref(ref_cmt, _,\n+                                  mc::BorrowedPtr(ref_kind, ref_region)) => {\n                 match link_reborrowed_region(rcx, span,\n                                              borrow_region, borrow_kind,\n                                              ref_cmt, ref_region, ref_kind,\n@@ -1317,20 +1318,20 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 }\n             }\n \n-            mc::cat_downcast(cmt_base, _) |\n-            mc::cat_deref(cmt_base, _, mc::Unique) |\n-            mc::cat_interior(cmt_base, _) => {\n+            Categorization::Downcast(cmt_base, _) |\n+            Categorization::Deref(cmt_base, _, mc::Unique) |\n+            Categorization::Interior(cmt_base, _) => {\n                 // Borrowing interior or owned data requires the base\n                 // to be valid and borrowable in the same fashion.\n                 borrow_cmt = cmt_base;\n                 borrow_kind = borrow_kind;\n             }\n \n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-            mc::cat_static_item |\n-            mc::cat_upvar(..) |\n-            mc::cat_local(..) |\n-            mc::cat_rvalue(..) => {\n+            Categorization::Deref(_, _, mc::UnsafePtr(..)) |\n+            Categorization::StaticItem |\n+            Categorization::Upvar(..) |\n+            Categorization::Local(..) |\n+            Categorization::Rvalue(..) => {\n                 // These are all \"base cases\" with independent lifetimes\n                 // that are not subject to inference\n                 return;"}, {"sha": "d4a2fe872652dd44c4330fb89dc4d45444f57417", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=9e135f7b1595dc7ca1c3d7f220d619886ef8ccbd", "patch": "@@ -45,6 +45,7 @@ use super::FnCtxt;\n use check::demand;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n+use middle::mem_categorization::Categorization;\n use middle::ty::{self, Ty};\n use middle::infer::{InferCtxt, UpvarRegion};\n use std::collections::HashSet;\n@@ -294,8 +295,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n                guarantor);\n         match guarantor.cat {\n-            mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n-            mc::cat_deref(_, _, mc::Implicit(..)) => {\n+            Categorization::Deref(_, _, mc::BorrowedPtr(..)) |\n+            Categorization::Deref(_, _, mc::Implicit(..)) => {\n                 match cmt.note {\n                     mc::NoteUpvarRef(upvar_id) => {\n                         debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n@@ -334,16 +335,16 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                cmt);\n \n         match cmt.cat.clone() {\n-            mc::cat_deref(base, _, mc::Unique) |\n-            mc::cat_interior(base, _) |\n-            mc::cat_downcast(base, _) => {\n+            Categorization::Deref(base, _, mc::Unique) |\n+            Categorization::Interior(base, _) |\n+            Categorization::Downcast(base, _) => {\n                 // Interior or owned data is mutable if base is\n                 // mutable, so iterate to the base.\n                 self.adjust_upvar_borrow_kind_for_mut(base);\n             }\n \n-            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n-            mc::cat_deref(base, _, mc::Implicit(..)) => {\n+            Categorization::Deref(base, _, mc::BorrowedPtr(..)) |\n+            Categorization::Deref(base, _, mc::Implicit(..)) => {\n                 if !self.try_adjust_upvar_deref(&cmt.note, ty::MutBorrow) {\n                     // assignment to deref of an `&mut`\n                     // borrowed pointer implies that the\n@@ -353,11 +354,11 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                 }\n             }\n \n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-            mc::cat_static_item |\n-            mc::cat_rvalue(_) |\n-            mc::cat_local(_) |\n-            mc::cat_upvar(..) => {\n+            Categorization::Deref(_, _, mc::UnsafePtr(..)) |\n+            Categorization::StaticItem |\n+            Categorization::Rvalue(_) |\n+            Categorization::Local(_) |\n+            Categorization::Upvar(..) => {\n                 return;\n             }\n         }\n@@ -368,28 +369,28 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                cmt);\n \n         match cmt.cat.clone() {\n-            mc::cat_deref(base, _, mc::Unique) |\n-            mc::cat_interior(base, _) |\n-            mc::cat_downcast(base, _) => {\n+            Categorization::Deref(base, _, mc::Unique) |\n+            Categorization::Interior(base, _) |\n+            Categorization::Downcast(base, _) => {\n                 // Interior or owned data is unique if base is\n                 // unique.\n                 self.adjust_upvar_borrow_kind_for_unique(base);\n             }\n \n-            mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n-            mc::cat_deref(base, _, mc::Implicit(..)) => {\n+            Categorization::Deref(base, _, mc::BorrowedPtr(..)) |\n+            Categorization::Deref(base, _, mc::Implicit(..)) => {\n                 if !self.try_adjust_upvar_deref(&cmt.note, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n                     self.adjust_upvar_borrow_kind_for_unique(base);\n                 }\n             }\n \n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-            mc::cat_static_item |\n-            mc::cat_rvalue(_) |\n-            mc::cat_local(_) |\n-            mc::cat_upvar(..) => {\n+            Categorization::Deref(_, _, mc::UnsafePtr(..)) |\n+            Categorization::StaticItem |\n+            Categorization::Rvalue(_) |\n+            Categorization::Local(_) |\n+            Categorization::Upvar(..) => {\n             }\n         }\n     }"}]}