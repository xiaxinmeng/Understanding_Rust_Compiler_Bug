{"sha": "50f94f6c95c944f08c4af264f48260e42efefd47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZjk0ZjZjOTVjOTQ0ZjA4YzRhZjI2NGY0ODI2MGU0MmVmZWZkNDc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-02T22:01:35Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-13T05:11:45Z"}, "message": "Avoid needless reexpansions.", "tree": {"sha": "3df5ddaa6ecb78d6a0ad8f4399b54c660b2f3df0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3df5ddaa6ecb78d6a0ad8f4399b54c660b2f3df0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f94f6c95c944f08c4af264f48260e42efefd47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f94f6c95c944f08c4af264f48260e42efefd47", "html_url": "https://github.com/rust-lang/rust/commit/50f94f6c95c944f08c4af264f48260e42efefd47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f94f6c95c944f08c4af264f48260e42efefd47/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f81f4964d26683c9a47ff4516a97ab84095d7bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f81f4964d26683c9a47ff4516a97ab84095d7bc9", "html_url": "https://github.com/rust-lang/rust/commit/f81f4964d26683c9a47ff4516a97ab84095d7bc9"}], "stats": {"total": 34, "additions": 18, "deletions": 16}, "files": [{"sha": "f6eb6f1da4f19f069b38d29a657cd99394ccb024", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50f94f6c95c944f08c4af264f48260e42efefd47/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f94f6c95c944f08c4af264f48260e42efefd47/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=50f94f6c95c944f08c4af264f48260e42efefd47", "patch": "@@ -13,7 +13,7 @@ pub use self::SyntaxExtension::*;\n use ast;\n use ast::{Name, PatKind};\n use attr::HasAttrs;\n-use codemap::{self, CodeMap, ExpnInfo};\n+use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n use ext;\n@@ -805,8 +805,8 @@ impl<'a> ExtCtxt<'a> {\n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n-pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                      -> Option<(InternedString, ast::StrStyle)> {\n+pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+                              -> Option<Spanned<(InternedString, ast::StrStyle)>> {\n     // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n         expr.span.expn_id = cx.backtrace;\n@@ -817,14 +817,19 @@ pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n-            ast::LitKind::Str(ref s, style) => return Some(((*s).clone(), style)),\n+            ast::LitKind::Str(ref s, style) => return Some(respan(expr.span, (s.clone(), style))),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n     }\n     None\n }\n \n+pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+                      -> Option<(InternedString, ast::StrStyle)> {\n+    expr_to_spanned_string(cx, expr, err_msg).map(|s| s.node)\n+}\n+\n /// Non-fatally assert that `tts` is empty. Note that this function\n /// returns even when `tts` is non-empty, macros that *need* to stop\n /// compilation should call\n@@ -851,7 +856,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None\n     }\n-    let ret = cx.expander().fold_expr(panictry!(p.parse_expr()));\n+    let ret = panictry!(p.parse_expr());\n     if p.token != token::Eof {\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n     }"}, {"sha": "892ebcfa76129ee468188419c22db46ebf7b81ec", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/50f94f6c95c944f08c4af264f48260e42efefd47/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f94f6c95c944f08c4af264f48260e42efefd47/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=50f94f6c95c944f08c4af264f48260e42efefd47", "patch": "@@ -17,7 +17,6 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::fold::Folder;\n use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -702,10 +701,12 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let macsp = ecx.call_site();\n-    // Expand the format literal so that efmt.span will have a backtrace. This\n-    // is essential for locating a bug when the format literal is generated in\n-    // a macro. (e.g. println!(\"{}\"), which uses concat!($fmt, \"\\n\")).\n-    let efmt = ecx.expander().fold_expr(efmt);\n+    let msg = \"format argument must be a string literal.\";\n+    let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n+        Some(fmt) => fmt,\n+        None => return DummyResult::raw_expr(sp),\n+    };\n+\n     let mut cx = Context {\n         ecx: ecx,\n         args: args,\n@@ -723,14 +724,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         str_pieces: Vec::new(),\n         all_pieces_simple: true,\n         macsp: macsp,\n-        fmtsp: efmt.span,\n-    };\n-    let fmt = match expr_to_string(cx.ecx, efmt, \"format argument must be a string literal.\") {\n-        Some((fmt, _)) => fmt,\n-        None => return DummyResult::raw_expr(sp),\n+        fmtsp: fmt.span,\n     };\n \n-    let mut parser = parse::Parser::new(&fmt);\n+    let mut parser = parse::Parser::new(&fmt.node.0);\n     let mut pieces = vec![];\n \n     loop {"}]}