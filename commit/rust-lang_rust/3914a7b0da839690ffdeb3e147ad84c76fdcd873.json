{"sha": "3914a7b0da839690ffdeb3e147ad84c76fdcd873", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MTRhN2IwZGE4Mzk2OTBmZmRlYjNlMTQ3YWQ4NGM3NmZkY2Q4NzM=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-06-12T08:25:41Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-08-12T22:18:46Z"}, "message": "where available use 64- or 128bit atomics instead of a Mutex to monotonize time", "tree": {"sha": "cfdf011ced982fc64506b8d31f88acac000165b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfdf011ced982fc64506b8d31f88acac000165b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3914a7b0da839690ffdeb3e147ad84c76fdcd873", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3914a7b0da839690ffdeb3e147ad84c76fdcd873", "html_url": "https://github.com/rust-lang/rust/commit/3914a7b0da839690ffdeb3e147ad84c76fdcd873", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3914a7b0da839690ffdeb3e147ad84c76fdcd873/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae90dcf0207c57c3034f00b07048d63f8b2363c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae90dcf0207c57c3034f00b07048d63f8b2363c8", "html_url": "https://github.com/rust-lang/rust/commit/ae90dcf0207c57c3034f00b07048d63f8b2363c8"}], "stats": {"total": 134, "additions": 122, "deletions": 12}, "files": [{"sha": "ec105f231e5a75c344327ffe565f06e8d976999c", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3914a7b0da839690ffdeb3e147ad84c76fdcd873/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3914a7b0da839690ffdeb3e147ad84c76fdcd873/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=3914a7b0da839690ffdeb3e147ad84c76fdcd873", "patch": "@@ -12,15 +12,14 @@\n \n #![stable(feature = \"time\", since = \"1.3.0\")]\n \n+mod monotonic;\n #[cfg(test)]\n mod tests;\n \n-use crate::cmp;\n use crate::error::Error;\n use crate::fmt;\n use crate::ops::{Add, AddAssign, Sub, SubAssign};\n use crate::sys::time;\n-use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::FromInner;\n \n #[stable(feature = \"time\", since = \"1.3.0\")]\n@@ -249,14 +248,7 @@ impl Instant {\n             return Instant(os_now);\n         }\n \n-        static LOCK: StaticMutex = StaticMutex::new();\n-        static mut LAST_NOW: time::Instant = time::Instant::zero();\n-        unsafe {\n-            let _lock = LOCK.lock();\n-            let now = cmp::max(LAST_NOW, os_now);\n-            LAST_NOW = now;\n-            Instant(now)\n-        }\n+        Instant(monotonic::monotonize(os_now))\n     }\n \n     /// Returns the amount of time elapsed from another instant to this one."}, {"sha": "4f79b670a3ae916f616037718aa917253d6bc6ea", "filename": "library/std/src/time/monotonic.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3914a7b0da839690ffdeb3e147ad84c76fdcd873/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3914a7b0da839690ffdeb3e147ad84c76fdcd873/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs?ref=3914a7b0da839690ffdeb3e147ad84c76fdcd873", "patch": "@@ -0,0 +1,93 @@\n+use crate::sys::time;\n+\n+#[inline]\n+pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n+    inner::monotonize(raw)\n+}\n+\n+#[cfg(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")))]\n+pub mod inner {\n+    use crate::sync::atomic::AtomicU64;\n+    use crate::sync::atomic::Ordering::*;\n+    use crate::sys::time;\n+    use crate::time::Duration;\n+\n+    const ZERO: time::Instant = time::Instant::zero();\n+\n+    // bits 30 and 31 are never used since the seconds part never exceeds 10^9\n+    const UNINITIALIZED: u64 = 0xff00_0000;\n+    static MONO: AtomicU64 = AtomicU64::new(UNINITIALIZED);\n+\n+    #[inline]\n+    pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n+        let delta = raw.checked_sub_instant(&ZERO).unwrap();\n+        let secs = delta.as_secs();\n+        // occupies no more than 30 bits (10^9 seconds)\n+        let nanos = delta.subsec_nanos() as u64;\n+\n+        // This wraps around every 136 years (2^32 seconds).\n+        // To detect backsliding we use wrapping arithmetic and declare forward steps smaller\n+        // than 2^31 seconds as expected and everything else as a backslide which will be\n+        // monotonized.\n+        // This could be a problem for programs that call instants at intervals greater\n+        // than 68 years. Interstellar probes may want to ensure that actually_monotonic() is true.\n+        let packed = (secs << 32) | nanos;\n+        let old = MONO.load(Relaxed);\n+\n+        if packed == UNINITIALIZED || packed.wrapping_sub(old) < u64::MAX / 2 {\n+            MONO.store(packed, Relaxed);\n+            raw\n+        } else {\n+            // Backslide occurred. We reconstruct monotonized time by assuming the clock will never\n+            // backslide more than 2`32 seconds which means we can reuse the upper 32bits from\n+            // the seconds.\n+            let secs = (secs & 0xffff_ffff << 32) | old >> 32;\n+            let nanos = old as u32;\n+            ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n+        }\n+    }\n+}\n+\n+#[cfg(target_has_atomic = \"128\")]\n+pub mod inner {\n+    use crate::sync::atomic::AtomicU128;\n+    use crate::sync::atomic::Ordering::*;\n+    use crate::sys::time;\n+    use crate::time::Duration;\n+\n+    const ZERO: time::Instant = time::Instant::zero();\n+    static MONO: AtomicU128 = AtomicU128::new(0);\n+\n+    #[inline]\n+    pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n+        let delta = raw.checked_sub_instant(&ZERO).unwrap();\n+        // Split into seconds and nanos since Duration doesn't have a\n+        // constructor that takes an u128\n+        let secs = delta.as_secs() as u128;\n+        let nanos = delta.subsec_nanos() as u128;\n+        let timestamp: u128 = secs << 64 | nanos;\n+        let timestamp = MONO.fetch_max(timestamp, Relaxed).max(timestamp);\n+        let secs = (timestamp >> 64) as u64;\n+        let nanos = timestamp as u32;\n+        ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n+    }\n+}\n+\n+#[cfg(not(any(target_has_atomic = \"64\", target_has_atomic = \"128\")))]\n+pub mod inner {\n+    use crate::cmp;\n+    use crate::sys::time;\n+    use crate::sys_common::mutex::StaticMutex;\n+\n+    #[inline]\n+    pub(super) fn monotonize(os_now: time::Instant) -> time::Instant {\n+        static LOCK: StaticMutex = StaticMutex::new();\n+        static mut LAST_NOW: time::Instant = time::Instant::zero();\n+        unsafe {\n+            let _lock = LOCK.lock();\n+            let now = cmp::max(LAST_NOW, os_now);\n+            LAST_NOW = now;\n+            now\n+        }\n+    }\n+}"}, {"sha": "c5c8f192768a95dfd89fc12ac3139dfc7ee08186", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3914a7b0da839690ffdeb3e147ad84c76fdcd873/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3914a7b0da839690ffdeb3e147ad84c76fdcd873/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=3914a7b0da839690ffdeb3e147ad84c76fdcd873", "patch": "@@ -13,8 +13,33 @@ macro_rules! assert_almost_eq {\n #[test]\n fn instant_monotonic() {\n     let a = Instant::now();\n-    let b = Instant::now();\n-    assert!(b >= a);\n+    loop {\n+        let b = Instant::now();\n+        assert!(b >= a);\n+        if b > a {\n+            break;\n+        }\n+    }\n+}\n+\n+#[test]\n+fn instant_monotonic_concurrent() -> crate::thread::Result<()> {\n+    let threads: Vec<_> = (0..8)\n+        .map(|_| {\n+            crate::thread::spawn(|| {\n+                let mut old = Instant::now();\n+                for _ in 0..5_000_000 {\n+                    let new = Instant::now();\n+                    assert!(new >= old);\n+                    old = new;\n+                }\n+            })\n+        })\n+        .collect();\n+    for t in threads {\n+        t.join()?;\n+    }\n+    Ok(())\n }\n \n #[test]"}]}