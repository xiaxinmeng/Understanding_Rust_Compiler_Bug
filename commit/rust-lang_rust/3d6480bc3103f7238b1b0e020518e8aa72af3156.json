{"sha": "3d6480bc3103f7238b1b0e020518e8aa72af3156", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNjQ4MGJjMzEwM2Y3MjM4YjFiMGUwMjA1MThlOGFhNzJhZjMxNTY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-12T19:19:13Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-13T12:29:47Z"}, "message": "Render Fn* trait objects and impl types as rust does", "tree": {"sha": "080939aab1f5304b0ba22615547baa16141e83df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/080939aab1f5304b0ba22615547baa16141e83df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d6480bc3103f7238b1b0e020518e8aa72af3156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6480bc3103f7238b1b0e020518e8aa72af3156", "html_url": "https://github.com/rust-lang/rust/commit/3d6480bc3103f7238b1b0e020518e8aa72af3156", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d6480bc3103f7238b1b0e020518e8aa72af3156/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e3ab549d5a73f85e19eed5b915d78870f8892c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e3ab549d5a73f85e19eed5b915d78870f8892c", "html_url": "https://github.com/rust-lang/rust/commit/e9e3ab549d5a73f85e19eed5b915d78870f8892c"}], "stats": {"total": 163, "additions": 133, "deletions": 30}, "files": [{"sha": "d2f1b401481578f37912554314e42b04234a9dd4", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=3d6480bc3103f7238b1b0e020518e8aa72af3156", "patch": "@@ -1,14 +1,15 @@\n //! FIXME: write short doc here\n \n-use std::fmt;\n+use std::{borrow::Cow, fmt};\n \n use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDefId, FnSig, GenericPredicate,\n-    Lifetime, Obligation, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n+use arrayvec::ArrayVec;\n use hir_def::{\n-    find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId, AssocContainerId,\n-    Lookup, ModuleId,\n+    db::DefDatabase, find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId,\n+    AssocContainerId, HasModule, Lookup, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n \n@@ -257,25 +258,45 @@ impl HirDisplay for ApplicationTy {\n                 t.hir_fmt(f)?;\n                 write!(f, \"; _]\")?;\n             }\n-            TypeCtor::RawPtr(m) => {\n+            TypeCtor::RawPtr(m) | TypeCtor::Ref(m) => {\n                 let t = self.parameters.as_single();\n+                let ty_display =\n+                    t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n-                write!(f, \"*{}\", m.as_keyword_for_ptr())?;\n-                if matches!(t, Ty::Dyn(predicates) if predicates.len() > 1) {\n-                    write!(f, \"(\")?;\n-                    t.hir_fmt(f)?;\n-                    write!(f, \")\")?;\n+                if matches!(self.ctor, TypeCtor::RawPtr(_)) {\n+                    write!(f, \"*{}\", m.as_keyword_for_ptr())?;\n                 } else {\n-                    t.hir_fmt(f)?;\n+                    write!(f, \"&{}\", m.as_keyword_for_ref())?;\n+                }\n+\n+                let datas;\n+                let predicates = match t {\n+                    Ty::Dyn(predicates) if predicates.len() > 1 => {\n+                        Cow::Borrowed(predicates.as_ref())\n+                    }\n+                    &Ty::Opaque(OpaqueTy {\n+                        opaque_ty_id: OpaqueTyId::ReturnTypeImplTrait(func, idx),\n+                        ref parameters,\n+                    }) => {\n+                        datas =\n+                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                        let data = (*datas)\n+                            .as_ref()\n+                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                        let bounds = data.subst(parameters);\n+                        Cow::Owned(bounds.value)\n+                    }\n+                    _ => Cow::Borrowed(&[][..]),\n+                };\n+\n+                if let [GenericPredicate::Implemented(trait_ref), _] = predicates.as_ref() {\n+                    let trait_ = trait_ref.trait_;\n+                    if fn_traits(f.db.upcast(), trait_).any(|it| it == trait_) {\n+                        return write!(f, \"{}\", ty_display);\n+                    }\n                 }\n-            }\n-            TypeCtor::Ref(m) => {\n-                let t = self.parameters.as_single();\n-                let ty_display =\n-                    t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n-                write!(f, \"&{}\", m.as_keyword_for_ref())?;\n-                if matches!(t, Ty::Dyn(predicates) if predicates.len() > 1) {\n+                if predicates.len() > 1 {\n                     write!(f, \"(\")?;\n                     write!(f, \"{}\", ty_display)?;\n                     write!(f, \")\")?;\n@@ -595,6 +616,17 @@ impl HirDisplay for FnSig {\n     }\n }\n \n+fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = TraitId> {\n+    let krate = trait_.lookup(db).container.module(db).krate;\n+    let fn_traits = [\n+        db.lang_item(krate, \"fn\".into()),\n+        db.lang_item(krate, \"fn_mut\".into()),\n+        db.lang_item(krate, \"fn_once\".into()),\n+    ];\n+    // FIXME: Replace ArrayVec when into_iter is a thing on arrays\n+    ArrayVec::from(fn_traits).into_iter().flatten().flat_map(|it| it.as_trait())\n+}\n+\n pub fn write_bounds_like_dyn_trait(\n     predicates: &[GenericPredicate],\n     f: &mut HirFormatter,\n@@ -607,10 +639,15 @@ pub fn write_bounds_like_dyn_trait(\n     // predicate for that trait).\n     let mut first = true;\n     let mut angle_open = false;\n+    let mut is_fn_trait = false;\n     for p in predicates.iter() {\n         match p {\n             GenericPredicate::Implemented(trait_ref) => {\n-                if angle_open {\n+                let trait_ = trait_ref.trait_;\n+                if !is_fn_trait {\n+                    is_fn_trait = fn_traits(f.db.upcast(), trait_).any(|it| it == trait_);\n+                }\n+                if !is_fn_trait && angle_open {\n                     write!(f, \">\")?;\n                     angle_open = false;\n                 }\n@@ -620,14 +657,27 @@ pub fn write_bounds_like_dyn_trait(\n                 // We assume that the self type is $0 (i.e. the\n                 // existential) here, which is the only thing that's\n                 // possible in actual Rust, and hence don't print it\n-                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name)?;\n-                if trait_ref.substs.len() > 1 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                    // there might be assoc type bindings, so we leave the angle brackets open\n-                    angle_open = true;\n+                write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n+                if let [_, params @ ..] = &*trait_ref.substs.0 {\n+                    if is_fn_trait {\n+                        if let Some(args) = params.first().and_then(|it| it.as_tuple()) {\n+                            write!(f, \"(\")?;\n+                            f.write_joined(&*args.0, \", \")?;\n+                            write!(f, \")\")?;\n+                        }\n+                    } else if !params.is_empty() {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(params, \", \")?;\n+                        // there might be assoc type bindings, so we leave the angle brackets open\n+                        angle_open = true;\n+                    }\n                 }\n             }\n+            GenericPredicate::Projection(projection_pred) if is_fn_trait => {\n+                is_fn_trait = false;\n+                write!(f, \" -> \")?;\n+                projection_pred.ty.hir_fmt(f)?;\n+            }\n             GenericPredicate::Projection(projection_pred) => {\n                 // in types in actual Rust, these will always come\n                 // after the corresponding Implemented predicate"}, {"sha": "3d29021aaf115129266eedc9c5ac65960e373e40", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=3d6480bc3103f7238b1b0e020518e8aa72af3156", "patch": "@@ -39,3 +39,18 @@ fn main() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn render_raw_ptr_impl_ty() {\n+    check_types_source_code(\n+        r#\"\n+trait Sized {}\n+trait Unpin {}\n+fn foo() -> *const (impl Unpin + Sized) { loop {} }\n+fn main() {\n+    let foo = foo();\n+    foo;\n+}   //^ *const (impl Unpin + Sized)\n+\"#,\n+    );\n+}"}, {"sha": "e5a3f95a6c1de1999dbdcd3dbcffd4d23f8f18b2", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=3d6480bc3103f7238b1b0e020518e8aa72af3156", "patch": "@@ -3038,16 +3038,16 @@ fn infer_box_fn_arg() {\n             406..417 '&self.inner': &*mut T\n             407..411 'self': &Box<T>\n             407..417 'self.inner': *mut T\n-            478..575 '{     ...(&s) }': FnOnce::Output<dyn FnOnce<(&Option<i32>,)>, (&Option<i32>,)>\n+            478..575 '{     ...(&s) }': FnOnce::Output<dyn FnOnce(&Option<i32>), (&Option<i32>,)>\n             488..489 's': Option<i32>\n             492..504 'Option::None': Option<i32>\n-            514..515 'f': Box<dyn FnOnce<(&Option<i32>,)>>\n+            514..515 'f': Box<dyn FnOnce(&Option<i32>)>\n             549..562 'box (|ps| {})': Box<|{unknown}| -> ()>\n             554..561 '|ps| {}': |{unknown}| -> ()\n             555..557 'ps': {unknown}\n             559..561 '{}': ()\n-            568..569 'f': Box<dyn FnOnce<(&Option<i32>,)>>\n-            568..573 'f(&s)': FnOnce::Output<dyn FnOnce<(&Option<i32>,)>, (&Option<i32>,)>\n+            568..569 'f': Box<dyn FnOnce(&Option<i32>)>\n+            568..573 'f(&s)': FnOnce::Output<dyn FnOnce(&Option<i32>), (&Option<i32>,)>\n             570..572 '&s': &Option<i32>\n             571..572 's': Option<i32>\n         \"#]],"}, {"sha": "a2039fcc73cd6fd08b6dd1da737f3765475125d4", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=3d6480bc3103f7238b1b0e020518e8aa72af3156", "patch": "@@ -1398,6 +1398,43 @@ fn main() {\n     Foo::bar(&Foo);\n            //^^^^ self\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn fn_hints() {\n+        check(\n+            r#\"\n+trait Sized {}\n+\n+fn foo() -> impl Fn() { loop {} }\n+fn foo1() -> impl Fn(f64) { loop {} }\n+fn foo2() -> impl Fn(f64, f64) { loop {} }\n+fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n+fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n+fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n+fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n+fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo();\n+     // ^^^ impl Fn()\n+    let foo = foo1();\n+     // ^^^ impl Fn(f64)\n+    let foo = foo2();\n+     // ^^^ impl Fn(f64, f64)\n+    let foo = foo3();\n+     // ^^^ impl Fn(f64, f64) -> u32\n+    let foo = foo4();\n+     // ^^^ &dyn Fn(f64, f64) -> u32\n+    let foo = foo5();\n+     // ^^^ &dyn Fn(&dyn Fn(f64, f64) -> u32, f64) -> u32\n+    let foo = foo6();\n+     // ^^^ impl Fn(f64, f64) -> u32 + Sized\n+    let foo = foo7();\n+     // ^^^ *const (impl Fn(f64, f64) -> u32 + Sized)\n+}\n \"#,\n         )\n     }"}, {"sha": "5e88de64dbfd99fc3ad3748967f1281a06a973ff", "filename": "crates/ide_db/src/helpers/famous_defs_fixture.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs_fixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6480bc3103f7238b1b0e020518e8aa72af3156/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs_fixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs_fixture.rs?ref=3d6480bc3103f7238b1b0e020518e8aa72af3156", "patch": "@@ -1,4 +1,5 @@\n //- /libcore.rs crate:core\n+//! Signatures of traits, types and functions from the core lib for use in tests.\n pub mod convert {\n     pub trait From<T> {\n         fn from(t: T) -> Self;"}, {"sha": "6abad189adfadb1d4df6013606aaedfa9bf41c25", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d6480bc3103f7238b1b0e020518e8aa72af3156/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6480bc3103f7238b1b0e020518e8aa72af3156/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=3d6480bc3103f7238b1b0e020518e8aa72af3156", "patch": "@@ -324,7 +324,7 @@ impl TidyDocs {\n         }\n \n         fn is_exclude_file(d: &Path) -> bool {\n-            let file_names = [\"tests.rs\"];\n+            let file_names = [\"tests.rs\", \"famous_defs_fixture.rs\"];\n \n             d.file_name()\n                 .unwrap_or_default()"}]}