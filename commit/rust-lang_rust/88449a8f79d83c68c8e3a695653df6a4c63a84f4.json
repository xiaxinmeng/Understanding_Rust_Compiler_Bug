{"sha": "88449a8f79d83c68c8e3a695653df6a4c63a84f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NDQ5YThmNzlkODNjNjhjOGUzYTY5NTY1M2RmNmE0YzYzYTg0ZjQ=", "commit": {"author": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-03T05:47:38Z"}, "committer": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-03T14:36:07Z"}, "message": "add naivest entry API to VecMap", "tree": {"sha": "7bec75645fb7bf85174e113fb076e20aafc9cce3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bec75645fb7bf85174e113fb076e20aafc9cce3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88449a8f79d83c68c8e3a695653df6a4c63a84f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88449a8f79d83c68c8e3a695653df6a4c63a84f4", "html_url": "https://github.com/rust-lang/rust/commit/88449a8f79d83c68c8e3a695653df6a4c63a84f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88449a8f79d83c68c8e3a695653df6a4c63a84f4/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaf4c5c784637f3df8bdebc6ec21dbd4bc69420a", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf4c5c784637f3df8bdebc6ec21dbd4bc69420a", "html_url": "https://github.com/rust-lang/rust/commit/eaf4c5c784637f3df8bdebc6ec21dbd4bc69420a"}], "stats": {"total": 194, "additions": 193, "deletions": 1}, "files": [{"sha": "70af10fa567cd128291d41fa7c4e02f694f29617", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 193, "deletions": 1, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/88449a8f79d83c68c8e3a695653df6a4c63a84f4/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88449a8f79d83c68c8e3a695653df6a4c63a84f4/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=88449a8f79d83c68c8e3a695653df6a4c63a84f4", "patch": "@@ -13,6 +13,8 @@\n \n #![allow(missing_docs)]\n \n+pub use self::Entry::*;\n+\n use core::prelude::*;\n \n use core::cmp::Ordering;\n@@ -66,6 +68,32 @@ pub struct VecMap<V> {\n     v: Vec<Option<V>>,\n }\n \n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n+pub enum Entry<'a, V:'a> {\n+    /// A vacant Entry\n+    Vacant(VacantEntry<'a, V>),\n+    /// An occupied Entry\n+    Occupied(OccupiedEntry<'a, V>),\n+}\n+\n+/// A vacant Entry.\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n+pub struct VacantEntry<'a, V:'a> {\n+    map: &'a mut VecMap<V>,\n+    index: usize,\n+}\n+\n+/// An occupied Entry.\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n+pub struct OccupiedEntry<'a, V:'a> {\n+    map: &'a mut VecMap<V>,\n+    index: usize,\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Default for VecMap<V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -485,6 +513,119 @@ impl<V> VecMap<V> {\n         let result = &mut self.v[*key];\n         result.take()\n     }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    /// use std::collections::vec_map::Entry;\n+    ///\n+    /// let mut count: VecMap<u32> = VecMap::new();\n+    ///\n+    /// // count the number of occurrences of numbers in the vec\n+    /// for x in vec![1, 2, 1, 2, 3, 4, 1, 2, 4].iter() {\n+    ///     match count.entry(*x) {\n+    ///         Entry::Vacant(view) => {\n+    ///             view.insert(1);\n+    ///         },\n+    ///         Entry::Occupied(mut view) => {\n+    ///             let v = view.get_mut();\n+    ///             *v += 1;\n+    ///         },\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(count[1], 3);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"precise API still under development\")]\n+    pub fn entry(&mut self, key: usize) -> Entry<V> {\n+        // FIXME(Gankro): this is basically the dumbest implementation of\n+        // entry possible, because weird non-lexical borrows issues make it\n+        // completely insane to do any other way. That said, Entry is a border-line\n+        // useless construct on VecMap, so it's hardly a big loss.\n+        if self.contains_key(&key) {\n+            Occupied(OccupiedEntry {\n+                map: self,\n+                index: key,\n+            })\n+        } else {\n+            Vacant(VacantEntry {\n+                map: self,\n+                index: key,\n+            })\n+        }\n+    }\n+}\n+\n+\n+impl<'a, V> Entry<'a, V> {\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, V>> {\n+        match self {\n+            Occupied(entry) => Ok(entry.into_mut()),\n+            Vacant(entry) => Err(entry),\n+        }\n+    }\n+}\n+\n+impl<'a, V> VacantEntry<'a, V> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        let index = self.index;\n+        self.map.insert(index, value);\n+        &mut self.map[index]\n+    }\n+}\n+\n+impl<'a, V> OccupiedEntry<'a, V> {\n+    /// Gets a reference to the value in the entry.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn get(&self) -> &V {\n+        let index = self.index;\n+        &self.map[index]\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        let index = self.index;\n+        &mut self.map[index]\n+    }\n+\n+    /// Converts the entry into a mutable reference to its value.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn into_mut(self) -> &'a mut V {\n+        let index = self.index;\n+        &mut self.map[index]\n+    }\n+\n+    /// Sets the value of the entry with the OccupiedEntry's key,\n+    /// and returns the entry's old value.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn insert(&mut self, value: V) -> V {\n+        let index = self.index;\n+        self.map.insert(index, value).unwrap()\n+    }\n+\n+    /// Takes the value of the entry out of the map, and returns it.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn remove(self) -> V {\n+        let index = self.index;\n+        self.map.remove(&index).unwrap()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -787,7 +928,7 @@ mod test_map {\n     use prelude::*;\n     use core::hash::{hash, SipHasher};\n \n-    use super::VecMap;\n+    use super::{VecMap, Occupied, Vacant};\n \n     #[test]\n     fn test_get_mut() {\n@@ -1139,6 +1280,57 @@ mod test_map {\n \n         map[4];\n     }\n+\n+    #[test]\n+    fn test_entry(){\n+        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+        let mut map: VecMap<i32> = xs.iter().map(|&x| x).collect();\n+\n+        // Existing key (insert)\n+        match map.entry(1) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                assert_eq!(view.get(), &10);\n+                assert_eq!(view.insert(100), 10);\n+            }\n+        }\n+        assert_eq!(map.get(&1).unwrap(), &100);\n+        assert_eq!(map.len(), 6);\n+\n+\n+        // Existing key (update)\n+        match map.entry(2) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                let v = view.get_mut();\n+                *v *= 10;\n+            }\n+        }\n+        assert_eq!(map.get(&2).unwrap(), &200);\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (take)\n+        match map.entry(3) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(view) => {\n+                assert_eq!(view.remove(), 30);\n+            }\n+        }\n+        assert_eq!(map.get(&3), None);\n+        assert_eq!(map.len(), 5);\n+\n+\n+        // Inexistent key (insert)\n+        match map.entry(10) {\n+            Occupied(_) => unreachable!(),\n+            Vacant(view) => {\n+                assert_eq!(*view.insert(1000), 1000);\n+            }\n+        }\n+        assert_eq!(map.get(&10).unwrap(), &1000);\n+        assert_eq!(map.len(), 6);\n+    }\n }\n \n #[cfg(test)]"}]}