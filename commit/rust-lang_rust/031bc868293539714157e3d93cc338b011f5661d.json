{"sha": "031bc868293539714157e3d93cc338b011f5661d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMWJjODY4MjkzNTM5NzE0MTU3ZTNkOTNjYzMzOGIwMTFmNTY2MWQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-21T11:57:32Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-21T11:57:32Z"}, "message": "Merge #236\n\n236: WIP: Module name resolution r=matklad a=matklad\n\nwork towards #231 \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "624843cfddada855a6a80380e817bb188596c441", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/624843cfddada855a6a80380e817bb188596c441"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/031bc868293539714157e3d93cc338b011f5661d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/031bc868293539714157e3d93cc338b011f5661d", "html_url": "https://github.com/rust-lang/rust/commit/031bc868293539714157e3d93cc338b011f5661d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/031bc868293539714157e3d93cc338b011f5661d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "713c3ea30b38199e05e1f70094d85177f16915f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/713c3ea30b38199e05e1f70094d85177f16915f8", "html_url": "https://github.com/rust-lang/rust/commit/713c3ea30b38199e05e1f70094d85177f16915f8"}, {"sha": "5a61b218f8869532ccb6be9dccff9e7d8641bf49", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a61b218f8869532ccb6be9dccff9e7d8641bf49", "html_url": "https://github.com/rust-lang/rust/commit/5a61b218f8869532ccb6be9dccff9e7d8641bf49"}], "stats": {"total": 735, "additions": 556, "deletions": 179}, "files": [{"sha": "012453497d15da94ebabc0797b9a0b682da894d3", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -9,7 +9,7 @@ env:\n \n build: &rust_build\n   language: rust\n-  rust: beta\n+  rust: beta-2018-11-19\n   script:\n     - cargo gen-tests --verify\n     - cargo gen-syntax --verify"}, {"sha": "a8a752fc70a3b210b2c0e2d3a7326bb08116682a", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -204,9 +204,9 @@ mod tests {\n                 <|>\n             }\n             \",\n-            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"Baz\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+            r#\"[CompletionItem { label: \"quux\", lookup: None, snippet: None },\n+                CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n+                CompletionItem { label: \"Baz\", lookup: None, snippet: None }]\"#,\n         );\n     }\n \n@@ -230,8 +230,8 @@ mod tests {\n                 fn quux() { <|> }\n             }\n             \",\n-            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+            r#\"[CompletionItem { label: \"quux\", lookup: None, snippet: None },\n+                CompletionItem { label: \"Bar\", lookup: None, snippet: None }]\"#,\n         );\n     }\n "}, {"sha": "84383b54759409d7295b4b1a85eb1290bc134f26", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -39,14 +39,17 @@ pub(super) fn completions(\n             let module_scope = module.scope(db)?;\n             acc.extend(\n                 module_scope\n-                    .entries()\n+                    .items\n                     .iter()\n-                    .filter(|entry| {\n+                    .filter(|(_name, res)| {\n                         // Don't expose this item\n-                        !entry.ptr().range().is_subrange(&name_ref.syntax().range())\n+                        match res.import_name {\n+                            None => true,\n+                            Some(ptr) => !ptr.range().is_subrange(&name_ref.syntax().range()),\n+                        }\n                     })\n-                    .map(|entry| CompletionItem {\n-                        label: entry.name().to_string(),\n+                    .map(|(name, _res)| CompletionItem {\n+                        label: name.to_string(),\n                         lookup: None,\n                         snippet: None,\n                     }),\n@@ -173,11 +176,14 @@ fn complete_path(\n         Some(it) => it,\n     };\n     let module_scope = target_module.scope(db)?;\n-    let completions = module_scope.entries().iter().map(|entry| CompletionItem {\n-        label: entry.name().to_string(),\n-        lookup: None,\n-        snippet: None,\n-    });\n+    let completions = module_scope\n+        .items\n+        .iter()\n+        .map(|(name, _res)| CompletionItem {\n+            label: name.to_string(),\n+            lookup: None,\n+            snippet: None,\n+        });\n     acc.extend(completions);\n     Ok(())\n }"}, {"sha": "887d687ea939480e984b6757395037d51ecc0b08", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -7,8 +7,8 @@ use salsa::{self, Database};\n use crate::{\n     db,\n     descriptors::{\n-        DescriptorDatabase, FnScopesQuery, FnSyntaxQuery, ModuleScopeQuery, ModuleTreeQuery,\n-        SubmodulesQuery,\n+        DescriptorDatabase, FnScopesQuery, FnSyntaxQuery, ModuleTreeQuery,\n+        SubmodulesQuery, ItemMapQuery, InputModuleItemsQuery,\n     },\n     symbol_index::SymbolIndex,\n     syntax_ptr::SyntaxPtr,\n@@ -85,8 +85,9 @@ salsa::database_storage! {\n         }\n         impl DescriptorDatabase {\n             fn module_tree() for ModuleTreeQuery;\n-            fn module_scope() for ModuleScopeQuery;\n             fn fn_scopes() for FnScopesQuery;\n+            fn _input_module_items() for InputModuleItemsQuery;\n+            fn _item_map() for ItemMapQuery;\n             fn _fn_syntax() for FnSyntaxQuery;\n             fn _submodules() for SubmodulesQuery;\n         }"}, {"sha": "6b56d92e1669d2d9e7b076bea0b496b0c3ca2933", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n use crate::{\n     db::SyntaxDatabase,\n     descriptors::function::{resolve_local_name, FnId, FnScopes},\n-    descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource},\n+    descriptors::module::{ModuleId, ModuleTree, ModuleSource, nameres::{ItemMap, InputModuleItems}},\n     input::SourceRootId,\n     loc2id::IdDatabase,\n     syntax_ptr::LocalSyntaxPtr,\n@@ -25,14 +25,18 @@ salsa::query_group! {\n             use fn function::imp::fn_scopes;\n         }\n \n+        fn _input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n+            type InputModuleItemsQuery;\n+            use fn module::nameres::input_module_items;\n+        }\n+        fn _item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n+            type ItemMapQuery;\n+            use fn module::nameres::item_map;\n+        }\n         fn _module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n             type ModuleTreeQuery;\n             use fn module::imp::module_tree;\n         }\n-        fn _module_scope(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleScope>> {\n-            type ModuleScopeQuery;\n-            use fn module::imp::module_scope;\n-        }\n         fn _fn_syntax(fn_id: FnId) -> FnDefNode {\n             type FnSyntaxQuery;\n             // Don't retain syntax trees in memory"}, {"sha": "d4dce861fafe7f23571a58fa87bb18c5e834c3f5", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    ast::{self, ModuleItemOwner, NameOwner},\n+    ast::{self, NameOwner},\n     SmolStr,\n };\n use relative_path::RelativePathBuf;\n@@ -15,7 +15,7 @@ use crate::{\n };\n \n use super::{\n-    LinkData, LinkId, ModuleData, ModuleId, ModuleScope, ModuleSource, ModuleSourceNode,\n+    LinkData, LinkId, ModuleData, ModuleId, ModuleSource, ModuleSourceNode,\n     ModuleTree, Problem,\n };\n \n@@ -81,23 +81,6 @@ pub(crate) fn modules<'a>(\n         })\n }\n \n-pub(crate) fn module_scope(\n-    db: &impl DescriptorDatabase,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n-) -> Cancelable<Arc<ModuleScope>> {\n-    let tree = db._module_tree(source_root_id)?;\n-    let source = module_id.source(&tree).resolve(db);\n-    let res = match source {\n-        ModuleSourceNode::SourceFile(it) => ModuleScope::new(it.borrowed().items()),\n-        ModuleSourceNode::Module(it) => match it.borrowed().item_list() {\n-            Some(items) => ModuleScope::new(items.items()),\n-            None => ModuleScope::new(std::iter::empty()),\n-        },\n-    };\n-    Ok(Arc::new(res))\n-}\n-\n pub(crate) fn module_tree(\n     db: &impl DescriptorDatabase,\n     source_root: SourceRootId,"}, {"sha": "cfdffcdbcc9b89f0bcf2c9d2296b86e720337e53", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -1,5 +1,5 @@\n pub(super) mod imp;\n-pub(crate) mod scope;\n+pub(super) mod nameres;\n \n use std::sync::Arc;\n \n@@ -18,7 +18,7 @@ use crate::{\n     input::SourceRootId\n };\n \n-pub(crate) use self::scope::ModuleScope;\n+pub(crate) use self::{nameres::ModuleScope};\n \n /// `ModuleDescriptor` is API entry point to get all the information\n /// about a particular module.\n@@ -102,9 +102,11 @@ impl ModuleDescriptor {\n \n     /// The root of the tree this module is part of\n     pub fn crate_root(&self) -> ModuleDescriptor {\n-        generate(Some(self.clone()), |it| it.parent())\n-            .last()\n-            .unwrap()\n+        let root_id = self.module_id.crate_root(&self.tree);\n+        ModuleDescriptor {\n+            module_id: root_id,\n+            ..self.clone()\n+        }\n     }\n \n     /// `name` is `None` for the crate's root module\n@@ -123,8 +125,10 @@ impl ModuleDescriptor {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(&self, db: &impl DescriptorDatabase) -> Cancelable<Arc<ModuleScope>> {\n-        db._module_scope(self.source_root_id, self.module_id)\n+    pub(crate) fn scope(&self, db: &impl DescriptorDatabase) -> Cancelable<ModuleScope> {\n+        let item_map = db._item_map(self.source_root_id)?;\n+        let res = item_map.per_module[&self.module_id].clone();\n+        Ok(res)\n     }\n \n     pub fn problems(&self, db: &impl DescriptorDatabase) -> Vec<(SyntaxNode, Problem)> {\n@@ -146,6 +150,13 @@ pub(crate) struct ModuleTree {\n }\n \n impl ModuleTree {\n+    fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n+        self.mods\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, _)| ModuleId(idx as u32))\n+    }\n+\n     fn modules_for_source(&self, source: ModuleSource) -> Vec<ModuleId> {\n         self.mods\n             .iter()\n@@ -204,6 +215,11 @@ impl ModuleId {\n         let link = self.parent_link(tree)?;\n         Some(tree.link(link).owner)\n     }\n+    fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n+        generate(Some(self), move |it| it.parent(tree))\n+            .last()\n+            .unwrap()\n+    }\n     fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n         let link = tree\n             .module(self)\n@@ -213,6 +229,13 @@ impl ModuleId {\n             .find(|it| it.name == name)?;\n         Some(*link.points_to.first()?)\n     }\n+    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (SmolStr, ModuleId)> + 'a {\n+        tree.module(self).children.iter().filter_map(move |&it| {\n+            let link = tree.link(it);\n+            let module = *link.points_to.first()?;\n+            Some((link.name.clone(), module))\n+        })\n+    }\n     fn problems(self, tree: &ModuleTree, db: &impl SyntaxDatabase) -> Vec<(SyntaxNode, Problem)> {\n         tree.module(self)\n             .children"}, {"sha": "c5bf467cab9d9eb6fdd775cc6b50415c31ecfe98", "filename": "crates/ra_analysis/src/descriptors/module/nameres.rs", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -0,0 +1,453 @@\n+//! Name resolution algorithm\n+use std::{\n+    sync::Arc,\n+    time::Instant,\n+};\n+\n+use rustc_hash::FxHashMap;\n+\n+use ra_syntax::{\n+    SmolStr, SyntaxKind::{self, *},\n+    ast::{self, AstNode, ModuleItemOwner}\n+};\n+\n+use crate::{\n+    Cancelable,\n+    loc2id::{DefId, DefLoc},\n+    descriptors::{\n+        DescriptorDatabase,\n+        module::{ModuleId, ModuleTree, ModuleSourceNode},\n+    },\n+    syntax_ptr::{LocalSyntaxPtr},\n+    input::SourceRootId,\n+};\n+\n+/// Item map is the result of the name resolution. Item map contains, for each\n+/// module, the set of visible items.\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct ItemMap {\n+    pub(crate) per_module: FxHashMap<ModuleId, ModuleScope>,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq, Clone)]\n+pub(crate) struct ModuleScope {\n+    pub(crate) items: FxHashMap<SmolStr, Resolution>,\n+    pub(crate) import_resolutions: FxHashMap<LocalSyntaxPtr, DefId>,\n+}\n+\n+/// A set of items and imports declared inside a module, without relation to\n+/// other modules.\n+///\n+/// This stands in-between raw syntax and name resolution and alow us to avoid\n+/// recomputing name res: if `InputModuleItems` are the same, we can avoid\n+/// running name resolution.\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub(crate) struct InputModuleItems {\n+    items: Vec<ModuleItem>,\n+    glob_imports: Vec<Path>,\n+    imports: Vec<Path>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+struct Path {\n+    kind: PathKind,\n+    segments: Vec<(LocalSyntaxPtr, SmolStr)>,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum PathKind {\n+    Abs,\n+    Self_,\n+    Super,\n+    Crate,\n+}\n+\n+pub(crate) fn input_module_items(\n+    db: &impl DescriptorDatabase,\n+    source_root: SourceRootId,\n+    module_id: ModuleId,\n+) -> Cancelable<Arc<InputModuleItems>> {\n+    let module_tree = db._module_tree(source_root)?;\n+    let source = module_id.source(&module_tree);\n+    let res = match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => {\n+            let items = it.borrowed().items();\n+            InputModuleItems::new(items)\n+        }\n+        ModuleSourceNode::Module(it) => {\n+            let items = it\n+                .borrowed()\n+                .item_list()\n+                .into_iter()\n+                .flat_map(|it| it.items());\n+            InputModuleItems::new(items)\n+        }\n+    };\n+    Ok(Arc::new(res))\n+}\n+\n+pub(crate) fn item_map(\n+    db: &impl DescriptorDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<Arc<ItemMap>> {\n+    let start = Instant::now();\n+    let module_tree = db._module_tree(source_root)?;\n+    let input = module_tree\n+        .modules()\n+        .map(|id| {\n+            let items = db._input_module_items(source_root, id)?;\n+            Ok((id, items))\n+        })\n+        .collect::<Cancelable<FxHashMap<_, _>>>()?;\n+\n+    let mut resolver = Resolver {\n+        db: db,\n+        input: &input,\n+        source_root,\n+        module_tree,\n+        result: ItemMap::default(),\n+    };\n+    resolver.resolve()?;\n+    let res = resolver.result;\n+    let elapsed = start.elapsed();\n+    log::info!(\"item_map: {:?}\", elapsed);\n+    Ok(Arc::new(res))\n+}\n+\n+/// Resolution is basically `DefId` atm, but it should account for stuff like\n+/// multiple namespaces, ambiguity and errors.\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct Resolution {\n+    /// None for unresolved\n+    pub(crate) def_id: Option<DefId>,\n+    /// ident by whitch this is imported into local scope.\n+    /// TODO: make this offset-independent.\n+    pub(crate) import_name: Option<LocalSyntaxPtr>,\n+}\n+\n+// #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+// enum Namespace {\n+//     Types,\n+//     Values,\n+// }\n+\n+// #[derive(Debug)]\n+// struct PerNs<T> {\n+//     types: Option<T>,\n+//     values: Option<T>,\n+// }\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct ModuleItem {\n+    ptr: LocalSyntaxPtr,\n+    name: SmolStr,\n+    kind: SyntaxKind,\n+    vis: Vis,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum Vis {\n+    // Priv,\n+    Other,\n+}\n+\n+impl InputModuleItems {\n+    fn new<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> InputModuleItems {\n+        let mut res = InputModuleItems::default();\n+        for item in items {\n+            res.add_item(item);\n+        }\n+        res\n+    }\n+\n+    fn add_item(&mut self, item: ast::ModuleItem) -> Option<()> {\n+        match item {\n+            ast::ModuleItem::StructDef(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::EnumDef(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::FnDef(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::TraitDef(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::TypeDef(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::ImplItem(_) => {\n+                // impls don't define items\n+            }\n+            ast::ModuleItem::UseItem(it) => self.add_use_item(it),\n+            ast::ModuleItem::ExternCrateItem(_) => {\n+                // TODO\n+            }\n+            ast::ModuleItem::ConstDef(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::StaticDef(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::Module(it) => self.items.push(ModuleItem::new(it)?),\n+        }\n+        Some(())\n+    }\n+\n+    fn add_use_item(&mut self, item: ast::UseItem) {\n+        if let Some(tree) = item.use_tree() {\n+            self.add_use_tree(None, tree);\n+        }\n+    }\n+\n+    fn add_use_tree(&mut self, prefix: Option<Path>, tree: ast::UseTree) {\n+        if let Some(use_tree_list) = tree.use_tree_list() {\n+            let prefix = match tree.path() {\n+                None => prefix,\n+                Some(path) => match convert_path(prefix, path) {\n+                    Some(it) => Some(it),\n+                    None => return, // TODO: report errors somewhere\n+                },\n+            };\n+            for tree in use_tree_list.use_trees() {\n+                self.add_use_tree(prefix.clone(), tree);\n+            }\n+        } else {\n+            if let Some(path) = tree.path() {\n+                if let Some(path) = convert_path(prefix, path) {\n+                    if tree.has_star() {\n+                        &mut self.glob_imports\n+                    } else {\n+                        &mut self.imports\n+                    }\n+                    .push(path);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n+    let prefix = if let Some(qual) = path.qualifier() {\n+        Some(convert_path(prefix, qual)?)\n+    } else {\n+        None\n+    };\n+    let segment = path.segment()?;\n+    let res = match segment.kind()? {\n+        ast::PathSegmentKind::Name(name) => {\n+            let mut res = prefix.unwrap_or_else(|| Path {\n+                kind: PathKind::Abs,\n+                segments: Vec::with_capacity(1),\n+            });\n+            let ptr = LocalSyntaxPtr::new(name.syntax());\n+            res.segments.push((ptr, name.text()));\n+            res\n+        }\n+        ast::PathSegmentKind::CrateKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Crate,\n+                segments: Vec::new(),\n+            }\n+        }\n+        ast::PathSegmentKind::SelfKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Self_,\n+                segments: Vec::new(),\n+            }\n+        }\n+        ast::PathSegmentKind::SuperKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path {\n+                kind: PathKind::Super,\n+                segments: Vec::new(),\n+            }\n+        }\n+    };\n+    Some(res)\n+}\n+\n+impl ModuleItem {\n+    fn new<'a>(item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n+        let name = item.name()?.text();\n+        let ptr = LocalSyntaxPtr::new(item.syntax());\n+        let kind = item.syntax().kind();\n+        let vis = Vis::Other;\n+        let res = ModuleItem {\n+            ptr,\n+            name,\n+            kind,\n+            vis,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+struct Resolver<'a, DB> {\n+    db: &'a DB,\n+    input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n+    source_root: SourceRootId,\n+    module_tree: Arc<ModuleTree>,\n+    result: ItemMap,\n+}\n+\n+impl<'a, DB> Resolver<'a, DB>\n+where\n+    DB: DescriptorDatabase,\n+{\n+    fn resolve(&mut self) -> Cancelable<()> {\n+        for (&module_id, items) in self.input.iter() {\n+            self.populate_module(module_id, items)\n+        }\n+\n+        for &module_id in self.input.keys() {\n+            crate::db::check_canceled(self.db)?;\n+            self.resolve_imports(module_id);\n+        }\n+        Ok(())\n+    }\n+\n+    fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) {\n+        let file_id = module_id.source(&self.module_tree).file_id();\n+\n+        let mut module_items = ModuleScope::default();\n+\n+        for import in input.imports.iter() {\n+            if let Some((ptr, name)) = import.segments.last() {\n+                module_items.items.insert(\n+                    name.clone(),\n+                    Resolution {\n+                        def_id: None,\n+                        import_name: Some(*ptr),\n+                    },\n+                );\n+            }\n+        }\n+\n+        for item in input.items.iter() {\n+            if item.kind == MODULE {\n+                // handle submodules separatelly\n+                continue;\n+            }\n+            let ptr = item.ptr.into_global(file_id);\n+            let def_loc = DefLoc::Item { ptr };\n+            let def_id = self.db.id_maps().def_id(def_loc);\n+            let resolution = Resolution {\n+                def_id: Some(def_id),\n+                import_name: None,\n+            };\n+            module_items.items.insert(item.name.clone(), resolution);\n+        }\n+\n+        for (name, mod_id) in module_id.children(&self.module_tree) {\n+            let def_loc = DefLoc::Module {\n+                id: mod_id,\n+                source_root: self.source_root,\n+            };\n+            let def_id = self.db.id_maps().def_id(def_loc);\n+            let resolution = Resolution {\n+                def_id: Some(def_id),\n+                import_name: None,\n+            };\n+            module_items.items.insert(name, resolution);\n+        }\n+\n+        self.result.per_module.insert(module_id, module_items);\n+    }\n+\n+    fn resolve_imports(&mut self, module_id: ModuleId) {\n+        for import in self.input[&module_id].imports.iter() {\n+            self.resolve_import(module_id, import);\n+        }\n+    }\n+\n+    fn resolve_import(&mut self, module_id: ModuleId, import: &Path) {\n+        let mut curr = match import.kind {\n+            // TODO: handle extern crates\n+            PathKind::Abs => return,\n+            PathKind::Self_ => module_id,\n+            PathKind::Super => {\n+                match module_id.parent(&self.module_tree) {\n+                    Some(it) => it,\n+                    // TODO: error\n+                    None => return,\n+                }\n+            }\n+            PathKind::Crate => module_id.crate_root(&self.module_tree),\n+        };\n+\n+        for (i, (ptr, name)) in import.segments.iter().enumerate() {\n+            let is_last = i == import.segments.len() - 1;\n+\n+            let def_id = match self.result.per_module[&curr].items.get(name) {\n+                None => return,\n+                Some(res) => match res.def_id {\n+                    Some(it) => it,\n+                    None => return,\n+                },\n+            };\n+\n+            self.update(module_id, |items| {\n+                items.import_resolutions.insert(*ptr, def_id);\n+            });\n+\n+            if !is_last {\n+                curr = match self.db.id_maps().def_loc(def_id) {\n+                    DefLoc::Module { id, .. } => id,\n+                    _ => return,\n+                }\n+            } else {\n+                self.update(module_id, |items| {\n+                    let res = Resolution {\n+                        def_id: Some(def_id),\n+                        import_name: Some(*ptr),\n+                    };\n+                    items.items.insert(name.clone(), res);\n+                })\n+            }\n+        }\n+    }\n+\n+    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n+        let module_items = self.result.per_module.get_mut(&module_id).unwrap();\n+        f(module_items)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        mock_analysis::analysis_and_position,\n+        descriptors::{DescriptorDatabase, module::ModuleDescriptor},\n+        input::FilesDatabase,\n+};\n+    use super::*;\n+\n+    fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n+        let (analysis, pos) = analysis_and_position(fixture);\n+        let db = analysis.imp.db;\n+        let source_root = db.file_source_root(pos.file_id);\n+        let descr = ModuleDescriptor::guess_from_position(&*db, pos)\n+            .unwrap()\n+            .unwrap();\n+        let module_id = descr.module_id;\n+        (db._item_map(source_root).unwrap(), module_id)\n+    }\n+\n+    #[test]\n+    fn test_item_map() {\n+        let (item_map, module_id) = item_map(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+            <|>\n+\n+            //- /foo/mod.rs\n+            pub mod bar;\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+        \",\n+        );\n+        let name = SmolStr::from(\"Baz\");\n+        let resolution = &item_map.per_module[&module_id].items[&name];\n+        assert!(resolution.def_id.is_some());\n+    }\n+}"}, {"sha": "4490228e41aa6ba4ba202a58cb190e6d33e9a78b", "filename": "crates/ra_analysis/src/descriptors/module/scope.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/713c3ea30b38199e05e1f70094d85177f16915f8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs?ref=713c3ea30b38199e05e1f70094d85177f16915f8", "patch": "@@ -1,124 +0,0 @@\n-//! Backend for module-level scope resolution & completion\n-\n-use ra_syntax::{ast, AstNode, SmolStr};\n-\n-use crate::syntax_ptr::LocalSyntaxPtr;\n-\n-/// `ModuleScope` contains all named items declared in the scope.\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleScope {\n-    entries: Vec<Entry>,\n-}\n-\n-/// `Entry` is a single named declaration iside a module.\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct Entry {\n-    ptr: LocalSyntaxPtr,\n-    kind: EntryKind,\n-    name: SmolStr,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-enum EntryKind {\n-    Item,\n-    Import,\n-}\n-\n-impl ModuleScope {\n-    pub(super) fn new<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n-        let mut entries = Vec::new();\n-        for item in items {\n-            let entry = match item {\n-                ast::ModuleItem::StructDef(item) => Entry::new(item),\n-                ast::ModuleItem::EnumDef(item) => Entry::new(item),\n-                ast::ModuleItem::FnDef(item) => Entry::new(item),\n-                ast::ModuleItem::ConstDef(item) => Entry::new(item),\n-                ast::ModuleItem::StaticDef(item) => Entry::new(item),\n-                ast::ModuleItem::TraitDef(item) => Entry::new(item),\n-                ast::ModuleItem::TypeDef(item) => Entry::new(item),\n-                ast::ModuleItem::Module(item) => Entry::new(item),\n-                ast::ModuleItem::UseItem(item) => {\n-                    if let Some(tree) = item.use_tree() {\n-                        collect_imports(tree, &mut entries);\n-                    }\n-                    continue;\n-                }\n-                ast::ModuleItem::ExternCrateItem(_) | ast::ModuleItem::ImplItem(_) => continue,\n-            };\n-            entries.extend(entry)\n-        }\n-\n-        ModuleScope { entries }\n-    }\n-\n-    pub fn entries(&self) -> &[Entry] {\n-        self.entries.as_slice()\n-    }\n-}\n-\n-impl Entry {\n-    fn new<'a>(item: impl ast::NameOwner<'a>) -> Option<Entry> {\n-        let name = item.name()?;\n-        Some(Entry {\n-            name: name.text(),\n-            ptr: LocalSyntaxPtr::new(name.syntax()),\n-            kind: EntryKind::Item,\n-        })\n-    }\n-    fn new_import(path: ast::Path) -> Option<Entry> {\n-        let name_ref = path.segment()?.name_ref()?;\n-        Some(Entry {\n-            name: name_ref.text(),\n-            ptr: LocalSyntaxPtr::new(name_ref.syntax()),\n-            kind: EntryKind::Import,\n-        })\n-    }\n-    pub fn name(&self) -> &SmolStr {\n-        &self.name\n-    }\n-    pub fn ptr(&self) -> LocalSyntaxPtr {\n-        self.ptr\n-    }\n-}\n-\n-fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n-    if let Some(use_tree_list) = tree.use_tree_list() {\n-        return use_tree_list\n-            .use_trees()\n-            .for_each(|it| collect_imports(it, acc));\n-    }\n-    if let Some(path) = tree.path() {\n-        acc.extend(Entry::new_import(path));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ra_syntax::{ast::ModuleItemOwner, SourceFileNode};\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let file = SourceFileNode::parse(&code);\n-        let scope = ModuleScope::new(file.ast().items());\n-        let actual = scope.entries.iter().map(|it| it.name()).collect::<Vec<_>>();\n-        assert_eq!(expected, actual.as_slice());\n-    }\n-\n-    #[test]\n-    fn test_module_scope() {\n-        do_check(\n-            \"\n-            struct Foo;\n-            enum Bar {}\n-            mod baz {}\n-            fn quux() {}\n-            use x::{\n-                y::z,\n-                t,\n-            };\n-            type T = ();\n-        \",\n-            &[\"Foo\", \"Bar\", \"baz\", \"quux\", \"z\", \"t\", \"T\"],\n-        )\n-    }\n-}"}, {"sha": "e4b55f9b0a5748c0d3e993985b895546e115654e", "filename": "crates/ra_analysis/src/loc2id.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Floc2id.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -8,7 +8,9 @@ use std::{\n use rustc_hash::FxHashMap;\n \n use crate::{\n+    descriptors::module::ModuleId,\n     syntax_ptr::SyntaxPtr,\n+    input::SourceRootId,\n };\n \n /// There are two principle ways to refer to things:\n@@ -89,6 +91,21 @@ macro_rules! impl_numeric_id {\n pub(crate) struct FnId(u32);\n impl_numeric_id!(FnId);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct DefId(u32);\n+impl_numeric_id!(DefId);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum DefLoc {\n+    Module {\n+        id: ModuleId,\n+        source_root: SourceRootId,\n+    },\n+    Item {\n+        ptr: SyntaxPtr,\n+    },\n+}\n+\n pub(crate) trait IdDatabase: salsa::Database {\n     fn id_maps(&self) -> &IdMaps;\n }\n@@ -105,9 +122,17 @@ impl IdMaps {\n     pub(crate) fn fn_ptr(&self, fn_id: FnId) -> SyntaxPtr {\n         self.inner.fns.lock().id2loc(fn_id)\n     }\n+\n+    pub(crate) fn def_id(&self, loc: DefLoc) -> DefId {\n+        self.inner.defs.lock().loc2id(&loc)\n+    }\n+    pub(crate) fn def_loc(&self, def_id: DefId) -> DefLoc {\n+        self.inner.defs.lock().id2loc(def_id)\n+    }\n }\n \n #[derive(Debug, Default)]\n struct IdMapsInner {\n     fns: Mutex<Loc2IdMap<SyntaxPtr, FnId>>,\n+    defs: Mutex<Loc2IdMap<DefLoc, DefId>>,\n }"}, {"sha": "72b2ebf970baa5fefcf020844ee569d6680ff687", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -447,8 +447,8 @@ fn test_complete_crate_path() {\n     );\n     let completions = analysis.completions(position).unwrap().unwrap();\n     assert_eq_dbg(\n-        r#\"[CompletionItem { label: \"foo\", lookup: None, snippet: None },\n-            CompletionItem { label: \"Spam\", lookup: None, snippet: None }]\"#,\n+        r#\"[CompletionItem { label: \"Spam\", lookup: None, snippet: None },\n+            CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n         &completions,\n     );\n }\n@@ -466,8 +466,8 @@ fn test_complete_crate_path_with_braces() {\n     );\n     let completions = analysis.completions(position).unwrap().unwrap();\n     assert_eq_dbg(\n-        r#\"[CompletionItem { label: \"foo\", lookup: None, snippet: None },\n-            CompletionItem { label: \"Spam\", lookup: None, snippet: None }]\"#,\n+        r#\"[CompletionItem { label: \"Spam\", lookup: None, snippet: None },\n+            CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n         &completions,\n     );\n }"}, {"sha": "91c67119fb880f1732cb9be3c04804c854814cbd", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -315,6 +315,12 @@ impl<'a> PathSegment<'a> {\n     }\n }\n \n+impl<'a> UseTree<'a> {\n+    pub fn has_star(self) -> bool {\n+        self.syntax().children().any(|it| it.kind() == STAR)\n+    }\n+}\n+\n impl<'a> UseTreeList<'a> {\n     pub fn parent_use_tree(self) -> UseTree<'a> {\n         self.syntax()"}, {"sha": "e81761cf2f7b7c423fde31ec1ba66bd22d3c8a98", "filename": "crates/tools/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/031bc868293539714157e3d93cc338b011f5661d/crates%2Ftools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/031bc868293539714157e3d93cc338b011f5661d/crates%2Ftools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Flib.rs?ref=031bc868293539714157e3d93cc338b011f5661d", "patch": "@@ -17,7 +17,7 @@ pub type Result<T> = ::std::result::Result<T, failure::Error>;\n pub const GRAMMAR: &str = \"crates/ra_syntax/src/grammar.ron\";\n pub const SYNTAX_KINDS: &str = \"crates/ra_syntax/src/syntax_kinds/generated.rs.tera\";\n pub const AST: &str = \"crates/ra_syntax/src/ast/generated.rs.tera\";\n-const TOOLCHAIN: &str = \"beta-2018-10-30\";\n+const TOOLCHAIN: &str = \"beta-2018-11-19\";\n \n #[derive(Debug)]\n pub struct Test {"}]}