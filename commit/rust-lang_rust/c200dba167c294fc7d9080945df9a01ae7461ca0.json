{"sha": "c200dba167c294fc7d9080945df9a01ae7461ca0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMDBkYmExNjdjMjk0ZmM3ZDkwODA5NDVkZjlhMDFhZTc0NjFjYTA=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-23T09:49:53Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-23T09:49:53Z"}, "message": "Add basic parameter name hints heuristics", "tree": {"sha": "6030d4f75e60600629a2bf116d56bdc7d982553f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6030d4f75e60600629a2bf116d56bdc7d982553f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c200dba167c294fc7d9080945df9a01ae7461ca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c200dba167c294fc7d9080945df9a01ae7461ca0", "html_url": "https://github.com/rust-lang/rust/commit/c200dba167c294fc7d9080945df9a01ae7461ca0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c200dba167c294fc7d9080945df9a01ae7461ca0/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1651ce0ebe1cf1d51541a04457f72595d669c967", "url": "https://api.github.com/repos/rust-lang/rust/commits/1651ce0ebe1cf1d51541a04457f72595d669c967", "html_url": "https://github.com/rust-lang/rust/commit/1651ce0ebe1cf1d51541a04457f72595d669c967"}], "stats": {"total": 228, "additions": 187, "deletions": 41}, "files": [{"sha": "2c4c932de9028bcc6ce2d6829f5a85d7338b3323", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c200dba167c294fc7d9080945df9a01ae7461ca0/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c200dba167c294fc7d9080945df9a01ae7461ca0/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=c200dba167c294fc7d9080945df9a01ae7461ca0", "patch": "@@ -38,6 +38,8 @@ pub struct FunctionSignature {\n     pub ret_type: Option<String>,\n     /// Where predicates\n     pub where_predicates: Vec<String>,\n+    /// Self param presence\n+    pub has_self_param: bool,\n }\n \n impl FunctionSignature {\n@@ -78,6 +80,7 @@ impl FunctionSignature {\n                 generic_parameters: generic_parameters(&node),\n                 where_predicates: where_predicates(&node),\n                 doc: None,\n+                has_self_param: false,\n             }\n             .with_doc_opt(st.docs(db)),\n         )\n@@ -115,6 +118,7 @@ impl FunctionSignature {\n                 generic_parameters: vec![],\n                 where_predicates: vec![],\n                 doc: None,\n+                has_self_param: false,\n             }\n             .with_doc_opt(variant.docs(db)),\n         )\n@@ -136,6 +140,7 @@ impl FunctionSignature {\n                 generic_parameters: vec![],\n                 where_predicates: vec![],\n                 doc: None,\n+                has_self_param: false,\n             }\n             .with_doc_opt(macro_def.docs(db)),\n         )\n@@ -144,16 +149,18 @@ impl FunctionSignature {\n \n impl From<&'_ ast::FnDef> for FunctionSignature {\n     fn from(node: &ast::FnDef) -> FunctionSignature {\n-        fn param_list(node: &ast::FnDef) -> Vec<String> {\n+        fn param_list(node: &ast::FnDef) -> (bool, Vec<String>) {\n             let mut res = vec![];\n+            let mut has_self_param = false;\n             if let Some(param_list) = node.param_list() {\n                 if let Some(self_param) = param_list.self_param() {\n+                    has_self_param = true;\n                     res.push(self_param.syntax().text().to_string())\n                 }\n \n                 res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n             }\n-            res\n+            (has_self_param, res)\n         }\n \n         fn param_name_list(node: &ast::FnDef) -> Vec<String> {\n@@ -183,6 +190,8 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n             res\n         }\n \n+        let (has_self_param, parameters) = param_list(node);\n+\n         FunctionSignature {\n             kind: CallableKind::Function,\n             visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n@@ -191,12 +200,13 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                 .ret_type()\n                 .and_then(|r| r.type_ref())\n                 .map(|n| n.syntax().text().to_string()),\n-            parameters: param_list(node),\n+            parameters,\n             parameter_names: param_name_list(node),\n             generic_parameters: generic_parameters(node),\n             where_predicates: where_predicates(node),\n             // docs are processed separately\n             doc: None,\n+            has_self_param,\n         }\n     }\n }"}, {"sha": "fb63fd1de433837b9de6d1c29b1cb96c6a5e7293", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 174, "deletions": 38, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/c200dba167c294fc7d9080945df9a01ae7461ca0/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c200dba167c294fc7d9080945df9a01ae7461ca0/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=c200dba167c294fc7d9080945df9a01ae7461ca0", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{Function, HirDisplay, SourceAnalyzer, SourceBinder};\n+use hir::{HirDisplay, SourceAnalyzer, SourceBinder};\n use once_cell::unsync::Lazy;\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n@@ -112,58 +112,73 @@ fn get_param_name_hints(\n     // we need args len to determine whether to skip or not the &self parameter\n     .collect::<Vec<_>>();\n \n-    let (has_self_param, fn_signature) = get_fn_signature(db, analyzer, &expr)?;\n-    let parameters = if has_self_param && fn_signature.parameter_names.len() > args.len() {\n-        fn_signature.parameter_names.into_iter().skip(1)\n-    } else {\n-        fn_signature.parameter_names.into_iter().skip(0)\n-    };\n-\n-    let hints =\n-        parameters\n-            .zip(args)\n-            .filter_map(|(param, arg)| {\n-                if !param.is_empty() {\n-                    Some((arg.syntax().text_range(), param))\n-                } else {\n-                    None\n-                }\n-            })\n-            .map(|(range, param_name)| InlayHint {\n-                range,\n-                kind: InlayKind::ParameterHint,\n-                label: param_name.into(),\n-            });\n+    let fn_signature = get_fn_signature(db, analyzer, &expr)?;\n+    let parameters =\n+        if fn_signature.has_self_param && fn_signature.parameter_names.len() > args.len() {\n+            fn_signature.parameter_names.iter().skip(1)\n+        } else {\n+            fn_signature.parameter_names.iter().skip(0)\n+        };\n+\n+    let hints = parameters\n+        .zip(args)\n+        .filter(|(param, arg)| {\n+            should_show_param_hint(&fn_signature, param, &arg.syntax().to_string())\n+        })\n+        .map(|(param_name, arg)| InlayHint {\n+            range: arg.syntax().text_range(),\n+            kind: InlayKind::ParameterHint,\n+            label: param_name.into(),\n+        });\n \n     acc.extend(hints);\n     Some(())\n }\n \n+fn should_show_param_hint(\n+    fn_signature: &FunctionSignature,\n+    param_name: &str,\n+    argument_string: &str,\n+) -> bool {\n+    if param_name.is_empty() || argument_string.ends_with(param_name) {\n+        return false;\n+    }\n+\n+    let parameters_len = if fn_signature.has_self_param {\n+        fn_signature.parameters.len() - 1\n+    } else {\n+        fn_signature.parameters.len()\n+    };\n+    // avoid displaying hints for common functions like map, filter, etc.\n+    if parameters_len == 1 && (param_name.len() == 1 || param_name == \"predicate\") {\n+        return false;\n+    }\n+\n+    true\n+}\n+\n fn get_fn_signature(\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n     expr: &ast::Expr,\n-) -> Option<(bool, FunctionSignature)> {\n+) -> Option<FunctionSignature> {\n     match expr {\n         ast::Expr::CallExpr(expr) => {\n             // FIXME: Type::as_callable is broken for closures\n             let callable_def = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::FunctionId(it) => {\n-                    let fn_def: Function = it.into();\n-                    Some((fn_def.has_self_param(db), FunctionSignature::from_hir(db, fn_def)))\n+                    Some(FunctionSignature::from_hir(db, it.into()))\n                 }\n-                hir::CallableDef::StructId(it) => FunctionSignature::from_struct(db, it.into())\n-                    .map(|signature| (false, signature)),\n+                hir::CallableDef::StructId(it) => FunctionSignature::from_struct(db, it.into()),\n                 hir::CallableDef::EnumVariantId(it) => {\n                     FunctionSignature::from_enum_variant(db, it.into())\n-                        .map(|signature| (false, signature))\n                 }\n             }\n         }\n         ast::Expr::MethodCallExpr(expr) => {\n             let fn_def = analyzer.resolve_method_call(&expr)?;\n-            Some((fn_def.has_self_param(db), FunctionSignature::from_hir(db, fn_def)))\n+            Some(FunctionSignature::from_hir(db, fn_def))\n         }\n         _ => None,\n     }\n@@ -723,12 +738,42 @@ fn main() {\n     fn function_call_parameter_hint() {\n         let (analysis, file_id) = single_file(\n             r#\"\n+enum CustomOption<T> {\n+    None,\n+    Some(T),\n+}\n+\n+struct FileId {}\n+struct SmolStr {}\n+\n+impl From<&str> for SmolStr {\n+    fn from(_: &str) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+struct TextRange {}\n+struct SyntaxKind {}\n+struct NavigationTarget {}\n+\n struct Test {}\n \n impl Test {\n     fn method(&self, mut param: i32) -> i32 {\n         param * 2\n     }\n+\n+    fn from_syntax(\n+        file_id: FileId,\n+        name: SmolStr,\n+        focus_range: CustomOption<TextRange>,\n+        full_range: TextRange,\n+        kind: SyntaxKind,\n+        docs: CustomOption<String>,\n+        description: CustomOption<String>,\n+    ) -> NavigationTarget {\n+        NavigationTarget {}\n+    }\n }\n \n fn test_func(mut foo: i32, bar: i32, msg: &str, _: i32, last: i32) -> i32 {\n@@ -741,53 +786,144 @@ fn main() {\n     let t: Test = Test {};\n     t.method(123);\n     Test::method(&t, 3456);\n+\n+    Test::from_syntax(\n+        FileId {},\n+        \"impl\".into(),\n+        CustomOption::None,\n+        TextRange {},\n+        SyntaxKind {},\n+        CustomOption::None,\n+        CustomOption::None,\n+    );\n }\"#,\n         );\n \n         assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n             InlayHint {\n-                range: [215; 226),\n+                range: [777; 788),\n                 kind: TypeHint,\n                 label: \"i32\",\n             },\n             InlayHint {\n-                range: [259; 260),\n+                range: [821; 822),\n                 kind: ParameterHint,\n                 label: \"foo\",\n             },\n             InlayHint {\n-                range: [262; 263),\n+                range: [824; 825),\n                 kind: ParameterHint,\n                 label: \"bar\",\n             },\n             InlayHint {\n-                range: [265; 272),\n+                range: [827; 834),\n                 kind: ParameterHint,\n                 label: \"msg\",\n             },\n             InlayHint {\n-                range: [277; 288),\n+                range: [839; 850),\n                 kind: ParameterHint,\n                 label: \"last\",\n             },\n             InlayHint {\n-                range: [331; 334),\n+                range: [893; 896),\n                 kind: ParameterHint,\n                 label: \"param\",\n             },\n             InlayHint {\n-                range: [354; 356),\n+                range: [916; 918),\n                 kind: ParameterHint,\n                 label: \"&self\",\n             },\n             InlayHint {\n-                range: [358; 362),\n+                range: [920; 924),\n                 kind: ParameterHint,\n                 label: \"param\",\n             },\n+            InlayHint {\n+                range: [959; 968),\n+                kind: ParameterHint,\n+                label: \"file_id\",\n+            },\n+            InlayHint {\n+                range: [978; 991),\n+                kind: ParameterHint,\n+                label: \"name\",\n+            },\n+            InlayHint {\n+                range: [1001; 1019),\n+                kind: ParameterHint,\n+                label: \"focus_range\",\n+            },\n+            InlayHint {\n+                range: [1029; 1041),\n+                kind: ParameterHint,\n+                label: \"full_range\",\n+            },\n+            InlayHint {\n+                range: [1051; 1064),\n+                kind: ParameterHint,\n+                label: \"kind\",\n+            },\n+            InlayHint {\n+                range: [1074; 1092),\n+                kind: ParameterHint,\n+                label: \"docs\",\n+            },\n+            InlayHint {\n+                range: [1102; 1120),\n+                kind: ParameterHint,\n+                label: \"description\",\n+            },\n         ]\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn omitted_parameters_hints_heuristics() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+fn map(f: i32) {}\n+fn filter(predicate: i32) {}\n+\n+struct TestVarContainer {\n+    test_var: i32,\n+}\n+\n+struct Test {}\n+\n+impl Test {\n+    fn map(self, f: i32) -> Self {\n+        self\n+    }\n+\n+    fn filter(self, predicate: i32) -> Self {\n+        self\n+    }\n+\n+    fn no_hints_expected(&self, _: i32, test_var: i32) {}\n+}\n+\n+fn main() {\n+    let container: TestVarContainer = TestVarContainer { test_var: 42 };\n+    let test: Test = Test {};\n+\n+    map(22);\n+    filter(33);\n+\n+    let test_processed: Test = test.map(1).filter(2);\n+\n+    let test_var: i32 = 55;\n+    test_processed.no_hints_expected(22, test_var);\n+    test_processed.no_hints_expected(33, container.test_var);\n+}\"#,\n+        );\n+\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, Some(8)).unwrap(), @r###\"\n+        []\n+        \"###\n+        );\n+    }\n }"}]}