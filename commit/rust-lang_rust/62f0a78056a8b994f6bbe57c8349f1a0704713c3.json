{"sha": "62f0a78056a8b994f6bbe57c8349f1a0704713c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZjBhNzgwNTZhOGI5OTRmNmJiZTU3YzgzNDlmMWEwNzA0NzEzYzM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-11T19:58:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-11T19:58:52Z"}, "message": "Rollup merge of #78216 - workingjubilee:duration-zero, r=m-ou-se\n\nDuration::zero() -> Duration::ZERO\n\nIn review for #72790, whether or not a constant or a function should be favored for `#![feature(duration_zero)]` was seen as an open question. In https://github.com/rust-lang/rust/issues/73544#issuecomment-691701670 an invitation was opened to either stabilize the methods or propose a switch to the constant value, supplemented with reasoning. Followup comments suggested community preference leans towards the const ZERO, which would be reason enough.\n\nZERO also \"makes sense\" beside existing associated consts for Duration. It is ever so slightly awkward to have a series of constants specifying 1 of various units but leave 0 as a method, especially when they are side-by-side in code. It seems unintuitive for the one non-dynamic value (that isn't from Default) to be not-a-const, which could hurt discoverability of the associated constants overall. Elsewhere in `std`, methods for obtaining a constant value were even deprecated, as seen with [std::u32::min_value](https://doc.rust-lang.org/std/primitive.u32.html#method.min_value).\n\nMost importantly, ZERO costs less to use. A match supports a const pattern, but const fn can only be used if evaluated through a const context such as an inline `const { const_fn() }` or a `const NAME: T = const_fn()` declaration elsewhere. Likewise, while https://github.com/rust-lang/rust/issues/73544#issuecomment-691949373 notes `Duration::zero()` can optimize to a constant value, \"can\" is not \"will\". Only const contexts have a strong promise of such. Even without that in mind, the comment in question still leans in favor of the constant for simplicity. As it costs less for a developer to use, may cost less to optimize, and seems to have more of a community consensus for it, the associated const seems best.\n\nr? ```@LukasKalbertodt```", "tree": {"sha": "180b09f663dab4de0b2e0efad5a20f919c0b7ec3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/180b09f663dab4de0b2e0efad5a20f919c0b7ec3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62f0a78056a8b994f6bbe57c8349f1a0704713c3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfrEJ9CRBK7hj4Ov3rIwAAdHIIAC4SG0JAVULTfUcVKozx9DPg\n25TNsr1p6jFif9D+htAQXTMXdTzb93W41y/HWJOmYpLpVftyPpUXxfblHeDertP4\nkY7TZeBWtfZpiSA+a9m15gXBIi41fL85VjogfE2/ACL8ortU2BcoyckBcDBSpY8l\n15NZn3gKttKAfkvsCOWNCJKVHtixOfNCNNB5Y2o2xLQIVjfk/FuLEwmBDgGpDTZ3\nG4ukQVIWgyJ1M2omGyvJIF3jCc64fVIaSjzwRvhTA32Jmg0yMAenFvJWYcOlibzc\n8cPLUOUeEQNE6Lj6rYAcE2fYZ3wBERky4n9Rkj4T1aC/PP8KXUmeKlhwo8ggZLQ=\n=YWMi\n-----END PGP SIGNATURE-----\n", "payload": "tree 180b09f663dab4de0b2e0efad5a20f919c0b7ec3\nparent 7afc5172305cdae588a0318ce545749cf4ed947d\nparent 82f3a236cdb80f65cd5b89a1cb015f95184bf66a\nauthor Jonas Schievink <jonasschievink@gmail.com> 1605124732 +0100\ncommitter GitHub <noreply@github.com> 1605124732 +0100\n\nRollup merge of #78216 - workingjubilee:duration-zero, r=m-ou-se\n\nDuration::zero() -> Duration::ZERO\n\nIn review for #72790, whether or not a constant or a function should be favored for `#![feature(duration_zero)]` was seen as an open question. In https://github.com/rust-lang/rust/issues/73544#issuecomment-691701670 an invitation was opened to either stabilize the methods or propose a switch to the constant value, supplemented with reasoning. Followup comments suggested community preference leans towards the const ZERO, which would be reason enough.\n\nZERO also \"makes sense\" beside existing associated consts for Duration. It is ever so slightly awkward to have a series of constants specifying 1 of various units but leave 0 as a method, especially when they are side-by-side in code. It seems unintuitive for the one non-dynamic value (that isn't from Default) to be not-a-const, which could hurt discoverability of the associated constants overall. Elsewhere in `std`, methods for obtaining a constant value were even deprecated, as seen with [std::u32::min_value](https://doc.rust-lang.org/std/primitive.u32.html#method.min_value).\n\nMost importantly, ZERO costs less to use. A match supports a const pattern, but const fn can only be used if evaluated through a const context such as an inline `const { const_fn() }` or a `const NAME: T = const_fn()` declaration elsewhere. Likewise, while https://github.com/rust-lang/rust/issues/73544#issuecomment-691949373 notes `Duration::zero()` can optimize to a constant value, \"can\" is not \"will\". Only const contexts have a strong promise of such. Even without that in mind, the comment in question still leans in favor of the constant for simplicity. As it costs less for a developer to use, may cost less to optimize, and seems to have more of a community consensus for it, the associated const seems best.\n\nr? ```@LukasKalbertodt```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62f0a78056a8b994f6bbe57c8349f1a0704713c3", "html_url": "https://github.com/rust-lang/rust/commit/62f0a78056a8b994f6bbe57c8349f1a0704713c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62f0a78056a8b994f6bbe57c8349f1a0704713c3/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7afc5172305cdae588a0318ce545749cf4ed947d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7afc5172305cdae588a0318ce545749cf4ed947d", "html_url": "https://github.com/rust-lang/rust/commit/7afc5172305cdae588a0318ce545749cf4ed947d"}, {"sha": "82f3a236cdb80f65cd5b89a1cb015f95184bf66a", "url": "https://api.github.com/repos/rust-lang/rust/commits/82f3a236cdb80f65cd5b89a1cb015f95184bf66a", "html_url": "https://github.com/rust-lang/rust/commit/82f3a236cdb80f65cd5b89a1cb015f95184bf66a"}], "stats": {"total": 170, "additions": 75, "deletions": 95}, "files": [{"sha": "88b4e2a2436e73a050dda5864e1bdfdfe00f6df4", "filename": "library/core/src/time.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/62f0a78056a8b994f6bbe57c8349f1a0704713c3/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0a78056a8b994f6bbe57c8349f1a0704713c3/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=62f0a78056a8b994f6bbe57c8349f1a0704713c3", "patch": "@@ -108,18 +108,20 @@ impl Duration {\n     #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n     pub const NANOSECOND: Duration = Duration::from_nanos(1);\n \n-    /// The minimum duration.\n+    /// A duration of zero time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(duration_constants)]\n+    /// #![feature(duration_zero)]\n     /// use std::time::Duration;\n     ///\n-    /// assert_eq!(Duration::MIN, Duration::new(0, 0));\n+    /// let duration = Duration::ZERO;\n+    /// assert!(duration.is_zero());\n+    /// assert_eq!(duration.as_nanos(), 0);\n     /// ```\n-    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n-    pub const MIN: Duration = Duration::from_nanos(0);\n+    #[unstable(feature = \"duration_zero\", issue = \"73544\")]\n+    pub const ZERO: Duration = Duration::from_nanos(0);\n \n     /// The maximum duration.\n     ///\n@@ -166,24 +168,6 @@ impl Duration {\n         Duration { secs, nanos }\n     }\n \n-    /// Creates a new `Duration` that spans no time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(duration_zero)]\n-    /// use std::time::Duration;\n-    ///\n-    /// let duration = Duration::zero();\n-    /// assert!(duration.is_zero());\n-    /// assert_eq!(duration.as_nanos(), 0);\n-    /// ```\n-    #[unstable(feature = \"duration_zero\", issue = \"73544\")]\n-    #[inline]\n-    pub const fn zero() -> Duration {\n-        Duration { secs: 0, nanos: 0 }\n-    }\n-\n     /// Creates a new `Duration` from the specified number of whole seconds.\n     ///\n     /// # Examples\n@@ -277,7 +261,7 @@ impl Duration {\n     /// #![feature(duration_zero)]\n     /// use std::time::Duration;\n     ///\n-    /// assert!(Duration::zero().is_zero());\n+    /// assert!(Duration::ZERO.is_zero());\n     /// assert!(Duration::new(0, 0).is_zero());\n     /// assert!(Duration::from_nanos(0).is_zero());\n     /// assert!(Duration::from_secs(0).is_zero());\n@@ -536,26 +520,26 @@ impl Duration {\n         }\n     }\n \n-    /// Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::MIN`]\n+    /// Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::ZERO`]\n     /// if the result would be negative or if overflow occurred.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(duration_saturating_ops)]\n-    /// #![feature(duration_constants)]\n+    /// #![feature(duration_zero)]\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 1).saturating_sub(Duration::new(0, 0)), Duration::new(0, 1));\n-    /// assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::MIN);\n+    /// assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::ZERO);\n     /// ```\n     #[unstable(feature = \"duration_saturating_ops\", issue = \"76416\")]\n     #[inline]\n     #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n     pub const fn saturating_sub(self, rhs: Duration) -> Duration {\n         match self.checked_sub(rhs) {\n             Some(res) => res,\n-            None => Duration::MIN,\n+            None => Duration::ZERO,\n         }\n     }\n "}, {"sha": "f14639e0d589fb95eeb5abc329ad0a9eba461d92", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/62f0a78056a8b994f6bbe57c8349f1a0704713c3/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0a78056a8b994f6bbe57c8349f1a0704713c3/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=62f0a78056a8b994f6bbe57c8349f1a0704713c3", "patch": "@@ -108,24 +108,24 @@ fn sub() {\n \n #[test]\n fn checked_sub() {\n-    let zero = Duration::new(0, 0);\n-    let one_nano = Duration::new(0, 1);\n-    let one_sec = Duration::new(1, 0);\n-    assert_eq!(one_nano.checked_sub(zero), Some(Duration::new(0, 1)));\n-    assert_eq!(one_sec.checked_sub(one_nano), Some(Duration::new(0, 999_999_999)));\n-    assert_eq!(zero.checked_sub(one_nano), None);\n-    assert_eq!(zero.checked_sub(one_sec), None);\n+    assert_eq!(Duration::NANOSECOND.checked_sub(Duration::ZERO), Some(Duration::NANOSECOND));\n+    assert_eq!(\n+        Duration::SECOND.checked_sub(Duration::NANOSECOND),\n+        Some(Duration::new(0, 999_999_999))\n+    );\n+    assert_eq!(Duration::ZERO.checked_sub(Duration::NANOSECOND), None);\n+    assert_eq!(Duration::ZERO.checked_sub(Duration::SECOND), None);\n }\n \n #[test]\n fn saturating_sub() {\n-    let zero = Duration::new(0, 0);\n-    let one_nano = Duration::new(0, 1);\n-    let one_sec = Duration::new(1, 0);\n-    assert_eq!(one_nano.saturating_sub(zero), Duration::new(0, 1));\n-    assert_eq!(one_sec.saturating_sub(one_nano), Duration::new(0, 999_999_999));\n-    assert_eq!(zero.saturating_sub(one_nano), Duration::MIN);\n-    assert_eq!(zero.saturating_sub(one_sec), Duration::MIN);\n+    assert_eq!(Duration::NANOSECOND.saturating_sub(Duration::ZERO), Duration::NANOSECOND);\n+    assert_eq!(\n+        Duration::SECOND.saturating_sub(Duration::NANOSECOND),\n+        Duration::new(0, 999_999_999)\n+    );\n+    assert_eq!(Duration::ZERO.saturating_sub(Duration::NANOSECOND), Duration::ZERO);\n+    assert_eq!(Duration::ZERO.saturating_sub(Duration::SECOND), Duration::ZERO);\n }\n \n #[test]\n@@ -337,87 +337,82 @@ fn duration_const() {\n     const SUB_SEC_NANOS: u32 = DURATION.subsec_nanos();\n     assert_eq!(SUB_SEC_NANOS, 123_456_789);\n \n-    const ZERO: Duration = Duration::zero();\n-    assert_eq!(ZERO, Duration::new(0, 0));\n-\n-    const IS_ZERO: bool = ZERO.is_zero();\n+    const IS_ZERO: bool = Duration::ZERO.is_zero();\n     assert!(IS_ZERO);\n \n-    const ONE: Duration = Duration::new(1, 0);\n-\n-    const SECONDS: u64 = ONE.as_secs();\n+    const SECONDS: u64 = Duration::SECOND.as_secs();\n     assert_eq!(SECONDS, 1);\n \n     const FROM_SECONDS: Duration = Duration::from_secs(1);\n-    assert_eq!(FROM_SECONDS, ONE);\n+    assert_eq!(FROM_SECONDS, Duration::SECOND);\n \n-    const SECONDS_F32: f32 = ONE.as_secs_f32();\n+    const SECONDS_F32: f32 = Duration::SECOND.as_secs_f32();\n     assert_eq!(SECONDS_F32, 1.0);\n \n     const FROM_SECONDS_F32: Duration = Duration::from_secs_f32(1.0);\n-    assert_eq!(FROM_SECONDS_F32, ONE);\n+    assert_eq!(FROM_SECONDS_F32, Duration::SECOND);\n \n-    const SECONDS_F64: f64 = ONE.as_secs_f64();\n+    const SECONDS_F64: f64 = Duration::SECOND.as_secs_f64();\n     assert_eq!(SECONDS_F64, 1.0);\n \n     const FROM_SECONDS_F64: Duration = Duration::from_secs_f64(1.0);\n-    assert_eq!(FROM_SECONDS_F64, ONE);\n+    assert_eq!(FROM_SECONDS_F64, Duration::SECOND);\n \n-    const MILLIS: u128 = ONE.as_millis();\n+    const MILLIS: u128 = Duration::SECOND.as_millis();\n     assert_eq!(MILLIS, 1_000);\n \n     const FROM_MILLIS: Duration = Duration::from_millis(1_000);\n-    assert_eq!(FROM_MILLIS, ONE);\n+    assert_eq!(FROM_MILLIS, Duration::SECOND);\n \n-    const MICROS: u128 = ONE.as_micros();\n+    const MICROS: u128 = Duration::SECOND.as_micros();\n     assert_eq!(MICROS, 1_000_000);\n \n     const FROM_MICROS: Duration = Duration::from_micros(1_000_000);\n-    assert_eq!(FROM_MICROS, ONE);\n+    assert_eq!(FROM_MICROS, Duration::SECOND);\n \n-    const NANOS: u128 = ONE.as_nanos();\n+    const NANOS: u128 = Duration::SECOND.as_nanos();\n     assert_eq!(NANOS, 1_000_000_000);\n \n     const FROM_NANOS: Duration = Duration::from_nanos(1_000_000_000);\n-    assert_eq!(FROM_NANOS, ONE);\n+    assert_eq!(FROM_NANOS, Duration::SECOND);\n \n     const MAX: Duration = Duration::new(u64::MAX, 999_999_999);\n \n-    const CHECKED_ADD: Option<Duration> = MAX.checked_add(ONE);\n+    const CHECKED_ADD: Option<Duration> = MAX.checked_add(Duration::SECOND);\n     assert_eq!(CHECKED_ADD, None);\n \n-    const CHECKED_SUB: Option<Duration> = ZERO.checked_sub(ONE);\n+    const CHECKED_SUB: Option<Duration> = Duration::ZERO.checked_sub(Duration::SECOND);\n     assert_eq!(CHECKED_SUB, None);\n \n-    const CHECKED_MUL: Option<Duration> = ONE.checked_mul(1);\n-    assert_eq!(CHECKED_MUL, Some(ONE));\n+    const CHECKED_MUL: Option<Duration> = Duration::SECOND.checked_mul(1);\n+    assert_eq!(CHECKED_MUL, Some(Duration::SECOND));\n \n-    const MUL_F32: Duration = ONE.mul_f32(1.0);\n-    assert_eq!(MUL_F32, ONE);\n+    const MUL_F32: Duration = Duration::SECOND.mul_f32(1.0);\n+    assert_eq!(MUL_F32, Duration::SECOND);\n \n-    const MUL_F64: Duration = ONE.mul_f64(1.0);\n-    assert_eq!(MUL_F64, ONE);\n+    const MUL_F64: Duration = Duration::SECOND.mul_f64(1.0);\n+    assert_eq!(MUL_F64, Duration::SECOND);\n \n-    const CHECKED_DIV: Option<Duration> = ONE.checked_div(1);\n-    assert_eq!(CHECKED_DIV, Some(ONE));\n+    const CHECKED_DIV: Option<Duration> = Duration::SECOND.checked_div(1);\n+    assert_eq!(CHECKED_DIV, Some(Duration::SECOND));\n \n-    const DIV_F32: Duration = ONE.div_f32(1.0);\n-    assert_eq!(DIV_F32, ONE);\n+    const DIV_F32: Duration = Duration::SECOND.div_f32(1.0);\n+    assert_eq!(DIV_F32, Duration::SECOND);\n \n-    const DIV_F64: Duration = ONE.div_f64(1.0);\n-    assert_eq!(DIV_F64, ONE);\n+    const DIV_F64: Duration = Duration::SECOND.div_f64(1.0);\n+    assert_eq!(DIV_F64, Duration::SECOND);\n \n-    const DIV_DURATION_F32: f32 = ONE.div_duration_f32(ONE);\n+    const DIV_DURATION_F32: f32 = Duration::SECOND.div_duration_f32(Duration::SECOND);\n     assert_eq!(DIV_DURATION_F32, 1.0);\n \n-    const DIV_DURATION_F64: f64 = ONE.div_duration_f64(ONE);\n+    const DIV_DURATION_F64: f64 = Duration::SECOND.div_duration_f64(Duration::SECOND);\n     assert_eq!(DIV_DURATION_F64, 1.0);\n \n-    const SATURATING_ADD: Duration = MAX.saturating_add(ONE);\n+    const SATURATING_ADD: Duration = MAX.saturating_add(Duration::SECOND);\n     assert_eq!(SATURATING_ADD, MAX);\n \n-    const SATURATING_SUB: Duration = ZERO.saturating_sub(ONE);\n-    assert_eq!(SATURATING_SUB, ZERO);\n+    const SATURATING_SUB: Duration = Duration::ZERO.saturating_sub(Duration::SECOND);\n+    assert_eq!(SATURATING_SUB, Duration::ZERO);\n \n     const SATURATING_MUL: Duration = MAX.saturating_mul(2);\n     assert_eq!(SATURATING_MUL, MAX);"}, {"sha": "fa2608e6fb6d3385a6a70cd501d15d16316087af", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62f0a78056a8b994f6bbe57c8349f1a0704713c3/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0a78056a8b994f6bbe57c8349f1a0704713c3/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=62f0a78056a8b994f6bbe57c8349f1a0704713c3", "patch": "@@ -257,6 +257,7 @@\n #![feature(doc_spotlight)]\n #![feature(dropck_eyepatch)]\n #![feature(duration_constants)]\n+#![feature(duration_zero)]\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]"}, {"sha": "20c813fdc70ff6f8a833fcb0ed766e5d51f95b07", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62f0a78056a8b994f6bbe57c8349f1a0704713c3/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0a78056a8b994f6bbe57c8349f1a0704713c3/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=62f0a78056a8b994f6bbe57c8349f1a0704713c3", "patch": "@@ -5,7 +5,7 @@ macro_rules! assert_almost_eq {\n         let (a, b) = ($a, $b);\n         if a != b {\n             let (a, b) = if a > b { (a, b) } else { (b, a) };\n-            assert!(a - Duration::new(0, 1000) <= b, \"{:?} is not almost equal to {:?}\", a, b);\n+            assert!(a - Duration::from_micros(1) <= b, \"{:?} is not almost equal to {:?}\", a, b);\n         }\n     }};\n }\n@@ -34,7 +34,7 @@ fn instant_math() {\n     assert_almost_eq!(b - dur, a);\n     assert_almost_eq!(a + dur, b);\n \n-    let second = Duration::new(1, 0);\n+    let second = Duration::SECOND;\n     assert_almost_eq!(a - second + second, a);\n     assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n \n@@ -65,32 +65,32 @@ fn instant_math_is_associative() {\n #[should_panic]\n fn instant_duration_since_panic() {\n     let a = Instant::now();\n-    (a - Duration::new(1, 0)).duration_since(a);\n+    (a - Duration::SECOND).duration_since(a);\n }\n \n #[test]\n fn instant_checked_duration_since_nopanic() {\n     let now = Instant::now();\n-    let earlier = now - Duration::new(1, 0);\n-    let later = now + Duration::new(1, 0);\n+    let earlier = now - Duration::SECOND;\n+    let later = now + Duration::SECOND;\n     assert_eq!(earlier.checked_duration_since(now), None);\n-    assert_eq!(later.checked_duration_since(now), Some(Duration::new(1, 0)));\n-    assert_eq!(now.checked_duration_since(now), Some(Duration::new(0, 0)));\n+    assert_eq!(later.checked_duration_since(now), Some(Duration::SECOND));\n+    assert_eq!(now.checked_duration_since(now), Some(Duration::ZERO));\n }\n \n #[test]\n fn instant_saturating_duration_since_nopanic() {\n     let a = Instant::now();\n-    let ret = (a - Duration::new(1, 0)).saturating_duration_since(a);\n-    assert_eq!(ret, Duration::new(0, 0));\n+    let ret = (a - Duration::SECOND).saturating_duration_since(a);\n+    assert_eq!(ret, Duration::ZERO);\n }\n \n #[test]\n fn system_time_math() {\n     let a = SystemTime::now();\n     let b = SystemTime::now();\n     match b.duration_since(a) {\n-        Ok(dur) if dur == Duration::new(0, 0) => {\n+        Ok(Duration::ZERO) => {\n             assert_almost_eq!(a, b);\n         }\n         Ok(dur) => {\n@@ -106,16 +106,16 @@ fn system_time_math() {\n         }\n     }\n \n-    let second = Duration::new(1, 0);\n+    let second = Duration::SECOND;\n     assert_almost_eq!(a.duration_since(a - second).unwrap(), second);\n     assert_almost_eq!(a.duration_since(a + second).unwrap_err().duration(), second);\n \n     assert_almost_eq!(a - second + second, a);\n     assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n \n-    let one_second_from_epoch = UNIX_EPOCH + Duration::new(1, 0);\n+    let one_second_from_epoch = UNIX_EPOCH + Duration::SECOND;\n     let one_second_from_epoch2 =\n-        UNIX_EPOCH + Duration::new(0, 500_000_000) + Duration::new(0, 500_000_000);\n+        UNIX_EPOCH + Duration::from_millis(500) + Duration::from_millis(500);\n     assert_eq!(one_second_from_epoch, one_second_from_epoch2);\n \n     // checked_add_duration will not panic on overflow\n@@ -141,12 +141,12 @@ fn system_time_elapsed() {\n #[test]\n fn since_epoch() {\n     let ts = SystemTime::now();\n-    let a = ts.duration_since(UNIX_EPOCH + Duration::new(1, 0)).unwrap();\n+    let a = ts.duration_since(UNIX_EPOCH + Duration::SECOND).unwrap();\n     let b = ts.duration_since(UNIX_EPOCH).unwrap();\n     assert!(b > a);\n-    assert_eq!(b - a, Duration::new(1, 0));\n+    assert_eq!(b - a, Duration::SECOND);\n \n-    let thirty_years = Duration::new(1, 0) * 60 * 60 * 24 * 365 * 30;\n+    let thirty_years = Duration::SECOND * 60 * 60 * 24 * 365 * 30;\n \n     // Right now for CI this test is run in an emulator, and apparently the\n     // aarch64 emulator's sense of time is that we're still living in the"}]}