{"sha": "e4309c2db6aedeae8705da87735213e063c3df51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MzA5YzJkYjZhZWRlYWU4NzA1ZGE4NzczNTIxM2UwNjNjM2RmNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-15T18:26:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-15T18:26:18Z"}, "message": "Auto merge of #29209 - arielb1:exponential-evaluation, r=nmatsakis\n\nThis fixes an exponential worst-case and also provides an additional 1% perf improvement.\n\nr? @nikomatsakis", "tree": {"sha": "96c8483c5958400964a3d6575530f3585009665c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96c8483c5958400964a3d6575530f3585009665c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4309c2db6aedeae8705da87735213e063c3df51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4309c2db6aedeae8705da87735213e063c3df51", "html_url": "https://github.com/rust-lang/rust/commit/e4309c2db6aedeae8705da87735213e063c3df51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4309c2db6aedeae8705da87735213e063c3df51/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68f812230912bc1f60f26b9150c6b2dc73ca217e", "url": "https://api.github.com/repos/rust-lang/rust/commits/68f812230912bc1f60f26b9150c6b2dc73ca217e", "html_url": "https://github.com/rust-lang/rust/commit/68f812230912bc1f60f26b9150c6b2dc73ca217e"}, {"sha": "5982594c7e6fd1ddd7084c9d6d125426a180c964", "url": "https://api.github.com/repos/rust-lang/rust/commits/5982594c7e6fd1ddd7084c9d6d125426a180c964", "html_url": "https://github.com/rust-lang/rust/commit/5982594c7e6fd1ddd7084c9d6d125426a180c964"}], "stats": {"total": 829, "additions": 530, "deletions": 299}, "files": [{"sha": "691bac0cef865f82c6cde00f92074961e1018226", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -44,6 +44,7 @@ pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::is_vtable_safe_method;\n+pub use self::select::EvaluationCache;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n@@ -339,32 +340,53 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n            ty,\n            bound);\n \n-    let mut fulfill_cx = FulfillmentContext::new(false);\n-\n-    // We can use a dummy node-id here because we won't pay any mind\n-    // to region obligations that arise (there shouldn't really be any\n-    // anyhow).\n     let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n-\n-    fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n-\n-    // Note: we only assume something is `Copy` if we can\n-    // *definitively* show that it implements `Copy`. Otherwise,\n-    // assume it is move; linear is always ok.\n-    match fulfill_cx.select_all_or_error(infcx) {\n-        Ok(()) => {\n-            debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n-                   ty,\n-                   bound);\n-            true\n-        }\n-        Err(e) => {\n-            debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} errors={:?}\",\n-                   ty,\n-                   bound,\n-                   e);\n-            false\n+    let obligation =\n+        util::predicate_for_builtin_bound(infcx.tcx, cause, bound, 0, ty);\n+    let obligation = match obligation {\n+        Ok(o) => o,\n+        Err(..) => return false\n+    };\n+    let result = SelectionContext::new(infcx)\n+        .evaluate_obligation_conservatively(&obligation);\n+    debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} => {:?}\",\n+           ty, bound, result);\n+\n+    if result && (ty.has_infer_types() || ty.has_closure_types()) {\n+        // Because of inference \"guessing\", selection can sometimes claim\n+        // to succeed while the success requires a guess. To ensure\n+        // this function's result remains infallible, we must confirm\n+        // that guess. While imperfect, I believe this is sound.\n+\n+        let mut fulfill_cx = FulfillmentContext::new(false);\n+\n+        // We can use a dummy node-id here because we won't pay any mind\n+        // to region obligations that arise (there shouldn't really be any\n+        // anyhow).\n+        let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n+\n+        fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n+\n+        // Note: we only assume something is `Copy` if we can\n+        // *definitively* show that it implements `Copy`. Otherwise,\n+        // assume it is move; linear is always ok.\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Ok(()) => {\n+                debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n+                       ty,\n+                       bound);\n+                true\n+            }\n+            Err(e) => {\n+                debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} errors={:?}\",\n+                       ty,\n+                       bound,\n+                       e);\n+                false\n+            }\n         }\n+    } else {\n+        result\n     }\n }\n "}, {"sha": "ba69632fde1b1ad63065350e3951be7ee526b2c4", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 200, "deletions": 214, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! See `README.md` for high-level documentation\n-#![allow(dead_code)] // FIXME -- just temporarily\n \n pub use self::MethodMatchResult::*;\n pub use self::MethodMatchedData::*;\n@@ -190,7 +189,6 @@ pub enum MethodMatchedData {\n /// parameter environment.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n-    PhantomFnCandidate,\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(DefId),\n@@ -236,11 +234,24 @@ enum BuiltinBoundConditions<'tcx> {\n     AmbiguousBuiltin\n }\n \n-#[derive(Debug)]\n-enum EvaluationResult<'tcx> {\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+/// The result of trait evaluation. The order is important\n+/// here as the evaluation of a list is the maximum of the\n+/// evaluations.\n+enum EvaluationResult {\n+    /// Evaluation successful\n     EvaluatedToOk,\n+    /// Evaluation failed because of recursion - treated as ambiguous\n+    EvaluatedToUnknown,\n+    /// Evaluation is known to be ambiguous\n     EvaluatedToAmbig,\n-    EvaluatedToErr(SelectionError<'tcx>),\n+    /// Evaluation failed\n+    EvaluatedToErr,\n+}\n+\n+#[derive(Clone)]\n+pub struct EvaluationCache<'tcx> {\n+    hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n@@ -381,6 +392,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n+\n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n     pub fn evaluate_obligation(&mut self,\n                                obligation: &PredicateObligation<'tcx>)\n@@ -389,45 +401,50 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_obligation({:?})\",\n                obligation);\n \n-        self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-            .may_apply()\n+        self.infcx.probe(|_| {\n+            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+                .may_apply()\n+        })\n     }\n \n-    fn evaluate_builtin_bound_recursively<'o>(&mut self,\n-                                              bound: ty::BuiltinBound,\n-                                              previous_stack: &TraitObligationStack<'o, 'tcx>,\n-                                              ty: Ty<'tcx>)\n-                                              -> EvaluationResult<'tcx>\n+    /// Evaluates whether the obligation `obligation` can be satisfied,\n+    /// and returns `false` if not certain. However, this is not entirely\n+    /// accurate if inference variables are involved.\n+    pub fn evaluate_obligation_conservatively(&mut self,\n+                                              obligation: &PredicateObligation<'tcx>)\n+                               -> bool\n     {\n-        let obligation =\n-            util::predicate_for_builtin_bound(\n-                self.tcx(),\n-                previous_stack.obligation.cause.clone(),\n-                bound,\n-                previous_stack.obligation.recursion_depth + 1,\n-                ty);\n-\n-        match obligation {\n-            Ok(obligation) => {\n-                self.evaluate_predicate_recursively(previous_stack.list(), &obligation)\n-            }\n-            Err(ErrorReported) => {\n-                EvaluatedToOk\n-            }\n-        }\n+        debug!(\"evaluate_obligation_conservatively({:?})\",\n+               obligation);\n+\n+        self.infcx.probe(|_| {\n+            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+                == EvaluatedToOk\n+        })\n     }\n \n+    /// Evaluates the predicates in `predicates` recursively. Note that\n+    /// this applies projections in the predicates, and therefore\n+    /// is run within an inference probe.\n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n                                                 stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n-                                                -> EvaluationResult<'tcx>\n+                                                -> EvaluationResult\n         where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n-            match self.evaluate_predicate_recursively(stack, obligation) {\n-                EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n+            let eval = self.evaluate_predicate_recursively(stack, obligation);\n+            debug!(\"evaluate_predicate_recursively({:?}) = {:?}\",\n+                   obligation, eval);\n+            match eval {\n+                EvaluatedToErr => { return EvaluatedToErr; }\n                 EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n+                EvaluatedToUnknown => {\n+                    if result < EvaluatedToUnknown {\n+                        result = EvaluatedToUnknown;\n+                    }\n+                }\n                 EvaluatedToOk => { }\n             }\n         }\n@@ -437,7 +454,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn evaluate_predicate_recursively<'o>(&mut self,\n                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n-                                           -> EvaluationResult<'tcx>\n+                                           -> EvaluationResult\n     {\n         debug!(\"evaluate_predicate_recursively({:?})\",\n                obligation);\n@@ -459,12 +476,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::Equate(ref p) => {\n-                let result = self.infcx.probe(|_| {\n-                    self.infcx.equality_predicate(obligation.cause.span, p)\n-                });\n-                match result {\n+                // does this code ever run?\n+                match self.infcx.equality_predicate(obligation.cause.span, p) {\n                     Ok(()) => EvaluatedToOk,\n-                    Err(_) => EvaluatedToErr(Unimplemented),\n+                    Err(_) => EvaluatedToErr\n                 }\n             }\n \n@@ -489,49 +504,58 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if object_safety::is_object_safe(self.tcx(), trait_def_id) {\n                     EvaluatedToOk\n                 } else {\n-                    EvaluatedToErr(Unimplemented)\n+                    EvaluatedToErr\n                 }\n             }\n \n             ty::Predicate::Projection(ref data) => {\n-                self.infcx.probe(|_| {\n-                    let project_obligation = obligation.with(data.clone());\n-                    match project::poly_project_and_unify_type(self, &project_obligation) {\n-                        Ok(Some(subobligations)) => {\n-                            self.evaluate_predicates_recursively(previous_stack,\n-                                                                 subobligations.iter())\n-                        }\n-                        Ok(None) => {\n-                            EvaluatedToAmbig\n-                        }\n-                        Err(_) => {\n-                            EvaluatedToErr(Unimplemented)\n-                        }\n+                let project_obligation = obligation.with(data.clone());\n+                match project::poly_project_and_unify_type(self, &project_obligation) {\n+                    Ok(Some(subobligations)) => {\n+                        self.evaluate_predicates_recursively(previous_stack,\n+                                                             subobligations.iter())\n                     }\n-                })\n+                    Ok(None) => {\n+                        EvaluatedToAmbig\n+                    }\n+                    Err(_) => {\n+                        EvaluatedToErr\n+                    }\n+                }\n             }\n         }\n     }\n \n     fn evaluate_obligation_recursively<'o>(&mut self,\n                                            previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                            obligation: &TraitObligation<'tcx>)\n-                                           -> EvaluationResult<'tcx>\n+                                           -> EvaluationResult\n     {\n         debug!(\"evaluate_obligation_recursively({:?})\",\n                obligation);\n \n         let stack = self.push_stack(previous_stack, obligation);\n+        let fresh_trait_ref = stack.fresh_trait_ref;\n+        if let Some(result) = self.check_evaluation_cache(fresh_trait_ref) {\n+            debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n+                   fresh_trait_ref,\n+                   result);\n+            return result;\n+        }\n \n         let result = self.evaluate_stack(&stack);\n \n-        debug!(\"result: {:?}\", result);\n+        debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n+               fresh_trait_ref,\n+               result);\n+        self.insert_evaluation_cache(fresh_trait_ref, result);\n+\n         result\n     }\n \n     fn evaluate_stack<'o>(&mut self,\n                           stack: &TraitObligationStack<'o, 'tcx>)\n-                          -> EvaluationResult<'tcx>\n+                          -> EvaluationResult\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -559,16 +583,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // precise still.\n         let input_types = stack.fresh_trait_ref.0.input_types();\n         let unbound_input_types = input_types.iter().any(|ty| ty.is_fresh());\n-        if\n-            unbound_input_types &&\n-             (self.intercrate ||\n+        if unbound_input_types && self.intercrate {\n+            debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n+                   stack.fresh_trait_ref);\n+            return EvaluatedToAmbig;\n+        }\n+        if unbound_input_types &&\n               stack.iter().skip(1).any(\n                   |prev| self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n-                                                     &prev.fresh_trait_ref)))\n+                                                     &prev.fresh_trait_ref))\n         {\n-            debug!(\"evaluate_stack({:?}) --> unbound argument, recursion -->  ambiguous\",\n+            debug!(\"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n                    stack.fresh_trait_ref);\n-            return EvaluatedToAmbig;\n+            return EvaluatedToUnknown;\n         }\n \n         // If there is any previous entry on the stack that precisely\n@@ -601,40 +628,74 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match self.candidate_from_obligation(stack) {\n-            Ok(Some(c)) => self.winnow_candidate(stack, &c),\n+            Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n             Ok(None) => EvaluatedToAmbig,\n-            Err(e) => EvaluatedToErr(e),\n+            Err(..) => EvaluatedToErr\n         }\n     }\n \n-    /// Evaluates whether the impl with id `impl_def_id` could be applied to the self type\n-    /// `obligation_self_ty`. This can be used either for trait or inherent impls.\n-    pub fn evaluate_impl(&mut self,\n-                         impl_def_id: DefId,\n-                         obligation: &TraitObligation<'tcx>)\n-                         -> bool\n+    /// Further evaluate `candidate` to decide whether all type parameters match and whether nested\n+    /// obligations are met. Returns true if `candidate` remains viable after this further\n+    /// scrutiny.\n+    fn evaluate_candidate<'o>(&mut self,\n+                              stack: &TraitObligationStack<'o, 'tcx>,\n+                              candidate: &SelectionCandidate<'tcx>)\n+                              -> EvaluationResult\n     {\n-        debug!(\"evaluate_impl(impl_def_id={:?}, obligation={:?})\",\n-               impl_def_id,\n-               obligation);\n-\n-        self.infcx.probe(|snapshot| {\n-            match self.match_impl(impl_def_id, obligation, snapshot) {\n-                Ok((substs, skol_map)) => {\n-                    let vtable_impl = self.vtable_impl(impl_def_id,\n-                                                       substs,\n-                                                       obligation.cause.clone(),\n-                                                       obligation.recursion_depth + 1,\n-                                                       skol_map,\n-                                                       snapshot);\n-                    self.winnow_selection(TraitObligationStackList::empty(),\n-                                          VtableImpl(vtable_impl)).may_apply()\n-                }\n-                Err(()) => {\n-                    false\n+        debug!(\"evaluate_candidate: depth={} candidate={:?}\",\n+               stack.obligation.recursion_depth, candidate);\n+        let result = self.infcx.probe(|_| {\n+            let candidate = (*candidate).clone();\n+            match self.confirm_candidate(stack.obligation, candidate) {\n+                Ok(selection) => {\n+                    self.evaluate_predicates_recursively(\n+                        stack.list(),\n+                        selection.nested_obligations().iter())\n                 }\n+                Err(..) => EvaluatedToErr\n             }\n-        })\n+        });\n+        debug!(\"evaluate_candidate: depth={} result={:?}\",\n+               stack.obligation.recursion_depth, result);\n+        result\n+    }\n+\n+    fn pick_evaluation_cache(&self) -> &EvaluationCache<'tcx> {\n+        // see comment in `pick_candidate_cache`\n+        if self.intercrate ||\n+            !self.param_env().caller_bounds.is_empty()\n+        {\n+            &self.param_env().evaluation_cache\n+        } else\n+        {\n+            &self.tcx().evaluation_cache\n+        }\n+    }\n+\n+    fn check_evaluation_cache(&self, trait_ref: ty::PolyTraitRef<'tcx>)\n+                              -> Option<EvaluationResult>\n+    {\n+        let cache = self.pick_evaluation_cache();\n+        cache.hashmap.borrow().get(&trait_ref).cloned()\n+    }\n+\n+    fn insert_evaluation_cache(&mut self,\n+                               trait_ref: ty::PolyTraitRef<'tcx>,\n+                               result: EvaluationResult)\n+    {\n+        // Avoid caching results that depend on more than just the trait-ref:\n+        // The stack can create EvaluatedToUnknown, and closure signatures\n+        // being yet uninferred can create \"spurious\" EvaluatedToAmbig\n+        // and EvaluatedToOk.\n+        if result == EvaluatedToUnknown ||\n+            ((result == EvaluatedToAmbig || result == EvaluatedToOk)\n+             && trait_ref.has_closure_types())\n+        {\n+            return;\n+        }\n+\n+        let cache = self.pick_evaluation_cache();\n+        cache.hashmap.borrow_mut().insert(trait_ref, result);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -669,7 +730,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match self.check_candidate_cache(&cache_fresh_trait_pred) {\n             Some(c) => {\n-                debug!(\"CACHE HIT: cache_fresh_trait_pred={:?}, candidate={:?}\",\n+                debug!(\"CACHE HIT: SELECT({:?})={:?}\",\n                        cache_fresh_trait_pred,\n                        c);\n                 return c;\n@@ -681,7 +742,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n \n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n-            debug!(\"CACHE MISS: cache_fresh_trait_pred={:?}, candidate={:?}\",\n+            debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n                    cache_fresh_trait_pred, candidate);\n             self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n         }\n@@ -740,7 +801,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Instead, we select the right impl now but report `Bar does\n         // not implement Clone`.\n         if candidates.len() > 1 {\n-            candidates.retain(|c| self.winnow_candidate(stack, c).may_apply())\n+            candidates.retain(|c| self.evaluate_candidate(stack, c).may_apply())\n         }\n \n         // If there are STILL multiple candidate, we can further reduce\n@@ -1138,16 +1199,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn evaluate_where_clause<'o>(&mut self,\n                                  stack: &TraitObligationStack<'o, 'tcx>,\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                                 -> EvaluationResult<'tcx>\n+                                 -> EvaluationResult\n     {\n         self.infcx().probe(move |_| {\n             match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n                     self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n-                Err(()) => {\n-                    EvaluatedToErr(Unimplemented)\n-                }\n+                Err(()) => EvaluatedToErr\n             }\n         })\n     }\n@@ -1486,37 +1545,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // attempt to evaluate recursive bounds to see if they are\n     // satisfied.\n \n-    /// Further evaluate `candidate` to decide whether all type parameters match and whether nested\n-    /// obligations are met. Returns true if `candidate` remains viable after this further\n-    /// scrutiny.\n-    fn winnow_candidate<'o>(&mut self,\n-                            stack: &TraitObligationStack<'o, 'tcx>,\n-                            candidate: &SelectionCandidate<'tcx>)\n-                            -> EvaluationResult<'tcx>\n-    {\n-        debug!(\"winnow_candidate: candidate={:?}\", candidate);\n-        let result = self.infcx.probe(|_| {\n-            let candidate = (*candidate).clone();\n-            match self.confirm_candidate(stack.obligation, candidate) {\n-                Ok(selection) => self.winnow_selection(stack.list(),\n-                                                       selection),\n-                Err(error) => EvaluatedToErr(error),\n-            }\n-        });\n-        debug!(\"winnow_candidate depth={} result={:?}\",\n-               stack.obligation.recursion_depth, result);\n-        result\n-    }\n-\n-    fn winnow_selection<'o>(&mut self,\n-                            stack: TraitObligationStackList<'o,'tcx>,\n-                            selection: Selection<'tcx>)\n-                            -> EvaluationResult<'tcx>\n-    {\n-        self.evaluate_predicates_recursively(stack,\n-                                             selection.nested_obligations().iter())\n-    }\n-\n     /// Returns true if `candidate_i` should be dropped in favor of\n     /// `candidate_j`.  Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n@@ -1542,9 +1570,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         \"default implementations shouldn't be recorded \\\n                          when there are other valid candidates\");\n                 }\n-                &PhantomFnCandidate => {\n-                    self.tcx().sess.bug(\"PhantomFn didn't short-circuit selection\");\n-                }\n                 &ImplCandidate(..) |\n                 &ClosureCandidate(..) |\n                 &FnPointerCandidate(..) |\n@@ -1974,7 +1999,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     try!(self.confirm_builtin_candidate(obligation, builtin_bound))))\n             }\n \n-            PhantomFnCandidate |\n             ErrorCandidate => {\n                 Ok(VtableBuiltin(VtableBuiltinData { nested: vec![] }))\n             }\n@@ -2260,6 +2284,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                impl_def_id,\n                impl_obligations);\n \n+        // Because of RFC447, the impl-trait-ref and obligations\n+        // are sufficient to determine the impl substs, without\n+        // relying on projections in the impl-trait-ref.\n+        //\n+        // e.g. `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n         impl_obligations.append(&mut substs.obligations);\n \n         VtableImplData { impl_def_id: impl_def_id,\n@@ -2744,74 +2773,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    /// Determines whether the self type declared against\n-    /// `impl_def_id` matches `obligation_self_ty`. If successful,\n-    /// returns the substitutions used to make them match. See\n-    /// `match_impl()`. For example, if `impl_def_id` is declared\n-    /// as:\n-    ///\n-    ///    impl<T:Copy> Foo for Box<T> { ... }\n-    ///\n-    /// and `obligation_self_ty` is `int`, we'd get back an `Err(_)`\n-    /// result. But if `obligation_self_ty` were `Box<int>`, we'd get\n-    /// back `Ok(T=int)`.\n-    fn match_inherent_impl(&mut self,\n-                           impl_def_id: DefId,\n-                           obligation_cause: &ObligationCause,\n-                           obligation_self_ty: Ty<'tcx>)\n-                           -> Result<Substs<'tcx>,()>\n-    {\n-        // Create fresh type variables for each type parameter declared\n-        // on the impl etc.\n-        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n-                                                         obligation_cause.span,\n-                                                         impl_def_id);\n-\n-        // Find the self type for the impl.\n-        let impl_self_ty = self.tcx().lookup_item_type(impl_def_id).ty;\n-        let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n-\n-        debug!(\"match_impl_self_types(obligation_self_ty={:?}, impl_self_ty={:?})\",\n-               obligation_self_ty,\n-               impl_self_ty);\n-\n-        match self.match_self_types(obligation_cause,\n-                                    impl_self_ty,\n-                                    obligation_self_ty) {\n-            Ok(()) => {\n-                debug!(\"Matched impl_substs={:?}\", impl_substs);\n-                Ok(impl_substs)\n-            }\n-            Err(()) => {\n-                debug!(\"NoMatch\");\n-                Err(())\n-            }\n-        }\n-    }\n-\n-    fn match_self_types(&mut self,\n-                        cause: &ObligationCause,\n-\n-                        // The self type provided by the impl/caller-obligation:\n-                        provided_self_ty: Ty<'tcx>,\n-\n-                        // The self type the obligation is for:\n-                        required_self_ty: Ty<'tcx>)\n-                        -> Result<(),()>\n-    {\n-        // FIXME(#5781) -- equating the types is stronger than\n-        // necessary. Should consider variance of trait w/r/t Self.\n-\n-        let origin = infer::RelateSelfType(cause.span);\n-        match self.infcx.eq_types(false,\n-                                  origin,\n-                                  provided_self_ty,\n-                                  required_self_ty) {\n-            Ok(()) => Ok(()),\n-            Err(_) => Err(()),\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n@@ -2892,17 +2853,37 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  -> Vec<PredicateObligation<'tcx>>\n     {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n+        let tcx = self.tcx();\n \n-        let predicates = self.tcx().lookup_predicates(def_id);\n-        let predicates = predicates.instantiate(self.tcx(), substs);\n-        let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n-        let mut predicates = self.infcx().plug_leaks(skol_map, snapshot, &predicates);\n-        let mut obligations =\n-            util::predicates_for_generics(cause,\n-                                          recursion_depth,\n-                                          &predicates.value);\n-        obligations.append(&mut predicates.obligations);\n-        obligations\n+        // To allow for one-pass evaluation of the nested obligation,\n+        // each predicate must be preceded by the obligations required\n+        // to normalize it.\n+        // for example, if we have:\n+        //    impl<U: Iterator, V: Iterator<Item=U>> Foo for V where U::Item: Copy\n+        // the impl will have the following predicates:\n+        //    <V as Iterator>::Item = U,\n+        //    U: Iterator, U: Sized,\n+        //    V: Iterator, V: Sized,\n+        //    <U as Iterator>::Item: Copy\n+        // When we substitute, say, `V => IntoIter<u32>, U => $0`, the last\n+        // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n+        // `$1: Copy`, so we must ensure the obligations are emitted in\n+        // that order.\n+        let predicates = tcx\n+            .lookup_predicates(def_id)\n+            .predicates.iter()\n+            .flat_map(|predicate| {\n+                let predicate =\n+                    normalize_with_depth(self, cause.clone(), recursion_depth,\n+                                         &predicate.subst(tcx, substs));\n+                predicate.obligations.into_iter().chain(\n+                    Some(Obligation {\n+                        cause: cause.clone(),\n+                        recursion_depth: recursion_depth,\n+                        predicate: predicate.value\n+                    }))\n+            }).collect();\n+        self.infcx().plug_leaks(skol_map, snapshot, &predicates)\n     }\n \n     #[allow(unused_comparisons)]\n@@ -2956,6 +2937,14 @@ impl<'tcx> SelectionCache<'tcx> {\n     }\n }\n \n+impl<'tcx> EvaluationCache<'tcx> {\n+    pub fn new() -> EvaluationCache<'tcx> {\n+        EvaluationCache {\n+            hashmap: RefCell::new(FnvHashMap())\n+        }\n+    }\n+}\n+\n impl<'o,'tcx> TraitObligationStack<'o,'tcx> {\n     fn list(&'o self) -> TraitObligationStackList<'o,'tcx> {\n         TraitObligationStackList::with(self)\n@@ -3001,17 +2990,14 @@ impl<'o,'tcx> fmt::Debug for TraitObligationStack<'o,'tcx> {\n     }\n }\n \n-impl<'tcx> EvaluationResult<'tcx> {\n+impl EvaluationResult {\n     fn may_apply(&self) -> bool {\n         match *self {\n             EvaluatedToOk |\n             EvaluatedToAmbig |\n-            EvaluatedToErr(OutputTypeParameterMismatch(..)) |\n-            EvaluatedToErr(TraitNotObjectSafe(_)) =>\n-                true,\n+            EvaluatedToUnknown => true,\n \n-            EvaluatedToErr(Unimplemented) =>\n-                false,\n+            EvaluatedToErr => false\n         }\n     }\n }"}, {"sha": "e02a120a5c60fa04cb07bc73d5fa9c463ee8293a", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -332,6 +332,11 @@ pub struct ctxt<'tcx> {\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n \n+    /// Caches the results of trait evaluation. This cache is used\n+    /// for things that do not have to do with the parameters in scope.\n+    /// Merge this with `selection_cache`?\n+    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n+\n     /// A set of predicates that have been fulfilled *somewhere*.\n     /// This is used to avoid duplicate work. Predicates are only\n     /// added to this set when they mention only \"global\" names\n@@ -512,6 +517,7 @@ impl<'tcx> ctxt<'tcx> {\n             transmute_restrictions: RefCell::new(Vec::new()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n             repr_hint_cache: RefCell::new(DefIdMap()),\n             const_qualif_map: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),"}, {"sha": "0a9fa1d6ce394c75e26d90ac38855eaf3c05c406", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -1091,6 +1091,9 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     /// for things that have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n \n+    /// Caches the results of trait evaluation.\n+    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n+\n     /// Scope that is attached to free regions for this scope. This\n     /// is usually the id of the fn body, but for more abstract scopes\n     /// like structs we often use the node-id of the struct.\n@@ -1112,6 +1115,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n             selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n             free_id: self.free_id,\n         }\n     }\n@@ -2584,6 +2588,7 @@ impl<'tcx> ctxt<'tcx> {\n                                    caller_bounds: Vec::new(),\n                                    implicit_region_bound: ty::ReEmpty,\n                                    selection_cache: traits::SelectionCache::new(),\n+                                   evaluation_cache: traits::EvaluationCache::new(),\n \n                                    // for an empty parameter\n                                    // environment, there ARE no free\n@@ -2673,6 +2678,7 @@ impl<'tcx> ctxt<'tcx> {\n             implicit_region_bound: ty::ReScope(free_id_outlive),\n             caller_bounds: predicates,\n             selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n             free_id: free_id,\n         };\n "}, {"sha": "41303b46dfd09edf37c27c7e0ce95babdbc7a728", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -822,6 +822,7 @@ impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where '\n             implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n             caller_bounds: self.caller_bounds.fold_with(folder),\n             selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n             free_id: self.free_id,\n         }\n     }"}, {"sha": "185623a4402531f794ede5b45703c65d17d3a25b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -775,31 +775,33 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n-            let ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n+            let mut ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.register_item_type(ccx.tcx.map.local_def_id(it.id),\n+            tcx.register_item_type(def_id,\n                                    TypeScheme { generics: ty_generics.clone(),\n                                                 ty: selfty });\n-            tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                               ty_predicates.clone());\n             if let &Some(ref ast_trait_ref) = opt_trait_ref {\n                 tcx.impl_trait_refs.borrow_mut().insert(\n-                    ccx.tcx.map.local_def_id(it.id),\n+                    def_id,\n                     Some(astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                              &ExplicitRscope,\n                                                              ast_trait_ref,\n                                                              Some(selfty)))\n                         );\n             } else {\n-                tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id), None);\n+                tcx.impl_trait_refs.borrow_mut().insert(def_id, None);\n             }\n \n+            enforce_impl_params_are_constrained(tcx, generics, &mut ty_predicates, def_id);\n+            tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n+\n \n             // If there is a trait reference, treat the methods as always public.\n             // This is to work around some incorrect behavior in privacy checking:\n@@ -844,7 +846,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                generics: ty_generics.clone(),\n                                                ty: ty,\n                                            });\n-                    convert_associated_const(ccx, ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n+                    convert_associated_const(ccx, ImplContainer(def_id),\n                                              impl_item.name, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n                                              ty, true /* has_value */);\n@@ -861,7 +863,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n-                    convert_associated_type(ccx, ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n+                    convert_associated_type(ccx, ImplContainer(def_id),\n                                             impl_item.name, impl_item.id, impl_item.vis,\n                                             Some(typ));\n                 }\n@@ -880,7 +882,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             });\n             convert_methods(ccx,\n-                            ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n+                            ImplContainer(def_id),\n                             methods,\n                             selfty,\n                             &ty_generics,\n@@ -898,10 +900,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             }\n \n-            enforce_impl_params_are_constrained(tcx,\n-                                                generics,\n-                                                ccx.tcx.map.local_def_id(it.id),\n-                                                impl_items);\n+            enforce_impl_lifetimes_are_constrained(tcx, generics, def_id, impl_items);\n         },\n         hir::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n@@ -2377,13 +2376,15 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n /// Checks that all the type parameters on an impl\n fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                              ast_generics: &hir::Generics,\n-                                             impl_def_id: DefId,\n-                                             impl_items: &[P<hir::ImplItem>])\n+                                             impl_predicates: &mut ty::GenericPredicates<'tcx>,\n+                                             impl_def_id: DefId)\n {\n     let impl_scheme = tcx.lookup_item_type(impl_def_id);\n-    let impl_predicates = tcx.lookup_predicates(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n+    assert!(impl_predicates.predicates.is_empty_in(FnSpace));\n+    assert!(impl_predicates.predicates.is_empty_in(SelfSpace));\n+\n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n@@ -2393,10 +2394,10 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n         input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref));\n     }\n \n-    ctp::identify_constrained_type_params(tcx,\n-                                          impl_predicates.predicates.as_slice(),\n-                                          impl_trait_ref,\n-                                          &mut input_parameters);\n+    ctp::setup_constraining_predicates(tcx,\n+                                       impl_predicates.predicates.get_mut_slice(TypeSpace),\n+                                       impl_trait_ref,\n+                                       &mut input_parameters);\n \n     for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n         let param_ty = ty::ParamTy { space: TypeSpace,\n@@ -2406,8 +2407,25 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.to_string());\n         }\n     }\n+}\n \n+fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                ast_generics: &hir::Generics,\n+                                                impl_def_id: DefId,\n+                                                impl_items: &[P<hir::ImplItem>])\n+{\n     // Every lifetime used in an associated type must be constrained.\n+    let impl_scheme = tcx.lookup_item_type(impl_def_id);\n+    let impl_predicates = tcx.lookup_predicates(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+\n+    let mut input_parameters: HashSet<_> =\n+        ctp::parameters_for_type(impl_scheme.ty).into_iter().collect();\n+    if let Some(ref trait_ref) = impl_trait_ref {\n+        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref));\n+    }\n+    ctp::identify_constrained_type_params(tcx,\n+        &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n     let lifetimes_in_associated_types: HashSet<_> =\n         impl_items.iter()"}, {"sha": "39d5872b3dc7a2fcf7dba29cf2f9c3f9fc626615", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 83, "deletions": 31, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -84,40 +84,92 @@ pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut HashSet<Parameter>)\n {\n-    loop {\n-        let num_inputs = input_parameters.len();\n-\n-        let poly_projection_predicates = // : iterator over PolyProjectionPredicate\n-            predicates.iter()\n-                      .filter_map(|predicate| {\n-                          match *predicate {\n-                              ty::Predicate::Projection(ref data) => Some(data.clone()),\n-                              _ => None,\n-                          }\n-                      });\n-\n-        for poly_projection in poly_projection_predicates {\n-            // Note that we can skip binder here because the impl\n-            // trait ref never contains any late-bound regions.\n-            let projection = poly_projection.skip_binder();\n-\n-            // Special case: watch out for some kind of sneaky attempt\n-            // to project out an associated type defined by this very\n-            // trait.\n-            let unbound_trait_ref = &projection.projection_ty.trait_ref;\n-            if Some(unbound_trait_ref.clone()) == impl_trait_ref {\n-                continue;\n-            }\n+    let mut predicates = predicates.to_owned();\n+    setup_constraining_predicates(_tcx, &mut predicates, impl_trait_ref, input_parameters);\n+}\n+\n \n-            let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref);\n-            let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n-            if relies_only_on_inputs {\n+/// Order the predicates in `predicates` such that each parameter is\n+/// constrained before it is used, if that is possible, and add the\n+/// paramaters so constrained to `input_parameters`. For example,\n+/// imagine the following impl:\n+///\n+///     impl<T: Debug, U: Iterator<Item=T>> Trait for U\n+///\n+/// The impl's predicates are collected from left to right. Ignoring\n+/// the implicit `Sized` bounds, these are\n+///   * T: Debug\n+///   * U: Iterator\n+///   * <U as Iterator>::Item = T -- a desugared ProjectionPredicate\n+///\n+/// When we, for example, try to go over the trait-reference\n+/// `IntoIter<u32> as Trait`, we substitute the impl parameters with fresh\n+/// variables and match them with the impl trait-ref, so we know that\n+/// `$U = IntoIter<u32>`.\n+///\n+/// However, in order to process the `$T: Debug` predicate, we must first\n+/// know the value of `$T` - which is only given by processing the\n+/// projection. As we occasionally want to process predicates in a single\n+/// pass, we want the projection to come first. In fact, as projections\n+/// can (acyclically) depend on one another - see RFC447 for details - we\n+/// need to topologically sort them.\n+pub fn setup_constraining_predicates<'tcx>(_tcx: &ty::ctxt<'tcx>,\n+                                           predicates: &mut [ty::Predicate<'tcx>],\n+                                           impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+                                           input_parameters: &mut HashSet<Parameter>)\n+{\n+    // The canonical way of doing the needed topological sort\n+    // would be a DFS, but getting the graph and its ownership\n+    // right is annoying, so I am using an in-place fixed-point iteration,\n+    // which is `O(nt)` where `t` is the depth of type-parameter constraints,\n+    // remembering that `t` should be less than 7 in practice.\n+    //\n+    // Basically, I iterate over all projections and swap every\n+    // \"ready\" projection to the start of the list, such that\n+    // all of the projections before `i` are topologically sorted\n+    // and constrain all the parameters in `input_parameters`.\n+    //\n+    // In the example, `input_parameters` starts by containing `U` - which\n+    // is constrained by the trait-ref - and so on the first pass we\n+    // observe that `<U as Iterator>::Item = T` is a \"ready\" projection that\n+    // constrains `T` and swap it to front. As it is the sole projection,\n+    // no more swaps can take place afterwards, with the result being\n+    //   * <U as Iterator>::Item = T\n+    //   * T: Debug\n+    //   * U: Iterator\n+    let mut i = 0;\n+    let mut changed = true;\n+    while changed {\n+        changed = false;\n+\n+        for j in i..predicates.len() {\n+\n+            if let ty::Predicate::Projection(ref poly_projection) = predicates[j] {\n+                // Note that we can skip binder here because the impl\n+                // trait ref never contains any late-bound regions.\n+                let projection = poly_projection.skip_binder();\n+\n+                // Special case: watch out for some kind of sneaky attempt\n+                // to project out an associated type defined by this very\n+                // trait.\n+                let unbound_trait_ref = &projection.projection_ty.trait_ref;\n+                if Some(unbound_trait_ref.clone()) == impl_trait_ref {\n+                    continue;\n+                }\n+\n+                let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref);\n+                let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n+                if !relies_only_on_inputs {\n+                    continue;\n+                }\n                 input_parameters.extend(parameters_for_type(projection.ty));\n+            } else {\n+                continue;\n             }\n-        }\n-\n-        if input_parameters.len() == num_inputs {\n-            break;\n+            // fancy control flow to bypass borrow checker\n+            predicates.swap(i, j);\n+            i += 1;\n+            changed = true;\n         }\n     }\n }"}, {"sha": "d14b0fa9e6602a397e3a715961b44370909aa0df", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -37,6 +37,7 @@ fn main()\n     let f: f32 = 1.2;\n     let v = 0 as *const u8;\n     let fat_v : *const [u8] = unsafe { &*(0 as *const [u8; 1])};\n+    let fat_sv : *const [i8] = unsafe { &*(0 as *const [i8; 1])};\n     let foo: &Foo = &f;\n \n     let _ = v as &u8; //~ ERROR non-scalar\n@@ -94,7 +95,7 @@ fn main()\n     let _ = main as *mut str; //~ ERROR casting\n     let _ = &f as *mut f32; //~ ERROR casting\n     let _ = &f as *const f64; //~ ERROR casting\n-    let _ = fat_v as usize;\n+    let _ = fat_sv as usize;\n     //~^ ERROR casting\n     //~^^ HELP through a thin pointer first\n \n@@ -106,7 +107,7 @@ fn main()\n     let _ = main.f as *const u32; //~ ERROR attempted access of field\n \n     let cf: *const Foo = &0;\n-    let _ = cf as *const [u8];\n+    let _ = cf as *const [u16];\n     //~^ ERROR casting\n     //~^^ NOTE vtable kinds\n     let _ = cf as *const Bar;"}, {"sha": "28806b6e2ab8cbd39eceb141c533e71e0abd2b61", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//~^^^^^^^^^^ ERROR overflow\n //\n // We get an error message at the top of file (dummy span).\n // This is not helpful, but also kind of annoying to prevent,\n@@ -32,6 +31,7 @@ impl<T:Clone> ToOpt for Option<T> {\n }\n \n fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n+//~^ ERROR reached the recursion limit during monomorphization\n     if counter > 0 {\n         function(counter - 1, t.to_option());\n         // FIXME(#4287) Error message should be here. It should be"}, {"sha": "64bfa232f3ffd0220c86a45f717919005be18ef6", "filename": "src/test/compile-fail/issue-29147.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Fcompile-fail%2Fissue-29147.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Fcompile-fail%2Fissue-29147.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29147.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![recursion_limit=\"1024\"]\n+\n+pub struct S0<T>(T,T);\n+pub struct S1<T>(Option<Box<S0<S0<T>>>>,Option<Box<S0<S0<T>>>>);\n+pub struct S2<T>(Option<Box<S1<S1<T>>>>,Option<Box<S1<S1<T>>>>);\n+pub struct S3<T>(Option<Box<S2<S2<T>>>>,Option<Box<S2<S2<T>>>>);\n+pub struct S4<T>(Option<Box<S3<S3<T>>>>,Option<Box<S3<S3<T>>>>);\n+pub struct S5<T>(Option<Box<S4<S4<T>>>>,Option<Box<S4<S4<T>>>>,Option<T>);\n+\n+trait Foo { fn xxx(&self); }\n+trait Bar {} // anything local or #[fundamental]\n+\n+impl<T> Foo for T where T: Bar, T: Sync {\n+    fn xxx(&self) {}\n+}\n+\n+impl Foo for S5<u32> { fn xxx(&self) {} }\n+impl Foo for S5<u64> { fn xxx(&self) {} }\n+\n+fn main() {\n+    let _ = <S5<_>>::xxx; //~ ERROR cannot resolve `S5<_> : Foo`\n+}"}, {"sha": "b1d45a82276a8b3c39bae308870f96d2a8ba1449", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -8,12 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//~^^^^^^^^^^ ERROR overflow\n-//\n-// We get an error message at the top of file (dummy span).\n-// This is not helpful, but also kind of annoying to prevent,\n-// so for now just live with it.\n-\n enum Nil {NilValue}\n struct Cons<T> {head:isize, tail:T}\n trait Dot {fn dot(&self, other:Self) -> isize;}\n@@ -26,7 +20,7 @@ impl<T:Dot> Dot for Cons<T> {\n   }\n }\n fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n-  match n {    0 => {first.dot(second)}\n+  match n {    0 => {first.dot(second)} //~ ERROR overflow\n       // FIXME(#4287) Error message should be here. It should be\n       // a type error to instantiate `test` at a type other than T.\n     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}"}, {"sha": "4b52378e5088932e4db0cefa0af93ba6c830e14d", "filename": "src/test/run-pass/coherence-rfc447-constrained.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Frun-pass%2Fcoherence-rfc447-constrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Frun-pass%2Fcoherence-rfc447-constrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-rfc447-constrained.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that trait matching can handle impls whose types are only\n+// constrained by a projection.\n+\n+trait IsU32 {}\n+impl IsU32 for u32 {}\n+\n+trait Mirror { type Image: ?Sized; }\n+impl<T: ?Sized> Mirror for T { type Image = T; }\n+\n+trait Bar {}\n+impl<U: Mirror, V: Mirror<Image=L>, L: Mirror<Image=U>> Bar for V\n+    where U::Image: IsU32 {}\n+\n+trait Foo { fn name() -> &'static str; }\n+impl Foo for u64 { fn name() -> &'static str { \"u64\" } }\n+impl<T: Bar> Foo for T { fn name() -> &'static str { \"Bar\" }}\n+\n+fn main() {\n+    assert_eq!(<u64 as Foo>::name(), \"u64\");\n+    assert_eq!(<u32 as Foo>::name(), \"Bar\");\n+}"}, {"sha": "026b98905d099b21f7741cc07c3c0ae5c04df139", "filename": "src/test/run-pass/issue-29147.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Frun-pass%2Fissue-29147.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Frun-pass%2Fissue-29147.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29147.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![recursion_limit=\"1024\"]\n+\n+use std::mem;\n+\n+pub struct S0<T>(T,T);\n+pub struct S1<T>(Option<Box<S0<S0<T>>>>,Option<Box<S0<S0<T>>>>);\n+pub struct S2<T>(Option<Box<S1<S1<T>>>>,Option<Box<S1<S1<T>>>>);\n+pub struct S3<T>(Option<Box<S2<S2<T>>>>,Option<Box<S2<S2<T>>>>);\n+pub struct S4<T>(Option<Box<S3<S3<T>>>>,Option<Box<S3<S3<T>>>>);\n+pub struct S5<T>(Option<Box<S4<S4<T>>>>,Option<Box<S4<S4<T>>>>,Option<T>);\n+\n+trait Foo { fn xxx(&self); }\n+/// some local of #[fundamental] trait\n+trait Bar {}\n+\n+impl<T> Foo for T where T: Bar, T: Sync {\n+    fn xxx(&self) {}\n+}\n+\n+impl Foo for S5<u8> { fn xxx(&self) {} }\n+\n+fn main() {\n+    let s = S5(None,None,None);\n+    s.xxx();\n+    assert_eq!(mem::size_of_val(&s.2), mem::size_of::<Option<u8>>());\n+}"}, {"sha": "71cd3c9441e104e5698d880c88cc51e2a3d77ec8", "filename": "src/test/run-pass/trait-copy-guessing.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Frun-pass%2Ftrait-copy-guessing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4309c2db6aedeae8705da87735213e063c3df51/src%2Ftest%2Frun-pass%2Ftrait-copy-guessing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-copy-guessing.rs?ref=e4309c2db6aedeae8705da87735213e063c3df51", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// \"guessing\" in trait selection can affect `copy_or_move`. Check that this\n+// is correctly handled. I am not sure what is the \"correct\" behaviour,\n+// but we should at least not ICE.\n+\n+use std::mem;\n+\n+struct U([u8; 1337]);\n+\n+struct S<'a,T:'a>(&'a T);\n+impl<'a, T> Clone for S<'a, T> { fn clone(&self) -> Self { S(self.0) } }\n+/// This impl triggers inference \"guessing\" - S<_>: Copy => _ = U\n+impl<'a> Copy for S<'a, Option<U>> {}\n+\n+fn assert_impls_fn<R,T: Fn()->R>(_: &T){}\n+\n+fn main() {\n+    let n = None;\n+    let e = S(&n);\n+    let f = || {\n+        // S being copy is critical for this to work\n+        drop(e);\n+        mem::size_of_val(e.0)\n+    };\n+    assert_impls_fn(&f);\n+    assert_eq!(f(), 1337+1);\n+\n+    assert_eq!((|| {\n+        // S being Copy is not critical here, but\n+        // we check it anyway.\n+        let n = None;\n+        let e = S(&n);\n+        let ret = mem::size_of_val(e.0);\n+        drop(e);\n+        ret\n+    })(), 1337+1);\n+}"}]}