{"sha": "1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjOWY5N2I2Njk0MDAxYTU3MmZlOGEwODVmYjlhOGNmYzZjYTQ0Yjg=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2011-11-19T06:44:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-21T19:15:19Z"}, "message": "stdlib: added (2,3,4)-valued logic ADTs\n\nThis is useful for writing caches and perhaps in typestate predicates.\nIt also adds a companion module for bool with from_str, to_str, ... fns.", "tree": {"sha": "0a015bfdeb8476ace9658dba1da881426b2f4362", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a015bfdeb8476ace9658dba1da881426b2f4362"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "html_url": "https://github.com/rust-lang/rust/commit/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beced3612efaa5d6207d48510bd5847c69ee230b", "url": "https://api.github.com/repos/rust-lang/rust/commits/beced3612efaa5d6207d48510bd5847c69ee230b", "html_url": "https://github.com/rust-lang/rust/commit/beced3612efaa5d6207d48510bd5847c69ee230b"}], "stats": {"total": 850, "additions": 848, "deletions": 2}, "files": [{"sha": "68c798ceb23848601f229482db2ea68ff785a91a", "filename": "src/lib/bool.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Flib%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Flib%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbool.rs?ref=1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "patch": "@@ -0,0 +1,134 @@\n+// -*- rust -*-\n+\n+/*\n+Module: bool\n+\n+Classic Boolean logic reified as ADT\n+*/\n+\n+export t;\n+export not, and, or, xor, implies;\n+export eq, ne, is_true, is_false;\n+export from_str, to_str, all_values, to_bit;\n+\n+/*\n+Type: t\n+\n+The type of boolean logic values\n+*/\n+type t = bool;\n+\n+/* Function: not\n+\n+Negation/Inverse\n+*/\n+pure fn not(v: t) -> t { !v }\n+\n+/* Function: and\n+\n+Conjunction\n+*/\n+pure fn and(a: t, b: t) -> t { a && b }\n+\n+/* Function: and\n+\n+Disjunction\n+*/\n+pure fn or(a: t, b: t) -> t { a || b }\n+\n+/*\n+Function: xor\n+\n+Exclusive or, i.e. `or(and(a, not(b)), and(not(a), b))`\n+*/\n+pure fn xor(a: t, b: t) -> t { (a && !b) || (!a && b) }\n+\n+/*\n+Function: implies\n+\n+Implication in the logic, i.e. from `a` follows `b`\n+*/\n+pure fn implies(a: t, b: t) -> t { !a || b }\n+\n+/*\n+Predicate: eq\n+\n+Returns:\n+\n+true if truth values `a` and `b` are indistinguishable in the logic\n+*/\n+pure fn eq(a: t, b: t) -> bool { a == b }\n+\n+/*\n+Predicate: ne\n+\n+Returns:\n+\n+true if truth values `a` and `b` are distinguishable in the logic\n+*/\n+pure fn ne(a: t, b: t) -> bool { a != b }\n+\n+/*\n+Predicate: is_true\n+\n+Returns:\n+\n+true if `v` represents truth in the logic\n+*/\n+pure fn is_true(v: t) -> bool { v }\n+\n+/*\n+Predicate: is_false\n+\n+Returns:\n+\n+true if `v` represents falsehood in the logic\n+*/\n+pure fn is_false(v: t) -> bool { !v }\n+\n+/*\n+Function: from_str\n+\n+Parse logic value from `s`\n+*/\n+pure fn from_str(s: str) -> t {\n+    alt s {\n+      \"true\" { true }\n+      \"false\" { false }\n+    }\n+}\n+\n+/*\n+Function: to_str\n+\n+Convert `v` into a string\n+*/\n+pure fn to_str(v: t) -> str { if v { \"true\" } else { \"false\" } }\n+\n+/*\n+Function: all_values\n+\n+Iterates over all truth values by passing them to `blk`\n+in an unspecified order\n+*/\n+fn all_values(blk: block(v: t)) {\n+    blk(true);\n+    blk(false);\n+}\n+\n+/*\n+Function: to_bit\n+\n+Returns:\n+\n+An u8 whose first bit is set if `if_true(v)` holds\n+*/\n+fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "a1165caf864124b6fc57b8b7b9afcfc140ac741d", "filename": "src/lib/four.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Flib%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Flib%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffour.rs?ref=1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "patch": "@@ -0,0 +1,229 @@\n+// -*- rust -*-\n+\n+/*\n+Module: four\n+\n+The fourrternary Belnap relevance logic FOUR represented as ADT\n+\n+This allows reasoning with four logic values (true, false, none, both)\n+\n+Implementation: Truth values are represented using a single u8 and\n+all operations are done using bitshifting which is fast\n+on current cpus.\n+*/\n+\n+import tri;\n+\n+export t, none, true, false, both;\n+export not, and, or, xor, implies, implies_materially;\n+export eq, ne, is_true, is_false;\n+export from_str, to_str, all_values, to_trit, to_bit;\n+\n+/*\n+Type: t\n+\n+The type of fourrternary logic values\n+\n+It may be thought of as  tuple `(y, x)` of two bools\n+\n+*/\n+type t = u8;\n+\n+const b0: u8  = 1u8;\n+const b1: u8  = 2u8;\n+const b01: u8 = 3u8;\n+\n+/*\n+Constant: none\n+\n+Logic value `(0, 0)` for bottom (neither true or false)\n+*/\n+const none: t  = 0u8;\n+\n+/*\n+Constant: true\n+\n+Logic value `(0, 1)` for truth\n+*/\n+const true: t  = 1u8;\n+\n+/*\n+Constant: false\n+\n+Logic value `(1, 0)` for falsehood\n+*/\n+const false: t = 2u8;\n+\n+/*\n+Constant: both\n+\n+Logic value `(1, 1)` for top (both true and false)\n+*/\n+const both: t  = 3u8;\n+\n+/* Function: not\n+\n+Negation/Inverse\n+\n+Returns:\n+\n+`'(v.y, v.x)`\n+*/\n+pure fn not(v: t) -> t { ((v << 1u8) | (v >> 1u8)) & b01 }\n+\n+/* Function: and\n+\n+Conjunction\n+\n+Returns:\n+\n+`(a.x | b.x, a.y & b.y)`\n+*/\n+pure fn and(a: t, b: t) -> t { ((a & b) & b0) | ((a | b) & b1) }\n+\n+/* Function: or\n+\n+Disjunction\n+\n+Returns:\n+\n+`(a.x & b.x, a.y | b.y)`\n+*/\n+pure fn or(a: t, b: t) -> t { ((a | b) & b0) | ((a & b) & b1) }\n+\n+/* Function: xor\n+\n+Classic exclusive or\n+\n+Returns:\n+\n+`or(and(a, not(b)), and(not(a), b))`\n+*/\n+pure fn xor(a: t, b: t) -> t { or(and(a, not(b)), and(not(a), b)) }\n+\n+/*\n+Function: implies\n+\n+Strong implication (from `a` strongly follows `b`)\n+\n+Returns:\n+\n+`( x1 & y2, !x1 | x2)`\n+*/\n+pure fn implies(a: t, b: t) -> t { ((a << 1u8) & b & b1) | (((!a) | b) & b0) }\n+\n+/*\n+Function: implies_materially\n+\n+Classic (material) implication in the logic\n+(from `a` materially follows `b`)\n+\n+Returns:\n+\n+`or(not(a), b)`\n+*/\n+pure fn implies_materially(a: t, b: t) -> t { or(not(a), b) }\n+\n+/*\n+Predicate: eq\n+\n+Returns:\n+\n+true if truth values `a` and `b` are indistinguishable in the logic\n+*/\n+pure fn eq(a: t, b: t) -> bool { a == b }\n+\n+/*\n+Predicate: ne\n+\n+Returns:\n+\n+true if truth values `a` and `b` are distinguishable in the logic\n+*/\n+pure fn ne(a: t, b: t) -> bool { a != b }\n+\n+/*\n+Predicate: is_true\n+\n+Returns:\n+\n+true if `v` represents truth in the logic (is `true` or `both`)\n+*/\n+pure fn is_true(v: t) -> bool { (v & b0) != 0u8 }\n+\n+/*\n+Predicate: is_false\n+\n+Returns:\n+\n+true if `v` represents falsehood in the logic (is `false` or `none`)\n+*/\n+pure fn is_false(v: t) -> bool { (v & b0) == 0u8 }\n+\n+/*\n+Function: from_str\n+\n+Parse logic value from `s`\n+*/\n+pure fn from_str(s: str) -> t {\n+    alt s {\n+      \"none\" { none }\n+      \"false\" { four::false }\n+      \"true\" { four::true }\n+      \"both\" { both }\n+    }\n+}\n+\n+/*\n+Function: to_str\n+\n+Convert `v` into a string\n+*/\n+pure fn to_str(v: t) -> str {\n+    // FIXME replace with consts as soon as that works\n+    alt v {\n+      0u8 { \"none\" }\n+      1u8 { \"true\" }\n+      2u8 { \"false\" }\n+      3u8 { \"both\" }\n+    }\n+}\n+\n+/*\n+Function: all_values\n+\n+Iterates over all truth values by passing them to `blk`\n+in an unspecified order\n+*/\n+fn all_values(blk: block(v: t)) {\n+    blk(both);\n+    blk(four::true);\n+    blk(four::false);\n+    blk(none);\n+}\n+\n+/*\n+Function: to_bit\n+\n+Returns:\n+\n+An u8 whose first bit is set if `if_true(v)` holds\n+*/\n+fn to_bit(v: t) -> u8 { v & b0 }\n+\n+/*\n+Function: to_tri\n+\n+Returns:\n+\n+A trit of `v` (`both` and `none` are both coalesced into `trit::unknown`)\n+*/\n+fn to_trit(v: t) -> tri::t { v & (v ^ not(v)) }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "87184d5e9055b5f771897776a80239b286c5deb1", "filename": "src/lib/std.rc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "patch": "@@ -7,9 +7,9 @@\n #[license = \"BSD\"];\n \n \n-export box, char, float, int, str, ptr, uint, u8, u32, u64, vec;\n+export box, char, float, int, str, ptr, uint, u8, u32, u64, vec, bool;\n export comm, fs, io, net, run, sys, task;\n-export ctypes, either, option, result, util;\n+export ctypes, either, option, result, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n export ebml, dbg, getopts, json, math, rand, sha1, term, time, unsafe;\n@@ -30,6 +30,7 @@ mod uint;\n mod u8;\n mod u32;\n mod u64;\n+mod bool;\n mod vec;\n \n \n@@ -50,6 +51,8 @@ mod ctypes;\n mod either;\n mod option;\n mod result;\n+mod four;\n+mod tri;\n mod util;\n \n "}, {"sha": "27e24bb4f47ca4c69405addac1677641288ed02f", "filename": "src/lib/tri.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Flib%2Ftri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Flib%2Ftri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftri.rs?ref=1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "patch": "@@ -0,0 +1,188 @@\n+// -*- rust -*-\n+\n+/*\n+Module: tri\n+\n+ADT for the ternary Kleene logic K3\n+\n+This allows reasoning with three logic values (true, false, unknown)\n+\n+Implementation: Truth values are represented using a single u8 and\n+all operations are done using bitshifting which is fast\n+on current cpus.\n+*/\n+\n+export t, true, false, unknown;\n+export not, and, or, xor, implies, eq, ne, is_true, is_false;\n+export from_str, to_str, all_values, to_bit;\n+\n+/*\n+Type: t\n+\n+The type of ternary logic values\n+*/\n+type t = u8;\n+\n+const b0: u8  = 1u8;\n+const b1: u8  = 2u8;\n+const b01: u8 = 3u8;\n+\n+/*\n+Constant: unknown\n+\n+Logic value for unknown (maybe true xor maybe false)\n+*/\n+const unknown: t = 0u8;\n+\n+/*\n+Constant: true\n+\n+Logic value for truth\n+*/\n+const true: t = 1u8;\n+\n+/*\n+Constant: false\n+\n+Logic value for falsehood\n+*/\n+const false: t = 2u8;\n+\n+/* Function: not\n+\n+Negation/Inverse\n+*/\n+pure fn not(v: t) -> t { ((v << 1u8) | (v >> 1u8)) & b01 }\n+\n+/* Function: and\n+\n+Conjunction\n+*/\n+pure fn and(a: t, b: t) -> t { ((a | b) & b1) | ((a & b) & b0) }\n+\n+/* Function: or\n+\n+Disjunction\n+*/\n+pure fn or(a: t, b: t) -> t { ((a & b) & b1) | ((a | b) & b0) }\n+\n+/*\n+Function: xor\n+\n+Exclusive or\n+*/\n+pure fn xor(a: t, b: t) -> t {\n+    let anb = a & b;\n+    let aob = a & not(b);\n+    ret ((anb & b1) | (anb << 1u8) | (aob >> 1u8) | (aob & b0)) & b01;\n+}\n+\n+/*\n+Function: implies\n+\n+Classic implication, i.e. from `a` follows `b`\n+*/\n+pure fn implies(a: t, b: t) -> t {\n+    ret ((a & b1) >> 1u8) | (b & b0) | ((a << 1u8) & b & b1);\n+}\n+\n+/*\n+Predicate: eq\n+\n+Returns:\n+\n+true if truth values `a` and `b` are indistinguishable in the logic\n+*/\n+pure fn eq(a: t, b: t) -> bool {  a == b }\n+\n+/*\n+Predicate: ne\n+\n+Returns:\n+\n+true if truth values `a` and `b` are distinguishable in the logic\n+*/\n+pure fn ne(a: t, b: t) -> bool { a != b }\n+\n+/*\n+Predicate: is_true\n+\n+Returns:\n+\n+true if `v` represents truth in the logic\n+*/\n+pure fn is_true(v: t) -> bool { v == tri::true }\n+\n+/*\n+Predicate: is_false\n+\n+Returns:\n+\n+true if `v` represents false in the logic\n+*/\n+pure fn is_false(v: t) -> bool { v == tri::false }\n+\n+/*\n+Predicate: is_unknown\n+\n+Returns:\n+\n+true if `v` represents the unknown state in the logic\n+*/\n+pure fn is_unknown(v: t) -> bool { v == unknown }\n+\n+/*\n+Function: from_str\n+\n+Parse logic value from `s`\n+*/\n+pure fn from_str(s: str) -> t {\n+    alt s {\n+      \"unknown\" { unknown }\n+      \"true\" { tri::true }\n+      \"false\" { tri::false }\n+    }\n+}\n+\n+/*\n+Function: to_str\n+\n+Convert `v` into a string\n+*/\n+pure fn to_str(v: t) -> str {\n+    // FIXME replace with consts as soon as that works\n+    alt v {\n+      0u8 { \"unknown\" }\n+      1u8 { \"true\" }\n+      2u8 { \"false\" }\n+    }\n+}\n+\n+/*\n+Function: all_values\n+\n+Iterates over all truth values by passing them to `blk`\n+in an unspecified order\n+*/\n+fn all_values(blk: block(v: t)) {\n+    blk(tri::false);\n+    blk(unknown);\n+    blk(tri::true);\n+}\n+\n+/*\n+Function: to_bit\n+\n+Returns:\n+\n+An u8 whose first bit is set if `if_true(v)` holds\n+*/\n+fn to_bit(v: t) -> u8 { v & b0 }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "2f91b7aa1e1588207f13fb1ceafee5bfac1d1ab2", "filename": "src/test/stdtest/bool.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Ftest%2Fstdtest%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Ftest%2Fstdtest%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbool.rs?ref=1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "patch": "@@ -0,0 +1,23 @@\n+use std;\n+\n+import std::bool;\n+\n+#[test]\n+fn test_bool_from_str() {\n+    bool::all_values { |v|\n+        assert v == bool::from_str(bool::to_str(v))\n+    }\n+}\n+\n+#[test]\n+fn test_bool_to_str() {\n+    assert bool::to_str(false) == \"false\";\n+    assert bool::to_str(true) == \"true\";\n+}\n+\n+#[test]\n+fn test_bool_to_bit() {\n+    bool::all_values { |v|\n+        assert bool::to_bit(v) == if bool::is_true(v) { 1u8 } else { 0u8 };\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "d0af7a393d3b69ad1b6c48d2f1f80ed466afd28a", "filename": "src/test/stdtest/four.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Ftest%2Fstdtest%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Ftest%2Fstdtest%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffour.rs?ref=1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "patch": "@@ -0,0 +1,149 @@\n+use std;\n+\n+import std::tri;\n+import std::four;\n+\n+fn eq1(a: four::t, b: four::t) -> bool { four::eq(a , b) }\n+fn ne1(a: four::t, b: four::t) -> bool { four::ne(a , b) }\n+\n+fn eq2(a: four::t, b: four::t) -> bool { eq1( a, b ) && eq1( b, a ) }\n+\n+#[test]\n+fn test_four_req_eq() {\n+    four::all_values { |a|\n+        four::all_values { |b|\n+            assert if a == b { eq1( a, b ) } else { ne1( a, b ) };\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_four_and_symmetry() {\n+    four::all_values { |a|\n+        four::all_values { |b|\n+            assert eq1( four::and(a ,b), four::and(b, a) );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_four_xor_symmetry() {\n+    four::all_values { |a|\n+        four::all_values { |b|\n+            assert eq1( four::and(a ,b), four::and(b, a) );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_four_or_symmetry() {\n+    four::all_values { |a|\n+        four::all_values { |b|\n+            assert eq1( four::or(a ,b), four::or(b, a) );\n+        }\n+    }\n+}\n+\n+fn to_tup(v: four::t) -> (bool, bool) {\n+    alt v {\n+      0u8 { (false, false) }\n+      1u8 { (false, true) }\n+      2u8 { (true, false) }\n+      3u8 { (true, true) }\n+    }\n+}\n+\n+#[test]\n+fn test_four_not() {\n+    four::all_values { |a|\n+        let (x, y) = to_tup(a);\n+        assert to_tup(four::not(a)) == (y, x);\n+    };\n+}\n+\n+\n+#[test]\n+fn test_four_and() {\n+    four::all_values { |a|\n+        four::all_values { |b|\n+            let (y1, x1) = to_tup(a);\n+            let (y2, x2) = to_tup(b);\n+            let (y3, x3) = to_tup(four::and(a, b));\n+\n+            assert (x3, y3) == (x1 && x2, y1 || y2);\n+        }\n+    };\n+}\n+\n+#[test]\n+fn test_four_or() {\n+    four::all_values { |a|\n+        four::all_values { |b|\n+            let (y1, x1) = to_tup(a);\n+            let (y2, x2) = to_tup(b);\n+            let (y3, x3) = to_tup(four::or(a, b));\n+\n+            assert (x3, y3) == (x1 || x2, y1 && y2);\n+        }\n+    };\n+}\n+\n+#[test]\n+fn test_four_implies() {\n+    four::all_values { |a|\n+        four::all_values { |b|\n+            let (_, x1) = to_tup(a);\n+            let (y2, x2) = to_tup(b);\n+            let (y3, x3) = to_tup(four::implies(a, b));\n+\n+            assert (x3, y3) == (!x1 || x2, x1 && y2);\n+        }\n+    };\n+}\n+\n+#[test]\n+fn test_four_is_true() {\n+    assert !four::is_true(four::none);\n+    assert !four::is_true(four::false);\n+    assert four::is_true(four::true);\n+    assert four::is_true(four::both);\n+}\n+\n+#[test]\n+fn test_four_is_false() {\n+    assert four::is_false(four::none);\n+    assert four::is_false(four::false);\n+    assert !four::is_false(four::true);\n+    assert !four::is_false(four::both);\n+}\n+\n+#[test]\n+fn test_four_from_str() {\n+    four::all_values { |v|\n+        assert eq1( v, four::from_str(four::to_str(v)) );\n+    }\n+}\n+\n+#[test]\n+fn test_four_to_str() {\n+    assert four::to_str(four::none) == \"none\";\n+    assert four::to_str(four::false) == \"false\";\n+    assert four::to_str(four::true) == \"true\" ;\n+    assert four::to_str(four::both) == \"both\";\n+}\n+\n+#[test]\n+fn test_four_to_tri() {\n+    assert tri::eq( four::to_trit(four::true), tri::true );\n+    assert tri::eq( four::to_trit(four::false), tri::false );\n+    assert tri::eq( four::to_trit(four::none), tri::unknown );\n+    log four::to_trit(four::both);\n+    assert tri::eq( four::to_trit(four::both), tri::unknown );\n+}\n+\n+#[test]\n+fn test_four_to_bit() {\n+    four::all_values { |v|\n+        assert four::to_bit(v) == if four::is_true(v) { 1u8 } else { 0u8 };\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "289c1221c92e4ac8d8d499a1db2843cf085a9a9f", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "patch": "@@ -1,12 +1,14 @@\n use std;\n \n mod bitv;\n+mod bool;\n mod box;\n mod char;\n mod comm;\n mod deque;\n mod either;\n mod float;\n+mod four;\n mod fs;\n mod getopts;\n mod int;\n@@ -32,6 +34,7 @@ mod str;\n mod sys;\n mod task;\n mod test;\n+mod tri;\n mod treemap;\n mod uint;\n mod unsafe;"}, {"sha": "4ea87c1270eccd2340b25a4c1b09f8c87ca7b9fb", "filename": "src/test/stdtest/tri.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Ftest%2Fstdtest%2Ftri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8/src%2Ftest%2Fstdtest%2Ftri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftri.rs?ref=1c9f97b6694001a572fe8a085fb9a8cfc6ca44b8", "patch": "@@ -0,0 +1,117 @@\n+use std;\n+\n+import std::tri;\n+\n+pure fn eq1(a: tri::t, b: tri::t) -> bool { tri::eq(a , b) }\n+pure fn ne1(a: tri::t, b: tri::t) -> bool { tri::ne(a , b) }\n+\n+pure fn eq2(a: tri::t, b: tri::t) -> bool { eq1( a, b ) && eq1( b, a ) }\n+\n+#[test]\n+fn test_eq2() {\n+    tri::all_values { |a|\n+        tri::all_values { |b|\n+            assert if a == b { eq1( a, b ) } else { ne1( a, b ) }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_tri_and_symmetry() {\n+    tri::all_values { |a|\n+        tri::all_values { |b|\n+            assert eq1( tri::and(a ,b), tri::and(b, a) );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_tri_or_symmetry() {\n+    tri::all_values { |a|\n+        tri::all_values { |b|\n+            assert eq1( tri::or(a ,b), tri::or(b, a) );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_tri_xor_symmetry() {\n+    tri::all_values { |a|\n+        tri::all_values { |b|\n+            assert eq1( tri::xor(a ,b), tri::xor(b, a) );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_tri_not() {\n+    assert eq2( tri::not(tri::true), tri::false);\n+    assert eq2( tri::not(tri::unknown), tri::unknown);\n+    assert eq2( tri::not(tri::false), tri::true);\n+}\n+\n+#[test]\n+fn test_tri_and() {\n+    assert eq2( tri::and(tri::true, tri::true), tri::true);\n+    assert eq2( tri::and(tri::true, tri::false), tri::false);\n+    assert eq2( tri::and(tri::true, tri::unknown), tri::unknown);\n+    assert eq2( tri::and(tri::false, tri::false), tri::false);\n+    assert eq2( tri::and(tri::false, tri::unknown), tri::false);\n+    assert eq2( tri::and(tri::unknown, tri::unknown), tri::unknown);\n+}\n+\n+#[test]\n+fn test_tri_or() {\n+    assert eq2( tri::or(tri::true, tri::true), tri::true);\n+    assert eq2( tri::or(tri::true, tri::false), tri::true);\n+    assert eq2( tri::or(tri::true, tri::unknown), tri::true);\n+    assert eq2( tri::or(tri::false, tri::false), tri::false);\n+    assert eq2( tri::or(tri::false, tri::unknown), tri::unknown);\n+    assert eq2( tri::or(tri::unknown, tri::unknown), tri::unknown);\n+}\n+\n+#[test]\n+fn test_tri_xor() {\n+    assert eq2( tri::xor(tri::true, tri::true), tri::false);\n+    assert eq2( tri::xor(tri::false, tri::false), tri::false);\n+    assert eq2( tri::xor(tri::true, tri::false), tri::true);\n+    assert eq2( tri::xor(tri::true, tri::unknown), tri::unknown);\n+    assert eq2( tri::xor(tri::false, tri::unknown), tri::unknown);\n+    assert eq2( tri::xor(tri::unknown, tri::unknown), tri::unknown);\n+}\n+\n+#[test]\n+fn test_tri_implies() {\n+    assert eq2( tri::implies(tri::false, tri::false), tri::true);\n+    assert eq2( tri::implies(tri::false, tri::unknown), tri::true);\n+    assert eq2( tri::implies(tri::false, tri::true), tri::true);\n+\n+    assert eq2( tri::implies(tri::unknown, tri::false), tri::unknown);\n+    assert eq2( tri::implies(tri::unknown, tri::unknown), tri::unknown);\n+    assert eq2( tri::implies(tri::unknown, tri::true), tri::true);\n+\n+    assert eq2( tri::implies(tri::true, tri::false), tri::false);\n+    assert eq2( tri::implies(tri::true, tri::unknown), tri::unknown);\n+    assert eq2( tri::implies(tri::true, tri::true), tri::true);\n+}\n+\n+#[test]\n+fn test_tri_from_str() {\n+    tri::all_values { |v|\n+        assert eq2( v, tri::from_str(tri::to_str(v)));\n+    }\n+}\n+\n+#[test]\n+fn test_tri_to_str() {\n+    assert tri::to_str(tri::false) == \"false\";\n+    assert tri::to_str(tri::unknown) == \"unknown\";\n+    assert tri::to_str(tri::true) == \"true\";\n+}\n+\n+#[test]\n+fn test_tri_to_bit() {\n+    tri::all_values { |v|\n+        assert tri::to_bit(v) == if tri::is_true(v) { 1u8 } else { 0u8 };\n+    }\n+}\n\\ No newline at end of file"}]}