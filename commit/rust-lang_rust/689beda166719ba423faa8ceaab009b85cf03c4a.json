{"sha": "689beda166719ba423faa8ceaab009b85cf03c4a", "node_id": "C_kwDOAAsO6NoAKDY4OWJlZGExNjY3MTliYTQyM2ZhYThjZWFhYjAwOWI4NWNmMDNjNGE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-05T13:25:04Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-05T13:49:48Z"}, "message": "Implement `OwnedSlice`", "tree": {"sha": "6d29425376cd810738451db88dc9996d0b20f205", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d29425376cd810738451db88dc9996d0b20f205"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/689beda166719ba423faa8ceaab009b85cf03c4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/689beda166719ba423faa8ceaab009b85cf03c4a", "html_url": "https://github.com/rust-lang/rust/commit/689beda166719ba423faa8ceaab009b85cf03c4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/689beda166719ba423faa8ceaab009b85cf03c4a/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be8e5ba157a4ae494f9b4219b3b848e44ea5e8d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/be8e5ba157a4ae494f9b4219b3b848e44ea5e8d3", "html_url": "https://github.com/rust-lang/rust/commit/be8e5ba157a4ae494f9b4219b3b848e44ea5e8d3"}], "stats": {"total": 125, "additions": 120, "deletions": 5}, "files": [{"sha": "62e22127b77cf5b850ca4cf39abfcd2473f96063", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/689beda166719ba423faa8ceaab009b85cf03c4a/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689beda166719ba423faa8ceaab009b85cf03c4a/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=689beda166719ba423faa8ceaab009b85cf03c4a", "patch": "@@ -27,6 +27,8 @@\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n #![feature(get_mut_unchecked)]\n+#![feature(lint_reasons)]\n+#![feature(unwrap_infallible)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -82,6 +84,7 @@ pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n+pub mod owned_slice;\n pub mod sso;\n pub mod steal;\n pub mod tagged_ptr;"}, {"sha": "dce209adfaa8997348b5d4aa976703be2abcf14d", "filename": "compiler/rustc_data_structures/src/owned_slice.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/689beda166719ba423faa8ceaab009b85cf03c4a/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689beda166719ba423faa8ceaab009b85cf03c4a/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs?ref=689beda166719ba423faa8ceaab009b85cf03c4a", "patch": "@@ -0,0 +1,113 @@\n+use std::{borrow::Borrow, ops::Deref};\n+\n+// Use our fake Send/Sync traits when on not parallel compiler,\n+// so that `OwnedSlice` only implements/requires Send/Sync\n+// for parallel compiler builds.\n+use crate::sync::{Send, Sync};\n+\n+/// An owned slice.\n+///\n+/// This is similar to `Box<[u8]>` but allows slicing and using anything as the\n+/// backing buffer.\n+///\n+/// See [`slice_owned`] for `OwnedSlice` construction and examples.\n+///\n+/// ---------------------------------------------------------------------------\n+///\n+/// This is essentially a replacement for `owning_ref` which is a lot simpler\n+/// and even sound! \ud83c\udf38\n+pub struct OwnedSlice {\n+    /// This is conceptually a `&'self.owner [u8]`.\n+    bytes: *const [u8],\n+\n+    // +---------------------------------------+\n+    // | We expect `dead_code` lint here,      |\n+    // | because we don't want to accidentally |\n+    // | touch the owner \u2014 otherwise the owner |\n+    // | could invalidate out `bytes` pointer  |\n+    // |                                       |\n+    // | so be quite                           |\n+    // +----+  +-------------------------------+\n+    //       \\/\n+    //      \u2282(\u00b4\uff65\u25e1\uff65\u2282 )\u2218\u02da\u02f3\u00b0\n+    #[expect(dead_code)]\n+    owner: Box<dyn Send + Sync>,\n+}\n+\n+/// Makes an [`OwnedSlice`] out of an `owner` and a `slicer` function.\n+///\n+/// ## Examples\n+///\n+/// ```rust\n+/// # use rustc_data_structures::owned_slice::{OwnedSlice, slice_owned};\n+/// let vec = vec![1, 2, 3, 4];\n+///\n+/// // Identical to slicing via `&v[1..3]` but produces an owned slice\n+/// let slice: OwnedSlice = slice_owned(vec, |v| &v[1..3]);\n+/// assert_eq!(&*slice, [2, 3]);\n+/// ```\n+///\n+/// ```rust\n+/// # use rustc_data_structures::owned_slice::{OwnedSlice, slice_owned};\n+/// # use std::ops::Deref;\n+/// let vec = vec![1, 2, 3, 4];\n+///\n+/// // Identical to slicing via `&v[..]` but produces an owned slice\n+/// let slice: OwnedSlice = slice_owned(vec, Deref::deref);\n+/// assert_eq!(&*slice, [1, 2, 3, 4]);\n+/// ```\n+pub fn slice_owned<O, F>(owner: O, slicer: F) -> OwnedSlice\n+where\n+    O: Send + Sync + 'static,\n+    F: Fn(&O) -> &[u8],\n+{\n+    try_slice_owned(owner, |x| Ok::<_, !>(slicer(x))).into_ok()\n+}\n+\n+/// Makes an [`OwnedSlice`] out of an `owner` and a `slicer` function that can fail.\n+///\n+/// See [`slice_owned`] for the infallible version.\n+pub fn try_slice_owned<O, F, E>(owner: O, slicer: F) -> Result<OwnedSlice, E>\n+where\n+    O: Send + Sync + 'static,\n+    F: Fn(&O) -> Result<&[u8], E>,\n+{\n+    // We box the owner of the bytes, so it doesn't move.\n+    //\n+    // Since the owner does not move and we don't access it in any way\n+    // before drop, there is nothing that can invalidate the bytes pointer.\n+    //\n+    // Thus, \"extending\" the lifetime of the reference returned from `F` is fine.\n+    // We pretend that we pass it a reference that lives as long as the returned slice.\n+    //\n+    // N.B. the HRTB on the `slicer` is important \u2014 without it the caller could provide\n+    // a short lived slice, unrelated to the owner.\n+\n+    let owner = Box::new(owner);\n+    let bytes = slicer(&*owner)?;\n+\n+    Ok(OwnedSlice { bytes, owner })\n+}\n+\n+impl Deref for OwnedSlice {\n+    type Target = [u8];\n+\n+    fn deref(&self) -> &[u8] {\n+        // Safety:\n+        // `self.bytes` is valid per the construction in `slice_owned`\n+        // (which is the only constructor)\n+        unsafe { &*self.bytes }\n+    }\n+}\n+\n+impl Borrow<[u8]> for OwnedSlice {\n+    fn borrow(&self) -> &[u8] {\n+        self\n+    }\n+}\n+\n+// Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Send`\n+unsafe impl Send for OwnedSlice {}\n+\n+// Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Sync`\n+unsafe impl Sync for OwnedSlice {}"}, {"sha": "8a53e28034b7109a9a78268bd7f94b0c9df2ef21", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/689beda166719ba423faa8ceaab009b85cf03c4a/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689beda166719ba423faa8ceaab009b85cf03c4a/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=689beda166719ba423faa8ceaab009b85cf03c4a", "patch": "@@ -57,18 +57,17 @@ mod vec;\n \n cfg_if! {\n     if #[cfg(not(parallel_compiler))] {\n-        pub auto trait Send {}\n-        pub auto trait Sync {}\n-\n-        impl<T> Send for T {}\n-        impl<T> Sync for T {}\n+        pub unsafe auto trait Send {}\n+        pub unsafe auto trait Sync {}\n \n         #[macro_export]\n         macro_rules! rustc_erase_owner {\n             ($v:expr) => {\n                 $v.erase_owner()\n             }\n         }\n+        unsafe impl<T> Send for T {}\n+        unsafe impl<T> Sync for T {}\n \n         use std::ops::Add;\n "}]}