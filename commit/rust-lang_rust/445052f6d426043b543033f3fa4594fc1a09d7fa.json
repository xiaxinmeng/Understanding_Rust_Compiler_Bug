{"sha": "445052f6d426043b543033f3fa4594fc1a09d7fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NTA1MmY2ZDQyNjA0M2I1NDMwMzNmM2ZhNDU5NGZjMWEwOWQ3ZmE=", "commit": {"author": {"name": "Leander Tentrup", "email": "leander.tentrup@gmail.com", "date": "2020-04-22T13:28:35Z"}, "committer": {"name": "Leander Tentrup", "email": "leander.tentrup@gmail.com", "date": "2020-04-22T13:28:35Z"}, "message": "Adapt format specifier highlighting to support escaped squences and unicode identifiers", "tree": {"sha": "3638c65c16b78f142101a87274edd94d647b6745", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3638c65c16b78f142101a87274edd94d647b6745"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/445052f6d426043b543033f3fa4594fc1a09d7fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/445052f6d426043b543033f3fa4594fc1a09d7fa", "html_url": "https://github.com/rust-lang/rust/commit/445052f6d426043b543033f3fa4594fc1a09d7fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/445052f6d426043b543033f3fa4594fc1a09d7fa/comments", "author": {"login": "ltentrup", "id": 201808, "node_id": "MDQ6VXNlcjIwMTgwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/201808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ltentrup", "html_url": "https://github.com/ltentrup", "followers_url": "https://api.github.com/users/ltentrup/followers", "following_url": "https://api.github.com/users/ltentrup/following{/other_user}", "gists_url": "https://api.github.com/users/ltentrup/gists{/gist_id}", "starred_url": "https://api.github.com/users/ltentrup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ltentrup/subscriptions", "organizations_url": "https://api.github.com/users/ltentrup/orgs", "repos_url": "https://api.github.com/users/ltentrup/repos", "events_url": "https://api.github.com/users/ltentrup/events{/privacy}", "received_events_url": "https://api.github.com/users/ltentrup/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ltentrup", "id": 201808, "node_id": "MDQ6VXNlcjIwMTgwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/201808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ltentrup", "html_url": "https://github.com/ltentrup", "followers_url": "https://api.github.com/users/ltentrup/followers", "following_url": "https://api.github.com/users/ltentrup/following{/other_user}", "gists_url": "https://api.github.com/users/ltentrup/gists{/gist_id}", "starred_url": "https://api.github.com/users/ltentrup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ltentrup/subscriptions", "organizations_url": "https://api.github.com/users/ltentrup/orgs", "repos_url": "https://api.github.com/users/ltentrup/repos", "events_url": "https://api.github.com/users/ltentrup/events{/privacy}", "received_events_url": "https://api.github.com/users/ltentrup/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2829a52161bc414f3b361c06b66633a234bba16", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2829a52161bc414f3b361c06b66633a234bba16", "html_url": "https://github.com/rust-lang/rust/commit/b2829a52161bc414f3b361c06b66633a234bba16"}], "stats": {"total": 353, "additions": 209, "deletions": 144}, "files": [{"sha": "433f2e0c5e91eb8c5d328781ff36e6dfe40616d7", "filename": "crates/ra_ide/src/snapshots/highlight_strings.html", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/445052f6d426043b543033f3fa4594fc1a09d7fa/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/445052f6d426043b543033f3fa4594fc1a09d7fa/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html?ref=445052f6d426043b543033f3fa4594fc1a09d7fa", "patch": "@@ -74,4 +74,9 @@\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">, `</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">:</span><span class=\"attribute\">&gt;</span><span class=\"numeric_literal\">8</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">` has 3 right-aligned characters\"</span>, <span class=\"string_literal\">\"Hello\"</span>, <span class=\"numeric_literal\">3</span>, name=<span class=\"string_literal\">\"1234.56\"</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello {{}}\"</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"{{ Hello\"</span>);\n+\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">r\"Hello, </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"world\"</span>);\n+\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">\\x41</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, A = <span class=\"numeric_literal\">92</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">\u043d\u0438\u0447\u043e\u0441\u0438</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, \u043d\u0438\u0447\u043e\u0441\u0438 = <span class=\"numeric_literal\">92</span>);\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "b5fd3390f20cd454b7d0e2484944bc82ba1232fe", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/445052f6d426043b543033f3fa4594fc1a09d7fa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445052f6d426043b543033f3fa4594fc1a09d7fa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=445052f6d426043b543033f3fa4594fc1a09d7fa", "patch": "@@ -245,28 +245,29 @@ pub(crate) fn highlight(\n                 stack.push();\n                 if is_format_string {\n                     string.lex_format_specifier(|piece_range, kind| {\n-                        let highlight = match kind {\n-                            FormatSpecifier::Open\n-                            | FormatSpecifier::Close\n-                            | FormatSpecifier::Colon\n-                            | FormatSpecifier::Fill\n-                            | FormatSpecifier::Align\n-                            | FormatSpecifier::Sign\n-                            | FormatSpecifier::NumberSign\n-                            | FormatSpecifier::DollarSign\n-                            | FormatSpecifier::Dot\n-                            | FormatSpecifier::Asterisk\n-                            | FormatSpecifier::QuestionMark => HighlightTag::Attribute,\n-                            FormatSpecifier::Integer | FormatSpecifier::Zero => {\n-                                HighlightTag::NumericLiteral\n-                            }\n-                            FormatSpecifier::Identifier => HighlightTag::Local,\n-                        };\n-                        stack.add(HighlightedRange {\n-                            range: piece_range + range.start(),\n-                            highlight: highlight.into(),\n-                            binding_hash: None,\n-                        });\n+                        if let Some(highlight) = highlight_format_specifier(kind) {\n+                            stack.add(HighlightedRange {\n+                                range: piece_range + range.start(),\n+                                highlight: highlight.into(),\n+                                binding_hash: None,\n+                            });\n+                        }\n+                    });\n+                }\n+                stack.pop();\n+            } else if let Some(string) =\n+                element_to_highlight.as_token().cloned().and_then(ast::RawString::cast)\n+            {\n+                stack.push();\n+                if is_format_string {\n+                    string.lex_format_specifier(|piece_range, kind| {\n+                        if let Some(highlight) = highlight_format_specifier(kind) {\n+                            stack.add(HighlightedRange {\n+                                range: piece_range + range.start(),\n+                                highlight: highlight.into(),\n+                                binding_hash: None,\n+                            });\n+                        }\n                     });\n                 }\n                 stack.pop();\n@@ -277,6 +278,24 @@ pub(crate) fn highlight(\n     stack.flattened()\n }\n \n+fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n+    Some(match kind {\n+        FormatSpecifier::Open\n+        | FormatSpecifier::Close\n+        | FormatSpecifier::Colon\n+        | FormatSpecifier::Fill\n+        | FormatSpecifier::Align\n+        | FormatSpecifier::Sign\n+        | FormatSpecifier::NumberSign\n+        | FormatSpecifier::DollarSign\n+        | FormatSpecifier::Dot\n+        | FormatSpecifier::Asterisk\n+        | FormatSpecifier::QuestionMark => HighlightTag::Attribute,\n+        FormatSpecifier::Integer | FormatSpecifier::Zero => HighlightTag::NumericLiteral,\n+        FormatSpecifier::Identifier => HighlightTag::Local,\n+    })\n+}\n+\n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n     let path = macro_call.path()?;\n     let name_ref = path.segment()?.name_ref()?;"}, {"sha": "a9aae957f0134022c3aa6f75cd36705e246c0e88", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/445052f6d426043b543033f3fa4594fc1a09d7fa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445052f6d426043b543033f3fa4594fc1a09d7fa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=445052f6d426043b543033f3fa4594fc1a09d7fa", "patch": "@@ -223,6 +223,11 @@ fn main() {\n     println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n     println!(\"Hello {{}}\");\n     println!(\"{{ Hello\");\n+\n+    println!(r\"Hello, {}!\", \"world\");\n+\n+    println!(\"{\\x41}\", A = 92);\n+    println!(\"{\u043d\u0438\u0447\u043e\u0441\u0438}\", \u043d\u0438\u0447\u043e\u0441\u0438 = 92);\n }\"#\n         .trim(),\n     );"}, {"sha": "aa34b682d92ed75534427fcadc074c340d1f10be", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 158, "deletions": 122, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/445052f6d426043b543033f3fa4594fc1a09d7fa/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445052f6d426043b543033f3fa4594fc1a09d7fa/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=445052f6d426043b543033f3fa4594fc1a09d7fa", "patch": "@@ -192,68 +192,76 @@ pub enum FormatSpecifier {\n }\n \n pub trait HasFormatSpecifier: AstToken {\n+    fn char_ranges(\n+        &self,\n+    ) -> Option<Vec<(TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>>;\n+\n     fn lex_format_specifier<F>(&self, mut callback: F)\n     where\n         F: FnMut(TextRange, FormatSpecifier),\n     {\n-        let src = self.text().as_str();\n-        let initial_len = src.len();\n-        let mut chars = src.chars();\n+        let char_ranges = if let Some(char_ranges) = self.char_ranges() {\n+            char_ranges\n+        } else {\n+            return;\n+        };\n+        let mut chars = char_ranges.iter().peekable();\n \n-        while let Some(first_char) = chars.next() {\n+        while let Some((range, first_char)) = chars.next() {\n             match first_char {\n-                '{' => {\n+                Ok('{') => {\n                     // Format specifier, see syntax at https://doc.rust-lang.org/std/fmt/index.html#syntax\n-                    if chars.clone().next() == Some('{') {\n+                    if let Some((_, Ok('{'))) = chars.peek() {\n                         // Escaped format specifier, `{{`\n                         chars.next();\n                         continue;\n                     }\n \n-                    let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n-                    let end = initial_len - chars.as_str().len();\n-                    callback(\n-                        TextRange::from_to(TextUnit::from_usize(start), TextUnit::from_usize(end)),\n-                        FormatSpecifier::Open,\n-                    );\n+                    callback(*range, FormatSpecifier::Open);\n \n                     // check for integer/identifier\n-                    match chars.clone().next().unwrap_or_default() {\n+                    match chars\n+                        .peek()\n+                        .and_then(|next| next.1.as_ref().ok())\n+                        .copied()\n+                        .unwrap_or_default()\n+                    {\n                         '0'..='9' => {\n                             // integer\n-                            read_integer(&mut chars, initial_len, &mut callback);\n+                            read_integer(&mut chars, &mut callback);\n                         }\n-                        'a'..='z' | 'A'..='Z' | '_' => {\n+                        c if c == '_' || c.is_alphabetic() => {\n                             // identifier\n-                            read_identifier(&mut chars, initial_len, &mut callback);\n+                            read_identifier(&mut chars, &mut callback);\n                         }\n                         _ => {}\n                     }\n \n-                    if chars.clone().next() == Some(':') {\n-                        skip_char_and_emit(\n-                            &mut chars,\n-                            initial_len,\n-                            FormatSpecifier::Colon,\n-                            &mut callback,\n-                        );\n+                    if let Some((_, Ok(':'))) = chars.peek() {\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::Colon, &mut callback);\n \n                         // check for fill/align\n                         let mut cloned = chars.clone().take(2);\n-                        let first = cloned.next().unwrap_or_default();\n-                        let second = cloned.next().unwrap_or_default();\n+                        let first = cloned\n+                            .next()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default();\n+                        let second = cloned\n+                            .next()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default();\n                         match second {\n                             '<' | '^' | '>' => {\n                                 // alignment specifier, first char specifies fillment\n                                 skip_char_and_emit(\n                                     &mut chars,\n-                                    initial_len,\n                                     FormatSpecifier::Fill,\n                                     &mut callback,\n                                 );\n                                 skip_char_and_emit(\n                                     &mut chars,\n-                                    initial_len,\n                                     FormatSpecifier::Align,\n                                     &mut callback,\n                                 );\n@@ -262,7 +270,6 @@ pub trait HasFormatSpecifier: AstToken {\n                                 '<' | '^' | '>' => {\n                                     skip_char_and_emit(\n                                         &mut chars,\n-                                        initial_len,\n                                         FormatSpecifier::Align,\n                                         &mut callback,\n                                     );\n@@ -272,11 +279,15 @@ pub trait HasFormatSpecifier: AstToken {\n                         }\n \n                         // check for sign\n-                        match chars.clone().next().unwrap_or_default() {\n+                        match chars\n+                            .peek()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default()\n+                        {\n                             '+' | '-' => {\n                                 skip_char_and_emit(\n                                     &mut chars,\n-                                    initial_len,\n                                     FormatSpecifier::Sign,\n                                     &mut callback,\n                                 );\n@@ -285,50 +296,49 @@ pub trait HasFormatSpecifier: AstToken {\n                         }\n \n                         // check for `#`\n-                        if let Some('#') = chars.clone().next() {\n+                        if let Some((_, Ok('#'))) = chars.peek() {\n                             skip_char_and_emit(\n                                 &mut chars,\n-                                initial_len,\n                                 FormatSpecifier::NumberSign,\n                                 &mut callback,\n                             );\n                         }\n \n                         // check for `0`\n                         let mut cloned = chars.clone().take(2);\n-                        let first = cloned.next();\n-                        let second = cloned.next();\n+                        let first = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n+                        let second = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n \n                         if first == Some('0') && second != Some('$') {\n-                            skip_char_and_emit(\n-                                &mut chars,\n-                                initial_len,\n-                                FormatSpecifier::Zero,\n-                                &mut callback,\n-                            );\n+                            skip_char_and_emit(&mut chars, FormatSpecifier::Zero, &mut callback);\n                         }\n \n                         // width\n-                        match chars.clone().next().unwrap_or_default() {\n+                        match chars\n+                            .peek()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default()\n+                        {\n                             '0'..='9' => {\n-                                read_integer(&mut chars, initial_len, &mut callback);\n-                                if chars.clone().next() == Some('$') {\n+                                read_integer(&mut chars, &mut callback);\n+                                if let Some((_, Ok('$'))) = chars.peek() {\n                                     skip_char_and_emit(\n                                         &mut chars,\n-                                        initial_len,\n                                         FormatSpecifier::DollarSign,\n                                         &mut callback,\n                                     );\n                                 }\n                             }\n-                            'a'..='z' | 'A'..='Z' | '_' => {\n-                                read_identifier(&mut chars, initial_len, &mut callback);\n-                                if chars.clone().next() != Some('$') {\n+                            c if c == '_' || c.is_alphabetic() => {\n+                                read_identifier(&mut chars, &mut callback);\n+                                if chars.peek().and_then(|next| next.1.as_ref().ok()).copied()\n+                                    != Some('$')\n+                                {\n                                     continue;\n                                 }\n                                 skip_char_and_emit(\n                                     &mut chars,\n-                                    initial_len,\n                                     FormatSpecifier::DollarSign,\n                                     &mut callback,\n                                 );\n@@ -337,42 +347,41 @@ pub trait HasFormatSpecifier: AstToken {\n                         }\n \n                         // precision\n-                        if chars.clone().next() == Some('.') {\n-                            skip_char_and_emit(\n-                                &mut chars,\n-                                initial_len,\n-                                FormatSpecifier::Dot,\n-                                &mut callback,\n-                            );\n-\n-                            match chars.clone().next().unwrap_or_default() {\n+                        if let Some((_, Ok('.'))) = chars.peek() {\n+                            skip_char_and_emit(&mut chars, FormatSpecifier::Dot, &mut callback);\n+\n+                            match chars\n+                                .peek()\n+                                .and_then(|next| next.1.as_ref().ok())\n+                                .copied()\n+                                .unwrap_or_default()\n+                            {\n                                 '*' => {\n                                     skip_char_and_emit(\n                                         &mut chars,\n-                                        initial_len,\n                                         FormatSpecifier::Asterisk,\n                                         &mut callback,\n                                     );\n                                 }\n                                 '0'..='9' => {\n-                                    read_integer(&mut chars, initial_len, &mut callback);\n-                                    if chars.clone().next() == Some('$') {\n+                                    read_integer(&mut chars, &mut callback);\n+                                    if let Some((_, Ok('$'))) = chars.peek() {\n                                         skip_char_and_emit(\n                                             &mut chars,\n-                                            initial_len,\n                                             FormatSpecifier::DollarSign,\n                                             &mut callback,\n                                         );\n                                     }\n                                 }\n-                                'a'..='z' | 'A'..='Z' | '_' => {\n-                                    read_identifier(&mut chars, initial_len, &mut callback);\n-                                    if chars.clone().next() != Some('$') {\n+                                c if c == '_' || c.is_alphabetic() => {\n+                                    read_identifier(&mut chars, &mut callback);\n+                                    if chars.peek().and_then(|next| next.1.as_ref().ok()).copied()\n+                                        != Some('$')\n+                                    {\n                                         continue;\n                                     }\n                                     skip_char_and_emit(\n                                         &mut chars,\n-                                        initial_len,\n                                         FormatSpecifier::DollarSign,\n                                         &mut callback,\n                                     );\n@@ -384,41 +393,40 @@ pub trait HasFormatSpecifier: AstToken {\n                         }\n \n                         // type\n-                        match chars.clone().next().unwrap_or_default() {\n+                        match chars\n+                            .peek()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default()\n+                        {\n                             '?' => {\n                                 skip_char_and_emit(\n                                     &mut chars,\n-                                    initial_len,\n                                     FormatSpecifier::QuestionMark,\n                                     &mut callback,\n                                 );\n                             }\n-                            'a'..='z' | 'A'..='Z' | '_' => {\n-                                read_identifier(&mut chars, initial_len, &mut callback);\n+                            c if c == '_' || c.is_alphabetic() => {\n+                                read_identifier(&mut chars, &mut callback);\n                             }\n                             _ => {}\n                         }\n                     }\n \n                     let mut cloned = chars.clone().take(2);\n-                    let first = cloned.next();\n-                    let second = cloned.next();\n+                    let first = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n+                    let second = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n                     if first != Some('}') {\n                         continue;\n                     }\n                     if second == Some('}') {\n                         // Escaped format end specifier, `}}`\n                         continue;\n                     }\n-                    skip_char_and_emit(\n-                        &mut chars,\n-                        initial_len,\n-                        FormatSpecifier::Close,\n-                        &mut callback,\n-                    );\n+                    skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n                 }\n                 _ => {\n-                    while let Some(next_char) = chars.clone().next() {\n+                    while let Some((_, Ok(next_char))) = chars.peek() {\n                         match next_char {\n                             '{' => break,\n                             _ => {}\n@@ -429,69 +437,97 @@ pub trait HasFormatSpecifier: AstToken {\n             };\n         }\n \n-        fn skip_char_and_emit<F>(\n-            chars: &mut std::str::Chars,\n-            initial_len: usize,\n+        fn skip_char_and_emit<'a, I, F>(\n+            chars: &mut std::iter::Peekable<I>,\n             emit: FormatSpecifier,\n             callback: &mut F,\n         ) where\n+            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n             F: FnMut(TextRange, FormatSpecifier),\n         {\n-            let start = initial_len - chars.as_str().len();\n-            chars.next();\n-            let end = initial_len - chars.as_str().len();\n-            callback(\n-                TextRange::from_to(TextUnit::from_usize(start), TextUnit::from_usize(end)),\n-                emit,\n-            );\n+            let (range, _) = chars.next().unwrap();\n+            callback(*range, emit);\n         }\n \n-        fn read_integer<F>(chars: &mut std::str::Chars, initial_len: usize, callback: &mut F)\n+        fn read_integer<'a, I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n         where\n+            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n             F: FnMut(TextRange, FormatSpecifier),\n         {\n-            let start = initial_len - chars.as_str().len();\n-            chars.next();\n-            while let Some(next_char) = chars.clone().next() {\n-                match next_char {\n-                    '0'..='9' => {\n-                        chars.next();\n-                    }\n-                    _ => {\n-                        break;\n-                    }\n+            let (mut range, c) = chars.next().unwrap();\n+            assert!(c.as_ref().unwrap().is_ascii_digit());\n+            while let Some((r, Ok(next_char))) = chars.peek() {\n+                if next_char.is_ascii_digit() {\n+                    chars.next();\n+                    range = range.extend_to(r);\n+                } else {\n+                    break;\n                 }\n             }\n-            let end = initial_len - chars.as_str().len();\n-            callback(\n-                TextRange::from_to(TextUnit::from_usize(start), TextUnit::from_usize(end)),\n-                FormatSpecifier::Integer,\n-            );\n+            callback(range, FormatSpecifier::Integer);\n         }\n-        fn read_identifier<F>(chars: &mut std::str::Chars, initial_len: usize, callback: &mut F)\n+\n+        fn read_identifier<'a, I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n         where\n+            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n             F: FnMut(TextRange, FormatSpecifier),\n         {\n-            let start = initial_len - chars.as_str().len();\n-            chars.next();\n-            while let Some(next_char) = chars.clone().next() {\n-                match next_char {\n-                    'a'..='z' | 'A'..='Z' | '0'..='9' | '_' => {\n-                        chars.next();\n-                    }\n-                    _ => {\n-                        break;\n-                    }\n+            let (mut range, c) = chars.next().unwrap();\n+            assert!(c.as_ref().unwrap().is_alphabetic() || *c.as_ref().unwrap() == '_');\n+            while let Some((r, Ok(next_char))) = chars.peek() {\n+                if *next_char == '_' || next_char.is_ascii_digit() || next_char.is_alphabetic() {\n+                    chars.next();\n+                    range = range.extend_to(r);\n+                } else {\n+                    break;\n                 }\n             }\n-            let end = initial_len - chars.as_str().len();\n-            callback(\n-                TextRange::from_to(TextUnit::from_usize(start), TextUnit::from_usize(end)),\n-                FormatSpecifier::Identifier,\n-            );\n+            callback(range, FormatSpecifier::Identifier);\n         }\n     }\n }\n \n-impl HasFormatSpecifier for String {}\n-impl HasFormatSpecifier for RawString {}\n+impl HasFormatSpecifier for String {\n+    fn char_ranges(\n+        &self,\n+    ) -> Option<Vec<(TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>> {\n+        let text = self.text().as_str();\n+        let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n+        let offset = self.text_range_between_quotes()?.start() - self.syntax().text_range().start();\n+\n+        let mut res = Vec::with_capacity(text.len());\n+        rustc_lexer::unescape::unescape_str(text, &mut |range, unescaped_char| {\n+            res.push((\n+                TextRange::from_to(\n+                    TextUnit::from_usize(range.start),\n+                    TextUnit::from_usize(range.end),\n+                ) + offset,\n+                unescaped_char,\n+            ))\n+        });\n+\n+        Some(res)\n+    }\n+}\n+\n+impl HasFormatSpecifier for RawString {\n+    fn char_ranges(\n+        &self,\n+    ) -> Option<Vec<(TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>> {\n+        let text = self.text().as_str();\n+        let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n+        let offset = self.text_range_between_quotes()?.start() - self.syntax().text_range().start();\n+\n+        let mut res = Vec::with_capacity(text.len());\n+        for (idx, c) in text.char_indices() {\n+            res.push((\n+                TextRange::from_to(\n+                    TextUnit::from_usize(idx),\n+                    TextUnit::from_usize(idx + c.len_utf8()),\n+                ) + offset,\n+                Ok(c),\n+            ));\n+        }\n+        Some(res)\n+    }\n+}"}]}