{"sha": "90754ae9c95c18841c0200d77da917af5ecde5ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNzU0YWU5Yzk1YzE4ODQxYzAyMDBkNzdkYTkxN2FmNWVjZGU1ZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-15T06:01:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-15T06:01:26Z"}, "message": "auto merge of #10478 : TeXitoi/rust/shootout-meteor, r=brson\n\nThis implementation of the meteor contest implements:\r\n - insertion check with bit trick;\r\n - pregenetation of every feasible placement of the pieces on the\r\n   board;\r\n - filtering of placement that implies unfeasible board\r\n - central symetry breaking\r\n\r\nrelated to #2776", "tree": {"sha": "181023f45bcda348968dc8acf1783b534cbb72d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/181023f45bcda348968dc8acf1783b534cbb72d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90754ae9c95c18841c0200d77da917af5ecde5ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90754ae9c95c18841c0200d77da917af5ecde5ee", "html_url": "https://github.com/rust-lang/rust/commit/90754ae9c95c18841c0200d77da917af5ecde5ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90754ae9c95c18841c0200d77da917af5ecde5ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43f6791e75c4545348f3ee882dbfb43f1c921c18", "url": "https://api.github.com/repos/rust-lang/rust/commits/43f6791e75c4545348f3ee882dbfb43f1c921c18", "html_url": "https://github.com/rust-lang/rust/commit/43f6791e75c4545348f3ee882dbfb43f1c921c18"}, {"sha": "d2bcc7b621b791f4abe7000a99816209a8ea7a45", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bcc7b621b791f4abe7000a99816209a8ea7a45", "html_url": "https://github.com/rust-lang/rust/commit/d2bcc7b621b791f4abe7000a99816209a8ea7a45"}], "stats": {"total": 281, "additions": 281, "deletions": 0}, "files": [{"sha": "78b31b335c93d63d03f536c1796e5ea7042c3024", "filename": "src/test/bench/shootout-meteor.rs", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/90754ae9c95c18841c0200d77da917af5ecde5ee/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90754ae9c95c18841c0200d77da917af5ecde5ee/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=90754ae9c95c18841c0200d77da917af5ecde5ee", "patch": "@@ -0,0 +1,281 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//\n+// Utilities.\n+//\n+\n+// returns an infinite iterator of repeated applications of f to x,\n+// i.e. [x, f(x), f(f(x)), ...], as haskell iterate function.\n+fn iterate<'a, T>(x: T, f: &'a fn(&T) -> T) -> Iterate<'a, T> {\n+    Iterate {f: f, next: x}\n+}\n+struct Iterate<'self, T> {\n+    priv f: &'self fn(&T) -> T,\n+    priv next: T\n+}\n+impl<'self, T> Iterator<T> for Iterate<'self, T> {\n+    fn next(&mut self) -> Option<T> {\n+        let mut res = (self.f)(&self.next);\n+        std::util::swap(&mut res, &mut self.next);\n+        Some(res)\n+    }\n+}\n+\n+// a linked list using borrowed next.\n+enum List<'self, T> {\n+    Nil,\n+    Cons(T, &'self List<'self, T>)\n+}\n+struct ListIterator<'self, T> {\n+    priv cur: &'self List<'self, T>\n+}\n+impl<'self, T> List<'self, T> {\n+    fn iter(&'self self) -> ListIterator<'self, T> {\n+        ListIterator{cur: self}\n+    }\n+}\n+impl<'self, T> Iterator<&'self T> for ListIterator<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        match *self.cur {\n+            Nil => None,\n+            Cons(ref elt, next) => {\n+                self.cur = next;\n+                Some(elt)\n+            }\n+        }\n+    }\n+}\n+\n+//\n+// preprocess\n+//\n+\n+// Takes a pieces p on the form [(y1, x1), (y2, x2), ...] and returns\n+// every possible transformations (the 6 rotations with their\n+// corresponding mirrored piece), with, as minimum coordinates, (0,\n+// 0).  If all is false, only generate half of the possibilities (used\n+// to break the symetry of the board).\n+fn transform(piece: ~[(int, int)], all: bool) -> ~[~[(int, int)]] {\n+    let mut res =\n+        // rotations\n+        iterate(piece, |rot| rot.iter().map(|&(y, x)| (x + y, -y)).collect())\n+        .take(if all {6} else {3})\n+        // mirror\n+        .flat_map(|cur_piece| {\n+            iterate(cur_piece, |mir| mir.iter().map(|&(y, x)| (x, y)).collect())\n+            .take(2)\n+        }).to_owned_vec();\n+\n+    // translating to (0, 0) as minimum coordinates.\n+    for cur_piece in res.mut_iter() {\n+        let (dy, dx) = *cur_piece.iter().min_by(|e| *e).unwrap();\n+        for &(ref mut y, ref mut x) in cur_piece.mut_iter() {\n+            *y -= dy; *x -= dx;\n+        }\n+    }\n+\n+    res\n+}\n+\n+// A mask is a piece somewere on the board.  It is represented as a\n+// u64: for i in the first 50 bits, m[i] = 1 if the cell at (i/5, i%5)\n+// is occuped.  m[50 + id] = 1 if the identifier of the piece is id.\n+\n+// Takes a piece with minimum coordinate (0, 0) (as generated by\n+// transform).  Returns the corresponding mask if p translated by (dy,\n+// dx) is on the board.\n+fn mask(dy: int, dx: int, id: uint, p: &[(int, int)]) -> Option<u64> {\n+    let mut m = 1 << (50 + id);\n+    for &(y, x) in p.iter() {\n+        let x = x + dx + (y + (dy % 2)) / 2;\n+        if x < 0 || x > 4 {return None;}\n+        let y = y + dy;\n+        if y < 0 || y > 9 {return None;}\n+        m |= 1 << (y * 5 + x);\n+    }\n+    Some(m)\n+}\n+\n+// Makes every possible masks.  masks[id][i] correspond to every\n+// possible masks for piece with identifier id with minimum coordinate\n+// (i/5, i%5).\n+fn make_masks() -> ~[~[~[u64]]] {\n+    let pieces = ~[\n+        ~[(0,0),(0,1),(0,2),(0,3),(1,3)],\n+        ~[(0,0),(0,2),(0,3),(1,0),(1,1)],\n+        ~[(0,0),(0,1),(0,2),(1,2),(2,1)],\n+        ~[(0,0),(0,1),(0,2),(1,1),(2,1)],\n+        ~[(0,0),(0,2),(1,0),(1,1),(2,1)],\n+        ~[(0,0),(0,1),(0,2),(1,1),(1,2)],\n+        ~[(0,0),(0,1),(1,1),(1,2),(2,1)],\n+        ~[(0,0),(0,1),(0,2),(1,0),(1,2)],\n+        ~[(0,0),(0,1),(0,2),(1,2),(1,3)],\n+        ~[(0,0),(0,1),(0,2),(0,3),(1,2)]];\n+    let mut res = ~[];\n+    for (id, p) in pieces.move_iter().enumerate() {\n+        // To break the central symetry of the problem, every\n+        // transformation must be taken except for one piece (piece 3\n+        // here).\n+        let trans = transform(p, id != 3);\n+        let mut cur_piece = ~[];\n+        for dy in range(0, 10) {\n+            for dx in range(0, 5) {\n+                let masks = \n+                    trans.iter()\n+                    .filter_map(|t| mask(dy, dx, id, *t))\n+                    .collect();\n+                cur_piece.push(masks);\n+            }\n+        }\n+        res.push(cur_piece);\n+    }\n+    res\n+}\n+\n+// Check if all coordinates can be covered by an unused piece and that\n+// all unused piece can be placed on the board.\n+fn is_board_unfeasible(board: u64, masks: &[~[~[u64]]]) -> bool {\n+    let mut coverable = board;\n+    for i in range(0, 50).filter(|&i| board & 1 << i == 0) {\n+        for (cur_id, pos_masks) in masks.iter().enumerate() {\n+            if board & 1 << (50 + cur_id) != 0 {continue;}\n+            for &cur_m in pos_masks[i].iter() {\n+                if cur_m & board == 0 {coverable |= cur_m;}\n+            }\n+        }\n+        if coverable & (1 << i) == 0 {return true;}\n+    }\n+    // check if every coordinates can be covered and every piece can\n+    // be used.\n+    coverable != (1 << 60) - 1\n+}\n+\n+// Filter the masks that we can prove to result to unfeasible board.\n+fn filter_masks(masks: &[~[~[u64]]]) -> ~[~[~[u64]]] {\n+    masks.iter().map(\n+        |p| p.iter().map(\n+            |p| p.iter()\n+                .map(|&m| m)\n+                .filter(|&m| !is_board_unfeasible(m, masks))\n+                .collect())\n+            .collect())\n+        .collect()\n+}\n+\n+// Gets the identifier of a mask.\n+fn get_id(m: u64) -> u8 {\n+    for id in range(0, 10) {\n+        if m & (1 << (id + 50)) != 0 {return id as u8;}\n+    }\n+    fail!(\"{:016x} does not have a valid identifier\", m);\n+}\n+\n+// Converts a list of mask to a ~str.\n+fn to_utf8(raw_sol: &List<u64>) -> ~str {\n+    let mut sol: ~[u8] = std::vec::from_elem(50, '.' as u8);\n+    for &m in raw_sol.iter() {\n+        let id = get_id(m);\n+        for i in range(0, 50) {\n+            if m & 1 << i != 0 {sol[i] = '0' as u8 + id;}\n+        }\n+    }\n+    std::str::from_utf8_owned(sol)\n+}\n+\n+// Prints a solution in ~str form.\n+fn print_sol(sol: &str) {\n+    for (i, c) in sol.iter().enumerate() {\n+        if (i) % 5 == 0 {println(\"\");}\n+        if (i + 5) % 10 == 0 {print(\" \");}\n+        print!(\"{} \", c);\n+    }\n+    println(\"\");\n+}\n+\n+// The data managed during the search\n+struct Data {\n+    // If more than stop_after is found, stop the search.\n+    stop_after: int,\n+    // Number of solution found.\n+    nb: int,\n+    // Lexicographically minimal solution found.\n+    min: ~str,\n+    // Lexicographically maximal solution found.\n+    max: ~str\n+}\n+\n+// Records a new found solution.  Returns false if the search must be\n+// stopped.\n+fn handle_sol(raw_sol: &List<u64>, data: &mut Data) -> bool {\n+    // because we break the symetry, 2 solutions correspond to a call\n+    // to this method: the normal solution, and the same solution in\n+    // reverse order, i.e. the board rotated by half a turn.\n+    data.nb += 2;\n+    let sol1 = to_utf8(raw_sol);\n+    let sol2: ~str = sol1.iter().invert().collect();\n+\n+    if data.nb == 2 {\n+        data.min = sol1.clone();\n+        data.max = sol1.clone();\n+    }\n+\n+    if sol1 < data.min {data.min = sol1.clone();}\n+    if sol2 < data.min {data.min = sol2.clone();}\n+    if sol1 > data.max {data.max = sol1;}\n+    if sol2 > data.max {data.max = sol2;}\n+    data.nb < data.stop_after\n+}\n+\n+// Search for every solutions.  Returns false if the search was\n+// stopped before the end.\n+fn search(\n+    masks: &[~[~[u64]]],\n+    board: u64,\n+    mut i: int,\n+    cur: List<u64>,\n+    data: &mut Data)\n+    -> bool\n+{\n+    // Search for the lesser empty coordinate.\n+    while board & (1 << i)  != 0 && i < 50 {i += 1;}\n+    // the board is full: a solution is found.\n+    if i >= 50 {return handle_sol(&cur, data);}\n+\n+    // for every unused piece\n+    for id in range(0, 10).filter(|id| board & (1 << (id + 50)) == 0) {\n+        // for each mask that fits on the board\n+        for &m in masks[id][i].iter().filter(|&m| board & *m == 0) {\n+            // This check is too costy.\n+            //if is_board_unfeasible(board | m, masks) {continue;}\n+            if !search(masks, board | m, i + 1, Cons(m, &cur), data) {\n+                return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n+fn main () {\n+    let args = std::os::args();\n+    let stop_after = if args.len() <= 1 {\n+        2098\n+    } else {\n+        from_str(args[1]).unwrap()\n+    };\n+    let masks = make_masks();\n+    let masks = filter_masks(masks);\n+    let mut data = Data {stop_after: stop_after, nb: 0, min: ~\"\", max: ~\"\"};\n+    search(masks, 0, 0, Nil, &mut data);\n+    println!(\"{} solutions found\", data.nb);\n+    print_sol(data.min);\n+    print_sol(data.max);\n+    println(\"\");\n+}"}]}