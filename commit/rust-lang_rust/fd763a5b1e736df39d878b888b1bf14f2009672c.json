{"sha": "fd763a5b1e736df39d878b888b1bf14f2009672c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNzYzYTViMWU3MzZkZjM5ZDg3OGI4ODhiMWJmMTRmMjAwOTY3MmM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-15T19:42:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-08-25T00:08:14Z"}, "message": "native: clone/close_accept for win32 pipes\n\nThis commits takes a similar strategy to the previous commit to implement\nclose_accept and clone for the native win32 pipes implementation.\n\nCloses #15595", "tree": {"sha": "5bcae6049440cb543eec5ae46f0d7f7d7491bc60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bcae6049440cb543eec5ae46f0d7f7d7491bc60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd763a5b1e736df39d878b888b1bf14f2009672c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd763a5b1e736df39d878b888b1bf14f2009672c", "html_url": "https://github.com/rust-lang/rust/commit/fd763a5b1e736df39d878b888b1bf14f2009672c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd763a5b1e736df39d878b888b1bf14f2009672c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c301db20a40d63ee330956a97102c3e566475f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/c301db20a40d63ee330956a97102c3e566475f75", "html_url": "https://github.com/rust-lang/rust/commit/c301db20a40d63ee330956a97102c3e566475f75"}], "stats": {"total": 165, "additions": 117, "deletions": 48}, "files": [{"sha": "909b37895b7b5495036f46c027fa8ca0d8a7ccc8", "filename": "src/libnative/io/c_windows.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Fc_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Fc_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_windows.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -115,6 +115,12 @@ extern \"system\" {\n                       optval: *mut libc::c_char,\n                       optlen: *mut libc::c_int) -> libc::c_int;\n \n+    pub fn SetEvent(hEvent: libc::HANDLE) -> libc::BOOL;\n+    pub fn WaitForMultipleObjects(nCount: libc::DWORD,\n+                                  lpHandles: *const libc::HANDLE,\n+                                  bWaitAll: libc::BOOL,\n+                                  dwMilliseconds: libc::DWORD) -> libc::DWORD;\n+\n     pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;\n     pub fn CancelIoEx(hFile: libc::HANDLE,\n                       lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;"}, {"sha": "368b5914444ac9509f12fca2e28f23258b674cca", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -15,7 +15,7 @@ use std::ptr;\n use std::rt::mutex;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n-use std::sync::atomics;\n+use std::sync::atomic;\n \n use super::{retry, keep_going};\n use super::c;\n@@ -456,7 +456,7 @@ impl TcpListener {\n                         listener: self,\n                         reader: reader,\n                         writer: writer,\n-                        closed: atomics::AtomicBool::new(false),\n+                        closed: atomic::AtomicBool::new(false),\n                     }),\n                     deadline: 0,\n                 })\n@@ -476,7 +476,7 @@ impl TcpListener {\n                         listener: self,\n                         abort: try!(os::Event::new()),\n                         accept: accept,\n-                        closed: atomics::AtomicBool::new(false),\n+                        closed: atomic::AtomicBool::new(false),\n                     }),\n                     deadline: 0,\n                 })\n@@ -510,15 +510,15 @@ struct AcceptorInner {\n     listener: TcpListener,\n     reader: FileDesc,\n     writer: FileDesc,\n-    closed: atomics::AtomicBool,\n+    closed: atomic::AtomicBool,\n }\n \n #[cfg(windows)]\n struct AcceptorInner {\n     listener: TcpListener,\n     abort: os::Event,\n     accept: os::Event,\n-    closed: atomics::AtomicBool,\n+    closed: atomic::AtomicBool,\n }\n \n impl TcpAcceptor {\n@@ -542,7 +542,7 @@ impl TcpAcceptor {\n         // self-pipe is never written to unless close_accept() is called.\n         let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n \n-        while !self.inner.closed.load(atomics::SeqCst) {\n+        while !self.inner.closed.load(atomic::SeqCst) {\n             match retry(|| unsafe {\n                 libc::accept(self.fd(), ptr::mut_null(), ptr::mut_null())\n             }) {\n@@ -581,12 +581,12 @@ impl TcpAcceptor {\n         // stolen, so we do all of this in a loop as well.\n         let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n \n-        while !self.inner.closed.load(atomics::SeqCst) {\n+        while !self.inner.closed.load(atomic::SeqCst) {\n             let ms = if self.deadline == 0 {\n                 c::WSA_INFINITE as u64\n             } else {\n                 let now = ::io::timer::now();\n-                if self.deadline < now {0} else {now - self.deadline}\n+                if self.deadline < now {0} else {self.deadline - now}\n             };\n             let ret = unsafe {\n                 c::WSAWaitForMultipleEvents(2, events.as_ptr(), libc::FALSE,\n@@ -600,7 +600,6 @@ impl TcpAcceptor {\n                 c::WSA_WAIT_EVENT_0 => break,\n                 n => assert_eq!(n, c::WSA_WAIT_EVENT_0 + 1),\n             }\n-            println!(\"woke up\");\n \n             let mut wsaevents: c::WSANETWORKEVENTS = unsafe { mem::zeroed() };\n             let ret = unsafe {\n@@ -614,7 +613,19 @@ impl TcpAcceptor {\n             } {\n                 -1 if util::wouldblock() => {}\n                 -1 => return Err(os::last_error()),\n-                fd => return Ok(TcpStream::new(Inner::new(fd))),\n+\n+                // Accepted sockets inherit the same properties as the caller,\n+                // so we need to deregister our event and switch the socket back\n+                // to blocking mode\n+                fd => {\n+                    let stream = TcpStream::new(Inner::new(fd));\n+                    let ret = unsafe {\n+                        c::WSAEventSelect(fd, events[1], 0)\n+                    };\n+                    if ret != 0 { return Err(os::last_error()) }\n+                    try!(util::set_nonblocking(fd, false));\n+                    return Ok(stream)\n+                }\n             }\n         }\n \n@@ -648,7 +659,7 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n \n     #[cfg(unix)]\n     fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomics::SeqCst);\n+        self.inner.closed.store(true, atomic::SeqCst);\n         let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n         match fd.inner_write([0]) {\n             Ok(..) => Ok(()),\n@@ -659,7 +670,7 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n \n     #[cfg(windows)]\n     fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomics::SeqCst);\n+        self.inner.closed.store(true, atomic::SeqCst);\n         let ret = unsafe { c::WSASetEvent(self.inner.abort.handle()) };\n         if ret == libc::TRUE {\n             Ok(())"}, {"sha": "a3564dfe2cc9a5905cdc9b6464787a0f8102e5da", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -15,7 +15,7 @@ use std::mem;\n use std::rt::mutex;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n-use std::sync::atomics;\n+use std::sync::atomic;\n \n use super::retry;\n use super::net;\n@@ -239,7 +239,7 @@ impl UnixListener {\n                         listener: self,\n                         reader: reader,\n                         writer: writer,\n-                        closed: atomics::AtomicBool::new(false),\n+                        closed: atomic::AtomicBool::new(false),\n                     }),\n                     deadline: 0,\n                 })\n@@ -267,7 +267,7 @@ struct AcceptorInner {\n     listener: UnixListener,\n     reader: FileDesc,\n     writer: FileDesc,\n-    closed: atomics::AtomicBool,\n+    closed: atomic::AtomicBool,\n }\n \n impl UnixAcceptor {\n@@ -276,7 +276,7 @@ impl UnixAcceptor {\n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n         let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n \n-        while !self.inner.closed.load(atomics::SeqCst) {\n+        while !self.inner.closed.load(atomic::SeqCst) {\n             unsafe {\n                 let mut storage: libc::sockaddr_storage = mem::zeroed();\n                 let storagep = &mut storage as *mut libc::sockaddr_storage;\n@@ -317,7 +317,7 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n \n     #[cfg(unix)]\n     fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomics::SeqCst);\n+        self.inner.closed.store(true, atomic::SeqCst);\n         let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n         match fd.inner_write([0]) {\n             Ok(..) => Ok(()),"}, {"sha": "95afa11f4a9a0c8f72712d1524dc2678a2a41089", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 71, "deletions": 23, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -169,23 +169,30 @@ unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE {\n }\n \n pub fn await(handle: libc::HANDLE, deadline: u64,\n-             overlapped: &mut libc::OVERLAPPED) -> bool {\n-    if deadline == 0 { return true }\n+             events: &[libc::HANDLE]) -> IoResult<uint> {\n+    use libc::consts::os::extra::{WAIT_FAILED, WAIT_TIMEOUT, WAIT_OBJECT_0};\n \n     // If we've got a timeout, use WaitForSingleObject in tandem with CancelIo\n     // to figure out if we should indeed get the result.\n-    let now = ::io::timer::now();\n-    let timeout = deadline < now || unsafe {\n-        let ms = (deadline - now) as libc::DWORD;\n-        let r = libc::WaitForSingleObject(overlapped.hEvent,\n-                                          ms);\n-        r != libc::WAIT_OBJECT_0\n-    };\n-    if timeout {\n-        unsafe { let _ = c::CancelIo(handle); }\n-        false\n+    let ms = if deadline == 0 {\n+        libc::INFINITE as u64\n     } else {\n-        true\n+        let now = ::io::timer::now();\n+        if deadline < now {0} else {deadline - now}\n+    };\n+    let ret = unsafe {\n+        c::WaitForMultipleObjects(events.len() as libc::DWORD,\n+                                  events.as_ptr(),\n+                                  libc::FALSE,\n+                                  ms as libc::DWORD)\n+    };\n+    match ret {\n+        WAIT_FAILED => Err(super::last_error()),\n+        WAIT_TIMEOUT => unsafe {\n+            let _ = c::CancelIo(handle);\n+            Err(util::timeout(\"operation timed out\"))\n+        },\n+        n => Ok((n - WAIT_OBJECT_0) as uint)\n     }\n }\n \n@@ -390,8 +397,8 @@ impl rtio::RtioPipe for UnixStream {\n         drop(guard);\n         loop {\n             // Process a timeout if one is pending\n-            let succeeded = await(self.handle(), self.read_deadline,\n-                                  &mut overlapped);\n+            let wait_succeeded = await(self.handle(), self.read_deadline,\n+                                       [overlapped.hEvent]);\n \n             let ret = unsafe {\n                 libc::GetOverlappedResult(self.handle(),\n@@ -408,7 +415,7 @@ impl rtio::RtioPipe for UnixStream {\n \n             // If the reading half is now closed, then we're done. If we woke up\n             // because the writing half was closed, keep trying.\n-            if !succeeded {\n+            if wait_succeeded.is_err() {\n                 return Err(util::timeout(\"read timed out\"))\n             }\n             if self.read_closed() {\n@@ -458,8 +465,8 @@ impl rtio::RtioPipe for UnixStream {\n                     })\n                 }\n                 // Process a timeout if one is pending\n-                let succeeded = await(self.handle(), self.write_deadline,\n-                                      &mut overlapped);\n+                let wait_succeeded = await(self.handle(), self.write_deadline,\n+                                           [overlapped.hEvent]);\n                 let ret = unsafe {\n                     libc::GetOverlappedResult(self.handle(),\n                                               &mut overlapped,\n@@ -473,7 +480,7 @@ impl rtio::RtioPipe for UnixStream {\n                     if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n                         return Err(super::last_error())\n                     }\n-                    if !succeeded {\n+                    if !wait_succeeded.is_ok() {\n                         let amt = offset + bytes_written as uint;\n                         return if amt > 0 {\n                             Err(IoError {\n@@ -577,6 +584,10 @@ impl UnixListener {\n             listener: self,\n             event: try!(Event::new(true, false)),\n             deadline: 0,\n+            inner: Arc::new(AcceptorState {\n+                abort: try!(Event::new(true, false)),\n+                closed: atomic::AtomicBool::new(false),\n+            }),\n         })\n     }\n }\n@@ -597,11 +608,17 @@ impl rtio::RtioUnixListener for UnixListener {\n }\n \n pub struct UnixAcceptor {\n+    inner: Arc<AcceptorState>,\n     listener: UnixListener,\n     event: Event,\n     deadline: u64,\n }\n \n+struct AcceptorState {\n+    abort: Event,\n+    closed: atomic::AtomicBool,\n+}\n+\n impl UnixAcceptor {\n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n         // This function has some funky implementation details when working with\n@@ -638,6 +655,10 @@ impl UnixAcceptor {\n         // using the original server pipe.\n         let handle = self.listener.handle;\n \n+        // If we've had an artifical call to close_accept, be sure to never\n+        // proceed in accepting new clients in the future\n+        if self.inner.closed.load(atomic::SeqCst) { return Err(util::eof()) }\n+\n         let name = try!(to_utf16(&self.listener.name));\n \n         // Once we've got a \"server handle\", we need to wait for a client to\n@@ -652,7 +673,9 @@ impl UnixAcceptor {\n \n             if err == libc::ERROR_IO_PENDING as libc::DWORD {\n                 // Process a timeout if one is pending\n-                let _ = await(handle, self.deadline, &mut overlapped);\n+                let wait_succeeded = await(handle, self.deadline,\n+                                           [self.inner.abort.handle(),\n+                                            overlapped.hEvent]);\n \n                 // This will block until the overlapped I/O is completed. The\n                 // timeout was previously handled, so this will either block in\n@@ -665,7 +688,11 @@ impl UnixAcceptor {\n                                               libc::TRUE)\n                 };\n                 if ret == 0 {\n-                    err = unsafe { libc::GetLastError() };\n+                    if wait_succeeded.is_ok() {\n+                        err = unsafe { libc::GetLastError() };\n+                    } else {\n+                        return Err(util::timeout(\"accept timed out\"))\n+                    }\n                 } else {\n                     // we succeeded, bypass the check below\n                     err = libc::ERROR_PIPE_CONNECTED as libc::DWORD;\n@@ -711,11 +738,32 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     }\n \n     fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n-        fail!()\n+        let name = to_utf16(&self.listener.name).ok().unwrap();\n+        box UnixAcceptor {\n+            inner: self.inner.clone(),\n+            event: Event::new(true, false).ok().unwrap(),\n+            deadline: 0,\n+            listener: UnixListener {\n+                name: self.listener.name.clone(),\n+                handle: unsafe {\n+                    let p = pipe(name.as_ptr(), false) ;\n+                    assert!(p != libc::INVALID_HANDLE_VALUE as libc::HANDLE);\n+                    p\n+                },\n+            },\n+        } as Box<rtio::RtioUnixAcceptor + Send>\n     }\n \n     fn close_accept(&mut self) -> IoResult<()> {\n-        fail!()\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let ret = unsafe {\n+            c::SetEvent(self.inner.abort.handle())\n+        };\n+        if ret == 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n     }\n }\n "}, {"sha": "078989b058180328acc784722f031cabc2fe7b66", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -175,6 +175,9 @@ pub fn await(fds: &[net::sock_t], deadline: Option<u64>,\n         c::fd_set(&mut set, fd);\n         max = cmp::max(max, fd + 1);\n     }\n+    if cfg!(windows) {\n+        max = fds.len() as net::sock_t;\n+    }\n \n     let (read, write) = match status {\n         Readable => (&mut set as *mut _, ptr::mut_null()),"}, {"sha": "84ef9deaf922fd3555dfed54e55a9a76bf049e2d", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -387,7 +387,7 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(self: Box<TcpListener>)\n+    fn listen(mut self: Box<TcpListener>)\n               -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> {\n         let _m = self.fire_homing_missile();\n "}, {"sha": "9ece6525e1e82b07239e342a0e54a6811d4c76fa", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -245,7 +245,7 @@ impl PipeListener {\n }\n \n impl rtio::RtioUnixListener for PipeListener {\n-    fn listen(self: Box<PipeListener>)\n+    fn listen(mut self: Box<PipeListener>)\n               -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n         let _m = self.fire_homing_missile();\n "}, {"sha": "a6fdceaa3739fc75d23c435bc4ef82e2e185b980", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -461,8 +461,7 @@ impl TcpAcceptor {\n     ///\n     /// ```\n     /// # #![allow(experimental)]\n-    /// use std::io::TcpListener;\n-    /// use std::io::{Listener, Acceptor, TimedOut};\n+    /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n     /// let a2 = a.clone();"}, {"sha": "3bd31c6a839edf2c7e89528b9703ba4885672886", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -731,6 +731,7 @@ mod tests {\n         rx2.recv();\n     })\n \n+    #[cfg(not(windows))]\n     iotest!(fn clone_accept_smoke() {\n         let addr = next_test_unix();\n         let l = UnixListener::bind(&addr);\n@@ -746,6 +747,7 @@ mod tests {\n         });\n \n         assert!(a.accept().is_ok());\n+        drop(a);\n         assert!(a2.accept().is_ok());\n     })\n "}, {"sha": "b8470ef7b8fac1f5484b011dffa52c11fd049b03", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd763a5b1e736df39d878b888b1bf14f2009672c/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=fd763a5b1e736df39d878b888b1bf14f2009672c", "patch": "@@ -15,7 +15,7 @@ extern crate green;\n extern crate native;\n \n use std::io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n-use std::sync::{atomics, Arc};\n+use std::sync::{atomic, Arc};\n use std::task::TaskBuilder;\n use native::NativeTaskBuilder;\n \n@@ -38,7 +38,7 @@ fn test() {\n     let mut l = TcpListener::bind(\"127.0.0.1\", 0).unwrap();\n     let addr = l.socket_name().unwrap();\n     let mut a = l.listen().unwrap();\n-    let cnt = Arc::new(atomics::AtomicUint::new(0));\n+    let cnt = Arc::new(atomic::AtomicUint::new(0));\n \n     let (tx, rx) = channel();\n     for _ in range(0, N) {\n@@ -52,7 +52,7 @@ fn test() {\n                 match a.accept() {\n                     Ok(..) => {\n                         mycnt += 1;\n-                        if cnt.fetch_add(1, atomics::SeqCst) == N * M - 1 {\n+                        if cnt.fetch_add(1, atomic::SeqCst) == N * M - 1 {\n                             break\n                         }\n                     }\n@@ -89,6 +89,6 @@ fn test() {\n     assert_eq!(rx.iter().take(N - 1).count(), N - 1);\n \n     // Everything should have been accepted.\n-    assert_eq!(cnt.load(atomics::SeqCst), N * M);\n+    assert_eq!(cnt.load(atomic::SeqCst), N * M);\n }\n "}]}