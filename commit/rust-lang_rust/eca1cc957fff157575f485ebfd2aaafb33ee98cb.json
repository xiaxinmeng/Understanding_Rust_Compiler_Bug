{"sha": "eca1cc957fff157575f485ebfd2aaafb33ee98cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYTFjYzk1N2ZmZjE1NzU3NWY0ODVlYmZkMmFhYWZiMzNlZTk4Y2I=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-11-08T03:01:38Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-11-08T04:14:00Z"}, "message": "Add FxHasher, a faster alternative to FnvHasher.", "tree": {"sha": "8770cba6cb3a4d7d7195c8bc50df3e7d4b4176a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8770cba6cb3a4d7d7195c8bc50df3e7d4b4176a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eca1cc957fff157575f485ebfd2aaafb33ee98cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eca1cc957fff157575f485ebfd2aaafb33ee98cb", "html_url": "https://github.com/rust-lang/rust/commit/eca1cc957fff157575f485ebfd2aaafb33ee98cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eca1cc957fff157575f485ebfd2aaafb33ee98cb/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57f971bc1610ef57c57616822c60aadc7e477904", "url": "https://api.github.com/repos/rust-lang/rust/commits/57f971bc1610ef57c57616822c60aadc7e477904", "html_url": "https://github.com/rust-lang/rust/commit/57f971bc1610ef57c57616822c60aadc7e477904"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "1fb7673521d880029037f94d529df6025b8fccf3", "filename": "src/librustc_data_structures/fx.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/eca1cc957fff157575f485ebfd2aaafb33ee98cb/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca1cc957fff157575f485ebfd2aaafb33ee98cb/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=eca1cc957fff157575f485ebfd2aaafb33ee98cb", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::{HashMap, HashSet};\n+use std::default::Default;\n+use std::hash::{Hasher, Hash, BuildHasherDefault};\n+use std::ops::BitXor;\n+\n+pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;\n+pub type FxHashSet<V> = HashSet<V, BuildHasherDefault<FxHasher>>;\n+\n+#[allow(non_snake_case)]\n+pub fn FxHashMap<K: Hash + Eq, V>() -> FxHashMap<K, V> {\n+    HashMap::default()\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn FxHashSet<V: Hash + Eq>() -> FxHashSet<V> {\n+    HashSet::default()\n+}\n+\n+/// A speedy hash algorithm for use within rustc. The hashmap in libcollections\n+/// by default uses SipHash which isn't quite as speedy as we want. In the\n+/// compiler we're not really worried about DOS attempts, so we use a fast\n+/// non-cryptographic hash.\n+///\n+/// This is the same as the algorithm used by Firefox -- which is a homespun\n+/// one not based on any widely-known algorithm -- though modified to produce\n+/// 64-bit hash values instead of 32-bit hash values. It consistently\n+/// out-performs an FNV-based hash within rustc itself -- the collision rate is\n+/// similar or slightly worse than FNV, but the speed of the hash function\n+/// itself is much higher because it works on up to 8 bytes at a time.\n+pub struct FxHasher {\n+    hash: usize\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+const K: usize = 0x9e3779b9;\n+#[cfg(target_pointer_width = \"64\")]\n+const K: usize = 0x517cc1b727220a95;\n+\n+impl Default for FxHasher {\n+    #[inline]\n+    fn default() -> FxHasher {\n+        FxHasher { hash: 0 }\n+    }\n+}\n+\n+impl FxHasher {\n+    #[inline]\n+    fn add_to_hash(&mut self, i: usize) {\n+        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);\n+    }\n+}\n+\n+impl Hasher for FxHasher {\n+    #[inline]\n+    fn write(&mut self, bytes: &[u8]) {\n+        for byte in bytes {\n+            let i = *byte;\n+            self.add_to_hash(i as usize);\n+        }\n+    }\n+\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+        self.add_to_hash((i >> 32) as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.add_to_hash(i);\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.hash as u64\n+    }\n+}\n+\n+pub fn hash<T: Hash>(v: &T) -> u64 {\n+    let mut state = FxHasher::default();\n+    v.hash(&mut state);\n+    state.finish()\n+}"}]}