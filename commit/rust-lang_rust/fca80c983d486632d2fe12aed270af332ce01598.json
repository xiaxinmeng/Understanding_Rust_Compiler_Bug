{"sha": "fca80c983d486632d2fe12aed270af332ce01598", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYTgwYzk4M2Q0ODY2MzJkMmZlMTJhZWQyNzBhZjMzMmNlMDE1OTg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-02T06:14:38Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-05T04:53:21Z"}, "message": "Generalize `Invocation` to include modifiers/decorators.", "tree": {"sha": "931915a2ae60c20e370d7f7f9a5e283248474372", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/931915a2ae60c20e370d7f7f9a5e283248474372"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fca80c983d486632d2fe12aed270af332ce01598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fca80c983d486632d2fe12aed270af332ce01598", "html_url": "https://github.com/rust-lang/rust/commit/fca80c983d486632d2fe12aed270af332ce01598", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fca80c983d486632d2fe12aed270af332ce01598/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cba93f9933fe96fb77d625a480eb4cdddeed91f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cba93f9933fe96fb77d625a480eb4cdddeed91f", "html_url": "https://github.com/rust-lang/rust/commit/3cba93f9933fe96fb77d625a480eb4cdddeed91f"}], "stats": {"total": 233, "additions": 138, "deletions": 95}, "files": [{"sha": "769a5af0262c5ddbd31dff77f07b09d96181a0ee", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fca80c983d486632d2fe12aed270af332ce01598/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fca80c983d486632d2fe12aed270af332ce01598/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=fca80c983d486632d2fe12aed270af332ce01598", "patch": "@@ -91,16 +91,6 @@ impl Annotatable {\n             _ => panic!(\"expected Item\")\n         }\n     }\n-\n-    pub fn fold_with<F: Folder>(self, folder: &mut F) -> SmallVector<Self> {\n-        match self {\n-            Annotatable::Item(item) => folder.fold_item(item).map(Annotatable::Item),\n-            Annotatable::ImplItem(item) =>\n-                folder.fold_impl_item(item.unwrap()).map(|item| Annotatable::ImplItem(P(item))),\n-            Annotatable::TraitItem(item) =>\n-                folder.fold_trait_item(item.unwrap()).map(|item| Annotatable::TraitItem(P(item))),\n-        }\n-    }\n }\n \n // A more flexible ItemDecorator."}, {"sha": "66a766a666bb43f77f96c1221bff4c0c68d8198b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 138, "deletions": 85, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/fca80c983d486632d2fe12aed270af332ce01598/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fca80c983d486632d2fe12aed270af332ce01598/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fca80c983d486632d2fe12aed270af332ce01598", "patch": "@@ -109,29 +109,104 @@ impl ExpansionKind {\n     fn dummy(self, span: Span) -> Expansion {\n         self.make_from(DummyResult::any(span)).unwrap()\n     }\n+\n+    fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n+        let items = items.into_iter();\n+        match self {\n+            ExpansionKind::Items =>\n+                Expansion::Items(items.map(Annotatable::expect_item).collect()),\n+            ExpansionKind::ImplItems =>\n+                Expansion::ImplItems(items.map(Annotatable::expect_impl_item).collect()),\n+            ExpansionKind::TraitItems =>\n+                Expansion::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n+            _ => unreachable!(),\n+        }\n+    }\n }\n \n pub struct Invocation {\n-    span: Span,\n-    attrs: Vec<ast::Attribute>,\n-    mac: ast::Mac,\n-    ident: Option<Ident>,\n+    kind: InvocationKind,\n+    expansion_kind: ExpansionKind,\n     mark: Mark,\n-    kind: ExpansionKind,\n+}\n+\n+enum InvocationKind {\n+    Bang {\n+        attrs: Vec<ast::Attribute>,\n+        mac: ast::Mac,\n+        ident: Option<Ident>,\n+        span: Span,\n+    },\n+    Attr {\n+        attr: ast::Attribute,\n+        item: Annotatable,\n+    },\n }\n \n pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n     if let ast::ExprKind::Mac(mac) = expr.node {\n-        let invoc = fld.new_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr);\n-        expand_mac_invoc(invoc, fld).make_expr()\n+        let invoc = fld.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr);\n+        expand_invoc(invoc, fld).make_expr()\n     } else {\n         P(noop_fold_expr(expr, fld))\n     }\n }\n \n+fn expand_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n+    match invoc.kind {\n+        InvocationKind::Bang { .. } => expand_bang_invoc(invoc, fld),\n+        InvocationKind::Attr { .. } => expand_attr_invoc(invoc, fld),\n+    }\n+}\n+\n+fn expand_attr_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n+    let Invocation { expansion_kind: kind, .. } = invoc;\n+    let (attr, item) = match invoc.kind {\n+        InvocationKind::Attr { attr, item } => (attr, item),\n+        _ => unreachable!(),\n+    };\n+\n+    let extension = match fld.cx.syntax_env.find(intern(&attr.name())) {\n+        Some(extension) => extension,\n+        None => unreachable!(),\n+    };\n+\n+    attr::mark_used(&attr);\n+    fld.cx.bt_push(ExpnInfo {\n+        call_site: attr.span,\n+        callee: NameAndSpan {\n+            format: MacroAttribute(intern(&attr.name())),\n+            span: Some(attr.span),\n+            allow_internal_unstable: false,\n+        }\n+    });\n+\n+    let modified = match *extension {\n+        MultiModifier(ref mac) => {\n+            kind.expect_from_annotatables(mac.expand(fld.cx, attr.span, &attr.node.value, item))\n+        }\n+        MultiDecorator(ref mac) => {\n+            let mut items = Vec::new();\n+            mac.expand(fld.cx, attr.span, &attr.node.value, &item, &mut |item| items.push(item));\n+            items.push(item);\n+            kind.expect_from_annotatables(items)\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    fld.cx.bt_pop();\n+\n+    let configured = modified.fold_with(&mut fld.strip_unconfigured());\n+    configured.fold_with(fld)\n+}\n+\n /// Expand a macro invocation. Returns the result of expansion.\n-fn expand_mac_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n-    let Invocation { span, attrs, mac, ident, mark, kind } = invoc;\n+fn expand_bang_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n+    let Invocation { mark, expansion_kind: kind, .. } = invoc;\n+    let (attrs, mac, ident, span) = match invoc.kind {\n+        InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n+        _ => unreachable!(),\n+    };\n     let Mac_ { path, tts, .. } = mac.node;\n \n     // Detect use of feature-gated or invalid attributes on macro invoations\n@@ -270,11 +345,8 @@ fn expand_mac_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n     fully_expanded\n }\n \n-// When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n-                   -> SmallVector<P<ast::Item>> {\n-    expand_annotatable(Annotatable::Item(it), fld)\n-        .into_iter().map(|i| i.expect_item()).collect()\n+pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n+    expand_annotatable(Annotatable::Item(it), fld).make_items()\n }\n \n // does this attribute list contain \"macro_use\" ?\n@@ -311,8 +383,8 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n         _ => return noop_fold_stmt(stmt, fld)\n     };\n \n-    let invoc = fld.new_invoc(mac, attrs.into(), stmt.span, ExpansionKind::Stmts);\n-    let mut fully_expanded = expand_mac_invoc(invoc, fld).make_stmts();\n+    let invoc = fld.new_bang_invoc(mac, attrs.into(), stmt.span, ExpansionKind::Stmts);\n+    let mut fully_expanded = expand_invoc(invoc, fld).make_stmts();\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n@@ -332,28 +404,30 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     }\n     p.and_then(|p| match p.node {\n         PatKind::Mac(mac) => {\n-            let invoc = fld.new_invoc(mac, Vec::new(), p.span, ExpansionKind::Pat);\n-            expand_mac_invoc(invoc, fld).make_pat()\n+            let invoc = fld.new_bang_invoc(mac, Vec::new(), p.span, ExpansionKind::Pat);\n+            expand_invoc(invoc, fld).make_pat()\n         }\n         _ => unreachable!(),\n     })\n }\n \n-fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n+fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> Expansion {\n     match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n                 if match it.node {\n                     ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n                     _ => unreachable!(),\n                 } {\n-                    return SmallVector::one(Annotatable::Item(it));\n+                    return Expansion::Items(SmallVector::one(it));\n                 }\n                 it.and_then(|it| match it.node {\n                     ItemKind::Mac(mac) => {\n-                        let mut invoc = fld.new_invoc(mac, it.attrs, it.span, ExpansionKind::Items);\n-                        invoc.ident = Some(it.ident);\n-                        expand_mac_invoc(invoc, fld).make_items()\n+                        let invoc =\n+                            fld.new_invoc(ExpansionKind::Items, InvocationKind::Bang {\n+                                mac: mac, attrs: it.attrs, ident: Some(it.ident), span: it.span,\n+                            });\n+                        expand_invoc(invoc, fld)\n                     }\n                     _ => unreachable!(),\n                 })\n@@ -370,31 +444,24 @@ fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector\n                 if valid_ident {\n                     fld.cx.mod_pop();\n                 }\n-                result\n+                Expansion::Items(result)\n             },\n-            _ => noop_fold_item(it, fld),\n-        }.into_iter().map(|i| Annotatable::Item(i)).collect(),\n-\n-        Annotatable::TraitItem(it) => {\n-            expand_trait_item(it.unwrap(), fld).into_iter().\n-                map(|it| Annotatable::TraitItem(P(it))).collect()\n-        }\n+            _ => Expansion::Items(noop_fold_item(it, fld)),\n+        },\n \n-        Annotatable::ImplItem(ii) => {\n-            expand_impl_item(ii.unwrap(), fld).into_iter().\n-                map(|ii| Annotatable::ImplItem(P(ii))).collect()\n-        }\n+        Annotatable::TraitItem(it) => Expansion::TraitItems(expand_trait_item(it.unwrap(), fld)),\n+        Annotatable::ImplItem(ii) => Expansion::ImplItems(expand_impl_item(ii.unwrap(), fld)),\n     }\n }\n \n-fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n-    let mut multi_modifier = None;\n+fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> Expansion {\n+    let mut attr = None;\n     item = item.map_attrs(|mut attrs| {\n         for i in 0..attrs.len() {\n             if let Some(extension) = fld.cx.syntax_env.find(intern(&attrs[i].name())) {\n                 match *extension {\n                     MultiModifier(..) | MultiDecorator(..) => {\n-                        multi_modifier = Some((attrs.remove(i), extension));\n+                        attr = Some(attrs.remove(i));\n                         break;\n                     }\n                     _ => {}\n@@ -404,47 +471,25 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n         attrs\n     });\n \n-    match multi_modifier {\n-        None => expand_multi_modified(item, fld),\n-        Some((attr, extension)) => {\n-            attr::mark_used(&attr);\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: attr.span,\n-                callee: NameAndSpan {\n-                    format: MacroAttribute(intern(&attr.name())),\n-                    span: Some(attr.span),\n-                    allow_internal_unstable: false,\n-                }\n-            });\n-\n-            let modified = match *extension {\n-                MultiModifier(ref mac) => mac.expand(fld.cx, attr.span, &attr.node.value, item),\n-                MultiDecorator(ref mac) => {\n-                    let mut items = Vec::new();\n-                    mac.expand(fld.cx, attr.span, &attr.node.value, &item,\n-                               &mut |item| items.push(item));\n-                    items.push(item);\n-                    items\n-                }\n-                _ => unreachable!(),\n-            };\n-\n-            fld.cx.bt_pop();\n-            let configured = modified.into_iter().flat_map(|it| {\n-                it.fold_with(&mut fld.strip_unconfigured())\n-            }).collect::<SmallVector<_>>();\n-\n-            configured.into_iter().flat_map(|it| expand_annotatable(it, fld)).collect()\n-        }\n+    if let Some(attr) = attr {\n+        let kind = match item {\n+            Annotatable::Item(_) => ExpansionKind::Items,\n+            Annotatable::ImplItem(_) => ExpansionKind::ImplItems,\n+            Annotatable::TraitItem(_) => ExpansionKind::TraitItems,\n+        };\n+        let invoc = fld.new_invoc(kind, InvocationKind::Attr { attr: attr, item: item });\n+        expand_invoc(invoc, fld)\n+    } else {\n+        expand_multi_modified(item, fld)\n     }\n }\n \n fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n                  -> SmallVector<ast::ImplItem> {\n     match ii.node {\n         ast::ImplItemKind::Macro(mac) => {\n-            let invoc = fld.new_invoc(mac, ii.attrs, ii.span, ExpansionKind::ImplItems);\n-            expand_mac_invoc(invoc, fld).make_impl_items()\n+            let invoc = fld.new_bang_invoc(mac, ii.attrs, ii.span, ExpansionKind::ImplItems);\n+            expand_invoc(invoc, fld).make_impl_items()\n         }\n         _ => fold::noop_fold_impl_item(ii, fld)\n     }\n@@ -454,8 +499,8 @@ fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n                      -> SmallVector<ast::TraitItem> {\n     match ti.node {\n         ast::TraitItemKind::Macro(mac) => {\n-            let invoc = fld.new_invoc(mac, ti.attrs, ti.span, ExpansionKind::TraitItems);\n-            expand_mac_invoc(invoc, fld).make_trait_items()\n+            let invoc = fld.new_bang_invoc(mac, ti.attrs, ti.span, ExpansionKind::TraitItems);\n+            expand_invoc(invoc, fld).make_trait_items()\n         }\n         _ => fold::noop_fold_trait_item(ti, fld)\n     }\n@@ -469,8 +514,8 @@ pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n \n     match t.node {\n         ast::TyKind::Mac(mac) => {\n-            let invoc = fld.new_invoc(mac, Vec::new(), t.span, ExpansionKind::Ty);\n-            expand_mac_invoc(invoc, fld).make_ty()\n+            let invoc = fld.new_bang_invoc(mac, Vec::new(), t.span, ExpansionKind::Ty);\n+            expand_invoc(invoc, fld).make_ty()\n         }\n         _ => unreachable!(),\n     }\n@@ -542,10 +587,20 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         });\n     }\n \n-    fn new_invoc(&self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind)\n+    fn new_invoc(&self, expansion_kind: ExpansionKind, kind: InvocationKind)\n                  -> Invocation {\n-        let mark = Mark::fresh();\n-        Invocation { span: span, attrs: attrs, mac: mac, mark: mark, kind: kind, ident: None }\n+        Invocation { mark: Mark::fresh(), kind: kind, expansion_kind: expansion_kind }\n+    }\n+\n+    fn new_bang_invoc(\n+        &self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind,\n+    ) -> Invocation {\n+        self.new_invoc(kind, InvocationKind::Bang {\n+            attrs: attrs,\n+            mac: mac,\n+            ident: None,\n+            span: span,\n+        })\n     }\n \n     fn with_exts_frame<T, F: FnOnce(&mut Self) -> T>(&mut self, macros_escape: bool, f: F) -> T {\n@@ -573,8 +628,8 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expr.and_then(|expr| match expr.node {\n             ast::ExprKind::Mac(mac) => {\n                 let invoc =\n-                    self.new_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr);\n-                expand_mac_invoc(invoc, self).make_opt_expr()\n+                    self.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr);\n+                expand_invoc(invoc, self).make_opt_expr()\n             }\n             _ => Some(expand_expr(expr, self)),\n         })\n@@ -624,13 +679,11 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n \n     fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        expand_annotatable(Annotatable::TraitItem(P(i)), self)\n-            .into_iter().map(|i| i.expect_trait_item()).collect()\n+        expand_annotatable(Annotatable::TraitItem(P(i)), self).make_trait_items()\n     }\n \n     fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        expand_annotatable(Annotatable::ImplItem(P(i)), self)\n-            .into_iter().map(|i| i.expect_impl_item()).collect()\n+        expand_annotatable(Annotatable::ImplItem(P(i)), self).make_impl_items()\n     }\n \n     fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {"}]}