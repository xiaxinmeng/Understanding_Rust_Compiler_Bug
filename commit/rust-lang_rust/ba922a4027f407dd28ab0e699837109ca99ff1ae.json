{"sha": "ba922a4027f407dd28ab0e699837109ca99ff1ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhOTIyYTQwMjdmNDA3ZGQyOGFiMGU2OTk4MzcxMDljYTk5ZmYxYWU=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-06-29T15:45:59Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-06-29T16:02:21Z"}, "message": "Fix handling of temp cleanups for the \"self\" argument\n\nThe code that tried to revoke the cleanup for the self argument tried\nto use \"llself\" to do so, but the cleanup might actually be registered\nwith a different ValueRef due to e.g. casting. Currently, this is\nworked around by early revocation of the cleanup for self in\ntrans_self_arg.\n\nTo handle this correctly, we have to put the ValueRef for the cleanup\ninto the MethodData, so trans_call_inner can use it to revoke the\ncleanup when it's actually supposed to.", "tree": {"sha": "bfcb128ec065eaa8d5bac9e6894ab7b27cae3ace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfcb128ec065eaa8d5bac9e6894ab7b27cae3ace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba922a4027f407dd28ab0e699837109ca99ff1ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba922a4027f407dd28ab0e699837109ca99ff1ae", "html_url": "https://github.com/rust-lang/rust/commit/ba922a4027f407dd28ab0e699837109ca99ff1ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba922a4027f407dd28ab0e699837109ca99ff1ae/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a40c5db469b5065f64c69ae7874f162ff2669a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a40c5db469b5065f64c69ae7874f162ff2669a8", "html_url": "https://github.com/rust-lang/rust/commit/2a40c5db469b5065f64c69ae7874f162ff2669a8"}], "stats": {"total": 48, "additions": 23, "deletions": 25}, "files": [{"sha": "821f5c7950fea2af70766b68a8a724a9e1a94a00", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba922a4027f407dd28ab0e699837109ca99ff1ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba922a4027f407dd28ab0e699837109ca99ff1ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=ba922a4027f407dd28ab0e699837109ca99ff1ae", "patch": "@@ -62,6 +62,7 @@ pub struct FnData {\n pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n+    temp_cleanup: Option<ValueRef>,\n     self_ty: ty::t,\n     self_mode: ty::SelfMode,\n     explicit_self: ast::explicit_self_\n@@ -646,9 +647,10 @@ pub fn trans_call_inner(in_cx: block,\n         // Now that the arguments have finished evaluating, we need to revoke\n         // the cleanup for the self argument, if it exists\n         match callee.data {\n-            Method(d) if d.self_mode == ty::ByCopy ||\n-                         d.explicit_self == ast::sty_value => {\n-                revoke_clean(bcx, d.llself);\n+            Method(d) => {\n+                for d.temp_cleanup.iter().advance |&v| {\n+                    revoke_clean(bcx, v);\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "3884a2d03f67001d3c9592b6b34d1e9380532aaf", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ba922a4027f407dd28ab0e699837109ca99ff1ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba922a4027f407dd28ab0e699837109ca99ff1ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ba922a4027f407dd28ab0e699837109ca99ff1ae", "patch": "@@ -129,28 +129,20 @@ pub fn trans_method(ccx: @mut CrateContext,\n \n pub fn trans_self_arg(bcx: block,\n                       base: @ast::expr,\n+                      temp_cleanups: &mut ~[ValueRef],\n                       mentry: typeck::method_map_entry) -> Result {\n     let _icx = push_ctxt(\"impl::trans_self_arg\");\n-    let mut temp_cleanups = ~[];\n \n     // self is passed as an opaque box in the environment slot\n     let self_ty = ty::mk_opaque_box(bcx.tcx());\n-    let result = trans_arg_expr(bcx,\n-                                self_ty,\n-                                mentry.self_mode,\n-                                mentry.explicit_self,\n-                                base,\n-                                &mut temp_cleanups,\n-                                None,\n-                                DontAutorefArg);\n-\n-    // FIXME(#3446)---this is wrong, actually.  The temp_cleanups\n-    // should be revoked only after all arguments have been passed.\n-    for temp_cleanups.iter().advance |c| {\n-        revoke_clean(bcx, *c)\n-    }\n-\n-    return result;\n+    trans_arg_expr(bcx,\n+                   self_ty,\n+                   mentry.self_mode,\n+                   mentry.explicit_self,\n+                   base,\n+                   temp_cleanups,\n+                   None,\n+                   DontAutorefArg)\n }\n \n pub fn trans_method_callee(bcx: block,\n@@ -203,12 +195,14 @@ pub fn trans_method_callee(bcx: block,\n     match origin {\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n-            let Result {bcx, val} = trans_self_arg(bcx, this, mentry);\n+            let mut temp_cleanups = ~[];\n+            let Result {bcx, val} = trans_self_arg(bcx, this, &mut temp_cleanups, mentry);\n             Callee {\n                 bcx: bcx,\n                 data: Method(MethodData {\n                     llfn: callee_fn.llfn,\n                     llself: val,\n+                    temp_cleanup: temp_cleanups.head_opt().map(|&v| *v),\n                     self_ty: node_id_type(bcx, this.id),\n                     self_mode: mentry.self_mode,\n                     explicit_self: mentry.explicit_self\n@@ -254,9 +248,8 @@ pub fn trans_method_callee(bcx: block,\n                                store,\n                                mentry.explicit_self)\n         }\n-            typeck::method_super(*) => {\n-            fail!(\"method_super should have been handled \\\n-                   above\")\n+        typeck::method_super(*) => {\n+            fail!(\"method_super should have been handled above\")\n         }\n     }\n }\n@@ -413,8 +406,9 @@ pub fn trans_monomorphized_callee(bcx: block,\n               bcx.ccx(), impl_did, mname);\n \n           // obtain the `self` value:\n+          let mut temp_cleanups = ~[];\n           let Result {bcx, val: llself_val} =\n-              trans_self_arg(bcx, base, mentry);\n+              trans_self_arg(bcx, base, &mut temp_cleanups, mentry);\n \n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n@@ -441,6 +435,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n                   llself: llself_val,\n+                  temp_cleanup: temp_cleanups.head_opt().map(|&v| *v),\n                   self_ty: node_id_type(bcx, base.id),\n                   self_mode: mentry.self_mode,\n                   explicit_self: mentry.explicit_self\n@@ -636,6 +631,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n         data: Method(MethodData {\n             llfn: mptr,\n             llself: llself,\n+            temp_cleanup: None,\n             self_ty: ty::mk_opaque_box(bcx.tcx()),\n             self_mode: ty::ByRef,\n             explicit_self: explicit_self"}]}