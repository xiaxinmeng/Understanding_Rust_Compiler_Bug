{"sha": "d4d67406d7fd06258b92adcd8f5d600720679d7f", "node_id": "C_kwDOAAsO6NoAKGQ0ZDY3NDA2ZDdmZDA2MjU4YjkyYWRjZDhmNWQ2MDA3MjA2NzlkN2Y", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-10T18:07:43Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-10T18:08:10Z"}, "message": "internal: clean up code duplication", "tree": {"sha": "a32d553dcf9a601b2879edbb6ab8bb9df4e106fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a32d553dcf9a601b2879edbb6ab8bb9df4e106fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4d67406d7fd06258b92adcd8f5d600720679d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d67406d7fd06258b92adcd8f5d600720679d7f", "html_url": "https://github.com/rust-lang/rust/commit/d4d67406d7fd06258b92adcd8f5d600720679d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4d67406d7fd06258b92adcd8f5d600720679d7f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "079e9fe49645fab8cb20a8cfb2da81915f018b04", "url": "https://api.github.com/repos/rust-lang/rust/commits/079e9fe49645fab8cb20a8cfb2da81915f018b04", "html_url": "https://github.com/rust-lang/rust/commit/079e9fe49645fab8cb20a8cfb2da81915f018b04"}], "stats": {"total": 122, "additions": 45, "deletions": 77}, "files": [{"sha": "63b5022ae837d19405387e6a40ec3a8f197010c8", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=d4d67406d7fd06258b92adcd8f5d600720679d7f", "patch": "@@ -28,10 +28,8 @@ static TOKEN_LIMIT: Limit = Limit::new(524_288);\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum TokenExpander {\n-    /// Old-style `macro_rules`.\n-    MacroRules { mac: mbe::MacroRules, def_site_token_map: mbe::TokenMap },\n-    /// AKA macros 2.0.\n-    MacroDef { mac: mbe::MacroDef, def_site_token_map: mbe::TokenMap },\n+    /// Old-style `macro_rules` or the new macros 2.0\n+    DeclarativeMacro { mac: mbe::DeclarativeMacro, def_site_token_map: mbe::TokenMap },\n     /// Stuff like `line!` and `file!`.\n     Builtin(BuiltinFnLikeExpander),\n     /// `global_allocator` and such.\n@@ -50,8 +48,7 @@ impl TokenExpander {\n         tt: &tt::Subtree,\n     ) -> mbe::ExpandResult<tt::Subtree> {\n         match self {\n-            TokenExpander::MacroRules { mac, .. } => mac.expand(tt),\n-            TokenExpander::MacroDef { mac, .. } => mac.expand(tt),\n+            TokenExpander::DeclarativeMacro { mac, .. } => mac.expand(tt),\n             TokenExpander::Builtin(it) => it.expand(db, id, tt),\n             TokenExpander::BuiltinAttr(it) => it.expand(db, id, tt),\n             TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt),\n@@ -66,8 +63,7 @@ impl TokenExpander {\n \n     pub(crate) fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n         match self {\n-            TokenExpander::MacroRules { mac, .. } => mac.map_id_down(id),\n-            TokenExpander::MacroDef { mac, .. } => mac.map_id_down(id),\n+            TokenExpander::DeclarativeMacro { mac, .. } => mac.map_id_down(id),\n             TokenExpander::Builtin(..)\n             | TokenExpander::BuiltinAttr(..)\n             | TokenExpander::BuiltinDerive(..)\n@@ -77,8 +73,7 @@ impl TokenExpander {\n \n     pub(crate) fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, mbe::Origin) {\n         match self {\n-            TokenExpander::MacroRules { mac, .. } => mac.map_id_up(id),\n-            TokenExpander::MacroDef { mac, .. } => mac.map_id_up(id),\n+            TokenExpander::DeclarativeMacro { mac, .. } => mac.map_id_up(id),\n             TokenExpander::Builtin(..)\n             | TokenExpander::BuiltinAttr(..)\n             | TokenExpander::BuiltinDerive(..)\n@@ -368,24 +363,27 @@ fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n \n fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError> {\n     match id.kind {\n-        MacroDefKind::Declarative(ast_id) => match ast_id.to_node(db) {\n-            ast::Macro::MacroRules(macro_rules) => {\n-                let arg = macro_rules\n-                    .token_tree()\n-                    .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n-                let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n-                let mac = mbe::MacroRules::parse(&tt)?;\n-                Ok(Arc::new(TokenExpander::MacroRules { mac, def_site_token_map }))\n-            }\n-            ast::Macro::MacroDef(macro_def) => {\n-                let arg = macro_def\n-                    .body()\n-                    .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n-                let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n-                let mac = mbe::MacroDef::parse(&tt)?;\n-                Ok(Arc::new(TokenExpander::MacroDef { mac, def_site_token_map }))\n-            }\n-        },\n+        MacroDefKind::Declarative(ast_id) => {\n+            let (mac, def_site_token_map) = match ast_id.to_node(db) {\n+                ast::Macro::MacroRules(macro_rules) => {\n+                    let arg = macro_rules\n+                        .token_tree()\n+                        .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n+                    let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n+                    let mac = mbe::DeclarativeMacro::parse_macro_rules(&tt)?;\n+                    (mac, def_site_token_map)\n+                }\n+                ast::Macro::MacroDef(macro_def) => {\n+                    let arg = macro_def\n+                        .body()\n+                        .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n+                    let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n+                    let mac = mbe::DeclarativeMacro::parse_macro2(&tt)?;\n+                    (mac, def_site_token_map)\n+                }\n+            };\n+            Ok(Arc::new(TokenExpander::DeclarativeMacro { mac, def_site_token_map }))\n+        }\n         MacroDefKind::BuiltIn(expander, _) => Ok(Arc::new(TokenExpander::Builtin(expander))),\n         MacroDefKind::BuiltInAttr(expander, _) => {\n             Ok(Arc::new(TokenExpander::BuiltinAttr(expander)))"}, {"sha": "51f14d684c13b47f4f94404e24326473ebd39adc", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=d4d67406d7fd06258b92adcd8f5d600720679d7f", "patch": "@@ -160,11 +160,9 @@ impl HygieneInfo {\n                     InFile::new(loc.kind.file_id(), loc.kind.arg(db)?.text_range().start()),\n                 ),\n                 mbe::Origin::Def => match (&*self.macro_def, &self.attr_input_or_mac_def_start) {\n-                    (\n-                        TokenExpander::MacroDef { def_site_token_map, .. }\n-                        | TokenExpander::MacroRules { def_site_token_map, .. },\n-                        Some(tt),\n-                    ) => (def_site_token_map, *tt),\n+                    (TokenExpander::DeclarativeMacro { def_site_token_map, .. }, Some(tt)) => {\n+                        (def_site_token_map, *tt)\n+                    }\n                     _ => panic!(\"`Origin::Def` used with non-`macro_rules!` macro\"),\n                 },\n             },"}, {"sha": "b831ad26b492a5f0be8daf565042f1d26f7c8a80", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=d4d67406d7fd06258b92adcd8f5d600720679d7f", "patch": "@@ -468,11 +468,9 @@ impl ExpansionInfo {\n             _ => match origin {\n                 mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone()),\n                 mbe::Origin::Def => match (&*self.macro_def, &self.attr_input_or_mac_def) {\n-                    (\n-                        TokenExpander::MacroRules { def_site_token_map, .. }\n-                        | TokenExpander::MacroDef { def_site_token_map, .. },\n-                        Some(tt),\n-                    ) => (def_site_token_map, tt.syntax().cloned()),\n+                    (TokenExpander::DeclarativeMacro { def_site_token_map, .. }, Some(tt)) => {\n+                        (def_site_token_map, tt.syntax().cloned())\n+                    }\n                     _ => panic!(\"`Origin::Def` used with non-`macro_rules!` macro\"),\n                 },\n             },"}, {"sha": "a10f0e834dff58c64f7b3021d70e20c15500aed8", "filename": "crates/mbe/src/benchmark.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=d4d67406d7fd06258b92adcd8f5d600720679d7f", "patch": "@@ -9,7 +9,7 @@ use test_utils::{bench, bench_fixture, skip_slow_tests};\n \n use crate::{\n     parser::{Op, RepeatKind, Separator},\n-    syntax_node_to_token_tree, MacroRules,\n+    syntax_node_to_token_tree, DeclarativeMacro,\n };\n \n #[test]\n@@ -20,7 +20,7 @@ fn benchmark_parse_macro_rules() {\n     let rules = macro_rules_fixtures_tt();\n     let hash: usize = {\n         let _pt = bench(\"mbe parse macro rules\");\n-        rules.values().map(|it| MacroRules::parse(it).unwrap().rules.len()).sum()\n+        rules.values().map(|it| DeclarativeMacro::parse_macro_rules(it).unwrap().rules.len()).sum()\n     };\n     assert_eq!(hash, 1144);\n }\n@@ -47,10 +47,10 @@ fn benchmark_expand_macro_rules() {\n     assert_eq!(hash, 69413);\n }\n \n-fn macro_rules_fixtures() -> FxHashMap<String, MacroRules> {\n+fn macro_rules_fixtures() -> FxHashMap<String, DeclarativeMacro> {\n     macro_rules_fixtures_tt()\n         .into_iter()\n-        .map(|(id, tt)| (id, MacroRules::parse(&tt).unwrap()))\n+        .map(|(id, tt)| (id, DeclarativeMacro::parse_macro_rules(&tt).unwrap()))\n         .collect()\n }\n \n@@ -71,7 +71,7 @@ fn macro_rules_fixtures_tt() -> FxHashMap<String, tt::Subtree> {\n }\n \n /// Generate random invocation fixtures from rules\n-fn invocation_fixtures(rules: &FxHashMap<String, MacroRules>) -> Vec<(String, tt::Subtree)> {\n+fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(String, tt::Subtree)> {\n     let mut seed = 123456789;\n     let mut res = Vec::new();\n "}, {"sha": "498a1b3323cb5e47143f2b3d901c66aac7eb07ad", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d67406d7fd06258b92adcd8f5d600720679d7f/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=d4d67406d7fd06258b92adcd8f5d600720679d7f", "patch": "@@ -83,15 +83,7 @@ pub use crate::{\n /// `tt::TokenTree`, but there's a crucial difference: in macro rules, `$ident`\n /// and `$()*` have special meaning (see `Var` and `Repeat` data structures)\n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct MacroRules {\n-    rules: Vec<Rule>,\n-    /// Highest id of the token we have in TokenMap\n-    shift: Shift,\n-}\n-\n-/// For Macro 2.0\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct MacroDef {\n+pub struct DeclarativeMacro {\n     rules: Vec<Rule>,\n     /// Highest id of the token we have in TokenMap\n     shift: Shift,\n@@ -176,8 +168,9 @@ pub enum Origin {\n     Call,\n }\n \n-impl MacroRules {\n-    pub fn parse(tt: &tt::Subtree) -> Result<MacroRules, ParseError> {\n+impl DeclarativeMacro {\n+    /// The old, `macro_rules! m {}` flavor.\n+    pub fn parse_macro_rules(tt: &tt::Subtree) -> Result<DeclarativeMacro, ParseError> {\n         // Note: this parsing can be implemented using mbe machinery itself, by\n         // matching against `$($lhs:tt => $rhs:tt);*` pattern, but implementing\n         // manually seems easier.\n@@ -198,30 +191,11 @@ impl MacroRules {\n             validate(&rule.lhs)?;\n         }\n \n-        Ok(MacroRules { rules, shift: Shift::new(tt) })\n-    }\n-\n-    pub fn expand(&self, tt: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n-        // apply shift\n-        let mut tt = tt.clone();\n-        self.shift.shift_all(&mut tt);\n-        expander::expand_rules(&self.rules, &tt)\n+        Ok(DeclarativeMacro { rules, shift: Shift::new(tt) })\n     }\n \n-    pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n-        self.shift.shift(id)\n-    }\n-\n-    pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, Origin) {\n-        match self.shift.unshift(id) {\n-            Some(id) => (id, Origin::Call),\n-            None => (id, Origin::Def),\n-        }\n-    }\n-}\n-\n-impl MacroDef {\n-    pub fn parse(tt: &tt::Subtree) -> Result<MacroDef, ParseError> {\n+    /// The new, unstable `macro m {}` flavor.\n+    pub fn parse_macro2(tt: &tt::Subtree) -> Result<DeclarativeMacro, ParseError> {\n         let mut src = TtIter::new(tt);\n         let mut rules = Vec::new();\n \n@@ -251,7 +225,7 @@ impl MacroDef {\n             validate(&rule.lhs)?;\n         }\n \n-        Ok(MacroDef { rules, shift: Shift::new(tt) })\n+        Ok(DeclarativeMacro { rules, shift: Shift::new(tt) })\n     }\n \n     pub fn expand(&self, tt: &tt::Subtree) -> ExpandResult<tt::Subtree> {"}]}