{"sha": "60f5011005eda4f08f0c36fe56e4df07ae9a903f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZjUwMTEwMDVlZGE0ZjA4ZjBjMzZmZTU2ZTRkZjA3YWU5YTkwM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T04:56:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T04:56:17Z"}, "message": "auto merge of #8296 : erickt/rust/remove-str-trailing-nulls, r=erickt\n\nThis PR fixes #7235 and #3371, which removes trailing nulls from `str` types. Instead, it replaces the creation of c strings with a new type, `std::c_str::CString`, which wraps a malloced byte array, and respects:\r\n\r\n*  No interior nulls\r\n* Ends with a trailing null", "tree": {"sha": "4f3636735525b80b6aa3c6fc37b88a5f9057548c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f3636735525b80b6aa3c6fc37b88a5f9057548c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60f5011005eda4f08f0c36fe56e4df07ae9a903f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60f5011005eda4f08f0c36fe56e4df07ae9a903f", "html_url": "https://github.com/rust-lang/rust/commit/60f5011005eda4f08f0c36fe56e4df07ae9a903f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60f5011005eda4f08f0c36fe56e4df07ae9a903f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e81e81f234731a31fad9afdc2045bef3fbdf1109", "url": "https://api.github.com/repos/rust-lang/rust/commits/e81e81f234731a31fad9afdc2045bef3fbdf1109", "html_url": "https://github.com/rust-lang/rust/commit/e81e81f234731a31fad9afdc2045bef3fbdf1109"}, {"sha": "ee59aacac490edd619db1c4e2fcd848f793bc3b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee59aacac490edd619db1c4e2fcd848f793bc3b9", "html_url": "https://github.com/rust-lang/rust/commit/ee59aacac490edd619db1c4e2fcd848f793bc3b9"}], "stats": {"total": 1855, "additions": 1236, "deletions": 619}, "files": [{"sha": "9106d4cd684d916f5c6d58bcbb83dd87962cce90", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -11,7 +11,7 @@\n // FIXME #3921. This is unsafe because linenoise uses global mutable\n // state without mutexes.\n \n-\n+use std::c_str::ToCStr;\n use std::libc::{c_char, c_int};\n use std::local_data;\n use std::str;\n@@ -32,7 +32,7 @@ pub mod rustrt {\n \n /// Add a line to history\n pub unsafe fn add_history(line: &str) -> bool {\n-    do line.as_c_str |buf| {\n+    do line.to_c_str().with_ref |buf| {\n         rustrt::linenoiseHistoryAdd(buf) == 1 as c_int\n     }\n }\n@@ -44,21 +44,21 @@ pub unsafe fn set_history_max_len(len: int) -> bool {\n \n /// Save line history to a file\n pub unsafe fn save_history(file: &str) -> bool {\n-    do file.as_c_str |buf| {\n+    do file.to_c_str().with_ref |buf| {\n         rustrt::linenoiseHistorySave(buf) == 1 as c_int\n     }\n }\n \n /// Load line history from a file\n pub unsafe fn load_history(file: &str) -> bool {\n-    do file.as_c_str |buf| {\n+    do file.to_c_str().with_ref |buf| {\n         rustrt::linenoiseHistoryLoad(buf) == 1 as c_int\n     }\n }\n \n /// Print out a prompt and then wait for input and return it\n pub unsafe fn read(prompt: &str) -> Option<~str> {\n-    do prompt.as_c_str |buf| {\n+    do prompt.to_c_str().with_ref |buf| {\n         let line = rustrt::linenoise(buf);\n \n         if line.is_null() { None }\n@@ -80,7 +80,7 @@ pub unsafe fn complete(cb: CompletionCb) {\n \n             unsafe {\n                 do cb(str::raw::from_c_str(line)) |suggestion| {\n-                    do suggestion.as_c_str |buf| {\n+                    do suggestion.to_c_str().with_ref |buf| {\n                         rustrt::linenoiseAddCompletion(completions, buf);\n                     }\n                 }"}, {"sha": "3edd7f1c66b00a60c6e7755c4d4dee338f08b6e0", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -476,6 +476,7 @@ impl FormatOp {\n     }\n }\n \n+#[cfg(stage0)]\n fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n     let mut s = match val {\n         Number(d) => {\n@@ -545,8 +546,103 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n         String(s) => {\n             match op {\n                 FormatString => {\n-                    let mut s = s.to_bytes_with_null();\n-                    s.pop(); // remove the null\n+                    let mut s = s.as_bytes().to_owned();\n+                    if flags.precision > 0 && flags.precision < s.len() {\n+                        s.truncate(flags.precision);\n+                    }\n+                    s\n+                }\n+                _ => {\n+                    return Err(fmt!(\"non-string on stack with %%%c\", op.to_char()))\n+                }\n+            }\n+        }\n+    };\n+    if flags.width > s.len() {\n+        let n = flags.width - s.len();\n+        if flags.left {\n+            s.grow(n, &(' ' as u8));\n+        } else {\n+            let mut s_ = vec::with_capacity(flags.width);\n+            s_.grow(n, &(' ' as u8));\n+            s_.push_all_move(s);\n+            s = s_;\n+        }\n+    }\n+    Ok(s)\n+}\n+\n+#[cfg(not(stage0))]\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n+    let mut s = match val {\n+        Number(d) => {\n+            match op {\n+                FormatString => {\n+                    return Err(~\"non-number on stack with %s\")\n+                }\n+                _ => {\n+                    let radix = match op {\n+                        FormatDigit => 10,\n+                        FormatOctal => 8,\n+                        FormatHex|FormatHEX => 16,\n+                        FormatString => util::unreachable()\n+                    };\n+                    let mut s = ~[];\n+                    match op {\n+                        FormatDigit => {\n+                            let sign = if flags.sign { SignAll } else { SignNeg };\n+                            do int_to_str_bytes_common(d, radix, sign) |c| {\n+                                s.push(c);\n+                            }\n+                        }\n+                        _ => {\n+                            do int_to_str_bytes_common(d as uint, radix, SignNone) |c| {\n+                                s.push(c);\n+                            }\n+                        }\n+                    };\n+                    if flags.precision > s.len() {\n+                        let mut s_ = vec::with_capacity(flags.precision);\n+                        let n = flags.precision - s.len();\n+                        s_.grow(n, &('0' as u8));\n+                        s_.push_all_move(s);\n+                        s = s_;\n+                    }\n+                    assert!(!s.is_empty(), \"string conversion produced empty result\");\n+                    match op {\n+                        FormatDigit => {\n+                            if flags.space && !(s[0] == '-' as u8 || s[0] == '+' as u8) {\n+                                s.unshift(' ' as u8);\n+                            }\n+                        }\n+                        FormatOctal => {\n+                            if flags.alternate && s[0] != '0' as u8 {\n+                                s.unshift('0' as u8);\n+                            }\n+                        }\n+                        FormatHex => {\n+                            if flags.alternate {\n+                                let s_ = util::replace(&mut s, ~['0' as u8, 'x' as u8]);\n+                                s.push_all_move(s_);\n+                            }\n+                        }\n+                        FormatHEX => {\n+                            s = s.into_ascii().to_upper().into_bytes();\n+                            if flags.alternate {\n+                                let s_ = util::replace(&mut s, ~['0' as u8, 'X' as u8]);\n+                                s.push_all_move(s_);\n+                            }\n+                        }\n+                        FormatString => util::unreachable()\n+                    }\n+                    s\n+                }\n+            }\n+        }\n+        String(s) => {\n+            match op {\n+                FormatString => {\n+                    let mut s = s.as_bytes().to_owned();\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);\n                     }"}, {"sha": "f79e01b6f28b296d031de972c042cb7a6a655035", "filename": "src/libextra/time.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -284,10 +284,14 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_digits(ss: &str, pos: uint, digits: uint, ws: bool)\n       -> Option<(i32, uint)> {\n         let mut pos = pos;\n+        let len = ss.len();\n         let mut value = 0_i32;\n \n         let mut i = 0u;\n         while i < digits {\n+            if pos >= len {\n+                return None;\n+            }\n             let range = ss.char_range_at(pos);\n             pos = range.next;\n \n@@ -853,7 +857,7 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n \n #[cfg(test)]\n mod tests {\n-    use time::*;\n+    use super::*;\n \n     use std::float;\n     use std::os;\n@@ -901,7 +905,7 @@ mod tests {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n-        let time = ::time::Timespec::new(1234567890, 54321);\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n         assert!(utc.tm_sec == 30_i32);\n@@ -922,7 +926,7 @@ mod tests {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n-        let time = ::time::Timespec::new(1234567890, 54321);\n+        let time = Timespec::new(1234567890, 54321);\n         let local = at(time);\n \n         error!(\"time_at: %?\", local);\n@@ -950,7 +954,7 @@ mod tests {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n-        let time = ::time::Timespec::new(1234567890, 54321);\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n         assert_eq!(utc.to_timespec(), time);\n@@ -961,7 +965,7 @@ mod tests {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n-        let time = ::time::Timespec::new(1234567890, 54321);\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n         let local = at(time);\n \n@@ -1142,7 +1146,7 @@ mod tests {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n-        let time = ::time::Timespec::new(1234567890, 54321);\n+        let time = Timespec::new(1234567890, 54321);\n         let utc   = at_utc(time);\n         let local = at(time);\n \n@@ -1156,7 +1160,7 @@ mod tests {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n-        let time = ::time::Timespec::new(1234567890, 54321);\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n         let local = at(time);\n "}, {"sha": "fbe17fb0d1c9e0ddf9a0904f1e1544d6db04e61e", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -22,6 +22,7 @@ use middle::trans::common::gensym_name;\n use middle::ty;\n use util::ppaux;\n \n+use std::c_str::ToCStr;\n use std::char;\n use std::hash::Streaming;\n use std::hash;\n@@ -76,9 +77,9 @@ pub fn WriteOutputFile(sess: Session,\n         OptLevel: c_int,\n         EnableSegmentedStacks: bool) {\n     unsafe {\n-        do Triple.as_c_str |Triple| {\n-            do Feature.as_c_str |Feature| {\n-                do Output.as_c_str |Output| {\n+        do Triple.to_c_str().with_ref |Triple| {\n+            do Feature.to_c_str().with_ref |Feature| {\n+                do Output.to_c_str().with_ref |Output| {\n                     let result = llvm::LLVMRustWriteOutputFile(\n                             PM,\n                             M,\n@@ -105,6 +106,7 @@ pub mod jit {\n     use lib::llvm::{ModuleRef, ContextRef, ExecutionEngineRef};\n     use metadata::cstore;\n \n+    use std::c_str::ToCStr;\n     use std::cast;\n     use std::local_data;\n     use std::unstable::intrinsics;\n@@ -146,7 +148,7 @@ pub mod jit {\n \n                 debug!(\"linking: %s\", path);\n \n-                do path.as_c_str |buf_t| {\n+                do path.to_c_str().with_ref |buf_t| {\n                     if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n                         llvm_err(sess, ~\"Could not link\");\n                     }\n@@ -165,7 +167,7 @@ pub mod jit {\n             // Next, we need to get a handle on the _rust_main function by\n             // looking up it's corresponding ValueRef and then requesting that\n             // the execution engine compiles the function.\n-            let fun = do \"_rust_main\".as_c_str |entry| {\n+            let fun = do \"_rust_main\".to_c_str().with_ref |entry| {\n                 llvm::LLVMGetNamedFunction(m, entry)\n             };\n             if fun.is_null() {\n@@ -230,6 +232,7 @@ pub mod write {\n \n     use back::passes;\n \n+    use std::c_str::ToCStr;\n     use std::libc::{c_int, c_uint};\n     use std::path::Path;\n     use std::run;\n@@ -263,14 +266,14 @@ pub mod write {\n                   output_type_bitcode => {\n                     if opts.optimize != session::No {\n                         let filename = output.with_filetype(\"no-opt.bc\");\n-                        do filename.to_str().as_c_str |buf| {\n+                        do filename.to_c_str().with_ref |buf| {\n                             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                         }\n                     }\n                   }\n                   _ => {\n                     let filename = output.with_filetype(\"bc\");\n-                    do filename.to_str().as_c_str |buf| {\n+                    do filename.to_c_str().with_ref |buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                     }\n                   }\n@@ -333,7 +336,7 @@ pub mod write {\n                     // Always output the bitcode file with --save-temps\n \n                     let filename = output.with_filetype(\"opt.bc\");\n-                    do filename.to_str().as_c_str |buf| {\n+                    do filename.to_c_str().with_ref |buf| {\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                     };\n                     // Save the assembly file if -S is used\n@@ -391,13 +394,13 @@ pub mod write {\n \n             if output_type == output_type_llvm_assembly {\n                 // Given options \"-S --emit-llvm\": output LLVM assembly\n-                do output.to_str().as_c_str |buf_o| {\n+                do output.to_c_str().with_ref |buf_o| {\n                     llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o);\n                 }\n             } else {\n                 // If only a bitcode file is asked for by using the\n                 // '--emit-llvm' flag, then output it here\n-                do output.to_str().as_c_str |buf| {\n+                do output.to_c_str().with_ref |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 }\n             }"}, {"sha": "854d11fd3503599e030e2d33d8f8a9dbd36ceb21", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::c_str::ToCStr;\n use std::io;\n \n use driver::session::{OptLevel, No, Less, Aggressive};\n@@ -172,7 +173,7 @@ pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~s\n }\n \n pub fn create_pass(name:&str) -> Option<PassRef> {\n-    do name.as_c_str |s| {\n+    do name.to_c_str().with_ref |s| {\n         unsafe {\n             let p = llvm::LLVMCreatePass(s);\n             if p.is_null() {"}, {"sha": "e879168eabff2d55d69e0095ed4bfd4038564abe", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use std::c_str::ToCStr;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ushort};\n use std::option;\n@@ -2259,7 +2259,7 @@ pub struct TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    let lltd = do string_rep.as_c_str |buf| {\n+    let lltd = do string_rep.to_c_str().with_ref |buf| {\n         unsafe { llvm::LLVMCreateTargetData(buf) }\n     };\n "}, {"sha": "704a22ec979252c2f27f1746d5cbaf240339bff1", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -23,6 +23,7 @@ use syntax::print::pprust;\n use syntax::{ast, attr};\n use syntax::attr::AttrMetaMethods;\n \n+use std::c_str::ToCStr;\n use std::cast;\n use std::io;\n use std::num;\n@@ -198,7 +199,7 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n fn get_metadata_section(os: os,\n                         filename: &Path) -> Option<@~[u8]> {\n     unsafe {\n-        let mb = do filename.to_str().as_c_str |buf| {\n+        let mb = do filename.to_c_str().with_ref |buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n         };\n         if mb as int == 0 { return option::None::<@~[u8]>; }"}, {"sha": "b6057199a280fbccddba02aefe60d7b20f42c5f7", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -12,6 +12,7 @@\n # Translation of inline assembly.\n */\n \n+use std::c_str::ToCStr;\n \n use lib;\n use middle::trans::build::*;\n@@ -119,8 +120,8 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         ast::asm_intel => lib::llvm::AD_Intel\n     };\n \n-    let r = do ia.asm.as_c_str |a| {\n-        do constraints.as_c_str |c| {\n+    let r = do ia.asm.to_c_str().with_ref |a| {\n+        do constraints.to_c_str().with_ref |c| {\n             InlineAsmCall(bcx, a, c, inputs, output, ia.volatile, ia.alignstack, dialect)\n         }\n     };"}, {"sha": "6b51832e8e337d1cdff995b9f94266cf8003b5c6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -65,6 +65,7 @@ use util::ppaux::{Repr, ty_to_str};\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::hash;\n use std::hashmap::HashMap;\n use std::io;\n@@ -179,7 +180,7 @@ impl<'self> Drop for StatRecorder<'self> {\n }\n \n pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n-    let llfn: ValueRef = do name.as_c_str |buf| {\n+    let llfn: ValueRef = do name.to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n         }\n@@ -219,7 +220,7 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n         None => ()\n     }\n     unsafe {\n-        let c = do name.as_c_str |buf| {\n+        let c = do name.to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n         };\n         externs.insert(name, c);\n@@ -521,7 +522,7 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n     if cx.sess.opts.save_temps {\n-        do s.as_c_str |buf| {\n+        do s.to_c_str().with_ref |buf| {\n             unsafe {\n                 llvm::LLVMSetValueName(v, buf)\n             }\n@@ -1135,7 +1136,7 @@ pub fn new_block(cx: @mut FunctionContext,\n                  opt_node_info: Option<NodeInfo>)\n               -> @mut Block {\n     unsafe {\n-        let llbb = do name.as_c_str |buf| {\n+        let llbb = do name.to_c_str().with_ref |buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n         };\n         let bcx = @mut Block::new(llbb,\n@@ -1552,7 +1553,7 @@ pub struct BasicBlocks {\n pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        do \"static_allocas\".as_c_str | buf| {\n+        do \"static_allocas\".to_c_str().with_ref | buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n         }\n     }\n@@ -1561,7 +1562,7 @@ pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        do \"return\".as_c_str |buf| {\n+        do \"return\".to_c_str().with_ref |buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n         }\n     }\n@@ -2312,7 +2313,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             };\n             decl_cdecl_fn(ccx.llmod, main_name, llfty)\n         };\n-        let llbb = do \"top\".as_c_str |buf| {\n+        let llbb = do \"top\".to_c_str().with_ref |buf| {\n             unsafe {\n                 llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n             }\n@@ -2322,7 +2323,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n             let crate_map = ccx.crate_map;\n-            let opaque_crate_map = do \"crate_map\".as_c_str |buf| {\n+            let opaque_crate_map = do \"crate_map\".to_c_str().with_ref |buf| {\n                 llvm::LLVMBuildPointerCast(bld, crate_map, Type::i8p().to_ref(), buf)\n             };\n \n@@ -2340,7 +2341,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n \n                 let args = {\n-                    let opaque_rust_main = do \"rust_main\".as_c_str |buf| {\n+                    let opaque_rust_main = do \"rust_main\".to_c_str().with_ref |buf| {\n                         llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n                     };\n \n@@ -2365,11 +2366,10 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 (rust_main, args)\n             };\n \n-            let result = llvm::LLVMBuildCall(bld,\n-                                             start_fn,\n-                                             &args[0],\n-                                             args.len() as c_uint,\n-                                             noname());\n+            let result = do args.as_imm_buf |buf, len| {\n+                llvm::LLVMBuildCall(bld, start_fn, buf, len as c_uint, noname())\n+            };\n+\n             llvm::LLVMBuildRet(bld, result);\n         }\n     }\n@@ -2428,7 +2428,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                             unsafe {\n                                 let llty = llvm::LLVMTypeOf(v);\n-                                let g = do sym.as_c_str |buf| {\n+                                let g = do sym.to_c_str().with_ref |buf| {\n                                     llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n                                 };\n \n@@ -2452,7 +2452,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n                         Some(sect) => unsafe {\n-                            do sect.as_c_str |buf| {\n+                            do sect.to_c_str().with_ref |buf| {\n                                 llvm::LLVMSetSection(v, buf);\n                             }\n                         },\n@@ -2493,7 +2493,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                         }\n                         ast::foreign_item_static(*) => {\n                             let ident = token::ident_to_str(&ni.ident);\n-                            let g = do ident.as_c_str |buf| {\n+                            let g = do ident.to_c_str().with_ref |buf| {\n                                 unsafe {\n                                     let ty = type_of(ccx, ty);\n                                     llvm::LLVMAddGlobal(ccx.llmod, ty.to_ref(), buf)\n@@ -2600,7 +2600,7 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n             let s = mangle_exported_name(ccx, p, ty::mk_int()).to_managed();\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n-            let discrim_gvar = do s.as_c_str |buf| {\n+            let discrim_gvar = do s.to_c_str().with_ref |buf| {\n                 unsafe {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n                 }\n@@ -2741,7 +2741,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n \n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n-    let gc_metadata = do gc_metadata_name.as_c_str |buf| {\n+    let gc_metadata = do gc_metadata_name.to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n         }\n@@ -2756,7 +2756,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     let elttype = Type::struct_([ccx.int_type, ccx.int_type], false);\n     let maptype = Type::array(&elttype, (ccx.module_data.len() + 1) as u64);\n-    let map = do \"_rust_mod_map\".as_c_str |buf| {\n+    let map = do \"_rust_mod_map\".to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n         }\n@@ -2804,7 +2804,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = Type::array(&int_type, n_subcrates as u64);\n     let maptype = Type::struct_([Type::i32(), Type::i8p(), int_type, arrtype], false);\n-    let map = do sym_name.as_c_str |buf| {\n+    let map = do sym_name.to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n         }\n@@ -2823,7 +2823,7 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n                       cdata.name,\n                       cstore::get_crate_vers(cstore, i),\n                       cstore::get_crate_hash(cstore, i));\n-        let cr = do nm.as_c_str |buf| {\n+        let cr = do nm.to_c_str().with_ref |buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n             }\n@@ -2886,21 +2886,21 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::Crate) {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct([llmeta]);\n-    let mut llglobal = do \"rust_metadata\".as_c_str |buf| {\n+    let mut llglobal = do \"rust_metadata\".to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n         }\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        do cx.sess.targ_cfg.target_strs.meta_sect_name.as_c_str |buf| {\n+        do cx.sess.targ_cfg.target_strs.meta_sect_name.to_c_str().with_ref |buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         };\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n         let t_ptr_i8 = Type::i8p();\n         llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n-        let llvm_used = do \"llvm.used\".as_c_str |buf| {\n+        let llvm_used = do \"llvm.used\".to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(cx.llmod, Type::array(&t_ptr_i8, 1).to_ref(), buf)\n         };\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n@@ -2914,7 +2914,7 @@ fn mk_global(ccx: &CrateContext,\n              internal: bool)\n           -> ValueRef {\n     unsafe {\n-        let llglobal = do name.as_c_str |buf| {\n+        let llglobal = do name.to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(llglobal, llval);"}, {"sha": "7d7fc9c087e64c97918e61af47bc87db2ba8771d", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -423,7 +423,7 @@ impl Builder {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                do name.as_c_str |c| {\n+                do name.to_c_str().with_ref |c| {\n                     llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c)\n                 }\n             }\n@@ -739,7 +739,7 @@ impl Builder {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = fmt!(\"# %s\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let asm = do comment_text.as_c_str |c| {\n+            let asm = do comment_text.to_c_str().with_ref |c| {\n                 unsafe {\n                     llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n                                              c, noname(), False, False)\n@@ -895,7 +895,7 @@ impl Builder {\n             let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n             let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n             let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-            let T: ValueRef = do \"llvm.trap\".as_c_str |buf| {\n+            let T: ValueRef = do \"llvm.trap\".to_c_str().with_ref |buf| {\n                 llvm::LLVMGetNamedFunction(M, buf)\n             };\n             assert!((T as int != 0));"}, {"sha": "f756460bd028b74e79c3d9832832945714f4a02a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -31,6 +31,7 @@ use util::ppaux::{Repr};\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::cast::transmute;\n use std::cast;\n use std::hashmap::{HashMap};\n@@ -707,7 +708,7 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        do s.as_c_str |buf| {\n+        do s.to_c_str().with_ref |buf| {\n             llvm::LLVMConstRealOfString(t.to_ref(), buf)\n         }\n     }\n@@ -755,12 +756,12 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n             None => ()\n         }\n \n-        let sc = do s.as_c_str |buf| {\n+        let sc = do s.to_c_str().with_ref |buf| {\n             llvm::LLVMConstStringInContext(cx.llcx, buf, s.len() as c_uint, False)\n         };\n \n         let gsym = token::gensym(\"str\");\n-        let g = do fmt!(\"str%u\", gsym).as_c_str |buf| {\n+        let g = do fmt!(\"str%u\", gsym).to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(g, sc);\n@@ -779,7 +780,7 @@ pub fn C_estr_slice(cx: &mut CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n-        C_struct([cs, C_uint(cx, len + 1u /* +1 for null */)])\n+        C_struct([cs, C_uint(cx, len)])\n     }\n }\n "}, {"sha": "0cb423d4921eb77a0ab654d279d5b6d2e892bc9d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -30,6 +30,7 @@ use util::ppaux::{Repr, ty_to_str};\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::libc::c_uint;\n use syntax::{ast, ast_util, ast_map};\n \n@@ -101,7 +102,7 @@ pub fn const_vec(cx: @mut CrateContext, e: &ast::expr, es: &[@ast::expr])\n \n fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n-        let gv = do \"const\".as_c_str |name| {\n+        let gv = do \"const\".to_c_str().with_ref |name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n         };\n         llvm::LLVMSetInitializer(gv, cv);\n@@ -527,7 +528,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               ast::expr_vec(ref es, ast::m_imm) => {\n                 let (cv, sz, llunitty) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n-                let gv = do \"const\".as_c_str |name| {\n+                let gv = do \"const\".to_c_str().with_ref |name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n                 };\n                 llvm::LLVMSetInitializer(gv, cv);"}, {"sha": "a644174731ab47940b9c08e6484e4a9468d73ebe", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -26,6 +26,7 @@ use middle::ty;\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::hash;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n@@ -124,11 +125,17 @@ impl CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n             set_task_llcx(llcx);\n-            let llmod = name.as_c_str(|buf| llvm::LLVMModuleCreateWithNameInContext(buf, llcx));\n+            let llmod = do name.to_c_str().with_ref |buf| {\n+                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n+            };\n             let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n             let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-            data_layout.as_c_str(|buf| llvm::LLVMSetDataLayout(llmod, buf));\n-            targ_triple.as_c_str(|buf| llvm::LLVMSetTarget(llmod, buf));\n+            do data_layout.to_c_str().with_ref |buf| {\n+                llvm::LLVMSetDataLayout(llmod, buf)\n+            };\n+            do targ_triple.to_c_str().with_ref |buf| {\n+                llvm::LLVMSetTarget(llmod, buf)\n+            };\n             let targ_cfg = sess.targ_cfg;\n \n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);"}, {"sha": "46eb3928d595eb956d7998ebb09f762b5e2abe34", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::c_str::ToCStr;\n \n use back::link;\n use lib;\n@@ -240,7 +241,7 @@ pub fn trans_log(log_ex: &ast::expr,\n             ccx, modpath, \"loglevel\");\n         let global;\n         unsafe {\n-            global = do s.as_c_str |buf| {\n+            global = do s.to_c_str().with_ref |buf| {\n                 llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n             };\n             llvm::LLVMSetGlobalConstant(global, False);"}, {"sha": "11136627826beb20a24fc6102ed15cd786eeb20b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -63,6 +63,7 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux::ty_to_str;\n \n+use std::c_str::ToCStr;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n@@ -159,7 +160,7 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n         let ty = node_id_type(bcx, node_id);\n         let type_metadata = type_metadata(cx, ty, span);\n \n-        let var_metadata = do name.as_c_str |name| {\n+        let var_metadata = do name.to_c_str().with_ref |name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateLocalVariable(\n                     DIB(cx),\n@@ -246,7 +247,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n             argument_index as c_uint\n         };\n \n-        let arg_metadata = do name.as_c_str |name| {\n+        let arg_metadata = do name.to_c_str().with_ref |name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateLocalVariable(\n                     DIB(cx),\n@@ -382,8 +383,8 @@ pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n     };\n \n     let fn_metadata =\n-        do cx.sess.str_of(ident).as_c_str |name| {\n-        do cx.sess.str_of(ident).as_c_str |linkage| {\n+        do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+        do cx.sess.str_of(ident).to_c_str().with_ref |linkage| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFunction(\n                     DIB(cx),\n@@ -430,11 +431,11 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n \n-    do crate_name.as_c_str |crate_name| {\n-    do work_dir.as_c_str |work_dir| {\n-    do producer.as_c_str |producer| {\n-    do \"\".as_c_str |flags| {\n-    do \"\".as_c_str |split_name| {\n+    do crate_name.to_c_str().with_ref |crate_name| {\n+    do work_dir.to_c_str().with_ref |work_dir| {\n+    do producer.to_c_str().with_ref |producer| {\n+    do \"\".to_c_str().with_ref |flags| {\n+    do \"\".to_c_str().with_ref |split_name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n                 DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n@@ -461,8 +462,8 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n         };\n \n     let file_metadata =\n-        do file_name.as_c_str |file_name| {\n-        do work_dir.as_c_str |work_dir| {\n+        do file_name.to_c_str().with_ref |file_name| {\n+        do work_dir.to_c_str().with_ref |work_dir| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n             }\n@@ -550,7 +551,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let ty_metadata = do name.as_c_str |name| {\n+    let ty_metadata = do name.to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -571,7 +572,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = ty_to_str(cx.tcx, pointer_type);\n-    let ptr_metadata = do name.as_c_str |name| {\n+    let ptr_metadata = do name.to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n                 DIB(cx),\n@@ -665,7 +666,7 @@ fn enum_metadata(cx: &mut CrateContext,\n             let name: &str = cx.sess.str_of(v.name);\n             let discriminant_value = v.disr_val as c_ulonglong;\n \n-            do name.as_c_str |name| {\n+            do name.to_c_str().with_ref |name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerator(\n                         DIB(cx),\n@@ -679,7 +680,7 @@ fn enum_metadata(cx: &mut CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| {\n+    let discriminant_type_metadata = do enum_name.to_c_str().with_ref |enum_name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateEnumerationType(\n                 DIB(cx),\n@@ -716,7 +717,7 @@ fn enum_metadata(cx: &mut CrateContext,\n                         Some(discriminant_type_metadata),\n                         span);\n \n-                    do \"\".as_c_str |name| {\n+                    do \"\".to_c_str().with_ref |name| {\n                         unsafe {\n                             llvm::LLVMDIBuilderCreateMemberType(\n                                 DIB(cx),\n@@ -736,7 +737,7 @@ fn enum_metadata(cx: &mut CrateContext,\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-            return do enum_name.as_c_str |enum_name| {\n+            return do enum_name.to_c_str().with_ref |enum_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateUnionType(\n                     DIB(cx),\n@@ -820,7 +821,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n             let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n             let member_name: &str = member_names[i];\n \n-            do member_name.as_c_str |member_name| {\n+            do member_name.to_c_str().with_ref |member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n@@ -838,7 +839,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n         })\n         .collect();\n \n-    return do composite_type_name.as_c_str |name| {\n+    return do composite_type_name.to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateStructType(\n                 DIB(cx),\n@@ -1064,7 +1065,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     debug!(\"unimplemented_type_metadata: %?\", ty::get(t));\n \n     let name = ty_to_str(cx.tcx, t);\n-    let metadata = do fmt!(\"NYI<%s>\", name).as_c_str |name| {\n+    let metadata = do fmt!(\"NYI<%s>\", name).to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),"}, {"sha": "8c63be084fd55bfdb93af5e8ca8b8ee7bfa8ad68", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -849,7 +849,6 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n \n         let _icx = push_ctxt(\"trans_index\");\n         let ccx = bcx.ccx();\n-        let base_ty = expr_ty(bcx, base);\n         let mut bcx = bcx;\n \n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n@@ -879,12 +878,6 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n         let (bcx, base, len) =\n             base_datum.get_vec_base_and_len(bcx, index_expr.span,\n                                             index_expr.id, 0);\n-        let mut len = len;\n-\n-        if ty::type_is_str(base_ty) {\n-            // acccount for null terminator in the case of string\n-            len = Sub(bcx, len, C_uint(bcx.ccx(), 1u));\n-        }\n \n         debug!(\"trans_index: base %s\", bcx.val_to_str(base));\n         debug!(\"trans_index: len %s\", bcx.val_to_str(len));\n@@ -943,7 +936,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n                             let symbol = csearch::get_symbol(\n                                 bcx.ccx().sess.cstore,\n                                 did);\n-                            let llval = do symbol.as_c_str |buf| {\n+                            let llval = do symbol.to_c_str().with_ref |buf| {\n                                 llvm::LLVMAddGlobal(bcx.ccx().llmod,\n                                                     llty.to_ref(),\n                                                     buf)"}, {"sha": "a70b907f2628cc4090eb86174f16cb51a7543aed", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -37,6 +37,7 @@ use util::ppaux::ty_to_short_str;\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::libc::c_uint;\n use syntax::ast;\n \n@@ -659,7 +660,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n     debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), name);\n-    let gvar = do name.as_c_str |buf| {\n+    let gvar = do name.to_c_str().with_ref |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n         }"}, {"sha": "f2c63164c82380850f3da7db04e37b59df68bf25", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -32,6 +32,7 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n use std::vec;\n use syntax::ast_map::{path, path_mod, path_name};\n use syntax::ast_util;\n@@ -604,7 +605,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n \n         let tbl = C_struct(components);\n         let vtable = ccx.sess.str_of(gensym_name(\"vtable\"));\n-        let vt_gvar = do vtable.as_c_str |buf| {\n+        let vt_gvar = do vtable.to_c_str().with_ref |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);"}, {"sha": "e0403ac9ad7a800875bf1ba67726499031957fad", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -58,7 +58,7 @@ impl Reflector {\n         let str_vstore = ty::vstore_slice(ty::re_static);\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, \"\", false);\n-        let len = C_uint(bcx.ccx(), s.len() + 1);\n+        let len = C_uint(bcx.ccx(), s.len());\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));"}, {"sha": "5b0e2fa18f240af3716c6604a6ae391512b18d5e", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -265,7 +265,7 @@ pub fn trans_lit_str(bcx: @mut Block,\n         Ignore => bcx,\n         SaveIn(lldest) => {\n             unsafe {\n-                let bytes = str_lit.len() + 1; // count null-terminator too\n+                let bytes = str_lit.len(); // count null-terminator too\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p().to_ref());\n@@ -363,7 +363,7 @@ pub fn write_content(bcx: @mut Block,\n                     return bcx;\n                 }\n                 SaveIn(lldest) => {\n-                    let bytes = s.len() + 1; // copy null-terminator too\n+                    let bytes = s.len();\n                     let llbytes = C_uint(bcx.ccx(), bytes);\n                     let llcstr = C_cstr(bcx.ccx(), s);\n                     base::call_memcpy(bcx, lldest, llcstr, llbytes, 1);\n@@ -491,7 +491,7 @@ pub fn elements_required(bcx: @mut Block, content_expr: &ast::expr) -> uint {\n \n     match content_expr.node {\n         ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n-            s.len() + 1\n+            s.len()\n         },\n         ast::expr_vec(ref es, _) => es.len(),\n         ast::expr_repeat(_, count_expr, _) => {\n@@ -524,7 +524,6 @@ pub fn get_base_and_len(bcx: @mut Block,\n     match vstore {\n         ty::vstore_fixed(n) => {\n             let base = GEPi(bcx, llval, [0u, 0u]);\n-            let n = if ty::type_is_str(vec_ty) { n + 1u } else { n };\n             let len = Mul(bcx, C_uint(ccx, n), vt.llunit_size);\n             (base, len)\n         }"}, {"sha": "110febfcc9f579b7080786fb98335b77c7f6a678", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -20,6 +20,7 @@ use middle::trans::base;\n use syntax::ast;\n use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n \n+use std::c_str::ToCStr;\n use std::vec;\n use std::cast;\n \n@@ -170,7 +171,7 @@ impl Type {\n \n     pub fn named_struct(name: &str) -> Type {\n         let ctx = base::task_llcx();\n-        ty!(name.as_c_str(|s| llvm::LLVMStructCreateNamed(ctx, s)))\n+        ty!(name.to_c_str().with_ref(|s| llvm::LLVMStructCreateNamed(ctx, s)))\n     }\n \n     pub fn empty_struct() -> Type {"}, {"sha": "afac9423fba66027da5112787412f681a96f3bb2", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -394,10 +394,12 @@ pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n pub fn link_exe(src: &Path, dest: &Path) -> bool {\n+    use std::c_str::ToCStr;\n     use std::libc;\n+\n     unsafe {\n-        do src.to_str().as_c_str |src_buf| {\n-            do dest.to_str().as_c_str |dest_buf| {\n+        do src.to_c_str().with_ref |src_buf| {\n+            do dest.to_c_str().with_ref |dest_buf| {\n                 libc::link(src_buf, dest_buf) == 0 as libc::c_int &&\n                     libc::chmod(dest_buf, 755) == 0 as libc::c_int\n             }"}, {"sha": "7e31354366084b061dffef714b178b0263badc03", "filename": "src/libstd/c_str.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -0,0 +1,233 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use iterator::Iterator;\n+use libc;\n+use ops::Drop;\n+use option::{Option, Some, None};\n+use ptr::RawPtr;\n+use ptr;\n+use str::StrSlice;\n+use vec::ImmutableVector;\n+\n+/// The representation of a C String.\n+///\n+/// This structure wraps a `*libc::c_char`, and will automatically free the\n+/// memory it is pointing to when it goes out of scope.\n+pub struct CString {\n+    priv buf: *libc::c_char,\n+    priv owns_buffer_: bool,\n+}\n+\n+impl CString {\n+    /// Create a C String from a pointer.\n+    pub unsafe fn new(buf: *libc::c_char, owns_buffer: bool) -> CString {\n+        CString { buf: buf, owns_buffer_: owns_buffer }\n+    }\n+\n+    /// Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.\n+    pub unsafe fn unwrap(self) -> *libc::c_char {\n+        let mut c_str = self;\n+        c_str.owns_buffer_ = false;\n+        c_str.buf\n+    }\n+\n+    /// Calls a closure with a reference to the underlying `*libc::c_char`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n+    pub fn with_ref<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        f(self.buf)\n+    }\n+\n+    /// Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n+    pub fn with_mut_ref<T>(&mut self, f: &fn(*mut libc::c_char) -> T) -> T {\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        f(unsafe { cast::transmute_mut_unsafe(self.buf) })\n+    }\n+\n+    /// Returns true if the CString is a null.\n+    pub fn is_null(&self) -> bool {\n+        self.buf.is_null()\n+    }\n+\n+    /// Returns true if the CString is not null.\n+    pub fn is_not_null(&self) -> bool {\n+        self.buf.is_not_null()\n+    }\n+\n+    /// Returns whether or not the `CString` owns the buffer.\n+    pub fn owns_buffer(&self) -> bool {\n+        self.owns_buffer_\n+    }\n+\n+    /// Converts the CString into a `&[u8]` without copying.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n+    pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        unsafe {\n+            let len = libc::strlen(self.buf) as uint;\n+            cast::transmute((self.buf, len + 1))\n+        }\n+    }\n+\n+    /// Return a CString iterator.\n+    fn iter<'a>(&'a self) -> CStringIterator<'a> {\n+        CStringIterator {\n+            ptr: self.buf,\n+            lifetime: unsafe { cast::transmute(self.buf) },\n+        }\n+    }\n+}\n+\n+impl Drop for CString {\n+    fn drop(&self) {\n+        if self.owns_buffer_ {\n+            unsafe {\n+                libc::free(self.buf as *libc::c_void)\n+            }\n+        }\n+    }\n+}\n+\n+/// A generic trait for converting a value to a CString.\n+pub trait ToCStr {\n+    /// Create a C String.\n+    fn to_c_str(&self) -> CString;\n+}\n+\n+impl<'self> ToCStr for &'self str {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        self.as_bytes().to_c_str()\n+    }\n+}\n+\n+impl<'self> ToCStr for &'self [u8] {\n+    fn to_c_str(&self) -> CString {\n+        do self.as_imm_buf |self_buf, self_len| {\n+            unsafe {\n+                let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n+                if buf.is_null() {\n+                    fail!(\"failed to allocate memory!\");\n+                }\n+\n+                ptr::copy_memory(buf, self_buf, self_len);\n+                *ptr::mut_offset(buf, self_len as int) = 0;\n+\n+                CString::new(buf as *libc::c_char, true)\n+            }\n+        }\n+    }\n+}\n+\n+/// External iterator for a CString's bytes.\n+///\n+/// Use with the `std::iterator` module.\n+pub struct CStringIterator<'self> {\n+    priv ptr: *libc::c_char,\n+    priv lifetime: &'self libc::c_char, // FIXME: #5922\n+}\n+\n+impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n+    fn next(&mut self) -> Option<libc::c_char> {\n+        let ch = unsafe { *self.ptr };\n+        if ch == 0 {\n+            None\n+        } else {\n+            self.ptr = ptr::offset(self.ptr, 1);\n+            Some(ch)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use libc;\n+    use ptr;\n+    use option::{Some, None};\n+\n+    #[test]\n+    fn test_to_c_str() {\n+        do \"\".to_c_str().with_ref |buf| {\n+            unsafe {\n+                assert_eq!(*ptr::offset(buf, 0), 0);\n+            }\n+        }\n+\n+        do \"hello\".to_c_str().with_ref |buf| {\n+            unsafe {\n+                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n+                assert_eq!(*ptr::offset(buf, 5), 0);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_is_null() {\n+        let c_str = unsafe { CString::new(ptr::null(), false) };\n+        assert!(c_str.is_null());\n+        assert!(!c_str.is_not_null());\n+    }\n+\n+    #[test]\n+    fn test_unwrap() {\n+        let c_str = \"hello\".to_c_str();\n+        unsafe { libc::free(c_str.unwrap() as *libc::c_void) }\n+    }\n+\n+    #[test]\n+    fn test_with_ref() {\n+        let c_str = \"hello\".to_c_str();\n+        let len = unsafe { c_str.with_ref(|buf| libc::strlen(buf)) };\n+        assert!(!c_str.is_null());\n+        assert!(c_str.is_not_null());\n+        assert_eq!(len, 5);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_with_ref_empty_fail() {\n+        let c_str = unsafe { CString::new(ptr::null(), false) };\n+        c_str.with_ref(|_| ());\n+    }\n+\n+    #[test]\n+    fn test_iterator() {\n+        let c_str = \"\".to_c_str();\n+        let mut iter = c_str.iter();\n+        assert_eq!(iter.next(), None);\n+\n+        let c_str = \"hello\".to_c_str();\n+        let mut iter = c_str.iter();\n+        assert_eq!(iter.next(), Some('h' as libc::c_char));\n+        assert_eq!(iter.next(), Some('e' as libc::c_char));\n+        assert_eq!(iter.next(), Some('l' as libc::c_char));\n+        assert_eq!(iter.next(), Some('l' as libc::c_char));\n+        assert_eq!(iter.next(), Some('o' as libc::c_char));\n+        assert_eq!(iter.next(), None);\n+    }\n+}"}, {"sha": "ff9057afb55fc47dfb1b10f88d8b7b958d757f34", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -165,10 +165,20 @@ mod tests {\n         }\n     }\n \n+    #[cfg(stage0)]\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n             assert_eq!(~[76u8, 0u8], transmute(~\"L\"));\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[test]\n+    fn test_transmute2() {\n+        unsafe {\n+            assert_eq!(~[76u8], transmute(~\"L\"));\n+        }\n+    }\n+\n }"}, {"sha": "07572d60917a0246c6f24be086ae26a64b52697f", "filename": "src/libstd/io.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -48,6 +48,7 @@ implement `Reader` and `Writer`, where appropriate.\n \n use cast;\n use clone::Clone;\n+use c_str::ToCStr;\n use container::Container;\n use int;\n use iterator::Iterator;\n@@ -1040,8 +1041,8 @@ pub fn stdin() -> @Reader {\n }\n \n pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n-    let f = do path.to_str().as_c_str |pathbuf| {\n-        do \"rb\".as_c_str |modebuf| {\n+    let f = do path.to_c_str().with_ref |pathbuf| {\n+        do \"rb\".to_c_str().with_ref |modebuf| {\n             unsafe { libc::fopen(pathbuf, modebuf as *libc::c_char) }\n         }\n     };\n@@ -1290,9 +1291,8 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n         }\n     }\n     let fd = unsafe {\n-        do path.to_str().as_c_str |pathbuf| {\n-            libc::open(pathbuf, fflags,\n-                       (S_IRUSR | S_IWUSR) as c_int)\n+        do path.to_c_str().with_ref |pathbuf| {\n+            libc::open(pathbuf, fflags, (S_IRUSR | S_IWUSR) as c_int)\n         }\n     };\n     if fd < (0 as c_int) {\n@@ -1574,8 +1574,8 @@ pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n // FIXME: fileflags // #2004\n pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n     unsafe {\n-        let f = do path.to_str().as_c_str |pathbuf| {\n-            do \"w\".as_c_str |modebuf| {\n+        let f = do path.to_c_str().with_ref |pathbuf| {\n+            do \"w\".to_c_str().with_ref |modebuf| {\n                 libc::fopen(pathbuf, modebuf)\n             }\n         };\n@@ -1707,6 +1707,7 @@ pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     (*bytes).clone()\n }\n \n+#[cfg(stage0)]\n pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n@@ -1719,6 +1720,11 @@ pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n+    str::from_bytes(with_bytes_writer(f))\n+}\n+\n // Utility functions\n pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n    uint {"}, {"sha": "678704fe0983308ee45bd5a6afbc051f76834721", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -2652,7 +2652,7 @@ pub mod funcs {\n                 pub fn execvpe(c: *c_char, argv: **c_char, envp: **c_char)\n                                -> c_int;\n                 #[link_name = \"_getcwd\"]\n-                pub fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n+                pub fn getcwd(buf: *mut c_char, size: size_t) -> *c_char;\n                 #[link_name = \"_getpid\"]\n                 pub fn getpid() -> c_int;\n                 #[link_name = \"_isatty\"]\n@@ -2804,7 +2804,7 @@ pub mod funcs {\n                 pub fn execvp(c: *c_char, argv: **c_char) -> c_int;\n                 pub fn fork() -> pid_t;\n                 pub fn fpathconf(filedes: c_int, name: c_int) -> c_long;\n-                pub fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n+                pub fn getcwd(buf: *mut c_char, size: size_t) -> *c_char;\n                 pub fn getegid() -> gid_t;\n                 pub fn geteuid() -> uid_t;\n                 pub fn getgid() -> gid_t ;"}, {"sha": "008d59d5376772308d8e958f787a72245a45be68", "filename": "src/libstd/os.rs", "status": "modified", "additions": 114, "deletions": 104, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -28,7 +28,7 @@\n \n #[allow(missing_doc)];\n \n-use cast;\n+use c_str::ToCStr;\n use clone::Clone;\n use container::Container;\n use io;\n@@ -70,14 +70,15 @@ pub static TMPBUF_SZ : uint = 1000u;\n static BUF_BYTES : uint = 2048u;\n \n pub fn getcwd() -> Path {\n-    let buf = [0 as libc::c_char, ..BUF_BYTES];\n-    unsafe {\n-        if(0 as *libc::c_char == libc::getcwd(\n-            &buf[0],\n-            BUF_BYTES as libc::size_t)) {\n-            fail!();\n+    let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n+    do buf.as_mut_buf |buf, len| {\n+        unsafe {\n+            if libc::getcwd(buf, len as size_t).is_null() {\n+                fail!()\n+            }\n+\n+            Path(str::raw::from_c_str(buf as *c_char))\n         }\n-        Path(str::raw::from_c_str(&buf[0]))\n     }\n }\n \n@@ -88,7 +89,7 @@ pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool) -> Option<~str> {\n     do buf.as_mut_buf |b, sz| {\n         if f(b, sz as size_t) {\n             unsafe {\n-                Some(str::raw::from_buf(b as *u8))\n+                Some(str::raw::from_c_str(b as *c_char))\n             }\n         } else {\n             None\n@@ -238,11 +239,13 @@ pub fn env() -> ~[(~str,~str)] {\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n         do with_env_lock {\n-            let s = n.as_c_str(|s| libc::getenv(s as *libc::c_char));\n-            if ptr::null::<u8>() == cast::transmute(s) {\n+            let s = do n.to_c_str().with_ref |buf| {\n+                libc::getenv(buf)\n+            };\n+            if s.is_null() {\n                 None\n             } else {\n-                Some(str::raw::from_buf(cast::transmute(s)))\n+                Some(str::raw::from_c_str(s))\n             }\n         }\n     }\n@@ -271,8 +274,8 @@ pub fn getenv(n: &str) -> Option<~str> {\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n         do with_env_lock {\n-            do n.to_str().as_c_str |nbuf| {\n-                do v.to_str().as_c_str |vbuf| {\n+            do n.to_c_str().with_ref |nbuf| {\n+                do v.to_c_str().with_ref |vbuf| {\n                     libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n                 }\n             }\n@@ -303,7 +306,7 @@ pub fn unsetenv(n: &str) {\n     fn _unsetenv(n: &str) {\n         unsafe {\n             do with_env_lock {\n-                do n.to_str().as_c_str |nbuf| {\n+                do n.to_c_str().with_ref |nbuf| {\n                     libc::funcs::posix01::unistd::unsetenv(nbuf);\n                 }\n             }\n@@ -325,7 +328,7 @@ pub fn unsetenv(n: &str) {\n }\n \n pub fn fdopen(fd: c_int) -> *FILE {\n-    do \"r\".as_c_str |modebuf| {\n+    do \"r\".to_c_str().with_ref |modebuf| {\n         unsafe {\n             libc::fdopen(fd, modebuf)\n         }\n@@ -458,18 +461,18 @@ pub fn self_exe_path() -> Option<Path> {\n         unsafe {\n             use libc::funcs::posix01::unistd::readlink;\n \n-            let mut path_str = str::with_capacity(TMPBUF_SZ);\n-            let len = do path_str.as_c_str |buf| {\n-                let buf = buf as *mut c_char;\n-                do \"/proc/self/exe\".as_c_str |proc_self_buf| {\n-                    readlink(proc_self_buf, buf, TMPBUF_SZ as size_t)\n+            let mut path = [0 as c_char, .. TMPBUF_SZ];\n+\n+            do path.as_mut_buf |buf, len| {\n+                let len = do \"/proc/self/exe\".to_c_str().with_ref |proc_self_buf| {\n+                    readlink(proc_self_buf, buf, len as size_t) as uint\n+                };\n+\n+                if len == -1 {\n+                    None\n+                } else {\n+                    Some(str::raw::from_buf_len(buf as *u8, len))\n                 }\n-            };\n-            if len == -1 {\n-                None\n-            } else {\n-                str::raw::set_len(&mut path_str, len as uint);\n-                Some(path_str)\n             }\n         }\n     }\n@@ -590,7 +593,7 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n /// Indicates whether a path represents a directory\n pub fn path_is_dir(p: &Path) -> bool {\n     unsafe {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             rustrt::rust_path_is_dir(buf) != 0 as c_int\n         }\n     }\n@@ -599,7 +602,7 @@ pub fn path_is_dir(p: &Path) -> bool {\n /// Indicates whether a path exists\n pub fn path_exists(p: &Path) -> bool {\n     unsafe {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             rustrt::rust_path_exists(buf) != 0 as c_int\n         }\n     }\n@@ -634,15 +637,15 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n             use os::win32::as_utf16_p;\n             // FIXME: turn mode into something useful? #2623\n             do as_utf16_p(p.to_str()) |buf| {\n-                libc::CreateDirectoryW(buf, cast::transmute(0))\n+                libc::CreateDirectoryW(buf, ptr::mut_null())\n                     != (0 as libc::BOOL)\n             }\n         }\n     }\n \n     #[cfg(unix)]\n     fn mkdir(p: &Path, mode: c_int) -> bool {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             unsafe {\n                 libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n             }\n@@ -691,13 +694,15 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n             extern {\n                 fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n             }\n-            let input = p.to_str();\n             let mut strings = ~[];\n-            let input_ptr = ::cast::transmute(&input[0]);\n             debug!(\"os::list_dir -- BEFORE OPENDIR\");\n-            let dir_ptr = opendir(input_ptr);\n+\n+            let dir_ptr = do p.to_c_str().with_ref |buf| {\n+                opendir(buf)\n+            };\n+\n             if (dir_ptr as uint != 0) {\n-        debug!(\"os::list_dir -- opendir() SUCCESS\");\n+                debug!(\"os::list_dir -- opendir() SUCCESS\");\n                 let mut entry_ptr = readdir(dir_ptr);\n                 while (entry_ptr as uint != 0) {\n                     strings.push(str::raw::from_c_str(rust_list_dir_val(\n@@ -707,7 +712,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 closedir(dir_ptr);\n             }\n             else {\n-        debug!(\"os::list_dir -- opendir() FAILURE\");\n+                debug!(\"os::list_dir -- opendir() FAILURE\");\n             }\n             debug!(\n                 \"os::list_dir -- AFTER -- #: %?\",\n@@ -723,6 +728,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 FindNextFileW,\n                 FindClose,\n             };\n+            use libc::types::os::arch::extra::HANDLE;\n             use os::win32::{\n                 as_utf16_p\n             };\n@@ -737,10 +743,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n             do as_utf16_p(star(p).to_str()) |path_ptr| {\n                 let mut strings = ~[];\n                 let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-                let find_handle =\n-                    FindFirstFileW(\n-                        path_ptr,\n-                        ::cast::transmute(wfd_ptr));\n+                let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n                 if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n                     let mut more_files = 1 as libc::c_int;\n                     while more_files != 0 {\n@@ -754,9 +757,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                             let fp_str = str::from_utf16(fp_vec);\n                             strings.push(fp_str);\n                         }\n-                        more_files = FindNextFileW(\n-                            find_handle,\n-                            ::cast::transmute(wfd_ptr));\n+                        more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n                     }\n                     FindClose(find_handle);\n                     free(wfd_ptr)\n@@ -818,7 +819,7 @@ pub fn remove_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn rmdir(p: &Path) -> bool {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             unsafe {\n                 libc::rmdir(buf) == (0 as c_int)\n             }\n@@ -843,7 +844,7 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n-        do p.to_str().as_c_str |buf| {\n+        do p.to_c_str().with_ref |buf| {\n             unsafe {\n                 libc::chdir(buf) == (0 as c_int)\n             }\n@@ -871,8 +872,8 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n     #[cfg(unix)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n         unsafe {\n-            let istream = do from.to_str().as_c_str |fromp| {\n-                do \"rb\".as_c_str |modebuf| {\n+            let istream = do from.to_c_str().with_ref |fromp| {\n+                do \"rb\".to_c_str().with_ref |modebuf| {\n                     libc::fopen(fromp, modebuf)\n                 }\n             };\n@@ -883,8 +884,8 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             let from_mode = from.get_mode().expect(\"copy_file: couldn't get permissions \\\n                                                     for source file\");\n \n-            let ostream = do to.to_str().as_c_str |top| {\n-                do \"w+b\".as_c_str |modebuf| {\n+            let ostream = do to.to_c_str().with_ref |top| {\n+                do \"w+b\".to_c_str().with_ref |modebuf| {\n                     libc::fopen(top, modebuf)\n                 }\n             };\n@@ -916,7 +917,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             fclose(ostream);\n \n             // Give the new file the old file's permissions\n-            if do to.to_str().as_c_str |to_buf| {\n+            if do to.to_c_str().with_ref |to_buf| {\n                 libc::chmod(to_buf, from_mode as libc::mode_t)\n             } != 0 {\n                 return false; // should be a condition...\n@@ -943,7 +944,7 @@ pub fn remove_file(p: &Path) -> bool {\n     #[cfg(unix)]\n     fn unlink(p: &Path) -> bool {\n         unsafe {\n-            do p.to_str().as_c_str |buf| {\n+            do p.to_c_str().with_ref |buf| {\n                 libc::unlink(buf) == (0 as c_int)\n             }\n         }\n@@ -1035,14 +1036,15 @@ pub fn last_os_error() -> ~str {\n         }\n \n         let mut buf = [0 as c_char, ..TMPBUF_SZ];\n-        unsafe {\n-            let err = strerror_r(errno() as c_int, &mut buf[0],\n-                                 TMPBUF_SZ as size_t);\n-            if err < 0 {\n-                fail!(\"strerror_r failure\");\n-            }\n \n-            str::raw::from_c_str(&buf[0])\n+        do buf.as_mut_buf |buf, len| {\n+            unsafe {\n+                if strerror_r(errno() as c_int, buf, len as size_t) < 0 {\n+                    fail!(\"strerror_r failure\");\n+                }\n+\n+                str::raw::from_c_str(buf as *c_char)\n+            }\n         }\n     }\n \n@@ -1068,23 +1070,31 @@ pub fn last_os_error() -> ~str {\n         static FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\n         static FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n \n-        let mut buf = [0 as c_char, ..TMPBUF_SZ];\n-\n         // This value is calculated from the macro\n         // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n         let langId = 0x0800 as DWORD;\n         let err = errno() as DWORD;\n+\n+        let mut buf = [0 as c_char, ..TMPBUF_SZ];\n+\n         unsafe {\n-            let res = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |\n-                                     FORMAT_MESSAGE_IGNORE_INSERTS,\n-                                     ptr::mut_null(), err, langId,\n-                                     &mut buf[0], TMPBUF_SZ as DWORD,\n-                                     ptr::null());\n-            if res == 0 {\n-                fail!(\"[%?] FormatMessage failure\", errno());\n+            do buf.as_mut_buf |buf, len| {\n+                let res = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |\n+                                         FORMAT_MESSAGE_IGNORE_INSERTS,\n+                                         ptr::mut_null(),\n+                                         err,\n+                                         langId,\n+                                         buf,\n+                                         len as DWORD,\n+                                         ptr::null());\n+                if res == 0 {\n+                    fail!(\"[%?] FormatMessage failure\", errno());\n+                }\n             }\n \n-            str::raw::from_c_str(&buf[0])\n+            do buf.as_imm_buf |buf, _len| {\n+                str::raw::from_c_str(buf)\n+            }\n         }\n     }\n \n@@ -1160,7 +1170,7 @@ pub fn real_args() -> ~[~str] {\n     }\n \n     unsafe {\n-        LocalFree(cast::transmute(szArgList));\n+        LocalFree(szArgList as *c_void);\n     }\n \n     return args;\n@@ -1272,7 +1282,7 @@ pub fn glob(pattern: &str) -> ~[Path] {\n     }\n \n     let mut g = default_glob_t();\n-    do pattern.as_c_str |c_pattern| {\n+    do pattern.to_c_str().with_ref |c_pattern| {\n         unsafe { libc::glob(c_pattern, 0, ptr::null(), &mut g) }\n     };\n     do(|| {\n@@ -1677,6 +1687,7 @@ pub mod consts {\n \n #[cfg(test)]\n mod tests {\n+    use c_str::ToCStr;\n     use libc::{c_int, c_void, size_t};\n     use libc;\n     use option::Some;\n@@ -1689,7 +1700,6 @@ mod tests {\n     use rand;\n     use run;\n     use str::StrSlice;\n-    use vec::CopyableVector;\n     use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n \n@@ -1912,39 +1922,39 @@ mod tests {\n     #[test]\n     fn copy_file_ok() {\n         unsafe {\n-          let tempdir = getcwd(); // would like to use $TMPDIR,\n-                                  // doesn't seem to work on Linux\n-          assert!((tempdir.to_str().len() > 0u));\n-          let input = tempdir.push(\"in.txt\");\n-          let out = tempdir.push(\"out.txt\");\n-\n-          /* Write the temp input file */\n-            let ostream = do input.to_str().as_c_str |fromp| {\n-                do \"w+b\".as_c_str |modebuf| {\n+            let tempdir = getcwd(); // would like to use $TMPDIR,\n+                                    // doesn't seem to work on Linux\n+            assert!((tempdir.to_str().len() > 0u));\n+            let input = tempdir.push(\"in.txt\");\n+            let out = tempdir.push(\"out.txt\");\n+\n+            /* Write the temp input file */\n+            let ostream = do input.to_c_str().with_ref |fromp| {\n+                do \"w+b\".to_c_str().with_ref |modebuf| {\n                     libc::fopen(fromp, modebuf)\n                 }\n-          };\n-          assert!((ostream as uint != 0u));\n-          let s = ~\"hello\";\n-          let mut buf = s.as_bytes_with_null().to_owned();\n-          let len = buf.len();\n-          do buf.as_mut_buf |b, _len| {\n-              assert_eq!(libc::fwrite(b as *c_void, 1u as size_t,\n-                                      (s.len() + 1u) as size_t, ostream),\n-                         len as size_t)\n-          }\n-          assert_eq!(libc::fclose(ostream), (0u as c_int));\n-          let in_mode = input.get_mode();\n-          let rs = os::copy_file(&input, &out);\n-          if (!os::path_exists(&input)) {\n-            fail!(\"%s doesn't exist\", input.to_str());\n-          }\n-          assert!((rs));\n-          let rslt = run::process_status(\"diff\", [input.to_str(), out.to_str()]);\n-          assert_eq!(rslt, 0);\n-          assert_eq!(out.get_mode(), in_mode);\n-          assert!((remove_file(&input)));\n-          assert!((remove_file(&out)));\n+            };\n+            assert!((ostream as uint != 0u));\n+            let s = ~\"hello\";\n+            do \"hello\".to_c_str().with_ref |buf| {\n+                let write_len = libc::fwrite(buf as *c_void,\n+                                             1u as size_t,\n+                                             (s.len() + 1u) as size_t,\n+                                             ostream);\n+                assert_eq!(write_len, (s.len() + 1) as size_t)\n+            }\n+            assert_eq!(libc::fclose(ostream), (0u as c_int));\n+            let in_mode = input.get_mode();\n+            let rs = os::copy_file(&input, &out);\n+            if (!os::path_exists(&input)) {\n+                fail!(\"%s doesn't exist\", input.to_str());\n+            }\n+            assert!((rs));\n+            let rslt = run::process_status(\"diff\", [input.to_str(), out.to_str()]);\n+            assert_eq!(rslt, 0);\n+            assert_eq!(out.get_mode(), in_mode);\n+            assert!((remove_file(&input)));\n+            assert!((remove_file(&out)));\n         }\n     }\n \n@@ -2003,11 +2013,11 @@ mod tests {\n         remove_file(&path);\n \n         let fd = unsafe {\n-            let fd = do path.to_str().as_c_str |path| {\n+            let fd = do path.to_c_str().with_ref |path| {\n                 open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n             };\n             lseek_(fd, size);\n-            do \"x\".as_c_str |x| {\n+            do \"x\".to_c_str().with_ref |x| {\n                 assert!(write(fd, x as *c_void, 1) == 1);\n             }\n             fd"}, {"sha": "14844e24006c5364b5f6d809bd557e0c28dc5ff4", "filename": "src/libstd/path.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -16,9 +16,11 @@ Cross-platform file path handling\n \n #[allow(missing_doc)];\n \n+use c_str::ToCStr;\n+use c_str;\n use clone::Clone;\n-use container::Container;\n use cmp::Eq;\n+use container::Container;\n use iterator::{Iterator, IteratorUtil, range};\n use libc;\n use num;\n@@ -379,7 +381,7 @@ mod stat {\n #[cfg(target_os = \"win32\")]\n impl WindowsPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n-        do self.to_str().as_c_str |buf| {\n+        do self.to_c_str().with_ref |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::stat(buf, &mut st) } {\n                 0 => Some(st),\n@@ -413,7 +415,7 @@ impl WindowsPath {\n #[cfg(not(target_os = \"win32\"))]\n impl PosixPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n-        do self.to_str().as_c_str |buf| {\n+        do self.to_c_str().with_ref |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::stat(buf as *libc::c_char, &mut st) } {\n                 0 => Some(st),\n@@ -491,7 +493,7 @@ impl PosixPath {\n #[cfg(unix)]\n impl PosixPath {\n     pub fn lstat(&self) -> Option<libc::stat> {\n-        do self.to_str().as_c_str |buf| {\n+        do self.to_c_str().with_ref |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::lstat(buf, &mut st) } {\n                 0 => Some(st),\n@@ -563,6 +565,12 @@ impl ToStr for PosixPath {\n     }\n }\n \n+impl ToCStr for PosixPath {\n+    fn to_c_str(&self) -> c_str::CString {\n+        self.to_str().to_c_str()\n+    }\n+}\n+\n // FIXME (#3227): when default methods in traits are working, de-duplicate\n // PosixPath and WindowsPath, most of their methods are common.\n impl GenericPath for PosixPath {\n@@ -769,6 +777,11 @@ impl ToStr for WindowsPath {\n     }\n }\n \n+impl c_str::ToCStr for WindowsPath {\n+    fn to_c_str(&self) -> c_str::CString {\n+        self.to_str().to_c_str()\n+    }\n+}\n \n impl GenericPath for WindowsPath {\n     fn from_str(s: &str) -> WindowsPath {"}, {"sha": "f035e61fa1e08a6db8c480f727bcee5dba082086", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -43,6 +43,7 @@ pub use io::{print, println};\n pub use iterator::range;\n \n // Reexported types and traits\n+pub use c_str::ToCStr;\n pub use clone::{Clone, DeepClone};\n pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n pub use char::Char;\n@@ -64,7 +65,7 @@ pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::RawPtr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n-pub use str::{Str, StrVector, StrSlice, OwnedStr, NullTerminatedStr};\n+pub use str::{Str, StrVector, StrSlice, OwnedStr};\n pub use from_str::FromStr;\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};"}, {"sha": "26653a51d66182dedf95b01b2d4345fec6652d82", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 63, "deletions": 55, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -456,6 +456,7 @@ pub mod ptr_tests {\n     use super::*;\n     use prelude::*;\n \n+    use c_str::ToCStr;\n     use cast;\n     use libc;\n     use str;\n@@ -502,22 +503,20 @@ pub mod ptr_tests {\n     fn test_position() {\n         use libc::c_char;\n \n-        let s = ~\"hello\";\n-        unsafe {\n-            assert!(2u == s.as_c_str(|p| position(p, |c| *c == 'l' as c_char)));\n-            assert!(4u == s.as_c_str(|p| position(p, |c| *c == 'o' as c_char)));\n-            assert!(5u == s.as_c_str(|p| position(p, |c| *c == 0 as c_char)));\n+        do \"hello\".to_c_str().with_ref |p| {\n+            unsafe {\n+                assert!(2u == position(p, |c| *c == 'l' as c_char));\n+                assert!(4u == position(p, |c| *c == 'o' as c_char));\n+                assert!(5u == position(p, |c| *c == 0 as c_char));\n+            }\n         }\n     }\n \n     #[test]\n     fn test_buf_len() {\n-        let s0 = ~\"hello\";\n-        let s1 = ~\"there\";\n-        let s2 = ~\"thing\";\n-        do s0.as_c_str |p0| {\n-            do s1.as_c_str |p1| {\n-                do s2.as_c_str |p2| {\n+        do \"hello\".to_c_str().with_ref |p0| {\n+            do \"there\".to_c_str().with_ref |p1| {\n+                do \"thing\".to_c_str().with_ref |p2| {\n                     let v = ~[p0, p1, p2, null()];\n                     do v.as_imm_buf |vp, len| {\n                         assert_eq!(unsafe { buf_len(vp) }, 3u);\n@@ -621,66 +620,75 @@ pub mod ptr_tests {\n     #[test]\n     fn test_ptr_array_each_with_len() {\n         unsafe {\n-            let one = ~\"oneOne\";\n-            let two = ~\"twoTwo\";\n-            let three = ~\"threeThree\";\n-            let arr: ~[*i8] = ~[\n-                ::cast::transmute(&one[0]),\n-                ::cast::transmute(&two[0]),\n-                ::cast::transmute(&three[0]),\n+            let one = \"oneOne\".to_c_str();\n+            let two = \"twoTwo\".to_c_str();\n+            let three = \"threeThree\".to_c_str();\n+            let arr = ~[\n+                one.with_ref(|buf| buf),\n+                two.with_ref(|buf| buf),\n+                three.with_ref(|buf| buf),\n             ];\n             let expected_arr = [\n                 one, two, three\n             ];\n-            let arr_ptr = &arr[0];\n-            let mut ctr = 0;\n-            let mut iteration_count = 0;\n-            array_each_with_len(arr_ptr, arr.len(),\n-                                |e| {\n-                                         let actual = str::raw::from_c_str(e);\n-                                         let expected = expected_arr[ctr].clone();\n-                                         debug!(\n-                                             \"test_ptr_array_each e: %s, a: %s\",\n-                                             expected, actual);\n-                                         assert_eq!(actual, expected);\n-                                         ctr += 1;\n-                                         iteration_count += 1;\n-                                     });\n-            assert_eq!(iteration_count, 3u);\n+\n+            do arr.as_imm_buf |arr_ptr, arr_len| {\n+                let mut ctr = 0;\n+                let mut iteration_count = 0;\n+                do array_each_with_len(arr_ptr, arr_len) |e| {\n+                     let actual = str::raw::from_c_str(e);\n+                     let expected = do expected_arr[ctr].with_ref |buf| {\n+                         str::raw::from_c_str(buf)\n+                     };\n+                     debug!(\n+                         \"test_ptr_array_each_with_len e: %s, a: %s\",\n+                         expected, actual);\n+                     assert_eq!(actual, expected);\n+                     ctr += 1;\n+                     iteration_count += 1;\n+                 }\n+                assert_eq!(iteration_count, 3u);\n+            }\n         }\n     }\n+\n     #[test]\n     fn test_ptr_array_each() {\n         unsafe {\n-            let one = ~\"oneOne\";\n-            let two = ~\"twoTwo\";\n-            let three = ~\"threeThree\";\n-            let arr: ~[*i8] = ~[\n-                ::cast::transmute(&one[0]),\n-                ::cast::transmute(&two[0]),\n-                ::cast::transmute(&three[0]),\n+            let one = \"oneOne\".to_c_str();\n+            let two = \"twoTwo\".to_c_str();\n+            let three = \"threeThree\".to_c_str();\n+            let arr = ~[\n+                one.with_ref(|buf| buf),\n+                two.with_ref(|buf| buf),\n+                three.with_ref(|buf| buf),\n                 // fake a null terminator\n-                0 as *i8\n+                null(),\n             ];\n             let expected_arr = [\n                 one, two, three\n             ];\n-            let arr_ptr = &arr[0];\n-            let mut ctr = 0;\n-            let mut iteration_count = 0;\n-            array_each(arr_ptr, |e| {\n-                let actual = str::raw::from_c_str(e);\n-                let expected = expected_arr[ctr].clone();\n-                debug!(\n-                    \"test_ptr_array_each e: %s, a: %s\",\n-                    expected, actual);\n-                assert_eq!(actual, expected);\n-                ctr += 1;\n-                iteration_count += 1;\n-            });\n-            assert_eq!(iteration_count, 3);\n+\n+            do arr.as_imm_buf |arr_ptr, arr_len| {\n+                let mut ctr = 0;\n+                let mut iteration_count = 0;\n+                do array_each(arr_ptr) |e| {\n+                     let actual = str::raw::from_c_str(e);\n+                     let expected = do expected_arr[ctr].with_ref |buf| {\n+                         str::raw::from_c_str(buf)\n+                     };\n+                     debug!(\n+                         \"test_ptr_array_each e: %s, a: %s\",\n+                         expected, actual);\n+                     assert_eq!(actual, expected);\n+                     ctr += 1;\n+                     iteration_count += 1;\n+                 }\n+                assert_eq!(iteration_count, 3);\n+            }\n         }\n     }\n+\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]"}, {"sha": "f620a7347a4cd31bf403146bfa4c62c2ceff9a5e", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use c_str::ToCStr;\n use cast::transmute;\n use libc::{c_char, size_t, STDERR_FILENO};\n use io;\n@@ -51,8 +52,8 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n             let msg = \"borrowed\";\n-            do msg.as_c_str |msg_p| {\n-                sys::begin_unwind_(msg_p as *c_char, file, line);\n+            do msg.to_c_str().with_ref |msg_p| {\n+                sys::begin_unwind_(msg_p, file, line);\n             }\n         }\n         Some(borrow_list) => { // recording borrows\n@@ -67,8 +68,8 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n                     sep = \" and at \";\n                 }\n             }\n-            do msg.as_c_str |msg_p| {\n-                sys::begin_unwind_(msg_p as *c_char, file, line)\n+            do msg.to_c_str().with_ref |msg_p| {\n+                sys::begin_unwind_(msg_p, file, line)\n             }\n         }\n     }\n@@ -207,8 +208,8 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n             let br = borrow_list.pop();\n             if br.box != a || br.file != file || br.line != line {\n                 let err = fmt!(\"wrong borrow found, br=%?\", br);\n-                do err.as_c_str |msg_p| {\n-                    sys::begin_unwind_(msg_p as *c_char, file, line)\n+                do err.to_c_str().with_ref |msg_p| {\n+                    sys::begin_unwind_(msg_p, file, line)\n                 }\n             }\n             borrow_list"}, {"sha": "117795f6c90e0ab49860e92cd73c6277fceea12a", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -58,15 +58,15 @@ impl Logger for StdErrLogger {\n /// Configure logging by traversing the crate map and setting the\n /// per-module global logging flags based on the logging spec\n pub fn init(crate_map: *u8) {\n+    use c_str::ToCStr;\n     use os;\n-    use str::StrSlice;\n     use ptr;\n     use option::{Some, None};\n \n     let log_spec = os::getenv(\"RUST_LOG\");\n     match log_spec {\n         Some(spec) => {\n-            do spec.as_c_str |buf| {\n+            do spec.to_c_str().with_ref |buf| {\n                 unsafe { rust_update_log_settings(crate_map, buf) }\n             }\n         }"}, {"sha": "038ebad3540aecd29657474dffaacaaf8a2ab365", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -8,26 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::*;\n-use result::*;\n-use ops::Drop;\n-use cell::Cell;\n-use cast;\n+use c_str::ToCStr;\n use cast::transmute;\n+use cast;\n+use cell::Cell;\n use clone::Clone;\n use libc::{c_int, c_uint, c_void};\n+use ops::Drop;\n+use option::*;\n use ptr;\n+use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n-use rt::uv::*;\n-use rt::uv::idle::IdleWatcher;\n-use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n+use rt::io::{standard_error, OtherIoError};\n+use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::Scheduler;\n-use rt::io::{standard_error, OtherIoError};\n use rt::tube::Tube;\n-use rt::local::Local;\n-use str::StrSlice;\n+use rt::uv::*;\n+use rt::uv::idle::IdleWatcher;\n+use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use unstable::sync::Exclusive;\n \n #[cfg(test)] use container::Container;\n@@ -654,7 +654,7 @@ impl RtioUdpSocket for UvUdpSocket {\n \n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n         let r = unsafe {\n-            do multi.to_str().as_c_str |m_addr| {\n+            do multi.to_str().to_c_str().with_ref |m_addr| {\n                 uvll::udp_set_membership(self.native_handle(), m_addr,\n                                          ptr::null(), uvll::UV_JOIN_GROUP)\n             }\n@@ -668,7 +668,7 @@ impl RtioUdpSocket for UvUdpSocket {\n \n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n         let r = unsafe {\n-            do multi.to_str().as_c_str |m_addr| {\n+            do multi.to_str().to_c_str().with_ref |m_addr| {\n                 uvll::udp_set_membership(self.native_handle(), m_addr,\n                                          ptr::null(), uvll::UV_LEAVE_GROUP)\n             }"}, {"sha": "e240395a495d36f02f60cc0daadd06c58353c773", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -29,6 +29,7 @@\n \n #[allow(non_camel_case_types)]; // C types\n \n+use c_str::ToCStr;\n use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n use libc::{malloc, free};\n use libc;\n@@ -372,12 +373,12 @@ pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n }\n \n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n-    do ip.as_c_str |ip_buf| {\n+    do ip.to_c_str().with_ref |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }\n pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n-    do ip.as_c_str |ip_buf| {\n+    do ip.to_c_str().with_ref |ip_buf| {\n         rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }"}, {"sha": "31e317604c77e073ba75edde11acddec9d970e13", "filename": "src/libstd/run.rs", "status": "modified", "additions": 66, "deletions": 46, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -12,6 +12,7 @@\n \n #[allow(missing_doc)];\n \n+use c_str::ToCStr;\n use cast;\n use clone::Clone;\n use comm::{stream, SharedChan, GenericChan, GenericPort};\n@@ -505,7 +506,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         do with_envp(env) |envp| {\n             do with_dirp(dir) |dirp| {\n-                do cmd.as_c_str |cmdp| {\n+                do cmd.to_c_str().with_ref |cmdp| {\n                     let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n                                                  0, envp, dirp, &mut si, &mut pi);\n@@ -688,46 +689,62 @@ fn spawn_process_os(prog: &str, args: &[~str],\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str],\n-                cb: &fn(**libc::c_char) -> T) -> T {\n-    let mut argptrs = ~[prog.as_c_str(|b| b)];\n-    let mut tmps = ~[];\n+fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n+    use vec;\n+\n+    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n+    // a reference to the intermediary byte buffers. So first build an array to\n+    // hold all the ~[u8] byte strings.\n+    let mut tmps = vec::with_capacity(args.len() + 1);\n+\n+    tmps.push(prog.to_c_str());\n+\n     for arg in args.iter() {\n-        let t = @(*arg).clone();\n-        tmps.push(t);\n-        argptrs.push(t.as_c_str(|b| b));\n+        tmps.push(arg.to_c_str());\n     }\n-    argptrs.push(ptr::null());\n-    argptrs.as_imm_buf(|buf, _len| cb(buf))\n+\n+    // Next, convert each of the byte strings into a pointer. This is\n+    // technically unsafe as the caller could leak these pointers out of our\n+    // scope.\n+    let mut ptrs = do tmps.map |tmp| {\n+        tmp.with_ref(|buf| buf)\n+    };\n+\n+    // Finally, make sure we add a null pointer.\n+    ptrs.push(ptr::null());\n+\n+    ptrs.as_imm_buf(|buf, _| cb(buf))\n }\n \n #[cfg(unix)]\n fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n-    // On posixy systems we can pass a char** for envp, which is\n-    // a null-terminated array of \"k=v\\n\" strings.\n+    use vec;\n+\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n+    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n     match env {\n-      Some(es) => {\n-        let mut tmps = ~[];\n-        let mut ptrs = ~[];\n-\n-        for pair in es.iter() {\n-            // Use of match here is just to workaround limitations\n-            // in the stage0 irrefutable pattern impl.\n-            match pair {\n-                &(ref k, ref v) => {\n-                    let kv = @fmt!(\"%s=%s\", *k, *v);\n-                    tmps.push(kv);\n-                    ptrs.push(kv.as_c_str(|b| b));\n-                }\n+        Some(env) => {\n+            let mut tmps = vec::with_capacity(env.len());\n+\n+            for pair in env.iter() {\n+                // Use of match here is just to workaround limitations\n+                // in the stage0 irrefutable pattern impl.\n+                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n+                tmps.push(kv.to_c_str());\n             }\n-        }\n \n-        ptrs.push(ptr::null());\n-        ptrs.as_imm_buf(|p, _len|\n-            unsafe { cb(::cast::transmute(p)) }\n-        )\n-      }\n-      _ => cb(ptr::null())\n+            // Once again, this is unsafe.\n+            let mut ptrs = do tmps.map |tmp| {\n+                tmp.with_ref(|buf| buf)\n+            };\n+            ptrs.push(ptr::null());\n+\n+            do ptrs.as_imm_buf |buf, _| {\n+                unsafe { cb(cast::transmute(buf)) }\n+            }\n+        }\n+        _ => cb(ptr::null())\n     }\n }\n \n@@ -737,25 +754,28 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n     match env {\n-      Some(es) => {\n-        let mut blk = ~[];\n-        for pair in es.iter() {\n-            let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n-            blk.push_all(kv.to_bytes_with_null());\n+        Some(env) => {\n+            let mut blk = ~[];\n+\n+            for pair in env.iter() {\n+                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n+                blk.push_all(kv.as_bytes());\n+                blk.push(0);\n+            }\n+\n+            blk.push(0);\n+\n+            do blk.as_imm_buf |p, _len| {\n+                unsafe { cb(cast::transmute(p)) }\n+            }\n         }\n-        blk.push(0);\n-        blk.as_imm_buf(|p, _len|\n-            unsafe { cb(::cast::transmute(p)) }\n-        )\n-      }\n-      _ => cb(ptr::mut_null())\n+        _ => cb(ptr::mut_null())\n     }\n }\n \n-fn with_dirp<T>(d: Option<&Path>,\n-                cb: &fn(*libc::c_char) -> T) -> T {\n+fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n     match d {\n-      Some(dir) => dir.to_str().as_c_str(cb),\n+      Some(dir) => dir.to_c_str().with_ref(|buf| cb(buf)),\n       None => cb(ptr::null())\n     }\n }"}, {"sha": "aa0bb905e9a68fb99d5933171434a21d73d4c6ef", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -170,6 +170,7 @@ pub mod local_data;\n /* Runtime and platform support */\n \n pub mod libc;\n+pub mod c_str;\n pub mod os;\n pub mod path;\n pub mod rand;"}, {"sha": "b72e5a87c6d48f052044629d907c32502c91948f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 389, "deletions": 210, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -33,6 +33,7 @@ use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n+#[cfg(stage0)]\n use unstable::raw::Repr;\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n@@ -83,21 +84,6 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n     }\n }\n \n-/// Convert a vector of bytes to a UTF-8 string.\n-/// The vector needs to be one byte longer than the string, and end with a 0 byte.\n-///\n-/// Compared to `from_bytes()`, this fn doesn't need to allocate a new owned str.\n-///\n-/// # Failure\n-///\n-/// Fails if invalid UTF-8\n-/// Fails if not null terminated\n-pub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str {\n-    assert_eq!(vv[vv.len() - 1], 0);\n-    assert!(is_utf8(vv));\n-    return unsafe { raw::from_bytes_with_null(vv) };\n-}\n-\n /// Converts a vector to a string slice without performing any allocations.\n ///\n /// Once the slice has been validated as utf-8, it is transmuted in-place and\n@@ -106,6 +92,7 @@ pub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str {\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n+#[cfg(stage0)]\n pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     unsafe {\n         assert!(is_utf8(vector));\n@@ -115,6 +102,20 @@ pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     }\n }\n \n+/// Converts a vector to a string slice without performing any allocations.\n+///\n+/// Once the slice has been validated as utf-8, it is transmuted in-place and\n+/// returned as a '&str' instead of a '&[u8]'\n+///\n+/// # Failure\n+///\n+/// Fails if invalid UTF-8\n+#[cfg(not(stage0))]\n+pub fn from_bytes_slice<'a>(v: &'a [u8]) -> &'a str {\n+    assert!(is_utf8(v));\n+    unsafe { cast::transmute(v) }\n+}\n+\n impl ToStr for ~str {\n     #[inline]\n     fn to_str(&self) -> ~str { self.to_owned() }\n@@ -133,11 +134,23 @@ impl ToStr for @str {\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n+#[cfg(stage0)]\n pub fn from_byte(b: u8) -> ~str {\n     assert!(b < 128u8);\n     unsafe { cast::transmute(~[b, 0u8]) }\n }\n \n+/// Convert a byte to a UTF-8 string\n+///\n+/// # Failure\n+///\n+/// Fails if invalid UTF-8\n+#[cfg(not(stage0))]\n+pub fn from_byte(b: u8) -> ~str {\n+    assert!(b < 128u8);\n+    unsafe { ::cast::transmute(~[b]) }\n+}\n+\n /// Convert a char to a string\n pub fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n@@ -168,6 +181,7 @@ pub trait StrVector {\n \n impl<'self, S: Str> StrVector for &'self [S] {\n     /// Concatenate a vector of strings.\n+    #[cfg(stage0)]\n     pub fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -191,7 +205,32 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         s\n     }\n \n+    /// Concatenate a vector of strings.\n+    #[cfg(not(stage0))]\n+    pub fn concat(&self) -> ~str {\n+        if self.is_empty() { return ~\"\"; }\n+\n+        let len = self.iter().transform(|s| s.as_slice().len()).sum();\n+\n+        let mut s = with_capacity(len);\n+\n+        unsafe {\n+            do s.as_mut_buf |buf, _| {\n+                let mut buf = buf;\n+                for ss in self.iter() {\n+                    do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n+                        ptr::copy_memory(buf, ssbuf, sslen);\n+                        buf = buf.offset(sslen as int);\n+                    }\n+                }\n+            }\n+            raw::set_len(&mut s, len);\n+        }\n+        s\n+    }\n+\n     /// Concatenate a vector of strings, placing a given separator between each.\n+    #[cfg(stage0)]\n     pub fn connect(&self, sep: &str) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -230,6 +269,45 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         }\n         s\n     }\n+\n+    /// Concatenate a vector of strings, placing a given separator between each.\n+    #[cfg(not(stage0))]\n+    pub fn connect(&self, sep: &str) -> ~str {\n+        if self.is_empty() { return ~\"\"; }\n+\n+        // concat is faster\n+        if sep.is_empty() { return self.concat(); }\n+\n+        // this is wrong without the guarantee that `self` is non-empty\n+        let len = sep.len() * (self.len() - 1)\n+            + self.iter().transform(|s| s.as_slice().len()).sum();\n+        let mut s = ~\"\";\n+        let mut first = true;\n+\n+        s.reserve(len);\n+\n+        unsafe {\n+            do s.as_mut_buf |buf, _| {\n+                do sep.as_imm_buf |sepbuf, seplen| {\n+                    let mut buf = buf;\n+                    for ss in self.iter() {\n+                        do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n+                            if first {\n+                                first = false;\n+                            } else {\n+                                ptr::copy_memory(buf, sepbuf, seplen);\n+                                buf = buf.offset(seplen as int);\n+                            }\n+                            ptr::copy_memory(buf, ssbuf, sslen);\n+                            buf = buf.offset(sslen as int);\n+                        }\n+                    }\n+                }\n+            }\n+            raw::set_len(&mut s, len);\n+        }\n+        s\n+    }\n }\n \n /// Something that can be used to compare against a character\n@@ -500,7 +578,7 @@ Section: Comparing strings\n */\n \n /// Bytewise slice equality\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n@@ -518,7 +596,28 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n     }\n }\n \n-#[cfg(test)]\n+/// Bytewise slice equality\n+#[cfg(not(test), not(stage0))]\n+#[lang=\"str_eq\"]\n+#[inline]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    do a.as_imm_buf |ap, alen| {\n+        do b.as_imm_buf |bp, blen| {\n+            if (alen != blen) { false }\n+            else {\n+                unsafe {\n+                    libc::memcmp(ap as *libc::c_void,\n+                                 bp as *libc::c_void,\n+                                 alen as libc::size_t) == 0\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Bytewise slice equality\n+#[cfg(test, stage0)]\n+#[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     do a.as_imm_buf |ap, alen| {\n@@ -535,6 +634,24 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n     }\n }\n \n+/// Bytewise slice equality\n+#[cfg(test, not(stage0))]\n+#[inline]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    do a.as_imm_buf |ap, alen| {\n+        do b.as_imm_buf |bp, blen| {\n+            if (alen != blen) { false }\n+            else {\n+                unsafe {\n+                    libc::memcmp(ap as *libc::c_void,\n+                                 bp as *libc::c_void,\n+                                 alen as libc::size_t) == 0\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Bytewise string equality\n #[cfg(not(test))]\n #[lang=\"uniq_str_eq\"]\n@@ -800,20 +917,12 @@ pub mod raw {\n     use str::is_utf8;\n     use vec;\n     use vec::MutableVector;\n-    use unstable::raw::{Slice, String};\n-\n-    /// Create a Rust string from a null-terminated *u8 buffer\n-    pub unsafe fn from_buf(buf: *u8) -> ~str {\n-        let mut curr = buf;\n-        let mut i = 0u;\n-        while *curr != 0u8 {\n-            i += 1u;\n-            curr = ptr::offset(buf, i as int);\n-        }\n-        return from_buf_len(buf, i);\n-    }\n+    use unstable::raw::Slice;\n+    #[cfg(stage0)]\n+    use unstable::raw::String;\n \n     /// Create a Rust string from a *u8 buffer of the given length\n+    #[cfg(stage0)]\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n         v.as_mut_buf(|vbuf, _len| {\n@@ -823,17 +932,31 @@ pub mod raw {\n         v.push(0u8);\n \n         assert!(is_utf8(v));\n-        return cast::transmute(v);\n+        cast::transmute(v)\n     }\n \n-    /// Create a Rust string from a null-terminated C string\n-    pub unsafe fn from_c_str(c_str: *libc::c_char) -> ~str {\n-        from_buf(c_str as *u8)\n+    /// Create a Rust string from a *u8 buffer of the given length\n+    #[cfg(not(stage0))]\n+    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n+        let mut v: ~[u8] = vec::with_capacity(len);\n+        do v.as_mut_buf |vbuf, _len| {\n+            ptr::copy_memory(vbuf, buf as *u8, len)\n+        };\n+        vec::raw::set_len(&mut v, len);\n+\n+        assert!(is_utf8(v));\n+        ::cast::transmute(v)\n     }\n \n-    /// Create a Rust string from a `*c_char` buffer of the given length\n-    pub unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> ~str {\n-        from_buf_len(c_str as *u8, len)\n+    /// Create a Rust string from a null-terminated C string\n+    pub unsafe fn from_c_str(buf: *libc::c_char) -> ~str {\n+        let mut curr = buf;\n+        let mut i = 0;\n+        while *curr != 0 {\n+            i += 1;\n+            curr = ptr::offset(buf, i);\n+        }\n+        from_buf_len(buf as *u8, i as uint)\n     }\n \n     /// Converts a vector of bytes to a new owned string.\n@@ -845,15 +968,17 @@ pub mod raw {\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n     /// that the utf-8-ness of the vector has already been validated\n+    #[cfg(stage0)]\n     pub unsafe fn from_bytes_owned(mut v: ~[u8]) -> ~str {\n         v.push(0u8);\n         cast::transmute(v)\n     }\n \n-    /// Converts a vector of bytes to a string.\n-    /// The byte slice needs to contain valid utf8 and needs to be one byte longer than\n-    /// the string, if possible ending in a 0 byte.\n-    pub unsafe fn from_bytes_with_null<'a>(v: &'a [u8]) -> &'a str {\n+    /// Converts an owned vector of bytes to a new owned string. This assumes\n+    /// that the utf-8-ness of the vector has already been validated\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub unsafe fn from_bytes_owned(v: ~[u8]) -> ~str {\n         cast::transmute(v)\n     }\n \n@@ -863,6 +988,7 @@ pub mod raw {\n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n     /// invalidated later.\n+    #[cfg(stage0)]\n     pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n         let s = s as *u8;\n         let mut curr = s;\n@@ -876,6 +1002,23 @@ pub mod raw {\n         cast::transmute(v)\n     }\n \n+    /// Form a slice from a C string. Unsafe because the caller must ensure the\n+    /// C string has the static lifetime, or else the return value may be\n+    /// invalidated later.\n+    #[cfg(not(stage0))]\n+    pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s;\n+        let mut len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = ptr::offset(s, len as int);\n+        }\n+        let v = Slice { data: s, len: len };\n+        assert!(is_utf8(::cast::transmute(v)));\n+        ::cast::transmute(v)\n+    }\n+\n     /// Takes a bytewise (not UTF-8) slice from a string.\n     ///\n     /// Returns the substring from [`begin`..`end`).\n@@ -884,6 +1027,7 @@ pub mod raw {\n     ///\n     /// If begin is greater than end.\n     /// If end is greater than the length of the string.\n+    #[cfg(stage0)]\n     #[inline]\n     pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n         do s.as_imm_buf |sbuf, n| {\n@@ -897,16 +1041,47 @@ pub mod raw {\n         }\n     }\n \n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// # Failure\n+    ///\n+    /// If begin is greater than end.\n+    /// If end is greater than the length of the string.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n+        do s.as_imm_buf |sbuf, n| {\n+             assert!((begin <= end));\n+             assert!((end <= n));\n+\n+             cast::transmute(Slice {\n+                 data: ptr::offset(sbuf, begin as int),\n+                 len: end - begin,\n+             })\n+        }\n+    }\n+\n     /// Appends a byte to a string. (Not UTF-8 safe).\n+    #[cfg(stage0)]\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n         let new_len = s.len() + 1;\n         s.reserve_at_least(new_len);\n         do s.as_mut_buf |buf, len| {\n-            *ptr::mut_offset(buf, (len-1) as int) = b;\n+            *ptr::mut_offset(buf, len as int) = b;\n         }\n         set_len(&mut *s, new_len);\n     }\n \n+    /// Appends a byte to a string. (Not UTF-8 safe).\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n+        let v: &mut ~[u8] = cast::transmute(s);\n+        v.push(b);\n+    }\n+\n     /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n     unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n         let new_len = s.len() + bytes.len();\n@@ -933,6 +1108,7 @@ pub mod raw {\n     }\n \n     /// Sets the length of the string and adds the null terminator\n+    #[cfg(stage0)]\n     #[inline]\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n         let v: **mut String = cast::transmute(v);\n@@ -942,6 +1118,23 @@ pub mod raw {\n         *null = 0u8;\n     }\n \n+    /// Sets the length of a string\n+    ///\n+    /// This will explicitly set the size of the string, without actually\n+    /// modifing its buffers, so it is up to the caller to ensure that\n+    /// the string is actually the specified size.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub unsafe fn set_len(s: &mut ~str, new_len: uint) {\n+        let v: &mut ~[u8] = cast::transmute(s);\n+        vec::raw::set_len(v, new_len)\n+    }\n+\n+    /// Sets the length of a string\n+    ///\n+    /// This will explicitly set the size of the string, without actually\n+    /// modifing its buffers, so it is up to the caller to ensure that\n+    /// the string is actually the specified size.\n     #[test]\n     fn test_from_buf_len() {\n         unsafe {\n@@ -1119,10 +1312,17 @@ impl<'self> Str for @str {\n }\n \n impl<'self> Container for &'self str {\n+    #[cfg(stage0)]\n     #[inline]\n     fn len(&self) -> uint {\n         do self.as_imm_buf |_p, n| { n - 1u }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn len(&self) -> uint {\n+        do self.as_imm_buf |_p, n| { n }\n+    }\n }\n \n impl Container for ~str {\n@@ -1210,7 +1410,6 @@ pub trait StrSlice<'self> {\n     fn subslice_offset(&self, inner: &str) -> uint;\n \n     fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n-    fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T;\n }\n \n /// Extension methods for strings\n@@ -1597,6 +1796,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     /// Copy a slice into a new unique str\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_owned(&self) -> ~str {\n         do self.as_imm_buf |src, len| {\n@@ -1614,6 +1814,24 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /// Copy a slice into a new unique str\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn to_owned(&self) -> ~str {\n+        do self.as_imm_buf |src, len| {\n+            unsafe {\n+                let mut v = vec::with_capacity(len);\n+\n+                do v.as_mut_buf |dst, _| {\n+                    ptr::copy_memory(dst, src, len);\n+                }\n+                vec::raw::set_len(&mut v, len);\n+                ::cast::transmute(v)\n+            }\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_managed(&self) -> @str {\n         let v = at_vec::from_fn(self.len() + 1, |i| {\n@@ -1622,6 +1840,15 @@ impl<'self> StrSlice<'self> for &'self str {\n         unsafe { cast::transmute(v) }\n     }\n \n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn to_managed(&self) -> @str {\n+        unsafe {\n+            let v: *&[u8] = cast::transmute(self);\n+            cast::transmute(at_vec::to_managed(*v))\n+        }\n+    }\n+\n     /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16] {\n         let mut u = ~[];\n@@ -1762,6 +1989,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Work with the byte buffer of a string as a byte slice.\n     ///\n     /// The byte slice does not include the null terminator.\n+    #[cfg(stage0)]\n     fn as_bytes(&self) -> &'self [u8] {\n         unsafe {\n             let mut slice = self.repr();\n@@ -1770,6 +1998,14 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /// Work with the byte buffer of a string as a byte slice.\n+    ///\n+    /// The byte slice does not include the null terminator.\n+    #[cfg(not(stage0))]\n+    fn as_bytes(&self) -> &'self [u8] {\n+        unsafe { cast::transmute(*self) }\n+    }\n+\n     /// Returns the byte index of the first character of `self` that matches `search`\n     ///\n     /// # Return value\n@@ -1836,6 +2072,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     /// Given a string, make a new string with repeated copies of it.\n+    #[cfg(stage0)]\n     fn repeat(&self, nn: uint) -> ~str {\n         do self.as_imm_buf |buf, len| {\n             // ignore the NULL terminator\n@@ -1857,6 +2094,27 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /// Given a string, make a new string with repeated copies of it.\n+    #[cfg(not(stage0))]\n+    fn repeat(&self, nn: uint) -> ~str {\n+        do self.as_imm_buf |buf, len| {\n+            let mut ret = with_capacity(nn * len);\n+\n+            unsafe {\n+                do ret.as_mut_buf |rbuf, _len| {\n+                    let mut rbuf = rbuf;\n+\n+                    do nn.times {\n+                        ptr::copy_memory(rbuf, buf, len);\n+                        rbuf = rbuf.offset(len as int);\n+                    }\n+                }\n+                raw::set_len(&mut ret, nn * len);\n+            }\n+            ret\n+        }\n+    }\n+\n     /// Retrieves the first character from a string slice and returns\n     /// it. This does not allocate a new string; instead, it returns a\n     /// slice that point one character beyond the character that was\n@@ -1959,61 +2217,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         let v: &[u8] = unsafe { cast::transmute(*self) };\n         v.as_imm_buf(f)\n     }\n-\n-    /// Work with the byte buffer of a string as a null-terminated C string.\n-    ///\n-    /// Allows for unsafe manipulation of strings, which is useful for foreign\n-    /// interop. This is similar to `str::as_buf`, but guarantees null-termination.\n-    /// If the given slice is not already null-terminated, this function will\n-    /// allocate a temporary, copy the slice, null terminate it, and pass\n-    /// that instead.\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~ {.rust}\n-    /// let s = \"PATH\".as_c_str(|path| libc::getenv(path));\n-    /// ~~~\n-    #[inline]\n-    fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n-        do self.as_imm_buf |buf, len| {\n-            // NB: len includes the trailing null.\n-            assert!(len > 0);\n-            if unsafe { *(ptr::offset(buf, (len - 1) as int)) != 0 } {\n-                self.to_owned().as_c_str(|s| f(s))\n-            } else {\n-                f(buf as *libc::c_char)\n-            }\n-        }\n-    }\n-}\n-\n-#[allow(missing_doc)]\n-pub trait NullTerminatedStr {\n-    fn as_bytes_with_null<'a>(&'a self) -> &'a [u8];\n-}\n-\n-impl NullTerminatedStr for ~str {\n-    /// Work with the byte buffer of a string as a byte slice.\n-    ///\n-    /// The byte slice does include the null terminator.\n-    #[inline]\n-    fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n-        let ptr: &'a ~[u8] = unsafe { cast::transmute(self) };\n-        let slice: &'a [u8] = *ptr;\n-        slice\n-    }\n-}\n-\n-impl NullTerminatedStr for @str {\n-    /// Work with the byte buffer of a string as a byte slice.\n-    ///\n-    /// The byte slice does include the null terminator.\n-    #[inline]\n-    fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n-        let ptr: &'a @[u8] = unsafe { cast::transmute(self) };\n-        let slice: &'a [u8] = *ptr;\n-        slice\n-    }\n }\n \n #[allow(missing_doc)]\n@@ -2028,6 +2231,7 @@ pub trait OwnedStr {\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n+    #[cfg(stage0)]\n     fn to_bytes_with_null(self) -> ~[u8];\n \n     /// Work with the mutable byte buffer and length of a slice.\n@@ -2174,6 +2378,7 @@ impl OwnedStr for ~str {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n+    #[cfg(stage0)]\n     #[inline]\n     pub fn reserve(&mut self, n: uint) {\n         unsafe {\n@@ -2182,6 +2387,29 @@ impl OwnedStr for ~str {\n         }\n     }\n \n+    /// Reserves capacity for exactly `n` bytes in the given string, not including\n+    /// the null terminator.\n+    ///\n+    /// Assuming single-byte characters, the resulting string will be large\n+    /// enough to hold a string of length `n`. To account for the null terminator,\n+    /// the underlying buffer will have the size `n` + 1.\n+    ///\n+    /// If the capacity for `s` is already equal to or greater than the requested\n+    /// capacity, then no action is taken.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - A string\n+    /// * n - The number of bytes to reserve space for\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub fn reserve(&mut self, n: uint) {\n+        unsafe {\n+            let v: &mut ~[u8] = cast::transmute(self);\n+            (*v).reserve(n);\n+        }\n+    }\n+\n     /// Reserves capacity for at least `n` bytes in the given string, not including\n     /// the null terminator.\n     ///\n@@ -2200,22 +2428,58 @@ impl OwnedStr for ~str {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n+    #[cfg(stage0)]\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two(n + 1u) - 1u)\n     }\n \n+    /// Reserves capacity for at least `n` bytes in the given string.\n+    ///\n+    /// Assuming single-byte characters, the resulting string will be large\n+    /// enough to hold a string of length `n`. To account for the null terminator,\n+    /// the underlying buffer will have the size `n` + 1.\n+    ///\n+    /// This function will over-allocate in order to amortize the allocation costs\n+    /// in scenarios where the caller may need to repeatedly reserve additional\n+    /// space.\n+    ///\n+    /// If the capacity for `s` is already equal to or greater than the requested\n+    /// capacity, then no action is taken.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - A string\n+    /// * n - The number of bytes to reserve space for\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn reserve_at_least(&mut self, n: uint) {\n+        self.reserve(uint::next_power_of_two(n))\n+    }\n+\n     /// Returns the number of single-byte characters the string can hold without\n     /// reallocating\n+    #[cfg(stage0)]\n     fn capacity(&self) -> uint {\n         let buf: &~[u8] = unsafe { cast::transmute(self) };\n         let vcap = buf.capacity();\n         assert!(vcap > 0u);\n         vcap - 1u\n     }\n \n+    /// Returns the number of single-byte characters the string can hold without\n+    /// reallocating\n+    #[cfg(not(stage0))]\n+    fn capacity(&self) -> uint {\n+        unsafe {\n+            let buf: &~[u8] = cast::transmute(self);\n+            buf.capacity()\n+        }\n+    }\n+\n     /// Convert to a vector of bytes. This does not allocate a new\n     /// string, and includes the null terminator.\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_bytes_with_null(self) -> ~[u8] {\n         unsafe { cast::transmute(self) }\n@@ -2904,71 +3168,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unsafe_from_bytes_with_null() {\n-        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-        let b = unsafe { raw::from_bytes_with_null(a) };\n-        assert_eq!(b, \"AAAAAAA\");\n-    }\n-\n-    #[test]\n-    fn test_from_bytes_with_null() {\n-        let ss = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let bb = [0xe0_u8, 0xb8_u8, 0xa8_u8,\n-                  0xe0_u8, 0xb9_u8, 0x84_u8,\n-                  0xe0_u8, 0xb8_u8, 0x97_u8,\n-                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n-                  0xe4_u8, 0xb8_u8, 0xad_u8,\n-                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n-                  0x56_u8, 0x69_u8, 0xe1_u8,\n-                  0xbb_u8, 0x87_u8, 0x74_u8,\n-                  0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8, 0x0_u8];\n-\n-        assert_eq!(ss, from_bytes_with_null(bb));\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn test_from_bytes_with_null_fail() {\n-        let bb = [0xff_u8, 0xb8_u8, 0xa8_u8,\n-                  0xe0_u8, 0xb9_u8, 0x84_u8,\n-                  0xe0_u8, 0xb8_u8, 0x97_u8,\n-                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n-                  0xe4_u8, 0xb8_u8, 0xad_u8,\n-                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n-                  0x56_u8, 0x69_u8, 0xe1_u8,\n-                  0xbb_u8, 0x87_u8, 0x74_u8,\n-                  0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8, 0x0_u8];\n-\n-         let _x = from_bytes_with_null(bb);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn test_from_bytes_with_null_fail_2() {\n-        let bb = [0xff_u8, 0xb8_u8, 0xa8_u8,\n-                  0xe0_u8, 0xb9_u8, 0x84_u8,\n-                  0xe0_u8, 0xb8_u8, 0x97_u8,\n-                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n-                  0xe4_u8, 0xb8_u8, 0xad_u8,\n-                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n-                  0x56_u8, 0x69_u8, 0xe1_u8,\n-                  0xbb_u8, 0x87_u8, 0x74_u8,\n-                  0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8, 0x60_u8];\n-\n-         let _x = from_bytes_with_null(bb);\n-    }\n-\n-    #[test]\n-    fn test_from_buf() {\n+    fn test_raw_from_c_str() {\n         unsafe {\n-            let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let a = ~[65, 65, 65, 65, 65, 65, 65, 0];\n             let b = vec::raw::to_ptr(a);\n-            let c = raw::from_buf(b);\n+            let c = raw::from_c_str(b);\n             assert_eq!(c, ~\"AAAAAAA\");\n         }\n     }\n@@ -2986,30 +3190,31 @@ mod tests {\n         assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n     }\n \n+    #[cfg(stage0)]\n     #[test]\n-    fn test_as_bytes_with_null() {\n-        // has null\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109, 0\n-        ];\n-\n-        let s1 = @\"\";\n-        let s2 = @\"abc\";\n-        let s3 = @\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert_eq!(s1.as_bytes_with_null(), &[0]);\n-        assert_eq!(s2.as_bytes_with_null(), &['a' as u8, 'b' as u8, 'c' as u8, 0]);\n-        assert_eq!(s3.as_bytes_with_null(), v);\n+    #[ignore(cfg(windows))]\n+    #[should_fail]\n+    fn test_as_bytes_fail() {\n+        // Don't double free. (I'm not sure if this exercises the\n+        // original problem code path anymore.)\n+        let s = ~\"\";\n+        let _bytes = s.as_bytes();\n+        fail!();\n+    }\n \n-        let s1 = ~\"\";\n-        let s2 = ~\"abc\";\n-        let s3 = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert_eq!(s1.as_bytes_with_null(), &[0]);\n-        assert_eq!(s2.as_bytes_with_null(), &['a' as u8, 'b' as u8, 'c' as u8, 0]);\n-        assert_eq!(s3.as_bytes_with_null(), v);\n+    #[cfg(stage0)]\n+    #[test]\n+    #[ignore(cfg(windows))]\n+    #[should_fail]\n+    fn test_as_bytes_fail() {\n+        // Don't double free. (I'm not sure if this exercises the\n+        // original problem code path anymore.)\n+        let s = ~\"\";\n+        let _bytes = s.as_bytes_with_null();\n+        fail!();\n     }\n \n+    #[cfg(stage0)]\n     #[test]\n     fn test_to_bytes_with_null() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -3031,50 +3236,24 @@ mod tests {\n         // Don't double free. (I'm not sure if this exercises the\n         // original problem code path anymore.)\n         let s = ~\"\";\n-        let _bytes = s.as_bytes_with_null();\n+        let _bytes = s.as_bytes();\n         fail!();\n     }\n \n     #[test]\n     fn test_as_imm_buf() {\n-        do \"\".as_imm_buf |buf, len| {\n-            assert_eq!(len, 1);\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n-            }\n+        do \"\".as_imm_buf |_, len| {\n+            assert_eq!(len, 0);\n         }\n \n         do \"hello\".as_imm_buf |buf, len| {\n-            assert_eq!(len, 6);\n+            assert_eq!(len, 5);\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n                 assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n                 assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n                 assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n                 assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_as_c_str() {\n-        let a = ~\"\";\n-        do a.as_c_str |buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n-            }\n-        }\n-\n-        let a = ~\"hello\";\n-        do a.as_c_str |buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n             }\n         }\n     }"}, {"sha": "02a6247428c86bfa60e2a280a92d4ebbd0b4b0f2", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -18,7 +18,9 @@ use container::Container;\n use cast;\n use ptr;\n use iterator::{Iterator, IteratorUtil};\n-use vec::{CopyableVector, ImmutableVector, OwnedVector};\n+use vec::{CopyableVector, ImmutableVector};\n+#[cfg(stage0)]\n+use vec::OwnedVector;\n use to_bytes::IterBytes;\n use option::{Some, None};\n \n@@ -96,19 +98,26 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n     }\n }\n \n-impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n+impl<'self> AsciiCast<&'self [Ascii]> for &'self str {\n     #[inline]\n-    fn to_ascii(&self) -> &'self[Ascii] {\n+    fn to_ascii(&self) -> &'self [Ascii] {\n         assert!(self.is_ascii());\n-        unsafe {self.to_ascii_nocheck()}\n+        unsafe { self.to_ascii_nocheck() }\n     }\n \n+    #[cfg(stage0)]\n     #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'self[Ascii] {\n+    unsafe fn to_ascii_nocheck(&self) -> &'self [Ascii] {\n         let (p,len): (*u8, uint) = cast::transmute(*self);\n         cast::transmute((p, len - 1))\n     }\n \n+    #[cfg(not(stage0))]\n+    #[inline]\n+    unsafe fn to_ascii_nocheck(&self) -> &'self [Ascii] {\n+        cast::transmute(*self)\n+    }\n+\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.byte_iter().all(|b| b.is_ascii())\n@@ -181,12 +190,19 @@ impl OwnedAsciiCast for ~str {\n         unsafe {self.into_ascii_nocheck()}\n     }\n \n+    #[cfg(stage0)]\n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n         let mut r: ~[Ascii] = cast::transmute(self);\n         r.pop();\n         r\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n+        cast::transmute(self)\n+    }\n }\n \n /// Trait for converting an ascii type to a string. Needed to convert `&[Ascii]` to `~str`\n@@ -205,11 +221,19 @@ pub trait AsciiStr {\n }\n \n impl<'self> AsciiStr for &'self [Ascii] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_str_ascii(&self) -> ~str {\n         let mut cpy = self.to_owned();\n         cpy.push(0u8.to_ascii());\n-        unsafe {cast::transmute(cpy)}\n+        unsafe { cast::transmute(cpy) }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn to_str_ascii(&self) -> ~str {\n+        let cpy = self.to_owned();\n+        unsafe { cast::transmute(cpy) }\n     }\n \n     #[inline]\n@@ -229,11 +253,18 @@ impl<'self> AsciiStr for &'self [Ascii] {\n }\n \n impl ToStrConsume for ~[Ascii] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn into_str(self) -> ~str {\n         let mut cpy = self;\n         cpy.push(0u8.to_ascii());\n-        unsafe {cast::transmute(cpy)}\n+        unsafe { cast::transmute(cpy) }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn into_str(self) -> ~str {\n+        unsafe { cast::transmute(self) }\n     }\n }\n \n@@ -252,7 +283,7 @@ pub trait ToBytesConsume {\n \n impl ToBytesConsume for ~[Ascii] {\n     fn into_bytes(self) -> ~[u8] {\n-        unsafe {cast::transmute(self)}\n+        unsafe { cast::transmute(self) }\n     }\n }\n "}, {"sha": "03e6412fcb8c739fb8bcc562123a66bfdb1549de", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -12,12 +12,12 @@\n \n #[allow(missing_doc)];\n \n+use c_str::ToCStr;\n use cast;\n use io;\n use libc;\n use libc::{c_char, size_t};\n use repr;\n-use str::StrSlice;\n use str;\n use unstable::intrinsics;\n \n@@ -105,8 +105,8 @@ pub trait FailWithCause {\n \n impl FailWithCause for ~str {\n     fn fail_with(cause: ~str, file: &'static str, line: uint) -> ! {\n-        do cause.as_c_str |msg_buf| {\n-            do file.as_c_str |file_buf| {\n+        do cause.to_c_str().with_ref |msg_buf| {\n+            do file.to_c_str().with_ref |file_buf| {\n                 begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n             }\n         }\n@@ -115,8 +115,8 @@ impl FailWithCause for ~str {\n \n impl FailWithCause for &'static str {\n     fn fail_with(cause: &'static str, file: &'static str, line: uint) -> ! {\n-        do cause.as_c_str |msg_buf| {\n-            do file.as_c_str |file_buf| {\n+        do cause.to_c_str().with_ref |msg_buf| {\n+            do file.to_c_str().with_ref |file_buf| {\n                 begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n             }\n         }"}, {"sha": "49e3e0777df84e58356fe734fe07d3e37c36f34f", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -15,6 +15,7 @@ Dynamic library facilities.\n A simple wrapper over the platforms dynamic library facilities\n \n */\n+use c_str::ToCStr;\n use cast;\n use path;\n use libc;\n@@ -65,7 +66,7 @@ impl DynamicLibrary {\n         // T but that feature is still unimplemented\n \n         let maybe_symbol_value = do dl::check_for_errors_in {\n-            do symbol.as_c_str |raw_string| {\n+            do symbol.to_c_str().with_ref |raw_string| {\n                 dl::symbol(self.handle, raw_string)\n             }\n         };\n@@ -135,6 +136,7 @@ mod test {\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n mod dl {\n+    use c_str::ToCStr;\n     use libc;\n     use path;\n     use ptr;\n@@ -143,7 +145,7 @@ mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n-        do filename.to_str().as_c_str |raw_name| {\n+        do filename.to_c_str().with_ref |raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int)\n         }\n     }"}, {"sha": "d63f914bc7386f215f98f86d5264f04ac601e0ff", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -549,12 +549,14 @@ pub mod rt {\n         // For strings, precision is the maximum characters\n         // displayed\n         let unpadded = match cv.precision {\n-          CountImplied => s,\n-          CountIs(max) => if (max as uint) < s.char_len() {\n-            s.slice(0, max as uint)\n-          } else {\n-            s\n-          }\n+            CountImplied => s,\n+            CountIs(max) => {\n+                if (max as uint) < s.char_len() {\n+                    s.slice(0, max as uint)\n+                } else {\n+                    s\n+                }\n+            }\n         };\n         pad(cv, unpadded, None, PadNozero, buf);\n     }"}, {"sha": "9e7ac1fd7db1337f230b4f9c075abbf32327c4cb", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -10,6 +10,7 @@\n \n //! Runtime calls emitted by the compiler.\n \n+use c_str::ToCStr;\n use cast::transmute;\n use libc::{c_char, c_uchar, c_void, size_t, uintptr_t};\n use str;\n@@ -28,7 +29,7 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n                          index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n-    do msg.as_c_str |buf| {\n+    do msg.to_c_str().with_ref |buf| {\n         fail_(buf, file, line);\n     }\n }"}, {"sha": "ddd452deef2cb59bad8834c259772af61c3789ea", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -292,10 +292,9 @@ void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n \n     if (zone != NULL) {\n         size_t size = strlen(zone);\n-        reserve_vec_exact(&out_tm->tm_zone, size + 1);\n+        reserve_vec_exact(&out_tm->tm_zone, size);\n         memcpy(out_tm->tm_zone->data, zone, size);\n-        out_tm->tm_zone->fill = size + 1;\n-        out_tm->tm_zone->data[size] = '\\0';\n+        out_tm->tm_zone->fill = size;\n     }\n }\n "}, {"sha": "3cfaa57d540f350a8aa4786ec1a337d834507248", "filename": "src/test/compile-fail/static-slice-not-null-terminated.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Fcompile-fail%2Fstatic-slice-not-null-terminated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81e81f234731a31fad9afdc2045bef3fbdf1109/src%2Ftest%2Fcompile-fail%2Fstatic-slice-not-null-terminated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-slice-not-null-terminated.rs?ref=e81e81f234731a31fad9afdc2045bef3fbdf1109", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let _ = (~\"foo\").as_bytes_with_null();\n-    let _ = (@\"foo\").as_bytes_with_null();\n-\n-    // a plain static slice is null terminated, but such a slice can\n-    // be sliced shorter (i.e. become non-null terminated) and still\n-    // have the static lifetime\n-    let foo: &'static str = \"foo\";\n-    let _ = foo.as_bytes_with_null();\n-     //~^ ERROR does not implement any method in scope named `as_bytes_with_null`\n-}"}, {"sha": "e91c11f5cd0a703eea86f5080aec6051d1c52bf9", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -20,11 +20,11 @@ mod libc {\n }\n \n fn atol(s: ~str) -> int {\n-    s.as_imm_buf(|x, _len| unsafe { libc::atol(x) })\n+    s.to_c_str().with_ref(|x| unsafe { libc::atol(x as *u8) })\n }\n \n fn atoll(s: ~str) -> i64 {\n-    s.as_imm_buf(|x, _len| unsafe { libc::atoll(x) })\n+    s.to_c_str().with_ref(|x| unsafe { libc::atoll(x as *u8) })\n }\n \n pub fn main() {"}, {"sha": "0e7d6d9f16a3c420f080df9a4115d7c09a1d49aa", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -10,15 +10,20 @@\n \n use std::str;\n \n-static a: [u8, ..3] = ['h' as u8, 'i' as u8, 0 as u8];\n-static c: &'static [u8, ..3] = &a;\n-static b: *u8 = c as *u8;\n+static A: [u8, ..2] = ['h' as u8, 'i' as u8];\n+static B: &'static [u8, ..2] = &A;\n+static C: *u8 = B as *u8;\n \n pub fn main() {\n-    let foo = &a as *u8;\n-    assert_eq!(unsafe { str::raw::from_bytes(a) }, ~\"hi\\x00\");\n-    assert_eq!(unsafe { str::raw::from_buf(foo) }, ~\"hi\");\n-    assert_eq!(unsafe { str::raw::from_buf(b) }, ~\"hi\");\n-    assert!(unsafe { *b == a[0] });\n-    assert!(unsafe { *(&c[0] as *u8) == a[0] });\n+    unsafe {\n+        let foo = &A as *u8;\n+        assert_eq!(str::raw::from_bytes(A), ~\"hi\");\n+        assert_eq!(str::raw::from_buf_len(foo, A.len()), ~\"hi\");\n+        assert_eq!(str::raw::from_buf_len(C, B.len()), ~\"hi\");\n+        assert!(*C == A[0]);\n+        assert!(*(&B[0] as *u8) == A[0]);\n+\n+        let bar = str::raw::from_bytes(A).to_c_str();\n+        assert_eq!(bar.with_ref(|buf| str::raw::from_c_str(buf)), ~\"hi\");\n+    }\n }"}, {"sha": "b5a114ef22364e64dc2bea3f7ccf326b914afa50", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f5011005eda4f08f0c36fe56e4df07ae9a903f/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=60f5011005eda4f08f0c36fe56e4df07ae9a903f", "patch": "@@ -26,8 +26,9 @@ mod libc {\n fn strlen(str: ~str) -> uint {\n     unsafe {\n         // C string is terminated with a zero\n-        let bytes = str.to_bytes_with_null();\n-        return libc::my_strlen(vec::raw::to_ptr(bytes));\n+        do str.to_c_str().with_ref |buf| {\n+            libc::my_strlen(buf as *u8)\n+        }\n     }\n }\n "}]}