{"sha": "913383d7755e5336c29314ea36760e07353e9983", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMzM4M2Q3NzU1ZTUzMzZjMjkzMTRlYTM2NzYwZTA3MzUzZTk5ODM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-12T07:44:43Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-12T07:44:43Z"}, "message": "rustc: Preserve more type information for interior vectors at the LLVM level, allowing SROA to take place. `log ~[ 2 ].(0)` now optimizes to just `log 2`.", "tree": {"sha": "7b2e76d7e539463b0872072b1cd6b84e6cb94622", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b2e76d7e539463b0872072b1cd6b84e6cb94622"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/913383d7755e5336c29314ea36760e07353e9983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/913383d7755e5336c29314ea36760e07353e9983", "html_url": "https://github.com/rust-lang/rust/commit/913383d7755e5336c29314ea36760e07353e9983", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/913383d7755e5336c29314ea36760e07353e9983/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "770bf24d726c885fcb39ef0c249d405953508b8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/770bf24d726c885fcb39ef0c249d405953508b8f", "html_url": "https://github.com/rust-lang/rust/commit/770bf24d726c885fcb39ef0c249d405953508b8f"}], "stats": {"total": 60, "additions": 39, "deletions": 21}, "files": [{"sha": "249884da1239f24e929f56bbe6370f26d1aee20e", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/913383d7755e5336c29314ea36760e07353e9983/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913383d7755e5336c29314ea36760e07353e9983/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=913383d7755e5336c29314ea36760e07353e9983", "patch": "@@ -67,6 +67,7 @@ const int closure_elt_bindings = 2;\n const int closure_elt_ty_params = 3;\n \n const uint ivec_default_size = 64u;\n+const uint ivec_default_length = 8u;\n \n const uint ivec_elt_len = 0u;\n const uint ivec_elt_alen = 1u;"}, {"sha": "0c671b722db67b6de3dcb19066c6c75071e4de75", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/913383d7755e5336c29314ea36760e07353e9983/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913383d7755e5336c29314ea36760e07353e9983/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=913383d7755e5336c29314ea36760e07353e9983", "patch": "@@ -572,10 +572,17 @@ fn T_opaque_vec_ptr() -> TypeRef {\n // Interior vector.\n //\n // TODO: Support user-defined vector sizes.\n-fn T_ivec() -> TypeRef {\n+fn T_ivec(TypeRef t) -> TypeRef {\n     ret T_struct([T_int(),          // Length (\"fill\"; if zero, heapified)\n                   T_int(),          // Alloc\n-                  T_array(T_i8(), abi::ivec_default_size)]);  // Body elements\n+                  T_array(t, abi::ivec_default_length)]);   // Body elements\n+}\n+\n+// Note that the size of this one is in bytes.\n+fn T_opaque_ivec() -> TypeRef {\n+    ret T_struct([T_int(),          // Length (\"fill\"; if zero, heapified)\n+                  T_int(),          // Alloc\n+                  T_array(T_i8(), abi::ivec_default_size)]); // Body elements\n }\n \n // Interior vector on the heap. Cast to this when the allocated length (second\n@@ -868,7 +875,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n         }\n         case (ty::ty_char) { llty = T_char(); }\n         case (ty::ty_str) { llty = T_ptr(T_str()); }\n-        case (ty::ty_istr) { llty = T_ivec(); }\n+        case (ty::ty_istr) { llty = T_ivec(T_i8()); }\n         case (ty::ty_tag(_, _)) {\n             if (ty::type_has_dynamic_size(cx.tcx, t)) {\n                 llty = T_opaque_tag(cx.tn);\n@@ -884,7 +891,11 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = T_ptr(T_vec(type_of_inner(cx, sp, mt.ty)));\n         }\n         case (ty::ty_ivec(?mt)) {\n-            llty = T_ivec();\n+            if (ty::type_has_dynamic_size(cx.tcx, mt.ty)) {\n+                llty = T_opaque_ivec();\n+            } else {\n+                llty = T_ivec(type_of_inner(cx, sp, mt.ty));\n+            }\n         }\n         case (ty::ty_ptr(?mt)) {\n             llty = T_ptr(type_of_inner(cx, sp, mt.ty));\n@@ -2661,9 +2672,8 @@ fn get_ivec_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n     auto stack_len = bcx.build.Load(bcx.build.InBoundsGEP(v,\n         [C_int(0), C_uint(abi::ivec_elt_len)]));\n     auto stack_elem = bcx.build.InBoundsGEP(v, [C_int(0),\n-                                        C_uint(abi::ivec_elt_elems)]);\n-    stack_elem = bcx.build.PointerCast(stack_elem,\n-                                       T_ptr(T_array(llunitty, 0u)));\n+                                        C_uint(abi::ivec_elt_elems),\n+                                        C_int(0)]);\n \n     auto on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n \n@@ -2691,22 +2701,22 @@ fn get_ivec_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n     // Technically this context is unnecessary, but it makes this function\n     // clearer.\n     auto zero_len = C_int(0);\n-    auto zero_elem = C_null(T_ptr(T_array(llunitty, 0u)));\n+    auto zero_elem = C_null(T_ptr(llunitty));\n     zero_len_cx.build.Br(next_cx.llbb);\n \n     // If we're here, then we actually have a heapified vector.\n     auto heap_len = nonzero_len_cx.build.Load(\n         nonzero_len_cx.build.InBoundsGEP(heap_ptr,\n             [C_int(0), C_uint(abi::ivec_heap_elt_len)]));\n     auto heap_elem = nonzero_len_cx.build.InBoundsGEP(heap_ptr,\n-        [C_int(0), C_uint(abi::ivec_heap_elt_elems)]);\n+        [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n     nonzero_len_cx.build.Br(next_cx.llbb);\n \n     // Now we can figure out the length of `v` and get a pointer to its first\n     // element.\n     auto len = next_cx.build.Phi(T_int(), [stack_len, zero_len, heap_len],\n         [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n-    auto elem = next_cx.build.Phi(T_ptr(T_array(llunitty, 0u)),\n+    auto elem = next_cx.build.Phi(T_ptr(llunitty),\n         [stack_elem, zero_elem, heap_elem],\n         [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n     ret tup(len, elem, next_cx);\n@@ -2791,6 +2801,8 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n         bcx = b_len_and_data._2;\n \n         // Calculate the last pointer address we want to handle.\n+        // TODO: Optimize this when the size of the unit type is statically\n+        // known to not use pointer casts, which tend to confuse LLVM.\n         auto len = umin(bcx, a_len, b_len);\n         auto b_elem_i8 = bcx.build.PointerCast(b_elem, T_ptr(T_i8()));\n         auto b_end_i8 = bcx.build.GEP(b_elem_i8, [len]);\n@@ -4817,16 +4829,17 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base,\n     alt (interior_len_and_data) {\n         case (some(?lad)) { body = lad._1; }\n         case (none) {\n-            body = next_cx.build.GEP(v, [C_int(0), C_int(abi::vec_elt_data)]);\n+            body = next_cx.build.GEP(v,\n+                [C_int(0), C_int(abi::vec_elt_data), C_int(0)]);\n         }\n     }\n \n     auto elt;\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, unit_ty)) {\n-        body = next_cx.build.PointerCast(body, T_ptr(T_array(T_i8(), 0u)));\n-        elt = next_cx.build.GEP(body, [C_int(0), scaled_ix]);\n+        body = next_cx.build.PointerCast(body, T_ptr(T_i8()));\n+        elt = next_cx.build.GEP(body, [scaled_ix]);\n     } else {\n-        elt = next_cx.build.GEP(body, [C_int(0), ix_val]);\n+        elt = next_cx.build.GEP(body, [ix_val]);\n \n         // We're crossing a box boundary here, so we may need to pointer cast.\n         auto llunitty = type_of(next_cx.fcx.lcx.ccx, sp, unit_ty);\n@@ -5649,7 +5662,13 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann)\n     bcx = rslt.bcx;\n \n     auto llunitty = type_of_or_i8(bcx, unit_ty);\n-    auto llvecptr = alloca(bcx, T_ivec());\n+    auto llvecptr;\n+    if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n+        llvecptr = alloca(bcx, T_opaque_ivec());\n+    } else {\n+        llvecptr = alloca(bcx, T_ivec(llunitty));\n+    }\n+\n     auto lllen = bcx.build.Mul(C_uint(vec::len(args)), unit_sz);\n \n     // Allocate the vector pieces and store length and allocated length.\n@@ -5661,7 +5680,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann)\n         bcx.build.Store(C_uint(abi::ivec_elt_alen), bcx.build.GEP(llvecptr,\n             [C_int(0), C_uint(abi::ivec_elt_alen)]));\n         llfirsteltptr = bcx.build.GEP(llvecptr,\n-            [C_int(0), C_uint(abi::ivec_elt_elems)]);\n+            [C_int(0), C_uint(abi::ivec_elt_elems), C_int(0)]);\n     } else {\n         // Heap case.\n         auto llstubty = T_ivec_heap(llunitty);\n@@ -5690,12 +5709,10 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann)\n             bcx.build.Store(lllen, bcx.build.GEP(llheapptr,\n                 [C_int(0), C_uint(abi::ivec_heap_elt_len)]));\n             llfirsteltptr = bcx.build.GEP(llheapptr,\n-                [C_int(0), C_uint(abi::ivec_heap_elt_elems)]);\n+                [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n         }\n     }\n \n-    llfirsteltptr = bcx.build.PointerCast(llfirsteltptr, T_ptr(llunitty));\n-\n     // Store the individual elements.\n     auto i = 0u;\n     for (@ast::expr e in args) {\n@@ -5705,10 +5722,10 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann)\n \n         auto lleltptr;\n         if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n-            lleltptr = bcx.build.GEP(llfirsteltptr,\n+            lleltptr = bcx.build.InBoundsGEP(llfirsteltptr,\n                 [bcx.build.Mul(C_uint(i), unit_align)]);\n         } else {\n-            lleltptr = bcx.build.GEP(llfirsteltptr, [C_uint(i)]);\n+            lleltptr = bcx.build.InBoundsGEP(llfirsteltptr, [C_uint(i)]);\n         }\n \n         bcx = copy_val(bcx, INIT, lleltptr, llsrc, unit_ty).bcx;"}]}