{"sha": "1fb78b19ce0f75c6e6297b26b20d92f31c27e703", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYjc4YjE5Y2UwZjc1YzZlNjI5N2IyNmIyMGQ5MmYzMWMyN2U3MDM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-08-05T19:09:49Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-08-05T19:09:49Z"}, "message": "Rollup merge of #27285 - lastorset:trait-operator-impl, r=steveklabnik\n\nI also included some smaller trait-related changes.\r\n\r\nFixes #26991.\r\n\r\nr? @shepmaster \r\nr? @steveklabnik", "tree": {"sha": "ef19c5830c8dbd684f495304696ce24c862a492f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef19c5830c8dbd684f495304696ce24c862a492f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fb78b19ce0f75c6e6297b26b20d92f31c27e703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb78b19ce0f75c6e6297b26b20d92f31c27e703", "html_url": "https://github.com/rust-lang/rust/commit/1fb78b19ce0f75c6e6297b26b20d92f31c27e703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fb78b19ce0f75c6e6297b26b20d92f31c27e703/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d03456183e85fe7bd465bbe7c8f67885a2528444", "url": "https://api.github.com/repos/rust-lang/rust/commits/d03456183e85fe7bd465bbe7c8f67885a2528444", "html_url": "https://github.com/rust-lang/rust/commit/d03456183e85fe7bd465bbe7c8f67885a2528444"}, {"sha": "427736931bb1cd34c97e4e1f79a5a84430415207", "url": "https://api.github.com/repos/rust-lang/rust/commits/427736931bb1cd34c97e4e1f79a5a84430415207", "html_url": "https://github.com/rust-lang/rust/commit/427736931bb1cd34c97e4e1f79a5a84430415207"}], "stats": {"total": 160, "additions": 146, "deletions": 14}, "files": [{"sha": "59dc8e9ed942e515b274eb8d59bcdd8f67ee8369", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1fb78b19ce0f75c6e6297b26b20d92f31c27e703/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/1fb78b19ce0f75c6e6297b26b20d92f31c27e703/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=1fb78b19ce0f75c6e6297b26b20d92f31c27e703", "patch": "@@ -6,7 +6,7 @@ Generics are called \u2018parametric polymorphism\u2019 in type theory,\n which means that they are types or functions that have multiple forms (\u2018poly\u2019\n is multiple, \u2018morph\u2019 is form) over a given parameter (\u2018parametric\u2019).\n \n-Anyway, enough with type theory, let\u2019s check out some generic code. Rust\u2019s\n+Anyway, enough type theory, let\u2019s check out some generic code. Rust\u2019s\n standard library provides a type, `Option<T>`, that\u2019s generic:\n \n ```rust\n@@ -27,7 +27,7 @@ let x: Option<i32> = Some(5);\n \n In the type declaration, we say `Option<i32>`. Note how similar this looks to\n `Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On\n-the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.\n+the right-hand side of the binding, we make a `Some(T)`, where `T` is `5`.\n Since that\u2019s an `i32`, the two sides match, and Rust is happy. If they didn\u2019t\n match, we\u2019d get an error:\n \n@@ -101,11 +101,6 @@ fn takes_two_things<T, U>(x: T, y: U) {\n }\n ```\n \n-Generic functions are most useful with \u2018trait bounds\u2019, which we\u2019ll cover in the\n-[section on traits][traits].\n-\n-[traits]: traits.html\n-\n ## Generic structs\n \n You can store a generic type in a `struct` as well:\n@@ -122,3 +117,28 @@ let float_origin = Point { x: 0.0, y: 0.0 };\n \n Similarly to functions, the `<T>` is where we declare the generic parameters,\n and we then use `x: T` in the type declaration, too.\n+\n+When you want to add an implementation for the generic struct, you just\n+declare the type parameter after the `impl`:\n+\n+```rust\n+# struct Point<T> {\n+#     x: T,\n+#     y: T,\n+# }\n+#\n+impl<T> Point<T> {\n+    fn swap(&mut self) {\n+        std::mem::swap(&mut self.x, &mut self.y);\n+    }\n+}\n+```\n+\n+So far you\u2019ve seen generics that take absolutely any type. These are useful in\n+many cases: you\u2019ve already seen `Option<T>`, and later you\u2019ll meet universal\n+container types like [`Vec<T>`][Vec]. On the other hand, often you want to\n+trade that flexibility for increased expressive power. Read about [trait\n+bounds][traits] to see why and how.\n+\n+[traits]: traits.html\n+[Vec]: ../std/vec/struct.Vec.html"}, {"sha": "e53664eeb552662e2b0e4a17aafd17dea37c2adb", "filename": "src/doc/trpl/operators-and-overloading.md", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1fb78b19ce0f75c6e6297b26b20d92f31c27e703/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/1fb78b19ce0f75c6e6297b26b20d92f31c27e703/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md?ref=1fb78b19ce0f75c6e6297b26b20d92f31c27e703", "patch": "@@ -81,3 +81,55 @@ will let you do this:\n let p: Point = // ...\n let x: f64 = p + 2i32;\n ```\n+\n+# Using operator traits in generic structs\n+\n+Now that we know how operator traits are defined, we can define our `HasArea`\n+trait and `Square` struct from the [traits chapter][traits] more generically:\n+\n+[traits]: traits.html\n+\n+```rust\n+use std::ops::Mul;\n+\n+trait HasArea<T> {\n+    fn area(&self) -> T;\n+}\n+\n+struct Square<T> {\n+    x: T,\n+    y: T,\n+    side: T,\n+}\n+\n+impl<T> HasArea<T> for Square<T>\n+        where T: Mul<Output=T> + Copy {\n+    fn area(&self) -> T {\n+        self.side * self.side\n+    }\n+}\n+\n+fn main() {\n+    let s = Square {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        side: 12.0f64,\n+    };\n+\n+    println!(\"Area of s: {}\", s.area());\n+}\n+```\n+\n+For `HasArea` and `Square`, we just declare a type parameter `T` and replace\n+`f64` with it. The `impl` needs more involved modifications:\n+\n+```ignore\n+impl<T> HasArea<T> for Square<T>\n+        where T: Mul<Output=T> + Copy { ... }\n+```\n+\n+The `area` method requires that we can multiply the sides, so we declare that\n+type `T` must implement `std::ops::Mul`. Like `Add`, mentioned above, `Mul`\n+itself takes an `Output` parameter: since we know that numbers don't change\n+type when multiplied, we also set it to `T`. `T` must also support copying, so\n+Rust doesn't try to move `self.side` into the return value."}, {"sha": "80c45ac4f0ade2f273788671cd6c373a1457d134", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1fb78b19ce0f75c6e6297b26b20d92f31c27e703/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/1fb78b19ce0f75c6e6297b26b20d92f31c27e703/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=1fb78b19ce0f75c6e6297b26b20d92f31c27e703", "patch": "@@ -47,8 +47,11 @@ As you can see, the `trait` block looks very similar to the `impl` block,\n but we don\u2019t define a body, just a type signature. When we `impl` a trait,\n we use `impl Trait for Item`, rather than just `impl Item`.\n \n-We can use traits to constrain our generics. Consider this function, which\n-does not compile:\n+## Traits bounds for generic functions\n+\n+Traits are useful because they allow a type to make certain promises about its\n+behavior. Generic functions can exploit this to constrain the types they\n+accept. Consider this function, which does not compile:\n \n ```rust,ignore\n fn print_area<T>(shape: T) {\n@@ -75,7 +78,7 @@ fn print_area<T: HasArea>(shape: T) {\n }\n ```\n \n-The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n+The syntax `<T: HasArea>` means \u201cany type that implements the `HasArea` trait.\u201d\n Because traits define function type signatures, we can be sure that any type\n which implements `HasArea` will have an `.area()` method.\n \n@@ -152,6 +155,63 @@ We get a compile-time error:\n error: the trait `HasArea` is not implemented for the type `_` [E0277]\n ```\n \n+## Traits bounds for generic structs\n+\n+Your generic structs can also benefit from trait constraints. All you need to\n+do is append the constraint when you declare type parameters. Here is a new\n+type `Rectangle<T>` and its operation `is_square()`:\n+\n+```rust\n+struct Rectangle<T> {\n+    x: T,\n+    y: T,\n+    width: T,\n+    height: T,\n+}\n+\n+impl<T: PartialEq> Rectangle<T> {\n+    fn is_square(&self) -> bool {\n+        self.width == self.height\n+    }\n+}\n+\n+fn main() {\n+    let mut r = Rectangle {\n+        x: 0,\n+        y: 0,\n+        width: 47,\n+        height: 47,\n+    };\n+\n+    assert!(r.is_square());\n+\n+    r.height = 42;\n+    assert!(!r.is_square());\n+}\n+```\n+\n+`is_square()` needs to check that the sides are equal, so the sides must be of\n+a type that implements the [`core::cmp::PartialEq`][PartialEq] trait:\n+\n+```ignore\n+impl<T: PartialEq> Rectangle<T> { ... }\n+```\n+\n+Now, a rectangle can be defined in terms of any type that can be compared for\n+equality.\n+\n+[PartialEq]: ../core/cmp/trait.PartialEq.html\n+\n+Here we defined a new struct `Rectangle` that accepts numbers of any\n+precision\u2014really, objects of pretty much any type\u2014as long as they can be\n+compared for equality. Could we do the same for our `HasArea` structs, `Square`\n+and `Circle`? Yes, but they need multiplication, and to work with that we need\n+to know more about [operator traits][operators-and-overloading].\n+\n+[operators-and-overloading]: operators-and-overloading.html\n+\n+# Rules for implementing traits\n+\n So far, we\u2019ve only added trait implementations to structs, but you can\n implement a trait for any type. So technically, we _could_ implement `HasArea`\n for `i32`:\n@@ -175,7 +235,7 @@ impl HasArea for i32 {\n It is considered poor style to implement methods on such primitive types, even\n though it is possible.\n \n-This may seem like the Wild West, but there are two other restrictions around\n+This may seem like the Wild West, but there are two restrictions around\n implementing traits that prevent this from getting out of hand. The first is\n that if the trait isn\u2019t defined in your scope, it doesn\u2019t apply. Here\u2019s an\n example: the standard library provides a [`Write`][write] trait which adds\n@@ -340,10 +400,10 @@ This shows off the additional feature of `where` clauses: they allow bounds\n where the left-hand side is an arbitrary type (`i32` in this case), not just a\n plain type parameter (like `T`).\n \n-## Default methods\n+# Default methods\n \n-There\u2019s one last feature of traits we should cover: default methods. It\u2019s\n-easiest just to show an example:\n+If you already know how a typical implementor will define a method, you can\n+let your trait supply a default:\n \n ```rust\n trait Foo {"}]}