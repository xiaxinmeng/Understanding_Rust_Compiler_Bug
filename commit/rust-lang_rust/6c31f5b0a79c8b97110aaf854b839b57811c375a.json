{"sha": "6c31f5b0a79c8b97110aaf854b839b57811c375a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMzFmNWIwYTc5YzhiOTcxMTBhYWY4NTRiODM5YjU3ODExYzM3NWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-07T13:48:58Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-07T13:48:58Z"}, "message": "Merge #1499\n\n1499: processing attribute #[path] of module  r=matklad a=andreevlex\n\nsupport two cases\r\n- simple name file `foo.rs`\r\n- declaration in mod.rs\r\n\r\n#1211 \n\nCo-authored-by: Alexander Andreev <andreevlex.as@gmail.com>", "tree": {"sha": "fe355f80c97e9e5fafe787ff0c9d5dd176df2c41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe355f80c97e9e5fafe787ff0c9d5dd176df2c41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c31f5b0a79c8b97110aaf854b839b57811c375a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c31f5b0a79c8b97110aaf854b839b57811c375a", "html_url": "https://github.com/rust-lang/rust/commit/6c31f5b0a79c8b97110aaf854b839b57811c375a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c31f5b0a79c8b97110aaf854b839b57811c375a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "89bfc59f1adc4c41235c4a17048c79c570eff6f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/89bfc59f1adc4c41235c4a17048c79c570eff6f4", "html_url": "https://github.com/rust-lang/rust/commit/89bfc59f1adc4c41235c4a17048c79c570eff6f4"}, {"sha": "1c582be63b35c6602638023d4bd0bc426b0ca744", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c582be63b35c6602638023d4bd0bc426b0ca744", "html_url": "https://github.com/rust-lang/rust/commit/1c582be63b35c6602638023d4bd0bc426b0ca744"}], "stats": {"total": 350, "additions": 241, "deletions": 109}, "files": [{"sha": "c84d2eada8219a4745930dd5de380bf14bc902ce", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=6c31f5b0a79c8b97110aaf854b839b57811c375a", "patch": "@@ -1,6 +1,6 @@\n /// This module implements import-resolution/macro expansion algorithm.\n ///\n-/// The result of this module is `CrateDefMap`: a datastructure which contains:\n+/// The result of this module is `CrateDefMap`: a data structure which contains:\n ///\n ///   * a tree of modules for the crate\n ///   * for each module, a set of items visible in the module (directly declared\n@@ -76,7 +76,7 @@ pub use self::{\n     raw::ImportId,\n };\n \n-/// Contans all top-level defs from a macro-expanded crate\n+/// Contains all top-level defs from a macro-expanded crate\n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateDefMap {\n     krate: Crate,"}, {"sha": "9f197bb58f7a4638eb8b1046ffe4a12c4fc5914a", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=6c31f5b0a79c8b97110aaf854b839b57811c375a", "patch": "@@ -1,6 +1,6 @@\n use arrayvec::ArrayVec;\n use ra_db::FileId;\n-use ra_syntax::ast;\n+use ra_syntax::{ast, SmolStr};\n use relative_path::RelativePathBuf;\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n@@ -508,11 +508,17 @@ where\n                 }\n                 .collect(&*items);\n             }\n-            // out of line module, resovle, parse and recurse\n-            raw::ModuleData::Declaration { name, ast_id } => {\n+            // out of line module, resolve, parse and recurse\n+            raw::ModuleData::Declaration { name, ast_id, attr_path } => {\n                 let ast_id = ast_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n-                match resolve_submodule(self.def_collector.db, self.file_id, name, is_root) {\n+                match resolve_submodule(\n+                    self.def_collector.db,\n+                    self.file_id,\n+                    name,\n+                    is_root,\n+                    attr_path.as_ref(),\n+                ) {\n                     Ok(file_id) => {\n                         let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n                         let raw_items = self.def_collector.db.raw_items(file_id.into());\n@@ -626,6 +632,7 @@ fn resolve_submodule(\n     file_id: HirFileId,\n     name: &Name,\n     is_root: bool,\n+    attr_path: Option<&SmolStr>,\n ) -> Result<FileId, RelativePathBuf> {\n     // FIXME: handle submodules of inline modules properly\n     let file_id = file_id.original_file(db);\n@@ -639,7 +646,13 @@ fn resolve_submodule(\n     let file_mod = dir_path.join(format!(\"{}.rs\", name));\n     let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n     let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n-    let mut candidates = ArrayVec::<[_; 2]>::new();\n+    let mut candidates = ArrayVec::<[_; 3]>::new();\n+    let file_attr_mod = attr_path.map(|file_path| {\n+        let file_attr_mod = dir_path.join(file_path.to_string());\n+        candidates.push(file_attr_mod.clone());\n+\n+        file_attr_mod\n+    });\n     if is_dir_owner {\n         candidates.push(file_mod.clone());\n         candidates.push(dir_mod);\n@@ -651,7 +664,13 @@ fn resolve_submodule(\n     // FIXME: handle ambiguity\n     match points_to.next() {\n         Some(file_id) => Ok(file_id),\n-        None => Err(if is_dir_owner { file_mod } else { file_dir_mod }),\n+        None => {\n+            if let Some(file_attr_mod) = file_attr_mod {\n+                Err(file_attr_mod)\n+            } else {\n+                Err(if is_dir_owner { file_mod } else { file_dir_mod })\n+            }\n+        }\n     }\n }\n "}, {"sha": "46b2bef5b579d75bbab9954499613af7c1064b68", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=6c31f5b0a79c8b97110aaf854b839b57811c375a", "patch": "@@ -3,7 +3,7 @@ use std::{ops::Index, sync::Arc};\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, AstPtr, SourceFile, TreeArc,\n+    AstNode, AstPtr, SmolStr, SourceFile, TreeArc,\n };\n use test_utils::tested_by;\n \n@@ -130,7 +130,7 @@ impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) enum ModuleData {\n-    Declaration { name: Name, ast_id: FileAstId<ast::Module> },\n+    Declaration { name: Name, ast_id: FileAstId<ast::Module>, attr_path: Option<SmolStr> },\n     Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n \n@@ -255,9 +255,12 @@ impl RawItemsCollector {\n             Some(it) => it.as_name(),\n             None => return,\n         };\n+\n+        let attr_path = extract_mod_path_attribute(module);\n         let ast_id = self.source_ast_id_map.ast_id(module);\n         if module.has_semi() {\n-            let item = self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id });\n+            let item =\n+                self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id, attr_path });\n             self.push_item(current_module, RawItem::Module(item));\n             return;\n         }\n@@ -339,3 +342,16 @@ impl RawItemsCollector {\n         .push(item)\n     }\n }\n+\n+fn extract_mod_path_attribute(module: &ast::Module) -> Option<SmolStr> {\n+    module.attrs().into_iter().find_map(|attr| {\n+        attr.as_key_value().and_then(|(name, value)| {\n+            let is_path = name == \"path\";\n+            if is_path {\n+                Some(value)\n+            } else {\n+                None\n+            }\n+        })\n+    })\n+}"}, {"sha": "8b0887fb59fe195ab6cd498242911e716ba59876", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 1, "deletions": 96, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=6c31f5b0a79c8b97110aaf854b839b57811c375a", "patch": "@@ -2,6 +2,7 @@ mod macros;\n mod globs;\n mod incremental;\n mod primitives;\n+mod mods;\n \n use std::sync::Arc;\n \n@@ -312,83 +313,6 @@ fn edition_2015_imports() {\n     \"###);\n }\n \n-#[test]\n-fn module_resolution_works_for_non_standard_filenames() {\n-    let map = def_map_with_crate_graph(\n-        \"\n-        //- /my_library.rs\n-        mod foo;\n-        use self::foo::Bar;\n-\n-        //- /foo/mod.rs\n-        pub struct Bar;\n-        \",\n-        crate_graph! {\n-            \"my_library\": (\"/my_library.rs\", []),\n-        },\n-    );\n-\n-    assert_snapshot_matches!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eefoo: t\n-        \u22ee\n-        \u22eecrate::foo\n-        \u22eeBar: t v\n-    \"###);\n-}\n-\n-#[test]\n-fn module_resolution_works_for_raw_modules() {\n-    let map = def_map_with_crate_graph(\n-        \"\n-        //- /library.rs\n-        mod r#async;\n-        use self::r#async::Bar;\n-\n-        //- /async.rs\n-        pub struct Bar;\n-        \",\n-        crate_graph! {\n-            \"library\": (\"/library.rs\", []),\n-        },\n-    );\n-\n-    assert_snapshot_matches!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBar: t v\n-        \u22eeasync: t\n-        \u22ee\n-        \u22eecrate::async\n-        \u22eeBar: t v\n-    \"###);\n-}\n-\n-#[test]\n-fn name_res_works_for_broken_modules() {\n-    covers!(name_res_works_for_broken_modules);\n-    let map = def_map(\n-        \"\n-        //- /lib.rs\n-        mod foo // no `;`, no body\n-\n-        use self::foo::Baz;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        pub use self::bar::Baz;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n-    );\n-    assert_snapshot_matches!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: _\n-    \"###);\n-}\n-\n #[test]\n fn item_map_using_self() {\n     let map = def_map(\n@@ -581,22 +505,3 @@ fn values_dont_shadow_extern_crates() {\n         \u22eefoo: v\n     \"###);\n }\n-\n-#[test]\n-fn unresolved_module_diagnostics() {\n-    let diagnostics = MockDatabase::with_files(\n-        r\"\n-        //- /lib.rs\n-        mod foo;\n-        mod bar;\n-        mod baz {}\n-        //- /foo.rs\n-        \",\n-    )\n-    .diagnostics();\n-\n-    assert_snapshot_matches!(diagnostics, @r###\"\n-\"mod bar;\": unresolved module\n-\"###\n-    );\n-}"}, {"sha": "7c8c832fc1781a3fdb5976f6634e6dcfd5084af8", "filename": "crates/ra_hir/src/nameres/tests/mods.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmods.rs?ref=6c31f5b0a79c8b97110aaf854b839b57811c375a", "patch": "@@ -0,0 +1,192 @@\n+use super::*;\n+\n+#[test]\n+fn name_res_works_for_broken_modules() {\n+    covers!(name_res_works_for_broken_modules);\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo // no `;`, no body\n+\n+        use self::foo::Baz;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        pub use self::bar::Baz;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBaz: _\n+    \"###);\n+}\n+\n+#[test]\n+fn module_resolution_works_for_non_standard_filenames() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /my_library.rs\n+        mod foo;\n+        use self::foo::Bar;\n+\n+        //- /foo/mod.rs\n+        pub struct Bar;\n+        \",\n+        crate_graph! {\n+            \"my_library\": (\"/my_library.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBar: t v\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::foo\n+        \u22eeBar: t v\n+    \"###);\n+}\n+\n+#[test]\n+fn module_resolution_works_for_raw_modules() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /library.rs\n+        mod r#async;\n+        use self::r#async::Bar;\n+\n+        //- /async.rs\n+        pub struct Bar;\n+        \",\n+        crate_graph! {\n+            \"library\": (\"/library.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBar: t v\n+        \u22eeasync: t\n+        \u22ee\n+        \u22eecrate::async\n+        \u22eeBar: t v\n+    \"###);\n+}\n+\n+#[test]\n+fn module_resolution_decl_path() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /library.rs\n+        #[path = \\\"bar/baz/foo.rs\\\"]\n+        mod foo;\n+        use self::foo::Bar;\n+\n+        //- /bar/baz/foo.rs\n+        pub struct Bar;\n+        \",\n+        crate_graph! {\n+            \"library\": (\"/library.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBar: t v\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::foo\n+        \u22eeBar: t v\n+    \"###);\n+}\n+\n+#[test]\n+fn module_resolution_module_with_path_in_mod_rs() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        mod foo;\n+        \n+        //- /foo/mod.rs\n+        #[path = \\\"baz.rs\\\"]\n+        pub mod bar;\n+\n+        use self::bar::Baz;\n+\n+        //- /foo/baz.rs\n+        pub struct Baz;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map, @r###\"\n+        \u22eecrate\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::foo\n+        \u22eeBaz: t v\n+        \u22eebar: t\n+        \u22ee\n+        \u22eecrate::foo::bar\n+        \u22eeBaz: t v\n+    \"###);\n+}\n+\n+#[test]\n+fn module_resolution_module_with_path_non_crate_root() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        mod foo;\n+        \n+        //- /foo.rs\n+        #[path = \\\"baz.rs\\\"]\n+        pub mod bar;\n+\n+        use self::bar::Baz;\n+\n+        //- /baz.rs\n+        pub struct Baz;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map, @r###\"\n+        \u22eecrate\n+        \u22eefoo: t\n+        \u22ee\n+        \u22eecrate::foo\n+        \u22eeBaz: t v\n+        \u22eebar: t\n+        \u22ee\n+        \u22eecrate::foo::bar\n+        \u22eeBaz: t v\n+    \"###);\n+}\n+\n+#[test]\n+fn unresolved_module_diagnostics() {\n+    let diagnostics = MockDatabase::with_files(\n+        r\"\n+        //- /lib.rs\n+        mod foo;\n+        mod bar;\n+        mod baz {}\n+        //- /foo.rs\n+        \",\n+    )\n+    .diagnostics();\n+\n+    assert_snapshot_matches!(diagnostics, @r###\"\n+\"mod bar;\": unresolved module\n+\"###\n+    );\n+}"}, {"sha": "76ace66ea912428460e3a988f97cb11f8c3f6f36", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=6c31f5b0a79c8b97110aaf854b839b57811c375a", "patch": "@@ -116,7 +116,7 @@ impl CrateImplBlocks {\n \n fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayVec<[Crate; 2]>> {\n     // Types like slice can have inherent impls in several crates, (core and alloc).\n-    // The correspoinding impls are marked with lang items, so we can use them to find the required crates.\n+    // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n     macro_rules! lang_item_crate {\n         ($db:expr, $cur_crate:expr, $($name:expr),+ $(,)?) => {{\n             let mut v = ArrayVec::<[Crate; 2]>::new();"}, {"sha": "6d44fef33e8e88d960e5d6ddf3f0ad131cb5b3a7", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c31f5b0a79c8b97110aaf854b839b57811c375a/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=6c31f5b0a79c8b97110aaf854b839b57811c375a", "patch": "@@ -52,7 +52,7 @@ pub fn set_filter(f: Filter) {\n /// It supports nested profiling scopes in case when this function invoked multiple times at the execution stack. In this case the profiling information will be nested at the output.\n /// Profiling information is being printed in the stderr.\n ///\n-/// #Example\n+/// # Example\n /// ```\n /// use ra_prof::{profile, set_filter, Filter};\n ///"}]}