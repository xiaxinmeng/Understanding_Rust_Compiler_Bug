{"sha": "38236a713512d0a70d1f03e995201d9bac63c882", "node_id": "C_kwDOAAsO6NoAKDM4MjM2YTcxMzUxMmQwYTcwZDFmMDNlOTk1MjAxZDliYWM2M2M4ODI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-29T04:09:55Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-10-02T21:15:19Z"}, "message": "Use `for_each_expr` in place of some visitors", "tree": {"sha": "9f4442f81d392deced82b18172feca0d8fac8839", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f4442f81d392deced82b18172feca0d8fac8839"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38236a713512d0a70d1f03e995201d9bac63c882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38236a713512d0a70d1f03e995201d9bac63c882", "html_url": "https://github.com/rust-lang/rust/commit/38236a713512d0a70d1f03e995201d9bac63c882", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38236a713512d0a70d1f03e995201d9bac63c882/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "649d443646e8ca6efad73643dcc11b488ae60a79", "url": "https://api.github.com/repos/rust-lang/rust/commits/649d443646e8ca6efad73643dcc11b488ae60a79", "html_url": "https://github.com/rust-lang/rust/commit/649d443646e8ca6efad73643dcc11b488ae60a79"}], "stats": {"total": 533, "additions": 205, "deletions": 328}, "files": [{"sha": "569bf27c3e716e13e3802e7e4cd6fe8bab627135", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -3,10 +3,11 @@ use clippy_utils::get_parent_expr;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{BlockCheckMode, Closure, Expr, ExprKind};\n+use rustc_hir::{BlockCheckMode, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -44,39 +45,6 @@ declare_clippy_lint! {\n \n declare_lint_pass!(BlocksInIfConditions => [BLOCKS_IN_IF_CONDITIONS]);\n \n-struct ExVisitor<'a, 'tcx> {\n-    found_block: Option<&'tcx Expr<'tcx>>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::Closure(&Closure { body, .. }) = expr.kind {\n-            // do not lint if the closure is called using an iterator (see #1141)\n-            if_chain! {\n-                if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, self_arg, ..) = &parent.kind;\n-                let caller = self.cx.typeck_results().expr_ty(self_arg);\n-                if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n-                if implements_trait(self.cx, caller, iter_id, &[]);\n-                then {\n-                    return;\n-                }\n-            }\n-\n-            let body = self.cx.tcx.hir().body(body);\n-            let ex = &body.value;\n-            if let ExprKind::Block(block, _) = ex.kind {\n-                if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n-                    self.found_block = Some(ex);\n-                    return;\n-                }\n-            }\n-        }\n-        walk_expr(self, expr);\n-    }\n-}\n-\n const BRACED_EXPR_MESSAGE: &str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &str = \"in an `if` condition, avoid complex blocks or closures with blocks; \\\n                                     instead, move the block or closure higher and bind it with a `let`\";\n@@ -144,11 +112,31 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor { found_block: None, cx };\n-                walk_expr(&mut visitor, cond);\n-                if let Some(block) = visitor.found_block {\n-                    span_lint(cx, BLOCKS_IN_IF_CONDITIONS, block.span, COMPLEX_BLOCK_MESSAGE);\n-                }\n+                let _: Option<!> = for_each_expr(cond, |e| {\n+                    if let ExprKind::Closure(closure) = e.kind {\n+                        // do not lint if the closure is called using an iterator (see #1141)\n+                        if_chain! {\n+                            if let Some(parent) = get_parent_expr(cx, e);\n+                            if let ExprKind::MethodCall(_, self_arg, _, _) = &parent.kind;\n+                            let caller = cx.typeck_results().expr_ty(self_arg);\n+                            if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+                            if implements_trait(cx, caller, iter_id, &[]);\n+                            then {\n+                                return ControlFlow::Continue(Descend::No);\n+                            }\n+                        }\n+\n+                        let body = cx.tcx.hir().body(closure.body);\n+                        let ex = &body.value;\n+                        if let ExprKind::Block(block, _) = ex.kind {\n+                            if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n+                                span_lint(cx, BLOCKS_IN_IF_CONDITIONS, ex.span, COMPLEX_BLOCK_MESSAGE);\n+                                return ControlFlow::Continue(Descend::No);\n+                            }\n+                        }\n+                    }\n+                    ControlFlow::Continue(Descend::Yes)\n+                });\n             }\n         }\n     }"}, {"sha": "77af3b53d63338ad735d7a46f351975af3343927", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -3,10 +3,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::LimitStack;\n+use core::ops::ControlFlow;\n use rustc_ast::ast::Attribute;\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId};\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, ExprKind, FnDecl, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n@@ -61,11 +63,27 @@ impl CognitiveComplexity {\n             return;\n         }\n \n-        let expr = &body.value;\n+        let expr = body.value;\n+\n+        let mut cc = 1u64;\n+        let mut returns = 0u64;\n+        let _: Option<!> = for_each_expr(expr, |e| {\n+            match e.kind {\n+                ExprKind::If(_, _, _) => {\n+                    cc += 1;\n+                },\n+                ExprKind::Match(_, arms, _) => {\n+                    if arms.len() > 1 {\n+                        cc += 1;\n+                    }\n+                    cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n+                },\n+                ExprKind::Ret(_) => returns += 1,\n+                _ => {},\n+            }\n+            ControlFlow::Continue(())\n+        });\n \n-        let mut helper = CcHelper { cc: 1, returns: 0 };\n-        helper.visit_expr(expr);\n-        let CcHelper { cc, returns } = helper;\n         let ret_ty = cx.typeck_results().node_type(expr.hir_id);\n         let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym::Result) {\n             returns\n@@ -74,13 +92,12 @@ impl CognitiveComplexity {\n             (returns / 2)\n         };\n \n-        let mut rust_cc = cc;\n         // prevent degenerate cases where unreachable code contains `return` statements\n-        if rust_cc >= ret_adjust {\n-            rust_cc -= ret_adjust;\n+        if cc >= ret_adjust {\n+            cc -= ret_adjust;\n         }\n \n-        if rust_cc > self.limit.limit() {\n+        if cc > self.limit.limit() {\n             let fn_span = match kind {\n                 FnKind::ItemFn(ident, _, _) | FnKind::Method(ident, _) => ident.span,\n                 FnKind::Closure => {\n@@ -107,7 +124,7 @@ impl CognitiveComplexity {\n                 COGNITIVE_COMPLEXITY,\n                 fn_span,\n                 &format!(\n-                    \"the function has a cognitive complexity of ({rust_cc}/{})\",\n+                    \"the function has a cognitive complexity of ({cc}/{})\",\n                     self.limit.limit()\n                 ),\n                 None,\n@@ -140,27 +157,3 @@ impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n         self.limit.pop_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n     }\n }\n-\n-struct CcHelper {\n-    cc: u64,\n-    returns: u64,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for CcHelper {\n-    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-        walk_expr(self, e);\n-        match e.kind {\n-            ExprKind::If(_, _, _) => {\n-                self.cc += 1;\n-            },\n-            ExprKind::Match(_, arms, _) => {\n-                if arms.len() > 1 {\n-                    self.cc += 1;\n-                }\n-                self.cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n-            },\n-            ExprKind::Ret(_) => self.returns += 1,\n-            _ => {},\n-        }\n-    }\n-}"}, {"sha": "d263804f32cf48538be82cad8e979d6543d490f8", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 33, "deletions": 44, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::{DefIdSet, LocalDefId};\n-use rustc_hir::{self as hir, def::Res, intravisit, QPath};\n+use rustc_hir::{self as hir, def::Res, QPath};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::{\n     lint::in_external_macro,\n@@ -13,8 +13,11 @@ use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n \n+use core::ops::ControlFlow;\n+\n use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n@@ -200,79 +203,65 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n     }\n }\n \n-struct StaticMutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    mutates_static: bool,\n+fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n+    use hir::ExprKind::{Field, Index, Path};\n+\n+    match e.kind {\n+        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n+        Path(_) => true,\n+        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n+        _ => false,\n+    }\n }\n \n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+    for_each_expr(body.value, |e| {\n         use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n \n-        if self.mutates_static {\n-            return;\n-        }\n-        match expr.kind {\n+        match e.kind {\n             Call(_, args) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                    if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n+                            cx,\n+                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n                         && is_mutated_static(arg)\n                     {\n-                        self.mutates_static = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                     tys.clear();\n                 }\n+                ControlFlow::Continue(())\n             },\n             MethodCall(_, receiver, args, _) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in std::iter::once(receiver).chain(args.iter()) {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                    if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n+                            cx,\n+                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n                         && is_mutated_static(arg)\n                     {\n-                        self.mutates_static = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                     tys.clear();\n                 }\n+                ControlFlow::Continue(())\n             },\n-            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n-                self.mutates_static |= is_mutated_static(target);\n+            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target)\n+                if is_mutated_static(target) =>\n+            {\n+                ControlFlow::Break(())\n             },\n-            _ => {},\n+            _ => ControlFlow::Continue(()),\n         }\n-    }\n-}\n-\n-fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n-    use hir::ExprKind::{Field, Index, Path};\n-\n-    match e.kind {\n-        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n-        Path(_) => true,\n-        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n-        _ => false,\n-    }\n-}\n-\n-fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n-    let mut v = StaticMutVisitor {\n-        cx,\n-        mutates_static: false,\n-    };\n-    intravisit::walk_expr(&mut v, body.value);\n-    v.mutates_static\n+    })\n+    .is_some()\n }"}, {"sha": "b7595d101e0fa9f04893f52eb75c8f44f4c98e96", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -5,8 +5,11 @@ use rustc_span::def_id::LocalDefId;\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::type_is_unsafe_function;\n+use clippy_utils::visitors::for_each_expr_with_closures;\n use clippy_utils::{iter_input_pats, path_to_local};\n \n+use core::ops::ControlFlow;\n+\n use super::NOT_UNSAFE_PTR_ARG_DEREF;\n \n pub(super) fn check_fn<'tcx>(\n@@ -39,21 +42,34 @@ fn check_raw_ptr<'tcx>(\n     body: &'tcx hir::Body<'tcx>,\n     def_id: LocalDefId,\n ) {\n-    let expr = &body.value;\n     if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(def_id) {\n         let raw_ptrs = iter_input_pats(decl, body)\n             .filter_map(|arg| raw_ptr_arg(cx, arg))\n             .collect::<HirIdSet>();\n \n         if !raw_ptrs.is_empty() {\n-            let typeck_results = cx.tcx.typeck_body(body.id());\n-            let mut v = DerefVisitor {\n-                cx,\n-                ptrs: raw_ptrs,\n-                typeck_results,\n-            };\n-\n-            intravisit::walk_expr(&mut v, expr);\n+            let typeck = cx.tcx.typeck_body(body.id());\n+            let _: Option<!> = for_each_expr_with_closures(cx, body.value, |e| {\n+                match e.kind {\n+                    hir::ExprKind::Call(f, args) if type_is_unsafe_function(cx, typeck.expr_ty(f)) => {\n+                        for arg in args {\n+                            check_arg(cx, &raw_ptrs, arg);\n+                        }\n+                    },\n+                    hir::ExprKind::MethodCall(_, recv, args, _) => {\n+                        let def_id = typeck.type_dependent_def_id(e.hir_id).unwrap();\n+                        if cx.tcx.fn_sig(def_id).skip_binder().unsafety == hir::Unsafety::Unsafe {\n+                            check_arg(cx, &raw_ptrs, recv);\n+                            for arg in args {\n+                                check_arg(cx, &raw_ptrs, arg);\n+                            }\n+                        }\n+                    },\n+                    hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => check_arg(cx, &raw_ptrs, ptr),\n+                    _ => (),\n+                }\n+                ControlFlow::Continue(())\n+            });\n         }\n     }\n }\n@@ -70,54 +86,13 @@ fn raw_ptr_arg(cx: &LateContext<'_>, arg: &hir::Param<'_>) -> Option<hir::HirId>\n     }\n }\n \n-struct DerefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    ptrs: HirIdSet,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Call(f, args) => {\n-                let ty = self.typeck_results.expr_ty(f);\n-\n-                if type_is_unsafe_function(self.cx, ty) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::MethodCall(_, receiver, args, _) => {\n-                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n-                let base_type = self.cx.tcx.type_of(def_id);\n-\n-                if type_is_unsafe_function(self.cx, base_type) {\n-                    self.check_arg(receiver);\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => self.check_arg(ptr),\n-            _ => (),\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n-    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n-        if let Some(id) = path_to_local(ptr) {\n-            if self.ptrs.contains(&id) {\n-                span_lint(\n-                    self.cx,\n-                    NOT_UNSAFE_PTR_ARG_DEREF,\n-                    ptr.span,\n-                    \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n-                );\n-            }\n-        }\n+fn check_arg(cx: &LateContext<'_>, raw_ptrs: &HirIdSet, arg: &hir::Expr<'_>) {\n+    if path_to_local(arg).map_or(false, |id| raw_ptrs.contains(&id)) {\n+        span_lint(\n+            cx,\n+            NOT_UNSAFE_PTR_ARG_DEREF,\n+            arg.span,\n+            \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n+        );\n     }\n }"}, {"sha": "1cef6226ad4ff40925445616a8bd93c986cef96e", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -2,9 +2,10 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n use clippy_utils::{is_res_lang_ctor, is_trait_method, path_res, path_to_local_id};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n@@ -13,7 +14,7 @@ use rustc_span::sym;\n use super::UNNECESSARY_FILTER_MAP;\n use super::UNNECESSARY_FIND_MAP;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, name: &str) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>, arg: &'tcx hir::Expr<'tcx>, name: &str) {\n     if !is_trait_method(cx, expr, sym::Iterator) {\n         return;\n     }\n@@ -26,10 +27,16 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n \n         let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, body.value);\n \n-        let mut return_visitor = ReturnVisitor::new(cx, arg_id);\n-        return_visitor.visit_expr(body.value);\n-        found_mapping |= return_visitor.found_mapping;\n-        found_filtering |= return_visitor.found_filtering;\n+        let _: Option<!> = for_each_expr(body.value, |e| {\n+            if let hir::ExprKind::Ret(Some(e)) = &e.kind {\n+                let (found_mapping_res, found_filtering_res) = check_expression(cx, arg_id, e);\n+                found_mapping |= found_mapping_res;\n+                found_filtering |= found_filtering_res;\n+                ControlFlow::Continue(Descend::No)\n+            } else {\n+                ControlFlow::Continue(Descend::Yes)\n+            }\n+        });\n \n         let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n@@ -97,35 +104,3 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n         _ => (true, true),\n     }\n }\n-\n-struct ReturnVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    arg_id: hir::HirId,\n-    // Found a non-None return that isn't Some(input)\n-    found_mapping: bool,\n-    // Found a return that isn't Some\n-    found_filtering: bool,\n-}\n-\n-impl<'a, 'tcx> ReturnVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n-        ReturnVisitor {\n-            cx,\n-            arg_id,\n-            found_mapping: false,\n-            found_filtering: false,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if let hir::ExprKind::Ret(Some(expr)) = &expr.kind {\n-            let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n-            self.found_mapping |= found_mapping;\n-            self.found_filtering |= found_filtering;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-}"}, {"sha": "26bca7c306a84e99d7e81f8370ed53696b62c11b", "filename": "clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -2,11 +2,12 @@ use clippy_utils::binop_traits;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{eq_expr_value, trait_ref_of_method};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_lint::LateContext;\n use rustc_middle::mir::FakeReadCause;\n@@ -65,15 +66,19 @@ pub(super) fn check<'tcx>(\n             }\n         };\n \n-        let mut visitor = ExprVisitor {\n-            assignee,\n-            counter: 0,\n-            cx,\n-        };\n-\n-        walk_expr(&mut visitor, e);\n+        let mut found = false;\n+        let found_multiple = for_each_expr(e, |e| {\n+            if eq_expr_value(cx, assignee, e) {\n+                if found {\n+                    return ControlFlow::Break(());\n+                }\n+                found = true;\n+            }\n+            ControlFlow::Continue(())\n+        })\n+        .is_some();\n \n-        if visitor.counter == 1 {\n+        if found && !found_multiple {\n             // a = a op b\n             if eq_expr_value(cx, assignee, l) {\n                 lint(assignee, r);\n@@ -98,22 +103,6 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n-struct ExprVisitor<'a, 'tcx> {\n-    assignee: &'a hir::Expr<'a>,\n-    counter: u8,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if eq_expr_value(self.cx, self.assignee, expr) {\n-            self.counter += 1;\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-}\n-\n fn imm_borrows_in_expr(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> hir::HirIdSet {\n     struct S(hir::HirIdSet);\n     impl Delegate<'_> for S {"}, {"sha": "2b2a41d160117a5f781cf7d389df8ad550e353d4", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -1,9 +1,11 @@\n use clippy_utils::diagnostics::{span_lint_and_then, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_opt, snippet_with_context};\n+use clippy_utils::visitors::{for_each_expr, Descend};\n use clippy_utils::{fn_def_id, path_to_local_id};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -270,33 +272,20 @@ fn emit_return_lint(\n }\n \n fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows || expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n+    for_each_expr(expr, |e| {\n+        if let Some(def_id) = fn_def_id(cx, e)\n+            && cx\n                 .tcx\n                 .fn_sig(def_id)\n-                .output()\n                 .skip_binder()\n+                .output()\n                 .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n+        {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(Descend::from(!expr.span.from_expansion()))\n         }\n-\n-        walk_expr(self, expr);\n-    }\n+    })\n+    .is_some()\n }"}, {"sha": "b57b484bdc897ed87aa85ae99daa1147153818c5", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{binop_traits, trait_ref_of_method, BINOP_TRAITS, OP_ASSIGN_TRAITS};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -92,25 +93,17 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n }\n \n fn count_binops(expr: &hir::Expr<'_>) -> u32 {\n-    let mut visitor = BinaryExprVisitor::default();\n-    visitor.visit_expr(expr);\n-    visitor.nb_binops\n-}\n-\n-#[derive(Default)]\n-struct BinaryExprVisitor {\n-    nb_binops: u32,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BinaryExprVisitor {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n+    let mut count = 0u32;\n+    let _: Option<!> = for_each_expr(expr, |e| {\n+        if matches!(\n+            e.kind,\n             hir::ExprKind::Binary(..)\n-            | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n-            | hir::ExprKind::AssignOp(..) => self.nb_binops += 1,\n-            _ => {},\n+                | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n+                | hir::ExprKind::AssignOp(..)\n+        ) {\n+            count += 1;\n         }\n-\n-        walk_expr(self, expr);\n-    }\n+        ControlFlow::Continue(())\n+    });\n+    count\n }"}, {"sha": "a69719b127b2fb04cc970d12356e83d1258dc687", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38236a713512d0a70d1f03e995201d9bac63c882/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=38236a713512d0a70d1f03e995201d9bac63c882", "patch": "@@ -1,12 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{method_chain_args, return_ty};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{Expr, ImplItemKind};\n+use rustc_hir::ImplItemKind;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n \n@@ -73,59 +73,45 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n     }\n }\n \n-struct FindExpectUnwrap<'a, 'tcx> {\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'tcx ty::TypeckResults<'tcx>,\n-    result: Vec<Span>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        // check for `expect`\n-        if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n-                || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n-            {\n-                self.result.push(expr.span);\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n+    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n+        let body = cx.tcx.hir().body(body_id);\n+        let typeck = cx.tcx.typeck(impl_item.def_id.def_id);\n+        let mut result = Vec::new();\n+        let _: Option<!> = for_each_expr(body.value, |e| {\n+            // check for `expect`\n+            if let Some(arglists) = method_chain_args(e, &[\"expect\"]) {\n+                let receiver_ty = typeck.expr_ty(arglists[0].0).peel_refs();\n+                if is_type_diagnostic_item(cx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(cx, receiver_ty, sym::Result)\n+                {\n+                    result.push(e.span);\n+                }\n             }\n-        }\n \n-        // check for `unwrap`\n-        if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n-                || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n-            {\n-                self.result.push(expr.span);\n+            // check for `unwrap`\n+            if let Some(arglists) = method_chain_args(e, &[\"unwrap\"]) {\n+                let receiver_ty = typeck.expr_ty(arglists[0].0).peel_refs();\n+                if is_type_diagnostic_item(cx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(cx, receiver_ty, sym::Result)\n+                {\n+                    result.push(e.span);\n+                }\n             }\n-        }\n \n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n-    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n-        let body = cx.tcx.hir().body(body_id);\n-        let mut fpu = FindExpectUnwrap {\n-            lcx: cx,\n-            typeck_results: cx.tcx.typeck(impl_item.def_id.def_id),\n-            result: Vec::new(),\n-        };\n-        fpu.visit_expr(body.value);\n+            ControlFlow::Continue(())\n+        });\n \n         // if we've found one, lint\n-        if !fpu.result.is_empty() {\n+        if !result.is_empty() {\n             span_lint_and_then(\n                 cx,\n                 UNWRAP_IN_RESULT,\n                 impl_span,\n                 \"used unwrap or expect in a function that returns result or option\",\n                 move |diag| {\n                     diag.help(\"unwrap and expect should not be used in a function that returns result or option\");\n-                    diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                    diag.span_note(result, \"potential non-recoverable error(s)\");\n                 },\n             );\n         }"}]}