{"sha": "7c9d786e5007004917d73749fad32bc3bff94cce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjOWQ3ODZlNTAwNzAwNDkxN2Q3Mzc0OWZhZDMyYmMzYmZmOTRjY2U=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-12T07:37:54Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-24T10:36:31Z"}, "message": "Move alignment and bounds check from `Memory` to `Allocation`", "tree": {"sha": "7d9557eb2ad9726bc32244cd7ec2673ea5e84b64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d9557eb2ad9726bc32244cd7ec2673ea5e84b64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c9d786e5007004917d73749fad32bc3bff94cce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9d786e5007004917d73749fad32bc3bff94cce", "html_url": "https://github.com/rust-lang/rust/commit/7c9d786e5007004917d73749fad32bc3bff94cce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c9d786e5007004917d73749fad32bc3bff94cce/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d98c46ce57d562ebcfb01ec814ff8d90d47ff7ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/d98c46ce57d562ebcfb01ec814ff8d90d47ff7ea", "html_url": "https://github.com/rust-lang/rust/commit/d98c46ce57d562ebcfb01ec814ff8d90d47ff7ea"}], "stats": {"total": 87, "additions": 45, "deletions": 42}, "files": [{"sha": "b2737ae203fbaac6b4cb148966b00961713f6084", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7c9d786e5007004917d73749fad32bc3bff94cce/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c9d786e5007004917d73749fad32bc3bff94cce/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=7c9d786e5007004917d73749fad32bc3bff94cce", "patch": "@@ -49,6 +49,51 @@ pub struct Allocation<Tag=(),Extra=()> {\n     pub extra: Extra,\n }\n \n+/// Alignment and bounds checks\n+impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n+    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n+    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n+    /// in-bounds!  This follows C's/LLVM's rules.  `check` indicates whether we\n+    /// additionally require the pointer to be pointing to a *live* (still allocated)\n+    /// allocation.\n+    /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n+    pub fn check_bounds_ptr(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        check: InboundsCheck,\n+    ) -> EvalResult<'tcx> {\n+        let allocation_size = match check {\n+            InboundsCheck::Live => {\n+                let alloc = self.get(ptr.alloc_id)?;\n+                alloc.bytes.len() as u64\n+            }\n+            InboundsCheck::MaybeDead => {\n+                self.get_size_and_align(ptr.alloc_id).0.bytes()\n+            }\n+        };\n+        if ptr.offset.bytes() > allocation_size {\n+            return err!(PointerOutOfBounds {\n+                ptr: ptr.erase_tag(),\n+                check,\n+                allocation_size: Size::from_bytes(allocation_size),\n+            });\n+        }\n+        Ok(())\n+    }\n+\n+    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n+    #[inline(always)]\n+    pub fn check_bounds(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        size: Size,\n+        check: InboundsCheck,\n+    ) -> EvalResult<'tcx> {\n+        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds_ptr(ptr.offset(size, &*self)?, check)\n+    }\n+}\n+\n /// Byte accessors\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined"}, {"sha": "9f8e8fc921af887610f9d694624b7deb934d25f2", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7c9d786e5007004917d73749fad32bc3bff94cce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c9d786e5007004917d73749fad32bc3bff94cce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7c9d786e5007004917d73749fad32bc3bff94cce", "patch": "@@ -284,48 +284,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             })\n         }\n     }\n-\n-    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n-    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.  `check` indicates whether we\n-    /// additionally require the pointer to be pointing to a *live* (still allocated)\n-    /// allocation.\n-    /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n-    pub fn check_bounds_ptr(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        check: InboundsCheck,\n-    ) -> EvalResult<'tcx> {\n-        let allocation_size = match check {\n-            InboundsCheck::Live => {\n-                let alloc = self.get(ptr.alloc_id)?;\n-                alloc.bytes.len() as u64\n-            }\n-            InboundsCheck::MaybeDead => {\n-                self.get_size_and_align(ptr.alloc_id).0.bytes()\n-            }\n-        };\n-        if ptr.offset.bytes() > allocation_size {\n-            return err!(PointerOutOfBounds {\n-                ptr: ptr.erase_tag(),\n-                check,\n-                allocation_size: Size::from_bytes(allocation_size),\n-            });\n-        }\n-        Ok(())\n-    }\n-\n-    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n-    #[inline(always)]\n-    pub fn check_bounds(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        size: Size,\n-        check: InboundsCheck,\n-    ) -> EvalResult<'tcx> {\n-        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds_ptr(ptr.offset(size, &*self)?, check)\n-    }\n }\n \n /// Allocation accessors"}]}