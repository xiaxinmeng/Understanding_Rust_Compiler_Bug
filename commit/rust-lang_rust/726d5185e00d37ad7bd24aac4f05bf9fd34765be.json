{"sha": "726d5185e00d37ad7bd24aac4f05bf9fd34765be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNmQ1MTg1ZTAwZDM3YWQ3YmQyNGFhYzRmMDViZjlmZDM0NzY1YmU=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-03-05T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-03-05T14:52:49Z"}, "message": "bootstrap: Use hash to determine if sanitizers needs to be rebuilt\n\n* Rebuild sanitizers runtimes when LLVM submodule commit changes.\n* When rebuilding LLVM / sanitizers, remove the stamp file before\n  starting the build process to invalidate previous build output.", "tree": {"sha": "a1252a0d54f1e7548f532d3bfa35b5667be371d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1252a0d54f1e7548f532d3bfa35b5667be371d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/726d5185e00d37ad7bd24aac4f05bf9fd34765be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/726d5185e00d37ad7bd24aac4f05bf9fd34765be", "html_url": "https://github.com/rust-lang/rust/commit/726d5185e00d37ad7bd24aac4f05bf9fd34765be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/726d5185e00d37ad7bd24aac4f05bf9fd34765be/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e179690f8ad9790eb3a6b1dbb6a0ddf479f2c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e179690f8ad9790eb3a6b1dbb6a0ddf479f2c86", "html_url": "https://github.com/rust-lang/rust/commit/1e179690f8ad9790eb3a6b1dbb6a0ddf479f2c86"}], "stats": {"total": 98, "additions": 67, "deletions": 31}, "files": [{"sha": "d4d66abd520a12b10dd9146f53e69ec9d2c97e02", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 67, "deletions": 31, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/726d5185e00d37ad7bd24aac4f05bf9fd34765be/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726d5185e00d37ad7bd24aac4f05bf9fd34765be/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=726d5185e00d37ad7bd24aac4f05bf9fd34765be", "patch": "@@ -11,6 +11,7 @@\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n@@ -54,7 +55,6 @@ impl Step for Llvm {\n             }\n         }\n \n-        let llvm_info = &builder.in_tree_llvm_info;\n         let root = \"src/llvm-project/llvm\";\n         let out_dir = builder.llvm_out(target);\n         let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n@@ -65,40 +65,35 @@ impl Step for Llvm {\n \n         let build_llvm_config =\n             llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n-        let done_stamp = out_dir.join(\"llvm-finished-building\");\n \n-        if done_stamp.exists() {\n-            if builder.config.llvm_skip_rebuild {\n-                builder.info(\n-                    \"Warning: \\\n-                    Using a potentially stale build of LLVM; \\\n-                    This may not behave well.\",\n-                );\n-                return build_llvm_config;\n-            }\n+        let stamp = out_dir.join(\"llvm-finished-building\");\n+        let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n \n-            if let Some(llvm_commit) = llvm_info.sha() {\n-                let done_contents = t!(fs::read(&done_stamp));\n+        if builder.config.llvm_skip_rebuild && stamp.path.exists() {\n+            builder.info(\n+                \"Warning: \\\n+                Using a potentially stale build of LLVM; \\\n+                This may not behave well.\",\n+            );\n+            return build_llvm_config;\n+        }\n \n-                // If LLVM was already built previously and the submodule's commit didn't change\n-                // from the previous build, then no action is required.\n-                if done_contents == llvm_commit.as_bytes() {\n-                    return build_llvm_config;\n-                }\n-            } else {\n+        if stamp.is_done() {\n+            if stamp.hash.is_none() {\n                 builder.info(\n                     \"Could not determine the LLVM submodule commit hash. \\\n                      Assuming that an LLVM rebuild is not necessary.\",\n                 );\n                 builder.info(&format!(\n                     \"To force LLVM to rebuild, remove the file `{}`\",\n-                    done_stamp.display()\n+                    stamp.path.display()\n                 ));\n-                return build_llvm_config;\n             }\n+            return build_llvm_config;\n         }\n \n         builder.info(&format!(\"Building LLVM for {}\", target));\n+        t!(stamp.remove());\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n@@ -271,7 +266,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        t!(fs::write(&done_stamp, llvm_info.sha().unwrap_or(\"\")));\n+        t!(stamp.write());\n \n         build_llvm_config\n     }\n@@ -584,17 +579,21 @@ impl Step for Sanitizers {\n             return runtimes;\n         }\n \n-        let done_stamp = out_dir.join(\"sanitizers-finished-building\");\n-        if done_stamp.exists() {\n-            builder.info(&format!(\n-                \"Assuming that sanitizers rebuild is not necessary. \\\n-                To force a rebuild, remove the file `{}`\",\n-                done_stamp.display()\n-            ));\n+        let stamp = out_dir.join(\"sanitizers-finished-building\");\n+        let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n+\n+        if stamp.is_done() {\n+            if stamp.hash.is_none() {\n+                builder.info(&format!(\n+                    \"Rebuild sanitizers by removing the file `{}`\",\n+                    stamp.path.display()\n+                ));\n+            }\n             return runtimes;\n         }\n \n         builder.info(&format!(\"Building sanitizers for {}\", self.target));\n+        t!(stamp.remove());\n         let _time = util::timeit(&builder);\n \n         let mut cfg = cmake::Config::new(&compiler_rt_dir);\n@@ -623,8 +622,7 @@ impl Step for Sanitizers {\n             cfg.build_target(&runtime.cmake_target);\n             cfg.build();\n         }\n-\n-        t!(fs::write(&done_stamp, b\"\"));\n+        t!(stamp.write());\n \n         runtimes\n     }\n@@ -689,3 +687,41 @@ fn supported_sanitizers(\n     }\n     result\n }\n+\n+struct HashStamp {\n+    path: PathBuf,\n+    hash: Option<Vec<u8>>,\n+}\n+\n+impl HashStamp {\n+    fn new(path: PathBuf, hash: Option<&str>) -> Self {\n+        HashStamp { path, hash: hash.map(|s| s.as_bytes().to_owned()) }\n+    }\n+\n+    fn is_done(&self) -> bool {\n+        match fs::read(&self.path) {\n+            Ok(h) => self.hash.as_deref().unwrap_or(b\"\") == h.as_slice(),\n+            Err(e) if e.kind() == io::ErrorKind::NotFound => false,\n+            Err(e) => {\n+                panic!(\"failed to read stamp file `{}`: {}\", self.path.display(), e);\n+            }\n+        }\n+    }\n+\n+    fn remove(&self) -> io::Result<()> {\n+        match fs::remove_file(&self.path) {\n+            Ok(()) => Ok(()),\n+            Err(e) => {\n+                if e.kind() == io::ErrorKind::NotFound {\n+                    Ok(())\n+                } else {\n+                    Err(e)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn write(&self) -> io::Result<()> {\n+        fs::write(&self.path, self.hash.as_deref().unwrap_or(b\"\"))\n+    }\n+}"}]}