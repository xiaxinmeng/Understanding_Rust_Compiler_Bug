{"sha": "d619e8995f70556d58e57a699ba726c17f9e48ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MTllODk5NWY3MDU1NmQ1OGU1N2E2OTliYTcyNmMxN2Y5ZTQ4YWQ=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-06-01T22:52:07Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-06-15T19:41:41Z"}, "message": "Make token trees re-lexable.", "tree": {"sha": "0c83bf73c9a629c34c19e9267a8e897cdcb1c6cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c83bf73c9a629c34c19e9267a8e897cdcb1c6cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d619e8995f70556d58e57a699ba726c17f9e48ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d619e8995f70556d58e57a699ba726c17f9e48ad", "html_url": "https://github.com/rust-lang/rust/commit/d619e8995f70556d58e57a699ba726c17f9e48ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d619e8995f70556d58e57a699ba726c17f9e48ad/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d25981c730f41591622a9c1a04cdd3de84e5a30", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d25981c730f41591622a9c1a04cdd3de84e5a30", "html_url": "https://github.com/rust-lang/rust/commit/1d25981c730f41591622a9c1a04cdd3de84e5a30"}], "stats": {"total": 68, "additions": 66, "deletions": 2}, "files": [{"sha": "bf151ca4a6803efa8ed16a7fbc84bb3c42f21467", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d619e8995f70556d58e57a699ba726c17f9e48ad/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d619e8995f70556d58e57a699ba726c17f9e48ad/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=d619e8995f70556d58e57a699ba726c17f9e48ad", "patch": "@@ -1,6 +1,7 @@\n import util::interner;\n import util::interner::intern;\n import diagnostic;\n+import ast::{tt_delim,tt_flat};\n \n export reader, string_reader, new_string_reader, is_whitespace;\n export nextch, is_eof, bump, get_str_from;\n@@ -14,6 +15,26 @@ iface reader {\n     fn interner() -> @interner::interner<@str>;\n }\n \n+enum tt_frame_up { /* to break a circularity */\n+    tt_frame_up(option<tt_frame>)\n+}\n+\n+type tt_frame = @{\n+    /* invariant: readme[idx] is always a tt_flat */\n+    readme: [ast::token_tree],\n+    mut idx: uint,\n+    up: tt_frame_up\n+};\n+\n+type tt_reader = @{\n+    mut cur: tt_frame,\n+    interner: @interner::interner<@str>,\n+    span_diagnostic: diagnostic::span_handler,\n+    /* cached: */\n+    mut cur_tok: token::token,\n+    mut cur_chpos: uint\n+};\n+\n type string_reader = @{\n     span_diagnostic: diagnostic::span_handler,\n     src: @str,\n@@ -39,13 +60,56 @@ impl string_reader_as_reader of reader for string_reader {\n     }\n     fn fatal(m: str) -> ! {\n         self.span_diagnostic.span_fatal(\n-            ast_util::mk_sp(self.chpos, self.chpos),\n-            m)\n+            ast_util::mk_sp(self.chpos, self.chpos), m)\n     }\n     fn chpos() -> uint { self.chpos }\n     fn interner() -> @interner::interner<@str> { self.interner }\n }\n \n+impl tt_reader_as_reader of reader for tt_reader {\n+    fn is_eof() -> bool { self.cur_tok == token::EOF }\n+    fn next_token() -> {tok: token::token, chpos: uint} {\n+        let ret_val = { tok: self.cur_tok, chpos: self.cur_chpos };\n+        self.cur.idx += 1u;\n+        if self.cur.idx >= vec::len(self.cur.readme) {\n+            /* done with this set; pop */\n+            alt self.cur.up {\n+              tt_frame_up(option::none) {\n+                self.cur_tok = token::EOF;\n+                ret ret_val;\n+              }\n+              tt_frame_up(option::some(tt_f)) {\n+                self.cur = tt_f;\n+                /* the above `if` would need to be a `while` if we didn't know\n+                that the last thing in a `tt_delim` is always a `tt_flat` */\n+                self.cur.idx += 1u;\n+              }\n+            }\n+        }\n+        /* if `tt_delim`s could be 0-length, we'd need to be able to switch\n+        between popping and pushing until we got to an actual `tt_flat` */\n+        loop { /* because it's easiest, this handles `tt_delim` not starting\n+                  with a `tt_flat`, even though it won't happen */\n+            alt self.cur.readme[self.cur.idx] {\n+              tt_delim(tts) {\n+                self.cur = @{readme: tts, mut idx: 0u,\n+                             up: tt_frame_up(option::some(self.cur)) };\n+              }\n+              tt_flat(chpos, tok) {\n+                self.cur_chpos = chpos; self.cur_tok = tok;\n+                ret ret_val;\n+              }\n+          }\n+        }\n+    }\n+    fn fatal(m: str) -> ! {\n+        self.span_diagnostic.span_fatal(\n+            ast_util::mk_sp(self.chpos(), self.chpos()), m);\n+    }\n+    fn chpos() -> uint { self.cur_chpos }\n+    fn interner() -> @interner::interner<@str> { self.interner }\n+}\n+\n fn get_str_from(rdr: string_reader, start: uint) -> str unsafe {\n     // I'm pretty skeptical about this subtraction. What if there's a\n     // multi-byte character before the mark?"}]}