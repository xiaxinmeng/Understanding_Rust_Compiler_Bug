{"sha": "8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhOTc2NjAwMGVjNjBmMmQzODFhOGJjNjRjZGUxYjdlOWFiYzdjNmI=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-12T18:47:44Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-12T18:47:44Z"}, "message": "Change a bunch of places in the stdlib to use blocks.", "tree": {"sha": "c2cdcbda37d24324e5afd13ede1dcde44bb017c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2cdcbda37d24324e5afd13ede1dcde44bb017c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "html_url": "https://github.com/rust-lang/rust/commit/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de4b383a0f6959ce4376274c5cae1b94bb76947c", "url": "https://api.github.com/repos/rust-lang/rust/commits/de4b383a0f6959ce4376274c5cae1b94bb76947c", "html_url": "https://github.com/rust-lang/rust/commit/de4b383a0f6959ce4376274c5cae1b94bb76947c"}], "stats": {"total": 90, "additions": 42, "deletions": 48}, "files": [{"sha": "f922789e9f008b3e7036a959bf0aafe8b957c4e4", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "patch": "@@ -36,7 +36,7 @@ fn create(nbits: uint, init: bool) -> t {\n     ret @{storage: storage, nbits: nbits};\n }\n \n-fn process(op: &fn(uint, uint) -> uint , v0: &t, v1: &t) -> bool {\n+fn process(op: &block(uint, uint) -> uint , v0: &t, v1: &t) -> bool {\n     let len = ivec::len(v1.storage);\n     assert (ivec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);"}, {"sha": "4c84e804185f3e6908552ccdbf029186ae751665", "filename": "src/lib/either.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "patch": "@@ -5,11 +5,8 @@ import option::none;\n \n tag t[T, U] { left(T); right(U); }\n \n-type operator[T, U] = fn(&T) -> U ;\n-\n-fn either[T, U,\n-          V](f_left: &operator[T, V], f_right: &operator[U, V],\n-             value: &t[T, U]) -> V {\n+fn either[T, U, V](f_left: &block(&T) -> V, f_right: &block(&U) -> V,\n+                   value: &t[T, U]) -> V {\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n "}, {"sha": "09c5841d42a913475679a7acc8f69f2bfe6b08c9", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "patch": "@@ -5,8 +5,6 @@ import option::some;\n import uint::next_power_of_two;\n import ptr::addr_of;\n \n-type operator2[T, U, V] = fn(&T, &U) -> V ;\n-\n native \"rust-intrinsic\" mod rusti {\n     fn ivec_len[T](v: &[T]) -> uint;\n }\n@@ -192,7 +190,7 @@ fn grow_set[@T](v: &mutable [mutable T], index: uint, initval: &T, val: &T) {\n \n // Functional utilities\n \n-fn map[@T, @U](f: fn(&T) -> U , v: &[mutable? T]) -> [U] {\n+fn map[@T, @U](f: &block(&T) -> U , v: &[mutable? T]) -> [U] {\n     let result = ~[];\n     reserve(result, len(v));\n     for elem: T  in v {\n@@ -202,7 +200,8 @@ fn map[@T, @U](f: fn(&T) -> U , v: &[mutable? T]) -> [U] {\n     ret result;\n }\n \n-fn filter_map[@T, @U](f: fn(&T) -> option::t[U] , v: &[mutable? T]) -> [U] {\n+fn filter_map[@T, @U](f: &block(&T) -> option::t[U],\n+                      v: &[mutable? T]) -> [U] {\n     let result = ~[];\n     for elem: T  in v {\n         let elem2 = elem; // satisfies alias checker\n@@ -214,20 +213,20 @@ fn filter_map[@T, @U](f: fn(&T) -> option::t[U] , v: &[mutable? T]) -> [U] {\n     ret result;\n }\n \n-fn foldl[@T, @U](p: fn(&U, &T) -> U , z: &U, v: &[mutable? T]) -> U {\n+fn foldl[@T, @U](p: &block(&U, &T) -> U , z: &U, v: &[mutable? T]) -> U {\n     let sz = len(v);\n     if sz == 0u { ret z; }\n     let first = v.(0);\n     let rest = slice(v, 1u, sz);\n-    ret p(foldl[T, U](p, z, rest), first);\n+    ret p(foldl(p, z, rest), first);\n }\n \n-fn any[T](f: fn(&T) -> bool , v: &[T]) -> bool {\n+fn any[T](f: &block(&T) -> bool , v: &[T]) -> bool {\n     for elem: T  in v { if f(elem) { ret true; } }\n     ret false;\n }\n \n-fn all[T](f: fn(&T) -> bool , v: &[T]) -> bool {\n+fn all[T](f: &block(&T) -> bool , v: &[T]) -> bool {\n     for elem: T  in v { if !f(elem) { ret false; } }\n     ret true;\n }\n@@ -243,9 +242,9 @@ fn count[T](x: &T, v: &[mutable? T]) -> uint {\n     ret cnt;\n }\n \n-fn find[@T](f: fn(&T) -> bool , v: &[T]) -> option::t[T] {\n-    for elt: T  in v { if f(elt) { ret some[T](elt); } }\n-    ret none[T];\n+fn find[@T](f: &block(&T) -> bool , v: &[T]) -> option::t[T] {\n+    for elt: T  in v { if f(elt) { ret some(elt); } }\n+    ret none;\n }\n \n fn unzip[@T, @U](v: &[{_0: T, _1: U}]) -> {_0: [T], _1: [U]} {"}, {"sha": "5aaf16c9f97de414c921d2ceeebae04d6ec72b8d", "filename": "src/lib/list.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "patch": "@@ -13,7 +13,7 @@ fn from_vec[@T](v: vec[T]) -> list[T] {\n     ret l;\n }\n \n-fn foldl[@T, @U](ls_: &list[T], u: &U, f: fn(&T, &U) -> U ) -> U {\n+fn foldl[@T, @U](ls_: &list[T], u: &U, f: &block(&T, &U) -> U ) -> U {\n     let accum: U = u;\n     let ls = ls_;\n     while true {\n@@ -25,7 +25,8 @@ fn foldl[@T, @U](ls_: &list[T], u: &U, f: fn(&T, &U) -> U ) -> U {\n     ret accum;\n }\n \n-fn find[@T, @U](ls_: &list[T], f: fn(&T) -> option::t[U] ) -> option::t[U] {\n+fn find[@T, @U](ls_: &list[T], f: &block(&T) -> option::t[U])\n+    -> option::t[U] {\n     let ls = ls_;\n     while true {\n         alt ls {"}, {"sha": "ff2dfc71efbd407927b7924aa4349caceb95703c", "filename": "src/lib/option.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "patch": "@@ -2,16 +2,14 @@\n \n tag t[@T] { none; some(T); }\n \n-type operator[@T, @U] = fn(&T) -> U ;\n-\n fn get[@T](opt: &t[T]) -> T {\n     alt opt {\n       some(x) { x }\n       none. { fail \"option none\" }\n     }\n }\n \n-fn map[@T, @U](f: &operator[T, U], opt: &t[T]) -> t[U] {\n+fn map[@T, @U](f: &block(&T) -> U, opt: &t[T]) -> t[U] {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n@@ -25,12 +23,12 @@ fn from_maybe[@T](def: &T, opt: &t[T]) -> T {\n     alt opt { some(x) { x } none. { def } }\n }\n \n-fn maybe[@T, @U](def: &U, f: fn(&T) -> U , opt: &t[T]) -> U {\n+fn maybe[@T, @U](def: &U, f: &block(&T) -> U, opt: &t[T]) -> U {\n     alt opt { none. { def } some(t) { f(t) } }\n }\n \n // Can be defined in terms of the above when/if we have const bind.\n-fn may[@T](f: fn(&T) , opt: &t[T]) {\n+fn may[@T](f: &block(&T), opt: &t[T]) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n "}, {"sha": "825a16cea6d683b06f81a7afd70651adcc6a5289", "filename": "src/lib/sort.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "patch": "@@ -9,10 +9,10 @@ export merge_sort;\n export quick_sort;\n export quick_sort3;\n \n-type lteq[T] = fn(&T, &T) -> bool ;\n+type lteq[T] = block(&T, &T) -> bool ;\n \n-fn merge_sort[@T](le: lteq[T], v: vec[T]) -> vec[T] {\n-    fn merge[@T](le: lteq[T], a: vec[T], b: vec[T]) -> vec[T] {\n+fn merge_sort[@T](le: &lteq[T], v: vec[T]) -> vec[T] {\n+    fn merge[@T](le: &lteq[T], a: vec[T], b: vec[T]) -> vec[T] {\n         let rs: vec[T] = [];\n         let a_len: uint = len[T](a);\n         let a_ix: uint = 0u;\n@@ -42,8 +42,8 @@ fn swap[@T](arr: vec[mutable T], x: uint, y: uint) {\n     arr.(y) = a;\n }\n \n-fn part[@T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n-           right: uint, pivot: uint) -> uint {\n+fn part[@T](compare_func: &lteq[T], arr: vec[mutable T], left: uint,\n+            right: uint, pivot: uint) -> uint {\n     let pivot_value = arr.(pivot);\n     swap[T](arr, pivot, right);\n     let storage_index: uint = left;\n@@ -59,8 +59,8 @@ fn part[@T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n     ret storage_index;\n }\n \n-fn qsort[@T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n-            right: uint) {\n+fn qsort[@T](compare_func: &lteq[T], arr: vec[mutable T], left: uint,\n+             right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n         let new_pivot = part[T](compare_func, arr, left, right, pivot);\n@@ -72,7 +72,7 @@ fn qsort[@T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n     }\n }\n \n-fn quick_sort[@T](compare_func: lteq[T], arr: vec[mutable T]) {\n+fn quick_sort[@T](compare_func: &lteq[T], arr: vec[mutable T]) {\n     if len[T](arr) == 0u { ret; }\n     qsort[T](compare_func, arr, 0u, len[T](arr) - 1u);\n }\n@@ -82,7 +82,7 @@ fn quick_sort[@T](compare_func: lteq[T], arr: vec[mutable T]) {\n // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n // According to these slides this is the algorithm of choice for\n // 'randomly ordered keys, abstract compare' & 'small number of key values'\n-fn qsort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n+fn qsort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n              arr: vec[mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr.(right);\n@@ -130,7 +130,7 @@ fn qsort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n     qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-fn quick_sort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n+fn quick_sort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n                   arr: vec[mutable T]) {\n     if vec::len[T](arr) == 0u { ret; }\n     qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n@@ -144,8 +144,8 @@ mod ivector {\n \n     type lteq[T] = fn(&T, &T) -> bool ;\n \n-    fn merge_sort[@T](le: lteq[T], v: &[T]) -> [T] {\n-        fn merge[@T](le: lteq[T], a: &[T], b: &[T]) -> [T] {\n+    fn merge_sort[@T](le: &lteq[T], v: &[T]) -> [T] {\n+        fn merge[@T](le: &lteq[T], a: &[T], b: &[T]) -> [T] {\n             let rs: [T] = ~[];\n             let a_len: uint = ilen[T](a);\n             let a_ix: uint = 0u;\n@@ -175,8 +175,8 @@ mod ivector {\n         arr.(y) = a;\n     }\n \n-    fn part[@T](compare_func: lteq[T], arr: &[mutable T], left: uint,\n-               right: uint, pivot: uint) -> uint {\n+    fn part[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n+                right: uint, pivot: uint) -> uint {\n         let pivot_value = arr.(pivot);\n         swap[T](arr, pivot, right);\n         let storage_index: uint = left;\n@@ -192,8 +192,8 @@ mod ivector {\n         ret storage_index;\n     }\n \n-    fn qsort[@T](compare_func: lteq[T], arr: &[mutable T], left: uint,\n-                right: uint) {\n+    fn qsort[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n+                 right: uint) {\n         if right > left {\n             let pivot = (left + right) / 2u;\n             let new_pivot = part[T](compare_func, arr, left, right, pivot);\n@@ -205,7 +205,7 @@ mod ivector {\n         }\n     }\n \n-    fn quick_sort[@T](compare_func: lteq[T], arr: &[mutable T]) {\n+    fn quick_sort[@T](compare_func: &lteq[T], arr: &[mutable T]) {\n         if ilen[T](arr) == 0u { ret; }\n         qsort[T](compare_func, arr, 0u, ilen[T](arr) - 1u);\n     }\n@@ -216,8 +216,8 @@ mod ivector {\n     // According to these slides this is the algorithm of choice for\n     // 'randomly ordered keys, abstract compare' & 'small number of key\n     // values'\n-    fn qsort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n-                 arr: &[mutable T], left: int, right: int) {\n+    fn qsort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n+                  arr: &[mutable T], left: int, right: int) {\n         if right <= left { ret; }\n         let v: T = arr.(right);\n         let i: int = left - 1;\n@@ -264,8 +264,8 @@ mod ivector {\n         qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n     }\n \n-    fn quick_sort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n-                      arr: &[mutable T]) {\n+    fn quick_sort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n+                       arr: &[mutable T]) {\n         if ilen[T](arr) == 0u { ret; }\n         qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n                   (ilen[T](arr) as int) - 1);"}, {"sha": "ab7ebd5a9e06abd25170a5a0d766e31b8e04a9d4", "filename": "src/test/stdtest/vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=8a9766000ec60f2d381a8bc64cde1b7e9abc7c6b", "patch": "@@ -39,9 +39,8 @@ fn test_slice() {\n #[test]\n fn test_map() {\n     fn square(x: &int) -> int { ret x * x; }\n-    let op: option::operator[int, int] = square;\n     let v: vec[int] = [1, 2, 3, 4, 5];\n-    let s: vec[int] = map[int, int](op, v);\n+    let s: vec[int] = map(square, v);\n     let i: int = 0;\n     while i < 5 { assert (v.(i) * v.(i) == s.(i)); i += 1; }\n }\n@@ -92,4 +91,4 @@ fn test_position_pred() {\n     let v1: vec[int] = [5, 4, 3, 2, 1];\n     assert (position_pred(less_than_three, v1) == option::some[uint](3u));\n     assert (position_pred(is_eighteen, v1) == option::none[uint]);\n-}\n\\ No newline at end of file\n+}"}]}