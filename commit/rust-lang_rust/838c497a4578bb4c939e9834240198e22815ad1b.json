{"sha": "838c497a4578bb4c939e9834240198e22815ad1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzOGM0OTdhNDU3OGJiNGM5MzllOTgzNDI0MDE5OGUyMjgxNWFkMWI=", "commit": {"author": {"name": "Christopher Serr", "email": "christopher.serr@gmail.com", "date": "2020-06-30T19:44:44Z"}, "committer": {"name": "Christopher Serr", "email": "christopher.serr@gmail.com", "date": "2020-07-02T07:35:37Z"}, "message": "Address review comments and add UI test", "tree": {"sha": "c1843266535caa7ddca94e5bc9629c0ef3651ab5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1843266535caa7ddca94e5bc9629c0ef3651ab5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/838c497a4578bb4c939e9834240198e22815ad1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/838c497a4578bb4c939e9834240198e22815ad1b", "html_url": "https://github.com/rust-lang/rust/commit/838c497a4578bb4c939e9834240198e22815ad1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/838c497a4578bb4c939e9834240198e22815ad1b/comments", "author": {"login": "CryZe", "id": 1451630, "node_id": "MDQ6VXNlcjE0NTE2MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1451630?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CryZe", "html_url": "https://github.com/CryZe", "followers_url": "https://api.github.com/users/CryZe/followers", "following_url": "https://api.github.com/users/CryZe/following{/other_user}", "gists_url": "https://api.github.com/users/CryZe/gists{/gist_id}", "starred_url": "https://api.github.com/users/CryZe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CryZe/subscriptions", "organizations_url": "https://api.github.com/users/CryZe/orgs", "repos_url": "https://api.github.com/users/CryZe/repos", "events_url": "https://api.github.com/users/CryZe/events{/privacy}", "received_events_url": "https://api.github.com/users/CryZe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CryZe", "id": 1451630, "node_id": "MDQ6VXNlcjE0NTE2MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1451630?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CryZe", "html_url": "https://github.com/CryZe", "followers_url": "https://api.github.com/users/CryZe/followers", "following_url": "https://api.github.com/users/CryZe/following{/other_user}", "gists_url": "https://api.github.com/users/CryZe/gists{/gist_id}", "starred_url": "https://api.github.com/users/CryZe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CryZe/subscriptions", "organizations_url": "https://api.github.com/users/CryZe/orgs", "repos_url": "https://api.github.com/users/CryZe/repos", "events_url": "https://api.github.com/users/CryZe/events{/privacy}", "received_events_url": "https://api.github.com/users/CryZe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f8c90e5b5b9d005999c18257f3844e92bc89eee", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f8c90e5b5b9d005999c18257f3844e92bc89eee", "html_url": "https://github.com/rust-lang/rust/commit/8f8c90e5b5b9d005999c18257f3844e92bc89eee"}], "stats": {"total": 1033, "additions": 528, "deletions": 505}, "files": [{"sha": "6775baa8c3273e7ef7a7b2a3a35c62a8d05c4eb3", "filename": "src/ci/docker/test-various/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/838c497a4578bb4c939e9834240198e22815ad1b/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/838c497a4578bb4c939e9834240198e22815ad1b/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile?ref=838c497a4578bb4c939e9834240198e22815ad1b", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   wget \\\n   patch\n \n-RUN curl -sL https://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.xz | \\\n+RUN curl -sL https://nodejs.org/dist/v14.4.0/node-v14.4.0-linux-x64.tar.xz | \\\n   tar -xJ\n \n WORKDIR /build/\n@@ -30,7 +30,7 @@ RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n   --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n-  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n+  --set build.nodejs=/node-v14.4.0-linux-x64/bin/node \\\n   --set rust.lld\n \n # Some run-make tests have assertions about code size, and enabling debug"}, {"sha": "89b70dce52c661c8c571f0929d306f846378c3bd", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/838c497a4578bb4c939e9834240198e22815ad1b/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838c497a4578bb4c939e9834240198e22815ad1b/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=838c497a4578bb4c939e9834240198e22815ad1b", "patch": "@@ -658,7 +658,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // `nontrapping-fptoint` target feature is activated. We'll use those if\n         // they are available.\n         if self.sess().target.target.arch == \"wasm32\"\n-            && self.sess().target_features.contains(&sym::wasm_nontrapping_fptoint)\n+            && self.sess().target_features.contains(&sym::nontrapping_fptoint)\n         {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n@@ -683,7 +683,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // `nontrapping-fptoint` target feature is activated. We'll use those if\n         // they are available.\n         if self.sess().target.target.arch == \"wasm32\"\n-            && self.sess().target_features.contains(&sym::wasm_nontrapping_fptoint)\n+            && self.sess().target_features.contains(&sym::nontrapping_fptoint)\n         {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);"}, {"sha": "c94e049e52d4ecae3c556483fb1f3fc7f2c6f70e", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/838c497a4578bb4c939e9834240198e22815ad1b/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838c497a4578bb4c939e9834240198e22815ad1b/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=838c497a4578bb4c939e9834240198e22815ad1b", "patch": "@@ -513,6 +513,7 @@ symbols! {\n         None,\n         non_exhaustive,\n         non_modrs_mods,\n+        nontrapping_fptoint: \"nontrapping-fptoint\",\n         noreturn,\n         no_niche,\n         no_sanitize,\n@@ -844,7 +845,6 @@ symbols! {\n         warn,\n         wasm_import_module,\n         wasm_target_feature,\n-        wasm_nontrapping_fptoint: \"nontrapping-fptoint\",\n         while_let,\n         windows,\n         windows_subsystem,"}, {"sha": "6c3e503693c3ceef3b999403776f48b36dc83834", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts-impl.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/838c497a4578bb4c939e9834240198e22815ad1b/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838c497a4578bb4c939e9834240198e22815ad1b/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-impl.rs?ref=838c497a4578bb4c939e9834240198e22815ad1b", "patch": "@@ -0,0 +1,507 @@\n+// ignore-test\n+\n+// Tests saturating float->int casts. See u128-as-f32.rs for the opposite direction.\n+//\n+// Some of these tests come from a similar file in miri,\n+// tests/run-pass/float.rs. Individual test cases are potentially duplicated\n+// with the previously existing tests, but since this runs so quickly anyway,\n+// we're not spending the time to figure out exactly which ones should be\n+// merged.\n+\n+extern crate test;\n+\n+use self::test::black_box;\n+use std::{f32, f64};\n+#[cfg(not(target_os = \"emscripten\"))]\n+use std::{i128, u128};\n+use std::{i16, i32, i64, i8, u16, u32, u64, u8};\n+\n+macro_rules! test {\n+    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n+        // black_box disables constant evaluation to test run-time conversions:\n+        assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n+                    \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+\n+        {\n+            const X: $src_ty = $val;\n+            const Y: $dest_ty = X as $dest_ty;\n+            assert_eq!(Y, $expected,\n+                        \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+        }\n+    );\n+\n+    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n+    )\n+}\n+\n+macro_rules! common_fptoi_tests {\n+    ($fty:ident -> $($ity:ident)+) => ({ $(\n+        test!($fty::NAN, $fty -> $ity, 0);\n+        test!($fty::INFINITY, $fty -> $ity, $ity::MAX);\n+        test!($fty::NEG_INFINITY, $fty -> $ity, $ity::MIN);\n+        // These two tests are not solely float->int tests, in particular the latter relies on\n+        // `u128::MAX as f32` not being UB. But that's okay, since this file tests int->float\n+        // as well, the test is just slightly misplaced.\n+        test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n+        test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n+        test!(0., $fty -> $ity, 0);\n+        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.9, $fty -> $ity, 0);\n+        test!(1., $fty -> $ity, 1);\n+        test!(42., $fty -> $ity, 42);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        common_fptoi_tests!(f32 -> $($ity)+);\n+        common_fptoi_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+macro_rules! fptoui_tests {\n+    ($fty: ident -> $($ity: ident)+) => ({ $(\n+        test!(-0., $fty -> $ity, 0);\n+        test!(-$fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.99999994, $fty -> $ity, 0);\n+        test!(-1., $fty -> $ity, 0);\n+        test!(-100., $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e50, $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e130, $fty -> $ity, 0);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        fptoui_tests!(f32 -> $($ity)+);\n+        fptoui_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+use std::fmt::Debug;\n+\n+// Helper function to avoid promotion so that this tests \"run-time\" casts, not CTFE.\n+#[track_caller]\n+#[inline(never)]\n+fn assert_eq<T: PartialEq + Debug>(x: T, y: T) {\n+    assert_eq!(x, y);\n+}\n+\n+trait FloatToInt<Int>: Copy {\n+    fn cast(self) -> Int;\n+    unsafe fn cast_unchecked(self) -> Int;\n+}\n+\n+impl FloatToInt<i8> for f32 {\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i32> for f32 {\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u32> for f32 {\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i64> for f32 {\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u64> for f32 {\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+\n+impl FloatToInt<i8> for f64 {\n+    fn cast(self) -> i8 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i8 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i32> for f64 {\n+    fn cast(self) -> i32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u32> for f64 {\n+    fn cast(self) -> u32 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u32 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<i64> for f64 {\n+    fn cast(self) -> i64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+impl FloatToInt<u64> for f64 {\n+    fn cast(self) -> u64 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u64 {\n+        self.to_int_unchecked()\n+    }\n+}\n+// FIXME emscripten does not support i128\n+#[cfg(not(target_os = \"emscripten\"))]\n+impl FloatToInt<i128> for f64 {\n+    fn cast(self) -> i128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> i128 {\n+        self.to_int_unchecked()\n+    }\n+}\n+// FIXME emscripten does not support i128\n+#[cfg(not(target_os = \"emscripten\"))]\n+impl FloatToInt<u128> for f64 {\n+    fn cast(self) -> u128 {\n+        self as _\n+    }\n+    unsafe fn cast_unchecked(self) -> u128 {\n+        self.to_int_unchecked()\n+    }\n+}\n+\n+/// Test this cast both via `as` and via `to_int_unchecked` (i.e., it must not saturate).\n+#[track_caller]\n+#[inline(never)]\n+fn test_both_cast<F, I>(x: F, y: I)\n+where\n+    F: FloatToInt<I>,\n+    I: PartialEq + Debug,\n+{\n+    assert_eq!(x.cast(), y);\n+    assert_eq!(unsafe { x.cast_unchecked() }, y);\n+}\n+\n+fn casts() {\n+    // f32 -> i8\n+    test_both_cast::<f32, i8>(127.99, 127);\n+    test_both_cast::<f32, i8>(-128.99, -128);\n+\n+    // f32 -> i32\n+    test_both_cast::<f32, i32>(0.0, 0);\n+    test_both_cast::<f32, i32>(-0.0, 0);\n+    test_both_cast::<f32, i32>(/*0x1p-149*/ f32::from_bits(0x00000001), 0);\n+    test_both_cast::<f32, i32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_both_cast::<f32, i32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_both_cast::<f32, i32>(/*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd), -1);\n+    test_both_cast::<f32, i32>(1.9, 1);\n+    test_both_cast::<f32, i32>(-1.9, -1);\n+    test_both_cast::<f32, i32>(5.0, 5);\n+    test_both_cast::<f32, i32>(-5.0, -5);\n+    test_both_cast::<f32, i32>(2147483520.0, 2147483520);\n+    test_both_cast::<f32, i32>(-2147483648.0, -2147483648);\n+    // unrepresentable casts\n+    assert_eq::<i32>(2147483648.0f32 as i32, i32::MAX);\n+    assert_eq::<i32>(-2147483904.0f32 as i32, i32::MIN);\n+    assert_eq::<i32>(f32::MAX as i32, i32::MAX);\n+    assert_eq::<i32>(f32::MIN as i32, i32::MIN);\n+    assert_eq::<i32>(f32::INFINITY as i32, i32::MAX);\n+    assert_eq::<i32>(f32::NEG_INFINITY as i32, i32::MIN);\n+    assert_eq::<i32>(f32::NAN as i32, 0);\n+    assert_eq::<i32>((-f32::NAN) as i32, 0);\n+\n+    // f32 -> u32\n+    test_both_cast::<f32, u32>(0.0, 0);\n+    test_both_cast::<f32, u32>(-0.0, 0);\n+    test_both_cast::<f32, u32>(-0.9999999, 0);\n+    test_both_cast::<f32, u32>(/*0x1p-149*/ f32::from_bits(0x1), 0);\n+    test_both_cast::<f32, u32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_both_cast::<f32, u32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_both_cast::<f32, u32>(1.9, 1);\n+    test_both_cast::<f32, u32>(5.0, 5);\n+    test_both_cast::<f32, u32>(2147483648.0, 0x8000_0000);\n+    test_both_cast::<f32, u32>(4294967040.0, 0u32.wrapping_sub(256));\n+    test_both_cast::<f32, u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666), 0);\n+    test_both_cast::<f32, u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff), 0);\n+    test_both_cast::<f32, u32>((u32::MAX - 128) as f32, u32::MAX - 255); // rounding loss\n+\n+    // unrepresentable casts:\n+\n+    // rounds up and then becomes unrepresentable\n+    assert_eq::<u32>((u32::MAX - 127) as f32 as u32, u32::MAX);\n+\n+    assert_eq::<u32>(4294967296.0f32 as u32, u32::MAX);\n+    assert_eq::<u32>(-5.0f32 as u32, 0);\n+    assert_eq::<u32>(f32::MAX as u32, u32::MAX);\n+    assert_eq::<u32>(f32::MIN as u32, 0);\n+    assert_eq::<u32>(f32::INFINITY as u32, u32::MAX);\n+    assert_eq::<u32>(f32::NEG_INFINITY as u32, 0);\n+    assert_eq::<u32>(f32::NAN as u32, 0);\n+    assert_eq::<u32>((-f32::NAN) as u32, 0);\n+\n+    // f32 -> i64\n+    test_both_cast::<f32, i64>(4294967296.0, 4294967296);\n+    test_both_cast::<f32, i64>(-4294967296.0, -4294967296);\n+    test_both_cast::<f32, i64>(9223371487098961920.0, 9223371487098961920);\n+    test_both_cast::<f32, i64>(-9223372036854775808.0, -9223372036854775808);\n+\n+    // f64 -> i8\n+    test_both_cast::<f64, i8>(127.99, 127);\n+    test_both_cast::<f64, i8>(-128.99, -128);\n+\n+    // f64 -> i32\n+    test_both_cast::<f64, i32>(0.0, 0);\n+    test_both_cast::<f64, i32>(-0.0, 0);\n+    test_both_cast::<f64, i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_both_cast::<f64, i32>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n+    test_both_cast::<f64, i32>(1.9, 1);\n+    test_both_cast::<f64, i32>(-1.9, -1);\n+    test_both_cast::<f64, i32>(1e8, 100_000_000);\n+    test_both_cast::<f64, i32>(2147483647.0, 2147483647);\n+    test_both_cast::<f64, i32>(-2147483648.0, -2147483648);\n+    // unrepresentable casts\n+    assert_eq::<i32>(2147483648.0f64 as i32, i32::MAX);\n+    assert_eq::<i32>(-2147483649.0f64 as i32, i32::MIN);\n+\n+    // f64 -> i64\n+    test_both_cast::<f64, i64>(0.0, 0);\n+    test_both_cast::<f64, i64>(-0.0, 0);\n+    test_both_cast::<f64, i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1), 0);\n+    test_both_cast::<f64, i64>(\n+        /*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001),\n+        0,\n+    );\n+    test_both_cast::<f64, i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_both_cast::<f64, i64>(\n+        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n+        -1,\n+    );\n+    test_both_cast::<f64, i64>(5.0, 5);\n+    test_both_cast::<f64, i64>(5.9, 5);\n+    test_both_cast::<f64, i64>(-5.0, -5);\n+    test_both_cast::<f64, i64>(-5.9, -5);\n+    test_both_cast::<f64, i64>(4294967296.0, 4294967296);\n+    test_both_cast::<f64, i64>(-4294967296.0, -4294967296);\n+    test_both_cast::<f64, i64>(9223372036854774784.0, 9223372036854774784);\n+    test_both_cast::<f64, i64>(-9223372036854775808.0, -9223372036854775808);\n+    // unrepresentable casts\n+    assert_eq::<i64>(9223372036854775808.0f64 as i64, i64::MAX);\n+    assert_eq::<i64>(-9223372036854777856.0f64 as i64, i64::MIN);\n+    assert_eq::<i64>(f64::MAX as i64, i64::MAX);\n+    assert_eq::<i64>(f64::MIN as i64, i64::MIN);\n+    assert_eq::<i64>(f64::INFINITY as i64, i64::MAX);\n+    assert_eq::<i64>(f64::NEG_INFINITY as i64, i64::MIN);\n+    assert_eq::<i64>(f64::NAN as i64, 0);\n+    assert_eq::<i64>((-f64::NAN) as i64, 0);\n+\n+    // f64 -> u64\n+    test_both_cast::<f64, u64>(0.0, 0);\n+    test_both_cast::<f64, u64>(-0.0, 0);\n+    test_both_cast::<f64, u64>(-0.99999999999, 0);\n+    test_both_cast::<f64, u64>(5.0, 5);\n+    test_both_cast::<f64, u64>(1e16, 10000000000000000);\n+    test_both_cast::<f64, u64>((u64::MAX - 1024) as f64, u64::MAX - 2047); // rounding loss\n+    test_both_cast::<f64, u64>(9223372036854775808.0, 9223372036854775808);\n+    // unrepresentable casts\n+    assert_eq::<u64>(-5.0f64 as u64, 0);\n+    // rounds up and then becomes unrepresentable\n+    assert_eq::<u64>((u64::MAX - 1023) as f64 as u64, u64::MAX);\n+    assert_eq::<u64>(18446744073709551616.0f64 as u64, u64::MAX);\n+    assert_eq::<u64>(f64::MAX as u64, u64::MAX);\n+    assert_eq::<u64>(f64::MIN as u64, 0);\n+    assert_eq::<u64>(f64::INFINITY as u64, u64::MAX);\n+    assert_eq::<u64>(f64::NEG_INFINITY as u64, 0);\n+    assert_eq::<u64>(f64::NAN as u64, 0);\n+    assert_eq::<u64>((-f64::NAN) as u64, 0);\n+\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // f64 -> i128\n+        assert_eq::<i128>(f64::MAX as i128, i128::MAX);\n+        assert_eq::<i128>(f64::MIN as i128, i128::MIN);\n+\n+        // f64 -> u128\n+        assert_eq::<u128>(f64::MAX as u128, u128::MAX);\n+        assert_eq::<u128>(f64::MIN as u128, 0);\n+    }\n+\n+    // int -> f32\n+    assert_eq::<f32>(127i8 as f32, 127.0);\n+    assert_eq::<f32>(2147483647i32 as f32, 2147483648.0);\n+    assert_eq::<f32>((-2147483648i32) as f32, -2147483648.0);\n+    assert_eq::<f32>(1234567890i32 as f32, /*0x1.26580cp+30*/ f32::from_bits(0x4e932c06));\n+    assert_eq::<f32>(16777217i32 as f32, 16777216.0);\n+    assert_eq::<f32>((-16777217i32) as f32, -16777216.0);\n+    assert_eq::<f32>(16777219i32 as f32, 16777220.0);\n+    assert_eq::<f32>((-16777219i32) as f32, -16777220.0);\n+    assert_eq::<f32>(\n+        0x7fffff4000000001i64 as f32,\n+        /*0x1.fffffep+62*/ f32::from_bits(0x5effffff),\n+    );\n+    assert_eq::<f32>(\n+        0x8000004000000001u64 as i64 as f32,\n+        /*-0x1.fffffep+62*/ f32::from_bits(0xdeffffff),\n+    );\n+    assert_eq::<f32>(\n+        0x0020000020000001i64 as f32,\n+        /*0x1.000002p+53*/ f32::from_bits(0x5a000001),\n+    );\n+    assert_eq::<f32>(\n+        0xffdfffffdfffffffu64 as i64 as f32,\n+        /*-0x1.000002p+53*/ f32::from_bits(0xda000001),\n+    );\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        assert_eq::<f32>(i128::MIN as f32, -170141183460469231731687303715884105728.0f32);\n+        assert_eq::<f32>(u128::MAX as f32, f32::INFINITY); // saturation\n+    }\n+\n+    // int -> f64\n+    assert_eq::<f64>(127i8 as f64, 127.0);\n+    assert_eq::<f64>(i16::MIN as f64, -32768.0f64);\n+    assert_eq::<f64>(2147483647i32 as f64, 2147483647.0);\n+    assert_eq::<f64>(-2147483648i32 as f64, -2147483648.0);\n+    assert_eq::<f64>(987654321i32 as f64, 987654321.0);\n+    assert_eq::<f64>(9223372036854775807i64 as f64, 9223372036854775807.0);\n+    assert_eq::<f64>(-9223372036854775808i64 as f64, -9223372036854775808.0);\n+    assert_eq::<f64>(4669201609102990i64 as f64, 4669201609102990.0); // Feigenbaum (?)\n+    assert_eq::<f64>(9007199254740993i64 as f64, 9007199254740992.0);\n+    assert_eq::<f64>(-9007199254740993i64 as f64, -9007199254740992.0);\n+    assert_eq::<f64>(9007199254740995i64 as f64, 9007199254740996.0);\n+    assert_eq::<f64>(-9007199254740995i64 as f64, -9007199254740996.0);\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // even that fits...\n+        assert_eq::<f64>(u128::MAX as f64, 340282366920938463463374607431768211455.0f64);\n+    }\n+\n+    // f32 -> f64\n+    assert_eq::<u64>((0.0f32 as f64).to_bits(), 0.0f64.to_bits());\n+    assert_eq::<u64>(((-0.0f32) as f64).to_bits(), (-0.0f64).to_bits());\n+    assert_eq::<f64>(5.0f32 as f64, 5.0f64);\n+    assert_eq::<f64>(\n+        /*0x1p-149*/ f32::from_bits(0x1) as f64,\n+        /*0x1p-149*/ f64::from_bits(0x36a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1p-149*/ f32::from_bits(0x80000001) as f64,\n+        /*-0x1p-149*/ f64::from_bits(0xb6a0000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.fffffep+127*/ f32::from_bits(0x7f7fffff) as f64,\n+        /*0x1.fffffep+127*/ f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*-0x1.fffffep+127*/ (-f32::from_bits(0x7f7fffff)) as f64,\n+        /*-0x1.fffffep+127*/ -f64::from_bits(0x47efffffe0000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1p-119*/ f32::from_bits(0x4000000) as f64,\n+        /*0x1p-119*/ f64::from_bits(0x3880000000000000),\n+    );\n+    assert_eq::<f64>(\n+        /*0x1.8f867ep+125*/ f32::from_bits(0x7e47c33f) as f64,\n+        6.6382536710104395e+37,\n+    );\n+    assert_eq::<f64>(f32::INFINITY as f64, f64::INFINITY);\n+    assert_eq::<f64>(f32::NEG_INFINITY as f64, f64::NEG_INFINITY);\n+\n+    // f64 -> f32\n+    assert_eq::<u32>((0.0f64 as f32).to_bits(), 0.0f32.to_bits());\n+    assert_eq::<u32>(((-0.0f64) as f32).to_bits(), (-0.0f32).to_bits());\n+    assert_eq::<f32>(5.0f64 as f32, 5.0f32);\n+    assert_eq::<f32>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as f32, 0.0);\n+    assert_eq::<f32>(/*-0x0.0000000000001p-1022*/ (-f64::from_bits(0x1)) as f32, -0.0);\n+    assert_eq::<f32>(\n+        /*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32,\n+        /*0x1p-149*/ f32::from_bits(0x800000),\n+    );\n+    assert_eq::<f32>(\n+        /*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32,\n+        /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728),\n+    );\n+    assert_eq::<f32>(f64::MAX as f32, f32::INFINITY);\n+    assert_eq::<f32>(f64::MIN as f32, f32::NEG_INFINITY);\n+    assert_eq::<f32>(f64::INFINITY as f32, f32::INFINITY);\n+    assert_eq::<f32>(f64::NEG_INFINITY as f32, f32::NEG_INFINITY);\n+}\n+\n+pub fn run() {\n+    casts(); // from miri's tests\n+\n+    common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n+    fptoui_tests!(f* -> u8 u16 u32 u64);\n+    // FIXME emscripten does not support i128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        common_fptoi_tests!(f* -> i128 u128);\n+        fptoui_tests!(f* -> u128);\n+    }\n+\n+    // The following tests cover edge cases for some integer types.\n+\n+    // # u8\n+    test!(254., f* -> u8, 254);\n+    test!(256., f* -> u8, 255);\n+\n+    // # i8\n+    test!(-127., f* -> i8, -127);\n+    test!(-129., f* -> i8, -128);\n+    test!(126., f* -> i8, 126);\n+    test!(128., f* -> i8, 127);\n+\n+    // # i32\n+    // -2147483648. is i32::MIN (exactly)\n+    test!(-2147483648., f* -> i32, i32::MIN);\n+    // 2147483648. is i32::MAX rounded up\n+    test!(2147483648., f32 -> i32, 2147483647);\n+    // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n+    // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n+    test!(2147483520., f32 -> i32, 2147483520);\n+    // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n+    test!(-2147483904., f* -> i32, i32::MIN);\n+    test!(-2147483520., f* -> i32, -2147483520);\n+\n+    // # u32\n+    // round(MAX) and nextUp(round(MAX))\n+    test!(4294967040., f* -> u32, 4294967040);\n+    test!(4294967296., f* -> u32, 4294967295);\n+\n+    // # u128\n+    #[cfg(not(target_os = \"emscripten\"))]\n+    {\n+        // float->int:\n+        test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n+        // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n+        const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n+        test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n+    }\n+}"}, {"sha": "cad05917391be97623a7c921866f21665dc2df5c", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts-wasm.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/838c497a4578bb4c939e9834240198e22815ad1b/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-wasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838c497a4578bb4c939e9834240198e22815ad1b/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-wasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts-wasm.rs?ref=838c497a4578bb4c939e9834240198e22815ad1b", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+// only-wasm32\n+// compile-flags: -Zmir-opt-level=0 -C target-feature=+nontrapping-fptoint\n+\n+#![feature(test, stmt_expr_attributes)]\n+#![deny(overflowing_literals)]\n+\n+#[path = \"saturating-float-casts-impl.rs\"]\n+mod implementation;\n+\n+pub fn main() {\n+    implementation::run();\n+}"}, {"sha": "cc248a9bea0879c325295f13a785511f3dd5909c", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts.rs", "status": "modified", "additions": 3, "deletions": 500, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/838c497a4578bb4c939e9834240198e22815ad1b/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838c497a4578bb4c939e9834240198e22815ad1b/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs?ref=838c497a4578bb4c939e9834240198e22815ad1b", "patch": "@@ -1,509 +1,12 @@\n // run-pass\n // compile-flags:-Zmir-opt-level=0\n-// Tests saturating float->int casts. See u128-as-f32.rs for the opposite direction.\n-//\n-// Some of these tests come from a similar file in miri,\n-// tests/run-pass/float.rs. Individual test cases are potentially duplicated\n-// with the previously existing tests, but since this runs so quickly anyway,\n-// we're not spending the time to figure out exactly which ones should be\n-// merged.\n \n #![feature(test, stmt_expr_attributes)]\n #![deny(overflowing_literals)]\n-extern crate test;\n \n-use std::{f32, f64};\n-#[cfg(not(target_os = \"emscripten\"))]\n-use std::{i128, u128};\n-use std::{i16, i32, i64, i8, u16, u32, u64, u8};\n-use test::black_box;\n-\n-macro_rules! test {\n-    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n-        // black_box disables constant evaluation to test run-time conversions:\n-        assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n-                    \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n-\n-        {\n-            const X: $src_ty = $val;\n-            const Y: $dest_ty = X as $dest_ty;\n-            assert_eq!(Y, $expected,\n-                        \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n-        }\n-    );\n-\n-    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n-        test!($fval, f32 -> $ity, $ival);\n-        test!($fval, f64 -> $ity, $ival);\n-    )\n-}\n-\n-macro_rules! common_fptoi_tests {\n-    ($fty:ident -> $($ity:ident)+) => ({ $(\n-        test!($fty::NAN, $fty -> $ity, 0);\n-        test!($fty::INFINITY, $fty -> $ity, $ity::MAX);\n-        test!($fty::NEG_INFINITY, $fty -> $ity, $ity::MIN);\n-        // These two tests are not solely float->int tests, in particular the latter relies on\n-        // `u128::MAX as f32` not being UB. But that's okay, since this file tests int->float\n-        // as well, the test is just slightly misplaced.\n-        test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n-        test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n-        test!(0., $fty -> $ity, 0);\n-        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n-        test!(-0.9, $fty -> $ity, 0);\n-        test!(1., $fty -> $ity, 1);\n-        test!(42., $fty -> $ity, 42);\n-    )+ });\n-\n-    (f* -> $($ity:ident)+) => ({\n-        common_fptoi_tests!(f32 -> $($ity)+);\n-        common_fptoi_tests!(f64 -> $($ity)+);\n-    })\n-}\n-\n-macro_rules! fptoui_tests {\n-    ($fty: ident -> $($ity: ident)+) => ({ $(\n-        test!(-0., $fty -> $ity, 0);\n-        test!(-$fty::MIN_POSITIVE, $fty -> $ity, 0);\n-        test!(-0.99999994, $fty -> $ity, 0);\n-        test!(-1., $fty -> $ity, 0);\n-        test!(-100., $fty -> $ity, 0);\n-        test!(#[allow(overflowing_literals)] -1e50, $fty -> $ity, 0);\n-        test!(#[allow(overflowing_literals)] -1e130, $fty -> $ity, 0);\n-    )+ });\n-\n-    (f* -> $($ity:ident)+) => ({\n-        fptoui_tests!(f32 -> $($ity)+);\n-        fptoui_tests!(f64 -> $($ity)+);\n-    })\n-}\n-\n-use std::fmt::Debug;\n-\n-// Helper function to avoid promotion so that this tests \"run-time\" casts, not CTFE.\n-#[track_caller]\n-#[inline(never)]\n-fn assert_eq<T: PartialEq + Debug>(x: T, y: T) {\n-    assert_eq!(x, y);\n-}\n-\n-trait FloatToInt<Int>: Copy {\n-    fn cast(self) -> Int;\n-    unsafe fn cast_unchecked(self) -> Int;\n-}\n-\n-impl FloatToInt<i8> for f32 {\n-    fn cast(self) -> i8 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i8 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<i32> for f32 {\n-    fn cast(self) -> i32 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i32 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<u32> for f32 {\n-    fn cast(self) -> u32 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u32 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<i64> for f32 {\n-    fn cast(self) -> i64 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i64 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<u64> for f32 {\n-    fn cast(self) -> u64 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u64 {\n-        self.to_int_unchecked()\n-    }\n-}\n-\n-impl FloatToInt<i8> for f64 {\n-    fn cast(self) -> i8 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i8 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<i32> for f64 {\n-    fn cast(self) -> i32 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i32 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<u32> for f64 {\n-    fn cast(self) -> u32 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u32 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<i64> for f64 {\n-    fn cast(self) -> i64 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i64 {\n-        self.to_int_unchecked()\n-    }\n-}\n-impl FloatToInt<u64> for f64 {\n-    fn cast(self) -> u64 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u64 {\n-        self.to_int_unchecked()\n-    }\n-}\n-// FIXME emscripten does not support i128\n-#[cfg(not(target_os = \"emscripten\"))]\n-impl FloatToInt<i128> for f64 {\n-    fn cast(self) -> i128 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> i128 {\n-        self.to_int_unchecked()\n-    }\n-}\n-// FIXME emscripten does not support i128\n-#[cfg(not(target_os = \"emscripten\"))]\n-impl FloatToInt<u128> for f64 {\n-    fn cast(self) -> u128 {\n-        self as _\n-    }\n-    unsafe fn cast_unchecked(self) -> u128 {\n-        self.to_int_unchecked()\n-    }\n-}\n-\n-/// Test this cast both via `as` and via `to_int_unchecked` (i.e., it must not saturate).\n-#[track_caller]\n-#[inline(never)]\n-fn test_both_cast<F, I>(x: F, y: I)\n-where\n-    F: FloatToInt<I>,\n-    I: PartialEq + Debug,\n-{\n-    assert_eq!(x.cast(), y);\n-    assert_eq!(unsafe { x.cast_unchecked() }, y);\n-}\n-\n-fn casts() {\n-    // f32 -> i8\n-    test_both_cast::<f32, i8>(127.99, 127);\n-    test_both_cast::<f32, i8>(-128.99, -128);\n-\n-    // f32 -> i32\n-    test_both_cast::<f32, i32>(0.0, 0);\n-    test_both_cast::<f32, i32>(-0.0, 0);\n-    test_both_cast::<f32, i32>(/*0x1p-149*/ f32::from_bits(0x00000001), 0);\n-    test_both_cast::<f32, i32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n-    test_both_cast::<f32, i32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n-    test_both_cast::<f32, i32>(/*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd), -1);\n-    test_both_cast::<f32, i32>(1.9, 1);\n-    test_both_cast::<f32, i32>(-1.9, -1);\n-    test_both_cast::<f32, i32>(5.0, 5);\n-    test_both_cast::<f32, i32>(-5.0, -5);\n-    test_both_cast::<f32, i32>(2147483520.0, 2147483520);\n-    test_both_cast::<f32, i32>(-2147483648.0, -2147483648);\n-    // unrepresentable casts\n-    assert_eq::<i32>(2147483648.0f32 as i32, i32::MAX);\n-    assert_eq::<i32>(-2147483904.0f32 as i32, i32::MIN);\n-    assert_eq::<i32>(f32::MAX as i32, i32::MAX);\n-    assert_eq::<i32>(f32::MIN as i32, i32::MIN);\n-    assert_eq::<i32>(f32::INFINITY as i32, i32::MAX);\n-    assert_eq::<i32>(f32::NEG_INFINITY as i32, i32::MIN);\n-    assert_eq::<i32>(f32::NAN as i32, 0);\n-    assert_eq::<i32>((-f32::NAN) as i32, 0);\n-\n-    // f32 -> u32\n-    test_both_cast::<f32, u32>(0.0, 0);\n-    test_both_cast::<f32, u32>(-0.0, 0);\n-    test_both_cast::<f32, u32>(-0.9999999, 0);\n-    test_both_cast::<f32, u32>(/*0x1p-149*/ f32::from_bits(0x1), 0);\n-    test_both_cast::<f32, u32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n-    test_both_cast::<f32, u32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n-    test_both_cast::<f32, u32>(1.9, 1);\n-    test_both_cast::<f32, u32>(5.0, 5);\n-    test_both_cast::<f32, u32>(2147483648.0, 0x8000_0000);\n-    test_both_cast::<f32, u32>(4294967040.0, 0u32.wrapping_sub(256));\n-    test_both_cast::<f32, u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666), 0);\n-    test_both_cast::<f32, u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff), 0);\n-    test_both_cast::<f32, u32>((u32::MAX - 128) as f32, u32::MAX - 255); // rounding loss\n-\n-    // unrepresentable casts:\n-\n-    // rounds up and then becomes unrepresentable\n-    assert_eq::<u32>((u32::MAX - 127) as f32 as u32, u32::MAX);\n-\n-    assert_eq::<u32>(4294967296.0f32 as u32, u32::MAX);\n-    assert_eq::<u32>(-5.0f32 as u32, 0);\n-    assert_eq::<u32>(f32::MAX as u32, u32::MAX);\n-    assert_eq::<u32>(f32::MIN as u32, 0);\n-    assert_eq::<u32>(f32::INFINITY as u32, u32::MAX);\n-    assert_eq::<u32>(f32::NEG_INFINITY as u32, 0);\n-    assert_eq::<u32>(f32::NAN as u32, 0);\n-    assert_eq::<u32>((-f32::NAN) as u32, 0);\n-\n-    // f32 -> i64\n-    test_both_cast::<f32, i64>(4294967296.0, 4294967296);\n-    test_both_cast::<f32, i64>(-4294967296.0, -4294967296);\n-    test_both_cast::<f32, i64>(9223371487098961920.0, 9223371487098961920);\n-    test_both_cast::<f32, i64>(-9223372036854775808.0, -9223372036854775808);\n-\n-    // f64 -> i8\n-    test_both_cast::<f64, i8>(127.99, 127);\n-    test_both_cast::<f64, i8>(-128.99, -128);\n-\n-    // f64 -> i32\n-    test_both_cast::<f64, i32>(0.0, 0);\n-    test_both_cast::<f64, i32>(-0.0, 0);\n-    test_both_cast::<f64, i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n-    test_both_cast::<f64, i32>(\n-        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n-        -1,\n-    );\n-    test_both_cast::<f64, i32>(1.9, 1);\n-    test_both_cast::<f64, i32>(-1.9, -1);\n-    test_both_cast::<f64, i32>(1e8, 100_000_000);\n-    test_both_cast::<f64, i32>(2147483647.0, 2147483647);\n-    test_both_cast::<f64, i32>(-2147483648.0, -2147483648);\n-    // unrepresentable casts\n-    assert_eq::<i32>(2147483648.0f64 as i32, i32::MAX);\n-    assert_eq::<i32>(-2147483649.0f64 as i32, i32::MIN);\n-\n-    // f64 -> i64\n-    test_both_cast::<f64, i64>(0.0, 0);\n-    test_both_cast::<f64, i64>(-0.0, 0);\n-    test_both_cast::<f64, i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1), 0);\n-    test_both_cast::<f64, i64>(\n-        /*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001),\n-        0,\n-    );\n-    test_both_cast::<f64, i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n-    test_both_cast::<f64, i64>(\n-        /*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a),\n-        -1,\n-    );\n-    test_both_cast::<f64, i64>(5.0, 5);\n-    test_both_cast::<f64, i64>(5.9, 5);\n-    test_both_cast::<f64, i64>(-5.0, -5);\n-    test_both_cast::<f64, i64>(-5.9, -5);\n-    test_both_cast::<f64, i64>(4294967296.0, 4294967296);\n-    test_both_cast::<f64, i64>(-4294967296.0, -4294967296);\n-    test_both_cast::<f64, i64>(9223372036854774784.0, 9223372036854774784);\n-    test_both_cast::<f64, i64>(-9223372036854775808.0, -9223372036854775808);\n-    // unrepresentable casts\n-    assert_eq::<i64>(9223372036854775808.0f64 as i64, i64::MAX);\n-    assert_eq::<i64>(-9223372036854777856.0f64 as i64, i64::MIN);\n-    assert_eq::<i64>(f64::MAX as i64, i64::MAX);\n-    assert_eq::<i64>(f64::MIN as i64, i64::MIN);\n-    assert_eq::<i64>(f64::INFINITY as i64, i64::MAX);\n-    assert_eq::<i64>(f64::NEG_INFINITY as i64, i64::MIN);\n-    assert_eq::<i64>(f64::NAN as i64, 0);\n-    assert_eq::<i64>((-f64::NAN) as i64, 0);\n-\n-    // f64 -> u64\n-    test_both_cast::<f64, u64>(0.0, 0);\n-    test_both_cast::<f64, u64>(-0.0, 0);\n-    test_both_cast::<f64, u64>(-0.99999999999, 0);\n-    test_both_cast::<f64, u64>(5.0, 5);\n-    test_both_cast::<f64, u64>(1e16, 10000000000000000);\n-    test_both_cast::<f64, u64>((u64::MAX - 1024) as f64, u64::MAX - 2047); // rounding loss\n-    test_both_cast::<f64, u64>(9223372036854775808.0, 9223372036854775808);\n-    // unrepresentable casts\n-    assert_eq::<u64>(-5.0f64 as u64, 0);\n-    // rounds up and then becomes unrepresentable\n-    assert_eq::<u64>((u64::MAX - 1023) as f64 as u64, u64::MAX);\n-    assert_eq::<u64>(18446744073709551616.0f64 as u64, u64::MAX);\n-    assert_eq::<u64>(f64::MAX as u64, u64::MAX);\n-    assert_eq::<u64>(f64::MIN as u64, 0);\n-    assert_eq::<u64>(f64::INFINITY as u64, u64::MAX);\n-    assert_eq::<u64>(f64::NEG_INFINITY as u64, 0);\n-    assert_eq::<u64>(f64::NAN as u64, 0);\n-    assert_eq::<u64>((-f64::NAN) as u64, 0);\n-\n-    // FIXME emscripten does not support i128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        // f64 -> i128\n-        assert_eq::<i128>(f64::MAX as i128, i128::MAX);\n-        assert_eq::<i128>(f64::MIN as i128, i128::MIN);\n-\n-        // f64 -> u128\n-        assert_eq::<u128>(f64::MAX as u128, u128::MAX);\n-        assert_eq::<u128>(f64::MIN as u128, 0);\n-    }\n-\n-    // int -> f32\n-    assert_eq::<f32>(127i8 as f32, 127.0);\n-    assert_eq::<f32>(2147483647i32 as f32, 2147483648.0);\n-    assert_eq::<f32>((-2147483648i32) as f32, -2147483648.0);\n-    assert_eq::<f32>(1234567890i32 as f32, /*0x1.26580cp+30*/ f32::from_bits(0x4e932c06));\n-    assert_eq::<f32>(16777217i32 as f32, 16777216.0);\n-    assert_eq::<f32>((-16777217i32) as f32, -16777216.0);\n-    assert_eq::<f32>(16777219i32 as f32, 16777220.0);\n-    assert_eq::<f32>((-16777219i32) as f32, -16777220.0);\n-    assert_eq::<f32>(\n-        0x7fffff4000000001i64 as f32,\n-        /*0x1.fffffep+62*/ f32::from_bits(0x5effffff),\n-    );\n-    assert_eq::<f32>(\n-        0x8000004000000001u64 as i64 as f32,\n-        /*-0x1.fffffep+62*/ f32::from_bits(0xdeffffff),\n-    );\n-    assert_eq::<f32>(\n-        0x0020000020000001i64 as f32,\n-        /*0x1.000002p+53*/ f32::from_bits(0x5a000001),\n-    );\n-    assert_eq::<f32>(\n-        0xffdfffffdfffffffu64 as i64 as f32,\n-        /*-0x1.000002p+53*/ f32::from_bits(0xda000001),\n-    );\n-    // FIXME emscripten does not support i128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        assert_eq::<f32>(i128::MIN as f32, -170141183460469231731687303715884105728.0f32);\n-        assert_eq::<f32>(u128::MAX as f32, f32::INFINITY); // saturation\n-    }\n-\n-    // int -> f64\n-    assert_eq::<f64>(127i8 as f64, 127.0);\n-    assert_eq::<f64>(i16::MIN as f64, -32768.0f64);\n-    assert_eq::<f64>(2147483647i32 as f64, 2147483647.0);\n-    assert_eq::<f64>(-2147483648i32 as f64, -2147483648.0);\n-    assert_eq::<f64>(987654321i32 as f64, 987654321.0);\n-    assert_eq::<f64>(9223372036854775807i64 as f64, 9223372036854775807.0);\n-    assert_eq::<f64>(-9223372036854775808i64 as f64, -9223372036854775808.0);\n-    assert_eq::<f64>(4669201609102990i64 as f64, 4669201609102990.0); // Feigenbaum (?)\n-    assert_eq::<f64>(9007199254740993i64 as f64, 9007199254740992.0);\n-    assert_eq::<f64>(-9007199254740993i64 as f64, -9007199254740992.0);\n-    assert_eq::<f64>(9007199254740995i64 as f64, 9007199254740996.0);\n-    assert_eq::<f64>(-9007199254740995i64 as f64, -9007199254740996.0);\n-    // FIXME emscripten does not support i128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        // even that fits...\n-        assert_eq::<f64>(u128::MAX as f64, 340282366920938463463374607431768211455.0f64);\n-    }\n-\n-    // f32 -> f64\n-    assert_eq::<u64>((0.0f32 as f64).to_bits(), 0.0f64.to_bits());\n-    assert_eq::<u64>(((-0.0f32) as f64).to_bits(), (-0.0f64).to_bits());\n-    assert_eq::<f64>(5.0f32 as f64, 5.0f64);\n-    assert_eq::<f64>(\n-        /*0x1p-149*/ f32::from_bits(0x1) as f64,\n-        /*0x1p-149*/ f64::from_bits(0x36a0000000000000),\n-    );\n-    assert_eq::<f64>(\n-        /*-0x1p-149*/ f32::from_bits(0x80000001) as f64,\n-        /*-0x1p-149*/ f64::from_bits(0xb6a0000000000000),\n-    );\n-    assert_eq::<f64>(\n-        /*0x1.fffffep+127*/ f32::from_bits(0x7f7fffff) as f64,\n-        /*0x1.fffffep+127*/ f64::from_bits(0x47efffffe0000000),\n-    );\n-    assert_eq::<f64>(\n-        /*-0x1.fffffep+127*/ (-f32::from_bits(0x7f7fffff)) as f64,\n-        /*-0x1.fffffep+127*/ -f64::from_bits(0x47efffffe0000000),\n-    );\n-    assert_eq::<f64>(\n-        /*0x1p-119*/ f32::from_bits(0x4000000) as f64,\n-        /*0x1p-119*/ f64::from_bits(0x3880000000000000),\n-    );\n-    assert_eq::<f64>(\n-        /*0x1.8f867ep+125*/ f32::from_bits(0x7e47c33f) as f64,\n-        6.6382536710104395e+37,\n-    );\n-    assert_eq::<f64>(f32::INFINITY as f64, f64::INFINITY);\n-    assert_eq::<f64>(f32::NEG_INFINITY as f64, f64::NEG_INFINITY);\n-\n-    // f64 -> f32\n-    assert_eq::<u32>((0.0f64 as f32).to_bits(), 0.0f32.to_bits());\n-    assert_eq::<u32>(((-0.0f64) as f32).to_bits(), (-0.0f32).to_bits());\n-    assert_eq::<f32>(5.0f64 as f32, 5.0f32);\n-    assert_eq::<f32>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as f32, 0.0);\n-    assert_eq::<f32>(/*-0x0.0000000000001p-1022*/ (-f64::from_bits(0x1)) as f32, -0.0);\n-    assert_eq::<f32>(\n-        /*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32,\n-        /*0x1p-149*/ f32::from_bits(0x800000),\n-    );\n-    assert_eq::<f32>(\n-        /*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32,\n-        /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728),\n-    );\n-    assert_eq::<f32>(f64::MAX as f32, f32::INFINITY);\n-    assert_eq::<f32>(f64::MIN as f32, f32::NEG_INFINITY);\n-    assert_eq::<f32>(f64::INFINITY as f32, f32::INFINITY);\n-    assert_eq::<f32>(f64::NEG_INFINITY as f32, f32::NEG_INFINITY);\n-}\n+#[path = \"saturating-float-casts-impl.rs\"]\n+mod implementation;\n \n pub fn main() {\n-    casts(); // from miri's tests\n-\n-    common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n-    fptoui_tests!(f* -> u8 u16 u32 u64);\n-    // FIXME emscripten does not support i128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        common_fptoi_tests!(f* -> i128 u128);\n-        fptoui_tests!(f* -> u128);\n-    }\n-\n-    // The following tests cover edge cases for some integer types.\n-\n-    // # u8\n-    test!(254., f* -> u8, 254);\n-    test!(256., f* -> u8, 255);\n-\n-    // # i8\n-    test!(-127., f* -> i8, -127);\n-    test!(-129., f* -> i8, -128);\n-    test!(126., f* -> i8, 126);\n-    test!(128., f* -> i8, 127);\n-\n-    // # i32\n-    // -2147483648. is i32::MIN (exactly)\n-    test!(-2147483648., f* -> i32, i32::MIN);\n-    // 2147483648. is i32::MAX rounded up\n-    test!(2147483648., f32 -> i32, 2147483647);\n-    // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n-    // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n-    test!(2147483520., f32 -> i32, 2147483520);\n-    // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n-    test!(-2147483904., f* -> i32, i32::MIN);\n-    test!(-2147483520., f* -> i32, -2147483520);\n-\n-    // # u32\n-    // round(MAX) and nextUp(round(MAX))\n-    test!(4294967040., f* -> u32, 4294967040);\n-    test!(4294967296., f* -> u32, 4294967295);\n-\n-    // # u128\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    {\n-        // float->int:\n-        test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n-        // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n-        const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n-        test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n-    }\n+    implementation::run();\n }"}]}