{"sha": "4e89a7c29325964182e0fb9f92539cf2d9f18e82", "node_id": "C_kwDOAAsO6NoAKDRlODlhN2MyOTMyNTk2NDE4MmUwZmI5ZjkyNTM5Y2YyZDlmMThlODI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-23T14:36:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-23T14:36:57Z"}, "message": "now we can make scalar_to_ptr a method on Scalar", "tree": {"sha": "202bc92b97923627f77ea39fbcddcb895620f957", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/202bc92b97923627f77ea39fbcddcb895620f957"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e89a7c29325964182e0fb9f92539cf2d9f18e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e89a7c29325964182e0fb9f92539cf2d9f18e82", "html_url": "https://github.com/rust-lang/rust/commit/4e89a7c29325964182e0fb9f92539cf2d9f18e82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e89a7c29325964182e0fb9f92539cf2d9f18e82/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "665a7e8f5663d143b1c318b39a847daff1791ca0", "url": "https://api.github.com/repos/rust-lang/rust/commits/665a7e8f5663d143b1c318b39a847daff1791ca0", "html_url": "https://github.com/rust-lang/rust/commit/665a7e8f5663d143b1c318b39a847daff1791ca0"}], "stats": {"total": 86, "additions": 41, "deletions": 45}, "files": [{"sha": "ba8222dc15218d245af6ab41ceab5d2524ad7e3b", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -173,18 +173,17 @@ pub(super) fn op_to_const<'tcx>(\n             Immediate::ScalarPair(a, b) => {\n                 debug!(\"ScalarPair(a: {:?}, b: {:?})\", a, b);\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-                let (data, start) =\n-                    match ecx.scalar_to_ptr(a.check_init().unwrap()).unwrap().into_parts() {\n-                        (Some(alloc_id), offset) => {\n-                            (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n-                        }\n-                        (None, _offset) => (\n-                            ecx.tcx.intern_const_alloc(\n-                                Allocation::from_bytes_byte_aligned_immutable(b\"\" as &[u8]),\n-                            ),\n-                            0,\n-                        ),\n-                    };\n+                let (data, start) = match a.to_pointer(ecx).unwrap().into_parts() {\n+                    (Some(alloc_id), offset) => {\n+                        (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n+                    }\n+                    (None, _offset) => (\n+                        ecx.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n+                            b\"\" as &[u8],\n+                        )),\n+                        0,\n+                    ),\n+                };\n                 let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();"}, {"sha": "c97c31eb9dadfb98508feee369e9697a24dbdce8", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -180,7 +180,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert!(cast_ty.is_integral());\n \n         let scalar = src.to_scalar()?;\n-        let ptr = self.scalar_to_ptr(scalar)?;\n+        let ptr = scalar.to_pointer(self)?;\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => M::expose_ptr(self, ptr)?,\n             Err(_) => {} // Do nothing, exposing an invalid pointer (`None` provenance) is a NOP.\n@@ -299,7 +299,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 let (old_data, old_vptr) = self.read_immediate(src)?.to_scalar_pair()?;\n-                let old_vptr = self.scalar_to_ptr(old_vptr)?;\n+                let old_vptr = old_vptr.to_pointer(self)?;\n                 let (ty, old_trait) = self.get_ptr_vtable(old_vptr)?;\n                 if old_trait != data_a.principal() {\n                     throw_ub_format!(\"upcast on a pointer whose vtable does not match its type\");"}, {"sha": "150d6589b0807e811f38df685f3e4a51993dd41f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -629,7 +629,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = self.scalar_to_ptr(metadata.unwrap_meta())?;\n+                let vtable = metadata.unwrap_meta().to_pointer(self)?;\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.get_vtable_size_and_align(vtable)?))\n             }"}, {"sha": "376b8872c90ac1be2610e792cadbd844e3b6d60d", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -245,7 +245,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             if let ty::Dynamic(..) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n-                let ptr = self.ecx.scalar_to_ptr(mplace.meta.unwrap_meta())?;\n+                let ptr = mplace.meta.unwrap_meta().to_pointer(&tcx)?;\n                 if let Some(alloc_id) = ptr.provenance {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable."}, {"sha": "ed2c4edf9dd72920e0d634c2ae406cc8f65986e8", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -9,7 +9,6 @@\n use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n-use std::convert::TryFrom;\n use std::fmt;\n use std::ptr;\n \n@@ -1172,34 +1171,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n /// Machine pointer introspection.\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn scalar_to_ptr(\n-        &self,\n-        scalar: Scalar<M::Provenance>,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n-        // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n-        // call to force getting out a pointer.\n-        Ok(\n-            match scalar\n-                .to_bits_or_ptr_internal(self.pointer_size())\n-                .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n-            {\n-                Err(ptr) => ptr.into(),\n-                Ok(bits) => {\n-                    let addr = u64::try_from(bits).unwrap();\n-                    Pointer::from_addr(addr)\n-                }\n-            },\n-        )\n-    }\n-\n     /// Test if this value might be null.\n     /// If the machine does not support ptr-to-int casts, this is conservative.\n     pub fn scalar_may_be_null(&self, scalar: Scalar<M::Provenance>) -> InterpResult<'tcx, bool> {\n         Ok(match scalar.try_to_int() {\n             Ok(int) => int.is_null(),\n             Err(_) => {\n                 // Can only happen during CTFE.\n-                let ptr = self.scalar_to_ptr(scalar)?;\n+                let ptr = scalar.to_pointer(self)?;\n                 match self.ptr_try_get_alloc_id(ptr) {\n                     Ok((alloc_id, offset, _)) => {\n                         let (size, _align, _kind) = self.get_alloc_info(alloc_id);"}, {"sha": "de284bd3bae3775a9000e3dbae1635d226403bdc", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -14,7 +14,7 @@ use rustc_target::abi::{VariantIdx, Variants};\n use super::{\n     alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n     InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Place, PlaceTy, Pointer,\n-    PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n+    Provenance, Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -455,7 +455,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n-        self.scalar_to_ptr(self.read_scalar(op)?.check_init()?)\n+        self.read_scalar(op)?.to_pointer(self)\n     }\n \n     /// Turn the wide MPlace into a string (must already be dereferenced!)"}, {"sha": "473da71a0ab9cb570ee88d11d9eb89db16b347bf", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -331,7 +331,7 @@ where\n             Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         };\n \n-        let mplace = MemPlace { ptr: self.scalar_to_ptr(ptr.check_init()?)?, meta };\n+        let mplace = MemPlace { ptr: ptr.to_pointer(self)?, meta };\n         // When deref'ing a pointer, the *static* alignment given by the type is what matters.\n         let align = layout.align.abi;\n         Ok(MPlaceTy { mplace, layout, align })\n@@ -889,7 +889,7 @@ where\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n-        let vtable = self.scalar_to_ptr(mplace.vtable())?; // also sanity checks the type\n+        let vtable = mplace.vtable().to_pointer(self)?; // also sanity checks the type\n         let (ty, _) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n "}, {"sha": "42de0dbdca92868b45a2eb18bb3a15077a675290", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -561,7 +561,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n \n                 // Get the required information from the vtable.\n-                let vptr = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n+                let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n                 let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n                 if dyn_trait != data.principal() {\n                     throw_ub_format!("}, {"sha": "d20f16755c391243cc88facc4960a08f7769c6b5", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -312,7 +312,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind() {\n             ty::Dynamic(..) => {\n-                let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta())?;\n+                let vtable = meta.unwrap_meta().to_pointer(self.ecx)?;\n                 // Make sure it is a genuine vtable pointer.\n                 let (_ty, _trait) = try_validation!(\n                     self.ecx.get_ptr_vtable(vtable),\n@@ -566,7 +566,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n-                    let ptr = self.ecx.scalar_to_ptr(value)?;\n+                    let ptr = value.to_pointer(self.ecx)?;\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,"}, {"sha": "834c114ee1c58d9067fc6ef4f161447200f5725a", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e89a7c29325964182e0fb9f92539cf2d9f18e82/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=4e89a7c29325964182e0fb9f92539cf2d9f18e82", "patch": "@@ -331,6 +331,19 @@ impl<Prov> Scalar<Prov> {\n }\n \n impl<'tcx, Prov: Provenance> Scalar<Prov> {\n+    pub fn to_pointer(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, Pointer<Option<Prov>>> {\n+        match self\n+            .to_bits_or_ptr_internal(cx.pointer_size())\n+            .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n+        {\n+            Err(ptr) => Ok(ptr.into()),\n+            Ok(bits) => {\n+                let addr = u64::try_from(bits).unwrap();\n+                Ok(Pointer::from_addr(addr))\n+            }\n+        }\n+    }\n+\n     /// Fundamental scalar-to-int (cast) operation. Many convenience wrappers exist below, that you\n     /// likely want to use instead.\n     ///\n@@ -546,6 +559,11 @@ impl<Prov> ScalarMaybeUninit<Prov> {\n }\n \n impl<'tcx, Prov: Provenance> ScalarMaybeUninit<Prov> {\n+    #[inline(always)]\n+    pub fn to_pointer(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, Pointer<Option<Prov>>> {\n+        self.check_init()?.to_pointer(cx)\n+    }\n+\n     #[inline(always)]\n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n         self.check_init()?.to_bool()"}]}