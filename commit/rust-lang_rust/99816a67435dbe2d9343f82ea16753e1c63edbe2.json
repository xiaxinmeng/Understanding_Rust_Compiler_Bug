{"sha": "99816a67435dbe2d9343f82ea16753e1c63edbe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ODE2YTY3NDM1ZGJlMmQ5MzQzZjgyZWExNjc1M2UxYzYzZWRiZTI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-18T01:25:32Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:30Z"}, "message": "Further simplify intrinsic matching", "tree": {"sha": "759ec7f7f370a7970e1bd2e2db40ebf65dec033c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/759ec7f7f370a7970e1bd2e2db40ebf65dec033c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99816a67435dbe2d9343f82ea16753e1c63edbe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99816a67435dbe2d9343f82ea16753e1c63edbe2", "html_url": "https://github.com/rust-lang/rust/commit/99816a67435dbe2d9343f82ea16753e1c63edbe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99816a67435dbe2d9343f82ea16753e1c63edbe2/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "611e90b11823e8328a9478c6a1c521696d4c5b75", "url": "https://api.github.com/repos/rust-lang/rust/commits/611e90b11823e8328a9478c6a1c521696d4c5b75", "html_url": "https://github.com/rust-lang/rust/commit/611e90b11823e8328a9478c6a1c521696d4c5b75"}], "stats": {"total": 118, "additions": 33, "deletions": 85}, "files": [{"sha": "17a04c14cba9c701120d2282c1987455fdb36c9f", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 33, "deletions": 85, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/99816a67435dbe2d9343f82ea16753e1c63edbe2/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99816a67435dbe2d9343f82ea16753e1c63edbe2/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=99816a67435dbe2d9343f82ea16753e1c63edbe2", "patch": "@@ -211,44 +211,20 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         }\n \n         \"copy_nonoverlapping\" => {\n-            copy_intrinsic(bcx,\n-                           false,\n-                           false,\n-                           substs.type_at(0),\n-                           llargs[1],\n-                           llargs[0],\n-                           llargs[2])\n+            copy_intrinsic(bcx, false, false, substs.type_at(0), llargs[1], llargs[0], llargs[2])\n         }\n         \"copy\" => {\n-            copy_intrinsic(bcx,\n-                           true,\n-                           false,\n-                           substs.type_at(0),\n-                           llargs[1],\n-                           llargs[0],\n-                           llargs[2])\n+            copy_intrinsic(bcx, true, false, substs.type_at(0), llargs[1], llargs[0], llargs[2])\n         }\n         \"write_bytes\" => {\n             memset_intrinsic(bcx, false, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n         }\n \n         \"volatile_copy_nonoverlapping_memory\" => {\n-            copy_intrinsic(bcx,\n-                           false,\n-                           true,\n-                           substs.type_at(0),\n-                           llargs[0],\n-                           llargs[1],\n-                           llargs[2])\n+            copy_intrinsic(bcx, false, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n         }\n         \"volatile_copy_memory\" => {\n-            copy_intrinsic(bcx,\n-                           true,\n-                           true,\n-                           substs.type_at(0),\n-                           llargs[0],\n-                           llargs[1],\n-                           llargs[2])\n+            copy_intrinsic(bcx, true, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n         }\n         \"volatile_set_memory\" => {\n             memset_intrinsic(bcx, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n@@ -293,10 +269,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             match int_type_width_signed(sty, ccx) {\n                 Some((width, signed)) =>\n                     match name {\n-                        \"ctlz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.ctlz.i{}\", width),\n-                                                        llargs[0]),\n-                        \"cttz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.cttz.i{}\", width),\n-                                                        llargs[0]),\n+                        \"ctlz\" | \"cttz\" => {\n+                            let y = C_bool(bcx.ccx(), false);\n+                            let llfn = ccx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n+                            bcx.call(llfn, &[llargs[0], y], None)\n+                        }\n                         \"ctpop\" => bcx.call(ccx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n                                         &llargs, None),\n                         \"bswap\" => {\n@@ -311,7 +288,16 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                             let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n                                                     if signed { 's' } else { 'u' },\n                                                     &name[..3], width);\n-                            with_overflow_intrinsic(bcx, &intrinsic, llargs[0], llargs[1], llresult)\n+                            let llfn = bcx.ccx().get_intrinsic(&intrinsic);\n+\n+                            // Convert `i1` to a `bool`, and write it to the out parameter\n+                            let val = bcx.call(llfn, &[llargs[0], llargs[1]], None);\n+                            let result = bcx.extract_value(val, 0);\n+                            let overflow = bcx.zext(bcx.extract_value(val, 1), Type::bool(ccx));\n+                            bcx.store(result, bcx.struct_gep(llresult, 0));\n+                            bcx.store(overflow, bcx.struct_gep(llresult, 1));\n+\n+                            C_nil(bcx.ccx())\n                         },\n                         \"overflowing_add\" => bcx.add(llargs[0], llargs[1]),\n                         \"overflowing_sub\" => bcx.sub(llargs[0], llargs[1]),\n@@ -412,6 +398,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                 _ => ccx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n             };\n \n+            let invalid_monomorphization = |sty| {\n+                span_invalid_monomorphization_error(tcx.sess, span,\n+                    &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                              expected basic integer type, found `{}`\", name, sty));\n+            };\n+\n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n                     let sty = &substs.type_at(0).sty;\n@@ -424,10 +416,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                         bcx.store(result, bcx.struct_gep(llresult, 0));\n                         bcx.store(success, bcx.struct_gep(llresult, 1));\n                     } else {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess, span,\n-                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\", name, sty));\n+                        invalid_monomorphization(sty);\n                     }\n                     C_nil(ccx)\n                 }\n@@ -437,10 +426,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         bcx.atomic_load(llargs[0], order)\n                     } else {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess, span,\n-                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\", name, sty));\n+                        invalid_monomorphization(sty);\n                         C_nil(ccx)\n                     }\n                 }\n@@ -450,10 +436,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         bcx.atomic_store(llargs[1], llargs[0], order);\n                     } else {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess, span,\n-                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\", name, sty));\n+                        invalid_monomorphization(sty);\n                     }\n                     C_nil(ccx)\n                 }\n@@ -489,15 +472,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         bcx.atomic_rmw(atom_op, llargs[0], llargs[1], order)\n                     } else {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess, span,\n-                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\", name, sty));\n+                        invalid_monomorphization(sty);\n                         C_nil(ccx)\n                     }\n                 }\n             }\n-\n         }\n \n         _ => {\n@@ -529,18 +508,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                         *any_changes_needed |= llvm_elem.is_some();\n \n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t,\n-                                                  any_changes_needed));\n+                        let elem = one(ty_to_type(ccx, t, any_changes_needed));\n                         vec![elem.ptr_to()]\n                     }\n                     Vector(ref t, ref llvm_elem, length) => {\n                         *any_changes_needed |= llvm_elem.is_some();\n \n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t,\n-                                                  any_changes_needed));\n-                        vec![Type::vector(&elem,\n-                                          length as u64)]\n+                        let elem = one(ty_to_type(ccx, t, any_changes_needed));\n+                        vec![Type::vector(&elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n@@ -585,8 +561,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n                         let llvm_elem = one(ty_to_type(bcx.ccx(), llvm_elem, &mut false));\n-                        vec![bcx.pointercast(llarg,\n-                                         llvm_elem.ptr_to())]\n+                        vec![bcx.pointercast(llarg, llvm_elem.ptr_to())]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n                         let llvm_elem = one(ty_to_type(bcx.ccx(), llvm_elem, &mut false));\n@@ -718,33 +693,6 @@ fn memset_intrinsic<'blk, 'tcx>(\n     call_memset(bcx, dst, val, bcx.mul(size, count), align, volatile)\n }\n \n-fn count_zeros_intrinsic(bcx: &BlockAndBuilder,\n-                         name: &str,\n-                         val: ValueRef)\n-                         -> ValueRef {\n-    let y = C_bool(bcx.ccx(), false);\n-    let llfn = bcx.ccx().get_intrinsic(&name);\n-    bcx.call(llfn, &[val, y], None)\n-}\n-\n-fn with_overflow_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                       name: &str,\n-                                       a: ValueRef,\n-                                       b: ValueRef,\n-                                       out: ValueRef)\n-                                       -> ValueRef {\n-    let llfn = bcx.ccx().get_intrinsic(&name);\n-\n-    // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = bcx.call(llfn, &[a, b], None);\n-    let result = bcx.extract_value(val, 0);\n-    let overflow = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx()));\n-    bcx.store(result, bcx.struct_gep(out, 0));\n-    bcx.store(overflow, bcx.struct_gep(out, 1));\n-\n-    C_nil(bcx.ccx())\n-}\n-\n fn try_intrinsic<'blk, 'tcx>(\n     bcx: &BlockAndBuilder<'blk, 'tcx>,\n     func: ValueRef,"}]}