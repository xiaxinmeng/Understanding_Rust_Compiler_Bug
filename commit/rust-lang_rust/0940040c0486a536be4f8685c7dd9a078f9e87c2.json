{"sha": "0940040c0486a536be4f8685c7dd9a078f9e87c2", "node_id": "C_kwDOAAsO6NoAKDA5NDAwNDBjMDQ4NmE1MzZiZTRmODY4NWM3ZGQ5YTA3OGY5ZTg3YzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-21T09:52:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-21T09:52:18Z"}, "message": "Auto merge of #103310 - lcnr:rustc_hir_typeck, r=compiler-errors\n\nmove hir typeck into separate crate\n\nsecond part https://github.com/rust-lang/compiler-team/issues/529\n\nI avoided pretty much anything that wasn't just a simple move + path adjustment. Left fixmes for methods which are at an odd place\n\nr? `@compiler-errors`", "tree": {"sha": "853d0ab60204348a26b53d5d2d81e3e2cdc6beef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/853d0ab60204348a26b53d5d2d81e3e2cdc6beef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0940040c0486a536be4f8685c7dd9a078f9e87c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0940040c0486a536be4f8685c7dd9a078f9e87c2", "html_url": "https://github.com/rust-lang/rust/commit/0940040c0486a536be4f8685c7dd9a078f9e87c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0940040c0486a536be4f8685c7dd9a078f9e87c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ab3b738ac718da74cd4aa0bb7f362d0adbdf84", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ab3b738ac718da74cd4aa0bb7f362d0adbdf84", "html_url": "https://github.com/rust-lang/rust/commit/b1ab3b738ac718da74cd4aa0bb7f362d0adbdf84"}, {"sha": "adc700b0899b183fbf45dbe2e9d788e97e4d726a", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc700b0899b183fbf45dbe2e9d788e97e4d726a", "html_url": "https://github.com/rust-lang/rust/commit/adc700b0899b183fbf45dbe2e9d788e97e4d726a"}], "stats": {"total": 2406, "additions": 1252, "deletions": 1154}, "files": [{"sha": "34d7f6066457009b62d8d8fe4b22ef6e2710d084", "filename": "Cargo.lock", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -3568,6 +3568,32 @@ dependencies = [\n  \"rustc_target\",\n ]\n \n+[[package]]\n+name = \"rustc_hir_typeck\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"rustc_ast\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_graphviz\",\n+ \"rustc_hir\",\n+ \"rustc_hir_analysis\",\n+ \"rustc_hir_pretty\",\n+ \"rustc_index\",\n+ \"rustc_infer\",\n+ \"rustc_lint\",\n+ \"rustc_macros\",\n+ \"rustc_middle\",\n+ \"rustc_serialize\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"rustc_trait_selection\",\n+ \"rustc_type_ir\",\n+ \"smallvec\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n@@ -3637,6 +3663,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_hir\",\n  \"rustc_hir_analysis\",\n+ \"rustc_hir_typeck\",\n  \"rustc_incremental\",\n  \"rustc_lint\",\n  \"rustc_macros\","}, {"sha": "9b9ef2b1fbd028a008683a47e44d497c1d3714dd", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -582,7 +582,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         assoc_bindings\n     }\n \n-    pub(crate) fn create_substs_for_associated_item(\n+    pub fn create_substs_for_associated_item(\n         &self,\n         span: Span,\n         item_def_id: DefId,"}, {"sha": "a1faf802519573c9a782c1cb532bac049ecc1e9a", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 311, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,6 +1,5 @@\n use crate::check::intrinsicck::InlineAsmCtxt;\n \n-use super::coercion::CoerceMany;\n use super::compare_method::check_type_bounds;\n use super::compare_method::{compare_impl_method, compare_ty_impl};\n use super::*;\n@@ -10,10 +9,8 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_lint::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n@@ -34,7 +31,7 @@ use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n use std::ops::ControlFlow;\n \n-pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Abi) {\n+pub fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Abi) {\n     match tcx.sess.target.is_abi_supported(abi) {\n         Some(true) => (),\n         Some(false) => {\n@@ -69,313 +66,6 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n     }\n }\n \n-/// Helper used for fns and closures. Does the grungy work of checking a function\n-/// body and returns the function context used for that purpose, since in the case of a fn item\n-/// there is still a bit more to do.\n-///\n-/// * ...\n-/// * inherited: other fields inherited from the enclosing fn (if any)\n-#[instrument(skip(inherited, body), level = \"debug\")]\n-pub(super) fn check_fn<'a, 'tcx>(\n-    inherited: &'a Inherited<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    fn_sig: ty::FnSig<'tcx>,\n-    decl: &'tcx hir::FnDecl<'tcx>,\n-    fn_id: hir::HirId,\n-    body: &'tcx hir::Body<'tcx>,\n-    can_be_generator: Option<hir::Movability>,\n-    return_type_pre_known: bool,\n-) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n-    // Create the function context. This is either derived from scratch or,\n-    // in the case of closures, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n-    fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n-    fcx.return_type_pre_known = return_type_pre_known;\n-\n-    let tcx = fcx.tcx;\n-    let hir = tcx.hir();\n-\n-    let declared_ret_ty = fn_sig.output();\n-\n-    let ret_ty =\n-        fcx.register_infer_ok_obligations(fcx.infcx.replace_opaque_types_with_inference_vars(\n-            declared_ret_ty,\n-            body.value.hir_id,\n-            decl.output.span(),\n-            param_env,\n-        ));\n-    // If we replaced declared_ret_ty with infer vars, then we must be inferring\n-    // an opaque type, so set a flag so we can improve diagnostics.\n-    fcx.return_type_has_opaque = ret_ty != declared_ret_ty;\n-\n-    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n-\n-    let span = body.value.span;\n-\n-    fn_maybe_err(tcx, span, fn_sig.abi);\n-\n-    if fn_sig.abi == Abi::RustCall {\n-        let expected_args = if let ImplicitSelfKind::None = decl.implicit_self { 1 } else { 2 };\n-\n-        let err = || {\n-            let item = match tcx.hir().get(fn_id) {\n-                Node::Item(hir::Item { kind: ItemKind::Fn(header, ..), .. }) => Some(header),\n-                Node::ImplItem(hir::ImplItem {\n-                    kind: hir::ImplItemKind::Fn(header, ..), ..\n-                }) => Some(header),\n-                Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(header, ..),\n-                    ..\n-                }) => Some(header),\n-                // Closures are RustCall, but they tuple their arguments, so shouldn't be checked\n-                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => None,\n-                node => bug!(\"Item being checked wasn't a function/closure: {:?}\", node),\n-            };\n-\n-            if let Some(header) = item {\n-                tcx.sess.span_err(header.span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n-            }\n-        };\n-\n-        if fn_sig.inputs().len() != expected_args {\n-            err()\n-        } else {\n-            // FIXME(CraftSpider) Add a check on parameter expansion, so we don't just make the ICE happen later on\n-            //   This will probably require wide-scale changes to support a TupleKind obligation\n-            //   We can't resolve this without knowing the type of the param\n-            if !matches!(fn_sig.inputs()[expected_args - 1].kind(), ty::Tuple(_) | ty::Param(_)) {\n-                err()\n-            }\n-        }\n-    }\n-\n-    if body.generator_kind.is_some() && can_be_generator.is_some() {\n-        let yield_ty = fcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n-        fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n-\n-        // Resume type defaults to `()` if the generator has no argument.\n-        let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());\n-\n-        fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n-    }\n-\n-    GatherLocalsVisitor::new(&fcx).visit_body(body);\n-\n-    // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n-    // (as it's created inside the body itself, not passed in from outside).\n-    let maybe_va_list = if fn_sig.c_variadic {\n-        let span = body.params.last().unwrap().span;\n-        let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(span));\n-        let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n-\n-        Some(tcx.bound_type_of(va_list_did).subst(tcx, &[region.into()]))\n-    } else {\n-        None\n-    };\n-\n-    // Add formal parameters.\n-    let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n-    let inputs_fn = fn_sig.inputs().iter().copied();\n-    for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n-        // Check the pattern.\n-        let ty_span = try { inputs_hir?.get(idx)?.span };\n-        fcx.check_pat_top(&param.pat, param_ty, ty_span, false);\n-\n-        // Check that argument is Sized.\n-        // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n-        // for simple cases like `fn foo(x: Trait)`,\n-        // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if param.pat.simple_ident().is_none() && !tcx.features().unsized_fn_params {\n-            fcx.require_type_is_sized(param_ty, param.pat.span, traits::SizedArgumentType(ty_span));\n-        }\n-\n-        fcx.write_ty(param.hir_id, param_ty);\n-    }\n-\n-    inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n-\n-    fcx.in_tail_expr = true;\n-    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n-        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n-        // been evaluated so that we have types available for all the nodes being returned, but that\n-        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n-        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n-        // while keeping the current ordering we will ignore the tail expression's type because we\n-        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n-        // because we will trigger \"unreachable expression\" lints unconditionally.\n-        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n-        // case that a newcomer might make, returning a bare trait, and in that case we populate\n-        // the tail expression's type so that the suggestion will be correct, but ignore all other\n-        // possible cases.\n-        fcx.check_expr(&body.value);\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    } else {\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-        fcx.check_return_expr(&body.value, false);\n-    }\n-    fcx.in_tail_expr = false;\n-\n-    // We insert the deferred_generator_interiors entry after visiting the body.\n-    // This ensures that all nested generators appear before the entry of this generator.\n-    // resolve_generator_interiors relies on this property.\n-    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n-        let interior = fcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n-\n-        let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n-        Some(GeneratorTypes {\n-            resume_ty,\n-            yield_ty,\n-            interior,\n-            movability: can_be_generator.unwrap(),\n-        })\n-    } else {\n-        None\n-    };\n-\n-    // Finalize the return check by taking the LUB of the return types\n-    // we saw and assigning it to the expected return type. This isn't\n-    // really expected to fail, since the coercions would have failed\n-    // earlier when trying to find a LUB.\n-    let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n-    let mut actual_return_ty = coercion.complete(&fcx);\n-    debug!(\"actual_return_ty = {:?}\", actual_return_ty);\n-    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n-        // We have special-cased the case where the function is declared\n-        // `-> dyn Foo` and we don't actually relate it to the\n-        // `fcx.ret_coercion`, so just substitute a type variable.\n-        actual_return_ty =\n-            fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n-        debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n-    }\n-\n-    // HACK(oli-obk, compiler-errors): We should be comparing this against\n-    // `declared_ret_ty`, but then anything uninferred would be inferred to\n-    // the opaque type itself. That again would cause writeback to assume\n-    // we have a recursive call site and do the sadly stabilized fallback to `()`.\n-    fcx.demand_suptype(span, ret_ty, actual_return_ty);\n-\n-    // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n-    if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n-        && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n-    {\n-        check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n-    }\n-\n-    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n-        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n-    {\n-        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n-    }\n-\n-    (fcx, gen_ty)\n-}\n-\n-fn check_panic_info_fn(\n-    tcx: TyCtxt<'_>,\n-    fn_id: LocalDefId,\n-    fn_sig: ty::FnSig<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    declared_ret_ty: Ty<'_>,\n-) {\n-    let Some(panic_info_did) = tcx.lang_items().panic_info() else {\n-        tcx.sess.err(\"language item required, but not found: `panic_info`\");\n-        return;\n-    };\n-\n-    if *declared_ret_ty.kind() != ty::Never {\n-        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n-    }\n-\n-    let inputs = fn_sig.inputs();\n-    if inputs.len() != 1 {\n-        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n-        return;\n-    }\n-\n-    let arg_is_panic_info = match *inputs[0].kind() {\n-        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n-            ty::Adt(ref adt, _) => {\n-                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n-            }\n-            _ => false,\n-        },\n-        _ => false,\n-    };\n-\n-    if !arg_is_panic_info {\n-        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n-    }\n-\n-    let DefKind::Fn = tcx.def_kind(fn_id) else {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"should be a function\");\n-        return;\n-    };\n-\n-    let generic_counts = tcx.generics_of(fn_id).own_counts();\n-    if generic_counts.types != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"should have no type parameters\");\n-    }\n-    if generic_counts.consts != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"should have no const parameters\");\n-    }\n-}\n-\n-fn check_alloc_error_fn(\n-    tcx: TyCtxt<'_>,\n-    fn_id: LocalDefId,\n-    fn_sig: ty::FnSig<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    declared_ret_ty: Ty<'_>,\n-) {\n-    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n-        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n-        return;\n-    };\n-\n-    if *declared_ret_ty.kind() != ty::Never {\n-        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n-    }\n-\n-    let inputs = fn_sig.inputs();\n-    if inputs.len() != 1 {\n-        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n-        return;\n-    }\n-\n-    let arg_is_alloc_layout = match inputs[0].kind() {\n-        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-        _ => false,\n-    };\n-\n-    if !arg_is_alloc_layout {\n-        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-    }\n-\n-    let DefKind::Fn = tcx.def_kind(fn_id) else {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n-        return;\n-    };\n-\n-    let generic_counts = tcx.generics_of(fn_id).own_counts();\n-    if generic_counts.types != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n-    }\n-    if generic_counts.consts != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess\n-            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n-    }\n-}\n-\n fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);"}, {"sha": "a026f8033c8cb5029a89602d5b249a48d7aa1e2f", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,117 +1,11 @@\n-use hir::HirId;\n use rustc_ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_index::vec::Idx;\n-use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitable, UintTy};\n use rustc_session::lint;\n use rustc_span::{Symbol, DUMMY_SP};\n-use rustc_target::abi::{Pointer, VariantIdx};\n use rustc_target::asm::{InlineAsmReg, InlineAsmRegClass, InlineAsmRegOrRegClass, InlineAsmType};\n \n-use super::FnCtxt;\n-\n-/// If the type is `Option<T>`, it will return `T`, otherwise\n-/// the type itself. Works on most `Option`-like types.\n-fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let ty::Adt(def, substs) = *ty.kind() else { return ty };\n-\n-    if def.variants().len() == 2 && !def.repr().c() && def.repr().int.is_none() {\n-        let data_idx;\n-\n-        let one = VariantIdx::new(1);\n-        let zero = VariantIdx::new(0);\n-\n-        if def.variant(zero).fields.is_empty() {\n-            data_idx = one;\n-        } else if def.variant(one).fields.is_empty() {\n-            data_idx = zero;\n-        } else {\n-            return ty;\n-        }\n-\n-        if def.variant(data_idx).fields.len() == 1 {\n-            return def.variant(data_idx).fields[0].ty(tcx, substs);\n-        }\n-    }\n-\n-    ty\n-}\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn check_transmute(&self, from: Ty<'tcx>, to: Ty<'tcx>, hir_id: HirId) {\n-        let tcx = self.tcx;\n-        let span = tcx.hir().span(hir_id);\n-        let normalize = |ty| {\n-            let ty = self.resolve_vars_if_possible(ty);\n-            self.tcx.normalize_erasing_regions(self.param_env, ty)\n-        };\n-        let from = normalize(from);\n-        let to = normalize(to);\n-        trace!(?from, ?to);\n-\n-        // Transmutes that are only changing lifetimes are always ok.\n-        if from == to {\n-            return;\n-        }\n-\n-        let skel = |ty| SizeSkeleton::compute(ty, tcx, self.param_env);\n-        let sk_from = skel(from);\n-        let sk_to = skel(to);\n-        trace!(?sk_from, ?sk_to);\n-\n-        // Check for same size using the skeletons.\n-        if let (Ok(sk_from), Ok(sk_to)) = (sk_from, sk_to) {\n-            if sk_from.same_size(sk_to) {\n-                return;\n-            }\n-\n-            // Special-case transmuting from `typeof(function)` and\n-            // `Option<typeof(function)>` to present a clearer error.\n-            let from = unpack_option_like(tcx, from);\n-            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer.size(&tcx) {\n-                struct_span_err!(tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n-                    .note(&format!(\"source type: {from}\"))\n-                    .note(&format!(\"target type: {to}\"))\n-                    .help(\"cast with `as` to a pointer instead\")\n-                    .emit();\n-                return;\n-            }\n-        }\n-\n-        // Try to display a sensible error with as much information as possible.\n-        let skeleton_string = |ty: Ty<'tcx>, sk| match sk {\n-            Ok(SizeSkeleton::Known(size)) => format!(\"{} bits\", size.bits()),\n-            Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{tail}`\"),\n-            Err(LayoutError::Unknown(bad)) => {\n-                if bad == ty {\n-                    \"this type does not have a fixed size\".to_owned()\n-                } else {\n-                    format!(\"size can vary because of {bad}\")\n-                }\n-            }\n-            Err(err) => err.to_string(),\n-        };\n-\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0512,\n-            \"cannot transmute between types of different sizes, \\\n-                                        or dependently-sized types\"\n-        );\n-        if from == to {\n-            err.note(&format!(\"`{from}` does not have a fixed size\"));\n-        } else {\n-            err.note(&format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n-                .note(&format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n-        }\n-        err.emit();\n-    }\n-}\n-\n pub struct InlineAsmCtxt<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "2e7b1025764076f651cb1fe50c54a2e6287c3f98", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 23, "deletions": 479, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -62,191 +62,45 @@ a type parameter).\n \n */\n \n-pub mod _match;\n-mod autoderef;\n-mod callee;\n-pub mod cast;\n mod check;\n-mod closure;\n-pub mod coercion;\n mod compare_method;\n-pub mod demand;\n-mod diverges;\n pub mod dropck;\n-mod expectation;\n-mod expr;\n-mod fallback;\n-mod fn_ctxt;\n-mod gather_locals;\n-mod generator_interior;\n-mod inherited;\n pub mod intrinsic;\n-mod intrinsicck;\n-pub mod method;\n-mod op;\n-mod pat;\n-mod place_op;\n+pub mod intrinsicck;\n mod region;\n-pub mod rvalue_scopes;\n-mod upvar;\n pub mod wfcheck;\n-pub mod writeback;\n \n-use check::{check_abi, check_fn, check_mod_item_types};\n-pub use diverges::Diverges;\n-pub use expectation::Expectation;\n-pub use fn_ctxt::*;\n-pub use inherited::{Inherited, InheritedBuilder};\n+pub use check::check_abi;\n \n-use crate::astconv::AstConv;\n-use crate::check::gather_locals::GatherLocalsVisitor;\n+use check::check_mod_item_types;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, MultiSpan,\n-};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{HirIdMap, ImplicitSelfKind, Node};\n use rustc_index::bit_set::BitSet;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, Ty, TyCtxt, UserType};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n-use rustc_session::config;\n use rustc_session::parse::feature_err;\n-use rustc_session::Session;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{self, BytePos, Span, Symbol};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n-use std::cell::RefCell;\n use std::num::NonZeroU32;\n \n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::coercion::DynamicCoerceMany;\n use self::compare_method::collect_trait_impl_trait_tys;\n use self::region::region_scope_tree;\n-pub use self::Expectation::*;\n-\n-#[macro_export]\n-macro_rules! type_error_struct {\n-    ($session:expr, $span:expr, $typ:expr, $code:ident, $($message:tt)*) => ({\n-        let mut err = rustc_errors::struct_span_err!($session, $span, $code, $($message)*);\n-\n-        if $typ.references_error() {\n-            err.downgrade_to_delayed_bug();\n-        }\n-\n-        err\n-    })\n-}\n-\n-/// The type of a local binding, including the revealed type for anon types.\n-#[derive(Copy, Clone, Debug)]\n-pub struct LocalTy<'tcx> {\n-    decl_ty: Ty<'tcx>,\n-    revealed_ty: Ty<'tcx>,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Needs {\n-    MutPlace,\n-    None,\n-}\n-\n-impl Needs {\n-    fn maybe_mut_place(m: hir::Mutability) -> Self {\n-        match m {\n-            hir::Mutability::Mut => Needs::MutPlace,\n-            hir::Mutability::Not => Needs::None,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnsafetyState {\n-    pub def: hir::HirId,\n-    pub unsafety: hir::Unsafety,\n-    from_fn: bool,\n-}\n-\n-impl UnsafetyState {\n-    pub fn function(unsafety: hir::Unsafety, def: hir::HirId) -> UnsafetyState {\n-        UnsafetyState { def, unsafety, from_fn: true }\n-    }\n-\n-    pub fn recurse(self, blk: &hir::Block<'_>) -> UnsafetyState {\n-        use hir::BlockCheckMode;\n-        match self.unsafety {\n-            // If this unsafe, then if the outer function was already marked as\n-            // unsafe we shouldn't attribute the unsafe'ness to the block. This\n-            // way the block can be warned about instead of ignoring this\n-            // extraneous block (functions are never warned about).\n-            hir::Unsafety::Unsafe if self.from_fn => self,\n-\n-            unsafety => {\n-                let (unsafety, def) = match blk.rules {\n-                    BlockCheckMode::UnsafeBlock(..) => (hir::Unsafety::Unsafe, blk.hir_id),\n-                    BlockCheckMode::DefaultBlock => (unsafety, self.def),\n-                };\n-                UnsafetyState { def, unsafety, from_fn: false }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone)]\n-pub enum PlaceOp {\n-    Deref,\n-    Index,\n-}\n-\n-pub struct BreakableCtxt<'tcx> {\n-    may_break: bool,\n-\n-    // this is `null` for loops where break with a value is illegal,\n-    // such as `while`, `for`, and `while let`\n-    coerce: Option<DynamicCoerceMany<'tcx>>,\n-}\n-\n-pub struct EnclosingBreakables<'tcx> {\n-    stack: Vec<BreakableCtxt<'tcx>>,\n-    by_id: HirIdMap<usize>,\n-}\n-\n-impl<'tcx> EnclosingBreakables<'tcx> {\n-    fn find_breakable(&mut self, target_id: hir::HirId) -> &mut BreakableCtxt<'tcx> {\n-        self.opt_find_breakable(target_id).unwrap_or_else(|| {\n-            bug!(\"could not find enclosing breakable with id {}\", target_id);\n-        })\n-    }\n-\n-    fn opt_find_breakable(&mut self, target_id: hir::HirId) -> Option<&mut BreakableCtxt<'tcx>> {\n-        match self.by_id.get(&target_id) {\n-            Some(ix) => Some(&mut self.stack[*ix]),\n-            None => None,\n-        }\n-    }\n-}\n \n pub fn provide(providers: &mut Providers) {\n-    method::provide(providers);\n     wfcheck::provide(providers);\n     *providers = Providers {\n-        typeck_item_bodies,\n-        typeck_const_arg,\n-        typeck,\n-        diagnostic_only_typeck,\n-        has_typeck_results,\n         adt_destructor,\n-        used_trait_imports,\n         check_mod_item_types,\n         region_scope_tree,\n         collect_trait_impl_trait_tys,\n@@ -259,259 +113,6 @@ fn adt_destructor(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::Destructor> {\n     tcx.calculate_dtor(def_id, dropck::check_drop_impl)\n }\n \n-/// If this `DefId` is a \"primary tables entry\", returns\n-/// `Some((body_id, body_ty, fn_sig))`. Otherwise, returns `None`.\n-///\n-/// If this function returns `Some`, then `typeck_results(def_id)` will\n-/// succeed; if it returns `None`, then `typeck_results(def_id)` may or\n-/// may not succeed. In some cases where this function returns `None`\n-/// (notably closures), `typeck_results(def_id)` would wind up\n-/// redirecting to the owning function.\n-fn primary_body_of(\n-    tcx: TyCtxt<'_>,\n-    id: hir::HirId,\n-) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n-    match tcx.hir().get(id) {\n-        Node::Item(item) => match item.kind {\n-            hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n-                Some((body, Some(ty), None))\n-            }\n-            hir::ItemKind::Fn(ref sig, .., body) => Some((body, None, Some(sig))),\n-            _ => None,\n-        },\n-        Node::TraitItem(item) => match item.kind {\n-            hir::TraitItemKind::Const(ty, Some(body)) => Some((body, Some(ty), None)),\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                Some((body, None, Some(sig)))\n-            }\n-            _ => None,\n-        },\n-        Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Const(ty, body) => Some((body, Some(ty), None)),\n-            hir::ImplItemKind::Fn(ref sig, body) => Some((body, None, Some(sig))),\n-            _ => None,\n-        },\n-        Node::AnonConst(constant) => Some((constant.body, None, None)),\n-        _ => None,\n-    }\n-}\n-\n-fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    // Closures' typeck results come from their outermost function,\n-    // as they are part of the same \"inference environment\".\n-    let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n-    if typeck_root_def_id != def_id {\n-        return tcx.has_typeck_results(typeck_root_def_id);\n-    }\n-\n-    if let Some(def_id) = def_id.as_local() {\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        primary_body_of(tcx, id).is_some()\n-    } else {\n-        false\n-    }\n-}\n-\n-fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDefId> {\n-    &*tcx.typeck(def_id).used_trait_imports\n-}\n-\n-fn typeck_const_arg<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (did, param_did): (LocalDefId, DefId),\n-) -> &ty::TypeckResults<'tcx> {\n-    let fallback = move || tcx.type_of(param_did);\n-    typeck_with_fallback(tcx, did, fallback)\n-}\n-\n-fn typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n-    if let Some(param_did) = tcx.opt_const_param_of(def_id) {\n-        tcx.typeck_const_arg((def_id, param_did))\n-    } else {\n-        let fallback = move || tcx.type_of(def_id.to_def_id());\n-        typeck_with_fallback(tcx, def_id, fallback)\n-    }\n-}\n-\n-/// Used only to get `TypeckResults` for type inference during error recovery.\n-/// Currently only used for type inference of `static`s and `const`s to avoid type cycle errors.\n-fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n-    let fallback = move || {\n-        let span = tcx.hir().span(tcx.hir().local_def_id_to_hir_id(def_id));\n-        tcx.ty_error_with_message(span, \"diagnostic only typeck table used\")\n-    };\n-    typeck_with_fallback(tcx, def_id, fallback)\n-}\n-\n-fn typeck_with_fallback<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-    fallback: impl Fn() -> Ty<'tcx> + 'tcx,\n-) -> &'tcx ty::TypeckResults<'tcx> {\n-    // Closures' typeck results come from their outermost function,\n-    // as they are part of the same \"inference environment\".\n-    let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id()).expect_local();\n-    if typeck_root_def_id != def_id {\n-        return tcx.typeck(typeck_root_def_id);\n-    }\n-\n-    let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let span = tcx.hir().span(id);\n-\n-    // Figure out what primary body this item has.\n-    let (body_id, body_ty, fn_sig) = primary_body_of(tcx, id).unwrap_or_else(|| {\n-        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n-    });\n-    let body = tcx.hir().body(body_id);\n-\n-    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n-        let param_env = tcx.param_env(def_id);\n-        let mut fcx = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n-            let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n-            } else {\n-                tcx.fn_sig(def_id)\n-            };\n-\n-            check_abi(tcx, id, span, fn_sig.abi());\n-\n-            // Compute the function signature from point of view of inside the fn.\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n-            let fn_sig = inh.normalize_associated_types_in(\n-                body.value.span,\n-                body_id.hir_id,\n-                param_env,\n-                fn_sig,\n-            );\n-            check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0\n-        } else {\n-            let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-            let expected_type = body_ty\n-                .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(<dyn AstConv<'_>>::ast_ty_to_ty(&fcx, ty)),\n-                    _ => None,\n-                })\n-                .unwrap_or_else(|| match tcx.hir().get(id) {\n-                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().get_parent_node(id)) {\n-                        Node::Expr(&hir::Expr {\n-                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n-                            ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Ty(&hir::Ty {\n-                            kind: hir::TyKind::Typeof(ref anon_const), ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n-                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty = asm\n-                                .operands\n-                                .iter()\n-                                .filter_map(|(op, _op_sp)| match op {\n-                                    hir::InlineAsmOperand::Const { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        // Inline assembly constants must be integers.\n-                                        Some(fcx.next_int_var())\n-                                    }\n-                                    hir::InlineAsmOperand::SymFn { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n-                                            kind: TypeVariableOriginKind::MiscVariable,\n-                                            span,\n-                                        }))\n-                                    }\n-                                    _ => None,\n-                                })\n-                                .next();\n-                            operand_ty.unwrap_or_else(fallback)\n-                        }\n-                        _ => fallback(),\n-                    },\n-                    _ => fallback(),\n-                });\n-\n-            let expected_type = fcx.normalize_associated_types_in(body.value.span, expected_type);\n-            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n-\n-            // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor::new(&fcx).visit_body(body);\n-\n-            fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n-\n-            fcx.write_ty(id, expected_type);\n-\n-            fcx\n-        };\n-\n-        let fallback_has_occurred = fcx.type_inference_fallback();\n-\n-        // Even though coercion casts provide type hints, we check casts after fallback for\n-        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n-        fcx.check_casts();\n-        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n-        // Closure and generator analysis may run after fallback\n-        // because they don't constrain other type variables.\n-        // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n-        let prev_constness = fcx.param_env.constness();\n-        fcx.param_env = fcx.param_env.without_const();\n-        fcx.closure_analyze(body);\n-        fcx.param_env = fcx.param_env.with_constness(prev_constness);\n-        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n-        // Before the generator analysis, temporary scopes shall be marked to provide more\n-        // precise information on types to be captured.\n-        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n-        fcx.resolve_generator_interiors(def_id.to_def_id());\n-\n-        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize_ty(span, ty);\n-            fcx.require_type_is_sized(ty, span, code);\n-        }\n-\n-        fcx.select_all_obligations_or_error();\n-\n-        if !fcx.infcx.is_tainted_by_errors() {\n-            fcx.check_transmutes();\n-        }\n-\n-        fcx.check_asms();\n-\n-        fcx.infcx.skip_region_resolution();\n-\n-        fcx.resolve_type_vars_in_body(body)\n-    });\n-\n-    // Consistency check our TypeckResults instance can hold all ItemLocalIds\n-    // it will need to hold.\n-    assert_eq!(typeck_results.hir_owner, id.owner);\n-\n-    typeck_results\n-}\n-\n-/// When `check_fn` is invoked on a generator (i.e., a body that\n-/// includes yield), it returns back some information about the yield\n-/// points.\n-struct GeneratorTypes<'tcx> {\n-    /// Type of generator argument / values returned by `yield`.\n-    resume_ty: Ty<'tcx>,\n-\n-    /// Type of value that is yielded.\n-    yield_ty: Ty<'tcx>,\n-\n-    /// Types that are captured (see `GeneratorInterior` for more).\n-    interior: Ty<'tcx>,\n-\n-    /// Indicates if the generator is movable or static (immovable).\n-    movability: hir::Movability,\n-}\n-\n /// Given a `DefId` for an opaque type in return position, find its parent item's return\n /// expressions.\n fn get_owner_return_paths<'tcx>(\n@@ -528,9 +129,10 @@ fn get_owner_return_paths<'tcx>(\n     })\n }\n \n-// Forbid defining intrinsics in Rust code,\n-// as they must always be defined by the compiler.\n-fn fn_maybe_err(tcx: TyCtxt<'_>, sp: Span, abi: Abi) {\n+/// Forbid defining intrinsics in Rust code,\n+/// as they must always be defined by the compiler.\n+// FIXME: Move this to a more appropriate place.\n+pub fn fn_maybe_err(tcx: TyCtxt<'_>, sp: Span, abi: Abi) {\n     if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n         tcx.sess.span_err(sp, \"intrinsic must be in `extern \\\"rust-intrinsic\\\" { ... }` block\");\n     }\n@@ -824,6 +426,17 @@ fn fn_sig_suggestion<'tcx>(\n     format!(\"{unsafety}fn {ident}{generics}({args}){output}{where_clauses} {{ todo!() }}\")\n }\n \n+pub fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n+    Some(match ty.kind() {\n+        ty::Bool => \"true\",\n+        ty::Char => \"'a'\",\n+        ty::Int(_) | ty::Uint(_) => \"42\",\n+        ty::Float(_) => \"3.14159\",\n+        ty::Error(_) | ty::Never => return None,\n+        _ => \"value\",\n+    })\n+}\n+\n /// Return placeholder code for the given associated item.\n /// Similar to `ty::AssocItem::suggestion`, but appropriate for use as the code snippet of a\n /// structured suggestion.\n@@ -845,7 +458,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n         ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.name),\n         ty::AssocKind::Const => {\n             let ty = tcx.type_of(assoc.def_id);\n-            let val = expr::ty_kind_suggestion(ty).unwrap_or(\"value\");\n+            let val = ty_kind_suggestion(ty).unwrap_or(\"value\");\n             format!(\"const {}: {} = {};\", assoc.name, ty, val)\n         }\n     }\n@@ -896,76 +509,7 @@ fn bad_non_zero_sized_fields<'tcx>(\n     err.emit();\n }\n \n-fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'_>, span: Span) {\n-    struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0533,\n-        \"expected unit struct, unit variant or constant, found {} `{}`\",\n-        res.descr(),\n-        rustc_hir_pretty::qpath_to_string(qpath),\n-    )\n-    .emit();\n-}\n-\n-/// Controls whether the arguments are tupled. This is used for the call\n-/// operator.\n-///\n-/// Tupling means that all call-side arguments are packed into a tuple and\n-/// passed as a single parameter. For example, if tupling is enabled, this\n-/// function:\n-/// ```\n-/// fn f(x: (isize, isize)) {}\n-/// ```\n-/// Can be called as:\n-/// ```ignore UNSOLVED (can this be done in user code?)\n-/// # fn f(x: (isize, isize)) {}\n-/// f(1, 2);\n-/// ```\n-/// Instead of:\n-/// ```\n-/// # fn f(x: (isize, isize)) {}\n-/// f((1, 2));\n-/// ```\n-#[derive(Clone, Eq, PartialEq)]\n-enum TupleArgumentsFlag {\n-    DontTupleArguments,\n-    TupleArguments,\n-}\n-\n-fn typeck_item_bodies(tcx: TyCtxt<'_>, (): ()) {\n-    tcx.hir().par_body_owners(|body_owner_def_id| tcx.ensure().typeck(body_owner_def_id));\n-}\n-\n-fn fatally_break_rust(sess: &Session) {\n-    let handler = sess.diagnostic();\n-    handler.span_bug_no_panic(\n-        MultiSpan::new(),\n-        \"It looks like you're trying to break rust; would you like some ICE?\",\n-    );\n-    handler.note_without_error(\"the compiler expectedly panicked. this is a feature.\");\n-    handler.note_without_error(\n-        \"we would appreciate a joke overview: \\\n-         https://github.com/rust-lang/rust/issues/43162#issuecomment-320764675\",\n-    );\n-    handler.note_without_error(&format!(\n-        \"rustc {} running on {}\",\n-        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n-        config::host_triple(),\n-    ));\n-}\n-\n-fn potentially_plural_count(count: usize, word: &str) -> String {\n+// FIXME: Consider moving this method to a more fitting place.\n+pub fn potentially_plural_count(count: usize, word: &str) -> String {\n     format!(\"{} {}{}\", count, word, pluralize!(count))\n }\n-\n-fn has_expected_num_generic_args<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_did: Option<DefId>,\n-    expected: usize,\n-) -> bool {\n-    trait_did.map_or(true, |trait_did| {\n-        let generics = tcx.generics_of(trait_did);\n-        generics.count() == expected + if generics.has_self { 1 } else { 0 }\n-    })\n-}"}, {"sha": "66ca7d7aa08f9cd1d23bfb0ab1afa32d4f684453", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -100,13 +100,12 @@ pub fn provide(providers: &mut Providers) {\n /// It's also used for the bodies of items like structs where the body (the fields)\n /// are just signatures.\n ///\n-/// This is in contrast to [`FnCtxt`], which is used to type-check bodies of\n+/// This is in contrast to `FnCtxt`, which is used to type-check bodies of\n /// functions, closures, and `const`s -- anywhere that expressions and statements show up.\n ///\n /// An important thing to note is that `ItemCtxt` does no inference -- it has no [`InferCtxt`] --\n /// while `FnCtxt` does do inference.\n ///\n-/// [`FnCtxt`]: crate::check::FnCtxt\n /// [`InferCtxt`]: rustc_infer::infer::InferCtxt\n ///\n /// # Trait predicates"}, {"sha": "aaebbe6398a1342083240bf692d15717698af821", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 2, "deletions": 125, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,22 +1,11 @@\n-//! Errors emitted by `hir_analysis`.\n+//! Errors emitted by `rustc_hir_analysis`.\n \n use rustc_errors::IntoDiagnostic;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler};\n-use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_macros::{Diagnostic, LintDiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::field_multiply_specified_in_initializer, code = \"E0062\")]\n-pub struct FieldMultiplySpecifiedInInitializer {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    #[label(hir_analysis::previous_use_label)]\n-    pub prev_span: Span,\n-    pub ident: Ident,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(hir_analysis::unrecognized_atomic_operation, code = \"E0092\")]\n pub struct UnrecognizedAtomicOperation<'a> {\n@@ -124,13 +113,6 @@ pub struct AssocTypeBindingNotAllowed {\n     pub span: Span,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::functional_record_update_on_non_struct, code = \"E0436\")]\n-pub struct FunctionalRecordUpdateOnNonStruct {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(hir_analysis::typeof_reserved_keyword_used, code = \"E0516\")]\n pub struct TypeofReservedKeywordUsed<'tcx> {\n@@ -142,39 +124,6 @@ pub struct TypeofReservedKeywordUsed<'tcx> {\n     pub opt_sugg: Option<(Span, Applicability)>,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::return_stmt_outside_of_fn_body, code = \"E0572\")]\n-pub struct ReturnStmtOutsideOfFnBody {\n-    #[primary_span]\n-    pub span: Span,\n-    #[label(hir_analysis::encl_body_label)]\n-    pub encl_body_span: Option<Span>,\n-    #[label(hir_analysis::encl_fn_label)]\n-    pub encl_fn_span: Option<Span>,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::yield_expr_outside_of_generator, code = \"E0627\")]\n-pub struct YieldExprOutsideOfGenerator {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::struct_expr_non_exhaustive, code = \"E0639\")]\n-pub struct StructExprNonExhaustive {\n-    #[primary_span]\n-    pub span: Span,\n-    pub what: &'static str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::method_call_on_unknown_type, code = \"E0699\")]\n-pub struct MethodCallOnUnknownType {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(hir_analysis::value_of_associated_struct_already_specified, code = \"E0719\")]\n pub struct ValueOfAssociatedStructAlreadySpecified {\n@@ -187,52 +136,6 @@ pub struct ValueOfAssociatedStructAlreadySpecified {\n     pub def_path: String,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::address_of_temporary_taken, code = \"E0745\")]\n-pub struct AddressOfTemporaryTaken {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum AddReturnTypeSuggestion {\n-    #[suggestion(\n-        hir_analysis::add_return_type_add,\n-        code = \"-> {found} \",\n-        applicability = \"machine-applicable\"\n-    )]\n-    Add {\n-        #[primary_span]\n-        span: Span,\n-        found: String,\n-    },\n-    #[suggestion(\n-        hir_analysis::add_return_type_missing_here,\n-        code = \"-> _ \",\n-        applicability = \"has-placeholders\"\n-    )]\n-    MissingHere {\n-        #[primary_span]\n-        span: Span,\n-    },\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum ExpectedReturnTypeLabel<'tcx> {\n-    #[label(hir_analysis::expected_default_return_type)]\n-    Unit {\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(hir_analysis::expected_return_type)]\n-    Other {\n-        #[primary_span]\n-        span: Span,\n-        expected: Ty<'tcx>,\n-    },\n-}\n-\n #[derive(Diagnostic)]\n #[diag(hir_analysis::unconstrained_opaque_type)]\n #[note]\n@@ -346,29 +249,3 @@ pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,\n }\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::missing_parentheses_in_range, code = \"E0689\")]\n-pub struct MissingParentheseInRange {\n-    #[primary_span]\n-    #[label(hir_analysis::missing_parentheses_in_range)]\n-    pub span: Span,\n-    pub ty_str: String,\n-    pub method_name: String,\n-\n-    #[subdiagnostic]\n-    pub add_missing_parentheses: Option<AddMissingParenthesesInRange>,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion_verbose(\n-    hir_analysis::add_missing_parentheses_in_range,\n-    applicability = \"maybe-incorrect\"\n-)]\n-pub struct AddMissingParenthesesInRange {\n-    pub func_name: String,\n-    #[suggestion_part(code = \"(\")]\n-    pub left: Span,\n-    #[suggestion_part(code = \")\")]\n-    pub right: Span,\n-}"}, {"sha": "dba505149de87f2a3e12a85b57e460e4c772a730", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -82,20 +82,19 @@ extern crate rustc_middle;\n \n // These are used by Clippy.\n pub mod check;\n-pub mod expr_use_visitor;\n \n-mod astconv;\n+pub mod astconv;\n mod bounds;\n mod check_unused;\n mod coherence;\n-mod collect;\n+// FIXME: This module shouldn't be public.\n+pub mod collect;\n mod constrained_generic_params;\n mod errors;\n pub mod hir_wf_check;\n mod impl_wf_check;\n-mod mem_categorization;\n mod outlives;\n-mod structured_errors;\n+pub mod structured_errors;\n mod variance;\n \n use rustc_errors::{struct_span_err, ErrorGuaranteed};"}, {"sha": "093f9bb84486e267cc72919c00a1f14de33cbf93", "filename": "compiler/rustc_hir_typeck/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2FCargo.toml?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -0,0 +1,28 @@\n+[package]\n+name = \"rustc_hir_typeck\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n+tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_graphviz = { path = \"../rustc_graphviz\" }\n+rustc_index = { path = \"../rustc_index\" }\n+rustc_infer = { path = \"../rustc_infer\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n+rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n+rustc_lint = { path = \"../rustc_lint\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_target = { path = \"../rustc_target\" }\n+rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "c22d828625bc85b0168ca10ec6a246899aeebf9f", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,5 +1,5 @@\n-use crate::check::coercion::{AsCoercionSite, CoerceMany};\n-use crate::check::{Diverges, Expectation, FnCtxt, Needs};\n+use crate::coercion::{AsCoercionSite, CoerceMany};\n+use crate::{Diverges, Expectation, FnCtxt, Needs};\n use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};", "previous_filename": "compiler/rustc_hir_analysis/src/check/_match.rs"}, {"sha": "59c366ad7d776cb41868bc18140e042f70ccab60", "filename": "compiler/rustc_hir_typeck/src/autoderef.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/autoderef.rs"}, {"sha": "1b33f2f02b8adf7507c636cadd740c14fff79054", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,8 +1,8 @@\n use super::method::probe::{IsSuggestion, Mode, ProbeScope};\n use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n-use crate::type_error_struct;\n \n+use crate::type_error_struct;\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, StashKey};\n use rustc_hir as hir;", "previous_filename": "compiler/rustc_hir_analysis/src/check/callee.rs"}, {"sha": "0e7576ecf8b0c58db99f94302423f095eec341de", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -30,9 +30,7 @@\n \n use super::FnCtxt;\n \n-use crate::hir::def_id::DefId;\n use crate::type_error_struct;\n-use hir::def_id::LOCAL_CRATE;\n use rustc_errors::{struct_span_err, Applicability, DelayDm, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_middle::mir::Mutability;\n@@ -43,6 +41,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable, VariantDef};\n use rustc_session::lint;\n use rustc_session::Session;\n+use rustc_span::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -527,7 +526,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 err.emit();\n             }\n             CastError::SizedUnsizedCast => {\n-                use crate::structured_errors::{SizedUnsizedCast, StructuredDiagnostic};\n+                use rustc_hir_analysis::structured_errors::{\n+                    SizedUnsizedCast, StructuredDiagnostic,\n+                };\n \n                 SizedUnsizedCast {\n                     sess: &fcx.tcx.sess,", "previous_filename": "compiler/rustc_hir_analysis/src/check/cast.rs"}, {"sha": "7f76364e15a75e2ecc8ae38c64c2c3e336dcfaa2", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -0,0 +1,324 @@\n+use crate::coercion::CoerceMany;\n+use crate::gather_locals::GatherLocalsVisitor;\n+use crate::{FnCtxt, Inherited};\n+use crate::{GeneratorTypes, UnsafetyState};\n+use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{ImplicitSelfKind, ItemKind, Node};\n+use rustc_hir_analysis::check::fn_maybe_err;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::RegionVariableOrigin;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::def_id::LocalDefId;\n+use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits;\n+use std::cell::RefCell;\n+\n+/// Helper used for fns and closures. Does the grungy work of checking a function\n+/// body and returns the function context used for that purpose, since in the case of a fn item\n+/// there is still a bit more to do.\n+///\n+/// * ...\n+/// * inherited: other fields inherited from the enclosing fn (if any)\n+#[instrument(skip(inherited, body), level = \"debug\")]\n+pub(super) fn check_fn<'a, 'tcx>(\n+    inherited: &'a Inherited<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    fn_id: hir::HirId,\n+    body: &'tcx hir::Body<'tcx>,\n+    can_be_generator: Option<hir::Movability>,\n+    return_type_pre_known: bool,\n+) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n+    // Create the function context. This is either derived from scratch or,\n+    // in the case of closures, based on the outer context.\n+    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n+    fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n+    fcx.return_type_pre_known = return_type_pre_known;\n+\n+    let tcx = fcx.tcx;\n+    let hir = tcx.hir();\n+\n+    let declared_ret_ty = fn_sig.output();\n+\n+    let ret_ty =\n+        fcx.register_infer_ok_obligations(fcx.infcx.replace_opaque_types_with_inference_vars(\n+            declared_ret_ty,\n+            body.value.hir_id,\n+            decl.output.span(),\n+            param_env,\n+        ));\n+    // If we replaced declared_ret_ty with infer vars, then we must be inferring\n+    // an opaque type, so set a flag so we can improve diagnostics.\n+    fcx.return_type_has_opaque = ret_ty != declared_ret_ty;\n+\n+    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n+\n+    let span = body.value.span;\n+\n+    fn_maybe_err(tcx, span, fn_sig.abi);\n+\n+    if fn_sig.abi == Abi::RustCall {\n+        let expected_args = if let ImplicitSelfKind::None = decl.implicit_self { 1 } else { 2 };\n+\n+        let err = || {\n+            let item = match tcx.hir().get(fn_id) {\n+                Node::Item(hir::Item { kind: ItemKind::Fn(header, ..), .. }) => Some(header),\n+                Node::ImplItem(hir::ImplItem {\n+                    kind: hir::ImplItemKind::Fn(header, ..), ..\n+                }) => Some(header),\n+                Node::TraitItem(hir::TraitItem {\n+                    kind: hir::TraitItemKind::Fn(header, ..),\n+                    ..\n+                }) => Some(header),\n+                // Closures are RustCall, but they tuple their arguments, so shouldn't be checked\n+                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => None,\n+                node => bug!(\"Item being checked wasn't a function/closure: {:?}\", node),\n+            };\n+\n+            if let Some(header) = item {\n+                tcx.sess.span_err(header.span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n+            }\n+        };\n+\n+        if fn_sig.inputs().len() != expected_args {\n+            err()\n+        } else {\n+            // FIXME(CraftSpider) Add a check on parameter expansion, so we don't just make the ICE happen later on\n+            //   This will probably require wide-scale changes to support a TupleKind obligation\n+            //   We can't resolve this without knowing the type of the param\n+            if !matches!(fn_sig.inputs()[expected_args - 1].kind(), ty::Tuple(_) | ty::Param(_)) {\n+                err()\n+            }\n+        }\n+    }\n+\n+    if body.generator_kind.is_some() && can_be_generator.is_some() {\n+        let yield_ty = fcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n+        fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n+\n+        // Resume type defaults to `()` if the generator has no argument.\n+        let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());\n+\n+        fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n+    }\n+\n+    GatherLocalsVisitor::new(&fcx).visit_body(body);\n+\n+    // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n+    // (as it's created inside the body itself, not passed in from outside).\n+    let maybe_va_list = if fn_sig.c_variadic {\n+        let span = body.params.last().unwrap().span;\n+        let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(span));\n+        let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n+\n+        Some(tcx.bound_type_of(va_list_did).subst(tcx, &[region.into()]))\n+    } else {\n+        None\n+    };\n+\n+    // Add formal parameters.\n+    let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n+    let inputs_fn = fn_sig.inputs().iter().copied();\n+    for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n+        // Check the pattern.\n+        let ty_span = try { inputs_hir?.get(idx)?.span };\n+        fcx.check_pat_top(&param.pat, param_ty, ty_span, false);\n+\n+        // Check that argument is Sized.\n+        // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n+        // for simple cases like `fn foo(x: Trait)`,\n+        // where we would error once on the parameter as a whole, and once on the binding `x`.\n+        if param.pat.simple_ident().is_none() && !tcx.features().unsized_fn_params {\n+            fcx.require_type_is_sized(param_ty, param.pat.span, traits::SizedArgumentType(ty_span));\n+        }\n+\n+        fcx.write_ty(param.hir_id, param_ty);\n+    }\n+\n+    inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n+\n+    fcx.in_tail_expr = true;\n+    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n+        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n+        // been evaluated so that we have types available for all the nodes being returned, but that\n+        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n+        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n+        // while keeping the current ordering we will ignore the tail expression's type because we\n+        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n+        // because we will trigger \"unreachable expression\" lints unconditionally.\n+        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n+        // case that a newcomer might make, returning a bare trait, and in that case we populate\n+        // the tail expression's type so that the suggestion will be correct, but ignore all other\n+        // possible cases.\n+        fcx.check_expr(&body.value);\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+    } else {\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+        fcx.check_return_expr(&body.value, false);\n+    }\n+    fcx.in_tail_expr = false;\n+\n+    // We insert the deferred_generator_interiors entry after visiting the body.\n+    // This ensures that all nested generators appear before the entry of this generator.\n+    // resolve_generator_interiors relies on this property.\n+    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n+        let interior = fcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n+\n+        let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n+        Some(GeneratorTypes {\n+            resume_ty,\n+            yield_ty,\n+            interior,\n+            movability: can_be_generator.unwrap(),\n+        })\n+    } else {\n+        None\n+    };\n+\n+    // Finalize the return check by taking the LUB of the return types\n+    // we saw and assigning it to the expected return type. This isn't\n+    // really expected to fail, since the coercions would have failed\n+    // earlier when trying to find a LUB.\n+    let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n+    let mut actual_return_ty = coercion.complete(&fcx);\n+    debug!(\"actual_return_ty = {:?}\", actual_return_ty);\n+    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n+        // We have special-cased the case where the function is declared\n+        // `-> dyn Foo` and we don't actually relate it to the\n+        // `fcx.ret_coercion`, so just substitute a type variable.\n+        actual_return_ty =\n+            fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n+        debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n+    }\n+\n+    // HACK(oli-obk, compiler-errors): We should be comparing this against\n+    // `declared_ret_ty`, but then anything uninferred would be inferred to\n+    // the opaque type itself. That again would cause writeback to assume\n+    // we have a recursive call site and do the sadly stabilized fallback to `()`.\n+    fcx.demand_suptype(span, ret_ty, actual_return_ty);\n+\n+    // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n+    if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n+        && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n+    {\n+        check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n+    }\n+\n+    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n+    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n+        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n+    {\n+        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n+    }\n+\n+    (fcx, gen_ty)\n+}\n+\n+fn check_panic_info_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(panic_info_did) = tcx.lang_items().panic_info() else {\n+        tcx.sess.err(\"language item required, but not found: `panic_info`\");\n+        return;\n+    };\n+\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_panic_info = match *inputs[0].kind() {\n+        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n+            ty::Adt(ref adt, _) => {\n+                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n+            }\n+            _ => false,\n+        },\n+        _ => false,\n+    };\n+\n+    if !arg_is_panic_info {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n+    }\n+\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no const parameters\");\n+    }\n+}\n+\n+fn check_alloc_error_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n+        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n+        return;\n+    };\n+\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_alloc_layout = match inputs[0].kind() {\n+        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n+        _ => false,\n+    };\n+\n+    if !arg_is_alloc_layout {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+    }\n+\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess\n+            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n+    }\n+}"}, {"sha": "de5b4a5021892f3cb9591a9b5fdb05cd60036b1e", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -2,11 +2,11 @@\n \n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n-use crate::astconv::AstConv;\n use hir::def::DefKind;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n+use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};", "previous_filename": "compiler/rustc_hir_analysis/src/check/closure.rs"}, {"sha": "86597a703e833810dafaa5f4a25062d7bbd67a6a", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -35,15 +35,15 @@\n //! // and are then unable to coerce `&7i32` to `&mut i32`.\n //! ```\n \n-use crate::astconv::AstConv;\n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Expr;\n+use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n use rustc_infer::traits::{Obligation, TraitEngine, TraitEngineExt};", "previous_filename": "compiler/rustc_hir_analysis/src/check/coercion.rs"}, {"sha": "2974ac97f2368fc4dea7598c758061c3a438a2b6", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,21 +1,20 @@\n-use crate::check::FnCtxt;\n-use rustc_infer::infer::InferOk;\n-use rustc_middle::middle::stability::EvalResult;\n-use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::ObligationCause;\n-\n+use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n ", "previous_filename": "compiler/rustc_hir_analysis/src/check/demand.rs"}, {"sha": "963a93a95c2bbc386dd026010593d883e6d621f9", "filename": "compiler/rustc_hir_typeck/src/diverges.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fdiverges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fdiverges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdiverges.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/diverges.rs"}, {"sha": "2f8898d5ea9a8d496feabf4931eb4c23619c1327", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -0,0 +1,127 @@\n+//! Errors emitted by `rustc_hir_analysis`.\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_middle::ty::Ty;\n+use rustc_span::{symbol::Ident, Span};\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis::field_multiply_specified_in_initializer, code = \"E0062\")]\n+pub struct FieldMultiplySpecifiedInInitializer {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(hir_analysis::previous_use_label)]\n+    pub prev_span: Span,\n+    pub ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis::return_stmt_outside_of_fn_body, code = \"E0572\")]\n+pub struct ReturnStmtOutsideOfFnBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(hir_analysis::encl_body_label)]\n+    pub encl_body_span: Option<Span>,\n+    #[label(hir_analysis::encl_fn_label)]\n+    pub encl_fn_span: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis::yield_expr_outside_of_generator, code = \"E0627\")]\n+pub struct YieldExprOutsideOfGenerator {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis::struct_expr_non_exhaustive, code = \"E0639\")]\n+pub struct StructExprNonExhaustive {\n+    #[primary_span]\n+    pub span: Span,\n+    pub what: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis::method_call_on_unknown_type, code = \"E0699\")]\n+pub struct MethodCallOnUnknownType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis::functional_record_update_on_non_struct, code = \"E0436\")]\n+pub struct FunctionalRecordUpdateOnNonStruct {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis::address_of_temporary_taken, code = \"E0745\")]\n+pub struct AddressOfTemporaryTaken {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum AddReturnTypeSuggestion {\n+    #[suggestion(\n+        hir_analysis::add_return_type_add,\n+        code = \"-> {found} \",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Add {\n+        #[primary_span]\n+        span: Span,\n+        found: String,\n+    },\n+    #[suggestion(\n+        hir_analysis::add_return_type_missing_here,\n+        code = \"-> _ \",\n+        applicability = \"has-placeholders\"\n+    )]\n+    MissingHere {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ExpectedReturnTypeLabel<'tcx> {\n+    #[label(hir_analysis::expected_default_return_type)]\n+    Unit {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(hir_analysis::expected_return_type)]\n+    Other {\n+        #[primary_span]\n+        span: Span,\n+        expected: Ty<'tcx>,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis::missing_parentheses_in_range, code = \"E0689\")]\n+pub struct MissingParentheseInRange {\n+    #[primary_span]\n+    #[label(hir_analysis::missing_parentheses_in_range)]\n+    pub span: Span,\n+    pub ty_str: String,\n+    pub method_name: String,\n+\n+    #[subdiagnostic]\n+    pub add_missing_parentheses: Option<AddMissingParenthesesInRange>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion_verbose(\n+    hir_analysis::add_missing_parentheses_in_range,\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct AddMissingParenthesesInRange {\n+    pub func_name: String,\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}"}, {"sha": "e9e810344776b963d52a0eeb85fbd6ecbcc8c376", "filename": "compiler/rustc_hir_typeck/src/expectation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/expectation.rs"}, {"sha": "41b00fda03ebfffc399ed750cc54b1399e3e1d2f", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "renamed", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -2,23 +2,22 @@\n //!\n //! See `mod.rs` for more context on type checking in general.\n \n-use crate::astconv::AstConv as _;\n-use crate::check::cast;\n-use crate::check::coercion::CoerceMany;\n-use crate::check::fatally_break_rust;\n-use crate::check::method::SelfSource;\n-use crate::check::Expectation::{self, ExpectCastableToType, ExpectHasType, NoExpectation};\n-use crate::check::{\n-    report_unexpected_variant_res, BreakableCtxt, Diverges, DynamicCoerceMany, FnCtxt, Needs,\n-    TupleArgumentsFlag::DontTupleArguments,\n-};\n+use crate::cast;\n+use crate::coercion::CoerceMany;\n+use crate::coercion::DynamicCoerceMany;\n+use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use crate::errors::{\n     FieldMultiplySpecifiedInInitializer, FunctionalRecordUpdateOnNonStruct,\n     YieldExprOutsideOfGenerator,\n };\n+use crate::fatally_break_rust;\n+use crate::method::SelfSource;\n use crate::type_error_struct;\n-\n-use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n+use crate::Expectation::{self, ExpectCastableToType, ExpectHasType, NoExpectation};\n+use crate::{\n+    report_unexpected_variant_res, BreakableCtxt, Diverges, FnCtxt, Needs,\n+    TupleArgumentsFlag::DontTupleArguments,\n+};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -32,6 +31,8 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Closure, ExprKind, HirId, QPath};\n+use rustc_hir_analysis::astconv::AstConv as _;\n+use rustc_hir_analysis::check::ty_kind_suggestion;\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n@@ -1362,7 +1363,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Create a new function context.\n         let fcx = FnCtxt::new(self, self.param_env.with_const(), body.value.hir_id);\n-        crate::check::GatherLocalsVisitor::new(&fcx).visit_body(body);\n+        crate::GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n         let ty = fcx.check_expr_with_expectation(&body.value, expected);\n         fcx.require_type_is_sized(ty, body.value.span, traits::ConstSized);\n@@ -2885,14 +2886,3 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n-\n-pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n-    Some(match ty.kind() {\n-        ty::Bool => \"true\",\n-        ty::Char => \"'a'\",\n-        ty::Int(_) | ty::Uint(_) => \"42\",\n-        ty::Float(_) => \"3.14159\",\n-        ty::Error(_) | ty::Never => return None,\n-        _ => \"value\",\n-    })\n-}", "previous_filename": "compiler/rustc_hir_analysis/src/check/expr.rs"}, {"sha": "fce2a5888ba24fe8fd710764b64ab644d130c58f", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "renamed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -89,15 +89,6 @@ enum ConsumeMode {\n     Move,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum MutateMode {\n-    Init,\n-    /// Example: `x = y`\n-    JustWrite,\n-    /// Example: `x += y`\n-    WriteAndRead,\n-}\n-\n /// The ExprUseVisitor type\n ///\n /// This is the code that actually walks the tree.", "previous_filename": "compiler/rustc_hir_analysis/src/expr_use_visitor.rs"}, {"sha": "747ecb036b2a15c7e3bb5183d03850eb6f3fa5a6", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,4 +1,4 @@\n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use rustc_data_structures::{\n     fx::{FxHashMap, FxHashSet},\n     graph::WithSuccessors,", "previous_filename": "compiler/rustc_hir_analysis/src/check/fallback.rs"}, {"sha": "6a1cffe3e6025186e8f4985a53ab29e49874a1bf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "renamed", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,12 +1,7 @@\n-use crate::astconv::{\n-    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n-    GenericArgCountResult, IsMethodCall, PathSeg,\n-};\n-use crate::check::callee::{self, DeferredCallResolution};\n-use crate::check::method::{self, MethodCallee, SelfSource};\n-use crate::check::rvalue_scopes;\n-use crate::check::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n-\n+use crate::callee::{self, DeferredCallResolution};\n+use crate::method::{self, MethodCallee, SelfSource};\n+use crate::rvalue_scopes;\n+use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n@@ -15,6 +10,10 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n+use rustc_hir_analysis::astconv::{\n+    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    GenericArgCountResult, IsMethodCall, PathSeg,\n+};\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::{InferOk, InferResult};\n@@ -603,9 +602,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior, kind) in generators.drain(..) {\n             self.select_obligations_where_possible(false, |_| {});\n-            crate::check::generator_interior::resolve_interior(\n-                self, def_id, body_id, interior, kind,\n-            );\n+            crate::generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n         }\n     }\n ", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/_impl.rs"}, {"sha": "fc83994caf53966aff1ba74745ca44856349f233", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/arg_matrix.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/arg_matrix.rs"}, {"sha": "08a3cbccfb05e6e25b80dbf18c2177c3f8b5d4a1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,26 +1,24 @@\n-use crate::astconv::AstConv;\n-use crate::check::coercion::CoerceMany;\n-use crate::check::fn_ctxt::arg_matrix::{\n-    ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx,\n+use crate::coercion::CoerceMany;\n+use crate::fn_ctxt::arg_matrix::{ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx};\n+use crate::gather_locals::Declaration;\n+use crate::method::MethodCallee;\n+use crate::Expectation::*;\n+use crate::TupleArgumentsFlag::*;\n+use crate::{\n+    struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs,\n+    TupleArgumentsFlag,\n };\n-use crate::check::gather_locals::Declaration;\n-use crate::check::intrinsicck::InlineAsmCtxt;\n-use crate::check::method::MethodCallee;\n-use crate::check::Expectation::*;\n-use crate::check::TupleArgumentsFlag::*;\n-use crate::check::{\n-    potentially_plural_count, struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt,\n-    LocalTy, Needs, TupleArgumentsFlag,\n-};\n-use crate::structured_errors::StructuredDiagnostic;\n-\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, Applicability, Diagnostic, DiagnosticId, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, Node, QPath};\n+use rustc_hir_analysis::astconv::AstConv;\n+use rustc_hir_analysis::check::intrinsicck::InlineAsmCtxt;\n+use rustc_hir_analysis::check::potentially_plural_count;\n+use rustc_hir_analysis::structured_errors::StructuredDiagnostic;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -391,7 +389,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ty: Ty<'tcx>,\n                     cast_ty: &str,\n                 ) {\n-                    use crate::structured_errors::MissingCastForVariadicArg;\n+                    use rustc_hir_analysis::structured_errors::MissingCastForVariadicArg;\n \n                     MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit();\n                 }", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/checks.rs"}, {"sha": "0c600daf4459e8e6886f6042f927eb4b2e78a549", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -6,12 +6,11 @@ mod suggestions;\n pub use _impl::*;\n pub use suggestions::*;\n \n-use crate::astconv::AstConv;\n-use crate::check::coercion::DynamicCoerceMany;\n-use crate::check::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n-\n+use crate::coercion::DynamicCoerceMany;\n+use crate::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer;\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -36,7 +35,7 @@ use std::ops::Deref;\n ///\n /// See [`ItemCtxt`]'s docs for more.\n ///\n-/// [`ItemCtxt`]: crate::collect::ItemCtxt\n+/// [`ItemCtxt`]: rustc_hir_analysis::collect::ItemCtxt\n /// [`InferCtxt`]: infer::InferCtxt\n pub struct FnCtxt<'a, 'tcx> {\n     pub(super) body_id: hir::HirId,", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/mod.rs"}, {"sha": "cd2e41aff0f124818e211e9d8a70f0fd214ca0e0", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,7 +1,6 @@\n use super::FnCtxt;\n-use crate::astconv::AstConv;\n-use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n+use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n@@ -10,6 +9,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n };\n+use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs"}, {"sha": "9a096f24fac0d965d39546ceaf52e4e529e33f27", "filename": "compiler/rustc_hir_typeck/src/gather_locals.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,9 +1,10 @@\n-use crate::check::{FnCtxt, LocalTy, UserType};\n+use crate::{FnCtxt, LocalTy};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::PatKind;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::Ty;\n+use rustc_middle::ty::UserType;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n ", "previous_filename": "compiler/rustc_hir_analysis/src/check/gather_locals.rs"}, {"sha": "122ad7009cb497181c76386740de783fb4ad0001", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_build.rs"}, {"sha": "139d17d2e1ca186d72705afb98d310597a1c09f5", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_propagate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_propagate.rs"}, {"sha": "c0a0bfe8e1c00a98cb53dd41b5d1e6e9bb7ba82c", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_visualize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_visualize.rs"}, {"sha": "4f3bdfbe758d90936d807041631fb66aea37422f", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -14,7 +14,7 @@\n \n use self::cfg_build::build_control_flow_graph;\n use self::record_consumed_borrow::find_consumed_and_borrowed;\n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use hir::def_id::DefId;\n use hir::{Body, HirId, HirIdMap, Node};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges.rs"}, {"sha": "7954ddc4166ca2dcd1352cc012bba4bc3e45e108", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,7 +1,7 @@\n use super::TrackedValue;\n use crate::{\n-    check::FnCtxt,\n     expr_use_visitor::{self, ExprUseVisitor},\n+    FnCtxt,\n };\n use hir::{def_id::DefId, Body, HirId, HirIdMap};\n use rustc_data_structures::fx::FxHashSet;", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs"}, {"sha": "898419b5b237450ec2b62f9bc95001bbf6dbfaeb", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior.rs"}, {"sha": "0fb7651b3a1e1decbabc188f605e718ed56367c8", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/inherited.rs"}, {"sha": "9812d96fcc3c7eec6f125fb68ad6080d7486ce36", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -0,0 +1,108 @@\n+use hir::HirId;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_index::vec::Idx;\n+use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_target::abi::{Pointer, VariantIdx};\n+\n+use super::FnCtxt;\n+\n+/// If the type is `Option<T>`, it will return `T`, otherwise\n+/// the type itself. Works on most `Option`-like types.\n+fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    let ty::Adt(def, substs) = *ty.kind() else { return ty };\n+\n+    if def.variants().len() == 2 && !def.repr().c() && def.repr().int.is_none() {\n+        let data_idx;\n+\n+        let one = VariantIdx::new(1);\n+        let zero = VariantIdx::new(0);\n+\n+        if def.variant(zero).fields.is_empty() {\n+            data_idx = one;\n+        } else if def.variant(one).fields.is_empty() {\n+            data_idx = zero;\n+        } else {\n+            return ty;\n+        }\n+\n+        if def.variant(data_idx).fields.len() == 1 {\n+            return def.variant(data_idx).fields[0].ty(tcx, substs);\n+        }\n+    }\n+\n+    ty\n+}\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn check_transmute(&self, from: Ty<'tcx>, to: Ty<'tcx>, hir_id: HirId) {\n+        let tcx = self.tcx;\n+        let span = tcx.hir().span(hir_id);\n+        let normalize = |ty| {\n+            let ty = self.resolve_vars_if_possible(ty);\n+            self.tcx.normalize_erasing_regions(self.param_env, ty)\n+        };\n+        let from = normalize(from);\n+        let to = normalize(to);\n+        trace!(?from, ?to);\n+\n+        // Transmutes that are only changing lifetimes are always ok.\n+        if from == to {\n+            return;\n+        }\n+\n+        let skel = |ty| SizeSkeleton::compute(ty, tcx, self.param_env);\n+        let sk_from = skel(from);\n+        let sk_to = skel(to);\n+        trace!(?sk_from, ?sk_to);\n+\n+        // Check for same size using the skeletons.\n+        if let (Ok(sk_from), Ok(sk_to)) = (sk_from, sk_to) {\n+            if sk_from.same_size(sk_to) {\n+                return;\n+            }\n+\n+            // Special-case transmuting from `typeof(function)` and\n+            // `Option<typeof(function)>` to present a clearer error.\n+            let from = unpack_option_like(tcx, from);\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer.size(&tcx) {\n+                struct_span_err!(tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n+                    .note(&format!(\"source type: {from}\"))\n+                    .note(&format!(\"target type: {to}\"))\n+                    .help(\"cast with `as` to a pointer instead\")\n+                    .emit();\n+                return;\n+            }\n+        }\n+\n+        // Try to display a sensible error with as much information as possible.\n+        let skeleton_string = |ty: Ty<'tcx>, sk| match sk {\n+            Ok(SizeSkeleton::Known(size)) => format!(\"{} bits\", size.bits()),\n+            Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{tail}`\"),\n+            Err(LayoutError::Unknown(bad)) => {\n+                if bad == ty {\n+                    \"this type does not have a fixed size\".to_owned()\n+                } else {\n+                    format!(\"size can vary because of {bad}\")\n+                }\n+            }\n+            Err(err) => err.to_string(),\n+        };\n+\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0512,\n+            \"cannot transmute between types of different sizes, \\\n+                                        or dependently-sized types\"\n+        );\n+        if from == to {\n+            err.note(&format!(\"`{from}` does not have a fixed size\"));\n+        } else {\n+            err.note(&format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n+                .note(&format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n+        }\n+        err.emit();\n+    }\n+}"}, {"sha": "e862d577573b44808dbb5b4cf977d021d1386391", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -0,0 +1,507 @@\n+#![feature(if_let_guard)]\n+#![feature(let_chains)]\n+#![feature(try_blocks)]\n+#![feature(never_type)]\n+#![feature(min_specialization)]\n+#![feature(control_flow_enum)]\n+#![feature(drain_filter)]\n+#![allow(rustc::potential_query_instability)]\n+#![recursion_limit = \"256\"]\n+\n+#[macro_use]\n+extern crate tracing;\n+\n+#[macro_use]\n+extern crate rustc_middle;\n+\n+mod _match;\n+mod autoderef;\n+mod callee;\n+// Used by clippy;\n+pub mod cast;\n+mod check;\n+mod closure;\n+mod coercion;\n+mod demand;\n+mod diverges;\n+mod errors;\n+mod expectation;\n+mod expr;\n+// Used by clippy;\n+pub mod expr_use_visitor;\n+mod fallback;\n+mod fn_ctxt;\n+mod gather_locals;\n+mod generator_interior;\n+mod inherited;\n+mod intrinsicck;\n+mod mem_categorization;\n+mod method;\n+mod op;\n+mod pat;\n+mod place_op;\n+mod rvalue_scopes;\n+mod upvar;\n+mod writeback;\n+\n+pub use diverges::Diverges;\n+pub use expectation::Expectation;\n+pub use fn_ctxt::*;\n+pub use inherited::{Inherited, InheritedBuilder};\n+\n+use crate::check::check_fn;\n+use crate::coercion::DynamicCoerceMany;\n+use crate::gather_locals::GatherLocalsVisitor;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::{struct_span_err, MultiSpan};\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{HirIdMap, Node};\n+use rustc_hir_analysis::astconv::AstConv;\n+use rustc_hir_analysis::check::check_abi;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_middle::traits;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::config;\n+use rustc_session::Session;\n+use rustc_span::def_id::{DefId, LocalDefId};\n+use rustc_span::Span;\n+\n+#[macro_export]\n+macro_rules! type_error_struct {\n+    ($session:expr, $span:expr, $typ:expr, $code:ident, $($message:tt)*) => ({\n+        let mut err = rustc_errors::struct_span_err!($session, $span, $code, $($message)*);\n+\n+        if $typ.references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n+\n+        err\n+    })\n+}\n+\n+/// The type of a local binding, including the revealed type for anon types.\n+#[derive(Copy, Clone, Debug)]\n+pub struct LocalTy<'tcx> {\n+    decl_ty: Ty<'tcx>,\n+    revealed_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnsafetyState {\n+    pub def: hir::HirId,\n+    pub unsafety: hir::Unsafety,\n+    from_fn: bool,\n+}\n+\n+impl UnsafetyState {\n+    pub fn function(unsafety: hir::Unsafety, def: hir::HirId) -> UnsafetyState {\n+        UnsafetyState { def, unsafety, from_fn: true }\n+    }\n+\n+    pub fn recurse(self, blk: &hir::Block<'_>) -> UnsafetyState {\n+        use hir::BlockCheckMode;\n+        match self.unsafety {\n+            // If this unsafe, then if the outer function was already marked as\n+            // unsafe we shouldn't attribute the unsafe'ness to the block. This\n+            // way the block can be warned about instead of ignoring this\n+            // extraneous block (functions are never warned about).\n+            hir::Unsafety::Unsafe if self.from_fn => self,\n+\n+            unsafety => {\n+                let (unsafety, def) = match blk.rules {\n+                    BlockCheckMode::UnsafeBlock(..) => (hir::Unsafety::Unsafe, blk.hir_id),\n+                    BlockCheckMode::DefaultBlock => (unsafety, self.def),\n+                };\n+                UnsafetyState { def, unsafety, from_fn: false }\n+            }\n+        }\n+    }\n+}\n+\n+/// If this `DefId` is a \"primary tables entry\", returns\n+/// `Some((body_id, body_ty, fn_sig))`. Otherwise, returns `None`.\n+///\n+/// If this function returns `Some`, then `typeck_results(def_id)` will\n+/// succeed; if it returns `None`, then `typeck_results(def_id)` may or\n+/// may not succeed. In some cases where this function returns `None`\n+/// (notably closures), `typeck_results(def_id)` would wind up\n+/// redirecting to the owning function.\n+fn primary_body_of(\n+    tcx: TyCtxt<'_>,\n+    id: hir::HirId,\n+) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n+    match tcx.hir().get(id) {\n+        Node::Item(item) => match item.kind {\n+            hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n+                Some((body, Some(ty), None))\n+            }\n+            hir::ItemKind::Fn(ref sig, .., body) => Some((body, None, Some(sig))),\n+            _ => None,\n+        },\n+        Node::TraitItem(item) => match item.kind {\n+            hir::TraitItemKind::Const(ty, Some(body)) => Some((body, Some(ty), None)),\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n+                Some((body, None, Some(sig)))\n+            }\n+            _ => None,\n+        },\n+        Node::ImplItem(item) => match item.kind {\n+            hir::ImplItemKind::Const(ty, body) => Some((body, Some(ty), None)),\n+            hir::ImplItemKind::Fn(ref sig, body) => Some((body, None, Some(sig))),\n+            _ => None,\n+        },\n+        Node::AnonConst(constant) => Some((constant.body, None, None)),\n+        _ => None,\n+    }\n+}\n+\n+fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    // Closures' typeck results come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n+    if typeck_root_def_id != def_id {\n+        return tcx.has_typeck_results(typeck_root_def_id);\n+    }\n+\n+    if let Some(def_id) = def_id.as_local() {\n+        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        primary_body_of(tcx, id).is_some()\n+    } else {\n+        false\n+    }\n+}\n+\n+fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDefId> {\n+    &*tcx.typeck(def_id).used_trait_imports\n+}\n+\n+fn typeck_item_bodies(tcx: TyCtxt<'_>, (): ()) {\n+    tcx.hir().par_body_owners(|body_owner_def_id| tcx.ensure().typeck(body_owner_def_id));\n+}\n+\n+fn typeck_const_arg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (did, param_did): (LocalDefId, DefId),\n+) -> &ty::TypeckResults<'tcx> {\n+    let fallback = move || tcx.type_of(param_did);\n+    typeck_with_fallback(tcx, did, fallback)\n+}\n+\n+fn typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n+    if let Some(param_did) = tcx.opt_const_param_of(def_id) {\n+        tcx.typeck_const_arg((def_id, param_did))\n+    } else {\n+        let fallback = move || tcx.type_of(def_id.to_def_id());\n+        typeck_with_fallback(tcx, def_id, fallback)\n+    }\n+}\n+\n+/// Used only to get `TypeckResults` for type inference during error recovery.\n+/// Currently only used for type inference of `static`s and `const`s to avoid type cycle errors.\n+fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n+    let fallback = move || {\n+        let span = tcx.hir().span(tcx.hir().local_def_id_to_hir_id(def_id));\n+        tcx.ty_error_with_message(span, \"diagnostic only typeck table used\")\n+    };\n+    typeck_with_fallback(tcx, def_id, fallback)\n+}\n+\n+fn typeck_with_fallback<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    fallback: impl Fn() -> Ty<'tcx> + 'tcx,\n+) -> &'tcx ty::TypeckResults<'tcx> {\n+    // Closures' typeck results come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id()).expect_local();\n+    if typeck_root_def_id != def_id {\n+        return tcx.typeck(typeck_root_def_id);\n+    }\n+\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let span = tcx.hir().span(id);\n+\n+    // Figure out what primary body this item has.\n+    let (body_id, body_ty, fn_sig) = primary_body_of(tcx, id).unwrap_or_else(|| {\n+        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n+    });\n+    let body = tcx.hir().body(body_id);\n+\n+    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n+        let param_env = tcx.param_env(def_id);\n+        let mut fcx = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+            let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n+                let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n+                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n+            } else {\n+                tcx.fn_sig(def_id)\n+            };\n+\n+            check_abi(tcx, id, span, fn_sig.abi());\n+\n+            // Compute the function signature from point of view of inside the fn.\n+            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n+            let fn_sig = inh.normalize_associated_types_in(\n+                body.value.span,\n+                body_id.hir_id,\n+                param_env,\n+                fn_sig,\n+            );\n+            check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0\n+        } else {\n+            let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n+            let expected_type = body_ty\n+                .and_then(|ty| match ty.kind {\n+                    hir::TyKind::Infer => Some(<dyn AstConv<'_>>::ast_ty_to_ty(&fcx, ty)),\n+                    _ => None,\n+                })\n+                .unwrap_or_else(|| match tcx.hir().get(id) {\n+                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().get_parent_node(id)) {\n+                        Node::Expr(&hir::Expr {\n+                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n+                            ..\n+                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span,\n+                        }),\n+                        Node::Ty(&hir::Ty {\n+                            kind: hir::TyKind::Typeof(ref anon_const), ..\n+                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span,\n+                        }),\n+                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n+                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n+                            let operand_ty = asm\n+                                .operands\n+                                .iter()\n+                                .filter_map(|(op, _op_sp)| match op {\n+                                    hir::InlineAsmOperand::Const { anon_const }\n+                                        if anon_const.hir_id == id =>\n+                                    {\n+                                        // Inline assembly constants must be integers.\n+                                        Some(fcx.next_int_var())\n+                                    }\n+                                    hir::InlineAsmOperand::SymFn { anon_const }\n+                                        if anon_const.hir_id == id =>\n+                                    {\n+                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n+                                            kind: TypeVariableOriginKind::MiscVariable,\n+                                            span,\n+                                        }))\n+                                    }\n+                                    _ => None,\n+                                })\n+                                .next();\n+                            operand_ty.unwrap_or_else(fallback)\n+                        }\n+                        _ => fallback(),\n+                    },\n+                    _ => fallback(),\n+                });\n+\n+            let expected_type = fcx.normalize_associated_types_in(body.value.span, expected_type);\n+            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n+\n+            // Gather locals in statics (because of block expressions).\n+            GatherLocalsVisitor::new(&fcx).visit_body(body);\n+\n+            fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n+\n+            fcx.write_ty(id, expected_type);\n+\n+            fcx\n+        };\n+\n+        let fallback_has_occurred = fcx.type_inference_fallback();\n+\n+        // Even though coercion casts provide type hints, we check casts after fallback for\n+        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n+        fcx.check_casts();\n+        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+\n+        // Closure and generator analysis may run after fallback\n+        // because they don't constrain other type variables.\n+        // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n+        let prev_constness = fcx.param_env.constness();\n+        fcx.param_env = fcx.param_env.without_const();\n+        fcx.closure_analyze(body);\n+        fcx.param_env = fcx.param_env.with_constness(prev_constness);\n+        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n+        // Before the generator analysis, temporary scopes shall be marked to provide more\n+        // precise information on types to be captured.\n+        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n+        fcx.resolve_generator_interiors(def_id.to_def_id());\n+\n+        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n+            let ty = fcx.normalize_ty(span, ty);\n+            fcx.require_type_is_sized(ty, span, code);\n+        }\n+\n+        fcx.select_all_obligations_or_error();\n+\n+        if !fcx.infcx.is_tainted_by_errors() {\n+            fcx.check_transmutes();\n+        }\n+\n+        fcx.check_asms();\n+\n+        fcx.infcx.skip_region_resolution();\n+\n+        fcx.resolve_type_vars_in_body(body)\n+    });\n+\n+    // Consistency check our TypeckResults instance can hold all ItemLocalIds\n+    // it will need to hold.\n+    assert_eq!(typeck_results.hir_owner, id.owner);\n+\n+    typeck_results\n+}\n+\n+/// When `check_fn` is invoked on a generator (i.e., a body that\n+/// includes yield), it returns back some information about the yield\n+/// points.\n+struct GeneratorTypes<'tcx> {\n+    /// Type of generator argument / values returned by `yield`.\n+    resume_ty: Ty<'tcx>,\n+\n+    /// Type of value that is yielded.\n+    yield_ty: Ty<'tcx>,\n+\n+    /// Types that are captured (see `GeneratorInterior` for more).\n+    interior: Ty<'tcx>,\n+\n+    /// Indicates if the generator is movable or static (immovable).\n+    movability: hir::Movability,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Needs {\n+    MutPlace,\n+    None,\n+}\n+\n+impl Needs {\n+    fn maybe_mut_place(m: hir::Mutability) -> Self {\n+        match m {\n+            hir::Mutability::Mut => Needs::MutPlace,\n+            hir::Mutability::Not => Needs::None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum PlaceOp {\n+    Deref,\n+    Index,\n+}\n+\n+pub struct BreakableCtxt<'tcx> {\n+    may_break: bool,\n+\n+    // this is `null` for loops where break with a value is illegal,\n+    // such as `while`, `for`, and `while let`\n+    coerce: Option<DynamicCoerceMany<'tcx>>,\n+}\n+\n+pub struct EnclosingBreakables<'tcx> {\n+    stack: Vec<BreakableCtxt<'tcx>>,\n+    by_id: HirIdMap<usize>,\n+}\n+\n+impl<'tcx> EnclosingBreakables<'tcx> {\n+    fn find_breakable(&mut self, target_id: hir::HirId) -> &mut BreakableCtxt<'tcx> {\n+        self.opt_find_breakable(target_id).unwrap_or_else(|| {\n+            bug!(\"could not find enclosing breakable with id {}\", target_id);\n+        })\n+    }\n+\n+    fn opt_find_breakable(&mut self, target_id: hir::HirId) -> Option<&mut BreakableCtxt<'tcx>> {\n+        match self.by_id.get(&target_id) {\n+            Some(ix) => Some(&mut self.stack[*ix]),\n+            None => None,\n+        }\n+    }\n+}\n+\n+fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'_>, span: Span) {\n+    struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0533,\n+        \"expected unit struct, unit variant or constant, found {} `{}`\",\n+        res.descr(),\n+        rustc_hir_pretty::qpath_to_string(qpath),\n+    )\n+    .emit();\n+}\n+\n+/// Controls whether the arguments are tupled. This is used for the call\n+/// operator.\n+///\n+/// Tupling means that all call-side arguments are packed into a tuple and\n+/// passed as a single parameter. For example, if tupling is enabled, this\n+/// function:\n+/// ```\n+/// fn f(x: (isize, isize)) {}\n+/// ```\n+/// Can be called as:\n+/// ```ignore UNSOLVED (can this be done in user code?)\n+/// # fn f(x: (isize, isize)) {}\n+/// f(1, 2);\n+/// ```\n+/// Instead of:\n+/// ```\n+/// # fn f(x: (isize, isize)) {}\n+/// f((1, 2));\n+/// ```\n+#[derive(Clone, Eq, PartialEq)]\n+enum TupleArgumentsFlag {\n+    DontTupleArguments,\n+    TupleArguments,\n+}\n+\n+fn fatally_break_rust(sess: &Session) {\n+    let handler = sess.diagnostic();\n+    handler.span_bug_no_panic(\n+        MultiSpan::new(),\n+        \"It looks like you're trying to break rust; would you like some ICE?\",\n+    );\n+    handler.note_without_error(\"the compiler expectedly panicked. this is a feature.\");\n+    handler.note_without_error(\n+        \"we would appreciate a joke overview: \\\n+         https://github.com/rust-lang/rust/issues/43162#issuecomment-320764675\",\n+    );\n+    handler.note_without_error(&format!(\n+        \"rustc {} running on {}\",\n+        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n+        config::host_triple(),\n+    ));\n+}\n+\n+fn has_expected_num_generic_args<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_did: Option<DefId>,\n+    expected: usize,\n+) -> bool {\n+    trait_did.map_or(true, |trait_did| {\n+        let generics = tcx.generics_of(trait_did);\n+        generics.count() == expected + if generics.has_self { 1 } else { 0 }\n+    })\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    method::provide(providers);\n+    *providers = Providers {\n+        typeck_item_bodies,\n+        typeck_const_arg,\n+        typeck,\n+        diagnostic_only_typeck,\n+        has_typeck_results,\n+        used_trait_imports,\n+        ..*providers\n+    };\n+}"}, {"sha": "362f1c3430041a45e668c263b825e7f790a2fbc9", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/mem_categorization.rs"}, {"sha": "be4ea99862222699c51341f1650fe94b81842cb8", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,10 +1,10 @@\n use super::{probe, MethodCallee};\n \n-use crate::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n-use crate::check::{callee, FnCtxt};\n+use crate::{callee, FnCtxt};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n+use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/confirm.rs"}, {"sha": "a1278edefbb7140271e2959e53e6314b6c0a505a", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -10,14 +10,14 @@ mod suggest;\n pub use self::suggest::SelfSource;\n pub use self::MethodError::*;\n \n-use crate::check::{Expectation, FnCtxt};\n-use crate::ObligationCause;\n+use crate::{Expectation, FnCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TypeVisitable};\n use rustc_span::symbol::Ident;", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/mod.rs"}, {"sha": "3c98a2aa3aba3db996a539229510f453d51e1e03", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,3 +1,7 @@\n+use crate::{\n+    method::probe::{self, Pick},\n+    FnCtxt,\n+};\n use hir::def_id::DefId;\n use hir::HirId;\n use hir::ItemKind;\n@@ -12,11 +16,6 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n-use crate::check::{\n-    method::probe::{self, Pick},\n-    FnCtxt,\n-};\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(super) fn lint_dot_call_from_2018(\n         &self,", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/prelude2021.rs"}, {"sha": "74cf2ac32aab270e2f43a88cae14100dd8957eb4", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -3,14 +3,12 @@ use super::CandidateSource;\n use super::MethodError;\n use super::NoMatchData;\n \n-use crate::check::FnCtxt;\n use crate::errors::MethodCallOnUnknownType;\n-use crate::hir::def::DefKind;\n-use crate::hir::def_id::DefId;\n-\n+use crate::FnCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def::Namespace;\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n@@ -23,6 +21,7 @@ use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, ParamEnvAnd, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint;\n+use rustc_span::def_id::DefId;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::lev_distance::{\n     find_best_match_for_name_with_substrings, lev_distance_with_substrings,", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/probe.rs"}, {"sha": "f4351bfa84aed5a32f1788f4be4c891e31c7b2b2", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,8 +1,8 @@\n //! Give useful errors and suggestions to users when an item can't be\n //! found or is otherwise invalid.\n \n-use crate::check::FnCtxt;\n use crate::errors;\n+use crate::FnCtxt;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/suggest.rs"}, {"sha": "89573997693855ffff40d455944fb8018bf3ab67", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -2,7 +2,7 @@\n \n use super::method::MethodCallee;\n use super::{has_expected_num_generic_args, FnCtxt};\n-use crate::check::Expectation;\n+use crate::Expectation;\n use rustc_ast as ast;\n use rustc_errors::{self, struct_span_err, Applicability, Diagnostic};\n use rustc_hir as hir;", "previous_filename": "compiler/rustc_hir_analysis/src/check/op.rs"}, {"sha": "ea90da4a6dc351c559418c2c00558d1e48bec526", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,6 +1,5 @@\n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use rustc_ast as ast;\n-\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,", "previous_filename": "compiler/rustc_hir_analysis/src/check/pat.rs"}, {"sha": "ba8cf6926f30b19e1b3800043f7316a2fa6da176", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,5 +1,5 @@\n-use crate::check::method::MethodCallee;\n-use crate::check::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n+use crate::method::MethodCallee;\n+use crate::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;", "previous_filename": "compiler/rustc_hir_analysis/src/check/place_op.rs"}, {"sha": "22c9e7961070c6d14e6761bd16f230e408b8d3f1", "filename": "compiler/rustc_hir_typeck/src/rvalue_scopes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Frvalue_scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Frvalue_scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Frvalue_scopes.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/rvalue_scopes.rs"}, {"sha": "4dea40829f6221a2b4e4400789676b9bd5b8b4ce", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "previous_filename": "compiler/rustc_hir_analysis/src/check/upvar.rs"}, {"sha": "1e26daa9c2c72fa08054bb812935cbb2f3179f08", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -2,7 +2,7 @@\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n \n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use hir::def_id::LocalDefId;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::ErrorGuaranteed;", "previous_filename": "compiler/rustc_hir_analysis/src/check/writeback.rs"}, {"sha": "6a4c5b4d37376e0e7d2582a7fdc3574f0b0a7a8d", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -38,6 +38,7 @@ rustc_mir_transform = { path = \"../rustc_mir_transform\" }\n rustc_monomorphize = { path = \"../rustc_monomorphize\" }\n rustc_passes = { path = \"../rustc_passes\" }\n rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+rustc_hir_typeck = { path = \"../rustc_hir_typeck\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }"}, {"sha": "a47c3e3253ecdd643cb8cef700da097ee1c3d440", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -736,6 +736,7 @@ pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     rustc_monomorphize::provide(providers);\n     rustc_privacy::provide(providers);\n     rustc_hir_analysis::provide(providers);\n+    rustc_hir_typeck::provide(providers);\n     ty::provide(providers);\n     traits::provide(providers);\n     rustc_passes::provide(providers);"}, {"sha": "c9a8307eba4f29af517fe9f5cdd0e10fd8e274ba", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_hir;\n use rustc_hir::intravisit;\n use rustc_hir::{self, AssocItemKind, Body, FnDecl, HirId, HirIdSet, Impl, ItemKind, Node, Pat, PatKind};\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::FakeReadCause;\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n \n     fn fake_read(\n         &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n         _: FakeReadCause,\n         _: HirId,\n     ) {"}, {"sha": "89ffca8128a9e1bfb8d18706db5a8cbdceb9ed49", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -32,6 +32,7 @@ extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_analysis;\n+extern crate rustc_hir_typeck;\n extern crate rustc_hir_pretty;\n extern crate rustc_index;\n extern crate rustc_infer;"}, {"sha": "91b321c4474794711e4c03a91405a97b907fbe18", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::{get_enclosing_block, higher, path_to_local};\n use if_chain::if_chain;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{BindingAnnotation, Expr, ExprKind, HirId, Node, PatKind};\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::{mir::FakeReadCause, ty};\n@@ -115,7 +115,7 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n \n     fn fake_read(\n         &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n         _: FakeReadCause,\n         _: HirId,\n     ) {"}, {"sha": "5cf88bfc8880d7dbb8b20283c1ffedb5658702d9", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -8,7 +8,7 @@ use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trai\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, ItemKind, LangItem, Node};\n-use rustc_hir_analysis::check::{FnCtxt, Inherited};\n+use rustc_hir_typeck::{FnCtxt, Inherited};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::Mutability;"}, {"sha": "9c949a28f44d5dd886b846cbfc18059bf26105c9", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{\n     BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Mutability, Node, PatKind, QPath, TyKind,\n };\n use rustc_hir::{HirIdMap, HirIdSet};\n-use rustc_hir_analysis::expr_use_visitor as euv;\n+use rustc_hir_typeck::expr_use_visitor as euv;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::FakeReadCause;\n@@ -342,7 +342,7 @@ impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n \n     fn fake_read(\n         &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n         _: FakeReadCause,\n         _: HirId,\n     ) {"}, {"sha": "ee9fd94064c08a53d7d7c4f402ac3db43dd11389", "filename": "src/tools/clippy/clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -8,7 +8,7 @@ use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_lint::LateContext;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::BorrowKind;"}, {"sha": "70d166c4854c484bfe6502f75747c3e77c13c9b0", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -1,5 +1,5 @@\n use rustc_hir::Expr;\n-use rustc_hir_analysis::check::{cast, FnCtxt, Inherited};\n+use rustc_hir_typeck::{cast, FnCtxt, Inherited};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;"}, {"sha": "7e42fcc6569b692dd86c65f9d6f5a987241d4735", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -24,7 +24,7 @@ extern crate rustc_attr;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n-extern crate rustc_hir_analysis;\n+extern crate rustc_hir_typeck;\n extern crate rustc_infer;\n extern crate rustc_lexer;\n extern crate rustc_lint;"}, {"sha": "5089987ef720081fa4fc769edc448d462cf78730", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -10,7 +10,7 @@ use rustc_ast_pretty::pprust::token_kind_to_string;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::{Closure, ExprKind, HirId, MutTy, TyKind};\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{EarlyContext, LateContext, LintContext};\n use rustc_middle::hir::place::ProjectionKind;\n@@ -1054,11 +1054,10 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n \n     fn fake_read(\n         &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n         _: FakeReadCause,\n         _: HirId,\n-    ) {\n-    }\n+    ) {}\n }\n \n #[cfg(test)]"}, {"sha": "000fb51c018579f44e8091f97df9c7ecdc541c7b", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0940040c0486a536be4f8685c7dd9a078f9e87c2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=0940040c0486a536be4f8685c7dd9a078f9e87c2", "patch": "@@ -5,7 +5,7 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirIdSet;\n use rustc_hir::{Expr, ExprKind, HirId, Node};\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n@@ -75,11 +75,10 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n \n     fn fake_read(\n         &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n         _: FakeReadCause,\n         _: HirId,\n-    ) {\n-    }\n+    ) {}\n }\n \n pub struct ParamBindingIdCollector {"}]}