{"sha": "bc03c82c79f4f970eb183cc40eb89f687f8853f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMDNjODJjNzlmNGY5NzBlYjE4M2NjNDBlYjg5ZjY4N2Y4ODUzZjU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-09-16T23:24:19Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-09-16T23:24:19Z"}, "message": "Check for infinitely sized tags. Un-XFAIL test/compile-fail/infinite-tag-type-recursion.rs.", "tree": {"sha": "5f589247b548b4f5eb19713646394f95dc612bfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f589247b548b4f5eb19713646394f95dc612bfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc03c82c79f4f970eb183cc40eb89f687f8853f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc03c82c79f4f970eb183cc40eb89f687f8853f5", "html_url": "https://github.com/rust-lang/rust/commit/bc03c82c79f4f970eb183cc40eb89f687f8853f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc03c82c79f4f970eb183cc40eb89f687f8853f5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "659d1e1b7d4a3c4bd5a4df811ff6de095e4b1884", "url": "https://api.github.com/repos/rust-lang/rust/commits/659d1e1b7d4a3c4bd5a4df811ff6de095e4b1884", "html_url": "https://github.com/rust-lang/rust/commit/659d1e1b7d4a3c4bd5a4df811ff6de095e4b1884"}], "stats": {"total": 83, "additions": 78, "deletions": 5}, "files": [{"sha": "631798c77749bdd59d996384d9e34ff0318f7291", "filename": "src/Makefile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc03c82c79f4f970eb183cc40eb89f687f8853f5/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bc03c82c79f4f970eb183cc40eb89f687f8853f5/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=bc03c82c79f4f970eb183cc40eb89f687f8853f5", "patch": "@@ -419,7 +419,6 @@ TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     test/run-fail/task-comm-14.rs \\\n                     test/compile-fail/bad-recv.rs \\\n                     test/compile-fail/bad-send.rs \\\n-                    test/compile-fail/infinite-tag-type-recursion.rs \\\n                     test/compile-fail/infinite-vec-type-recursion.rs \\\n                     test/compile-fail/writing-through-read-alias.rs\n \n@@ -591,7 +590,6 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                     $(addprefix test/compile-fail/, \\\n                       bad-recv.rs \\\n                       bad-send.rs \\\n-                      infinite-tag-type-recursion.rs \\\n                       infinite-vec-type-recursion.rs \\\n                       rec-missing-fields.rs \\\n                       writing-through-read-alias.rs \\"}, {"sha": "2b613cbad7e5eace7e024ebbf53e1d664d0aac5d", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bc03c82c79f4f970eb183cc40eb89f687f8853f5/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/bc03c82c79f4f970eb183cc40eb89f687f8853f5/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=bc03c82c79f4f970eb183cc40eb89f687f8853f5", "patch": "@@ -1024,6 +1024,75 @@ let populate_tag_graph_node (cx:Semant.ctxt) (id:Common.opaque_id) (n:int) =\n   in\n   Array.iter add_ty ty_tup\n \n+let stack_contains (stack:'a Stack.t) (elem:'a) : bool =\n+  try\n+    Stack.iter (fun elem' -> if elem = elem' then raise Exit) stack; false\n+  with Exit -> true\n+\n+let report_infinitely_sized_tag\n+    (id:Common.opaque_id)\n+    (stack:Common.opaque_id Stack.t)\n+    : unit =\n+  let string_of_tag_id tag_id =\n+    let ty = Ast.TY_tag { Ast.tag_id = tag_id; Ast.tag_args = [| |] } in\n+    Ast.sprintf_ty () ty\n+  in\n+  let msg = Buffer.create 0 in\n+  Buffer.add_string msg \"found tag of infinite size: \";\n+  while not (Stack.is_empty stack) do\n+    Buffer.add_string msg (string_of_tag_id (Stack.pop stack));\n+    Buffer.add_string msg \" <- \"\n+  done;\n+  Buffer.add_string msg (string_of_tag_id id);\n+  Buffer.add_string msg \"; use '@' for recursive references\";\n+  Common.err None \"%s\" (Buffer.contents msg)\n+\n+let check_for_tag_cycles (cx:Semant.ctxt) =\n+  (* Find cycles in tags using Tarjan's strongly connected components\n+   * algorithm. *)\n+  let lowlinks = Hashtbl.create 0 in\n+  let next_index, stack = ref 0, Stack.create () in\n+\n+  let rec check_node id node =\n+    if node.Semant.tgn_index = None then begin\n+      let index = !next_index in\n+      incr next_index;\n+      node.Semant.tgn_index <- Some index;\n+\n+      Stack.push id stack;\n+\n+      Hashtbl.add lowlinks id max_int;\n+\n+      let check_outgoing_edge id' =\n+        let node' = Hashtbl.find cx.Semant.ctxt_tag_containment id' in\n+        if node'.Semant.tgn_index = None then begin\n+          check_node id' node';\n+          let lowlink = Hashtbl.find lowlinks id in\n+          let lowlink' = Hashtbl.find lowlinks id' in\n+          Hashtbl.replace lowlinks id (min lowlink lowlink')\n+        end else if stack_contains stack id' then\n+          let lowlink = Hashtbl.find lowlinks id in\n+          let index' =\n+            match node'.Semant.tgn_index with\n+                Some index' -> index'\n+              | None ->\n+                  Common.bug\n+                    ()\n+                    \"check_for_tag_cycles: node in stack without index\"\n+          in\n+          Hashtbl.replace lowlinks id (min lowlink index')\n+      in\n+\n+      Queue.iter check_outgoing_edge node.Semant.tgn_children;\n+\n+      if index == Hashtbl.find lowlinks id then\n+        report_infinitely_sized_tag id stack;\n+\n+      ignore (Stack.pop stack)\n+    end\n+  in\n+  Hashtbl.iter check_node cx.Semant.ctxt_tag_containment\n+\n let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n   let path = Stack.create () in\n   let fn_ctx_stack = Stack.create () in\n@@ -1139,7 +1208,10 @@ let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n         if not (Hashtbl.mem cx.Semant.ctxt_auto_deref_lval lval_id) then\n           Hashtbl.add cx.Semant.ctxt_auto_deref_lval lval_id false\n       in\n-      Hashtbl.iter fill cx.Semant.ctxt_all_lvals\n+      Hashtbl.iter fill cx.Semant.ctxt_all_lvals;\n+\n+      (* Check for tag cycles. *)\n+      check_for_tag_cycles cx\n     in\n \n     {"}, {"sha": "a3d5d62d4365597a765bdbd743004b0b608abcc9", "filename": "src/test/compile-fail/infinite-tag-type-recursion.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc03c82c79f4f970eb183cc40eb89f687f8853f5/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc03c82c79f4f970eb183cc40eb89f687f8853f5/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs?ref=bc03c82c79f4f970eb183cc40eb89f687f8853f5", "patch": "@@ -1,8 +1,11 @@\n // -*- rust -*-\n \n-// error-pattern: Infinite type recursion\n+// error-pattern: tag of infinite size\n \n-type mlist = tag(cons(int,mlist), nil());\n+tag mlist {\n+  cons(int, mlist);\n+  nil();\n+}\n \n fn main() {\n   auto a = cons(10, cons(11, nil()));"}]}