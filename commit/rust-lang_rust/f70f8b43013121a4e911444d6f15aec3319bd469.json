{"sha": "f70f8b43013121a4e911444d6f15aec3319bd469", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MGY4YjQzMDEzMTIxYTRlOTExNDQ0ZDZmMTVhZWMzMzE5YmQ0Njk=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-05T13:04:39Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-05T13:04:39Z"}, "message": "Remove short intro from README\n\nOriginally, this was my 30 minute introduction, and we eventually made\nit the opener to the book. But as #25918 has shown, the example I use\nhere has some issues. The good news is that Rust makes heap allocation\nsyntatically expensive, but the bad news is that that means showing\nequivalent programs from Rust and other languages is difficult. After\nthinking about it, I'm not sure this section is pulling its weight, and\nsince it has problems, I'd rather just pull it than try to re-write it\nright now. I think the book is fine without it.\n\nFIxes #25918", "tree": {"sha": "f11223f821d88b937d2db6404ecd99965caf925b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f11223f821d88b937d2db6404ecd99965caf925b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f70f8b43013121a4e911444d6f15aec3319bd469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f70f8b43013121a4e911444d6f15aec3319bd469", "html_url": "https://github.com/rust-lang/rust/commit/f70f8b43013121a4e911444d6f15aec3319bd469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f70f8b43013121a4e911444d6f15aec3319bd469/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a216e847272ddbd3033037b606eaf2d801c250b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a216e847272ddbd3033037b606eaf2d801c250b9", "html_url": "https://github.com/rust-lang/rust/commit/a216e847272ddbd3033037b606eaf2d801c250b9"}], "stats": {"total": 156, "additions": 3, "deletions": 153}, "files": [{"sha": "7acb7f835b8ddbab7f3398bbbe787c9d2e7906c9", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 3, "deletions": 153, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f70f8b43013121a4e911444d6f15aec3319bd469/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f70f8b43013121a4e911444d6f15aec3319bd469/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=f70f8b43013121a4e911444d6f15aec3319bd469", "patch": "@@ -41,158 +41,8 @@ Copious cross-linking connects these parts together.\n \n ### Contributing\n \n-The source files from which this book is generated can be found on GitHub:\n-[github.com/rust-lang/rust/tree/master/src/doc/trpl](https://github.com/rust-lang/rust/tree/master/src/doc/trpl)\n+The source files from which this book is generated can be found on\n+[GitHub][trpl].\n \n-## A brief introduction to Rust\n+[trpl]: https://github.com/rust-lang/rust/tree/master/src/doc/trpl\n \n-Is Rust a language you might be interested in? Let\u2019s examine a few small code\n-samples to show off a few of its strengths.\n-\n-The main concept that makes Rust unique is called \u2018ownership\u2019. Consider this\n-small example:\n-\n-```rust\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-}\n-```\n-\n-This program makes a [variable binding][var] named `x`. The value of this\n-binding is a `Vec<T>`, a \u2018vector\u2019, that we create through a [macro][macro]\n-defined in the standard library. This macro is called `vec`, and we invoke\n-macros with a `!`. This follows a general principle of Rust: make things\n-explicit. Macros can do significantly more complicated things than function\n-calls, and so they\u2019re visually distinct. The `!` also helps with parsing,\n-making tooling easier to write, which is also important.\n-\n-We used `mut` to make `x` mutable: bindings are immutable by default in Rust.\n-We\u2019ll be mutating this vector later in the example.\n-\n-It\u2019s also worth noting that we didn\u2019t need a type annotation here: while Rust\n-is statically typed, we didn\u2019t need to explicitly annotate the type. Rust has\n-type inference to balance out the power of static typing with the verbosity of\n-annotating types.\n-\n-Rust prefers stack allocation to heap allocation: `x` is placed directly on the\n-stack. However, the `Vec<T>` type allocates space for the elements of the vector\n-on the heap. If you\u2019re not familiar with this distinction, you can ignore it for\n-now, or check out [\u2018The Stack and the Heap\u2019][heap]. As a systems programming\n-language, Rust gives us the ability to control how our memory is allocated, but\n-when we\u2019re getting started, it\u2019s less of a big deal.\n-\n-[var]: variable-bindings.html\n-[macro]: macros.html\n-[heap]: the-stack-and-the-heap.html\n-\n-Earlier, we mentioned that \u2018ownership\u2019 is the key new concept in Rust. In Rust\n-parlance, `x` is said to \u2018own\u2019 the vector. This means that when `x` goes out of\n-scope, the vector\u2019s memory will be de-allocated. This is done deterministically\n-by the Rust compiler, rather than through a mechanism such as a garbage\n-collector. In other words, in Rust, we don\u2019t call functions like `malloc` and\n-`free` ourselves: the compiler statically determines when we need to allocate or\n-deallocate memory, and inserts those calls itself. To err is to be human, but\n-compilers never forget.\n-\n-Let\u2019s add another line to our example:\n-\n-```rust\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-\n-    let y = &x[0];\n-}\n-```\n-\n-We\u2019ve introduced another binding, `y`. In this case, `y` is a \u2018reference\u2019 to the\n-first element of the vector. Rust\u2019s references are similar to pointers in other\n-languages, but with additional compile-time safety checks. References interact\n-with the ownership system by [\u2018borrowing\u2019][borrowing] what they point to, rather\n-than owning it. The difference is, when the reference goes out of scope, it\n-won't deallocate the underlying memory. If it did, we\u2019d de-allocate twice, which\n-is bad!\n-\n-[borrowing]: references-and-borrowing.html\n-\n-Let\u2019s add a third line. It looks innocent enough, but causes a compiler error:\n-\n-```rust,ignore\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-\n-    let y = &x[0];\n-\n-    x.push(\"foo\");\n-}\n-```\n-\n-`push` is a method on vectors that appends another element to the end of the\n-vector. When we try to compile this program, we get an error:\n-\n-```text\n-error: cannot borrow `x` as mutable because it is also borrowed as immutable\n-    x.push(\"foo\");\n-    ^\n-note: previous borrow of `x` occurs here; the immutable borrow prevents\n-subsequent moves or mutable borrows of `x` until the borrow ends\n-    let y = &x[0];\n-             ^\n-note: previous borrow ends here\n-fn main() {\n-\n-}\n-^\n-```\n-\n-Whew! The Rust compiler gives quite detailed errors at times, and this is one\n-of those times. As the error explains, while we made our binding mutable, we\n-still can't call `push`. This is because we already have a reference to an\n-element of the vector, `y`. Mutating something while another reference exists\n-is dangerous, because we may invalidate the reference. In this specific case,\n-when we create the vector, we may have only allocated space for two elements.\n-Adding a third would mean allocating a new chunk of memory for all those elements,\n-copying the old values over, and updating the internal pointer to that memory.\n-That all works just fine. The problem is that `y` wouldn\u2019t get updated, and so\n-we\u2019d have a \u2018dangling pointer\u2019. That\u2019s bad. Any use of `y` would be an error in\n-this case, and so the compiler has caught this for us.\n-\n-So how do we solve this problem? There are two approaches we can take. The first\n-is making a copy rather than using a reference:\n-\n-```rust\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-\n-    let y = x[0].clone();\n-\n-    x.push(\"foo\");\n-}\n-```\n-\n-Rust has [move semantics][move] by default, so if we want to make a copy of some\n-data, we call the `clone()` method. In this example, `y` is no longer a reference\n-to the vector stored in `x`, but a copy of its first element, `\"Hello\"`. Now\n-that we don\u2019t have a reference, our `push()` works just fine.\n-\n-[move]: ownership.html#move-semantics\n-\n-If we truly want a reference, we need the other option: ensure that our reference\n-goes out of scope before we try to do the mutation. That looks like this:\n-\n-```rust\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-\n-    {\n-        let y = &x[0];\n-    }\n-\n-    x.push(\"foo\");\n-}\n-```\n-\n-We created an inner scope with an additional set of curly braces. `y` will go out of\n-scope before we call `push()`, and so we\u2019re all good.\n-\n-This concept of ownership isn\u2019t just good for preventing dangling pointers, but an\n-entire set of related problems, like iterator invalidation, concurrency, and more."}]}