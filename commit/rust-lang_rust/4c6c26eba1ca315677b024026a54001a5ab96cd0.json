{"sha": "4c6c26eba1ca315677b024026a54001a5ab96cd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNmMyNmViYTFjYTMxNTY3N2IwMjQwMjZhNTQwMDFhNWFiOTZjZDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-03T02:15:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "change the strategy for diverging types\n\nThe new strategy is as follows. First, the `!` type is assigned\nin two cases:\n\n- a block with a diverging statement and no tail expression (e.g.,\n  `{return;}`);\n- any expression with the type `!` is considered diverging.\n\nSecond, we track when we are in a diverging state, and we permit a value\nof any type to be coerced **into** `!` if the expression that produced\nit is diverging. This means that `fn foo() -> ! { panic!(); 22 }`\ntype-checks, even though the block has a type of `usize`.\n\nFinally, coercions **from** the `!` type to any other are always\npermitted.\n\nFixes #39808.", "tree": {"sha": "8f529ab13033e07b3bbb7681643a1e63489a521c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f529ab13033e07b3bbb7681643a1e63489a521c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c6c26eba1ca315677b024026a54001a5ab96cd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c6c26eba1ca315677b024026a54001a5ab96cd0", "html_url": "https://github.com/rust-lang/rust/commit/4c6c26eba1ca315677b024026a54001a5ab96cd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c6c26eba1ca315677b024026a54001a5ab96cd0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "066d44bc0d1680e2094867631920104049fd4948", "url": "https://api.github.com/repos/rust-lang/rust/commits/066d44bc0d1680e2094867631920104049fd4948", "html_url": "https://github.com/rust-lang/rust/commit/066d44bc0d1680e2094867631920104049fd4948"}], "stats": {"total": 95, "additions": 83, "deletions": 12}, "files": [{"sha": "25d689b3c2c45e06d51ac84947aa215a041e5605", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=4c6c26eba1ca315677b024026a54001a5ab96cd0", "patch": "@@ -67,8 +67,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Checks that the type of `expr` can be coerced to `expected`.\n-    pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n+    //\n+    // NB: This code relies on `self.diverges` to be accurate.  In\n+    // particular, assignments to `!` will be permitted if the\n+    // diverges flag is currently \"always\".\n+    pub fn demand_coerce(&self,\n+                         expr: &hir::Expr,\n+                         checked_ty: Ty<'tcx>,\n+                         expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n+\n+        // If we are \"assigning\" to a `!` location, then we can permit\n+        // any type to be assigned there, so long as we are in\n+        // dead-code. This applies to e.g. `fn foo() -> ! { return; 22\n+        // }` but also `fn foo() { let x: ! = { return; 22 }; }`.\n+        //\n+        // You might imagine that we could just *always* bail if we\n+        // are in dead-code, but we don't want to do that, because\n+        // that leaves a lot of type variables unconstrained. See\n+        // e.g. #39808 and #39984.\n+        let in_dead_code = self.diverges.get().always();\n+        if expected.is_never() && in_dead_code {\n+            return;\n+        }\n+\n         if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);"}, {"sha": "5d002dba78c24350a94c2d412ba53fcb96babfa9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4c6c26eba1ca315677b024026a54001a5ab96cd0", "patch": "@@ -1533,18 +1533,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n-               node_id, ty, self.tag());\n+               node_id, self.resolve_type_vars_if_possible(&ty), self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n             self.set_tainted_by_errors();\n         }\n-\n-        // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-        if ty.is_never() || self.type_var_diverges(ty) {\n-            self.diverges.set(self.diverges.get() | Diverges::Always);\n-        }\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -3282,6 +3277,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n         }\n \n+        // Any expression that produces a value of type `!` must have diverged\n+        if ty.is_never() {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+        }\n+\n         // Record the type, which applies it effects.\n         // We need to do this after the warning above, so that\n         // we don't warn for the diverging expression itself.\n@@ -3967,7 +3967,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n         self.has_errors.set(false);\n \n-        let (node_id, span) = match stmt.node {\n+        let (node_id, _span) = match stmt.node {\n             hir::StmtDecl(ref decl, id) => {\n                 let span = match decl.node {\n                     hir::DeclLocal(ref l) => {\n@@ -3993,9 +3993,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if self.has_errors.get() {\n             self.write_error(node_id);\n-        } else if self.diverges.get().always() {\n-            self.write_ty(node_id, self.next_diverging_ty_var(\n-                TypeVariableOrigin::DivergingStmt(span)));\n         } else {\n             self.write_nil(node_id);\n         }\n@@ -4046,14 +4043,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         cause = self.misc(e.span);\n                     },\n                     None => {\n-                        e_ty = self.tcx.mk_nil();\n+                        e_ty = if self.diverges.get().always() {\n+                            self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span))\n+                        } else {\n+                            self.tcx.mk_nil()\n+                        };\n                         cause = self.misc(blk.span);\n                     }\n                 };\n \n                 (e_ty, cause)\n             });\n \n+        if let ExpectHasType(ety) = expected {\n             if let Some(ref e) = blk.expr {\n                 let result = if !ctxt.may_break {\n                     self.try_coerce(e, e_ty, ctxt.coerce_to)"}, {"sha": "eedad08ab5536708f63148611b20e31fae24b5a4", "filename": "src/test/compile-fail/diverging-tuple-parts-39485.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Ftest%2Fcompile-fail%2Fdiverging-tuple-parts-39485.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Ftest%2Fcompile-fail%2Fdiverging-tuple-parts-39485.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiverging-tuple-parts-39485.rs?ref=4c6c26eba1ca315677b024026a54001a5ab96cd0", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// After #39485, this test used to pass, but that change was reverted\n+// due to numerous inference failures like #39808, so it now fails\n+// again. #39485 made it so that diverging types never propagate\n+// upward; but we now do propagate such types upward in many more\n+// cases.\n+\n+fn g() {\n+    &panic!() //~ ERROR mismatched types\n+}\n+\n+fn f() -> isize {\n+    (return 1, return 2) //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "d854e6eb20388c856a7c9e259557a942c09124cf", "filename": "src/test/compile-fail/never-assign-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs?ref=4c6c26eba1ca315677b024026a54001a5ab96cd0", "patch": "@@ -11,6 +11,7 @@\n // Test that we can't use another type in place of !\n \n #![feature(never_type)]\n+#![deny(warnings)]\n \n fn main() {\n     let x: ! = \"hello\"; //~ ERROR mismatched types"}, {"sha": "f83e9328e5879af0ff7c3bb13ae9148ca802873f", "filename": "src/test/run-pass/issue-39808.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Ftest%2Frun-pass%2Fissue-39808.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c6c26eba1ca315677b024026a54001a5ab96cd0/src%2Ftest%2Frun-pass%2Fissue-39808.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39808.rs?ref=4c6c26eba1ca315677b024026a54001a5ab96cd0", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test: even though `Ok` is dead-code, its type needs to\n+// be influenced by the result of `Err` or else we get a \"type\n+// variable unconstrained\" error.\n+\n+fn main() {\n+    let _ = if false {\n+        Ok(return)\n+    } else {\n+        Err(\"\")\n+    };\n+}"}]}