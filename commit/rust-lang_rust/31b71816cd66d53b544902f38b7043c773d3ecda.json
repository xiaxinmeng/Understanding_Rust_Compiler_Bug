{"sha": "31b71816cd66d53b544902f38b7043c773d3ecda", "node_id": "C_kwDOAAsO6NoAKDMxYjcxODE2Y2Q2NmQ1M2I1NDQ5MDJmMzhiNzA0M2M3NzNkM2VjZGE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-08-20T22:18:16Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-09-04T13:27:35Z"}, "message": "Replace `offset` with `add` in `fmt/num.rs` & remove some casts", "tree": {"sha": "329a47d3753c81eb085ab75174481db644e707d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/329a47d3753c81eb085ab75174481db644e707d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31b71816cd66d53b544902f38b7043c773d3ecda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31b71816cd66d53b544902f38b7043c773d3ecda", "html_url": "https://github.com/rust-lang/rust/commit/31b71816cd66d53b544902f38b7043c773d3ecda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31b71816cd66d53b544902f38b7043c773d3ecda/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "495fa48790fad465edcdb7965d349617854a86c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/495fa48790fad465edcdb7965d349617854a86c3", "html_url": "https://github.com/rust-lang/rust/commit/495fa48790fad465edcdb7965d349617854a86c3"}], "stats": {"total": 124, "additions": 62, "deletions": 62}, "files": [{"sha": "b11ed6b0b42abcc56234d42bacc9560d71a62a66", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/31b71816cd66d53b544902f38b7043c773d3ecda/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b71816cd66d53b544902f38b7043c773d3ecda/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=31b71816cd66d53b544902f38b7043c773d3ecda", "patch": "@@ -211,7 +211,7 @@ macro_rules! impl_Display {\n         fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n             let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n-            let mut curr = buf.len() as isize;\n+            let mut curr = buf.len();\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n@@ -228,7 +228,7 @@ macro_rules! impl_Display {\n \n                 // eagerly decode 4 characters at a time\n                 while n >= 10000 {\n-                    let rem = (n % 10000) as isize;\n+                    let rem = (n % 10000) as usize;\n                     n /= 10000;\n \n                     let d1 = (rem / 100) << 1;\n@@ -238,37 +238,37 @@ macro_rules! impl_Display {\n                     // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since\n                     // otherwise `curr < 0`. But then `n` was originally at least `10000^10`\n                     // which is `10^40 > 2^128 > n`.\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(curr + 2), 2);\n                 }\n \n                 // if we reach here numbers are <= 9999, so at most 4 chars long\n-                let mut n = n as isize; // possibly reduce 64bit math\n+                let mut n = n as usize; // possibly reduce 64bit math\n \n                 // decode 2 more chars, if > 2 chars\n                 if n >= 100 {\n                     let d1 = (n % 100) << 1;\n                     n /= 100;\n                     curr -= 2;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n \n                 // decode last 1 or 2 chars\n                 if n < 10 {\n                     curr -= 1;\n-                    *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                    *buf_ptr.add(curr) = (n as u8) + b'0';\n                 } else {\n                     let d1 = n << 1;\n                     curr -= 2;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n             }\n \n             // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid\n             // UTF-8 since `DEC_DIGITS_LUT` is\n             let buf_slice = unsafe {\n                 str::from_utf8_unchecked(\n-                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n+                    slice::from_raw_parts(buf_ptr.add(curr), buf.len() - curr))\n             };\n             f.pad_integral(is_nonnegative, \"\", buf_slice)\n         }\n@@ -339,18 +339,18 @@ macro_rules! impl_Exp {\n             // Since `curr` always decreases by the number of digits copied, this means\n             // that `curr >= 0`.\n             let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n-            let mut curr = buf.len() as isize; //index for buf\n+            let mut curr = buf.len(); //index for buf\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             // decode 2 chars at a time\n             while n >= 100 {\n-                let d1 = ((n % 100) as isize) << 1;\n+                let d1 = ((n % 100) << 1) as usize;\n                 curr -= 2;\n                 // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n                 // `DEC_DIGITS_LUT` has a length of 200.\n                 unsafe {\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n                 n /= 100;\n                 exponent += 2;\n@@ -362,7 +362,7 @@ macro_rules! impl_Exp {\n                 curr -= 1;\n                 // SAFETY: Safe since `40 > curr >= 0` (see comment)\n                 unsafe {\n-                    *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n+                    *buf_ptr.add(curr) = (n as u8 % 10_u8) + b'0';\n                 }\n                 n /= 10;\n                 exponent += 1;\n@@ -372,18 +372,18 @@ macro_rules! impl_Exp {\n                 curr -= 1;\n                 // SAFETY: Safe since `40 > curr >= 0`\n                 unsafe {\n-                    *buf_ptr.offset(curr) = b'.';\n+                    *buf_ptr.add(curr) = b'.';\n                 }\n             }\n \n             // SAFETY: Safe since `40 > curr >= 0`\n             let buf_slice = unsafe {\n                 // decode last character\n                 curr -= 1;\n-                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                *buf_ptr.add(curr) = (n as u8) + b'0';\n \n                 let len = buf.len() - curr as usize;\n-                slice::from_raw_parts(buf_ptr.offset(curr), len)\n+                slice::from_raw_parts(buf_ptr.add(curr), len)\n             };\n \n             // stores 'e' (or 'E') and the up to 2-digit exponent\n@@ -392,13 +392,13 @@ macro_rules! impl_Exp {\n             // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n             // is contained within `exp_buf` since `len <= 3`.\n             let exp_slice = unsafe {\n-                *exp_ptr.offset(0) = if upper { b'E' } else { b'e' };\n+                *exp_ptr.add(0) = if upper { b'E' } else { b'e' };\n                 let len = if exponent < 10 {\n-                    *exp_ptr.offset(1) = (exponent as u8) + b'0';\n+                    *exp_ptr.add(1) = (exponent as u8) + b'0';\n                     2\n                 } else {\n                     let off = exponent << 1;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(off), exp_ptr.offset(1), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(off), exp_ptr.add(1), 2);\n                     3\n                 };\n                 slice::from_raw_parts(exp_ptr, len)\n@@ -479,7 +479,7 @@ mod imp {\n impl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);\n \n /// Helper function for writing a u64 into `buf` going from last to first, with `curr`.\n-fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut isize) {\n+fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut usize) {\n     let buf_ptr = MaybeUninit::slice_as_mut_ptr(buf);\n     let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n     assert!(*curr > 19);\n@@ -494,73 +494,73 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n             n /= 1e16 as u64;\n \n             // Some of these are nops but it looks more elegant this way.\n-            let d1 = ((to_parse / 1e14 as u64) % 100) << 1;\n-            let d2 = ((to_parse / 1e12 as u64) % 100) << 1;\n-            let d3 = ((to_parse / 1e10 as u64) % 100) << 1;\n-            let d4 = ((to_parse / 1e8 as u64) % 100) << 1;\n-            let d5 = ((to_parse / 1e6 as u64) % 100) << 1;\n-            let d6 = ((to_parse / 1e4 as u64) % 100) << 1;\n-            let d7 = ((to_parse / 1e2 as u64) % 100) << 1;\n-            let d8 = ((to_parse / 1e0 as u64) % 100) << 1;\n+            let d1 = (((to_parse / 1e14 as u64) % 100) << 1) as usize;\n+            let d2 = (((to_parse / 1e12 as u64) % 100) << 1) as usize;\n+            let d3 = (((to_parse / 1e10 as u64) % 100) << 1) as usize;\n+            let d4 = (((to_parse / 1e8 as u64) % 100) << 1) as usize;\n+            let d5 = (((to_parse / 1e6 as u64) % 100) << 1) as usize;\n+            let d6 = (((to_parse / 1e4 as u64) % 100) << 1) as usize;\n+            let d7 = (((to_parse / 1e2 as u64) % 100) << 1) as usize;\n+            let d8 = (((to_parse / 1e0 as u64) % 100) << 1) as usize;\n \n             *curr -= 16;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d5 as isize), buf_ptr.offset(*curr + 8), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d6 as isize), buf_ptr.offset(*curr + 10), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d7 as isize), buf_ptr.offset(*curr + 12), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d8 as isize), buf_ptr.offset(*curr + 14), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d3), buf_ptr.add(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d4), buf_ptr.add(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d5), buf_ptr.add(*curr + 8), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d6), buf_ptr.add(*curr + 10), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d7), buf_ptr.add(*curr + 12), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d8), buf_ptr.add(*curr + 14), 2);\n         }\n         if n >= 1e8 as u64 {\n             let to_parse = n % 1e8 as u64;\n             n /= 1e8 as u64;\n \n             // Some of these are nops but it looks more elegant this way.\n-            let d1 = ((to_parse / 1e6 as u64) % 100) << 1;\n-            let d2 = ((to_parse / 1e4 as u64) % 100) << 1;\n-            let d3 = ((to_parse / 1e2 as u64) % 100) << 1;\n-            let d4 = ((to_parse / 1e0 as u64) % 100) << 1;\n+            let d1 = (((to_parse / 1e6 as u64) % 100) << 1) as usize;\n+            let d2 = (((to_parse / 1e4 as u64) % 100) << 1) as usize;\n+            let d3 = (((to_parse / 1e2 as u64) % 100) << 1) as usize;\n+            let d4 = (((to_parse / 1e0 as u64) % 100) << 1) as usize;\n             *curr -= 8;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d3), buf_ptr.add(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d4), buf_ptr.add(*curr + 6), 2);\n         }\n         // `n` < 1e8 < (1 << 32)\n         let mut n = n as u32;\n         if n >= 1e4 as u32 {\n             let to_parse = n % 1e4 as u32;\n             n /= 1e4 as u32;\n \n-            let d1 = (to_parse / 100) << 1;\n-            let d2 = (to_parse % 100) << 1;\n+            let d1 = ((to_parse / 100) << 1) as usize;\n+            let d2 = ((to_parse % 100) << 1) as usize;\n             *curr -= 4;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(*curr + 2), 2);\n         }\n \n         // `n` < 1e4 < (1 << 16)\n         let mut n = n as u16;\n         if n >= 100 {\n-            let d1 = (n % 100) << 1;\n+            let d1 = ((n % 100) << 1) as usize;\n             n /= 100;\n             *curr -= 2;\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr), 2);\n         }\n \n         // decode last 1 or 2 chars\n         if n < 10 {\n             *curr -= 1;\n-            *buf_ptr.offset(*curr) = (n as u8) + b'0';\n+            *buf_ptr.add(*curr) = (n as u8) + b'0';\n         } else {\n-            let d1 = n << 1;\n+            let d1 = (n << 1) as usize;\n             *curr -= 2;\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr), 2);\n         }\n     }\n }\n@@ -593,21 +593,21 @@ impl fmt::Display for i128 {\n fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n     // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n     let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n-    let mut curr = buf.len() as isize;\n+    let mut curr = buf.len();\n \n     let (n, rem) = udiv_1e19(n);\n     parse_u64_into(rem, &mut buf, &mut curr);\n \n     if n != 0 {\n         // 0 pad up to point\n-        let target = (buf.len() - 19) as isize;\n+        let target = buf.len() - 19;\n         // SAFETY: Guaranteed that we wrote at most 19 bytes, and there must be space\n         // remaining since it has length 39\n         unsafe {\n             ptr::write_bytes(\n-                MaybeUninit::slice_as_mut_ptr(&mut buf).offset(target),\n+                MaybeUninit::slice_as_mut_ptr(&mut buf).add(target),\n                 b'0',\n-                (curr - target) as usize,\n+                curr - target,\n             );\n         }\n         curr = target;\n@@ -616,16 +616,16 @@ fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::R\n         parse_u64_into(rem, &mut buf, &mut curr);\n         // Should this following branch be annotated with unlikely?\n         if n != 0 {\n-            let target = (buf.len() - 38) as isize;\n+            let target = buf.len() - 38;\n             // The raw `buf_ptr` pointer is only valid until `buf` is used the next time,\n             // buf `buf` is not used in this scope so we are good.\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             // SAFETY: At this point we wrote at most 38 bytes, pad up to that point,\n             // There can only be at most 1 digit remaining.\n             unsafe {\n-                ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n+                ptr::write_bytes(buf_ptr.add(target), b'0', curr - target);\n                 curr = target - 1;\n-                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                *buf_ptr.add(curr) = (n as u8) + b'0';\n             }\n         }\n     }\n@@ -634,8 +634,8 @@ fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::R\n     // UTF-8 since `DEC_DIGITS_LUT` is\n     let buf_slice = unsafe {\n         str::from_utf8_unchecked(slice::from_raw_parts(\n-            MaybeUninit::slice_as_mut_ptr(&mut buf).offset(curr),\n-            buf.len() - curr as usize,\n+            MaybeUninit::slice_as_mut_ptr(&mut buf).add(curr),\n+            buf.len() - curr,\n         ))\n     };\n     f.pad_integral(is_nonnegative, \"\", buf_slice)"}]}