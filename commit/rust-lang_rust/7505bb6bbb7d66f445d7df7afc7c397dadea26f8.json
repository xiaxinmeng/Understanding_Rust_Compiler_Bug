{"sha": "7505bb6bbb7d66f445d7df7afc7c397dadea26f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MDViYjZiYmI3ZDY2ZjQ0NWQ3ZGY3YWZjN2MzOTdkYWRlYTI2Zjg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-03T10:24:29Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc_codegen_utils: revert some symbol_names refactors (while keeping the functional changes).", "tree": {"sha": "416623321b8562ec50b35eb2da89fc5c11692b9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/416623321b8562ec50b35eb2da89fc5c11692b9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7505bb6bbb7d66f445d7df7afc7c397dadea26f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7505bb6bbb7d66f445d7df7afc7c397dadea26f8", "html_url": "https://github.com/rust-lang/rust/commit/7505bb6bbb7d66f445d7df7afc7c397dadea26f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7505bb6bbb7d66f445d7df7afc7c397dadea26f8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2a3c5d79b9c6ee2ab4257eda41f1a86b273ef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2a3c5d79b9c6ee2ab4257eda41f1a86b273ef5", "html_url": "https://github.com/rust-lang/rust/commit/1c2a3c5d79b9c6ee2ab4257eda41f1a86b273ef5"}], "stats": {"total": 123, "additions": 55, "deletions": 68}, "files": [{"sha": "70ab185660c4c533ba66d440870e59f9639c2b1d", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 55, "deletions": 68, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7505bb6bbb7d66f445d7df7afc7c397dadea26f8/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7505bb6bbb7d66f445d7df7afc7c397dadea26f8/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=7505bb6bbb7d66f445d7df7afc7c397dadea26f8", "patch": "@@ -380,88 +380,75 @@ impl SymbolPathBuffer {\n         let _ = write!(self.result, \"17h{:016x}E\", hash);\n         self.result\n     }\n+}\n \n-    // Name sanitation. LLVM will happily accept identifiers with weird names, but\n-    // gas doesn't!\n-    // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-    // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n-    // are replaced with '$' there.\n-    fn sanitize_and_append(&mut self, s: &str) {\n-        self.temp_buf.clear();\n-\n-        for c in s.chars() {\n-            match c {\n-                // Escape these with $ sequences\n-                '@' => self.temp_buf.push_str(\"$SP$\"),\n-                '*' => self.temp_buf.push_str(\"$BP$\"),\n-                '&' => self.temp_buf.push_str(\"$RF$\"),\n-                '<' => self.temp_buf.push_str(\"$LT$\"),\n-                '>' => self.temp_buf.push_str(\"$GT$\"),\n-                '(' => self.temp_buf.push_str(\"$LP$\"),\n-                ')' => self.temp_buf.push_str(\"$RP$\"),\n-                ',' => self.temp_buf.push_str(\"$C$\"),\n-\n-                '-' | ':' => if self.strict_naming {\n-                    // NVPTX doesn't support these characters in symbol names.\n-                    self.temp_buf.push('$')\n-                }\n-                else {\n-                    // '.' doesn't occur in types and functions, so reuse it\n-                    // for ':' and '-'\n-                    self.temp_buf.push('.')\n-                },\n-\n-                '.' => if self.strict_naming {\n-                    self.temp_buf.push('$')\n-                }\n-                else {\n-                    self.temp_buf.push('.')\n-                },\n-\n-                // These are legal symbols\n-                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '$' => self.temp_buf.push(c),\n-\n-                _ => {\n-                    self.temp_buf.push('$');\n-                    for c in c.escape_unicode().skip(1) {\n-                        match c {\n-                            '{' => {}\n-                            '}' => self.temp_buf.push('$'),\n-                            c => self.temp_buf.push(c),\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        let need_underscore = {\n-            // Underscore-qualify anything that didn't start as an ident.\n-            !self.temp_buf.is_empty()\n-                && self.temp_buf.as_bytes()[0] != '_' as u8\n-                && !(self.temp_buf.as_bytes()[0] as char).is_xid_start()\n-        };\n+impl ItemPathBuffer for SymbolPathBuffer {\n+    fn root_mode(&self) -> &RootMode {\n+        const ABSOLUTE: &RootMode = &RootMode::Absolute;\n+        ABSOLUTE\n+    }\n \n+    fn push(&mut self, text: &str) {\n+        self.temp_buf.clear();\n+        let need_underscore = sanitize(&mut self.temp_buf, text, self.strict_naming);\n         let _ = write!(\n             self.result,\n             \"{}\",\n             self.temp_buf.len() + (need_underscore as usize)\n         );\n-\n         if need_underscore {\n             self.result.push('_');\n         }\n-\n         self.result.push_str(&self.temp_buf);\n     }\n }\n \n-impl ItemPathBuffer for SymbolPathBuffer {\n-    fn root_mode(&self) -> &RootMode {\n-        const ABSOLUTE: &RootMode = &RootMode::Absolute;\n-        ABSOLUTE\n-    }\n+// Name sanitation. LLVM will happily accept identifiers with weird names, but\n+// gas doesn't!\n+// gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+// NVPTX assembly has more strict naming rules than gas, so additionally, dots\n+// are replaced with '$' there.\n+//\n+// returns true if an underscore must be added at the start\n+fn sanitize(result: &mut String, s: &str, strict_naming: bool) -> bool {\n+    for c in s.chars() {\n+        match c {\n+            // Escape these with $ sequences\n+            '@' => result.push_str(\"$SP$\"),\n+            '*' => result.push_str(\"$BP$\"),\n+            '&' => result.push_str(\"$RF$\"),\n+            '<' => result.push_str(\"$LT$\"),\n+            '>' => result.push_str(\"$GT$\"),\n+            '(' => result.push_str(\"$LP$\"),\n+            ')' => result.push_str(\"$RP$\"),\n+            ',' => result.push_str(\"$C$\"),\n+\n+            '-' | ':' | '.' if strict_naming => {\n+                // NVPTX doesn't support these characters in symbol names.\n+                result.push('$')\n+            }\n \n-    fn push(&mut self, text: &str) {\n-        self.sanitize_and_append(text);\n+            // '.' doesn't occur in types and functions, so reuse it\n+            // for ':' and '-'\n+            '-' | ':' => result.push('.'),\n+\n+            // These are legal symbols\n+            'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => result.push(c),\n+\n+            _ => {\n+                result.push('$');\n+                for c in c.escape_unicode().skip(1) {\n+                    match c {\n+                        '{' => {}\n+                        '}' => result.push('$'),\n+                        c => result.push(c),\n+                    }\n+                }\n+            }\n+        }\n     }\n+\n+    // Underscore-qualify anything that didn't start as an ident.\n+    !result.is_empty() && result.as_bytes()[0] != '_' as u8\n+        && !(result.as_bytes()[0] as char).is_xid_start()\n }"}]}