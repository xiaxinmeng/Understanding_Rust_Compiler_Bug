{"sha": "d4f60b5ff42a4e8b5889879664002f90dacd6c04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZjYwYjVmZjQyYTRlOGI1ODg5ODc5NjY0MDAyZjkwZGFjZDZjMDQ=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-05-15T12:36:56Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-06-08T20:00:33Z"}, "message": "wip: of handling nested import paths for multi-macro paths", "tree": {"sha": "635202d0b37538b9b85953d43658a5a5c5d1b16b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/635202d0b37538b9b85953d43658a5a5c5d1b16b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4f60b5ff42a4e8b5889879664002f90dacd6c04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4f60b5ff42a4e8b5889879664002f90dacd6c04", "html_url": "https://github.com/rust-lang/rust/commit/d4f60b5ff42a4e8b5889879664002f90dacd6c04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4f60b5ff42a4e8b5889879664002f90dacd6c04/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "451363dc59b3030fee82e4faf04684c068f619cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/451363dc59b3030fee82e4faf04684c068f619cc", "html_url": "https://github.com/rust-lang/rust/commit/451363dc59b3030fee82e4faf04684c068f619cc"}], "stats": {"total": 244, "additions": 122, "deletions": 122}, "files": [{"sha": "1e1f27e9430c787872072e995954629baf553478", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 109, "deletions": 88, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/d4f60b5ff42a4e8b5889879664002f90dacd6c04/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f60b5ff42a4e8b5889879664002f90dacd6c04/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=d4f60b5ff42a4e8b5889879664002f90dacd6c04", "patch": "@@ -49,10 +49,7 @@ impl MacroRefData {\n         if path.contains(' ') {\n             path = path.split(' ').next().unwrap().to_string();\n         }\n-        Self {\n-            name,\n-            path,\n-        }\n+        Self { name, path }\n     }\n }\n \n@@ -79,7 +76,7 @@ impl MacroUseImports {\n                 } else {\n                     name.to_string()\n                 };\n-    \n+\n                 self.mac_refs.push(MacroRefData::new(name, callee.def_site, cx));\n                 self.collected.insert(call_site);\n             }\n@@ -91,7 +88,8 @@ impl MacroUseImports {\n         let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n         if let Some(callee) = span.source_callee() {\n             if !self.collected.contains(&call_site) {\n-                self.mac_refs.push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n+                self.mac_refs\n+                    .push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n                 self.collected.insert(call_site);\n             }\n         }\n@@ -147,78 +145,123 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n             self.push_unique_macro_pat_ty(cx, ty.span);\n         }\n     }\n-\n+    #[allow(clippy::too_many_lines)]\n     fn check_crate_post(&mut self, cx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n         let mut import_map = FxHashMap::default();\n         for (import, span) in &self.imports {\n             let found_idx = self.mac_refs.iter().position(|mac| import.ends_with(&mac.name));\n-            \n+\n             if let Some(idx) = found_idx {\n                 let _ = self.mac_refs.remove(idx);\n                 proccess_macro_path(*span, import, &mut import_map);\n             }\n         }\n-        println!(\"{:#?}\", import_map);\n+        // println!(\"{:#?}\", import_map);\n         let mut imports = vec![];\n         for (root, rest) in import_map {\n             let mut path = format!(\"use {}::\", root);\n-            let mut s = None;\n+            let mut attr_span = None;\n+            // when a multiple nested paths are found one may be written to the string\n+            // before it is found in this loop so we make note and skip it when this\n+            // loop finds it\n+            let mut found_nested = vec![];\n             let mut count = 1;\n             let rest_len = rest.len();\n+\n             if rest_len > 1 {\n                 path.push_str(\"{\");\n             }\n+\n             for m in &rest {\n-                println!(\"{} => {:?}\", root, m);\n-                if count == 1 {\n-                    s = Some(m.span());\n+                if attr_span.is_none() {\n+                    attr_span = Some(m.span());\n+                }\n+                if found_nested.contains(&m) {\n+                    continue;\n                 }\n-                \n                 let comma = if rest_len == count { \"\" } else { \", \" };\n                 match m {\n                     ModPath::Item { item, .. } => {\n                         path.push_str(&format!(\"{}{}\", item, comma));\n-                    }\n-                    ModPath::Nested { names, item, span } => {\n-                        let nested = rest.iter()\n+                    },\n+                    ModPath::Nested { segments, item, .. } => {\n+                        // do any other Nested paths match the current one\n+                        let nested = rest\n+                            .iter()\n                             // filter \"self\" out\n                             .filter(|other_m| other_m != &m)\n+                            // filters out Nested we have previously seen\n+                            .filter(|other_m| !found_nested.contains(other_m))\n                             // this matches the first path segment and filters non ModPath::Nested items\n                             .filter(|other_m| other_m.matches(0, m))\n                             .collect::<Vec<_>>();\n \n-                        println!(\"{:#?}\", nested);\n-\n                         if nested.is_empty() {\n-                            path.push_str(&format!(\"{}::{}{}\", names.join(\"::\").to_string(), item, comma))\n+                            path.push_str(&format!(\"{}::{}{}\", segments.join(\"::\").to_string(), item, comma))\n+                        // use mod_a::{mod_b::{one, two}, mod_c::item}\n                         } else {\n-                            // use mod_a::{mod_b::{one, two}, mod_c::item, item1, item2}\n-                            let mod_path = if names.len() - 1 > 0 {\n-                                ModPath::Nested { names: names.clone(), item: item.to_string(), span: *span, }\n-                            } else {\n-                                ModPath::Item { item: names[0].to_string(), span: *span, }\n-                            };\n-                            let names = recursive_path_push(mod_path, comma, &rest, String::new());\n-                            path.push_str(&format!(\"{}::{{{}}}{}\", names, item, comma))\n+                            found_nested.extend(nested.iter());\n+                            found_nested.push(&m);\n+                            // we check each segment for matches with other import paths if\n+                            // one differs we have to open a new `{}`\n+                            for (idx, seg) in segments.iter().enumerate() {\n+                                path.push_str(&format!(\"{}::\", seg));\n+                                if nested.iter().all(|other_m| other_m.matches(idx, &m)) {\n+                                    continue;\n+                                }\n+\n+                                path.push_str(\"{\");\n+                                let matched_seg_items = nested\n+                                    .iter()\n+                                    .filter(|other_m| !other_m.matches(idx, &m))\n+                                    .collect::<Vec<_>>();\n+                                for item in matched_seg_items {\n+                                    if let ModPath::Nested { item, .. } = item {\n+                                        path.push_str(&format!(\n+                                            \"{}{}\",\n+                                            item,\n+                                            if nested.len() == idx + 1 { \"\" } else { \", \" }\n+                                        ));\n+                                    }\n+                                }\n+                                path.push_str(\"}\");\n+                            }\n+                            path.push_str(&format!(\"{{{}{}\", item, comma));\n+                            for (i, item) in nested.iter().enumerate() {\n+                                if let ModPath::Nested { item, segments: matched_seg, .. } = item {\n+                                    path.push_str(&format!(\n+                                        \"{}{}{}\",\n+                                        if matched_seg > segments {\n+                                            format!(\"{}::\", matched_seg[segments.len()..].join(\"::\"))\n+                                        } else {\n+                                            String::new()\n+                                        },\n+                                        item,\n+                                        if nested.len() == i + 1 { \"\" } else { \", \" }\n+                                    ));\n+                                }\n+                            }\n+                            path.push_str(\"}\");\n                         }\n-                    }\n+                    },\n                 }\n-                count += 1;             \n+                count += 1;\n             }\n             if rest_len > 1 {\n                 path.push_str(\"};\");\n+            } else {\n+                path.push_str(\";\");\n             }\n-            if let Some(span) = s {\n+            if let Some(span) = attr_span {\n                 imports.push((span, path))\n+            } else {\n+                unreachable!(\"a span must always be attached to a macro_use attribute\")\n             }\n         }\n \n-        if !self.mac_refs.is_empty() {\n-            // TODO if not empty we found one we could not make a suggestion for\n-            // such as std::prelude::v1 or something else I haven't thought of.\n-            // If we defer the calling of span_lint_and_sugg we can make a decision about its\n-            // applicability?\n-        } else {\n+        // If mac_refs is not empty we have encountered an import we could not handle\n+        // such as `std::prelude::v1::foo` or some other macro that expands to an import.\n+        if self.mac_refs.is_empty() {\n             for (span, import) in imports {\n                 let help = format!(\"use {}\", import);\n                 span_lint_and_sugg(\n@@ -237,48 +280,56 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n \n #[derive(Debug, PartialEq)]\n enum ModPath {\n-    Item { item: String, span: Span, },\n-    Nested { names: Vec<String>, item: String, span: Span, },\n+    Item {\n+        item: String,\n+        span: Span,\n+    },\n+    Nested {\n+        segments: Vec<String>,\n+        item: String,\n+        span: Span,\n+    },\n }\n \n impl ModPath {\n     fn span(&self) -> Span {\n         match self {\n-            Self::Item { span, .. } => *span,\n-            Self::Nested { span, .. } => *span,\n+            Self::Item { span, .. } | Self::Nested { span, .. } => *span,\n         }\n     }\n \n     fn item(&self) -> &str {\n         match self {\n-            Self::Item { item, .. } => item,\n-            Self::Nested { item, .. } => item,\n+            Self::Item { item, .. } | Self::Nested { item, .. } => item,\n         }\n     }\n \n     fn matches(&self, idx: usize, other: &ModPath) -> bool {\n         match (self, other) {\n             (Self::Item { item, .. }, Self::Item { item: other_item, .. }) => item == other_item,\n-            (Self::Nested { names, .. }, Self::Nested { names: other_names, .. }) => {\n-                match (names.get(idx), other_names.get(idx)) {\n-                    (Some(seg), Some(other_seg)) => seg == other_seg,\n-                    (_, _) => false,\n-                }\n-            }\n+            (\n+                Self::Nested { segments, .. },\n+                Self::Nested {\n+                    segments: other_names, ..\n+                },\n+            ) => match (segments.get(idx), other_names.get(idx)) {\n+                (Some(seg), Some(other_seg)) => seg == other_seg,\n+                (_, _) => false,\n+            },\n             (_, _) => false,\n         }\n     }\n }\n \n+#[allow(clippy::comparison_chain)]\n fn proccess_macro_path(span: Span, import: &str, import_map: &mut FxHashMap<String, Vec<ModPath>>) {\n     let mut mod_path = import.split(\"::\").collect::<Vec<_>>();\n \n     if mod_path.len() == 2 {\n-        let item_list = import_map.entry(mod_path[0].to_string())\n-            .or_insert(vec![]);\n+        let item_list = import_map.entry(mod_path[0].to_string()).or_insert_with(Vec::new);\n \n         if !item_list.iter().any(|mods| mods.item() == mod_path[1]) {\n-            item_list.push(ModPath::Item{\n+            item_list.push(ModPath::Item {\n                 item: mod_path[1].to_string(),\n                 span,\n             });\n@@ -288,46 +339,16 @@ fn proccess_macro_path(span: Span, import: &str, import_map: &mut FxHashMap<Stri\n         let name = mod_path.remove(mod_path.len() - 1);\n \n         let nested = ModPath::Nested {\n-            names: mod_path.into_iter().map(ToString::to_string).collect(),\n+            segments: mod_path.into_iter().map(ToString::to_string).collect(),\n             item: name.to_string(),\n             span,\n         };\n-        import_map.entry(first.to_string())\n-            .or_insert(vec![])\n-            .push(nested);\n+        // CLIPPY NOTE: this told me to use `or_insert_with(vec![])`\n+        // import_map.entry(first.to_string()).or_insert(vec![]).push(nested);\n+        // which failed as `vec!` is not a closure then told me to add `||` which failed\n+        // with the redundant_closure lint so I finally gave up and used this.\n+        import_map.entry(first.to_string()).or_insert_with(Vec::new).push(nested);\n     } else {\n         unreachable!(\"test to see if code path hit TODO REMOVE\")\n     }\n }\n-\n-fn recursive_path_push(module: ModPath, comma: &str, rest: &[ModPath], mut path: String) -> String {\n-    match &module {\n-        ModPath::Item { item, .. } => {\n-            path.push_str(&format!(\"{}{}\", item, comma));\n-        }\n-        ModPath::Nested { names, item, span } => {\n-            let nested = rest.iter()\n-                // filter \"self\" out\n-                .filter(|other_m| other_m != &&module)\n-                // this matches the first path segment and filters non ModPath::Nested items\n-                .filter(|other_m| other_m.matches(0, &module))\n-                .collect::<Vec<_>>();\n-\n-            println!(\"{:#?}\", nested);\n-\n-            if nested.is_empty() {\n-                path.push_str(&format!(\"{}::{}{}\", names.join(\"::\").to_string(), item, comma))\n-            } else {\n-                // use mod_a::{mod_b::{one, two}, mod_c::item, item1, item2}\n-                let mod_path = if names.len() - 1 > 0 {\n-                    ModPath::Nested { names: names.clone(), item: item.to_string(), span: *span, }\n-                } else {\n-                    ModPath::Item { item: names[0].to_string(), span: *span, }\n-                };\n-                let names = recursive_path_push(mod_path, comma, rest, path.to_string());\n-                // path.push_str(&format!(\"{}{}\", item, comma));\n-            }\n-        }\n-    }\n-    path\n-}"}, {"sha": "ecb55d8cb48d5bbcb6f32ba3223d6ef8671793ed", "filename": "tests/ui/auxiliary/macro_use_helper.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4f60b5ff42a4e8b5889879664002f90dacd6c04/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f60b5ff42a4e8b5889879664002f90dacd6c04/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs?ref=d4f60b5ff42a4e8b5889879664002f90dacd6c04", "patch": "@@ -13,8 +13,13 @@ pub mod inner {\n \n     // RE-EXPORT\n     // this will stick in `inner` module\n+    pub use macro_rules::foofoo;\n     pub use macro_rules::try_err;\n \n+    pub mod nested {\n+        pub use macro_rules::string_add;\n+    }\n+\n     // ITEM\n     #[macro_export]\n     macro_rules! inner_mod_macro {"}, {"sha": "52dec0e44b306107fb627dfc7b0caa86e3e0961a", "filename": "tests/ui/macro_use_imports.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4f60b5ff42a4e8b5889879664002f90dacd6c04/tests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f60b5ff42a4e8b5889879664002f90dacd6c04/tests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.rs?ref=d4f60b5ff42a4e8b5889879664002f90dacd6c04", "patch": "@@ -18,6 +18,8 @@ mod a {\n     use mini_mac;\n     #[macro_use]\n     use mac::inner;\n+    #[macro_use]\n+    use mac::inner::nested;\n \n     #[derive(ClippyMiniMacroTest)]\n     struct Test;\n@@ -30,6 +32,8 @@ mod a {\n         let v: ty_macro!() = Vec::default();\n \n         inner::try_err!();\n+        inner::foofoo!();\n+        nested::string_add!();\n     }\n }\n "}, {"sha": "00c76c19ea9e866d54ba0d428e22dd6d0f712161", "filename": "tests/ui/macro_use_imports.stderr", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d4f60b5ff42a4e8b5889879664002f90dacd6c04/tests%2Fui%2Fmacro_use_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4f60b5ff42a4e8b5889879664002f90dacd6c04/tests%2Fui%2Fmacro_use_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.stderr?ref=d4f60b5ff42a4e8b5889879664002f90dacd6c04", "patch": "@@ -1,46 +1,16 @@\n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:15:5\n+  --> $DIR/macro_use_imports.rs:17:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::pub_macro`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use use mini_mac::ClippyMiniMacroTest;`\n    |\n    = note: `-D clippy::macro-use-imports` implied by `-D warnings`\n \n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n   --> $DIR/macro_use_imports.rs:15:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner_mod_macro`\n-\n-error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:15:5\n-   |\n-LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::function_macro`\n-\n-error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:15:5\n-   |\n-LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::ty_macro`\n-\n-error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:15:5\n-   |\n-LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::pub_in_private_macro`\n-\n-error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:17:5\n-   |\n-LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mini_mac::ClippyMiniMacroTest`\n-\n-error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:19:5\n-   |\n-LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::try_err`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro, inner::{foofoo, try_err, nested::string_add}};`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 2 previous errors\n "}]}