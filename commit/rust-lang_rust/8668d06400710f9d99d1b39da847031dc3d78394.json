{"sha": "8668d06400710f9d99d1b39da847031dc3d78394", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NjhkMDY0MDA3MTBmOWQ5OWQxYjM5ZGE4NDcwMzFkYzNkNzgzOTQ=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-05-24T21:49:39Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-05-25T23:39:35Z"}, "message": "Get rid of many implicit copies as a preliminary to Issue #2448.", "tree": {"sha": "e9b16f7ed60e3819ed53f86d94378916f17ffb74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b16f7ed60e3819ed53f86d94378916f17ffb74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8668d06400710f9d99d1b39da847031dc3d78394", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8668d06400710f9d99d1b39da847031dc3d78394", "html_url": "https://github.com/rust-lang/rust/commit/8668d06400710f9d99d1b39da847031dc3d78394", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8668d06400710f9d99d1b39da847031dc3d78394/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d89b4c8c61b4995559c2e5b963d58b5dd599fdf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d89b4c8c61b4995559c2e5b963d58b5dd599fdf3", "html_url": "https://github.com/rust-lang/rust/commit/d89b4c8c61b4995559c2e5b963d58b5dd599fdf3"}], "stats": {"total": 153, "additions": 75, "deletions": 78}, "files": [{"sha": "2602a0ab828752b78a46b91208eb95e996db77e1", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -603,7 +603,7 @@ fn install_uuid(c: cargo, wd: str, uuid: str) {\n     for_each_package(c, { |s, p|\n         info(#fmt[\"%s ? %s\", p.uuid, uuid]);\n         if p.uuid == uuid {\n-            vec::grow(ps, 1u, (s, p));\n+            vec::grow(ps, 1u, (s.name, p));\n         }\n     });\n     if vec::len(ps) == 1u {\n@@ -616,16 +616,16 @@ fn install_uuid(c: cargo, wd: str, uuid: str) {\n     }\n     error(\"Found multiple packages:\");\n     for ps.each {|elt|\n-        let (s,p) = elt;\n-        info(\"  \" + s.name + \"/\" + p.uuid + \" (\" + p.name + \")\");\n+        let (sname,p) = elt;\n+        info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n \n fn install_named(c: cargo, wd: str, name: str) {\n     let mut ps = [];\n     for_each_package(c, { |s, p|\n         if p.name == name {\n-            vec::grow(ps, 1u, (s, p));\n+            vec::grow(ps, 1u, (s.name, p));\n         }\n     });\n     if vec::len(ps) == 1u {\n@@ -638,8 +638,8 @@ fn install_named(c: cargo, wd: str, name: str) {\n     }\n     error(\"Found multiple packages:\");\n     for ps.each {|elt|\n-        let (s,p) = elt;\n-        info(\"  \" + s.name + \"/\" + p.uuid + \" (\" + p.name + \")\");\n+        let (sname,p) = elt;\n+        info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n "}, {"sha": "6fa20ce0804f1f78de456a24bcff3b6f57856a43", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -24,7 +24,7 @@ task to receive from it.\n unsafe fn chan_from_global_ptr<T: send>(\n     global: global_ptr,\n     builder: fn() -> task::builder,\n-    f: fn~(comm::port<T>)\n+    +f: fn~(comm::port<T>)\n ) -> comm::chan<T> {\n \n     enum msg {\n@@ -233,4 +233,4 @@ fn test_weaken_task_fail() unsafe {\n         }\n     };\n     assert result::is_failure(res);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ee8a1cc665bc6f425023f73351838554368c95cf", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -132,7 +132,7 @@ enum optval { val(str), given, }\n The result of checking command line arguments. Contains a vector\n of matches and a vector of free strings.\n \"]\n-type match = {opts: [opt], vals: [mut [optval]], free: [str]};\n+type match = {opts: [opt], vals: [[optval]], free: [str]};\n \n fn is_arg(arg: str) -> bool {\n     ret str::len(arg) > 1u && arg[0] == '-' as u8;\n@@ -275,7 +275,7 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n         }\n         i += 1u;\n     }\n-    ret ok({opts: opts, vals: vals, free: free});\n+    ret ok({opts: opts, vals: vec::from_mut(vals), free: free});\n }\n \n fn opt_vals(m: match, nm: str) -> [optval] {"}, {"sha": "2769e05b55b89c4bbb7efe8b8e3d74b49309179e", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -476,7 +476,7 @@ once a new connection is recv'd. Its parameter:\n     variant\n \"]\n fn conn_recv_spawn(server_port: tcp_conn_port,\n-                   cb: fn~(result::result<tcp_socket, tcp_err_data>)) {\n+                   +cb: fn~(result::result<tcp_socket, tcp_err_data>)) {\n     let new_conn_po = (**server_port).new_conn_po;\n     let iotask = (**server_port).iotask;\n     let new_conn_result = comm::recv(new_conn_po);\n@@ -681,8 +681,8 @@ of listen exiting because of an error\n fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n-          new_connect_cb: fn~(tcp_new_connection,\n-                              comm::chan<option<tcp_err_data>>))\n+          +new_connect_cb: fn~(tcp_new_connection,\n+                               comm::chan<option<tcp_err_data>>))\n     -> result::result<(), tcp_err_data> unsafe {\n     let stream_closed_po = comm::port::<()>();\n     let kill_po = comm::port::<option<tcp_err_data>>();\n@@ -773,7 +773,7 @@ Convenience methods extending `net::tcp::tcp_conn_port`\n \"]\n impl conn_port_methods for tcp_conn_port {\n     fn recv() -> result::result<tcp_socket, tcp_err_data> { conn_recv(self) }\n-    fn recv_spawn(cb: fn~(result::result<tcp_socket,tcp_err_data>))\n+    fn recv_spawn(+cb: fn~(result::result<tcp_socket,tcp_err_data>))\n                   { conn_recv_spawn(self, cb); }\n     fn peek() -> bool { conn_peek(self) }\n }"}, {"sha": "2325a9cd3fb0637001c1d5d00427a8c4e0d92761", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -58,7 +58,7 @@ fn sha1() -> sha1 {\n          msg_block: [mut u8],\n          mut msg_block_idx: uint,\n          mut computed: bool,\n-         work_buf: [mut u32]};\n+         work_buf: @[mut u32]};\n \n     fn add_input(st: sha1state, msg: [u8]) {\n         /* FIXME: Should be typestate precondition (#2345) */\n@@ -71,7 +71,6 @@ fn sha1() -> sha1 {\n                 st.len_high += 1u32;\n                 if st.len_high == 0u32 {\n                     // FIXME: Need better failure mode (#2346)\n-\n                     fail;\n                 }\n             }\n@@ -81,7 +80,7 @@ fn sha1() -> sha1 {\n     fn process_msg_block(st: sha1state) {\n         // FIXME: Make precondition (#2345)\n         assert (vec::len(st.h) == digest_buf_len);\n-        assert (vec::len(st.work_buf) == work_buf_len);\n+        assert (vec::len(*st.work_buf) == work_buf_len);\n         let mut t: int; // Loop counter\n         let w = st.work_buf;\n \n@@ -249,7 +248,7 @@ fn sha1() -> sha1 {\n         msg_block: vec::to_mut(vec::from_elem(msg_block_len, 0u8)),\n         mut msg_block_idx: 0u,\n         mut computed: false,\n-        work_buf: vec::to_mut(vec::from_elem(work_buf_len, 0u32))\n+        work_buf: @vec::to_mut(vec::from_elem(work_buf_len, 0u32))\n     };\n     let sh = st as sha1;\n     sh.reset();"}, {"sha": "3b4d007d989b036e5b4c596796968949dd53e012", "filename": "src/libstd/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -58,7 +58,7 @@ fn test_main(args: [str], tests: [test_desc]) {\n }\n \n type test_opts = {filter: option<str>, run_ignored: bool,\n-    logfile: option<str>};\n+                  logfile: option<str>};\n \n type opt_res = either<test_opts, str>;\n \n@@ -81,7 +81,7 @@ fn parse_opts(args: [str]) -> opt_res {\n     let logfile = getopts::opt_maybe_str(match, \"logfile\");\n \n     let test_opts = {filter: filter, run_ignored: run_ignored,\n-        logfile: logfile};\n+                     logfile: logfile};\n \n     ret either::left(test_opts);\n }\n@@ -126,7 +126,7 @@ fn run_tests_console(opts: test_opts,\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(\"\");\n-                st.failures += [test];\n+                st.failures += [copy test];\n               }\n               tr_ignored {\n                 st.ignored += 1u;\n@@ -273,7 +273,7 @@ fn run_tests(opts: test_opts, tests: [test_desc],\n              callback: fn@(testevent)) {\n \n     let mut filtered_tests = filter_tests(opts, tests);\n-    callback(te_filtered(filtered_tests));\n+    callback(te_filtered(copy filtered_tests));\n \n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n@@ -295,7 +295,7 @@ fn run_tests(opts: test_opts, tests: [test_desc],\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(te_wait(test));\n+                callback(te_wait(copy test));\n             }\n             run_test(test, ch);\n             wait_idx += 1u;\n@@ -304,7 +304,7 @@ fn run_tests(opts: test_opts, tests: [test_desc],\n \n         let (test, result) = comm::recv(p);\n         if concurrency != 1u {\n-            callback(te_wait(test));\n+            callback(te_wait(copy test));\n         }\n         callback(te_result(test, result));\n         wait_idx -= 1u;\n@@ -329,7 +329,7 @@ fn get_concurrency() -> uint {\n \n fn filter_tests(opts: test_opts,\n                 tests: [test_desc]) -> [test_desc] {\n-    let mut filtered = tests;\n+    let mut filtered = copy tests;\n \n     // Remove tests that don't match the test filter\n     filtered = if option::is_none(opts.filter) {\n@@ -344,7 +344,7 @@ fn filter_tests(opts: test_opts,\n         fn filter_fn(test: test_desc, filter_str: str) ->\n             option<test_desc> {\n             if str::contains(test.name, filter_str) {\n-                ret option::some(test);\n+                ret option::some(copy test);\n             } else { ret option::none; }\n         }\n \n@@ -360,7 +360,7 @@ fn filter_tests(opts: test_opts,\n         fn filter(test: test_desc) -> option<test_desc> {\n             if test.ignore {\n                 ret option::some({name: test.name,\n-                                  fn: test.fn,\n+                                  fn: copy test.fn,\n                                   ignore: false,\n                                   should_fail: test.should_fail});\n             } else { ret option::none; }\n@@ -385,19 +385,19 @@ type test_future = {test: test_desc, wait: fn@() -> test_result};\n \n fn run_test(+test: test_desc, monitor_ch: comm::chan<monitor_msg>) {\n     if test.ignore {\n-        comm::send(monitor_ch, (test, tr_ignored));\n+        comm::send(monitor_ch, (copy test, tr_ignored));\n         ret;\n     }\n \n     task::spawn {||\n-        let testfn = test.fn;\n+        let testfn = copy test.fn;\n         let mut builder = task::builder();\n         let result_future = task::future_result(builder);\n         task::unsupervise(builder);\n         task::run(builder, testfn);\n         let task_result = future::get(result_future);\n         let test_result = calc_result(test, task_result == task::success);\n-        comm::send(monitor_ch, (test, test_result));\n+        comm::send(monitor_ch, (copy test, test_result));\n     };\n }\n "}, {"sha": "a42546cf7ecd2f2a104cd88678e3fba19b35a5e3", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -624,11 +624,10 @@ unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                       addr_ptr: *sockaddr_in,\n                       ++after_connect_cb: *u8)\n -> libc::c_int {\n-    let address = *addr_ptr;\n     log(debug, #fmt(\"b4 native tcp_connect--addr port: %u cb: %u\",\n-                     address.sin_port as uint, after_connect_cb as uint));\n+                    (*addr_ptr).sin_port as uint, after_connect_cb as uint));\n     ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n-                                after_connect_cb, addr_ptr);\n+                                    after_connect_cb, addr_ptr);\n }\n // FIXME ref #2064\n unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t,\n@@ -1420,4 +1419,4 @@ mod test {\n         log(debug, output);\n         assert native_handle_size as uint == rust_handle_size;\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a4810d36a8e246d543452295cad33c1fdb32556b", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -200,7 +200,7 @@ diagnostic emitter which records when we hit a fatal error. If the task\n fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n-fn monitor(f: fn~(diagnostic::emitter)) {\n+fn monitor(+f: fn~(diagnostic::emitter)) {\n     enum monitor_msg {\n         fatal,\n         done,"}, {"sha": "56a1371d2895761857690bc770ca8be3c2a4ea9f", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -552,7 +552,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                      index: @mut [entry<int>]) {\n         *index += [{val: item.id, pos: ebml_w.writer.tell()}];\n     }\n-    let add_to_index = bind add_to_index_(item, ebml_w, index);\n+    let add_to_index = bind add_to_index_(item, copy ebml_w, index);\n \n     alt item.node {\n       item_const(_, _) {\n@@ -796,7 +796,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                         crate_node_id, [], \"\");\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n         visit_expr: {|_e, _cx, _v|},\n-        visit_item: {|i, cx, v|\n+        visit_item: {|i, cx, v, copy ebml_w|\n             visit::visit_item(i, cx, v);\n             alt check ecx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) {\n@@ -820,7 +820,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n               }\n             }\n         },\n-        visit_native_item: {|ni, cx, v|\n+        visit_native_item: {|ni, cx, v, copy ebml_w|\n             visit::visit_native_item(ni, cx, v);\n             alt check ecx.tcx.items.get(ni.id) {\n               ast_map::node_native_item(_, abi, pt) {"}, {"sha": "5a43611b2761cb5500c43f60f955a72bab62ca8d", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -725,7 +725,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              ebml_w: ebml::writer,\n                              ii: ast::inlined_item) {\n     ebml_w.wr_tag(c::tag_table as uint) {||\n-        visit_ids(ii, fn@(id: ast::node_id) {\n+        visit_ids(ii, fn@(id: ast::node_id, copy ebml_w) {\n             // Note: this will cause a copy of ebml_w, which is bad as\n             // it has mut fields.  But I believe it's harmless since\n             // we generate balanced EBML."}, {"sha": "c51df5bd391b0429b7a3de69dfa8cecc07140faa", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -1481,7 +1481,7 @@ fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n     alt inf.index.find(id) {\n       none { }\n       some(lst) {\n-        let found = list_search(lst, bind lookup_in_mie(e, _, ns));\n+        let found = list_search(lst, {|x| lookup_in_mie(e, x, ns)});\n         if !is_none(found) {\n             ret found;\n         }\n@@ -1511,7 +1511,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n         }\n     }\n     let matches = vec::filter_map(copy globs,\n-                                  bind lookup_in_mod_(e, _, sp, id, ns, dr));\n+                                  {|x| lookup_in_mod_(e, x, sp, id, ns, dr)});\n     if vec::len(matches) == 0u {\n         ret none;\n         }"}, {"sha": "c4fc1b6f333f228ddef006fb54fb256ebf656f56", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -4020,7 +4020,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block(cx: fn_ctxt, parent: block_parent, kind: block_kind,\n+fn new_block(cx: fn_ctxt, parent: block_parent, +kind: block_kind,\n              name: str, opt_node_info: option<node_info>) -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {"}, {"sha": "8c5a0d23b4256f42f1fa1beaa1f7790b4fdbd29f", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -56,7 +56,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     }\n \n     if fn_id_loc.crate != local_crate {\n-        let uses = vec::from_mut(cx.uses);\n+        let uses = vec::from_mut(copy cx.uses);\n         ccx.type_use_cache.insert(fn_id, uses);\n         ret uses;\n     }\n@@ -95,7 +95,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       }\n \n     }\n-    let uses = vec::from_mut(cx.uses);\n+    let uses = vec::from_mut(copy cx.uses);\n     ccx.type_use_cache.insert(fn_id, uses);\n     uses\n }"}, {"sha": "ebe0d108f4da8f5f8a1e45b924b7b9c4761661d3", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -56,7 +56,7 @@ fn from_file<T>(file: str, owner: srv_owner<T>) -> T {\n     run(owner, file, parse::from_file_sess)\n }\n \n-fn run<T>(owner: srv_owner<T>, source: str, parse: parser) -> T {\n+fn run<T>(owner: srv_owner<T>, source: str, +parse: parser) -> T {\n \n     let srv_ = srv({\n         ch: task::spawn_listener {|po|"}, {"sha": "9f1fc9fdc22b72ffed257cf71ffdb04406ce4673", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -90,7 +90,7 @@ fn fold_item(\n fn parse_item_attrs<T:send>(\n     srv: astsrv::srv,\n     id: doc::ast_id,\n-    parse_attrs: fn~([ast::attribute]) -> T) -> T {\n+    +parse_attrs: fn~([ast::attribute]) -> T) -> T {\n     astsrv::exec(srv) {|ctxt|\n         let attrs = alt ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) { item.attrs }"}, {"sha": "02d98164d10f9fb61903d09770a0ab3e5431d57c", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -55,18 +55,18 @@ type t<T> = {\n // initializers, but they do as function arguments\n fn mk_fold<T:copy>(\n     ctxt: T,\n-    fold_doc: fold_doc<T>,\n-    fold_crate: fold_crate<T>,\n-    fold_item: fold_item<T>,\n-    fold_mod: fold_mod<T>,\n-    fold_nmod: fold_nmod<T>,\n-    fold_fn: fold_fn<T>,\n-    fold_const: fold_const<T>,\n-    fold_enum: fold_enum<T>,\n-    fold_res: fold_res<T>,\n-    fold_iface: fold_iface<T>,\n-    fold_impl: fold_impl<T>,\n-    fold_type: fold_type<T>\n+    +fold_doc: fold_doc<T>,\n+    +fold_crate: fold_crate<T>,\n+    +fold_item: fold_item<T>,\n+    +fold_mod: fold_mod<T>,\n+    +fold_nmod: fold_nmod<T>,\n+    +fold_fn: fold_fn<T>,\n+    +fold_const: fold_const<T>,\n+    +fold_enum: fold_enum<T>,\n+    +fold_res: fold_res<T>,\n+    +fold_iface: fold_iface<T>,\n+    +fold_impl: fold_impl<T>,\n+    +fold_type: fold_type<T>\n ) -> fold<T> {\n     fold({\n         ctxt: ctxt,\n@@ -177,7 +177,7 @@ fn default_any_fold_mod<T:send copy>(\n ) -> doc::moddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        items: par::anymap(doc.items) {|itemtag|\n+        items: par::anymap(doc.items) {|itemtag, copy fold|\n             fold_itemtag(fold, itemtag)\n         }\n         with doc\n@@ -203,7 +203,7 @@ fn default_par_fold_mod<T:send copy>(\n ) -> doc::moddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        items: par::parmap(doc.items) {|itemtag|\n+        items: par::parmap(doc.items) {|itemtag, copy fold|\n             fold_itemtag(fold, itemtag)\n         }\n         with doc\n@@ -216,7 +216,7 @@ fn default_any_fold_nmod<T:send copy>(\n ) -> doc::nmoddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::anymap(doc.fns) {|fndoc|\n+        fns: par::anymap(doc.fns) {|fndoc, copy fold|\n             fold.fold_fn(fold, fndoc)\n         }\n         with doc\n@@ -242,7 +242,7 @@ fn default_par_fold_nmod<T:send copy>(\n ) -> doc::nmoddoc {\n     {\n         item: fold.fold_item(fold, doc.item),\n-        fns: par::parmap(doc.fns) {|fndoc|\n+        fns: par::parmap(doc.fns) {|fndoc, copy fold|\n             fold.fold_fn(fold, fndoc)\n         }\n         with doc"}, {"sha": "b98690f4fd9fcc9048e32a5a4458412a76dfdce1", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -7,9 +7,9 @@ import markdown_writer::writer_factory;\n export mk_pass;\n export header_kind, header_name, header_text;\n \n-fn mk_pass(writer_factory: writer_factory) -> pass {\n+fn mk_pass(+writer_factory: writer_factory) -> pass {\n     let f = fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n-        run(srv, doc, writer_factory)\n+        run(srv, doc, copy writer_factory)\n     };\n \n     {\n@@ -21,7 +21,7 @@ fn mk_pass(writer_factory: writer_factory) -> pass {\n fn run(\n     srv: astsrv::srv,\n     doc: doc::doc,\n-    writer_factory: writer_factory\n+    +writer_factory: writer_factory\n ) -> doc::doc {\n \n     fn mods_last(item1: doc::itemtag, item2: doc::itemtag) -> bool {\n@@ -80,7 +80,7 @@ type ctxt = {\n \n fn write_markdown(\n     doc: doc::doc,\n-    writer_factory: writer_factory\n+    +writer_factory: writer_factory\n ) {\n     par::anymap(doc.pages) {|page|\n         let ctxt = {"}, {"sha": "6d3e02edb8994153cd7d18d6d5f089617b743b6c", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -136,7 +136,7 @@ fn readclose(fd: libc::c_int) -> str {\n     ret buf;\n }\n \n-fn generic_writer(process: fn~(markdown: str)) -> writer {\n+fn generic_writer(+process: fn~(markdown: str)) -> writer {\n     let ch = task::spawn_listener {|po: comm::port<writeinstr>|\n         let mut markdown = \"\";\n         let mut keep_going = true;"}, {"sha": "38fb3ca51a782b89277f368f7fdaebc45ffad492", "filename": "src/rustdoc/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpar.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -13,7 +13,7 @@ fn parmap<T:send, U:send>(v: [T], f: fn~(T) -> U) -> [U] unsafe {\n         let po = comm::port();\n         let ch = comm::chan(po);\n         let addr = ptr::addr_of(elt);\n-        task::spawn {||\n+        task::spawn {|copy f|\n             comm::send(ch, f(*addr));\n         }\n         po\n@@ -28,4 +28,4 @@ fn test_parallel_map() {\n     let i = [1, 2, 3, 4];\n     let j = parmap(i) {|e| e + 1 };\n     assert j == [2, 3, 4, 5];\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ff1da28a2855b4a25f8d340a5331c5e5850d6655", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -6,7 +6,7 @@ export item_lteq, mk_pass;\n \n type item_lteq = fn~(doc::itemtag, doc::itemtag) -> bool;\n \n-fn mk_pass(name: str, lteq: item_lteq) -> pass {\n+fn mk_pass(name: str, +lteq: item_lteq) -> pass {\n     {\n         name: name,\n         f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {"}, {"sha": "689e4b16b32450bb5a11edf8891728128add1d32", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -2,7 +2,7 @@\n \n export mk_pass;\n \n-fn mk_pass(name: str, op: fn~(str) -> str) -> pass {\n+fn mk_pass(name: str, +op: fn~(str) -> str) -> pass {\n     {\n         name: name,\n         f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n@@ -44,7 +44,7 @@ fn fold_item(fold: fold::fold<op>, doc: doc::itemdoc) -> doc::itemdoc {\n }\n \n fn apply_to_sections(op: op, sections: [doc::section]) -> [doc::section] {\n-    par::anymap(sections) {|section|\n+    par::anymap(sections) {|section, copy op|\n         {\n             header: op(section.header),\n             body: op(section.body)\n@@ -53,13 +53,12 @@ fn apply_to_sections(op: op, sections: [doc::section]) -> [doc::section] {\n }\n \n fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n-    let fold_ctxt = fold.ctxt;\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     {\n-        variants: par::anymap(doc.variants) {|variant|\n+        variants: par::anymap(doc.variants) {|variant, copy fold|\n             {\n-                desc: maybe_apply_op(fold_ctxt, variant.desc)\n+                desc: maybe_apply_op(fold.ctxt, variant.desc)\n                 with variant\n             }\n         }\n@@ -77,7 +76,7 @@ fn fold_iface(fold: fold::fold<op>, doc: doc::ifacedoc) -> doc::ifacedoc {\n }\n \n fn apply_to_methods(op: op, docs: [doc::methoddoc]) -> [doc::methoddoc] {\n-    par::anymap(docs) {|doc|\n+    par::anymap(docs) {|doc, copy op|\n         {\n             brief: maybe_apply_op(op, doc.brief),\n             desc: maybe_apply_op(op, doc.desc),\n@@ -273,4 +272,4 @@ mod test {\n             mk_pass(\"\", {|s| str::trim(s)}).f(srv, doc)\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "73ce1f22be708455cec418a648d7654299799cfc", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8668d06400710f9d99d1b39da847031dc3d78394/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8668d06400710f9d99d1b39da847031dc3d78394/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=8668d06400710f9d99d1b39da847031dc3d78394", "patch": "@@ -49,4 +49,4 @@ fn main(args: [str]) {\n     let token = int::from_str(args[1]).get();\n \n     start(token);\n-}\n\\ No newline at end of file\n+}"}]}