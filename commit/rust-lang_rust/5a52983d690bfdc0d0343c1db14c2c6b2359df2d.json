{"sha": "5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNTI5ODNkNjkwYmZkYzBkMDM0M2MxZGIxNGMyYzZiMjM1OWRmMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-15T16:46:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-15T16:46:55Z"}, "message": "Auto merge of #54858 - nikomatsakis:universes-refactor-2, r=scalexm\n\nsecond round of refactorings for universes\n\nA second round of (what I believe to be) \"no functional change\" refactorings, taken from my universes branch.\n\nr? @scalexm", "tree": {"sha": "1662f8e6bf7862a5f426cff9725286a27262444d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1662f8e6bf7862a5f426cff9725286a27262444d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "html_url": "https://github.com/rust-lang/rust/commit/5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f9b581f71810744069228f86242e6ba00b7d09c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f9b581f71810744069228f86242e6ba00b7d09c", "html_url": "https://github.com/rust-lang/rust/commit/4f9b581f71810744069228f86242e6ba00b7d09c"}, {"sha": "05f67ca1a27a9e69cd99d540a0241759b83cc1bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/05f67ca1a27a9e69cd99d540a0241759b83cc1bd", "html_url": "https://github.com/rust-lang/rust/commit/05f67ca1a27a9e69cd99d540a0241759b83cc1bd"}], "stats": {"total": 1037, "additions": 536, "deletions": 501}, "files": [{"sha": "dd2c41dda640300ca78b72ed743bba2320dd9e58", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -1297,7 +1297,7 @@ impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {\n });\n \n impl_stable_hash_for!(\n-    impl<'tcx, R> for struct infer::canonical::QueryResult<'tcx, R> {\n+    impl<'tcx, R> for struct infer::canonical::QueryResponse<'tcx, R> {\n         var_values, region_constraints, certainty, value\n     }\n );"}, {"sha": "8c87c2a01c04fff99a3fe16ccc06ac3a71dfc5e9", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 117, "deletions": 84, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -17,7 +17,7 @@\n \n use infer::canonical::{\n     Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, Canonicalized,\n-    SmallCanonicalVarValues,\n+    OriginalQueryValues,\n };\n use infer::InferCtxt;\n use std::sync::atomic::Ordering;\n@@ -48,7 +48,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn canonicalize_query<V>(\n         &self,\n         value: &V,\n-        var_values: &mut SmallCanonicalVarValues<'tcx>\n+        query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'gcx, V>\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n@@ -63,11 +63,8 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             value,\n             Some(self),\n             self.tcx,\n-            CanonicalizeRegionMode {\n-                static_region: true,\n-                other_free_regions: true,\n-            },\n-            var_values,\n+            &CanonicalizeAllFreeRegions,\n+            query_state,\n         )\n     }\n \n@@ -96,23 +93,17 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// out the [chapter in the rustc guide][c].\n     ///\n     /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query-result\n-    pub fn canonicalize_response<V>(\n-        &self,\n-        value: &V,\n-    ) -> Canonicalized<'gcx, V>\n+    pub fn canonicalize_response<V>(&self, value: &V) -> Canonicalized<'gcx, V>\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n     {\n-        let mut var_values = SmallVec::new();\n+        let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n             value,\n             Some(self),\n             self.tcx,\n-            CanonicalizeRegionMode {\n-                static_region: false,\n-                other_free_regions: false,\n-            },\n-            &mut var_values\n+            &CanonicalizeQueryResponse,\n+            &mut query_state,\n         )\n     }\n \n@@ -128,7 +119,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n         value: &V,\n-        var_values: &mut SmallCanonicalVarValues<'tcx>\n+        query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'gcx, V>\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n@@ -143,39 +134,99 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             value,\n             Some(self),\n             self.tcx,\n-            CanonicalizeRegionMode {\n-                static_region: false,\n-                other_free_regions: true,\n-            },\n-            var_values\n+            &CanonicalizeFreeRegionsOtherThanStatic,\n+            query_state,\n         )\n     }\n }\n \n-/// If this flag is true, then all free regions will be replaced with\n-/// a canonical var. This is used to make queries as generic as\n-/// possible. For example, the query `F: Foo<'static>` would be\n-/// canonicalized to `F: Foo<'0>`.\n-struct CanonicalizeRegionMode {\n-    static_region: bool,\n-    other_free_regions: bool,\n+/// Controls how we canonicalize \"free regions\" that are not inference\n+/// variables. This depends on what we are canonicalizing *for* --\n+/// e.g., if we are canonicalizing to create a query, we want to\n+/// replace those with inference variables, since we want to make a\n+/// maximally general query. But if we are canonicalizing a *query\n+/// response*, then we don't typically replace free regions, as they\n+/// must have been introduced from other parts of the system.\n+trait CanonicalizeRegionMode {\n+    fn canonicalize_free_region(\n+        &self,\n+        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx>;\n+\n+    fn any(&self) -> bool;\n+}\n+\n+struct CanonicalizeQueryResponse;\n+\n+impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n+    fn canonicalize_free_region(\n+        &self,\n+        _canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        match r {\n+            ty::ReFree(_) | ty::ReEmpty | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n+            _ => {\n+                // Other than `'static` or `'empty`, the query\n+                // response should be executing in a fully\n+                // canonicalized environment, so there shouldn't be\n+                // any other region names it can come up.\n+                bug!(\"unexpected region in query response: `{:?}`\", r)\n+            }\n+        }\n+    }\n+\n+    fn any(&self) -> bool {\n+        false\n+    }\n }\n \n-impl CanonicalizeRegionMode {\n+struct CanonicalizeAllFreeRegions;\n+\n+impl CanonicalizeRegionMode for CanonicalizeAllFreeRegions {\n+    fn canonicalize_free_region(\n+        &self,\n+        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        canonicalizer.canonical_var_for_region(r)\n+    }\n+\n     fn any(&self) -> bool {\n-        self.static_region || self.other_free_regions\n+        true\n+    }\n+}\n+\n+struct CanonicalizeFreeRegionsOtherThanStatic;\n+\n+impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n+    fn canonicalize_free_region(\n+        &self,\n+        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        if let ty::ReStatic = r {\n+            r\n+        } else {\n+            canonicalizer.canonical_var_for_region(r)\n+        }\n+    }\n+\n+    fn any(&self) -> bool {\n+        true\n     }\n }\n \n struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     variables: SmallVec<[CanonicalVarInfo; 8]>,\n-    var_values: &'cx mut SmallCanonicalVarValues<'tcx>,\n+    query_state: &'cx mut OriginalQueryValues<'tcx>,\n     // Note that indices is only used once `var_values` is big enough to be\n     // heap-allocated.\n     indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n-    canonicalize_region_mode: CanonicalizeRegionMode,\n+    canonicalize_region_mode: &'cx dyn CanonicalizeRegionMode,\n     needs_canonical_flags: TypeFlags,\n }\n \n@@ -192,51 +243,25 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n             }\n \n             ty::ReVar(vid) => {\n-                let r = self\n-                    .infcx\n+                let r = self.infcx\n                     .unwrap()\n                     .borrow_region_constraints()\n                     .opportunistic_resolve_var(self.tcx, vid);\n-                let info = CanonicalVarInfo {\n-                    kind: CanonicalVarKind::Region,\n-                };\n                 debug!(\n                     \"canonical: region var found with vid {:?}, \\\n                      opportunistically resolved to {:?}\",\n                     vid, r\n                 );\n-                let cvar = self.canonical_var(info, r.into());\n-                self.tcx().mk_region(ty::ReCanonical(cvar))\n-            }\n-\n-            ty::ReStatic => {\n-                if self.canonicalize_region_mode.static_region {\n-                    let info = CanonicalVarInfo {\n-                        kind: CanonicalVarKind::Region,\n-                    };\n-                    let cvar = self.canonical_var(info, r.into());\n-                    self.tcx().mk_region(ty::ReCanonical(cvar))\n-                } else {\n-                    r\n-                }\n+                self.canonical_var_for_region(r)\n             }\n \n-            ty::ReEarlyBound(..)\n+            ty::ReStatic\n+            | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReScope(_)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty\n-            | ty::ReErased => {\n-                if self.canonicalize_region_mode.other_free_regions {\n-                    let info = CanonicalVarInfo {\n-                        kind: CanonicalVarKind::Region,\n-                    };\n-                    let cvar = self.canonical_var(info, r.into());\n-                    self.tcx().mk_region(ty::ReCanonical(cvar))\n-                } else {\n-                    r\n-                }\n-            }\n+            | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n \n             ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n                 bug!(\"canonical region encountered during canonicalization\")\n@@ -302,10 +327,10 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     /// `canonicalize_query` and `canonicalize_response`.\n     fn canonicalize<V>(\n         value: &V,\n-        infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        canonicalize_region_mode: CanonicalizeRegionMode,\n-        var_values: &'cx mut SmallCanonicalVarValues<'tcx>\n+        infcx: Option<&InferCtxt<'_, 'gcx, 'tcx>>,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalize_region_mode: &dyn CanonicalizeRegionMode,\n+        query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'gcx, V>\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n@@ -340,7 +365,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             canonicalize_region_mode,\n             needs_canonical_flags,\n             variables: SmallVec::new(),\n-            var_values,\n+            query_state,\n             indices: FxHashMap::default(),\n         };\n         let out_value = value.fold_with(&mut canonicalizer);\n@@ -371,11 +396,13 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n         let Canonicalizer {\n             variables,\n-            var_values,\n+            query_state,\n             indices,\n             ..\n         } = self;\n \n+        let var_values = &mut query_state.var_values;\n+\n         // This code is hot. `variables` and `var_values` are usually small\n         // (fewer than 8 elements ~95% of the time). They are SmallVec's to\n         // avoid allocations in those cases. We also don't use `indices` to\n@@ -398,28 +425,34 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n                 // fill up `indices` to facilitate subsequent lookups.\n                 if var_values.spilled() {\n                     assert!(indices.is_empty());\n-                    *indices =\n-                        var_values.iter()\n-                            .enumerate()\n-                            .map(|(i, &kind)| (kind, CanonicalVar::new(i)))\n-                            .collect();\n+                    *indices = var_values\n+                        .iter()\n+                        .enumerate()\n+                        .map(|(i, &kind)| (kind, CanonicalVar::new(i)))\n+                        .collect();\n                 }\n                 // The cv is the index of the appended element.\n                 CanonicalVar::new(var_values.len() - 1)\n             }\n         } else {\n             // `var_values` is large. Do a hashmap search via `indices`.\n-            *indices\n-                .entry(kind)\n-                .or_insert_with(|| {\n-                    variables.push(info);\n-                    var_values.push(kind);\n-                    assert_eq!(variables.len(), var_values.len());\n-                    CanonicalVar::new(variables.len() - 1)\n-                })\n+            *indices.entry(kind).or_insert_with(|| {\n+                variables.push(info);\n+                var_values.push(kind);\n+                assert_eq!(variables.len(), var_values.len());\n+                CanonicalVar::new(variables.len() - 1)\n+            })\n         }\n     }\n \n+    fn canonical_var_for_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let info = CanonicalVarInfo {\n+            kind: CanonicalVarKind::Region,\n+        };\n+        let cvar = self.canonical_var(info, r.into());\n+        self.tcx().mk_region(ty::ReCanonical(cvar))\n+    }\n+\n     /// Given a type variable `ty_var` of the given kind, first check\n     /// if `ty_var` is bound to anything; if so, canonicalize\n     /// *that*. Otherwise, create a new canonical variable for"}, {"sha": "a78b5b7d072644f91a10189cc20dbd246d39cf05", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -44,7 +44,7 @@ use ty::{self, CanonicalVar, Lift, Region, List, TyCtxt};\n \n mod canonicalizer;\n \n-pub mod query_result;\n+pub mod query_response;\n \n mod substitute;\n \n@@ -75,9 +75,16 @@ pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n }\n \n-/// Like CanonicalVarValues, but for use in places where a SmallVec is\n-/// appropriate.\n-pub type SmallCanonicalVarValues<'tcx> = SmallVec<[Kind<'tcx>; 8]>;\n+/// When we canonicalize a value to form a query, we wind up replacing\n+/// various parts of it with canonical variables. This struct stores\n+/// those replaced bits to remember for when we process the query\n+/// result.\n+#[derive(Clone, Debug, Default, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+pub struct OriginalQueryValues<'tcx> {\n+    /// This is equivalent to `CanonicalVarValues`, but using a\n+    /// `SmallVec` yields a significant performance win.\n+    pub var_values: SmallVec<[Kind<'tcx>; 8]>,\n+}\n \n /// Information about a canonical variable that is included with the\n /// canonical value. This is sufficient information for code to create\n@@ -118,10 +125,10 @@ pub enum CanonicalTyVarKind {\n }\n \n /// After we execute a query with a canonicalized key, we get back a\n-/// `Canonical<QueryResult<..>>`. You can use\n+/// `Canonical<QueryResponse<..>>`. You can use\n /// `instantiate_query_result` to access the data in this result.\n #[derive(Clone, Debug)]\n-pub struct QueryResult<'tcx, R> {\n+pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n     pub region_constraints: Vec<QueryRegionConstraint<'tcx>>,\n     pub certainty: Certainty,\n@@ -130,8 +137,8 @@ pub struct QueryResult<'tcx, R> {\n \n pub type Canonicalized<'gcx, V> = Canonical<'gcx, <V as Lift<'gcx>>::Lifted>;\n \n-pub type CanonicalizedQueryResult<'gcx, T> =\n-    Lrc<Canonical<'gcx, QueryResult<'gcx, <T as Lift<'gcx>>::Lifted>>>;\n+pub type CanonicalizedQueryResponse<'gcx, T> =\n+    Lrc<Canonical<'gcx, QueryResponse<'gcx, <T as Lift<'gcx>>::Lifted>>>;\n \n /// Indicates whether or not we were able to prove the query to be\n /// true.\n@@ -168,7 +175,7 @@ impl Certainty {\n     }\n }\n \n-impl<'tcx, R> QueryResult<'tcx, R> {\n+impl<'tcx, R> QueryResponse<'tcx, R> {\n     pub fn is_proven(&self) -> bool {\n         self.certainty.is_proven()\n     }\n@@ -178,7 +185,7 @@ impl<'tcx, R> QueryResult<'tcx, R> {\n     }\n }\n \n-impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n+impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {\n     pub fn is_proven(&self) -> bool {\n         self.value.is_proven()\n     }\n@@ -225,19 +232,26 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// inference variables and applies it to the canonical value.\n     /// Returns both the instantiated result *and* the substitution S.\n     ///\n-    /// This is useful at the start of a query: it basically brings\n-    /// the canonical value \"into scope\" within your new infcx. At the\n-    /// end of processing, the substitution S (once canonicalized)\n-    /// then represents the values that you computed for each of the\n-    /// canonical inputs to your query.\n-    pub fn instantiate_canonical_with_fresh_inference_vars<T>(\n+    /// This is only meant to be invoked as part of constructing an\n+    /// inference context at the start of a query (see\n+    /// `InferCtxtBuilder::enter_with_canonical`).  It basically\n+    /// brings the canonical value \"into scope\" within your new infcx.\n+    ///\n+    /// At the end of processing, the substitution S (once\n+    /// canonicalized) then represents the values that you computed\n+    /// for each of the canonical inputs to your query.\n+\n+    pub(in infer) fn instantiate_canonical_with_fresh_inference_vars<T>(\n         &self,\n         span: Span,\n         canonical: &Canonical<'tcx, T>,\n     ) -> (T, CanonicalVarValues<'tcx>)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n+        assert_eq!(self.universe(), ty::UniverseIndex::ROOT, \"infcx not newly created\");\n+        assert_eq!(self.type_variables.borrow().num_vars(), 0, \"infcx not newly created\");\n+\n         let canonical_inference_vars =\n             self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n         let result = canonical.substitute(self.tcx, &canonical_inference_vars);\n@@ -344,14 +358,14 @@ BraceStructTypeFoldableImpl! {\n }\n \n BraceStructTypeFoldableImpl! {\n-    impl<'tcx, R> TypeFoldable<'tcx> for QueryResult<'tcx, R> {\n+    impl<'tcx, R> TypeFoldable<'tcx> for QueryResponse<'tcx, R> {\n         var_values, region_constraints, certainty, value\n     } where R: TypeFoldable<'tcx>,\n }\n \n BraceStructLiftImpl! {\n-    impl<'a, 'tcx, R> Lift<'tcx> for QueryResult<'a, R> {\n-        type Lifted = QueryResult<'tcx, R::Lifted>;\n+    impl<'a, 'tcx, R> Lift<'tcx> for QueryResponse<'a, R> {\n+        type Lifted = QueryResponse<'tcx, R::Lifted>;\n         var_values, region_constraints, certainty, value\n     } where R: Lift<'tcx>\n }"}, {"sha": "c29a75c34cf9df0018afaa8a39b89f1583e20285", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "renamed", "additions": 77, "deletions": 69, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -19,8 +19,8 @@\n \n use infer::canonical::substitute::substitute_value;\n use infer::canonical::{\n-    Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResult, Certainty,\n-    QueryRegionConstraint, QueryResult, SmallCanonicalVarValues,\n+    Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResponse, Certainty,\n+    OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n };\n use infer::region_constraints::{Constraint, RegionConstraintData};\n use infer::InferCtxtBuilder;\n@@ -59,18 +59,20 @@ impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n         canonical_key: &Canonical<'tcx, K>,\n         operation: impl FnOnce(&InferCtxt<'_, 'gcx, 'tcx>, &mut FulfillmentContext<'tcx>, K)\n             -> Fallible<R>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, R>>\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n     {\n-        self.enter(|ref infcx| {\n-            let (key, canonical_inference_vars) =\n-                infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_key);\n-            let fulfill_cx = &mut FulfillmentContext::new();\n-            let value = operation(infcx, fulfill_cx, key)?;\n-            infcx.make_canonicalized_query_result(canonical_inference_vars, value, fulfill_cx)\n-        })\n+        self.enter_with_canonical(\n+            DUMMY_SP,\n+            canonical_key,\n+            |ref infcx, key, canonical_inference_vars| {\n+                let fulfill_cx = &mut FulfillmentContext::new();\n+                let value = operation(infcx, fulfill_cx, key)?;\n+                infcx.make_canonicalized_query_response(canonical_inference_vars, value, fulfill_cx)\n+            },\n+        )\n     }\n }\n \n@@ -94,41 +96,41 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///   the same thing happens, but the resulting query is marked as ambiguous.\n     /// - Finally, if any of the obligations result in a hard error,\n     ///   then `Err(NoSolution)` is returned.\n-    pub fn make_canonicalized_query_result<T>(\n+    pub fn make_canonicalized_query_response<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n         fulfill_cx: &mut FulfillmentContext<'tcx>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, T>>\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, T>>\n     where\n         T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n     {\n-        let query_result = self.make_query_result(inference_vars, answer, fulfill_cx)?;\n-        let canonical_result = self.canonicalize_response(&query_result);\n+        let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n+        let canonical_result = self.canonicalize_response(&query_response);\n \n         debug!(\n-            \"make_canonicalized_query_result: canonical_result = {:#?}\",\n+            \"make_canonicalized_query_response: canonical_result = {:#?}\",\n             canonical_result\n         );\n \n         Ok(Lrc::new(canonical_result))\n     }\n \n-    /// Helper for `make_canonicalized_query_result` that does\n+    /// Helper for `make_canonicalized_query_response` that does\n     /// everything up until the final canonicalization.\n-    fn make_query_result<T>(\n+    fn make_query_response<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n         fulfill_cx: &mut FulfillmentContext<'tcx>,\n-    ) -> Result<QueryResult<'tcx, T>, NoSolution>\n+    ) -> Result<QueryResponse<'tcx, T>, NoSolution>\n     where\n         T: Debug + TypeFoldable<'tcx> + Lift<'gcx>,\n     {\n         let tcx = self.tcx;\n \n         debug!(\n-            \"make_query_result(\\\n+            \"make_query_response(\\\n              inference_vars={:?}, \\\n              answer={:?})\",\n             inference_vars, answer,\n@@ -140,7 +142,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n         if !true_errors.is_empty() {\n             // FIXME -- we don't indicate *why* we failed to solve\n-            debug!(\"make_query_result: true_errors={:#?}\", true_errors);\n+            debug!(\"make_query_response: true_errors={:#?}\", true_errors);\n             return Err(NoSolution);\n         }\n \n@@ -155,7 +157,8 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 region_obligations\n                     .iter()\n                     .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region)),\n-                region_constraints)\n+                region_constraints,\n+            )\n         });\n \n         let certainty = if ambig_errors.is_empty() {\n@@ -164,7 +167,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             Certainty::Ambiguous\n         };\n \n-        Ok(QueryResult {\n+        Ok(QueryResponse {\n             var_values: inference_vars,\n             region_constraints,\n             certainty,\n@@ -182,30 +185,30 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// out the [chapter in the rustc guide][c].\n     ///\n     /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#processing-the-canonicalized-query-result\n-    pub fn instantiate_query_result_and_region_obligations<R>(\n+    pub fn instantiate_query_response_and_region_obligations<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        original_values: &SmallCanonicalVarValues<'tcx>,\n-        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+        original_values: &OriginalQueryValues<'tcx>,\n+        query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n     ) -> InferResult<'tcx, R>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n         let InferOk {\n             value: result_subst,\n             mut obligations,\n-        } = self.query_result_substitution(cause, param_env, original_values, query_result)?;\n+        } = self.query_response_substitution(cause, param_env, original_values, query_response)?;\n \n         obligations.extend(self.query_region_constraints_into_obligations(\n             cause,\n             param_env,\n-            &query_result.value.region_constraints,\n+            &query_response.value.region_constraints,\n             &result_subst,\n         ));\n \n         let user_result: R =\n-            query_result.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n+            query_response.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n \n         Ok(InferOk {\n             value: user_result,\n@@ -214,7 +217,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// An alternative to\n-    /// `instantiate_query_result_and_region_obligations` that is more\n+    /// `instantiate_query_response_and_region_obligations` that is more\n     /// efficient for NLL. NLL is a bit more advanced in the\n     /// \"transition to chalk\" than the rest of the compiler. During\n     /// the NLL type check, all of the \"processing\" of types and\n@@ -229,8 +232,8 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// into the older infcx-style constraints (e.g., calls to\n     /// `sub_regions` or `register_region_obligation`).\n     ///\n-    /// Therefore, `instantiate_nll_query_result_and_region_obligations` performs the same\n-    /// basic operations as `instantiate_query_result_and_region_obligations` but\n+    /// Therefore, `instantiate_nll_query_response_and_region_obligations` performs the same\n+    /// basic operations as `instantiate_query_response_and_region_obligations` but\n     /// it returns its result differently:\n     ///\n     /// - It creates a substitution `S` that maps from the original\n@@ -248,35 +251,35 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///   are propagated back in the return value.\n     /// - Finally, the query result (of type `R`) is propagated back,\n     ///   after applying the substitution `S`.\n-    pub fn instantiate_nll_query_result_and_region_obligations<R>(\n+    pub fn instantiate_nll_query_response_and_region_obligations<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        original_values: &SmallCanonicalVarValues<'tcx>,\n-        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+        original_values: &OriginalQueryValues<'tcx>,\n+        query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n         output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n     ) -> InferResult<'tcx, R>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n         // In an NLL query, there should be no type variables in the\n         // query, only region variables.\n-        debug_assert!(query_result.variables.iter().all(|v| match v.kind {\n+        debug_assert!(query_response.variables.iter().all(|v| match v.kind {\n             CanonicalVarKind::Ty(_) => false,\n             CanonicalVarKind::Region => true,\n         }));\n \n         let result_subst =\n-            self.query_result_substitution_guess(cause, original_values, query_result);\n+            self.query_response_substitution_guess(cause, original_values, query_response);\n \n         // Compute `QueryRegionConstraint` values that unify each of\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n         let mut obligations = vec![];\n \n-        for (index, original_value) in original_values.iter().enumerate() {\n+        for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n-            let result_value = query_result.substitute_projected(self.tcx, &result_subst, |v| {\n+            let result_value = query_response.substitute_projected(self.tcx, &result_subst, |v| {\n                 &v.var_values[CanonicalVar::new(index)]\n             });\n             match (original_value.unpack(), result_value.unpack()) {\n@@ -311,7 +314,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n         // ...also include the other query region constraints from the query.\n         output_query_region_constraints.extend(\n-            query_result.value.region_constraints.iter().filter_map(|r_c| {\n+            query_response.value.region_constraints.iter().filter_map(|r_c| {\n                 let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n                 let k1 = substitute_value(self.tcx, &result_subst, &k1);\n                 let r2 = substitute_value(self.tcx, &result_subst, &r2);\n@@ -324,7 +327,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let user_result: R =\n-            query_result.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n+            query_response.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n \n         Ok(InferOk {\n             value: user_result,\n@@ -342,30 +345,30 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// example) we are doing lazy normalization and the value\n     /// assigned to a type variable is unified with an unnormalized\n     /// projection.\n-    fn query_result_substitution<R>(\n+    fn query_response_substitution<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        original_values: &SmallCanonicalVarValues<'tcx>,\n-        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+        original_values: &OriginalQueryValues<'tcx>,\n+        query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n     ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n         debug!(\n-            \"query_result_substitution(original_values={:#?}, query_result={:#?})\",\n-            original_values, query_result,\n+            \"query_response_substitution(original_values={:#?}, query_response={:#?})\",\n+            original_values, query_response,\n         );\n \n         let result_subst =\n-            self.query_result_substitution_guess(cause, original_values, query_result);\n+            self.query_response_substitution_guess(cause, original_values, query_response);\n \n-        let obligations = self.unify_query_result_substitution_guess(\n+        let obligations = self.unify_query_response_substitution_guess(\n             cause,\n             param_env,\n             original_values,\n             &result_subst,\n-            query_result,\n+            query_response,\n         )?\n             .into_obligations();\n \n@@ -384,26 +387,26 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// will instantiate fresh inference variables for each canonical\n     /// variable instead. Therefore, the result of this method must be\n     /// properly unified\n-    fn query_result_substitution_guess<R>(\n+    fn query_response_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n-        original_values: &SmallCanonicalVarValues<'tcx>,\n-        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+        original_values: &OriginalQueryValues<'tcx>,\n+        query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n     ) -> CanonicalVarValues<'tcx>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n         debug!(\n-            \"query_result_substitution_guess(original_values={:#?}, query_result={:#?})\",\n-            original_values, query_result,\n+            \"query_response_substitution_guess(original_values={:#?}, query_response={:#?})\",\n+            original_values, query_response,\n         );\n \n         // Every canonical query result includes values for each of\n         // the inputs to the query. Therefore, we begin by unifying\n         // these values with the original inputs that were\n         // canonicalized.\n-        let result_values = &query_result.value.var_values;\n-        assert_eq!(original_values.len(), result_values.len());\n+        let result_values = &query_response.value.var_values;\n+        assert_eq!(original_values.var_values.len(), result_values.len());\n \n         // Quickly try to find initial values for the canonical\n         // variables in the result in terms of the query. We do this\n@@ -413,11 +416,11 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // result, then we can type the corresponding value from the\n         // input. See the example above.\n         let mut opt_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>> =\n-            IndexVec::from_elem_n(None, query_result.variables.len());\n+            IndexVec::from_elem_n(None, query_response.variables.len());\n \n         // In terms of our example above, we are iterating over pairs like:\n         // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n-        for (original_value, result_value) in original_values.iter().zip(result_values) {\n+        for (original_value, result_value) in original_values.var_values.iter().zip(result_values) {\n             match result_value.unpack() {\n                 UnpackedKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above...\n@@ -440,7 +443,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // given variable in the loop above, use that. Otherwise, use\n         // a fresh inference variable.\n         let result_subst = CanonicalVarValues {\n-            var_values: query_result\n+            var_values: query_response\n                 .variables\n                 .iter()\n                 .enumerate()\n@@ -458,29 +461,34 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// query result.  Often, but not always, this is a no-op, because\n     /// we already found the mapping in the \"guessing\" step.\n     ///\n-    /// See also: `query_result_substitution_guess`\n-    fn unify_query_result_substitution_guess<R>(\n+    /// See also: `query_response_substitution_guess`\n+    fn unify_query_response_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        original_values: &SmallCanonicalVarValues<'tcx>,\n+        original_values: &OriginalQueryValues<'tcx>,\n         result_subst: &CanonicalVarValues<'tcx>,\n-        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+        query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n     ) -> InferResult<'tcx, ()>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n         // A closure that yields the result value for the given\n         // canonical variable; this is taken from\n-        // `query_result.var_values` after applying the substitution\n+        // `query_response.var_values` after applying the substitution\n         // `result_subst`.\n-        let substituted_query_result = |index: CanonicalVar| -> Kind<'tcx> {\n-            query_result.substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index])\n+        let substituted_query_response = |index: CanonicalVar| -> Kind<'tcx> {\n+            query_response.substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index])\n         };\n \n         // Unify the original value for each variable with the value\n-        // taken from `query_result` (after applying `result_subst`).\n-        Ok(self.unify_canonical_vars(cause, param_env, original_values, substituted_query_result)?)\n+        // taken from `query_response` (after applying `result_subst`).\n+        Ok(self.unify_canonical_vars(\n+            cause,\n+            param_env,\n+            original_values,\n+            substituted_query_response,\n+        )?)\n     }\n \n     /// Converts the region constraints resulting from a query into an\n@@ -524,12 +532,12 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        variables1: &SmallCanonicalVarValues<'tcx>,\n+        variables1: &OriginalQueryValues<'tcx>,\n         variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n         self.commit_if_ok(|_| {\n             let mut obligations = vec![];\n-            for (index, value1) in variables1.iter().enumerate() {\n+            for (index, value1) in variables1.var_values.iter().enumerate() {\n                 let value2 = variables2(CanonicalVar::new(index));\n \n                 match (value1.unpack(), value2.unpack()) {", "previous_filename": "src/librustc/infer/canonical/query_result.rs"}, {"sha": "ae1892caa744e1b5f8e2453527132de45595587c", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -593,11 +593,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     where\n         T : TypeFoldable<'tcx>,\n     {\n-        let new_universe = self.create_subuniverse();\n+        let next_universe = self.create_next_universe();\n \n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n             self.tcx.mk_region(ty::RePlaceholder(ty::Placeholder {\n-                universe: new_universe,\n+                universe: next_universe,\n                 name: br,\n             }))\n         });"}, {"sha": "ef9886e06d4be51c616beead21cf9aa749c5d7b9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -20,6 +20,7 @@ pub use ty::IntVarValue;\n use arena::SyncDroplessArena;\n use errors::DiagnosticBuilder;\n use hir::def_id::DefId;\n+use infer::canonical::{Canonical, CanonicalVarValues};\n use middle::free_region::RegionRelations;\n use middle::lang_items;\n use middle::region;\n@@ -49,7 +50,6 @@ use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n-pub mod opaque_types;\n pub mod at;\n pub mod canonical;\n mod combine;\n@@ -62,6 +62,7 @@ mod higher_ranked;\n pub mod lattice;\n mod lexical_region_resolve;\n mod lub;\n+pub mod opaque_types;\n pub mod outlives;\n pub mod region_constraints;\n pub mod resolve;\n@@ -86,7 +87,7 @@ pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n /// NLL borrow checker will also do -- it might be set to true.\n #[derive(Copy, Clone, Default, Debug)]\n pub struct SuppressRegionErrors {\n-    suppressed: bool\n+    suppressed: bool,\n }\n \n impl SuppressRegionErrors {\n@@ -100,15 +101,11 @@ impl SuppressRegionErrors {\n     pub fn when_nll_is_enabled(tcx: TyCtxt<'_, '_, '_>) -> Self {\n         match tcx.borrowck_mode() {\n             // If we're on AST or Migrate mode, report AST region errors\n-            BorrowckMode::Ast | BorrowckMode::Migrate => SuppressRegionErrors {\n-                suppressed: false\n-            },\n+            BorrowckMode::Ast | BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n \n             // If we're on MIR or Compare mode, don't report AST region errors as they should\n             // be reported by NLL\n-            BorrowckMode::Compare | BorrowckMode::Mir => SuppressRegionErrors {\n-                suppressed: true\n-            },\n+            BorrowckMode::Compare | BorrowckMode::Mir => SuppressRegionErrors { suppressed: true },\n         }\n     }\n }\n@@ -494,10 +491,30 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         self\n     }\n \n-    pub fn enter<F, R>(&'tcx mut self, f: F) -> R\n+    /// Given a canonical value `C` as a starting point, create an\n+    /// inference context that contains each of the bound values\n+    /// within instantiated as a fresh variable. The `f` closure is\n+    /// invoked with the new infcx, along with the instantiated value\n+    /// `V` and a substitution `S`.  This substitution `S` maps from\n+    /// the bound values in `C` to their instantiated values in `V`\n+    /// (in other words, `S(C) = V`).\n+    pub fn enter_with_canonical<T, R>(\n+        &'tcx mut self,\n+        span: Span,\n+        canonical: &Canonical<'tcx, T>,\n+        f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n+    ) -> R\n     where\n-        F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R,\n+        T: TypeFoldable<'tcx>,\n     {\n+        self.enter(|infcx| {\n+            let (value, subst) =\n+                infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n+            f(infcx, value, subst)\n+        })\n+    }\n+\n+    pub fn enter<R>(&'tcx mut self, f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R) -> R {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref arena,\n@@ -1472,13 +1489,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.universe.get()\n     }\n \n-    /// Create and return a new subunivese of the current universe;\n-    /// update `self.universe` to that new subuniverse. At present,\n-    /// used only in the NLL subtyping code, which uses the new\n-    /// universe-based scheme instead of the more limited leak-check\n-    /// scheme.\n-    pub fn create_subuniverse(&self) -> ty::UniverseIndex {\n-        let u = self.universe.get().subuniverse();\n+    /// Create and return a fresh universe that extends all previous\n+    /// universes. Updates `self.universe` to that new universe.\n+    pub fn create_next_universe(&self) -> ty::UniverseIndex {\n+        let u = self.universe.get().next_universe();\n         self.universe.set(u);\n         u\n     }"}, {"sha": "8f7b0df8b95aa74f157d7cab5b1e42da2bb915d9", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -10,7 +10,7 @@\n \n use infer::at::At;\n use infer::InferOk;\n-use smallvec::SmallVec;\n+use infer::canonical::OriginalQueryValues;\n use std::iter::FromIterator;\n use syntax::source_map::Span;\n use ty::subst::Kind;\n@@ -51,14 +51,14 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n         }\n \n         let gcx = tcx.global_tcx();\n-        let mut orig_values = SmallVec::new();\n+        let mut orig_values = OriginalQueryValues::default();\n         let c_ty = self.infcx.canonicalize_query(&self.param_env.and(ty), &mut orig_values);\n         let span = self.cause.span;\n         debug!(\"c_ty = {:?}\", c_ty);\n         match &gcx.dropck_outlives(c_ty) {\n             Ok(result) if result.is_proven() => {\n                 if let Ok(InferOk { value, obligations }) =\n-                    self.infcx.instantiate_query_result_and_region_obligations(\n+                    self.infcx.instantiate_query_response_and_region_obligations(\n                     self.cause,\n                     self.param_env,\n                     &orig_values,"}, {"sha": "ca11c5f5a08746929b85e7dcf4861d9b2da4ec87", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use infer::InferCtxt;\n-use smallvec::SmallVec;\n+use infer::canonical::OriginalQueryValues;\n use traits::{EvaluationResult, PredicateObligation, SelectionContext,\n              TraitQueryMode, OverflowError};\n \n@@ -38,7 +38,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        let mut _orig_values = SmallVec::new();\n+        let mut _orig_values = OriginalQueryValues::default();\n         let c_pred = self.canonicalize_query(&obligation.param_env.and(obligation.predicate),\n                                              &mut _orig_values);\n         // Run canonical query. If overflow occurs, rerun from scratch but this time"}, {"sha": "4adb65dc58d917de255d7779c109a241ad676b12", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -13,9 +13,9 @@\n //! `normalize_projection_ty` query when it encounters projections.\n \n use infer::at::At;\n+use infer::canonical::OriginalQueryValues;\n use infer::{InferCtxt, InferOk};\n use mir::interpret::{ConstValue, GlobalId};\n-use smallvec::SmallVec;\n use traits::project::Normalized;\n use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -154,7 +154,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n \n                 let gcx = self.infcx.tcx.global_tcx();\n \n-                let mut orig_values = SmallVec::new();\n+                let mut orig_values = OriginalQueryValues::default();\n                 let c_data = self.infcx.canonicalize_query(\n                     &self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n@@ -167,7 +167,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                             return ty;\n                         }\n \n-                        match self.infcx.instantiate_query_result_and_region_obligations(\n+                        match self.infcx.instantiate_query_response_and_region_obligations(\n                             self.cause,\n                             self.param_env,\n                             &orig_values,"}, {"sha": "99f557d44d9aa4e085cad074ed573aa4db34ad72", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use infer::InferCtxt;\n+use infer::canonical::OriginalQueryValues;\n use syntax::ast;\n use syntax::source_map::Span;\n-use smallvec::SmallVec;\n use traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n use traits::query::NoSolution;\n use ty::{self, Ty, TyCtxt};\n@@ -105,7 +105,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ) -> Vec<OutlivesBound<'tcx>> {\n         debug!(\"implied_outlives_bounds(ty = {:?})\", ty);\n \n-        let mut orig_values = SmallVec::new();\n+        let mut orig_values = OriginalQueryValues::default();\n         let key = self.canonicalize_query(&param_env.and(ty), &mut orig_values);\n         let result = match self.tcx.global_tcx().implied_outlives_bounds(key) {\n             Ok(r) => r,\n@@ -119,7 +119,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         };\n         assert!(result.value.is_proven());\n \n-        let result = self.instantiate_query_result_and_region_obligations(\n+        let result = self.instantiate_query_response_and_region_obligations(\n             &ObligationCause::misc(span, body_id), param_env, &orig_values, &result);\n         debug!(\"implied_outlives_bounds for {:?}: {:#?}\", ty, result);\n         let result = match result {"}, {"sha": "54860dd0434a03ce6745bdf6d8b835baf2f20fd0", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -12,7 +12,7 @@ use infer::{InferCtxt, InferOk};\n use std::fmt;\n use traits::query::Fallible;\n \n-use infer::canonical::query_result;\n+use infer::canonical::query_response;\n use infer::canonical::QueryRegionConstraint;\n use std::rc::Rc;\n use syntax::source_map::DUMMY_SP;\n@@ -102,7 +102,7 @@ fn scrape_region_constraints<'gcx, 'tcx, R>(\n \n     let region_constraint_data = infcx.take_and_reset_region_constraints();\n \n-    let outlives = query_result::make_query_outlives(\n+    let outlives = query_response::make_query_outlives(\n         infcx.tcx,\n         region_obligations\n             .iter()"}, {"sha": "43dea442df65ada4205d78b216d23ea4bf58dada", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use traits::query::Fallible;\n use ty::{ParamEnvAnd, Ty, TyCtxt};\n \n@@ -25,12 +25,12 @@ impl<'tcx> Eq<'tcx> {\n }\n \n impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n-    type QueryResult = ();\n+    type QueryResponse = ();\n \n     fn try_fast_path(\n         _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Eq<'tcx>>,\n-    ) -> Option<Self::QueryResult> {\n+    ) -> Option<Self::QueryResponse> {\n         if key.value.a == key.value.b {\n             Some(())\n         } else {\n@@ -41,13 +41,13 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, ()>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_eq(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, ()>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n         v\n     }\n }"}, {"sha": "b113a322d370ac91db2d0eb1bea264ff563dc488", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use traits::query::outlives_bounds::OutlivesBound;\n use traits::query::Fallible;\n use ty::{ParamEnvAnd, Ty, TyCtxt};\n@@ -25,19 +25,19 @@ impl<'tcx> ImpliedOutlivesBounds<'tcx> {\n }\n \n impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ImpliedOutlivesBounds<'tcx> {\n-    type QueryResult = Vec<OutlivesBound<'tcx>>;\n+    type QueryResponse = Vec<OutlivesBound<'tcx>>;\n \n     fn try_fast_path(\n         _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         _key: &ParamEnvAnd<'tcx, Self>,\n-    ) -> Option<Self::QueryResult> {\n+    ) -> Option<Self::QueryResponse> {\n         None\n     }\n \n     fn perform_query(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self::QueryResult>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         // FIXME the query should take a `ImpliedOutlivesBounds`\n         let Canonical {\n             variables,\n@@ -56,8 +56,8 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ImpliedOutlivesBounds<\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, Self::QueryResult>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self::QueryResult>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, Self::QueryResponse>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>> {\n         v\n     }\n }"}, {"sha": "b292df758eeb5636ff83dd50b8dc6493403c9208", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryRegionConstraint,\n-                       QueryResult};\n+use infer::canonical::{\n+    Canonical, Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues,\n+    QueryRegionConstraint, QueryResponse,\n+};\n use infer::{InferCtxt, InferOk};\n-use smallvec::SmallVec;\n use std::fmt;\n use std::rc::Rc;\n use traits::query::Fallible;\n@@ -55,15 +56,15 @@ pub trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n     fmt::Debug + Sized + TypeFoldable<'tcx> + Lift<'gcx>\n {\n-    type QueryResult: TypeFoldable<'tcx> + Lift<'gcx>;\n+    type QueryResponse: TypeFoldable<'tcx> + Lift<'gcx>;\n \n     /// Give query the option for a simple fast path that never\n     /// actually hits the tcx cache lookup etc. Return `Some(r)` with\n     /// a final result or `None` to do the full path.\n     fn try_fast_path(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n-    ) -> Option<Self::QueryResult>;\n+    ) -> Option<Self::QueryResponse>;\n \n     /// Performs the actual query with the canonicalized key -- the\n     /// real work happens here. This method is not given an `infcx`\n@@ -74,29 +75,29 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n     fn perform_query(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self::QueryResult>>;\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>>;\n \n     /// Casts a lifted query result (which is in the gcx lifetime)\n     /// into the tcx lifetime. This is always just an identity cast,\n     /// but the generic code doesn't realize it -- put another way, in\n-    /// the generic code, we have a `Lifted<'gcx, Self::QueryResult>`\n-    /// and we want to convert that to a `Self::QueryResult`. This is\n+    /// the generic code, we have a `Lifted<'gcx, Self::QueryResponse>`\n+    /// and we want to convert that to a `Self::QueryResponse`. This is\n     /// not a priori valid, so we can't do it -- but in practice, it\n     /// is always a no-op (e.g., the lifted form of a type,\n     /// `Ty<'gcx>`, is a subtype of `Ty<'tcx>`). So we have to push\n     /// the operation into the impls that know more specifically what\n-    /// `QueryResult` is. This operation would (maybe) be nicer with\n+    /// `QueryResponse` is. This operation would (maybe) be nicer with\n     /// something like HKTs or GATs, since then we could make\n-    /// `QueryResult` parametric and `'gcx` and `'tcx` etc.\n+    /// `QueryResponse` parametric and `'gcx` and `'tcx` etc.\n     fn shrink_to_tcx_lifetime(\n-        lifted_query_result: &'a CanonicalizedQueryResult<'gcx, Self::QueryResult>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self::QueryResult>>;\n+        lifted_query_result: &'a CanonicalizedQueryResponse<'gcx, Self::QueryResponse>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>>;\n \n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n-    ) -> Fallible<Self::QueryResult> {\n+    ) -> Fallible<Self::QueryResponse> {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n             return Ok(result);\n         }\n@@ -105,7 +106,7 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n         // `canonicalize_hr_query_hack` here because of things\n         // like the subtype query, which go awry around\n         // `'static` otherwise.\n-        let mut canonical_var_values = SmallVec::new();\n+        let mut canonical_var_values = OriginalQueryValues::default();\n         let canonical_self =\n             infcx.canonicalize_hr_query_hack(&query_key, &mut canonical_var_values);\n         let canonical_result = Self::perform_query(infcx.tcx, canonical_self)?;\n@@ -114,7 +115,7 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n         let param_env = query_key.param_env;\n \n         let InferOk { value, obligations } = infcx\n-            .instantiate_nll_query_result_and_region_obligations(\n+            .instantiate_nll_query_response_and_region_obligations(\n                 &ObligationCause::dummy(),\n                 param_env,\n                 &canonical_var_values,\n@@ -145,7 +146,7 @@ impl<'gcx: 'tcx, 'tcx, Q> TypeOp<'gcx, 'tcx> for ParamEnvAnd<'tcx, Q>\n where\n     Q: QueryTypeOp<'gcx, 'tcx>,\n {\n-    type Output = Q::QueryResult;\n+    type Output = Q::QueryResponse;\n \n     fn fully_perform(\n         self,"}, {"sha": "c45e8b2554b0fdb1d00ae5e72e3247c5086eeb00", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use std::fmt;\n use traits::query::Fallible;\n use ty::fold::TypeFoldable;\n@@ -32,7 +32,7 @@ impl<'gcx: 'tcx, 'tcx, T> super::QueryTypeOp<'gcx, 'tcx> for Normalize<T>\n where\n     T: Normalizable<'gcx, 'tcx>,\n {\n-    type QueryResult = T;\n+    type QueryResponse = T;\n \n     fn try_fast_path(_tcx: TyCtxt<'_, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<T> {\n         if !key.value.value.has_projections() {\n@@ -45,13 +45,13 @@ where\n     fn perform_query(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self::QueryResult>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         T::type_op_method(tcx, canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, T>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, T>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, T>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, T>> {\n         T::shrink_to_tcx_lifetime(v)\n     }\n }\n@@ -60,13 +60,13 @@ pub trait Normalizable<'gcx, 'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx>\n     fn type_op_method(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>>;\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>>;\n \n     /// Convert from the `'gcx` (lifted) form of `Self` into the `tcx`\n     /// form of `Self`.\n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>>;\n+        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>>;\n }\n \n impl Normalizable<'gcx, 'tcx> for Ty<'tcx>\n@@ -76,13 +76,13 @@ where\n     fn type_op_method(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_ty(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n         v\n     }\n }\n@@ -94,13 +94,13 @@ where\n     fn type_op_method(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_predicate(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n         v\n     }\n }\n@@ -112,13 +112,13 @@ where\n     fn type_op_method(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_poly_fn_sig(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n         v\n     }\n }\n@@ -130,13 +130,13 @@ where\n     fn type_op_method(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_fn_sig(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n         v\n     }\n }"}, {"sha": "a36c5accd2a681ae2a491bc3675cb8568ae4cc6e", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use traits::query::dropck_outlives::trivial_dropck_outlives;\n use traits::query::dropck_outlives::DropckOutlivesResult;\n use traits::query::Fallible;\n@@ -29,12 +29,12 @@ impl super::QueryTypeOp<'gcx, 'tcx> for DropckOutlives<'tcx>\n where\n     'gcx: 'tcx,\n {\n-    type QueryResult = DropckOutlivesResult<'tcx>;\n+    type QueryResponse = DropckOutlivesResult<'tcx>;\n \n     fn try_fast_path(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n-    ) -> Option<Self::QueryResult> {\n+    ) -> Option<Self::QueryResponse> {\n         if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n             Some(DropckOutlivesResult::default())\n         } else {\n@@ -45,7 +45,7 @@ where\n     fn perform_query(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self::QueryResult>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         // Subtle: note that we are not invoking\n         // `infcx.at(...).dropck_outlives(...)` here, but rather the\n         // underlying `dropck_outlives` query. This same underlying\n@@ -76,8 +76,8 @@ where\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        lifted_query_result: &'a CanonicalizedQueryResult<'gcx, Self::QueryResult>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self::QueryResult>> {\n+        lifted_query_result: &'a CanonicalizedQueryResponse<'gcx, Self::QueryResponse>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>> {\n         lifted_query_result\n     }\n }"}, {"sha": "460ddb2a138b5d07a620c6fa8d9229ba056813e2", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use traits::query::Fallible;\n use ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n@@ -24,12 +24,12 @@ impl<'tcx> ProvePredicate<'tcx> {\n }\n \n impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n-    type QueryResult = ();\n+    type QueryResponse = ();\n \n     fn try_fast_path(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n-    ) -> Option<Self::QueryResult> {\n+    ) -> Option<Self::QueryResponse> {\n         // Proving Sized, very often on \"obviously sized\" types like\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n@@ -50,13 +50,13 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, ()>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_prove_predicate(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, ()>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n         v\n     }\n }"}, {"sha": "2b2939c644aa3a2ec91420e9fde4592555204746", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use traits::query::Fallible;\n use ty::{ParamEnvAnd, Ty, TyCtxt};\n \n@@ -28,7 +28,7 @@ impl<'tcx> Subtype<'tcx> {\n }\n \n impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n-    type QueryResult = ();\n+    type QueryResponse = ();\n \n     fn try_fast_path(_tcx: TyCtxt<'_, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<()> {\n         if key.value.sub == key.value.sup {\n@@ -41,13 +41,13 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResult<'gcx, ()>> {\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_subtype(canonicalized)\n     }\n \n     fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResult<'gcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResult<'tcx, ()>> {\n+        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n         v\n     }\n }"}, {"sha": "4135d499c58532256fd045d3e97519d45fe52aac", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 34, "deletions": 59, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -57,6 +57,7 @@ use syntax::symbol::{keywords, Symbol, LocalInternedString, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use smallvec;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n \n@@ -1456,10 +1457,10 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// \"Universes\" are used during type- and trait-checking in the\n /// presence of `for<..>` binders to control what sets of names are\n /// visible. Universes are arranged into a tree: the root universe\n-/// contains names that are always visible. But when you enter into\n-/// some subuniverse, then it may add names that are only visible\n-/// within that subtree (but it can still name the names of its\n-/// ancestor universes).\n+/// contains names that are always visible. Each child then adds a new\n+/// set of names that are visible, in addition to those of its parent.\n+/// We say that the child universe \"extends\" the parent universe with\n+/// new names.\n ///\n /// To make this more concrete, consider this program:\n ///\n@@ -1471,11 +1472,11 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// ```\n ///\n /// The struct name `Foo` is in the root universe U0. But the type\n-/// parameter `T`, introduced on `bar`, is in a subuniverse U1 --\n-/// i.e., within `bar`, we can name both `T` and `Foo`, but outside of\n-/// `bar`, we cannot name `T`. Then, within the type of `y`, the\n-/// region `'a` is in a subuniverse U2 of U1, because we can name it\n-/// inside the fn type but not outside.\n+/// parameter `T`, introduced on `bar`, is in an extended universe U1\n+/// -- i.e., within `bar`, we can name both `T` and `Foo`, but outside\n+/// of `bar`, we cannot name `T`. Then, within the type of `y`, the\n+/// region `'a` is in a universe U2 that extends U1, because we can\n+/// name it inside the fn type but not outside.\n ///\n /// Universes are used to do type- and trait-checking around these\n /// \"forall\" binders (also called **universal quantification**). The\n@@ -1488,65 +1489,39 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// declared, but a type name in a non-zero universe is a placeholder\n /// type -- an idealized representative of \"types in general\" that we\n /// use for checking generic functions.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct UniverseIndex(u32);\n-\n-impl UniverseIndex {\n-    /// The root universe, where things that the user defined are\n-    /// visible.\n-    pub const ROOT: Self = UniverseIndex(0);\n+newtype_index! {\n+    pub struct UniverseIndex {\n+        DEBUG_FORMAT = \"U{}\",\n+    }\n+}\n \n-    /// The \"max universe\" -- this isn't really a valid universe, but\n-    /// it's useful sometimes as a \"starting value\" when you are\n-    /// taking the minimum of a (non-empty!) set of universes.\n-    pub const MAX: Self = UniverseIndex(::std::u32::MAX);\n+impl_stable_hash_for!(struct UniverseIndex { private });\n \n-    /// Creates a universe index from the given integer.  Not to be\n-    /// used lightly lest you pick a bad value. But sometimes we\n-    /// convert universe indices into integers and back for various\n-    /// reasons.\n-    pub fn from_u32(index: u32) -> Self {\n-        UniverseIndex(index)\n-    }\n+impl UniverseIndex {\n+    pub const ROOT: UniverseIndex = UniverseIndex::from_u32_const(0);\n \n-    /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n-    /// So, for example, suppose we have this type in universe `U`:\n+    /// Returns the \"next\" universe index in order -- this new index\n+    /// is considered to extend all previous universes. This\n+    /// corresponds to entering a `forall` quantifier.  So, for\n+    /// example, suppose we have this type in universe `U`:\n     ///\n     /// ```\n     /// for<'a> fn(&'a u32)\n     /// ```\n     ///\n     /// Once we \"enter\" into this `for<'a>` quantifier, we are in a\n-    /// subuniverse of `U` -- in this new universe, we can name the\n-    /// region `'a`, but that region was not nameable from `U` because\n-    /// it was not in scope there.\n-    pub fn subuniverse(self) -> UniverseIndex {\n-        UniverseIndex(self.0.checked_add(1).unwrap())\n-    }\n-\n-    /// True if the names in this universe are a subset of the names in `other`.\n-    pub fn is_subset_of(self, other: UniverseIndex) -> bool {\n-        self.0 <= other.0\n-    }\n-\n-    pub fn as_u32(&self) -> u32 {\n-        self.0\n-    }\n-\n-    pub fn as_usize(&self) -> usize {\n-        self.0 as usize\n-    }\n-}\n-\n-impl fmt::Debug for UniverseIndex {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"U{}\", self.as_u32())\n-    }\n-}\n-\n-impl From<u32> for UniverseIndex {\n-    fn from(index: u32) -> Self {\n-        UniverseIndex(index)\n+    /// new universe that extends `U` -- in this new universe, we can\n+    /// name the region `'a`, but that region was not nameable from\n+    /// `U` because it was not in scope there.\n+    pub fn next_universe(self) -> UniverseIndex {\n+        UniverseIndex::from_u32(self.private.checked_add(1).unwrap())\n+    }\n+\n+    /// True if `self` can name a name from `other` -- in other words,\n+    /// if the set of names in `self` is a superset of those in\n+    /// `other`.\n+    pub fn can_name(self, other: UniverseIndex) -> bool {\n+        self.private >= other.private\n     }\n }\n "}, {"sha": "c4f39ffcd2067aebea1ed0ddf6d87414f3c15c34", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -559,7 +559,7 @@ define_queries! { <'tcx>\n         [] fn normalize_projection_ty: NormalizeProjectionTy(\n             CanonicalProjectionGoal<'tcx>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>>,\n             NoSolution,\n         >,\n \n@@ -571,15 +571,15 @@ define_queries! { <'tcx>\n         [] fn implied_outlives_bounds: ImpliedOutlivesBounds(\n             CanonicalTyGoal<'tcx>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n             NoSolution,\n         >,\n \n         /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n         [] fn dropck_outlives: DropckOutlives(\n             CanonicalTyGoal<'tcx>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>>,\n             NoSolution,\n         >,\n \n@@ -593,55 +593,55 @@ define_queries! { <'tcx>\n         [] fn type_op_eq: TypeOpEq(\n             CanonicalTypeOpEqGoal<'tcx>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n             NoSolution,\n         >,\n \n         /// Do not call this query directly: part of the `Subtype` type-op\n         [] fn type_op_subtype: TypeOpSubtype(\n             CanonicalTypeOpSubtypeGoal<'tcx>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n             NoSolution,\n         >,\n \n         /// Do not call this query directly: part of the `ProvePredicate` type-op\n         [] fn type_op_prove_predicate: TypeOpProvePredicate(\n             CanonicalTypeOpProvePredicateGoal<'tcx>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n             NoSolution,\n         >,\n \n         /// Do not call this query directly: part of the `Normalize` type-op\n         [] fn type_op_normalize_ty: TypeOpNormalizeTy(\n             CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Ty<'tcx>>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>>,\n             NoSolution,\n         >,\n \n         /// Do not call this query directly: part of the `Normalize` type-op\n         [] fn type_op_normalize_predicate: TypeOpNormalizePredicate(\n             CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::Predicate<'tcx>>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>>,\n             NoSolution,\n         >,\n \n         /// Do not call this query directly: part of the `Normalize` type-op\n         [] fn type_op_normalize_poly_fn_sig: TypeOpNormalizePolyFnSig(\n             CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::PolyFnSig<'tcx>>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>>,\n             NoSolution,\n         >,\n \n         /// Do not call this query directly: part of the `Normalize` type-op\n         [] fn type_op_normalize_fn_sig: TypeOpNormalizeFnSig(\n             CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>\n         ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::FnSig<'tcx>>>>,\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>>,\n             NoSolution,\n         >,\n "}, {"sha": "273799bd4bd34b9d71b0d9c5c2b01e76d680158e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -57,6 +57,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::ty::ClosureKind,\n     ::ty::IntVarValue,\n     ::ty::ParamTy,\n+    ::ty::UniverseIndex,\n     ::ty::Variance,\n     ::syntax_pos::Span,\n }"}, {"sha": "dd8a7f19a63bd1aba572714cd01fc38ae9bb36be", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -112,7 +112,7 @@ struct RegionDefinition<'tcx> {\n     /// Which universe is this region variable defined in? This is\n     /// most often `ty::UniverseIndex::ROOT`, but when we encounter\n     /// forall-quantifiers like `for<'a> { 'a = 'b }`, we would create\n-    /// the variable for `'a` in a subuniverse.\n+    /// the variable for `'a` in a fresh universe that extends ROOT.\n     universe: ty::UniverseIndex,\n \n     /// If this is 'static or an early-bound region, then this is\n@@ -339,11 +339,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 NLLRegionVariableOrigin::Placeholder(placeholder) => {\n                     // Each placeholder region is only visible from\n-                    // its universe `ui` and its superuniverses. So we\n+                    // its universe `ui` and its extensions. So we\n                     // can't just add it into `scc` unless the\n                     // universe of the scc can name this region.\n                     let scc_universe = self.scc_universes[scc];\n-                    if placeholder.universe.is_subset_of(scc_universe) {\n+                    if scc_universe.can_name(placeholder.universe) {\n                         self.scc_values.add_element(scc, placeholder);\n                     } else {\n                         self.add_incompatible_universe(scc);\n@@ -541,7 +541,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Quick check: if scc_b's declared universe is a subset of\n         // scc_a's declared univese (typically, both are ROOT), then\n         // it cannot contain any problematic universe elements.\n-        if self.scc_universes[scc_b].is_subset_of(universe_a) {\n+        if universe_a.can_name(self.scc_universes[scc_b]) {\n             return true;\n         }\n \n@@ -550,7 +550,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // from universe_a\n         self.scc_values\n             .placeholders_contained_in(scc_b)\n-            .all(|p| p.universe.is_subset_of(universe_a))\n+            .all(|p| universe_a.can_name(p.universe))\n     }\n \n     /// Extend `scc` so that it can outlive some placeholder region"}, {"sha": "3607ae4f5088d4b3bf97ad6b30ecf83f389660a3", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -148,8 +148,8 @@ crate enum RegionElement {\n     /// a lifetime parameter).\n     RootUniversalRegion(RegionVid),\n \n-    /// A subuniverse from a subuniverse (e.g., instantiated from a\n-    /// `for<'a> fn(&'a u32)` type).\n+    /// A placeholder (e.g., instantiated from a `for<'a> fn(&'a u32)`\n+    /// type).\n     PlaceholderRegion(ty::Placeholder),\n }\n \n@@ -252,19 +252,6 @@ impl PlaceholderIndices {\n     }\n }\n \n-impl ::std::iter::FromIterator<ty::Placeholder> for PlaceholderIndices {\n-    fn from_iter<I>(iter: I) -> Self\n-    where\n-        I: IntoIterator<Item = ty::Placeholder>,\n-    {\n-        let mut result = Self::default();\n-        iter.into_iter().for_each(|p| {\n-            result.insert(p);\n-        });\n-        result\n-    }\n-}\n-\n /// Stores the full values for a set of regions (in contrast to\n /// `LivenessValues`, which only stores those points in the where a\n /// region is live). The full value for a region may contain points in"}, {"sha": "96cc1c0afecb41e4acbdd1bae9883cbb727a8ff2", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -159,7 +159,7 @@ trait TypeRelatingDelegate<'tcx> {\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n-    fn next_subuniverse(&mut self) -> ty::UniverseIndex;\n+    fn create_next_universe(&mut self) -> ty::UniverseIndex;\n \n     /// Creates a new region variable representing a higher-ranked\n     /// region that is instantiated existentially. This creates an\n@@ -218,8 +218,8 @@ impl NllTypeRelatingDelegate<'me, 'bccx, 'gcx, 'tcx> {\n }\n \n impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n-    fn next_subuniverse(&mut self) -> ty::UniverseIndex {\n-        self.infcx.create_subuniverse()\n+    fn create_next_universe(&mut self) -> ty::UniverseIndex {\n+        self.infcx.create_next_universe()\n     }\n \n     fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n@@ -324,7 +324,7 @@ where\n                     // new universe for the placeholders we will make\n                     // from here out.\n                     let universe = lazy_universe.unwrap_or_else(|| {\n-                        let universe = delegate.next_subuniverse();\n+                        let universe = delegate.create_next_universe();\n                         lazy_universe = Some(universe);\n                         universe\n                     });"}, {"sha": "536c15234064faf86089d9e0de6445a130cc0ff6", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -10,7 +10,9 @@\n \n use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause};\n-use rustc::infer::canonical::{Canonical, CanonicalVarValues, QueryRegionConstraint, QueryResult};\n+use rustc::infer::canonical::{\n+    Canonical, CanonicalVarValues, OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n+};\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::traits::{\n     WellFormed,\n@@ -26,7 +28,6 @@ use rustc::traits::{\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, TyCtxt};\n-use smallvec::SmallVec;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n@@ -77,7 +78,7 @@ impl context::Context for ChalkArenas<'tcx> {\n     // u-canonicalization not yet implemented\n     type UniverseMap = UniverseMap;\n \n-    type Solution = Canonical<'tcx, QueryResult<'tcx, ()>>;\n+    type Solution = Canonical<'tcx, QueryResponse<'tcx, ()>>;\n \n     type InferenceNormalizedSubst = CanonicalVarValues<'tcx>;\n \n@@ -116,7 +117,7 @@ impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n         &self,\n         _root_goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n         _simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n-    ) -> Option<Canonical<'gcx, QueryResult<'gcx, ()>>> {\n+    ) -> Option<Canonical<'gcx, QueryResponse<'gcx, ()>>> {\n         unimplemented!()\n     }\n }\n@@ -390,7 +391,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         &mut self,\n         value: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n     ) -> Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n-        let mut _orig_values = SmallVec::new();\n+        let mut _orig_values = OriginalQueryValues::default();\n         self.infcx.canonicalize_query(value, &mut _orig_values)\n     }\n "}, {"sha": "ed61f07c4d83dda88a9c8bd40785ef67677f055b", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 108, "deletions": 109, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::hir::def_id::DefId;\n-use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n use rustc::traits::{FulfillmentContext, Normalized, ObligationCause, TraitEngineExt};\n@@ -30,124 +30,125 @@ crate fn provide(p: &mut Providers) {\n \n fn dropck_outlives<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    goal: CanonicalTyGoal<'tcx>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>, NoSolution> {\n-    debug!(\"dropck_outlives(goal={:#?})\", goal);\n-\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let tcx = infcx.tcx;\n-        let (\n-            ParamEnvAnd {\n+    canonical_goal: CanonicalTyGoal<'tcx>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>>, NoSolution> {\n+    debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n+\n+    tcx.infer_ctxt().enter_with_canonical(\n+        DUMMY_SP,\n+        &canonical_goal,\n+        |ref infcx, goal, canonical_inference_vars| {\n+            let tcx = infcx.tcx;\n+            let ParamEnvAnd {\n                 param_env,\n                 value: for_ty,\n-            },\n-            canonical_inference_vars,\n-        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n+            } = goal;\n \n-        let mut result = DropckOutlivesResult {\n-            kinds: vec![],\n-            overflows: vec![],\n-        };\n+            let mut result = DropckOutlivesResult {\n+                kinds: vec![],\n+                overflows: vec![],\n+            };\n \n-        // A stack of types left to process. Each round, we pop\n-        // something from the stack and invoke\n-        // `dtorck_constraint_for_ty`. This may produce new types that\n-        // have to be pushed on the stack. This continues until we have explored\n-        // all the reachable types from the type `for_ty`.\n-        //\n-        // Example: Imagine that we have the following code:\n-        //\n-        // ```rust\n-        // struct A {\n-        //     value: B,\n-        //     children: Vec<A>,\n-        // }\n-        //\n-        // struct B {\n-        //     value: u32\n-        // }\n-        //\n-        // fn f() {\n-        //   let a: A = ...;\n-        //   ..\n-        // } // here, `a` is dropped\n-        // ```\n-        //\n-        // at the point where `a` is dropped, we need to figure out\n-        // which types inside of `a` contain region data that may be\n-        // accessed by any destructors in `a`. We begin by pushing `A`\n-        // onto the stack, as that is the type of `a`. We will then\n-        // invoke `dtorck_constraint_for_ty` which will expand `A`\n-        // into the types of its fields `(B, Vec<A>)`. These will get\n-        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-        // lead to us trying to push `A` a second time -- to prevent\n-        // infinite recursion, we notice that `A` was already pushed\n-        // once and stop.\n-        let mut ty_stack = vec![(for_ty, 0)];\n-\n-        // Set used to detect infinite recursion.\n-        let mut ty_set = FxHashSet();\n-\n-        let fulfill_cx = &mut FulfillmentContext::new();\n-\n-        let cause = ObligationCause::dummy();\n-        while let Some((ty, depth)) = ty_stack.pop() {\n-            let DtorckConstraint {\n-                dtorck_types,\n-                outlives,\n-                overflows,\n-            } = dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty)?;\n-\n-            // \"outlives\" represent types/regions that may be touched\n-            // by a destructor.\n-            result.kinds.extend(outlives);\n-            result.overflows.extend(overflows);\n-\n-            // dtorck types are \"types that will get dropped but which\n-            // do not themselves define a destructor\", more or less. We have\n-            // to push them onto the stack to be expanded.\n-            for ty in dtorck_types {\n-                match infcx.at(&cause, param_env).normalize(&ty) {\n-                    Ok(Normalized {\n-                        value: ty,\n-                        obligations,\n-                    }) => {\n-                        fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                        debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                        match ty.sty {\n-                            // All parameters live for the duration of the\n-                            // function.\n-                            ty::Param(..) => {}\n-\n-                            // A projection that we couldn't resolve - it\n-                            // might have a destructor.\n-                            ty::Projection(..) | ty::Opaque(..) => {\n-                                result.kinds.push(ty.into());\n-                            }\n+            // A stack of types left to process. Each round, we pop\n+            // something from the stack and invoke\n+            // `dtorck_constraint_for_ty`. This may produce new types that\n+            // have to be pushed on the stack. This continues until we have explored\n+            // all the reachable types from the type `for_ty`.\n+            //\n+            // Example: Imagine that we have the following code:\n+            //\n+            // ```rust\n+            // struct A {\n+            //     value: B,\n+            //     children: Vec<A>,\n+            // }\n+            //\n+            // struct B {\n+            //     value: u32\n+            // }\n+            //\n+            // fn f() {\n+            //   let a: A = ...;\n+            //   ..\n+            // } // here, `a` is dropped\n+            // ```\n+            //\n+            // at the point where `a` is dropped, we need to figure out\n+            // which types inside of `a` contain region data that may be\n+            // accessed by any destructors in `a`. We begin by pushing `A`\n+            // onto the stack, as that is the type of `a`. We will then\n+            // invoke `dtorck_constraint_for_ty` which will expand `A`\n+            // into the types of its fields `(B, Vec<A>)`. These will get\n+            // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+            // lead to us trying to push `A` a second time -- to prevent\n+            // infinite recursion, we notice that `A` was already pushed\n+            // once and stop.\n+            let mut ty_stack = vec![(for_ty, 0)];\n+\n+            // Set used to detect infinite recursion.\n+            let mut ty_set = FxHashSet();\n+\n+            let fulfill_cx = &mut FulfillmentContext::new();\n+\n+            let cause = ObligationCause::dummy();\n+            while let Some((ty, depth)) = ty_stack.pop() {\n+                let DtorckConstraint {\n+                    dtorck_types,\n+                    outlives,\n+                    overflows,\n+                } = dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty)?;\n+\n+                // \"outlives\" represent types/regions that may be touched\n+                // by a destructor.\n+                result.kinds.extend(outlives);\n+                result.overflows.extend(overflows);\n+\n+                // dtorck types are \"types that will get dropped but which\n+                // do not themselves define a destructor\", more or less. We have\n+                // to push them onto the stack to be expanded.\n+                for ty in dtorck_types {\n+                    match infcx.at(&cause, param_env).normalize(&ty) {\n+                        Ok(Normalized {\n+                            value: ty,\n+                            obligations,\n+                        }) => {\n+                            fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+                            debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                            match ty.sty {\n+                                // All parameters live for the duration of the\n+                                // function.\n+                                ty::Param(..) => {}\n+\n+                                // A projection that we couldn't resolve - it\n+                                // might have a destructor.\n+                                ty::Projection(..) | ty::Opaque(..) => {\n+                                    result.kinds.push(ty.into());\n+                                }\n \n-                            _ => {\n-                                if ty_set.insert(ty) {\n-                                    ty_stack.push((ty, depth + 1));\n+                                _ => {\n+                                    if ty_set.insert(ty) {\n+                                        ty_stack.push((ty, depth + 1));\n+                                    }\n                                 }\n                             }\n                         }\n-                    }\n \n-                    // We don't actually expect to fail to normalize.\n-                    // That implies a WF error somewhere else.\n-                    Err(NoSolution) => {\n-                        return Err(NoSolution);\n+                        // We don't actually expect to fail to normalize.\n+                        // That implies a WF error somewhere else.\n+                        Err(NoSolution) => {\n+                            return Err(NoSolution);\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        debug!(\"dropck_outlives: result = {:#?}\", result);\n+            debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-        infcx.make_canonicalized_query_result(canonical_inference_vars, result, fulfill_cx)\n-    })\n+            infcx.make_canonicalized_query_response(canonical_inference_vars, result, fulfill_cx)\n+        },\n+    )\n }\n \n /// Return a set of constraints that needs to be satisfied in\n@@ -195,8 +196,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety)\n         }\n \n-        ty::Tuple(tys) => tys\n-            .iter()\n+        ty::Tuple(tys) => tys.iter()\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n@@ -308,8 +308,7 @@ crate fn adt_dtorck_constraint<'a, 'tcx>(\n         return Ok(result);\n     }\n \n-    let mut result = def\n-        .all_fields()\n+    let mut result = def.all_fields()\n         .map(|field| tcx.type_of(field.did))\n         .map(|fty| dtorck_constraint_for_ty(tcx, span, fty, 0, fty))\n         .collect::<Result<DtorckConstraint, NoSolution>>()?;"}, {"sha": "15ef1106311b3ec9c657720c147ad3c19a9fb904", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::traits::{EvaluationResult, Obligation, ObligationCause,\n-                    OverflowError, SelectionContext, TraitQueryMode};\n use rustc::traits::query::CanonicalPredicateGoal;\n+use rustc::traits::{\n+    EvaluationResult, Obligation, ObligationCause, OverflowError, SelectionContext, TraitQueryMode,\n+};\n use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use syntax::source_map::DUMMY_SP;\n@@ -24,20 +25,21 @@ crate fn provide(p: &mut Providers) {\n \n fn evaluate_obligation<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    goal: CanonicalPredicateGoal<'tcx>,\n+    canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let (\n-            ParamEnvAnd {\n+    tcx.infer_ctxt().enter_with_canonical(\n+        DUMMY_SP,\n+        &canonical_goal,\n+        |ref infcx, goal, _canonical_inference_vars| {\n+            let ParamEnvAnd {\n                 param_env,\n                 value: predicate,\n-            },\n-            _canonical_inference_vars,\n-        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n+            } = goal;\n \n-        let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n-        let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n+            let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n+            let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n \n-        selcx.evaluate_obligation_recursively(&obligation)\n-    })\n+            selcx.evaluate_obligation_recursively(&obligation)\n+        },\n+    )\n }"}, {"sha": "ad0a54e392f583ed55d483180a87a3d9f688ea32", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -37,7 +37,7 @@ fn implied_outlives_bounds<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: CanonicalTyGoal<'tcx>,\n ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n+        Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n         NoSolution,\n > {\n     tcx.infer_ctxt()"}, {"sha": "637a50728f39cec6354ae2f59de556d09ef48052", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::traits::query::{normalize::NormalizationResult, CanonicalProjectionGoal, NoSolution};\n use rustc::traits::{self, ObligationCause, SelectionContext, TraitEngineExt};\n use rustc::ty::query::Providers;\n@@ -28,7 +28,7 @@ crate fn provide(p: &mut Providers) {\n fn normalize_projection_ty<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: CanonicalProjectionGoal<'tcx>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>, NoSolution> {\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, NormalizationResult<'tcx>>>>, NoSolution> {\n     debug!(\"normalize_provider(goal={:#?})\", goal);\n \n     tcx.sess"}, {"sha": "a857cdbda45ae87cbdb6510d329a6b90470c12ec", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a52983d690bfdc0d0343c1db14c2c6b2359df2d/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=5a52983d690bfdc0d0343c1db14c2c6b2359df2d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::infer::InferCtxt;\n use rustc::traits::query::type_op::eq::Eq;\n use rustc::traits::query::type_op::normalize::Normalize;\n@@ -38,7 +38,7 @@ crate fn provide(p: &mut Providers) {\n fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, ()>>>, NoSolution> {\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, ()>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n             let (param_env, Eq { a, b }) = key.into_parts();\n@@ -68,39 +68,39 @@ where\n fn type_op_normalize_ty(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Ty<'tcx>>>>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, Ty<'tcx>>>>, NoSolution> {\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_predicate(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Predicate<'tcx>>>>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, Predicate<'tcx>>>>, NoSolution> {\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, Predicate<'tcx>>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_fn_sig(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<FnSig<'tcx>>>>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, FnSig<'tcx>>>>, NoSolution> {\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, FnSig<'tcx>>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_poly_fn_sig(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<PolyFnSig<'tcx>>>>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, PolyFnSig<'tcx>>>>, NoSolution> {\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, PolyFnSig<'tcx>>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_subtype<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Subtype<'tcx>>>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, ()>>>, NoSolution> {\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, ()>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n             let (param_env, Subtype { sub, sup }) = key.into_parts();\n@@ -114,7 +114,7 @@ fn type_op_subtype<'tcx>(\n fn type_op_prove_predicate<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, ProvePredicate<'tcx>>>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, ()>>>, NoSolution> {\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, ()>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n             let (param_env, ProvePredicate { predicate }) = key.into_parts();"}]}