{"sha": "557d4346a26266d2eb13f6b0adf106b8873b0da1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1N2Q0MzQ2YTI2MjY2ZDJlYjEzZjZiMGFkZjEwNmI4ODczYjBkYTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-26T13:38:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-26T13:38:41Z"}, "message": "Auto merge of #21237 - erickt:derive-assoc-types, r=erickt\n\nThis PR adds support for associated types to the `#[derive(...)]` syntax extension. In order to do this, it switches over to using where predicates to apply the type constraints. So now this:\r\n\r\n```rust\r\ntype Trait {\r\n    type Type;\r\n}\r\n\r\n#[derive(Clone)]\r\nstruct Foo<A> where A: Trait {\r\n    a: A,\r\n    b: <A as Trait>::Type,\r\n}\r\n```\r\n\r\nGets expended into this impl:\r\n\r\n```rust\r\nimpl<A: Clone> Clone for Foo<A> where\r\n    A: Trait,\r\n    <A as Trait>::Type: Clone,\r\n{\r\n    fn clone(&self) -> Foo<T> {\r\n        Foo {\r\n            a: self.a.clone(),\r\n            b: self.b.clone(),\r\n        }\r\n    }\r\n}\r\n```", "tree": {"sha": "d090541009a2400121f5bac3bca1002598eade28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d090541009a2400121f5bac3bca1002598eade28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/557d4346a26266d2eb13f6b0adf106b8873b0da1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/557d4346a26266d2eb13f6b0adf106b8873b0da1", "html_url": "https://github.com/rust-lang/rust/commit/557d4346a26266d2eb13f6b0adf106b8873b0da1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/557d4346a26266d2eb13f6b0adf106b8873b0da1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f", "html_url": "https://github.com/rust-lang/rust/commit/1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f"}, {"sha": "9cabe273d3adb06a19f63460deda96ae224b28bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cabe273d3adb06a19f63460deda96ae224b28bf", "html_url": "https://github.com/rust-lang/rust/commit/9cabe273d3adb06a19f63460deda96ae224b28bf"}], "stats": {"total": 364, "additions": 358, "deletions": 6}, "files": [{"sha": "0c5e4d67642acc08a82fdbd838ef4dbf21de7dec", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 118, "deletions": 6, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/557d4346a26266d2eb13f6b0adf106b8873b0da1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557d4346a26266d2eb13f6b0adf106b8873b0da1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=557d4346a26266d2eb13f6b0adf106b8873b0da1", "patch": "@@ -332,6 +332,46 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n     RefCell::new(f)\n }\n \n+/// This method helps to extract all the type parameters referenced from a\n+/// type. For a type parameter `<T>`, it looks for either a `TyPath` that\n+/// is not global and starts with `T`, or a `TyQPath`.\n+fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast::Ty>> {\n+    use visit;\n+\n+    struct Visitor<'a> {\n+        ty_param_names: &'a [ast::Name],\n+        types: Vec<P<ast::Ty>>,\n+    }\n+\n+    impl<'a> visit::Visitor<'a> for Visitor<'a> {\n+        fn visit_ty(&mut self, ty: &'a ast::Ty) {\n+            match ty.node {\n+                ast::TyPath(_, ref path) if !path.global => {\n+                    match path.segments.first() {\n+                        Some(segment) => {\n+                            if self.ty_param_names.contains(&segment.identifier.name) {\n+                                self.types.push(P(ty.clone()));\n+                            }\n+                        }\n+                        None => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+\n+            visit::walk_ty(self, ty)\n+        }\n+    }\n+\n+    let mut visitor = Visitor {\n+        ty_param_names: ty_param_names,\n+        types: Vec::new(),\n+    };\n+\n+    visit::Visitor::visit_ty(&mut visitor, ty);\n+\n+    visitor.types\n+}\n \n impl<'a> TraitDef<'a> {\n     pub fn expand<F>(&self,\n@@ -374,18 +414,42 @@ impl<'a> TraitDef<'a> {\n         }))\n     }\n \n-    /// Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n-    /// 'z, A, ..., Z>`, creates an impl like:\n+    /// Given that we are deriving a trait `DerivedTrait` for a type like:\n     ///\n     /// ```ignore\n-    /// impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n+    /// struct Struct<'a, ..., 'z, A, B: DeclaredTrait, C, ..., Z> where C: WhereTrait {\n+    ///     a: A,\n+    ///     b: B::Item,\n+    ///     b1: <B as DeclaredTrait>::Item,\n+    ///     c1: <C as WhereTrait>::Item,\n+    ///     c2: Option<<C as WhereTrait>::Item>,\n+    ///     ...\n+    /// }\n+    /// ```\n+    ///\n+    /// create an impl like:\n+    ///\n+    /// ```ignore\n+    /// impl<'a, ..., 'z, A, B: DeclaredTrait, C, ...  Z> where\n+    ///     C:                       WhereTrait,\n+    ///     A: DerivedTrait + B1 + ... + BN,\n+    ///     B: DerivedTrait + B1 + ... + BN,\n+    ///     C: DerivedTrait + B1 + ... + BN,\n+    ///     B::Item:                 DerivedTrait + B1 + ... + BN,\n+    ///     <C as WhereTrait>::Item: DerivedTrait + B1 + ... + BN,\n+    ///     ...\n+    /// {\n+    ///     ...\n+    /// }\n     /// ```\n     ///\n-    /// where B1, B2, ... are the bounds given by `bounds_paths`.'\n+    /// where B1, ..., BN are the bounds given by `bounds_paths`.'. Z is a phantom type, and\n+    /// therefore does not get bound by the derived trait.\n     fn create_derived_impl(&self,\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n+                           field_tys: Vec<P<ast::Ty>>,\n                            methods: Vec<P<ast::ImplItem>>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n@@ -466,6 +530,35 @@ impl<'a> TraitDef<'a> {\n             }\n         }));\n \n+        if !ty_params.is_empty() {\n+            let ty_param_names: Vec<ast::Name> = ty_params.iter()\n+                .map(|ty_param| ty_param.ident.name)\n+                .collect();\n+\n+            for field_ty in field_tys.into_iter() {\n+                let tys = find_type_parameters(&*field_ty, &ty_param_names);\n+\n+                for ty in tys.into_iter() {\n+                    let mut bounds: Vec<_> = self.additional_bounds.iter().map(|p| {\n+                        cx.typarambound(p.to_path(cx, self.span, type_ident, generics))\n+                    }).collect();\n+\n+                    // require the current trait\n+                    bounds.push(cx.typarambound(trait_path.clone()));\n+\n+                    let predicate = ast::WhereBoundPredicate {\n+                        span: self.span,\n+                        bound_lifetimes: vec![],\n+                        bounded_ty: ty,\n+                        bounds: OwnedSlice::from_vec(bounds),\n+                    };\n+\n+                    let predicate = ast::WherePredicate::BoundPredicate(predicate);\n+                    where_clause.predicates.push(predicate);\n+                }\n+            }\n+        }\n+\n         let trait_generics = Generics {\n             lifetimes: lifetimes,\n             ty_params: OwnedSlice::from_vec(ty_params),\n@@ -518,6 +611,10 @@ impl<'a> TraitDef<'a> {\n                          struct_def: &StructDef,\n                          type_ident: Ident,\n                          generics: &Generics) -> P<ast::Item> {\n+        let field_tys: Vec<P<ast::Ty>> = struct_def.fields.iter()\n+            .map(|field| field.node.ty.clone())\n+            .collect();\n+\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(\n@@ -550,14 +647,29 @@ impl<'a> TraitDef<'a> {\n                                      body)\n         }).collect();\n \n-        self.create_derived_impl(cx, type_ident, generics, methods)\n+        self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n     }\n \n     fn expand_enum_def(&self,\n                        cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n                        type_ident: Ident,\n                        generics: &Generics) -> P<ast::Item> {\n+        let mut field_tys = Vec::new();\n+\n+        for variant in enum_def.variants.iter() {\n+            match variant.node.kind {\n+                ast::VariantKind::TupleVariantKind(ref args) => {\n+                    field_tys.extend(args.iter()\n+                        .map(|arg| arg.ty.clone()));\n+                }\n+                ast::VariantKind::StructVariantKind(ref args) => {\n+                    field_tys.extend(args.fields.iter()\n+                        .map(|field| field.node.ty.clone()));\n+                }\n+            }\n+        }\n+\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, self,\n@@ -590,7 +702,7 @@ impl<'a> TraitDef<'a> {\n                                      body)\n         }).collect();\n \n-        self.create_derived_impl(cx, type_ident, generics, methods)\n+        self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n     }\n }\n "}, {"sha": "8670cd96fc6de7f406f85439d8532b21a9464089", "filename": "src/test/auxiliary/struct_variant_xc_aux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/557d4346a26266d2eb13f6b0adf106b8873b0da1/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557d4346a26266d2eb13f6b0adf106b8873b0da1/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs?ref=557d4346a26266d2eb13f6b0adf106b8873b0da1", "patch": "@@ -11,6 +11,7 @@\n #![crate_name=\"struct_variant_xc_aux\"]\n #![crate_type = \"lib\"]\n \n+#[derive(Copy)]\n pub enum Enum {\n     Variant(u8),\n     StructVariant { arg: u8 }"}, {"sha": "3799f2ffba440ccd9d156803ba4837bf26119471", "filename": "src/test/compile-fail/derive-assoc-type-not-impl.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/557d4346a26266d2eb13f6b0adf106b8873b0da1/src%2Ftest%2Fcompile-fail%2Fderive-assoc-type-not-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557d4346a26266d2eb13f6b0adf106b8873b0da1/src%2Ftest%2Fcompile-fail%2Fderive-assoc-type-not-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderive-assoc-type-not-impl.rs?ref=557d4346a26266d2eb13f6b0adf106b8873b0da1", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    type X;\n+    fn method(&self) {}\n+}\n+\n+#[derive(Clone)]\n+struct Bar<T: Foo> {\n+    x: T::X,\n+}\n+\n+struct NotClone;\n+\n+impl Foo for NotClone {\n+    type X = i8;\n+}\n+\n+fn main() {\n+    Bar::<NotClone> { x: 1 }.clone(); //~ ERROR\n+}"}, {"sha": "59eb5506c45c784184c0e88e2453dcb7d5b552f7", "filename": "src/test/run-pass/deriving-associated-types.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/557d4346a26266d2eb13f6b0adf106b8873b0da1/src%2Ftest%2Frun-pass%2Fderiving-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557d4346a26266d2eb13f6b0adf106b8873b0da1/src%2Ftest%2Frun-pass%2Fderiving-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-associated-types.rs?ref=557d4346a26266d2eb13f6b0adf106b8873b0da1", "patch": "@@ -0,0 +1,210 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core, debug_builders)]\n+\n+pub trait DeclaredTrait {\n+    type Type;\n+}\n+\n+impl DeclaredTrait for i32 {\n+    type Type = i32;\n+}\n+\n+pub trait WhereTrait {\n+    type Type;\n+}\n+\n+impl WhereTrait for i32 {\n+    type Type = i32;\n+}\n+\n+// Make sure we don't add a bound that just shares a name with an associated\n+// type.\n+pub mod module {\n+    pub type Type = i32;\n+}\n+\n+#[derive(PartialEq, Debug)]\n+struct PrivateStruct<T>(T);\n+\n+#[derive(PartialEq, Debug)]\n+struct TupleStruct<A, B: DeclaredTrait, C>(\n+    module::Type,\n+    Option<module::Type>,\n+    A,\n+    PrivateStruct<A>,\n+    B,\n+    B::Type,\n+    Option<B::Type>,\n+    <B as DeclaredTrait>::Type,\n+    Option<<B as DeclaredTrait>::Type>,\n+    C,\n+    C::Type,\n+    Option<C::Type>,\n+    <C as WhereTrait>::Type,\n+    Option<<C as WhereTrait>::Type>,\n+    <i32 as DeclaredTrait>::Type,\n+) where C: WhereTrait;\n+\n+#[derive(PartialEq, Debug)]\n+pub struct Struct<A, B: DeclaredTrait, C> where C: WhereTrait {\n+    m1: module::Type,\n+    m2: Option<module::Type>,\n+    a1: A,\n+    a2: PrivateStruct<A>,\n+    b: B,\n+    b1: B::Type,\n+    b2: Option<B::Type>,\n+    b3: <B as DeclaredTrait>::Type,\n+    b4: Option<<B as DeclaredTrait>::Type>,\n+    c: C,\n+    c1: C::Type,\n+    c2: Option<C::Type>,\n+    c3: <C as WhereTrait>::Type,\n+    c4: Option<<C as WhereTrait>::Type>,\n+    d: <i32 as DeclaredTrait>::Type,\n+}\n+\n+#[derive(PartialEq, Debug)]\n+enum Enum<A, B: DeclaredTrait, C> where C: WhereTrait {\n+    Unit,\n+    Seq(\n+        module::Type,\n+        Option<module::Type>,\n+        A,\n+        PrivateStruct<A>,\n+        B,\n+        B::Type,\n+        Option<B::Type>,\n+        <B as DeclaredTrait>::Type,\n+        Option<<B as DeclaredTrait>::Type>,\n+        C,\n+        C::Type,\n+        Option<C::Type>,\n+        <C as WhereTrait>::Type,\n+        Option<<C as WhereTrait>::Type>,\n+        <i32 as DeclaredTrait>::Type,\n+    ),\n+    Map {\n+        m1: module::Type,\n+        m2: Option<module::Type>,\n+        a1: A,\n+        a2: PrivateStruct<A>,\n+        b: B,\n+        b1: B::Type,\n+        b2: Option<B::Type>,\n+        b3: <B as DeclaredTrait>::Type,\n+        b4: Option<<B as DeclaredTrait>::Type>,\n+        c: C,\n+        c1: C::Type,\n+        c2: Option<C::Type>,\n+        c3: <C as WhereTrait>::Type,\n+        c4: Option<<C as WhereTrait>::Type>,\n+        d: <i32 as DeclaredTrait>::Type,\n+    },\n+}\n+\n+fn main() {\n+    let e: TupleStruct<\n+        i32,\n+        i32,\n+        i32,\n+    > = TupleStruct(\n+        0,\n+        None,\n+        0,\n+        PrivateStruct(0),\n+        0,\n+        0,\n+        None,\n+        0,\n+        None,\n+        0,\n+        0,\n+        None,\n+        0,\n+        None,\n+        0,\n+    );\n+    assert_eq!(e, e);\n+\n+    let e: Struct<\n+        i32,\n+        i32,\n+        i32,\n+    > = Struct {\n+        m1: 0,\n+        m2: None,\n+        a1: 0,\n+        a2: PrivateStruct(0),\n+        b: 0,\n+        b1: 0,\n+        b2: None,\n+        b3: 0,\n+        b4: None,\n+        c: 0,\n+        c1: 0,\n+        c2: None,\n+        c3: 0,\n+        c4: None,\n+        d: 0,\n+    };\n+    assert_eq!(e, e);\n+\n+    let e = Enum::Unit::<i32, i32, i32>;\n+    assert_eq!(e, e);\n+\n+    let e: Enum<\n+        i32,\n+        i32,\n+        i32,\n+    > = Enum::Seq(\n+        0,\n+        None,\n+        0,\n+        PrivateStruct(0),\n+        0,\n+        0,\n+        None,\n+        0,\n+        None,\n+        0,\n+        0,\n+        None,\n+        0,\n+        None,\n+        0,\n+    );\n+    assert_eq!(e, e);\n+\n+    let e: Enum<\n+        i32,\n+        i32,\n+        i32,\n+    > = Enum::Map {\n+        m1: 0,\n+        m2: None,\n+        a1: 0,\n+        a2: PrivateStruct(0),\n+        b: 0,\n+        b1: 0,\n+        b2: None,\n+        b3: 0,\n+        b4: None,\n+        c: 0,\n+        c1: 0,\n+        c2: None,\n+        c3: 0,\n+        c4: None,\n+        d: 0,\n+    };\n+    assert_eq!(e, e);\n+}"}]}