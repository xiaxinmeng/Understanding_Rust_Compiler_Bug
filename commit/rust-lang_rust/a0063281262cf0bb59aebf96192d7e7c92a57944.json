{"sha": "a0063281262cf0bb59aebf96192d7e7c92a57944", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMDYzMjgxMjYyY2YwYmI1OWFlYmY5NjE5MmQ3ZTdjOTJhNTc5NDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-10T23:33:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-10T23:33:13Z"}, "message": "Auto merge of #50611 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 18 pull requests\n\nSuccessful merges:\n\n - #49423 (Extend tests for RFC1598 (GAT))\n - #50010 (Give SliceIndex impls a test suite of girth befitting the implementation (and fix a UTF8 boundary check))\n - #50447 (Fix update-references for tests within subdirectories.)\n - #50514 (Pull in a wasm fix from LLVM upstream)\n - #50524 (Make DepGraph::previous_work_products immutable)\n - #50532 (Don't use Lock for heavily accessed CrateMetadata::cnum_map.)\n - #50538 ( Make CrateNum allocation more thread-safe. )\n - #50564 (Inline `Span` methods.)\n - #50565 (Use SmallVec for DepNodeIndex within dep_graph.)\n - #50569 (Allow for specifying a linker plugin for cross-language LTO)\n - #50572 (Clarify in the docs that `mul_add` is not always faster.)\n - #50574 (add fn `into_inner(self) -> (Idx, Idx)` to RangeInclusive (#49022))\n - #50575 (std: Avoid `ptr::copy` if unnecessary in `vec::Drain`)\n - #50588 (Move \"See also\" disambiguation links for primitive types to top)\n - #50590 (Fix tuple struct field spans)\n - #50591 (Restore RawVec::reserve* documentation)\n - #50598 (Remove unnecessary mutable borrow and resizing in DepGraph::serialize)\n - #50606 (Retry when downloading the Docker cache.)\n\nFailed merges:\n\n - #50161 (added missing implementation hint)\n - #50558 (Remove all reference to DepGraph::work_products)", "tree": {"sha": "114a9dfd1b6fe51ccfd8a20a1d7c213bb54bb037", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/114a9dfd1b6fe51ccfd8a20a1d7c213bb54bb037"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0063281262cf0bb59aebf96192d7e7c92a57944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0063281262cf0bb59aebf96192d7e7c92a57944", "html_url": "https://github.com/rust-lang/rust/commit/a0063281262cf0bb59aebf96192d7e7c92a57944", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0063281262cf0bb59aebf96192d7e7c92a57944/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acd3871ba17316419c644e17547887787628ec2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/acd3871ba17316419c644e17547887787628ec2f", "html_url": "https://github.com/rust-lang/rust/commit/acd3871ba17316419c644e17547887787628ec2f"}, {"sha": "2c5d13dc9ca6897ef65de99107e08cc4de5b11dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c5d13dc9ca6897ef65de99107e08cc4de5b11dc", "html_url": "https://github.com/rust-lang/rust/commit/2c5d13dc9ca6897ef65de99107e08cc4de5b11dc"}], "stats": {"total": 1870, "additions": 1384, "deletions": 486}, "files": [{"sha": "3465e386cd925c90c188a7cd27cd009c368c8beb", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -36,8 +36,10 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n       url=\"https://s3-us-west-1.amazonaws.com/$SCCACHE_BUCKET/docker/$cksum\"\n       echo \"Attempting to download $s3url\"\n+      rm -f /tmp/rustci_docker_cache\n       set +e\n-      loaded_images=$(curl $url | docker load | sed 's/.* sha/sha/')\n+      retry curl -f -L -C - -o /tmp/rustci_docker_cache \"$url\"\n+      loaded_images=$(docker load -i /tmp/rustci_docker_cache | sed 's/.* sha/sha/')\n       set -e\n       echo \"Downloaded containers:\\n$loaded_images\"\n     fi"}, {"sha": "bb6945f0fd6bbb5b542778b466c532e8d3682c23", "filename": "src/ci/shared.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -21,11 +21,12 @@ function retry {\n   while true; do\n     \"$@\" && break || {\n       if [[ $n -lt $max ]]; then\n+        sleep $n  # don't retry immediately\n         ((n++))\n         echo \"Command failed. Attempt $n/$max:\"\n       else\n         echo \"The command has failed after $n attempts.\"\n-        exit 1\n+        return 1\n       fi\n     }\n   done"}, {"sha": "5c6f6b22aae068f23d8759c8043fc0da1e497d0a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -385,26 +385,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n-    /// will reallocate the minimum possible amount of memory necessary.\n-    /// Generally this will be exactly the amount of memory necessary,\n-    /// but in principle the allocator is free to give back more than\n-    /// we asked for.\n-    ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n-    /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behavior of this function may break.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM\n+    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n            -> Result<(), CollectionAllocErr> {\n \n@@ -441,6 +422,26 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n+    /// Ensures that the buffer contains at least enough space to hold\n+    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n+    /// will reallocate the minimum possible amount of memory necessary.\n+    /// Generally this will be exactly the amount of memory necessary,\n+    /// but in principle the allocator is free to give back more than\n+    /// we asked for.\n+    ///\n+    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe\n+    /// code *you* write that relies on the behavior of this function may break.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM\n     pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         match self.try_reserve_exact(used_cap, needed_extra_cap) {\n             Err(CapacityOverflow) => capacity_overflow(),\n@@ -463,6 +464,42 @@ impl<T, A: Alloc> RawVec<T, A> {\n         Ok(cmp::max(double_cap, required_cap))\n     }\n \n+    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n+    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<(), CollectionAllocErr> {\n+         unsafe {\n+            // NOTE: we don't early branch on ZSTs here because we want this\n+            // to actually catch \"asking for more than usize::MAX\" in that case.\n+            // If we make it past the first branch then we are guaranteed to\n+            // panic.\n+\n+            // Don't actually need any more capacity.\n+            // Wrapping in case they give a bad `used_cap`\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+               return Ok(());\n+            }\n+\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n+            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n+\n+             // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size())?;\n+\n+            let res = match self.current_layout() {\n+                Some(layout) => {\n+                    debug_assert!(new_layout.align() == layout.align());\n+                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n+                }\n+                None => self.a.alloc(new_layout),\n+            };\n+\n+            self.ptr = res?.cast().into();\n+            self.cap = new_cap;\n+\n+            Ok(())\n+        }\n+    }\n+\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n@@ -515,42 +552,6 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n-        -> Result<(), CollectionAllocErr> {\n-         unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity.\n-            // Wrapping in case they give a bad `used_cap`\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-               return Ok(());\n-            }\n-\n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n-            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n-\n-             // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size())?;\n-\n-            let res = match self.current_layout() {\n-                Some(layout) => {\n-                    debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n-                }\n-                None => self.a.alloc(new_layout),\n-            };\n-\n-            self.ptr = res?.cast().into();\n-            self.cap = new_cap;\n-\n-            Ok(())\n-        }\n-    }\n-\n-    /// The same as try_reserve, but errors are lowered to a call to oom().\n     pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         match self.try_reserve(used_cap, needed_extra_cap) {\n             Err(CapacityOverflow) => capacity_overflow(),"}, {"sha": "6caf12aa7eb81983b9ff6d15c649bf2c7d26edc8", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -10,6 +10,8 @@\n \n //! A dynamically-sized view into a contiguous sequence, `[T]`.\n //!\n+//! *[See also the slice primitive type](../../std/primitive.slice.html).*\n+//!\n //! Slices are a view into a block of memory represented as a pointer and a\n //! length.\n //!\n@@ -78,8 +80,6 @@\n //! * Further methods that return iterators are [`.split`], [`.splitn`],\n //!   [`.chunks`], [`.windows`] and more.\n //!\n-//! *[See also the slice primitive type](../../std/primitive.slice.html).*\n-//!\n //! [`Clone`]: ../../std/clone/trait.Clone.html\n //! [`Eq`]: ../../std/cmp/trait.Eq.html\n //! [`Ord`]: ../../std/cmp/trait.Ord.html"}, {"sha": "42efdea74b1ab6aa2b912c3e555e2d74d789850a", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -10,6 +10,8 @@\n \n //! Unicode string slices.\n //!\n+//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n+//!\n //! The `&str` type is one of the two main string types, the other being `String`.\n //! Unlike its `String` counterpart, its contents are borrowed.\n //!\n@@ -29,8 +31,6 @@\n //! ```\n //! let hello_world: &'static str = \"Hello, world!\";\n //! ```\n-//!\n-//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "1a47e5433ea90d97455c7c8cf8a3ddb556dff6b1", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 356, "deletions": 134, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -291,113 +291,379 @@ fn test_replace_pattern() {\n     assert_eq!(data.replace(|c| c == '\u03b3', \"\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\"), \"abcd\u03b1\u03b2\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\u03b4abcd\u03b1\u03b2\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\u03b4\");\n }\n \n-#[test]\n-fn test_slice() {\n-    assert_eq!(\"ab\", &\"abc\"[0..2]);\n-    assert_eq!(\"bc\", &\"abc\"[1..3]);\n-    assert_eq!(\"\", &\"abc\"[1..1]);\n-    assert_eq!(\"\\u{65e5}\", &\"\\u{65e5}\\u{672c}\"[0..3]);\n+// The current implementation of SliceIndex fails to handle methods\n+// orthogonally from range types; therefore, it is worth testing\n+// all of the indexing operations on each input.\n+mod slice_index {\n+    // Test a slicing operation **that should succeed,**\n+    // testing it on all of the indexing methods.\n+    //\n+    // This is not suitable for testing failure on invalid inputs.\n+    macro_rules! assert_range_eq {\n+        ($s:expr, $range:expr, $expected:expr)\n+        => {\n+            let mut s: String = $s.to_owned();\n+            let mut expected: String = $expected.to_owned();\n+            {\n+                let s: &str = &s;\n+                let expected: &str = &expected;\n+\n+                assert_eq!(&s[$range], expected, \"(in assertion for: index)\");\n+                assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked($range), expected,\n+                        \"(in assertion for: get_unchecked)\",\n+                    );\n+                }\n+            }\n+            {\n+                let s: &mut str = &mut s;\n+                let expected: &mut str = &mut expected;\n+\n+                assert_eq!(\n+                    &mut s[$range], expected,\n+                    \"(in assertion for: index_mut)\",\n+                );\n+                assert_eq!(\n+                    s.get_mut($range), Some(&mut expected[..]),\n+                    \"(in assertion for: get_mut)\",\n+                );\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked_mut($range), expected,\n+                        \"(in assertion for: get_unchecked_mut)\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n \n-    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-    assert_eq!(\"\u0e1b\", &data[0..3]);\n-    assert_eq!(\"\u0e23\", &data[3..6]);\n-    assert_eq!(\"\", &data[3..3]);\n-    assert_eq!(\"\u534e\", &data[30..33]);\n+    // Make sure the macro can actually detect bugs,\n+    // because if it can't, then what are we even doing here?\n+    //\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method that panics, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"out of bounds\")]\n+    fn assert_range_eq_can_fail_by_panic() {\n+        assert_range_eq!(\"abc\", 0..5, \"abc\");\n+    }\n \n-    fn a_million_letter_x() -> String {\n-        let mut i = 0;\n-        let mut rs = String::new();\n-        while i < 100000 {\n-            rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n-            i += 1;\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"==\")]\n+    fn assert_range_eq_can_fail_by_inequality() {\n+        assert_range_eq!(\"abc\", 0..2, \"abc\");\n+    }\n+\n+    // Generates test cases for bad index operations.\n+    //\n+    // This generates `should_panic` test cases for Index/IndexMut\n+    // and `None` test cases for get/get_mut.\n+    macro_rules! panic_cases {\n+        ($(\n+            in mod $case_name:ident {\n+                data: $data:expr;\n+\n+                // optional:\n+                //\n+                // a similar input for which DATA[input] succeeds, and the corresponding\n+                // output str. This helps validate \"critical points\" where an input range\n+                // straddles the boundary between valid and invalid.\n+                // (such as the input `len..len`, which is just barely valid)\n+                $(\n+                    good: data[$good:expr] == $output:expr;\n+                )*\n+\n+                bad: data[$bad:expr];\n+                message: $expect_msg:expr; // must be a literal\n+            }\n+        )*) => {$(\n+            mod $case_name {\n+                #[test]\n+                fn pass() {\n+                    let mut v: String = $data.into();\n+\n+                    $( assert_range_eq!(v, $good, $output); )*\n+\n+                    {\n+                        let v: &str = &v;\n+                        assert_eq!(v.get($bad), None, \"(in None assertion for get)\");\n+                    }\n+\n+                    {\n+                        let v: &mut str = &mut v;\n+                        assert_eq!(v.get_mut($bad), None, \"(in None assertion for get_mut)\");\n+                    }\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_fail() {\n+                    let v: String = $data.into();\n+                    let v: &str = &v;\n+                    let _v = &v[$bad];\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_mut_fail() {\n+                    let mut v: String = $data.into();\n+                    let v: &mut str = &mut v;\n+                    let _v = &mut v[$bad];\n+                }\n+            }\n+        )*};\n+    }\n+\n+    #[test]\n+    fn simple_ascii() {\n+        assert_range_eq!(\"abc\", .., \"abc\");\n+\n+        assert_range_eq!(\"abc\", 0..2, \"ab\");\n+        assert_range_eq!(\"abc\", 0..=1, \"ab\");\n+        assert_range_eq!(\"abc\", ..2, \"ab\");\n+        assert_range_eq!(\"abc\", ..=1, \"ab\");\n+\n+        assert_range_eq!(\"abc\", 1..3, \"bc\");\n+        assert_range_eq!(\"abc\", 1..=2, \"bc\");\n+        assert_range_eq!(\"abc\", 1..1, \"\");\n+        assert_range_eq!(\"abc\", 1..=0, \"\");\n+    }\n+\n+    #[test]\n+    fn simple_unicode() {\n+        // \u65e5\u672c\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", .., \"\\u{65e5}\\u{672c}\");\n+\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 0..3, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 0..=2, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", ..3, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", ..=2, \"\\u{65e5}\");\n+\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3..6, \"\\u{672c}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3..=5, \"\\u{672c}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3.., \"\\u{672c}\");\n+\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert_range_eq!(data, 0..3, \"\u0e1b\");\n+        assert_range_eq!(data, 3..6, \"\u0e23\");\n+        assert_range_eq!(data, 3..3, \"\");\n+        assert_range_eq!(data, 30..33, \"\u534e\");\n+\n+        /*0: \u4e2d\n+          3: \u534e\n+          6: V\n+          7: i\n+          8: \u1ec7\n+         11: t\n+         12:\n+         13: N\n+         14: a\n+         15: m */\n+        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert_range_eq!(ss, 3..6, \"\u534e\");\n+        assert_range_eq!(ss, 6..16, \"Vi\u1ec7t Nam\");\n+        assert_range_eq!(ss, 6..=15, \"Vi\u1ec7t Nam\");\n+        assert_range_eq!(ss, 6.., \"Vi\u1ec7t Nam\");\n+\n+        assert_range_eq!(ss, 0..3, \"\u4e2d\");\n+        assert_range_eq!(ss, 3..7, \"\u534eV\");\n+        assert_range_eq!(ss, 3..=6, \"\u534eV\");\n+        assert_range_eq!(ss, 3..3, \"\");\n+        assert_range_eq!(ss, 3..=2, \"\");\n+    }\n+\n+    #[test]\n+    #[cfg(not(target_arch = \"asmjs\"))] // hits an OOM\n+    fn simple_big() {\n+        fn a_million_letter_x() -> String {\n+            let mut i = 0;\n+            let mut rs = String::new();\n+            while i < 100000 {\n+                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n+                i += 1;\n+            }\n+            rs\n         }\n-        rs\n+        fn half_a_million_letter_x() -> String {\n+            let mut i = 0;\n+            let mut rs = String::new();\n+            while i < 100000 {\n+                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n+                i += 1;\n+            }\n+            rs\n+        }\n+        let letters = a_million_letter_x();\n+        assert_range_eq!(letters, 0..3 * 500000, half_a_million_letter_x());\n     }\n-    fn half_a_million_letter_x() -> String {\n-        let mut i = 0;\n-        let mut rs = String::new();\n-        while i < 100000 {\n-            rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n-            i += 1;\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_slice_fail() {\n+        &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n+    }\n+\n+    panic_cases! {\n+        in mod rangefrom_len {\n+            data: \"abcdef\";\n+            good: data[6..] == \"\";\n+            bad: data[7..];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangeto_len {\n+            data: \"abcdef\";\n+            good: data[..6] == \"abcdef\";\n+            bad: data[..7];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangetoinclusive_len {\n+            data: \"abcdef\";\n+            good: data[..=5] == \"abcdef\";\n+            bad: data[..=6];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod range_len_len {\n+            data: \"abcdef\";\n+            good: data[6..6] == \"\";\n+            bad: data[7..7];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangeinclusive_len_len {\n+            data: \"abcdef\";\n+            good: data[6..=5] == \"\";\n+            bad: data[7..=6];\n+            message: \"out of bounds\";\n         }\n-        rs\n     }\n-    let letters = a_million_letter_x();\n-    assert_eq!(half_a_million_letter_x(), &letters[0..3 * 500000]);\n-}\n \n-#[test]\n-fn test_slice_2() {\n-    let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    panic_cases! {\n+        in mod range_neg_width {\n+            data: \"abcdef\";\n+            good: data[4..4] == \"\";\n+            bad: data[4..3];\n+            message: \"begin <= end (4 <= 3)\";\n+        }\n \n-    assert_eq!(\"\u534e\", &ss[3..6]);\n-    assert_eq!(\"Vi\u1ec7t Nam\", &ss[6..16]);\n+        in mod rangeinclusive_neg_width {\n+            data: \"abcdef\";\n+            good: data[4..=3] == \"\";\n+            bad: data[4..=2];\n+            message: \"begin <= end (4 <= 3)\";\n+        }\n+    }\n \n-    assert_eq!(\"ab\", &\"abc\"[0..2]);\n-    assert_eq!(\"bc\", &\"abc\"[1..3]);\n-    assert_eq!(\"\", &\"abc\"[1..1]);\n+    mod overflow {\n+        panic_cases! {\n+            in mod rangeinclusive {\n+                data: \"hello\";\n+                // note: using 0 specifically ensures that the result of overflowing is 0..0,\n+                //       so that `get` doesn't simply return None for the wrong reason.\n+                bad: data[0..=usize::max_value()];\n+                message: \"maximum usize\";\n+            }\n \n-    assert_eq!(\"\u4e2d\", &ss[0..3]);\n-    assert_eq!(\"\u534eV\", &ss[3..7]);\n-    assert_eq!(\"\", &ss[3..3]);\n-    /*0: \u4e2d\n-      3: \u534e\n-      6: V\n-      7: i\n-      8: \u1ec7\n-     11: t\n-     12:\n-     13: N\n-     14: a\n-     15: m */\n-}\n+            in mod rangetoinclusive {\n+                data: \"hello\";\n+                bad: data[..=usize::max_value()];\n+                message: \"maximum usize\";\n+            }\n+        }\n+    }\n \n-#[test]\n-#[should_panic]\n-fn test_slice_fail() {\n-    &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n-}\n+    mod boundary {\n+        const DATA: &'static str = \"abc\u03b1\u03b2\u03b3\";\n+\n+        const BAD_START: usize = 4;\n+        const GOOD_START: usize = 3;\n+        const BAD_END: usize = 6;\n+        const GOOD_END: usize = 7;\n+        const BAD_END_INCL: usize = BAD_END - 1;\n+        const GOOD_END_INCL: usize = GOOD_END - 1;\n+\n+        // it is especially important to test all of the different range types here\n+        // because some of the logic may be duplicated as part of micro-optimizations\n+        // to dodge unicode boundary checks on half-ranges.\n+        panic_cases! {\n+            in mod range_1 {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..super::GOOD_END];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slice_rangetoinclusive_max_panics() {\n-    &\"hello\"[..=usize::max_value()];\n-}\n+            in mod range_2 {\n+                data: super::DATA;\n+                bad: data[super::GOOD_START..super::BAD_END];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slice_rangeinclusive_max_panics() {\n-    &\"hello\"[1..=usize::max_value()];\n-}\n+            in mod rangefrom {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slicemut_rangetoinclusive_max_panics() {\n-    let mut s = \"hello\".to_owned();\n-    let s: &mut str = &mut s;\n-    &mut s[..=usize::max_value()];\n-}\n+            in mod rangeto {\n+                data: super::DATA;\n+                bad: data[..super::BAD_END];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slicemut_rangeinclusive_max_panics() {\n-    let mut s = \"hello\".to_owned();\n-    let s: &mut str = &mut s;\n-    &mut s[1..=usize::max_value()];\n-}\n+            in mod rangeinclusive_1 {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..=super::GOOD_END_INCL];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-fn test_str_get_maxinclusive() {\n-    let mut s = \"hello\".to_owned();\n-    {\n-        let s: &str = &s;\n-        assert_eq!(s.get(..=usize::max_value()), None);\n-        assert_eq!(s.get(1..=usize::max_value()), None);\n+            in mod rangeinclusive_2 {\n+                data: super::DATA;\n+                bad: data[super::GOOD_START..=super::BAD_END_INCL];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n+\n+            in mod rangetoinclusive {\n+                data: super::DATA;\n+                bad: data[..=super::BAD_END_INCL];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n+        }\n     }\n-    {\n-        let s: &mut str = &mut s;\n-        assert_eq!(s.get(..=usize::max_value()), None);\n-        assert_eq!(s.get(1..=usize::max_value()), None);\n+\n+    const LOREM_PARAGRAPH: &'static str = \"\\\n+    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem \\\n+    sit amet dolor ultricies condimentum. Praesent iaculis purus elit, ac malesuada \\\n+    quam malesuada in. Duis sed orci eros. Suspendisse sit amet magna mollis, mollis \\\n+    nunc luctus, imperdiet mi. Integer fringilla non sem ut lacinia. Fusce varius \\\n+    tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec tempus vel, \\\n+    gravida nec quam.\";\n+\n+    // check the panic includes the prefix of the sliced string\n+    #[test]\n+    #[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n+    fn test_slice_fail_truncated_1() {\n+        &LOREM_PARAGRAPH[..1024];\n+    }\n+    // check the truncation in the panic message\n+    #[test]\n+    #[should_panic(expected=\"luctus, im`[...]\")]\n+    fn test_slice_fail_truncated_2() {\n+        &LOREM_PARAGRAPH[..1024];\n     }\n }\n \n@@ -446,50 +712,6 @@ fn test_is_char_boundary() {\n         }\n     }\n }\n-const LOREM_PARAGRAPH: &'static str = \"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\";\n-\n-// check the panic includes the prefix of the sliced string\n-#[test]\n-#[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n-fn test_slice_fail_truncated_1() {\n-    &LOREM_PARAGRAPH[..1024];\n-}\n-// check the truncation in the panic message\n-#[test]\n-#[should_panic(expected=\"luctus, im`[...]\")]\n-fn test_slice_fail_truncated_2() {\n-    &LOREM_PARAGRAPH[..1024];\n-}\n-\n-#[test]\n-#[should_panic(expected=\"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\")]\n-fn test_slice_fail_boundary_1() {\n-    &\"abc\u03b1\u03b2\u03b3\"[4..];\n-}\n-\n-#[test]\n-#[should_panic(expected=\"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\")]\n-fn test_slice_fail_boundary_2() {\n-    &\"abc\u03b1\u03b2\u03b3\"[2..6];\n-}\n-\n-#[test]\n-fn test_slice_from() {\n-    assert_eq!(&\"abcd\"[0..], \"abcd\");\n-    assert_eq!(&\"abcd\"[2..], \"cd\");\n-    assert_eq!(&\"abcd\"[4..], \"\");\n-}\n-#[test]\n-fn test_slice_to() {\n-    assert_eq!(&\"abcd\"[..0], \"\");\n-    assert_eq!(&\"abcd\"[..2], \"ab\");\n-    assert_eq!(&\"abcd\"[..4], \"abcd\");\n-}\n \n #[test]\n fn test_trim_left_matches() {"}, {"sha": "690cbcb559bbf6099f4e67b0907bebf9e01051c6", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -2533,9 +2533,11 @@ impl<'a, T> Drop for Drain<'a, T> {\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;\n-                let src = source_vec.as_ptr().offset(tail as isize);\n-                let dst = source_vec.as_mut_ptr().offset(start as isize);\n-                ptr::copy(src, dst, self.tail_len);\n+                if tail != start {\n+                    let src = source_vec.as_ptr().offset(tail as isize);\n+                    let dst = source_vec.as_mut_ptr().offset(start as isize);\n+                    ptr::copy(src, dst, self.tail_len);\n+                }\n                 source_vec.set_len(start + self.tail_len);\n             }\n         }"}, {"sha": "4a7dc13f0f2ca69e881e3707d819f8d323c41feb", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -11,9 +11,9 @@\n //! This module provides constants which are specific to the implementation\n //! of the `f32` floating point data type.\n //!\n-//! Mathematically significant numbers are provided in the `consts` sub-module.\n-//!\n //! *[See also the `f32` primitive type](../../std/primitive.f32.html).*\n+//!\n+//! Mathematically significant numbers are provided in the `consts` sub-module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "801de5e87bd10b002c9c1974bfa871fd4ee83dec", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -11,9 +11,9 @@\n //! This module provides constants which are specific to the implementation\n //! of the `f64` floating point data type.\n //!\n-//! Mathematically significant numbers are provided in the `consts` sub-module.\n-//!\n //! *[See also the `f64` primitive type](../../std/primitive.f64.html).*\n+//!\n+//! Mathematically significant numbers are provided in the `consts` sub-module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "697e6a3efde284356e5ce023691e2b0de8a3dc29", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -411,6 +411,21 @@ impl<Idx> RangeInclusive<Idx> {\n     pub fn end(&self) -> &Idx {\n         &self.end\n     }\n+\n+    /// Destructures the RangeInclusive into (lower bound, upper (inclusive) bound).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inclusive_range_methods)]\n+    ///\n+    /// assert_eq!((3..=5).into_inner(), (3, 5));\n+    /// ```\n+    #[unstable(feature = \"inclusive_range_methods\", issue = \"49022\")]\n+    #[inline]\n+    pub fn into_inner(self) -> (Idx, Idx) {\n+        (self.start, self.end)\n+    }\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]"}, {"sha": "93ebc23ac0b0e33f45d3e6ed87519a57902be728", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -2262,6 +2262,12 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {} but ends at {}\", index, end);\n }\n \n+#[inline(never)]\n+#[cold]\n+fn slice_index_overflow_fail() -> ! {\n+    panic!(\"attempted to index slice up to maximum usize\");\n+}\n+\n /// A helper trait used for indexing operations.\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n@@ -2538,15 +2544,13 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        assert!(self.end != usize::max_value(),\n-            \"attempted to index slice up to maximum usize\");\n+        if self.end == usize::max_value() { slice_index_overflow_fail(); }\n         (self.start..self.end + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        assert!(self.end != usize::max_value(),\n-            \"attempted to index slice up to maximum usize\");\n+        if self.end == usize::max_value() { slice_index_overflow_fail(); }\n         (self.start..self.end + 1).index_mut(slice)\n     }\n }"}, {"sha": "df7b2f25a86df19820db40788ec3b27f53e4e33a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -1849,6 +1849,12 @@ mod traits {\n         }\n     }\n \n+    #[inline(never)]\n+    #[cold]\n+    fn str_index_overflow_fail() -> ! {\n+        panic!(\"attempted to index str up to maximum usize\");\n+    }\n+\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::RangeFull {\n         type Output = str;\n@@ -2029,19 +2035,13 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if let Some(end) = self.end.checked_add(1) {\n-                (self.start..end).get(slice)\n-            } else {\n-                None\n-            }\n+            if self.end == usize::max_value() { None }\n+            else { (self.start..self.end+1).get(slice) }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if let Some(end) = self.end.checked_add(1) {\n-                (self.start..end).get_mut(slice)\n-            } else {\n-                None\n-            }\n+            if self.end == usize::max_value() { None }\n+            else { (self.start..self.end+1).get_mut(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n@@ -2053,14 +2053,12 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            assert!(self.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n+            if self.end == usize::max_value() { str_index_overflow_fail(); }\n             (self.start..self.end+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            assert!(self.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n+            if self.end == usize::max_value() { str_index_overflow_fail(); }\n             (self.start..self.end+1).index_mut(slice)\n         }\n     }\n@@ -2072,40 +2070,30 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n-                Some(unsafe { self.get_unchecked(slice) })\n-            } else {\n-                None\n-            }\n+            if self.end == usize::max_value() { None }\n+            else { (..self.end+1).get(slice) }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.end < usize::max_value() && slice.is_char_boundary(self.end + 1) {\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n-            } else {\n-                None\n-            }\n+            if self.end == usize::max_value() { None }\n+            else { (..self.end+1).get_mut(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr();\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end + 1))\n+            (..self.end+1).get_unchecked(slice)\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_ptr();\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, self.end + 1))\n+            (..self.end+1).get_unchecked_mut(slice)\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            assert!(self.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n+            if self.end == usize::max_value() { str_index_overflow_fail(); }\n             (..self.end+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            assert!(self.end != usize::max_value(),\n-                \"attempted to index str up to maximum usize\");\n+            if self.end == usize::max_value() { str_index_overflow_fail(); }\n             (..self.end+1).index_mut(slice)\n         }\n     }"}, {"sha": "19b5c86c4740627b90b953dfb4c51801a690f997", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 213, "deletions": 37, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -376,48 +376,224 @@ fn test_windows_zip() {\n     assert_eq!(res, [14, 18, 22, 26]);\n }\n \n-#[test]\n-fn get_range() {\n-    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    assert_eq!(v.get(..), Some(&[0, 1, 2, 3, 4, 5][..]));\n-    assert_eq!(v.get(..2), Some(&[0, 1][..]));\n-    assert_eq!(v.get(2..), Some(&[2, 3, 4, 5][..]));\n-    assert_eq!(v.get(1..4), Some(&[1, 2, 3][..]));\n-    assert_eq!(v.get(7..), None);\n-    assert_eq!(v.get(7..10), None);\n-}\n+// The current implementation of SliceIndex fails to handle methods\n+// orthogonally from range types; therefore, it is worth testing\n+// all of the indexing operations on each input.\n+mod slice_index {\n+    // This checks all six indexing methods, given an input range that\n+    // should succeed. (it is NOT suitable for testing invalid inputs)\n+    macro_rules! assert_range_eq {\n+        ($arr:expr, $range:expr, $expected:expr)\n+        => {\n+            let mut arr = $arr;\n+            let mut expected = $expected;\n+            {\n+                let s: &[_] = &arr;\n+                let expected: &[_] = &expected;\n+\n+                assert_eq!(&s[$range], expected, \"(in assertion for: index)\");\n+                assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked($range), expected,\n+                        \"(in assertion for: get_unchecked)\",\n+                    );\n+                }\n+            }\n+            {\n+                let s: &mut [_] = &mut arr;\n+                let expected: &mut [_] = &mut expected;\n+\n+                assert_eq!(\n+                    &mut s[$range], expected,\n+                    \"(in assertion for: index_mut)\",\n+                );\n+                assert_eq!(\n+                    s.get_mut($range), Some(&mut expected[..]),\n+                    \"(in assertion for: get_mut)\",\n+                );\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked_mut($range), expected,\n+                        \"(in assertion for: get_unchecked_mut)\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n \n-#[test]\n-fn get_mut_range() {\n-    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    assert_eq!(v.get_mut(..), Some(&mut [0, 1, 2, 3, 4, 5][..]));\n-    assert_eq!(v.get_mut(..2), Some(&mut [0, 1][..]));\n-    assert_eq!(v.get_mut(2..), Some(&mut [2, 3, 4, 5][..]));\n-    assert_eq!(v.get_mut(1..4), Some(&mut [1, 2, 3][..]));\n-    assert_eq!(v.get_mut(7..), None);\n-    assert_eq!(v.get_mut(7..10), None);\n-}\n+    // Make sure the macro can actually detect bugs,\n+    // because if it can't, then what are we even doing here?\n+    //\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method that panics, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"out of range\")]\n+    fn assert_range_eq_can_fail_by_panic() {\n+        assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n+    }\n \n-#[test]\n-fn get_unchecked_range() {\n-    unsafe {\n-        let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-        assert_eq!(v.get_unchecked(..), &[0, 1, 2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked(..2), &[0, 1][..]);\n-        assert_eq!(v.get_unchecked(2..), &[2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked(1..4), &[1, 2, 3][..]);\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"==\")]\n+    fn assert_range_eq_can_fail_by_inequality() {\n+        assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n     }\n-}\n \n-#[test]\n-fn get_unchecked_mut_range() {\n-    unsafe {\n-        let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-        assert_eq!(v.get_unchecked_mut(..), &mut [0, 1, 2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked_mut(..2), &mut [0, 1][..]);\n-        assert_eq!(v.get_unchecked_mut(2..), &mut[2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked_mut(1..4), &mut [1, 2, 3][..]);\n+    // Test cases for bad index operations.\n+    //\n+    // This generates `should_panic` test cases for Index/IndexMut\n+    // and `None` test cases for get/get_mut.\n+    macro_rules! panic_cases {\n+        ($(\n+            // each test case needs a unique name to namespace the tests\n+            in mod $case_name:ident {\n+                data: $data:expr;\n+\n+                // optional:\n+                //\n+                // one or more similar inputs for which data[input] succeeds,\n+                // and the corresponding output as an array.  This helps validate\n+                // \"critical points\" where an input range straddles the boundary\n+                // between valid and invalid.\n+                // (such as the input `len..len`, which is just barely valid)\n+                $(\n+                    good: data[$good:expr] == $output:expr;\n+                )*\n+\n+                bad: data[$bad:expr];\n+                message: $expect_msg:expr;\n+            }\n+        )*) => {$(\n+            mod $case_name {\n+                #[test]\n+                fn pass() {\n+                    let mut v = $data;\n+\n+                    $( assert_range_eq!($data, $good, $output); )*\n+\n+                    {\n+                        let v: &[_] = &v;\n+                        assert_eq!(v.get($bad), None, \"(in None assertion for get)\");\n+                    }\n+\n+                    {\n+                        let v: &mut [_] = &mut v;\n+                        assert_eq!(v.get_mut($bad), None, \"(in None assertion for get_mut)\");\n+                    }\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_fail() {\n+                    let v = $data;\n+                    let v: &[_] = &v;\n+                    let _v = &v[$bad];\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_mut_fail() {\n+                    let mut v = $data;\n+                    let v: &mut [_] = &mut v;\n+                    let _v = &mut v[$bad];\n+                }\n+            }\n+        )*};\n     }\n+\n+    #[test]\n+    fn simple() {\n+        let v = [0, 1, 2, 3, 4, 5];\n+\n+        assert_range_eq!(v, .., [0, 1, 2, 3, 4, 5]);\n+        assert_range_eq!(v, ..2, [0, 1]);\n+        assert_range_eq!(v, ..=1, [0, 1]);\n+        assert_range_eq!(v, 2.., [2, 3, 4, 5]);\n+        assert_range_eq!(v, 1..4, [1, 2, 3]);\n+        assert_range_eq!(v, 1..=3, [1, 2, 3]);\n+    }\n+\n+    panic_cases! {\n+        in mod rangefrom_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[6..] == [];\n+            bad: data[7..];\n+            message: \"but ends at\"; // perhaps not ideal\n+        }\n+\n+        in mod rangeto_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[..6] == [0, 1, 2, 3, 4, 5];\n+            bad: data[..7];\n+            message: \"out of range\";\n+        }\n+\n+        in mod rangetoinclusive_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[..=5] == [0, 1, 2, 3, 4, 5];\n+            bad: data[..=6];\n+            message: \"out of range\";\n+        }\n+\n+        in mod range_len_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[6..6] == [];\n+            bad: data[7..7];\n+            message: \"out of range\";\n+        }\n+\n+        in mod rangeinclusive_len_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[6..=5] == [];\n+            bad: data[7..=6];\n+            message: \"out of range\";\n+        }\n+    }\n+\n+    panic_cases! {\n+        in mod range_neg_width {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[4..4] == [];\n+            bad: data[4..3];\n+            message: \"but ends at\";\n+        }\n+\n+        in mod rangeinclusive_neg_width {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[4..=3] == [];\n+            bad: data[4..=2];\n+            message: \"but ends at\";\n+        }\n+    }\n+\n+    panic_cases! {\n+        in mod rangeinclusive_overflow {\n+            data: [0, 1];\n+\n+            // note: using 0 specifically ensures that the result of overflowing is 0..0,\n+            //       so that `get` doesn't simply return None for the wrong reason.\n+            bad: data[0 ..= ::std::usize::MAX];\n+            message: \"maximum usize\";\n+        }\n+\n+        in mod rangetoinclusive_overflow {\n+            data: [0, 1];\n+\n+            bad: data[..= ::std::usize::MAX];\n+            message: \"maximum usize\";\n+        }\n+    } // panic_cases!\n }\n \n #[test]"}, {"sha": "343c9596c538321395d4d90a33b54301c255bedf", "filename": "src/libcore/tests/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibcore%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fstr.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// All `str` tests live in collectionstests::str\n+// All `str` tests live in liballoc/tests"}, {"sha": "03aff6410055815a27c1d63bd1b43a8e92b6fe2e", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -12,6 +12,7 @@ use errors::DiagnosticBuilder;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::sync::{Lrc, RwLock, ReadGuard, Lock};\n use std::env;\n use std::hash::Hash;\n@@ -77,7 +78,7 @@ struct DepGraphData {\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n-    previous_work_products: RwLock<FxHashMap<WorkProductId, WorkProduct>>,\n+    previous_work_products: FxHashMap<WorkProductId, WorkProduct>,\n \n     /// Work-products that we generate in this run.\n     work_products: RwLock<FxHashMap<WorkProductId, WorkProduct>>,\n@@ -90,7 +91,8 @@ struct DepGraphData {\n \n impl DepGraph {\n \n-    pub fn new(prev_graph: PreviousDepGraph) -> DepGraph {\n+    pub fn new(prev_graph: PreviousDepGraph,\n+               prev_work_products: FxHashMap<WorkProductId, WorkProduct>) -> DepGraph {\n         // Pre-allocate the fingerprints array. We over-allocate a little so\n         // that we hopefully don't have to re-allocate during this compilation\n         // session.\n@@ -100,7 +102,7 @@ impl DepGraph {\n                                                  (prev_graph_node_count * 115) / 100);\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n-                previous_work_products: RwLock::new(FxHashMap()),\n+                previous_work_products: prev_work_products,\n                 work_products: RwLock::new(FxHashMap()),\n                 dep_node_debug: Lock::new(FxHashMap()),\n                 current: Lock::new(CurrentDepGraph::new()),\n@@ -131,7 +133,7 @@ impl DepGraph {\n         let mut edges = Vec::new();\n         for (index, edge_targets) in current_dep_graph.edges.iter_enumerated() {\n             let from = current_dep_graph.nodes[index];\n-            for &edge_target in edge_targets {\n+            for &edge_target in edge_targets.iter() {\n                 let to = current_dep_graph.nodes[edge_target];\n                 edges.push((from, to));\n             }\n@@ -209,7 +211,7 @@ impl DepGraph {\n         self.with_task_impl(key, cx, arg, false, task,\n             |key| OpenTask::Regular(Lock::new(RegularOpenTask {\n                 node: key,\n-                reads: Vec::new(),\n+                reads: SmallVec::new(),\n                 read_set: FxHashSet(),\n             })),\n             |data, key, task| data.borrow_mut().complete_task(key, task))\n@@ -230,7 +232,7 @@ impl DepGraph {\n \n         self.with_task_impl(key, cx, input, true, identity_fn,\n             |_| OpenTask::Ignore,\n-            |data, key, _| data.borrow_mut().alloc_node(key, Vec::new()))\n+            |data, key, _| data.borrow_mut().alloc_node(key, SmallVec::new()))\n     }\n \n     fn with_task_impl<'gcx, C, A, R>(\n@@ -353,7 +355,7 @@ impl DepGraph {\n         if let Some(ref data) = self.data {\n             let (result, open_task) = ty::tls::with_context(|icx| {\n                 let task = OpenTask::Anon(Lock::new(AnonOpenTask {\n-                    reads: Vec::new(),\n+                    reads: SmallVec::new(),\n                     read_set: FxHashSet(),\n                 }));\n \n@@ -460,19 +462,6 @@ impl DepGraph {\n         self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n     }\n \n-    /// Indicates that a previous work product exists for `v`. This is\n-    /// invoked during initial start-up based on what nodes are clean\n-    /// (and what files exist in the incr. directory).\n-    pub fn insert_previous_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n-        debug!(\"insert_previous_work_product({:?}, {:?})\", v, data);\n-        self.data\n-            .as_ref()\n-            .unwrap()\n-            .previous_work_products\n-            .borrow_mut()\n-            .insert(v.clone(), data);\n-    }\n-\n     /// Indicates that we created the given work-product in this run\n     /// for `v`. This record will be preserved and loaded in the next\n     /// run.\n@@ -492,7 +481,7 @@ impl DepGraph {\n         self.data\n             .as_ref()\n             .and_then(|data| {\n-                data.previous_work_products.borrow().get(v).cloned()\n+                data.previous_work_products.get(v).cloned()\n             })\n     }\n \n@@ -504,8 +493,8 @@ impl DepGraph {\n \n     /// Access the map of work-products created during the cached run. Only\n     /// used during saving of the dep-graph.\n-    pub fn previous_work_products(&self) -> ReadGuard<FxHashMap<WorkProductId, WorkProduct>> {\n-        self.data.as_ref().unwrap().previous_work_products.borrow()\n+    pub fn previous_work_products(&self) -> &FxHashMap<WorkProductId, WorkProduct> {\n+        &self.data.as_ref().unwrap().previous_work_products\n     }\n \n     #[inline(always)]\n@@ -534,15 +523,9 @@ impl DepGraph {\n     }\n \n     pub fn serialize(&self) -> SerializedDepGraph {\n-        let mut fingerprints = self.fingerprints.borrow_mut();\n         let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n \n-        // Make sure we don't run out of bounds below.\n-        if current_dep_graph.nodes.len() > fingerprints.len() {\n-            fingerprints.resize(current_dep_graph.nodes.len(), Fingerprint::ZERO);\n-        }\n-\n-        let fingerprints = fingerprints.clone().convert_index_type();\n+        let fingerprints = self.fingerprints.borrow().clone().convert_index_type();\n         let nodes = current_dep_graph.nodes.clone().convert_index_type();\n \n         let total_edge_count: usize = current_dep_graph.edges.iter()\n@@ -626,7 +609,7 @@ impl DepGraph {\n \n         debug_assert!(data.colors.borrow().get(prev_dep_node_index).is_none());\n \n-        let mut current_deps = Vec::new();\n+        let mut current_deps = SmallVec::new();\n \n         for &dep_dep_node_index in prev_deps {\n             let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n@@ -923,7 +906,7 @@ pub enum WorkProductFileKind {\n \n pub(super) struct CurrentDepGraph {\n     nodes: IndexVec<DepNodeIndex, DepNode>,\n-    edges: IndexVec<DepNodeIndex, Vec<DepNodeIndex>>,\n+    edges: IndexVec<DepNodeIndex, SmallVec<[DepNodeIndex; 8]>>,\n     node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n     forbidden_edge: Option<EdgeFilter>,\n \n@@ -1061,7 +1044,7 @@ impl CurrentDepGraph {\n         } = task {\n             debug_assert_eq!(node, key);\n             let krate_idx = self.node_to_node_index[&DepNode::new_no_params(DepKind::Krate)];\n-            self.alloc_node(node, vec![krate_idx])\n+            self.alloc_node(node, SmallVec::one(krate_idx))\n         } else {\n             bug!(\"complete_eval_always_task() - Expected eval always task to be popped\");\n         }\n@@ -1107,7 +1090,7 @@ impl CurrentDepGraph {\n \n     fn alloc_node(&mut self,\n                   dep_node: DepNode,\n-                  edges: Vec<DepNodeIndex>)\n+                  edges: SmallVec<[DepNodeIndex; 8]>)\n                   -> DepNodeIndex {\n         debug_assert_eq!(self.edges.len(), self.nodes.len());\n         debug_assert_eq!(self.node_to_node_index.len(), self.nodes.len());\n@@ -1122,12 +1105,12 @@ impl CurrentDepGraph {\n \n pub struct RegularOpenTask {\n     node: DepNode,\n-    reads: Vec<DepNodeIndex>,\n+    reads: SmallVec<[DepNodeIndex; 8]>,\n     read_set: FxHashSet<DepNodeIndex>,\n }\n \n pub struct AnonOpenTask {\n-    reads: Vec<DepNodeIndex>,\n+    reads: SmallVec<[DepNodeIndex; 8]>,\n     read_set: FxHashSet<DepNodeIndex>,\n }\n "}, {"sha": "245663494ddef1f7ae2c3b8f600e109b0b3da3ec", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -95,6 +95,23 @@ pub enum Lto {\n     Fat,\n }\n \n+#[derive(Clone, PartialEq, Hash)]\n+pub enum CrossLangLto {\n+    LinkerPlugin(PathBuf),\n+    NoLink,\n+    Disabled\n+}\n+\n+impl CrossLangLto {\n+    pub fn embed_bitcode(&self) -> bool {\n+        match *self {\n+            CrossLangLto::LinkerPlugin(_) |\n+            CrossLangLto::NoLink => true,\n+            CrossLangLto::Disabled => false,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Hash)]\n pub enum DebugInfoLevel {\n     NoDebugInfo,\n@@ -412,6 +429,7 @@ top_level_options!(\n \n         // Remap source path prefixes in all output (messages, object files, debug, etc)\n         remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n+\n         edition: Edition [TRACKED],\n     }\n );\n@@ -777,11 +795,15 @@ macro_rules! options {\n             Some(\"`string` or `string=string`\");\n         pub const parse_lto: Option<&'static str> =\n             Some(\"one of `thin`, `fat`, or omitted\");\n+        pub const parse_cross_lang_lto: Option<&'static str> =\n+            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `no-link`, \\\n+                  or the path to the linker plugin\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, SomePasses, AllPasses, Sanitizer, Lto};\n+        use super::{$struct_name, Passes, SomePasses, AllPasses, Sanitizer, Lto,\n+                    CrossLangLto};\n         use rustc_target::spec::{LinkerFlavor, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n \n@@ -986,6 +1008,26 @@ macro_rules! options {\n             true\n         }\n \n+        fn parse_cross_lang_lto(slot: &mut CrossLangLto, v: Option<&str>) -> bool {\n+            if v.is_some() {\n+                let mut bool_arg = None;\n+                if parse_opt_bool(&mut bool_arg, v) {\n+                    *slot = if bool_arg.unwrap() {\n+                        CrossLangLto::NoLink\n+                    } else {\n+                        CrossLangLto::Disabled\n+                    };\n+                    return true\n+                }\n+            }\n+\n+            *slot = match v {\n+                None |\n+                Some(\"no-link\") => CrossLangLto::NoLink,\n+                Some(path) => CrossLangLto::LinkerPlugin(PathBuf::from(path)),\n+            };\n+            true\n+        }\n     }\n ) }\n \n@@ -1295,7 +1337,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"make the current crate share its generic instantiations\"),\n     chalk: bool = (false, parse_bool, [TRACKED],\n           \"enable the experimental Chalk-based trait solving engine\"),\n-    cross_lang_lto: bool = (false, parse_bool, [TRACKED],\n+    cross_lang_lto: CrossLangLto = (CrossLangLto::Disabled, parse_cross_lang_lto, [TRACKED],\n           \"generate build artifacts that are compatible with linker-based LTO.\"),\n }\n \n@@ -2327,7 +2369,7 @@ mod dep_tracking {\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{CrateType, DebugInfoLevel, ErrorOutputType, Lto, OptLevel, OutputTypes,\n-                Passes, Sanitizer};\n+                Passes, Sanitizer, CrossLangLto};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n@@ -2391,6 +2433,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Option<Sanitizer>);\n     impl_dep_tracking_hash_via_hash!(TargetTriple);\n     impl_dep_tracking_hash_via_hash!(Edition);\n+    impl_dep_tracking_hash_via_hash!(CrossLangLto);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n@@ -2455,7 +2498,7 @@ mod tests {\n     use lint;\n     use middle::cstore;\n     use session::config::{build_configuration, build_session_options_and_crate_config};\n-    use session::config::Lto;\n+    use session::config::{Lto, CrossLangLto};\n     use session::build_session;\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n@@ -3111,6 +3154,10 @@ mod tests {\n         opts = reference.clone();\n         opts.debugging_opts.relro_level = Some(RelroLevel::Full);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.cross_lang_lto = CrossLangLto::NoLink;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n \n     #[test]"}, {"sha": "23f84881c798098355513316001a1cb34bee001c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -657,6 +657,13 @@ impl Session {\n         }\n     }\n \n+    pub fn target_cpu(&self) -> &str {\n+        match self.opts.cg.target_cpu {\n+            Some(ref s) => &**s,\n+            None => &*self.target.target.options.cpu\n+        }\n+    }\n+\n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n         if let Some(x) = self.opts.cg.force_frame_pointers {\n             x"}, {"sha": "1e74039503d51c5760498d1fd3f8de3f75e7b5d5", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -980,15 +980,16 @@ where\n     let dep_graph = match future_dep_graph {\n         None => DepGraph::new_disabled(),\n         Some(future) => {\n-            let prev_graph = time(sess, \"blocked while dep-graph loading finishes\", || {\n-                future\n-                    .open()\n-                    .unwrap_or_else(|e| rustc_incremental::LoadResult::Error {\n-                        message: format!(\"could not decode incremental cache: {:?}\", e),\n-                    })\n-                    .open(sess)\n-            });\n-            DepGraph::new(prev_graph)\n+            let (prev_graph, prev_work_products) =\n+                time(sess, \"blocked while dep-graph loading finishes\", || {\n+                    future\n+                        .open()\n+                        .unwrap_or_else(|e| rustc_incremental::LoadResult::Error {\n+                            message: format!(\"could not decode incremental cache: {:?}\", e),\n+                        })\n+                        .open(sess)\n+                });\n+            DepGraph::new(prev_graph, prev_work_products)\n         }\n     };\n     let hir_forest = time(sess, \"lowering ast -> hir\", || {"}, {"sha": "f846759545eb949fbf82cf122be625c2325b7cad", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -10,7 +10,8 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use rustc::dep_graph::{PreviousDepGraph, SerializedDepGraph};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::OnDiskCache;\n@@ -32,73 +33,30 @@ pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     tcx.allocate_metadata_dep_nodes();\n     tcx.precompute_in_scope_traits_hashes();\n-\n-    if tcx.sess.incr_comp_session_dir_opt().is_none() {\n-        // If we are only building with -Zquery-dep-graph but without an actual\n-        // incr. comp. session directory, we exit here. Otherwise we'd fail\n-        // when trying to load work products.\n-        return\n-    }\n-\n-    let work_products_path = work_products_path(tcx.sess);\n-    let load_result = load_data(tcx.sess.opts.debugging_opts.incremental_info, &work_products_path);\n-\n-    if let LoadResult::Ok { data: (work_products_data, start_pos) } = load_result {\n-        // Decode the list of work_products\n-        let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n-        let work_products: Vec<SerializedWorkProduct> =\n-            RustcDecodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n-                let msg = format!(\"Error decoding `work-products` from incremental \\\n-                                   compilation session directory: {}\", e);\n-                tcx.sess.fatal(&msg[..])\n-            });\n-\n-        for swp in work_products {\n-            let mut all_files_exist = true;\n-            for &(_, ref file_name) in swp.work_product.saved_files.iter() {\n-                let path = in_incr_comp_dir_sess(tcx.sess, file_name);\n-                if !path.exists() {\n-                    all_files_exist = false;\n-\n-                    if tcx.sess.opts.debugging_opts.incremental_info {\n-                        eprintln!(\"incremental: could not find file for work \\\n-                                   product: {}\", path.display());\n-                    }\n-                }\n-            }\n-\n-            if all_files_exist {\n-                debug!(\"reconcile_work_products: all files for {:?} exist\", swp);\n-                tcx.dep_graph.insert_previous_work_product(&swp.id, swp.work_product);\n-            } else {\n-                debug!(\"reconcile_work_products: some file for {:?} does not exist\", swp);\n-                delete_dirty_work_product(tcx, swp);\n-            }\n-        }\n-    }\n }\n \n+type WorkProductMap = FxHashMap<WorkProductId, WorkProduct>;\n+\n pub enum LoadResult<T> {\n     Ok { data: T },\n     DataOutOfDate,\n     Error { message: String },\n }\n \n-\n-impl LoadResult<PreviousDepGraph> {\n-    pub fn open(self, sess: &Session) -> PreviousDepGraph {\n+impl LoadResult<(PreviousDepGraph, WorkProductMap)> {\n+    pub fn open(self, sess: &Session) -> (PreviousDepGraph, WorkProductMap) {\n         match self {\n             LoadResult::Error { message } => {\n                 sess.warn(&message);\n-                PreviousDepGraph::new(SerializedDepGraph::new())\n+                (PreviousDepGraph::new(SerializedDepGraph::new()), FxHashMap())\n             },\n             LoadResult::DataOutOfDate => {\n                 if let Err(err) = delete_all_session_dir_contents(sess) {\n                     sess.err(&format!(\"Failed to delete invalidated or incompatible \\\n                                       incremental compilation session directory contents `{}`: {}.\",\n                                       dep_graph_path(sess).display(), err));\n                 }\n-                PreviousDepGraph::new(SerializedDepGraph::new())\n+                (PreviousDepGraph::new(SerializedDepGraph::new()), FxHashMap())\n             }\n             LoadResult::Ok { data } => data\n         }\n@@ -125,10 +83,10 @@ fn load_data(report_incremental_info: bool, path: &Path) -> LoadResult<(Vec<u8>,\n     }\n }\n \n-fn delete_dirty_work_product(tcx: TyCtxt,\n+fn delete_dirty_work_product(sess: &Session,\n                              swp: SerializedWorkProduct) {\n     debug!(\"delete_dirty_work_product({:?})\", swp);\n-    work_product::delete_workproduct_files(tcx.sess, &swp.work_product);\n+    work_product::delete_workproduct_files(sess, &swp.work_product);\n }\n \n /// Either a result that has already be computed or a\n@@ -149,7 +107,7 @@ impl<T> MaybeAsync<T> {\n \n /// Launch a thread and load the dependency graph in the background.\n pub fn load_dep_graph(sess: &Session) ->\n-    MaybeAsync<LoadResult<PreviousDepGraph>>\n+    MaybeAsync<LoadResult<(PreviousDepGraph, WorkProductMap)>>\n {\n     // Since `sess` isn't `Sync`, we perform all accesses to `sess`\n     // before we fire the background thread.\n@@ -159,7 +117,7 @@ pub fn load_dep_graph(sess: &Session) ->\n     if sess.opts.incremental.is_none() {\n         // No incremental compilation.\n         return MaybeAsync::Sync(LoadResult::Ok {\n-            data: PreviousDepGraph::new(SerializedDepGraph::new())\n+            data: (PreviousDepGraph::new(SerializedDepGraph::new()), FxHashMap())\n         });\n     }\n \n@@ -169,6 +127,50 @@ pub fn load_dep_graph(sess: &Session) ->\n     let report_incremental_info = sess.opts.debugging_opts.incremental_info;\n     let expected_hash = sess.opts.dep_tracking_hash();\n \n+    let mut prev_work_products = FxHashMap();\n+\n+    // If we are only building with -Zquery-dep-graph but without an actual\n+    // incr. comp. session directory, we skip this. Otherwise we'd fail\n+    // when trying to load work products.\n+    if sess.incr_comp_session_dir_opt().is_some() {\n+        let work_products_path = work_products_path(sess);\n+        let load_result = load_data(report_incremental_info, &work_products_path);\n+\n+        if let LoadResult::Ok { data: (work_products_data, start_pos) } = load_result {\n+            // Decode the list of work_products\n+            let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n+            let work_products: Vec<SerializedWorkProduct> =\n+                RustcDecodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n+                    let msg = format!(\"Error decoding `work-products` from incremental \\\n+                                    compilation session directory: {}\", e);\n+                    sess.fatal(&msg[..])\n+                });\n+\n+            for swp in work_products {\n+                let mut all_files_exist = true;\n+                for &(_, ref file_name) in swp.work_product.saved_files.iter() {\n+                    let path = in_incr_comp_dir_sess(sess, file_name);\n+                    if !path.exists() {\n+                        all_files_exist = false;\n+\n+                        if sess.opts.debugging_opts.incremental_info {\n+                            eprintln!(\"incremental: could not find file for work \\\n+                                    product: {}\", path.display());\n+                        }\n+                    }\n+                }\n+\n+                if all_files_exist {\n+                    debug!(\"reconcile_work_products: all files for {:?} exist\", swp);\n+                    prev_work_products.insert(swp.id, swp.work_product);\n+                } else {\n+                    debug!(\"reconcile_work_products: some file for {:?} does not exist\", swp);\n+                    delete_dirty_work_product(sess, swp);\n+                }\n+            }\n+        }\n+    }\n+\n     MaybeAsync::Async(std::thread::spawn(move || {\n         time_ext(time_passes, None, \"background load prev dep-graph\", move || {\n             match load_data(report_incremental_info, &path) {\n@@ -195,7 +197,7 @@ pub fn load_dep_graph(sess: &Session) ->\n                     let dep_graph = SerializedDepGraph::decode(&mut decoder)\n                         .expect(\"Error reading cached dep-graph\");\n \n-                    LoadResult::Ok { data: PreviousDepGraph::new(dep_graph) }\n+                    LoadResult::Ok { data: (PreviousDepGraph::new(dep_graph), prev_work_products) }\n                 }\n             }\n         })"}, {"sha": "87b3a2dc69ff91fc5f3bc4f5bb9b98ff7ecbb45d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -51,7 +51,6 @@ pub struct Library {\n pub struct CrateLoader<'a> {\n     pub sess: &'a Session,\n     cstore: &'a CStore,\n-    next_crate_num: CrateNum,\n     local_crate_name: Symbol,\n }\n \n@@ -102,7 +101,6 @@ impl<'a> CrateLoader<'a> {\n         CrateLoader {\n             sess,\n             cstore,\n-            next_crate_num: cstore.next_crate_num(),\n             local_crate_name: Symbol::intern(local_crate_name),\n         }\n     }\n@@ -198,8 +196,7 @@ impl<'a> CrateLoader<'a> {\n         self.verify_no_symbol_conflicts(span, &crate_root);\n \n         // Claim this crate number and cache it\n-        let cnum = self.next_crate_num;\n-        self.next_crate_num = CrateNum::from_u32(cnum.as_u32() + 1);\n+        let cnum = self.cstore.alloc_new_crate_num();\n \n         // Stash paths for top-most crate locally if necessary.\n         let crate_paths = if root.is_none() {\n@@ -219,6 +216,8 @@ impl<'a> CrateLoader<'a> {\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n+        let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n+\n         let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n             crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n@@ -239,8 +238,9 @@ impl<'a> CrateLoader<'a> {\n             }),\n             root: crate_root,\n             blob: metadata,\n-            cnum_map: Lock::new(cnum_map),\n+            cnum_map,\n             cnum,\n+            dependencies: Lock::new(dependencies),\n             codemap_import_info: RwLock::new(vec![]),\n             attribute_cache: Lock::new([Vec::new(), Vec::new()]),\n             dep_kind: Lock::new(dep_kind),\n@@ -392,7 +392,7 @@ impl<'a> CrateLoader<'a> {\n \n         // Propagate the extern crate info to dependencies.\n         extern_crate.direct = false;\n-        for &dep_cnum in cmeta.cnum_map.borrow().iter() {\n+        for &dep_cnum in cmeta.dependencies.borrow().iter() {\n             self.update_extern_crate(dep_cnum, extern_crate, visited);\n         }\n     }\n@@ -1040,7 +1040,7 @@ impl<'a> CrateLoader<'a> {\n             }\n \n             info!(\"injecting a dep from {} to {}\", cnum, krate);\n-            data.cnum_map.borrow_mut().push(krate);\n+            data.dependencies.borrow_mut().push(krate);\n         });\n     }\n }"}, {"sha": "9bbce563b61dc15d145e32aea675d50f52f30581", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -64,8 +64,9 @@ pub struct CrateMetadata {\n     pub extern_crate: Lock<Option<ExternCrate>>,\n \n     pub blob: MetadataBlob,\n-    pub cnum_map: Lock<CrateNumMap>,\n+    pub cnum_map: CrateNumMap,\n     pub cnum: CrateNum,\n+    pub dependencies: Lock<Vec<CrateNum>>,\n     pub codemap_import_info: RwLock<Vec<ImportedFileMap>>,\n     pub attribute_cache: Lock<[Vec<Option<Lrc<[ast::Attribute]>>>; 2]>,\n \n@@ -96,32 +97,34 @@ pub struct CStore {\n impl CStore {\n     pub fn new(metadata_loader: Box<MetadataLoader + Sync>) -> CStore {\n         CStore {\n-            metas: RwLock::new(IndexVec::new()),\n+            // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n+            // order to make array indices in `metas` match with the\n+            // corresponding `CrateNum`. This first entry will always remain\n+            // `None`.\n+            metas: RwLock::new(IndexVec::from_elem_n(None, 1)),\n             extern_mod_crate_map: Lock::new(FxHashMap()),\n             metadata_loader,\n         }\n     }\n \n-    /// You cannot use this function to allocate a CrateNum in a thread-safe manner.\n-    /// It is currently only used in CrateLoader which is single-threaded code.\n-    pub fn next_crate_num(&self) -> CrateNum {\n-        CrateNum::new(self.metas.borrow().len() + 1)\n+    pub(super) fn alloc_new_crate_num(&self) -> CrateNum {\n+        let mut metas = self.metas.borrow_mut();\n+        let cnum = CrateNum::new(metas.len());\n+        metas.push(None);\n+        cnum\n     }\n \n-    pub fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n+    pub(super) fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n         self.metas.borrow()[cnum].clone().unwrap()\n     }\n \n-    pub fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n-        use rustc_data_structures::indexed_vec::Idx;\n-        let mut met = self.metas.borrow_mut();\n-        while met.len() <= cnum.index() {\n-            met.push(None);\n-        }\n-        met[cnum] = Some(data);\n+    pub(super) fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n+        let mut metas = self.metas.borrow_mut();\n+        assert!(metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n+        metas[cnum] = Some(data);\n     }\n \n-    pub fn iter_crate_data<I>(&self, mut i: I)\n+    pub(super) fn iter_crate_data<I>(&self, mut i: I)\n         where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n     {\n         for (k, v) in self.metas.borrow().iter_enumerated() {\n@@ -131,20 +134,22 @@ impl CStore {\n         }\n     }\n \n-    pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n+    pub(super) fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);\n         ordering.reverse();\n         ordering\n     }\n \n-    pub fn push_dependencies_in_postorder(&self, ordering: &mut Vec<CrateNum>, krate: CrateNum) {\n+    pub(super) fn push_dependencies_in_postorder(&self,\n+                                                 ordering: &mut Vec<CrateNum>,\n+                                                 krate: CrateNum) {\n         if ordering.contains(&krate) {\n             return;\n         }\n \n         let data = self.get_crate_data(krate);\n-        for &dep in data.cnum_map.borrow().iter() {\n+        for &dep in data.dependencies.borrow().iter() {\n             if dep != krate {\n                 self.push_dependencies_in_postorder(ordering, dep);\n             }\n@@ -153,7 +158,7 @@ impl CStore {\n         ordering.push(krate);\n     }\n \n-    pub fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n+    pub(super) fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         for (num, v) in self.metas.borrow().iter_enumerated() {\n             if let &Some(_) = v {\n@@ -163,11 +168,11 @@ impl CStore {\n         return ordering\n     }\n \n-    pub fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n+    pub(super) fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n-    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n+    pub(super) fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n }"}, {"sha": "53d1ff156274e796c855541d2aeef35699ec8d94", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx: 'a> TyDecoder<'a, 'tcx> for DecodeContext<'a, 'tcx> {\n         if cnum == LOCAL_CRATE {\n             self.cdata().cnum\n         } else {\n-            self.cdata().cnum_map.borrow()[cnum]\n+            self.cdata().cnum_map[cnum]\n         }\n     }\n }\n@@ -932,7 +932,7 @@ impl<'a, 'tcx> CrateMetadata {\n     // Translate a DefId from the current compilation environment to a DefId\n     // for an external crate.\n     fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n-        for (local, &global) in self.cnum_map.borrow().iter_enumerated() {\n+        for (local, &global) in self.cnum_map.iter_enumerated() {\n             if global == did.krate {\n                 return Some(DefId {\n                     krate: local,\n@@ -1007,7 +1007,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .enumerate()\n             .flat_map(|(i, link)| {\n                 let cnum = CrateNum::new(i + 1);\n-                link.map(|link| (self.cnum_map.borrow()[cnum], link))\n+                link.map(|link| (self.cnum_map[cnum], link))\n             })\n             .collect()\n     }"}, {"sha": "d39556e9bb197e6ff91aaef9fad166ee04bd3268", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -970,6 +970,9 @@ fn link_args(cmd: &mut Linker,\n              out_filename: &Path,\n              trans: &CrateTranslation) {\n \n+    // Linker plugins should be specified early in the list of arguments\n+    cmd.cross_lang_lto();\n+\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();"}, {"sha": "2a84ffe79b285f033711473fb3d5794e60a6ade0", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -21,7 +21,8 @@ use back::symbol_export;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n-use rustc::session::config::{self, CrateType, OptLevel, DebugInfoLevel};\n+use rustc::session::config::{self, CrateType, OptLevel, DebugInfoLevel,\n+                             CrossLangLto};\n use rustc::ty::TyCtxt;\n use rustc_target::spec::{LinkerFlavor, LldFlavor};\n use serialize::{json, Encoder};\n@@ -127,6 +128,7 @@ pub trait Linker {\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n     fn group_end(&mut self);\n+    fn cross_lang_lto(&mut self);\n     // Should have been finalize(self), but we don't support self-by-value on trait objects (yet?).\n     fn finalize(&mut self) -> Command;\n }\n@@ -434,6 +436,42 @@ impl<'a> Linker for GccLinker<'a> {\n             self.linker_arg(\"--end-group\");\n         }\n     }\n+\n+    fn cross_lang_lto(&mut self) {\n+        match self.sess.opts.debugging_opts.cross_lang_lto {\n+            CrossLangLto::Disabled |\n+            CrossLangLto::NoLink => {\n+                // Nothing to do\n+            }\n+            CrossLangLto::LinkerPlugin(ref path) => {\n+                self.linker_arg(&format!(\"-plugin={}\", path.display()));\n+\n+                let opt_level = match self.sess.opts.optimize {\n+                    config::OptLevel::No => \"O0\",\n+                    config::OptLevel::Less => \"O1\",\n+                    config::OptLevel::Default => \"O2\",\n+                    config::OptLevel::Aggressive => \"O3\",\n+                    config::OptLevel::Size => \"Os\",\n+                    config::OptLevel::SizeMin => \"Oz\",\n+                };\n+\n+                self.linker_arg(&format!(\"-plugin-opt={}\", opt_level));\n+                self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", self.sess.target_cpu()));\n+\n+                match self.sess.opts.cg.lto {\n+                    config::Lto::Thin |\n+                    config::Lto::ThinLocal => {\n+                        self.linker_arg(&format!(\"-plugin-opt=thin\"));\n+                    }\n+                    config::Lto::Fat |\n+                    config::Lto::Yes |\n+                    config::Lto::No => {\n+                        // default to regular LTO\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n@@ -666,6 +704,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n     // MSVC doesn't need group indicators\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n+\n+    fn cross_lang_lto(&mut self) {\n+        // Do nothing\n+    }\n }\n \n pub struct EmLinker<'a> {\n@@ -832,6 +874,10 @@ impl<'a> Linker for EmLinker<'a> {\n     // Appears not necessary on Emscripten\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n+\n+    fn cross_lang_lto(&mut self) {\n+        // Do nothing\n+    }\n }\n \n fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n@@ -984,4 +1030,8 @@ impl Linker for WasmLd {\n     // Not needed for now with LLD\n     fn group_start(&mut self) {}\n     fn group_end(&mut self) {}\n+\n+    fn cross_lang_lto(&mut self) {\n+        // Do nothing for now\n+    }\n }"}, {"sha": "64876e82309f05182f6fba788b23b39b39047540", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -174,10 +174,7 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n     let triple = &sess.target.target.llvm_target;\n \n     let triple = CString::new(triple.as_bytes()).unwrap();\n-    let cpu = match sess.opts.cg.target_cpu {\n-        Some(ref s) => &**s,\n-        None => &*sess.target.target.options.cpu\n-    };\n+    let cpu = sess.target_cpu();\n     let cpu = CString::new(cpu.as_bytes()).unwrap();\n     let features = attributes::llvm_target_features(sess)\n         .collect::<Vec<_>>()\n@@ -294,7 +291,7 @@ impl ModuleConfig {\n         self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode;\n         let embed_bitcode = sess.target.target.options.embed_bitcode ||\n                             sess.opts.debugging_opts.embed_bitcode ||\n-                            sess.opts.debugging_opts.cross_lang_lto;\n+                            sess.opts.debugging_opts.cross_lang_lto.embed_bitcode();\n         if embed_bitcode {\n             match sess.opts.optimize {\n                 config::OptLevel::No |\n@@ -1358,7 +1355,8 @@ fn execute_work_item(cgcx: &CodegenContext,\n \n             // Don't run LTO passes when cross-lang LTO is enabled. The linker\n             // will do that for us in this case.\n-            let needs_lto = needs_lto && !cgcx.opts.debugging_opts.cross_lang_lto;\n+            let needs_lto = needs_lto &&\n+                !cgcx.opts.debugging_opts.cross_lang_lto.embed_bitcode();\n \n             if needs_lto {\n                 Ok(WorkItemResult::NeedsLTO(mtrans))"}, {"sha": "f849db4ec6027ea8ee962fc58b475c74f4a2ac10", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -11,9 +11,9 @@\n //! This module provides constants which are specific to the implementation\n //! of the `f32` floating point data type.\n //!\n-//! Mathematically significant numbers are provided in the `consts` sub-module.\n-//!\n //! *[See also the `f32` primitive type](../../std/primitive.f32.html).*\n+//!\n+//! Mathematically significant numbers are provided in the `consts` sub-module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n@@ -195,8 +195,10 @@ impl f32 {\n     }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n+    /// error, yielding a more accurate result than an unfused multiply-add.\n+    ///\n+    /// Using `mul_add` can be more performant than an unfused multiply-add if\n+    /// the target architecture has a dedicated `fma` CPU instruction.\n     ///\n     /// ```\n     /// use std::f32;"}, {"sha": "40c3f4d0ef72623716a591a2d52559fa45644a28", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -11,9 +11,9 @@\n //! This module provides constants which are specific to the implementation\n //! of the `f64` floating point data type.\n //!\n-//! Mathematically significant numbers are provided in the `consts` sub-module.\n-//!\n //! *[See also the `f64` primitive type](../../std/primitive.f64.html).*\n+//!\n+//! Mathematically significant numbers are provided in the `consts` sub-module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n@@ -173,8 +173,10 @@ impl f64 {\n     }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n+    /// error, yielding a more accurate result than an unfused multiply-add.\n+    ///\n+    /// Using `mul_add` can be more performant than an unfused multiply-add if\n+    /// the target architecture has a dedicated `fma` CPU instruction.\n     ///\n     /// ```\n     /// let m = 10.0_f64;"}, {"sha": "7074928eaf6daac7dd4334b9c32803daf5c4ae46", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -370,6 +370,8 @@ mod prim_unit { }\n //\n /// Raw, unsafe pointers, `*const T`, and `*mut T`.\n ///\n+/// *[See also the `std::ptr` module](ptr/index.html).*\n+///\n /// Working with raw pointers in Rust is uncommon,\n /// typically limited to a few patterns.\n ///\n@@ -444,8 +446,6 @@ mod prim_unit { }\n /// but C APIs hand out a lot of pointers generally, so are a common source\n /// of raw pointers in Rust.\n ///\n-/// *[See also the `std::ptr` module](ptr/index.html).*\n-///\n /// [`null`]: ../std/ptr/fn.null.html\n /// [`null_mut`]: ../std/ptr/fn.null_mut.html\n /// [`is_null`]: ../std/primitive.pointer.html#method.is_null\n@@ -563,6 +563,8 @@ mod prim_array { }\n //\n /// A dynamically-sized view into a contiguous sequence, `[T]`.\n ///\n+/// *[See also the `std::slice` module](slice/index.html).*\n+///\n /// Slices are a view into a block of memory represented as a pointer and a\n /// length.\n ///\n@@ -585,24 +587,20 @@ mod prim_array { }\n /// assert_eq!(x, &[1, 7, 3]);\n /// ```\n ///\n-/// *[See also the `std::slice` module](slice/index.html).*\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_slice { }\n \n #[doc(primitive = \"str\")]\n //\n /// String slices.\n ///\n+/// *[See also the `std::str` module](str/index.html).*\n+///\n /// The `str` type, also called a 'string slice', is the most primitive string\n /// type. It is usually seen in its borrowed form, `&str`. It is also the type\n /// of string literals, `&'static str`.\n ///\n-/// Strings slices are always valid UTF-8.\n-///\n-/// This documentation describes a number of methods and trait implementations\n-/// on the `str` type. For technical reasons, there is additional, separate\n-/// documentation in the [`std::str`](str/index.html) module as well.\n+/// String slices are always valid UTF-8.\n ///\n /// # Examples\n ///\n@@ -862,23 +860,23 @@ mod prim_u128 { }\n //\n /// The pointer-sized signed integer type.\n ///\n+/// *[See also the `std::isize` module](isize/index.html).*\n+///\n /// The size of this primitive is how many bytes it takes to reference any\n /// location in memory. For example, on a 32 bit target, this is 4 bytes\n /// and on a 64 bit target, this is 8 bytes.\n-///\n-/// *[See also the `std::isize` module](isize/index.html).*\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_isize { }\n \n #[doc(primitive = \"usize\")]\n //\n /// The pointer-sized unsigned integer type.\n ///\n+/// *[See also the `std::usize` module](usize/index.html).*\n+///\n /// The size of this primitive is how many bytes it takes to reference any\n /// location in memory. For example, on a 32 bit target, this is 4 bytes\n /// and on a 64 bit target, this is 8 bytes.\n-///\n-/// *[See also the `std::usize` module](usize/index.html).*\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_usize { }\n "}, {"sha": "49b30c6f460fe61ac544148ebc6ed7af03dfc5e9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -5741,7 +5741,7 @@ impl<'a> Parser<'a> {\n                 let vis = p.parse_visibility(true)?;\n                 let ty = p.parse_ty()?;\n                 Ok(StructField {\n-                    span: lo.to(p.span),\n+                    span: lo.to(ty.span),\n                     vis,\n                     ident: None,\n                     id: ast::DUMMY_NODE_ID,"}, {"sha": "601a0273ae91178efa1b52a9c58321a1ea397d7c", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -31,11 +31,13 @@ pub struct Span(u32);\n \n impl Copy for Span {}\n impl Clone for Span {\n+    #[inline]\n     fn clone(&self) -> Span {\n         *self\n     }\n }\n impl PartialEq for Span {\n+    #[inline]\n     fn eq(&self, other: &Span) -> bool {\n         let a = self.0;\n         let b = other.0;\n@@ -44,6 +46,7 @@ impl PartialEq for Span {\n }\n impl Eq for Span {}\n impl Hash for Span {\n+    #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         let a = self.0;\n         a.hash(state)"}, {"sha": "fd7dd99edf371ac502ae4e70288c027f6692ace0", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -1 +1 @@\n-Subproject commit b6c1a03fb498f6c03d1cbfd4404223a046f8c3b2\n+Subproject commit fd7dd99edf371ac502ae4e70288c027f6692ace0"}, {"sha": "925f686fe1161bb4b036d59ee257a2d30124e697", "filename": "src/test/run-make/cross-lang-lto/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Frun-make%2Fcross-lang-lto%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Frun-make%2Fcross-lang-lto%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcross-lang-lto%2FMakefile?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -18,9 +18,9 @@ endif\n OBJDUMP=llvm-objdump\n SECTION_HEADERS=$(OBJDUMP) -section-headers\n \n-BUILD_LIB=$(RUSTC) lib.rs -Copt-level=2 -Z cross-lang-lto -Ccodegen-units=1\n+BUILD_LIB=$(RUSTC) lib.rs -Copt-level=2 -Z cross-lang-lto=no-link -Ccodegen-units=1\n \n-BUILD_EXE=$(RUSTC) main.rs -Copt-level=2 -Z cross-lang-lto -Ccodegen-units=1 --emit=obj\n+BUILD_EXE=$(RUSTC) main.rs -Copt-level=2 -Z cross-lang-lto=no-link -Ccodegen-units=1 --emit=obj\n \n all: staticlib staticlib-fat-lto staticlib-thin-lto rlib exe cdylib rdylib\n "}, {"sha": "fe3e294d9e32ad24112df7ce06fad8b75e9be7e5", "filename": "src/test/ui/issue-3008-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Fissue-3008-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Fissue-3008-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-3008-1.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -5,7 +5,7 @@ LL | enum Bar {\n    | ^^^^^^^^ recursive type has infinite size\n ...\n LL |     BarSome(Bar)\n-   |             ---- recursive without indirection\n+   |             --- recursive without indirection\n    |\n    = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n "}, {"sha": "b7e359af64ad06ea0c0f78ffc4e7f9e0c204b186", "filename": "src/test/ui/issue-32326.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Fissue-32326.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Fissue-32326.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-32326.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -4,7 +4,7 @@ error[E0072]: recursive type `Expr` has infinite size\n LL | enum Expr { //~ ERROR E0072\n    | ^^^^^^^^^ recursive type has infinite size\n LL |     Plus(Expr, Expr),\n-   |          ----- ----- recursive without indirection\n+   |          ----  ---- recursive without indirection\n    |          |\n    |          recursive without indirection\n    |"}, {"sha": "5071465b5f647569c5c5e754601658179bb411fe", "filename": "src/test/ui/rfc-2093-infer-outlives/enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -20,14 +20,14 @@ enum Foo<'a, T> {\n \n // Type U needs to outlive lifetime 'b\n struct Bar<'b, U> {\n-    field2: &'b U //~ ERROR 23:5: 23:18: the parameter type `U` may not live long enough [E0309]\n+    field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n }\n \n \n \n // Type K needs to outlive lifetime 'c.\n enum Ying<'c, K> {\n-    One(&'c Yang<K>) //~ ERROR 30:9: 30:21: the parameter type `K` may not live long enough [E0309]\n+    One(&'c Yang<K>) //~ ERROR the parameter type `K` may not live long enough [E0309]\n }\n \n struct Yang<V> {"}, {"sha": "604dd0b43c04a775346316858a92a415f0fbd987", "filename": "src/test/ui/rfc-2093-infer-outlives/enum.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -3,28 +3,28 @@ error[E0309]: the parameter type `U` may not live long enough\n    |\n LL | struct Bar<'b, U> {\n    |                - help: consider adding an explicit lifetime bound `U: 'b`...\n-LL |     field2: &'b U //~ ERROR 23:5: 23:18: the parameter type `U` may not live long enough [E0309]\n+LL |     field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n    |     ^^^^^^^^^^^^^\n    |\n note: ...so that the reference type `&'b U` does not outlive the data it points at\n   --> $DIR/enum.rs:23:5\n    |\n-LL |     field2: &'b U //~ ERROR 23:5: 23:18: the parameter type `U` may not live long enough [E0309]\n+LL |     field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n    |     ^^^^^^^^^^^^^\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/enum.rs:30:9\n    |\n LL | enum Ying<'c, K> {\n    |               - help: consider adding an explicit lifetime bound `K: 'c`...\n-LL |     One(&'c Yang<K>) //~ ERROR 30:9: 30:21: the parameter type `K` may not live long enough [E0309]\n-   |         ^^^^^^^^^^^^\n+LL |     One(&'c Yang<K>) //~ ERROR the parameter type `K` may not live long enough [E0309]\n+   |         ^^^^^^^^^^^\n    |\n note: ...so that the reference type `&'c Yang<K>` does not outlive the data it points at\n   --> $DIR/enum.rs:30:9\n    |\n-LL |     One(&'c Yang<K>) //~ ERROR 30:9: 30:21: the parameter type `K` may not live long enough [E0309]\n-   |         ^^^^^^^^^^^^\n+LL |     One(&'c Yang<K>) //~ ERROR the parameter type `K` may not live long enough [E0309]\n+   |         ^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e71166ed65bba4ec9bbb6030dc8ab481a6a468e6", "filename": "src/test/ui/rfc1598-generic-associated-types/collections.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_associated_types)]\n+#![feature(associated_type_defaults)]\n+\n+//FIXME(#44265): \"lifetime parameters are not allowed on this type\" errors will be addressed in a\n+//follow-up PR\n+\n+// A Collection trait and collection families. Based on\n+// http://smallcultfollowing.com/babysteps/blog/2016/11/03/\n+// associated-type-constructors-part-2-family-traits/\n+\n+trait Collection<T> {\n+    type Iter<'iter>: Iterator<Item=&'iter T>;\n+    type Family: CollectionFamily;\n+    // Test associated type defaults with parameters\n+    type Sibling<U>: Collection<U> =\n+        <<Self as Collection<T>>::Family as CollectionFamily>::Member<U>;\n+    //~^ ERROR type parameters are not allowed on this type [E0109]\n+\n+    fn empty() -> Self;\n+\n+    fn add(&mut self, value: T);\n+\n+    fn iterate<'iter>(&'iter self) -> Self::Iter<'iter>;\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+}\n+\n+trait CollectionFamily {\n+    type Member<T>: Collection<T, Family = Self>;\n+}\n+\n+struct VecFamily;\n+\n+impl CollectionFamily for VecFamily {\n+    type Member<T> = Vec<T>;\n+}\n+\n+impl<T> Collection<T> for Vec<T> {\n+    type Iter<'iter> = std::slice::Iter<'iter, T>;\n+    type Family = VecFamily;\n+\n+    fn empty() -> Self {\n+        Vec::new()\n+    }\n+\n+    fn add(&mut self, value: T) {\n+        self.push(value)\n+    }\n+\n+    fn iterate<'iter>(&'iter self) -> Self::Iter<'iter> {\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+        self.iter()\n+    }\n+}\n+\n+fn floatify<C>(ints: &C) -> <<C as Collection<i32>>::Family as CollectionFamily>::Member<f32>\n+//~^ ERROR type parameters are not allowed on this type [E0109]\n+where\n+    C: Collection<i32>,\n+{\n+    let mut res = C::Family::Member::<f32>::empty();\n+    for &v in ints.iterate() {\n+        res.add(v as f32);\n+    }\n+    res\n+}\n+\n+fn floatify_sibling<C>(ints: &C) -> <C as Collection<i32>>::Sibling<f32>\n+//~^ ERROR type parameters are not allowed on this type [E0109]\n+where\n+    C: Collection<i32>,\n+{\n+    let mut res = C::Family::Member::<f32>::empty();\n+    for &v in ints.iterate() {\n+        res.add(v as f32);\n+    }\n+    res\n+}\n+\n+fn use_floatify() {\n+    let a = vec![1i32, 2, 3];\n+    let b = floatify(a);\n+    println!(\"{}\", b.iterate().next());\n+    let c = floatify_sibling(a);\n+    println!(\"{}\", c.iterate().next());\n+}\n+\n+fn main() {}"}, {"sha": "ed96570583f4ffb4bbda6230eaa2a5438f686b9d", "filename": "src/test/ui/rfc1598-generic-associated-types/collections.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -0,0 +1,34 @@\n+error[E0109]: type parameters are not allowed on this type\n+  --> $DIR/collections.rs:65:90\n+   |\n+LL | fn floatify<C>(ints: &C) -> <<C as Collection<i32>>::Family as CollectionFamily>::Member<f32>\n+   |                                                                                          ^^^ type parameter not allowed\n+\n+error[E0109]: type parameters are not allowed on this type\n+  --> $DIR/collections.rs:77:69\n+   |\n+LL | fn floatify_sibling<C>(ints: &C) -> <C as Collection<i32>>::Sibling<f32>\n+   |                                                                     ^^^ type parameter not allowed\n+\n+error[E0109]: type parameters are not allowed on this type\n+  --> $DIR/collections.rs:26:71\n+   |\n+LL |         <<Self as Collection<T>>::Family as CollectionFamily>::Member<U>;\n+   |                                                                       ^ type parameter not allowed\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/collections.rs:33:50\n+   |\n+LL |     fn iterate<'iter>(&'iter self) -> Self::Iter<'iter>;\n+   |                                                  ^^^^^ lifetime parameter not allowed on this type\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/collections.rs:59:50\n+   |\n+LL |     fn iterate<'iter>(&'iter self) -> Self::Iter<'iter> {\n+   |                                                  ^^^^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors occurred: E0109, E0110.\n+For more information about an error, try `rustc --explain E0109`."}, {"sha": "04294100315264ec5f1a26bb3a6834da7e86500b", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -10,6 +10,8 @@\n \n #![feature(generic_associated_types)]\n \n+use std::ops::Deref;\n+\n //FIXME(#44265): \"lifetime parameters are not allowed on this type\" errors will be addressed in a\n //follow-up PR\n \n@@ -18,11 +20,18 @@ trait Foo {\n }\n \n trait Baz {\n-    type Quux<'a>;\n+    type Quux<'a>: Foo;\n+\n+    // This weird type tests that we can use universal function call syntax to access the Item on\n+    type Baa<'a>: Deref<Target = <Self::Quux<'a> as Foo>::Bar<'a, 'static>>;\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n }\n \n impl<T> Baz for T where T: Foo {\n-    type Quux<'a> = <T as Foo>::Bar<'a, 'static>;\n+    type Quux<'a> = T;\n+\n+    type Baa<'a> = &'a <T as Foo>::Bar<'a, 'static>;\n     //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n }\n "}, {"sha": "764a0db2478a8478d7d86dd03758905bf9db48f4", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -1,9 +1,21 @@\n error[E0110]: lifetime parameters are not allowed on this type\n-  --> $DIR/construct_with_other_type.rs:25:37\n+  --> $DIR/construct_with_other_type.rs:26:46\n    |\n-LL |     type Quux<'a> = <T as Foo>::Bar<'a, 'static>;\n-   |                                     ^^ lifetime parameter not allowed on this type\n+LL |     type Baa<'a>: Deref<Target = <Self::Quux<'a> as Foo>::Bar<'a, 'static>>;\n+   |                                              ^^ lifetime parameter not allowed on this type\n \n-error: aborting due to previous error\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/construct_with_other_type.rs:26:63\n+   |\n+LL |     type Baa<'a>: Deref<Target = <Self::Quux<'a> as Foo>::Bar<'a, 'static>>;\n+   |                                                               ^^ lifetime parameter not allowed on this type\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/construct_with_other_type.rs:34:40\n+   |\n+LL |     type Baa<'a> = &'a <T as Foo>::Bar<'a, 'static>;\n+   |                                        ^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0110`."}, {"sha": "38967dbbe4530ea4ab28da1943889f4ef1e8d54f", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -20,13 +20,40 @@ trait Iterable {\n     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n     //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n \n-    // This weird type tests that we can use universal function call syntax to access the Item on\n-    // Self::Iter which we have declared to be an Iterator\n-    type Iter2<'a>: Deref<Target = <Self::Iter<'a> as Iterator>::Item>;\n+    fn iter<'a>(&'a self) -> Self::Iter<'a>;\n     //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+}\n \n-    fn iter<'a>(&'a self) -> Self::Iter<'a>;\n+// Impl for struct type\n+impl<T> Iterable for Vec<T> {\n+    type Item<'a> = &'a T;\n+    type Iter<'a> = std::slice::Iter<'a, T>;\n+\n+    fn iter<'a>(&'a self) -> Self::Iter<'a> {\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+        self.iter()\n+    }\n+}\n+\n+// Impl for a primitive type\n+impl<T> Iterable for [T] {\n+    type Item<'a> = &'a T;\n+    type Iter<'a> = std::slice::Iter<'a, T>;\n+\n+    fn iter<'a>(&'a self) -> Self::Iter<'a> {\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+        self.iter()\n+    }\n+}\n+\n+fn make_iter<'a, I: Iterable>(it: &'a I) -> I::Iter<'a> {\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    it.iter()\n+}\n+\n+fn get_first<'a, I: Iterable>(it: &'a I) -> Option<I::Item<'a>> {\n     //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    it.iter().next()\n }\n \n fn main() {}"}, {"sha": "0e251300e451f8bb49eae67a15577a72ead73977", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.stderr", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -5,17 +5,35 @@ LL |     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n    |                                               ^^ lifetime parameter not allowed on this type\n \n error[E0110]: lifetime parameters are not allowed on this type\n-  --> $DIR/iterable.rs:25:48\n+  --> $DIR/iterable.rs:49:53\n    |\n-LL |     type Iter2<'a>: Deref<Target = <Self::Iter<'a> as Iterator>::Item>;\n-   |                                                ^^ lifetime parameter not allowed on this type\n+LL | fn make_iter<'a, I: Iterable>(it: &'a I) -> I::Iter<'a> {\n+   |                                                     ^^ lifetime parameter not allowed on this type\n \n error[E0110]: lifetime parameters are not allowed on this type\n-  --> $DIR/iterable.rs:28:41\n+  --> $DIR/iterable.rs:54:60\n+   |\n+LL | fn get_first<'a, I: Iterable>(it: &'a I) -> Option<I::Item<'a>> {\n+   |                                                            ^^ lifetime parameter not allowed on this type\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/iterable.rs:23:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'a>;\n    |                                         ^^ lifetime parameter not allowed on this type\n \n-error: aborting due to 3 previous errors\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/iterable.rs:32:41\n+   |\n+LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n+   |                                         ^^ lifetime parameter not allowed on this type\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/iterable.rs:43:41\n+   |\n+LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n+   |                                         ^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0110`."}, {"sha": "51527d4117c2c04c35ec02748bb9a1b0401ffb8e", "filename": "src/test/ui/rfc1598-generic-associated-types/parameter_number_and_kind.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_associated_types)]\n+#![feature(associated_type_defaults)]\n+\n+//FIXME(#44265): \"lifetime parameters are not allowed on this type\" errors will be addressed in a\n+//follow-up PR\n+\n+//FIXME(#44265): Update expected errors once E110 is resolved, now does not get past `trait Foo`\n+\n+trait Foo {\n+    type A<'a>;\n+    type B<'a, 'b>;\n+    type C;\n+    type D<T>;\n+    type E<'a, T>;\n+    // Test parameters in default values\n+    type FOk<T> = Self::E<'static, T>;\n+    //~^ ERROR type parameters are not allowed on this type [E0109]\n+    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n+    type FErr1 = Self::E<'static, 'static>; // Error\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    type FErr2<T> = Self::E<'static, T, u32>; // Error\n+    //~^ ERROR type parameters are not allowed on this type [E0109]\n+    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n+}\n+\n+struct Fooy;\n+\n+impl Foo for Fooy {\n+    type A = u32; // Error: parameter expected\n+    type B<'a, T> = Vec<T>; // Error: lifetime param expected\n+    type C<'a> = u32; // Error: no param expected\n+    type D<'a> = u32; // Error: type param expected\n+    type E<T, U> = u32; // Error: lifetime expected as the first param\n+}\n+\n+struct Fooer;\n+\n+impl Foo for Fooer {\n+    type A<T> = u32; // Error: lifetime parameter expected\n+    type B<'a> = u32; // Error: another lifetime param expected\n+    type C<T> = T; // Error: no param expected\n+    type D<'b, T> = u32; // Error: unexpected lifetime param\n+    type E<'a, 'b> = u32; // Error: type expected as the second param\n+}\n+\n+fn main() {}"}, {"sha": "df83fdaad5bfa66f13ce9210569fe1a31e288faf", "filename": "src/test/ui/rfc1598-generic-associated-types/parameter_number_and_kind.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -0,0 +1,34 @@\n+error[E0109]: type parameters are not allowed on this type\n+  --> $DIR/parameter_number_and_kind.rs:26:36\n+   |\n+LL |     type FOk<T> = Self::E<'static, T>;\n+   |                                    ^ type parameter not allowed\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/parameter_number_and_kind.rs:26:27\n+   |\n+LL |     type FOk<T> = Self::E<'static, T>;\n+   |                           ^^^^^^^ lifetime parameter not allowed on this type\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/parameter_number_and_kind.rs:29:26\n+   |\n+LL |     type FErr1 = Self::E<'static, 'static>; // Error\n+   |                          ^^^^^^^ lifetime parameter not allowed on this type\n+\n+error[E0109]: type parameters are not allowed on this type\n+  --> $DIR/parameter_number_and_kind.rs:31:38\n+   |\n+LL |     type FErr2<T> = Self::E<'static, T, u32>; // Error\n+   |                                      ^ type parameter not allowed\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/parameter_number_and_kind.rs:31:29\n+   |\n+LL |     type FErr2<T> = Self::E<'static, T, u32>; // Error\n+   |                             ^^^^^^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors occurred: E0109, E0110.\n+For more information about an error, try `rustc --explain E0109`."}, {"sha": "6cdcaf256839431ea1f8e27e9319b996748fb845", "filename": "src/test/ui/rfc1598-generic-associated-types/shadowing.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_associated_types)]\n+\n+//FIXME(#44265): The lifetime shadowing and type parameter shadowing\n+// should cause an error. Now it compiles (errorneously) and this will be addressed\n+// by a future PR. Then remove the following:\n+// compile-pass\n+\n+trait Shadow<'a> {\n+    type Bar<'a>; // Error: shadowed lifetime\n+}\n+\n+trait NoShadow<'a> {\n+    type Bar<'b>; // OK\n+}\n+\n+impl<'a> NoShadow<'a> for &'a u32 {\n+    type Bar<'a> = i32; // Error: shadowed lifetime\n+}\n+\n+trait ShadowT<T> {\n+    type Bar<T>; // Error: shadowed type parameter\n+}\n+\n+trait NoShadowT<T> {\n+    type Bar<U>; // OK\n+}\n+\n+impl<T> NoShadowT<T> for Option<T> {\n+    type Bar<T> = i32; // Error: shadowed type parameter\n+}\n+\n+fn main() {}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/rfc1598-generic-associated-types/shadowing.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.stdout?ref=a0063281262cf0bb59aebf96192d7e7c92a57944"}, {"sha": "522ddb5dc135e36e162d34cc5bfb34e2f27f427b", "filename": "src/test/ui/rfc1598-generic-associated-types/streaming_iterator.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -35,4 +35,48 @@ struct Foo<T: StreamingIterator> {\n fn foo<T>(iter: T) where T: StreamingIterator, for<'a> T::Item<'a>: Display { /* ... */ }\n //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n \n+// Full example of enumerate iterator\n+\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+struct StreamEnumerate<I> {\n+    iter: I,\n+    count: usize,\n+}\n+\n+impl<I: StreamingIterator> StreamingIterator for StreamEnumerate<I> {\n+    type Item<'a> = (usize, I::Item<'a>);\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    fn next<'a>(&'a self) -> Option<Self::Item<'a>> {\n+        //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+        match self.iter.next() {\n+            None => None,\n+            Some(val) => {\n+                let r = Some((self.count, val));\n+                self.count += 1;\n+                r\n+            }\n+        }\n+    }\n+}\n+\n+impl<I> StreamEnumerate<I> {\n+    pub fn new(iter: I) -> Self {\n+        StreamEnumerate {\n+            count: 0,\n+            iter: iter,\n+        }\n+    }\n+}\n+\n+fn test_stream_enumerate() {\n+    let v = vec![\"a\", \"b\", \"c\"];\n+    let se = StreamEnumerate::new(v.iter());\n+    let a: &str = se.next().unwrap().1;\n+    for (i, s) in se {\n+        println!(\"{} {}\", i, s);\n+    }\n+    println!(\"{}\", a);\n+}\n+\n+\n fn main() {}"}, {"sha": "607a4b8d57996e1cb0343783c379a9e4669093c8", "filename": "src/test/ui/rfc1598-generic-associated-types/streaming_iterator.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -16,6 +16,18 @@ error[E0110]: lifetime parameters are not allowed on this type\n LL |     fn next<'a>(&'a self) -> Option<Self::Item<'a>>;\n    |                                                ^^ lifetime parameter not allowed on this type\n \n-error: aborting due to 3 previous errors\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/streaming_iterator.rs:47:37\n+   |\n+LL |     type Item<'a> = (usize, I::Item<'a>);\n+   |                                     ^^ lifetime parameter not allowed on this type\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/streaming_iterator.rs:49:48\n+   |\n+LL |     fn next<'a>(&'a self) -> Option<Self::Item<'a>> {\n+   |                                                ^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0110`."}, {"sha": "2949a22747b8781639bdeba48e205aeebeea74d8", "filename": "src/test/ui/span/E0204.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Fspan%2FE0204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Fspan%2FE0204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0204.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -32,7 +32,7 @@ LL | #[derive(Copy)] //~ ERROR may not be implemented for this type\n    |          ^^^^\n LL | enum EFoo2<'a> {\n LL |     Bar(&'a mut bool),\n-   |         ------------- this field does not implement `Copy`\n+   |         ------------ this field does not implement `Copy`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ba80af6c7e037b7739310d06d14d04b020092b8d", "filename": "src/test/ui/union/union-sized-field.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -22,7 +22,7 @@ error[E0277]: the trait bound `T: std::marker::Sized` is not satisfied\n   --> $DIR/union-sized-field.rs:23:11\n    |\n LL |     Value(T), //~ ERROR the trait bound `T: std::marker::Sized` is not satisfied\n-   |           ^^ `T` does not have a constant size known at compile-time\n+   |           ^ `T` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = help: consider adding a `where T: std::marker::Sized` bound"}, {"sha": "0e18efbf9da3eda5b87c4e8d72e1e123bca283e8", "filename": "src/test/ui/unsized-enum2.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Funsized-enum2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Funsized-enum2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-enum2.stderr?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -2,7 +2,7 @@ error[E0277]: the trait bound `W: std::marker::Sized` is not satisfied\n   --> $DIR/unsized-enum2.rs:33:8\n    |\n LL |     VA(W), //~ ERROR `W: std::marker::Sized` is not satisfied\n-   |        ^^ `W` does not have a constant size known at compile-time\n+   |        ^ `W` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `W`\n    = help: consider adding a `where W: std::marker::Sized` bound\n@@ -22,7 +22,7 @@ error[E0277]: the trait bound `Y: std::marker::Sized` is not satisfied\n   --> $DIR/unsized-enum2.rs:35:15\n    |\n LL |     VC(isize, Y), //~ ERROR `Y: std::marker::Sized` is not satisfied\n-   |               ^^ `Y` does not have a constant size known at compile-time\n+   |               ^ `Y` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Y`\n    = help: consider adding a `where Y: std::marker::Sized` bound\n@@ -42,7 +42,7 @@ error[E0277]: the trait bound `[u8]: std::marker::Sized` is not satisfied\n   --> $DIR/unsized-enum2.rs:39:8\n    |\n LL |     VE([u8]), //~ ERROR `[u8]: std::marker::Sized` is not satisfied\n-   |        ^^^^^ `[u8]` does not have a constant size known at compile-time\n+   |        ^^^^ `[u8]` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n    = note: no field of an enum variant may have a dynamically sized type\n@@ -60,7 +60,7 @@ error[E0277]: the trait bound `[f32]: std::marker::Sized` is not satisfied\n   --> $DIR/unsized-enum2.rs:41:15\n    |\n LL |     VG(isize, [f32]), //~ ERROR `[f32]: std::marker::Sized` is not satisfied\n-   |               ^^^^^^ `[f32]` does not have a constant size known at compile-time\n+   |               ^^^^^ `[f32]` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[f32]`\n    = note: no field of an enum variant may have a dynamically sized type\n@@ -78,7 +78,7 @@ error[E0277]: the trait bound `Foo + 'static: std::marker::Sized` is not satisfi\n   --> $DIR/unsized-enum2.rs:51:8\n    |\n LL |     VM(Foo),  //~ ERROR `Foo + 'static: std::marker::Sized` is not satisfied\n-   |        ^^^^ `Foo + 'static` does not have a constant size known at compile-time\n+   |        ^^^ `Foo + 'static` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Foo + 'static`\n    = note: no field of an enum variant may have a dynamically sized type\n@@ -96,7 +96,7 @@ error[E0277]: the trait bound `FooBar + 'static: std::marker::Sized` is not sati\n   --> $DIR/unsized-enum2.rs:53:15\n    |\n LL |     VO(isize, FooBar), //~ ERROR `FooBar + 'static: std::marker::Sized` is not satisfied\n-   |               ^^^^^^^ `FooBar + 'static` does not have a constant size known at compile-time\n+   |               ^^^^^^ `FooBar + 'static` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `FooBar + 'static`\n    = note: no field of an enum variant may have a dynamically sized type\n@@ -114,7 +114,7 @@ error[E0277]: the trait bound `[i8]: std::marker::Sized` is not satisfied\n   --> $DIR/unsized-enum2.rs:57:8\n    |\n LL |     VQ(<&'static [i8] as Deref>::Target), //~ ERROR `[i8]: std::marker::Sized` is not satisfied\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `[i8]` does not have a constant size known at compile-time\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `[i8]` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[i8]`\n    = note: no field of an enum variant may have a dynamically sized type\n@@ -132,7 +132,7 @@ error[E0277]: the trait bound `[f64]: std::marker::Sized` is not satisfied\n   --> $DIR/unsized-enum2.rs:60:15\n    |\n LL |     VS(isize, <&'static [f64] as Deref>::Target),\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `[f64]` does not have a constant size known at compile-time\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `[f64]` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[f64]`\n    = note: no field of an enum variant may have a dynamically sized type\n@@ -150,7 +150,7 @@ error[E0277]: the trait bound `PathHelper1 + 'static: std::marker::Sized` is not\n   --> $DIR/unsized-enum2.rs:45:8\n    |\n LL |     VI(Path1), //~ ERROR `PathHelper1 + 'static: std::marker::Sized` is not satisfied\n-   |        ^^^^^^ `PathHelper1 + 'static` does not have a constant size known at compile-time\n+   |        ^^^^^ `PathHelper1 + 'static` does not have a constant size known at compile-time\n    |\n    = help: within `Path1`, the trait `std::marker::Sized` is not implemented for `PathHelper1 + 'static`\n    = note: required because it appears within the type `Path1`\n@@ -170,7 +170,7 @@ error[E0277]: the trait bound `PathHelper3 + 'static: std::marker::Sized` is not\n   --> $DIR/unsized-enum2.rs:47:15\n    |\n LL |     VK(isize, Path3), //~ ERROR `PathHelper3 + 'static: std::marker::Sized` is not satisfied\n-   |               ^^^^^^ `PathHelper3 + 'static` does not have a constant size known at compile-time\n+   |               ^^^^^ `PathHelper3 + 'static` does not have a constant size known at compile-time\n    |\n    = help: within `Path3`, the trait `std::marker::Sized` is not implemented for `PathHelper3 + 'static`\n    = note: required because it appears within the type `Path3`"}, {"sha": "00b4b5c5caa7836de4089968b816401b6f9583ca", "filename": "src/test/ui/update-references.sh", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a0063281262cf0bb59aebf96192d7e7c92a57944/src%2Ftest%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fupdate-references.sh?ref=a0063281262cf0bb59aebf96192d7e7c92a57944", "patch": "@@ -26,20 +26,21 @@ if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" || \"$1\" == \"\" || \"$2\" == \"\" ]]; then\n     echo \"   $0 ../../../build/x86_64-apple-darwin/test/ui *.rs */*.rs\"\n fi\n \n+MYDIR=$(dirname $0)\n \n BUILD_DIR=\"$1\"\n shift\n \n shopt -s nullglob\n \n while [[ \"$1\" != \"\" ]]; do\n-    MYDIR=$(dirname $1)\n     for EXT in \"stderr\" \"stdout\" \"fixed\"; do\n         for OUT_NAME in $BUILD_DIR/${1%.rs}.*$EXT; do\n+            OUT_DIR=`dirname \"$1\"`\n             OUT_BASE=`basename \"$OUT_NAME\"`\n-            if ! (diff $OUT_NAME $MYDIR/$OUT_BASE >& /dev/null); then\n-                echo updating $MYDIR/$OUT_BASE\n-                cp $OUT_NAME $MYDIR\n+            if ! (diff $OUT_NAME $MYDIR/$OUT_DIR/$OUT_BASE >& /dev/null); then\n+                echo updating $MYDIR/$OUT_DIR/$OUT_BASE\n+                cp $OUT_NAME $MYDIR/$OUT_DIR\n             fi\n         done\n     done"}]}