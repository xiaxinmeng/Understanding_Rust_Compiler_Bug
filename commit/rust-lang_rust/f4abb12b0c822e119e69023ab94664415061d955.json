{"sha": "f4abb12b0c822e119e69023ab94664415061d955", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YWJiMTJiMGM4MjJlMTE5ZTY5MDIzYWI5NDY2NDQxNTA2MWQ5NTU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-03T05:39:53Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T01:16:34Z"}, "message": "Address Niko's comments", "tree": {"sha": "25fff19cc9ee4af2d342b38460d770664b395ede", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25fff19cc9ee4af2d342b38460d770664b395ede"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4abb12b0c822e119e69023ab94664415061d955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4abb12b0c822e119e69023ab94664415061d955", "html_url": "https://github.com/rust-lang/rust/commit/f4abb12b0c822e119e69023ab94664415061d955", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4abb12b0c822e119e69023ab94664415061d955/comments", "author": null, "committer": null, "parents": [{"sha": "d193bf30ce1991297225801600da158c18bd3e16", "url": "https://api.github.com/repos/rust-lang/rust/commits/d193bf30ce1991297225801600da158c18bd3e16", "html_url": "https://github.com/rust-lang/rust/commit/d193bf30ce1991297225801600da158c18bd3e16"}], "stats": {"total": 111, "additions": 61, "deletions": 50}, "files": [{"sha": "59344258833a6829d01b664a9b7c4921a5b73f1b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f4abb12b0c822e119e69023ab94664415061d955/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4abb12b0c822e119e69023ab94664415061d955/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f4abb12b0c822e119e69023ab94664415061d955", "patch": "@@ -329,6 +329,12 @@ macro_rules! return_if_err(\n     )\n )\n \n+/// Whether the elements of an overloaded operation are passed by value or by reference\n+enum PassArgs {\n+    ByValue,\n+    ByRef,\n+}\n+\n impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn new(delegate: &'d mut Delegate<'tcx>,\n                typer: &'t TYPER,\n@@ -438,7 +444,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ast::ExprPath(..) => { }\n \n             ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &**base, Vec::new(), None) {\n+                if !self.walk_overloaded_operator(expr, &**base, Vec::new(), PassArgs::ByRef) {\n                     self.select_from_expr(&**base);\n                 }\n             }\n@@ -452,7 +458,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], None) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], PassArgs::ByRef) {\n                     self.select_from_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -465,7 +471,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     (&None, &Some(ref e)) => vec![&**e],\n                     (&None, &None) => Vec::new()\n                 };\n-                let overloaded = self.walk_overloaded_operator(expr, &**base, args, None);\n+                let overloaded =\n+                    self.walk_overloaded_operator(expr, &**base, args, PassArgs::ByRef);\n                 assert!(overloaded);\n             }\n \n@@ -570,14 +577,19 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprUnary(_, ref lhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, Vec::new(), None) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, Vec::new(), PassArgs::ByRef) {\n                     self.consume_expr(&**lhs);\n                 }\n             }\n \n             ast::ExprBinary(op, ref lhs, ref rhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], Some(op))\n-                {\n+                let pass_args = if ast_util::is_by_value_binop(op) {\n+                    PassArgs::ByValue\n+                } else {\n+                    PassArgs::ByRef\n+                };\n+\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], pass_args) {\n                     self.consume_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -913,21 +925,21 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,\n                                 rhs: Vec<&ast::Expr>,\n-                                binop: Option<ast::BinOp>)\n+                                pass_args: PassArgs)\n                                 -> bool\n     {\n         if !self.typer.is_method_call(expr.id) {\n             return false;\n         }\n \n-        match binop {\n-            Some(binop) if ast_util::is_by_value_binop(binop) => {\n+        match pass_args {\n+            PassArgs::ByValue => {\n                 self.consume_expr(receiver);\n                 self.consume_expr(rhs[0]);\n \n                 return true;\n             },\n-            _ => {},\n+            PassArgs::ByRef => {},\n         }\n \n         self.walk_expr(receiver);"}, {"sha": "5f8991278b08c8388e279f6064b1c90635892fb8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f4abb12b0c822e119e69023ab94664415061d955/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4abb12b0c822e119e69023ab94664415061d955/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f4abb12b0c822e119e69023ab94664415061d955", "patch": "@@ -77,7 +77,6 @@ type parameter).\n */\n \n pub use self::LvaluePreference::*;\n-pub use self::DerefArgs::*;\n pub use self::Expectation::*;\n use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n@@ -2117,7 +2116,7 @@ fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                       method_callee.ty,\n                                                       call_expression,\n                                                       args,\n-                                                      DontDerefArgs,\n+                                                      AutorefArgs::No,\n                                                       TupleArguments);\n         fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n         write_call(fcx, call_expression, output_type);\n@@ -2274,7 +2273,7 @@ fn try_overloaded_slice<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 method_ty_or_err,\n                                 expr,\n                                 args.as_slice(),\n-                                DoDerefArgs,\n+                                AutorefArgs::Yes,\n                                 DontTupleArguments);\n \n     opt_method_ty.map(|method_ty| {\n@@ -2480,7 +2479,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   method_type,\n                                                   iterator_expr,\n                                                   &[],\n-                                                  DontDerefArgs,\n+                                                  AutorefArgs::No,\n                                                   DontTupleArguments);\n \n     match method {\n@@ -2522,7 +2521,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          method_fn_ty: Ty<'tcx>,\n                                          callee_expr: &ast::Expr,\n                                          args_no_rcvr: &[&P<ast::Expr>],\n-                                         deref_args: DerefArgs,\n+                                         autoref_args: AutorefArgs,\n                                          tuple_arguments: TupleArgumentsFlag)\n                                          -> ty::FnOutput<'tcx> {\n     if ty::type_is_error(method_fn_ty) {\n@@ -2538,7 +2537,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              err_inputs.as_slice(),\n                              callee_expr,\n                              args_no_rcvr,\n-                             deref_args,\n+                             autoref_args,\n                              false,\n                              tuple_arguments);\n         ty::FnConverging(ty::mk_err())\n@@ -2551,7 +2550,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      fty.sig.inputs.slice_from(1),\n                                      callee_expr,\n                                      args_no_rcvr,\n-                                     deref_args,\n+                                     autoref_args,\n                                      fty.sig.variadic,\n                                      tuple_arguments);\n                 fty.sig.output\n@@ -2571,7 +2570,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   fn_inputs: &[Ty<'tcx>],\n                                   _callee_expr: &ast::Expr,\n                                   args: &[&P<ast::Expr>],\n-                                  deref_args: DerefArgs,\n+                                  autoref_args: AutorefArgs,\n                                   variadic: bool,\n                                   tuple_arguments: TupleArgumentsFlag) {\n     let tcx = fcx.ccx.tcx;\n@@ -2674,8 +2673,8 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 debug!(\"checking the argument\");\n                 let mut formal_ty = formal_tys[i];\n \n-                match deref_args {\n-                    DoDerefArgs => {\n+                match autoref_args {\n+                    AutorefArgs::Yes => {\n                         match formal_ty.sty {\n                             ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n                             ty::ty_err => (),\n@@ -2690,7 +2689,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             }\n                         }\n                     }\n-                    DontDerefArgs => {}\n+                    AutorefArgs::No => {}\n                 }\n \n                 check_expr_coercable_to_type(fcx, &***arg, formal_ty);\n@@ -2905,12 +2904,12 @@ pub fn lookup_tup_field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n // Controls whether the arguments are automatically referenced. This is useful\n // for overloaded binary and unary operators.\n #[deriving(PartialEq)]\n-pub enum DerefArgs {\n-    DontDerefArgs,\n-    DoDerefArgs\n+pub enum AutorefArgs {\n+    Yes,\n+    No,\n }\n \n-impl Copy for DerefArgs {}\n+impl Copy for AutorefArgs {}\n \n /// Controls whether the arguments are tupled. This is used for the call\n /// operator.\n@@ -2998,7 +2997,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                              fn_sig.inputs.as_slice(),\n                              f,\n                              args,\n-                             DontDerefArgs,\n+                             AutorefArgs::No,\n                              fn_sig.variadic,\n                              DontTupleArguments);\n \n@@ -3048,7 +3047,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  fn_ty,\n                                                  expr,\n                                                  args.as_slice(),\n-                                                 DontDerefArgs,\n+                                                 AutorefArgs::No,\n                                                  DontTupleArguments);\n \n         write_call(fcx, expr, ret_ty);\n@@ -3132,7 +3131,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                      lhs: &'a ast::Expr,\n                                      rhs: Option<&P<ast::Expr>>,\n                                      unbound_method: F,\n-                                     deref_args: DerefArgs) -> Ty<'tcx> where\n+                                     autoref_args: AutorefArgs) -> Ty<'tcx> where\n         F: FnOnce(),\n     {\n         let method = match trait_did {\n@@ -3148,7 +3147,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 //   traits that don't force left and right to have same\n                 //   type.\n                 let (adj_ty, adjustment) = match lhs_ty.sty {\n-                    ty::ty_rptr(r_in, mt) if deref_args == DoDerefArgs => {\n+                    ty::ty_rptr(r_in, mt) => {\n                         let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n                         fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, r_in);\n                         let adjusted_ty = ty::mk_rptr(fcx.tcx(), r_adj, mt);\n@@ -3185,7 +3184,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             method_ty,\n                                             op_ex,\n                                             args.as_slice(),\n-                                            deref_args,\n+                                            autoref_args,\n                                             DontTupleArguments) {\n                     ty::FnConverging(result_type) => result_type,\n                     ty::FnDiverging => ty::mk_err()\n@@ -3201,7 +3200,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             expected_ty,\n                                             op_ex,\n                                             args.as_slice(),\n-                                            deref_args,\n+                                            autoref_args,\n                                             DontTupleArguments);\n                 ty::mk_err()\n             }\n@@ -3320,23 +3319,23 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                   rhs: &P<ast::Expr>) -> Ty<'tcx> {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n-        let (name, trait_did, deref_args) = match op {\n-            ast::BiAdd => (\"add\", lang.add_trait(), DontDerefArgs),\n-            ast::BiSub => (\"sub\", lang.sub_trait(), DontDerefArgs),\n-            ast::BiMul => (\"mul\", lang.mul_trait(), DontDerefArgs),\n-            ast::BiDiv => (\"div\", lang.div_trait(), DontDerefArgs),\n-            ast::BiRem => (\"rem\", lang.rem_trait(), DontDerefArgs),\n-            ast::BiBitXor => (\"bitxor\", lang.bitxor_trait(), DontDerefArgs),\n-            ast::BiBitAnd => (\"bitand\", lang.bitand_trait(), DontDerefArgs),\n-            ast::BiBitOr => (\"bitor\", lang.bitor_trait(), DontDerefArgs),\n-            ast::BiShl => (\"shl\", lang.shl_trait(), DontDerefArgs),\n-            ast::BiShr => (\"shr\", lang.shr_trait(), DontDerefArgs),\n-            ast::BiLt => (\"lt\", lang.ord_trait(), DoDerefArgs),\n-            ast::BiLe => (\"le\", lang.ord_trait(), DoDerefArgs),\n-            ast::BiGe => (\"ge\", lang.ord_trait(), DoDerefArgs),\n-            ast::BiGt => (\"gt\", lang.ord_trait(), DoDerefArgs),\n-            ast::BiEq => (\"eq\", lang.eq_trait(), DoDerefArgs),\n-            ast::BiNe => (\"ne\", lang.eq_trait(), DoDerefArgs),\n+        let (name, trait_did) = match op {\n+            ast::BiAdd => (\"add\", lang.add_trait()),\n+            ast::BiSub => (\"sub\", lang.sub_trait()),\n+            ast::BiMul => (\"mul\", lang.mul_trait()),\n+            ast::BiDiv => (\"div\", lang.div_trait()),\n+            ast::BiRem => (\"rem\", lang.rem_trait()),\n+            ast::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n+            ast::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n+            ast::BiBitOr => (\"bitor\", lang.bitor_trait()),\n+            ast::BiShl => (\"shl\", lang.shl_trait()),\n+            ast::BiShr => (\"shr\", lang.shr_trait()),\n+            ast::BiLt => (\"lt\", lang.ord_trait()),\n+            ast::BiLe => (\"le\", lang.ord_trait()),\n+            ast::BiGe => (\"ge\", lang.ord_trait()),\n+            ast::BiGt => (\"gt\", lang.ord_trait()),\n+            ast::BiEq => (\"eq\", lang.eq_trait()),\n+            ast::BiNe => (\"ne\", lang.eq_trait()),\n             ast::BiAnd | ast::BiOr => {\n                 check_expr(fcx, &**rhs);\n                 return ty::mk_err();\n@@ -3349,7 +3348,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         ast_util::binop_to_string(op),\n                         actual)\n             }, lhs_resolved_t, None)\n-        }, deref_args)\n+        }, if ast_util::is_by_value_binop(op) { AutorefArgs::No } else { AutorefArgs::Yes })\n     }\n \n     fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -3365,7 +3364,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 format!(\"cannot apply unary operator `{}` to type `{}`\",\n                         op_str, actual)\n             }, rhs_t, None);\n-        }, DontDerefArgs)\n+        }, AutorefArgs::Yes)\n     }\n \n     // Check field access expressions"}]}