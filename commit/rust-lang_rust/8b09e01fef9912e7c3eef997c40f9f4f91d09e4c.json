{"sha": "8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMDllMDFmZWY5OTEyZTdjM2VlZjk5N2M0MGY5ZjRmOTFkMDllNGM=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-10-28T02:57:49Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-10-28T02:57:49Z"}, "message": "Add redox system", "tree": {"sha": "ab28c5cd1bb526809e12e316ea2b3c2135f72f28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab28c5cd1bb526809e12e316ea2b3c2135f72f28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "html_url": "https://github.com/rust-lang/rust/commit/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07436946b6ee6345509b73c6e4dafb38b6a243f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07436946b6ee6345509b73c6e4dafb38b6a243f1", "html_url": "https://github.com/rust-lang/rust/commit/07436946b6ee6345509b73c6e4dafb38b6a243f1"}], "stats": {"total": 4318, "additions": 4313, "deletions": 5}, "files": [{"sha": "bcd03d2856a70ceec7ec65fa77685d1a3099e2d9", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -316,13 +316,13 @@ extern crate rustc_unicode;\n extern crate libc;\n \n // We always need an unwinder currently for backtraces\n-extern crate unwind;\n+//REDOX TODO extern crate unwind;\n \n #[cfg(stage0)]\n extern crate alloc_system;\n \n // compiler-rt intrinsics\n-extern crate compiler_builtins;\n+//REDOX TODO extern crate compiler_builtins;\n \n // Make std testable by not duplicating lang items and other globals. See #2912\n #[cfg(test)] extern crate std as realstd;\n@@ -456,6 +456,8 @@ mod memchr;\n #[macro_use]\n #[path = \"sys/common/mod.rs\"] mod sys_common;\n \n+#[cfg(redox)]\n+#[path = \"sys/redox/mod.rs\"] mod sys;\n #[cfg(unix)]\n #[path = \"sys/unix/mod.rs\"] mod sys;\n #[cfg(windows)]"}, {"sha": "744ee6c22e5bfa884aa4ffd48ee2703af783a6ec", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -13,6 +13,9 @@\n #![stable(feature = \"os\", since = \"1.0.0\")]\n #![allow(missing_docs, bad_style)]\n \n+#[cfg(redox)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use sys::ext as unix;\n #[cfg(unix)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys::ext as unix;"}, {"sha": "274f3c10d9c3571c6c98ce69ea84cd37746d0975", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -32,7 +32,6 @@ pub mod condvar;\n pub mod io;\n pub mod memchr;\n pub mod mutex;\n-pub mod net;\n pub mod poison;\n pub mod remutex;\n pub mod rwlock;\n@@ -42,6 +41,12 @@ pub mod thread_local;\n pub mod util;\n pub mod wtf8;\n \n+#[cfg(redox)]\n+pub use sys::net;\n+\n+#[cfg(not(redox))]\n+pub mod net;\n+\n #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n #[cfg(any(all(unix, not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\"))),\n           all(windows, target_env = \"gnu\")))]"}, {"sha": "dda0abb4c0cb294d4c649208ec78c50e31bc3d6a", "filename": "src/libstd/sys/common/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -33,6 +33,12 @@ pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n \n+// On Redox, use an illegal instruction\n+#[cfg(redox)]\n+unsafe fn abort_internal() -> ! {\n+    ::intrinsics::abort()\n+}\n+\n // On Unix-like platforms, libc::abort will unregister signal handlers\n // including the SIGABRT handler, preventing the abort from being blocked, and\n // fclose streams, with the side effect of flushing them so libc bufferred"}, {"sha": "9123364598948d36fe68546c9670548f9271de69", "filename": "src/libstd/sys/redox/args.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Global initialization and retreival of command line arguments.\n+//!\n+//! On some platforms these are stored during runtime startup,\n+//! and on some they are retrieved from the system on demand.\n+\n+#![allow(dead_code)] // runtime init functions not used during testing\n+\n+use ffi::OsString;\n+use marker::PhantomData;\n+use vec;\n+\n+/// One-time global initialization.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+\n+/// One-time global cleanup.\n+pub unsafe fn cleanup() { imp::cleanup() }\n+\n+/// Returns the command line arguments\n+pub fn args() -> Args {\n+    imp::args()\n+}\n+\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+}\n+\n+mod imp {\n+    use os::unix::prelude::*;\n+    use mem;\n+    use ffi::{CStr, OsString};\n+    use marker::PhantomData;\n+    use libc;\n+    use super::Args;\n+\n+    use sys_common::mutex::Mutex;\n+\n+    static mut GLOBAL_ARGS_PTR: usize = 0;\n+    static LOCK: Mutex = Mutex::new();\n+\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+        let args = (0..argc).map(|i| {\n+            CStr::from_ptr(*argv.offset(i) as *const libc::c_char).to_bytes().to_vec()\n+        }).collect();\n+\n+        LOCK.lock();\n+        let ptr = get_global_ptr();\n+        assert!((*ptr).is_none());\n+        (*ptr) = Some(box args);\n+        LOCK.unlock();\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        LOCK.lock();\n+        *get_global_ptr() = None;\n+        LOCK.unlock();\n+    }\n+\n+    pub fn args() -> Args {\n+        let bytes = clone().unwrap_or(Vec::new());\n+        let v: Vec<OsString> = bytes.into_iter().map(|v| {\n+            OsStringExt::from_vec(v)\n+        }).collect();\n+        Args { iter: v.into_iter(), _dont_send_or_sync_me: PhantomData }\n+    }\n+\n+    fn clone() -> Option<Vec<Vec<u8>>> {\n+        unsafe {\n+            LOCK.lock();\n+            let ptr = get_global_ptr();\n+            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n+            LOCK.unlock();\n+            return ret\n+        }\n+    }\n+\n+    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n+        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n+    }\n+\n+}"}, {"sha": "63e427694ae6a7793cecca919066ba48c19047ea", "filename": "src/libstd/sys/redox/backtrace.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,8 @@\n+use libc;\n+use io;\n+use sys_common::backtrace::output;\n+\n+#[inline(never)]\n+pub fn write(w: &mut io::Write) -> io::Result<()> {\n+    output(w, 0, 0 as *mut libc::c_void, None)\n+}"}, {"sha": "2a6685bc12245dcbd276968ed6979810ec851a4c", "filename": "src/libstd/sys/redox/condvar.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,88 @@\n+use cell::UnsafeCell;\n+use intrinsics::{atomic_cxchg, atomic_xadd, atomic_xchg};\n+use ptr;\n+use time::Duration;\n+\n+use super::mutex::{mutex_lock, mutex_unlock, Mutex};\n+\n+use libc::{futex, FUTEX_WAIT, FUTEX_WAKE, FUTEX_REQUEUE};\n+\n+pub struct Condvar {\n+    lock: UnsafeCell<*mut i32>,\n+    seq: UnsafeCell<i32>\n+}\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar {\n+            lock: UnsafeCell::new(ptr::null_mut()),\n+            seq: UnsafeCell::new(0)\n+        }\n+    }\n+\n+    pub unsafe fn init(&self) {\n+\n+    }\n+\n+    pub fn notify_one(&self) {\n+        unsafe {\n+            let seq = self.seq.get();\n+\n+            atomic_xadd(seq, 1);\n+\n+            let _ = futex(seq, FUTEX_WAKE, 1, 0, ptr::null_mut());\n+        }\n+    }\n+\n+    pub fn notify_all(&self) {\n+        unsafe {\n+            let lock = self.lock.get();\n+            let seq = self.seq.get();\n+\n+            if *lock == ptr::null_mut() {\n+                return;\n+            }\n+\n+            atomic_xadd(seq, 1);\n+\n+            let _ = futex(seq, FUTEX_REQUEUE, 1, ::usize::MAX, *lock);\n+        }\n+    }\n+\n+    pub fn wait(&self, mutex: &Mutex) {\n+        unsafe {\n+            let lock = self.lock.get();\n+            let seq = self.seq.get();\n+\n+            if *lock != mutex.lock.get() {\n+                if *lock != ptr::null_mut() {\n+                    panic!(\"Condvar used with more than one Mutex\");\n+                }\n+\n+                atomic_cxchg(lock as *mut usize, 0, mutex.lock.get() as usize);\n+            }\n+\n+            mutex_unlock(*lock);\n+\n+            let _ = futex(seq, FUTEX_WAIT, *seq, 0, ptr::null_mut());\n+\n+            while atomic_xchg(*lock, 2) != 0 {\n+                let _ = futex(*lock, FUTEX_WAIT, 2, 0, ptr::null_mut());\n+            }\n+\n+            mutex_lock(*lock);\n+        }\n+    }\n+\n+    pub fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        unimplemented!();\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+\n+    }\n+}\n+\n+unsafe impl Send for Condvar {}\n+\n+unsafe impl Sync for Condvar {}"}, {"sha": "51fd2d079738ff10876b849f04320cd2bafbe666", "filename": "src/libstd/sys/redox/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod os {\n+    pub const FAMILY: &'static str = \"redox\";\n+    pub const OS: &'static str = \"redox\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}"}, {"sha": "d59b4fc0b70b8032a961d9123da86e7b5c2276ac", "filename": "src/libstd/sys/redox/ext/ffi.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extension to the primitives in the `std::ffi` module\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use ffi::{OsStr, OsString};\n+use mem;\n+use sys::os_str::Buf;\n+use sys_common::{FromInner, IntoInner, AsInner};\n+\n+/// Unix-specific extensions to `OsString`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStringExt {\n+    /// Creates an `OsString` from a byte vector.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_vec(vec: Vec<u8>) -> Self;\n+\n+    /// Yields the underlying byte vector of this `OsString`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_vec(self) -> Vec<u8>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStringExt for OsString {\n+    fn from_vec(vec: Vec<u8>) -> OsString {\n+        FromInner::from_inner(Buf { inner: vec })\n+    }\n+    fn into_vec(self) -> Vec<u8> {\n+        self.into_inner().inner\n+    }\n+}\n+\n+/// Unix-specific extensions to `OsStr`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStrExt {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_bytes(slice: &[u8]) -> &Self;\n+\n+    /// Gets the underlying byte view of the `OsStr` slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_bytes(&self) -> &[u8];\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStrExt for OsStr {\n+    fn from_bytes(slice: &[u8]) -> &OsStr {\n+        unsafe { mem::transmute(slice) }\n+    }\n+    fn as_bytes(&self) -> &[u8] {\n+        &self.as_inner().inner\n+    }\n+}"}, {"sha": "45ad7c092de18f282547c978f085c93635284e5b", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,300 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::fs` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fs::{self, Permissions, OpenOptions};\n+use io;\n+use path::Path;\n+use sys;\n+use sys_common::{FromInner, AsInner, AsInnerMut};\n+\n+/// Unix-specific extensions to `Permissions`\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+pub trait PermissionsExt {\n+    /// Returns the underlying raw `mode_t` bits that are the standard Unix\n+    /// permissions for this file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::File;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// let f = try!(File::create(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    /// let permissions = metadata.permissions();\n+    ///\n+    /// println!(\"permissions: {}\", permissions.mode());\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn mode(&self) -> u32;\n+\n+    /// Sets the underlying raw bits for this set of permissions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::File;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// let f = try!(File::create(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    /// let mut permissions = metadata.permissions();\n+    ///\n+    /// permissions.set_mode(0o644); // Read/write for owner and read for others.\n+    /// assert_eq!(permissions.mode(), 0o644);\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn set_mode(&mut self, mode: u32);\n+\n+    /// Creates a new instance of `Permissions` from the given set of Unix\n+    /// permission bits.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::Permissions;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// // Read/write for owner and read for others.\n+    /// let permissions = Permissions::from_mode(0o644);\n+    /// assert_eq!(permissions.mode(), 0o644);\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn from_mode(mode: u32) -> Self;\n+}\n+\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+impl PermissionsExt for Permissions {\n+    fn mode(&self) -> u32 {\n+        self.as_inner().mode()\n+    }\n+\n+    fn set_mode(&mut self, mode: u32) {\n+        *self = Permissions::from_inner(FromInner::from_inner(mode));\n+    }\n+\n+    fn from_mode(mode: u32) -> Permissions {\n+        Permissions::from_inner(FromInner::from_inner(mode))\n+    }\n+}\n+\n+/// Unix-specific extensions to `OpenOptions`\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+pub trait OpenOptionsExt {\n+    /// Sets the mode bits that a new file will be created with.\n+    ///\n+    /// If a new file is created as part of a `File::open_opts` call then this\n+    /// specified `mode` will be used as the permission bits for the new file.\n+    /// If no `mode` is set, the default of `0o666` will be used.\n+    /// The operating system masks out bits with the systems `umask`, to produce\n+    /// the final permissions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// extern crate libc;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.mode(0o644); // Give read/write for owner and read for others.\n+    /// let file = options.open(\"foo.txt\");\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn mode(&mut self, mode: u32) -> &mut Self;\n+\n+    /// Pass custom flags to the `flags` agument of `open`.\n+    ///\n+    /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n+    /// ensure they do not interfere with the access mode set by Rusts options.\n+    ///\n+    /// Custom flags can only set flags, not remove flags set by Rusts options.\n+    /// This options overwrites any previously set custom flags.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// extern crate libc;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.write(true);\n+    /// if cfg!(unix) {\n+    ///     options.custom_flags(libc::O_NOFOLLOW);\n+    /// }\n+    /// let file = options.open(\"foo.txt\");\n+    /// ```\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n+    fn custom_flags(&mut self, flags: i32) -> &mut Self;\n+}\n+\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+impl OpenOptionsExt for OpenOptions {\n+    fn mode(&mut self, mode: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().mode(mode); self\n+    }\n+\n+    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().custom_flags(flags); self\n+    }\n+}\n+\n+// Hm, why are there casts here to the returned type, shouldn't the types always\n+// be the same? Right you are! Turns out, however, on android at least the types\n+// in the raw `stat` structure are not the same as the types being returned. Who\n+// knew!\n+//\n+// As a result to make sure this compiles for all platforms we do the manual\n+// casts and rely on manual lowering to `stat` if the raw type is desired.\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn mode(&self) -> u32;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn uid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn gid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn size(&self) -> u64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn atime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn mtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn ctime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn ctime_nsec(&self) -> i64;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for fs::Metadata {\n+    fn mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn atime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime_nsec as i64\n+    }\n+    fn mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn mtime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime_nsec as i64\n+    }\n+    fn ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn ctime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime_nsec as i64\n+    }\n+}\n+\n+/*\n+/// Add special unix types (block/char device, fifo and socket)\n+#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+pub trait FileTypeExt {\n+    /// Returns whether this file type is a block device.\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_block_device(&self) -> bool;\n+    /// Returns whether this file type is a char device.\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_char_device(&self) -> bool;\n+    /// Returns whether this file type is a fifo.\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_fifo(&self) -> bool;\n+    /// Returns whether this file type is a socket.\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_socket(&self) -> bool;\n+}\n+\n+#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+impl FileTypeExt for fs::FileType {\n+    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }\n+    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }\n+    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }\n+    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }\n+}\n+*/\n+\n+/// Creates a new symbolic link on the filesystem.\n+///\n+/// The `dst` path will be a symbolic link pointing to the `src` path.\n+///\n+/// # Note\n+///\n+/// On Windows, you must specify whether a symbolic link points to a file\n+/// or directory.  Use `os::windows::fs::symlink_file` to create a\n+/// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n+/// symbolic link to a directory.  Additionally, the process must have\n+/// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n+/// symbolic link.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::symlink(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[stable(feature = \"symlink\", since = \"1.1.0\")]\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n+{\n+    sys::fs::symlink(src.as_ref(), dst.as_ref())\n+}\n+\n+#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+/// An extension trait for `fs::DirBuilder` for unix-specific options.\n+pub trait DirBuilderExt {\n+    /// Sets the mode to create new directories with. This option defaults to\n+    /// 0o777.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// use std::fs::DirBuilder;\n+    /// use std::os::unix::fs::DirBuilderExt;\n+    ///\n+    /// let mut builder = DirBuilder::new();\n+    /// builder.mode(0o755);\n+    /// ```\n+    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+    fn mode(&mut self, mode: u32) -> &mut Self;\n+}\n+\n+#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+impl DirBuilderExt for fs::DirBuilder {\n+    fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder {\n+        self.as_inner_mut().set_mode(mode);\n+        self\n+    }\n+}"}, {"sha": "bffd4f66a2803972c64fa35e4c9cfb62a02f456e", "filename": "src/libstd/sys/redox/ext/io.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to general I/O primitives\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fs;\n+use os::raw;\n+use sys;\n+use sys_common::{AsInner, FromInner, IntoInner};\n+\n+/// Raw file descriptors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawFd = raw::c_int;\n+\n+/// A trait to extract the raw unix file descriptor from an underlying\n+/// object.\n+///\n+/// This is only available on unix platforms and must be imported in order\n+/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n+/// and `AsRawSocket` set of traits.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This method does **not** pass ownership of the raw file descriptor\n+    /// to the caller. The descriptor is only guaranteed to be valid while\n+    /// the original object has not yet been destroyed.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+pub trait FromRawFd {\n+    /// Constructs a new instances of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function **consumes ownership** of the specified file\n+    /// descriptor. The returned object will take responsibility for closing\n+    /// it when the object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}\n+\n+/// A trait to express the ability to consume an object and acquire ownership of\n+/// its raw file descriptor.\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+pub trait IntoRawFd {\n+    /// Consumes this object, returning the raw underlying file descriptor.\n+    ///\n+    /// This function **transfers ownership** of the underlying file descriptor\n+    /// to the caller. Callers are then the unique owners of the file descriptor\n+    /// and must close the descriptor once it's no longer needed.\n+    #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+    fn into_raw_fd(self) -> RawFd;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for fs::File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for fs::File {\n+    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n+        fs::File::from_inner(sys::fs::File::from_inner(fd))\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for fs::File {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+/*\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n+    }\n+}\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n+    }\n+}\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::UdpSocket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+*/"}, {"sha": "7ba166e89320fecd1e4c0cac86c785e74e623e52", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Experimental extensions to `std` for Unix platforms.\n+//!\n+//! For now, this module is limited to extracting file descriptors,\n+//! but its functionality will grow over time.\n+//!\n+//! # Example\n+//!\n+//! ```no_run\n+//! use std::fs::File;\n+//! use std::os::unix::prelude::*;\n+//!\n+//! fn main() {\n+//!     let f = File::create(\"foo.txt\").unwrap();\n+//!     let fd = f.as_raw_fd();\n+//!\n+//!     // use fd with native unix bindings\n+//! }\n+//! ```\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub mod ffi;\n+pub mod fs;\n+pub mod io;\n+pub mod process;\n+\n+/// A prelude for conveniently writing platform-specific code.\n+///\n+/// Includes all extension traits, and some important type definitions.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod prelude {\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::process::{CommandExt, ExitStatusExt};\n+}"}, {"sha": "f8e6b2cf4709d358d58bbfeab993d00d41410b46", "filename": "src/libstd/sys/redox/ext/process.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::process` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use io;\n+use os::unix::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n+use process;\n+use sys;\n+use sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+\n+/// Unix-specific extensions to the `std::process::Command` builder\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait CommandExt {\n+    /// Sets the child process's user id. This translates to a\n+    /// `setuid` call in the child process. Failure in the `setuid`\n+    /// call will cause the spawn to fail.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn uid(&mut self, id: u32) -> &mut process::Command;\n+\n+    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// the same semantics as the `uid` field.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn gid(&mut self, id: u32) -> &mut process::Command;\n+\n+    /// Schedules a closure to be run just before the `exec` function is\n+    /// invoked.\n+    ///\n+    /// The closure is allowed to return an I/O error whose OS error code will\n+    /// be communicated back to the parent and returned as an error from when\n+    /// the spawn was requested.\n+    ///\n+    /// Multiple closures can be registered and they will be called in order of\n+    /// their registration. If a closure returns `Err` then no further closures\n+    /// will be called and the spawn operation will immediately return with a\n+    /// failure.\n+    ///\n+    /// # Notes\n+    ///\n+    /// This closure will be run in the context of the child process after a\n+    /// `fork`. This primarily means that any modificatons made to memory on\n+    /// behalf of this closure will **not** be visible to the parent process.\n+    /// This is often a very constrained environment where normal operations\n+    /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n+    /// other threads perhaps still running when the `fork` was run).\n+    ///\n+    /// When this closure is run, aspects such as the stdio file descriptors and\n+    /// working directory have successfully been changed, so output to these\n+    /// locations may not appear where intended.\n+    #[unstable(feature = \"process_exec\", issue = \"31398\")]\n+    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+\n+    /// Performs all the required setup by this `Command`, followed by calling\n+    /// the `execvp` syscall.\n+    ///\n+    /// On success this function will not return, and otherwise it will return\n+    /// an error indicating why the exec (or another part of the setup of the\n+    /// `Command`) failed.\n+    ///\n+    /// This function, unlike `spawn`, will **not** `fork` the process to create\n+    /// a new child. Like spawn, however, the default behavior for the stdio\n+    /// descriptors will be to inherited from the current process.\n+    ///\n+    /// # Notes\n+    ///\n+    /// The process may be in a \"broken state\" if this function returns in\n+    /// error. For example the working directory, environment variables, signal\n+    /// handling settings, various user/group information, or aspects of stdio\n+    /// file descriptors may have changed. If a \"transactional spawn\" is\n+    /// required to gracefully handle errors it is recommended to use the\n+    /// cross-platform `spawn` instead.\n+    #[stable(feature = \"process_exec2\", since = \"1.9.0\")]\n+    fn exec(&mut self) -> io::Error;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl CommandExt for process::Command {\n+    fn uid(&mut self, id: u32) -> &mut process::Command {\n+        self.as_inner_mut().uid(id as usize);\n+        self\n+    }\n+\n+    fn gid(&mut self, id: u32) -> &mut process::Command {\n+        self.as_inner_mut().gid(id as usize);\n+        self\n+    }\n+\n+    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    {\n+        self.as_inner_mut().before_exec(Box::new(f));\n+        self\n+    }\n+\n+    fn exec(&mut self) -> io::Error {\n+        self.as_inner_mut().exec(sys::process::Stdio::Inherit)\n+    }\n+}\n+\n+/// Unix-specific extensions to `std::process::ExitStatus`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ExitStatusExt {\n+    /// Creates a new `ExitStatus` from the raw underlying `i32` return value of\n+    /// a process.\n+    #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n+    fn from_raw(raw: i32) -> Self;\n+\n+    /// If the process was terminated by a signal, returns that signal.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn signal(&self) -> Option<i32>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExitStatusExt for process::ExitStatus {\n+    fn from_raw(raw: i32) -> Self {\n+        process::ExitStatus::from_inner(From::from(raw))\n+    }\n+\n+    fn signal(&self) -> Option<i32> {\n+        self.as_inner().signal()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl FromRawFd for process::Stdio {\n+    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n+        let fd = sys::fd::FileDesc::new(fd);\n+        let io = sys::process::Stdio::Fd(fd);\n+        process::Stdio::from_inner(io)\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStdin {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStdout {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStderr {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStdin {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStdout {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStderr {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}"}, {"sha": "99ae089b5c048189f6a5c46cf246c06469658d9a", "filename": "src/libstd/sys/redox/fd.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n+\n+use io::{self, Read};\n+use libc::{self, c_int, c_void};\n+use mem;\n+use sys::cvt;\n+use sys_common::AsInner;\n+use sys_common::io::read_to_end_uninitialized;\n+\n+pub struct FileDesc {\n+    fd: c_int,\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: c_int) -> FileDesc {\n+        FileDesc { fd: fd }\n+    }\n+\n+    pub fn raw(&self) -> c_int { self.fd }\n+\n+    /// Extracts the actual filedescriptor without closing it.\n+    pub fn into_raw(self) -> c_int {\n+        let fd = self.fd;\n+        mem::forget(self);\n+        fd\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::read(self.fd,\n+                       buf.as_mut_ptr() as *mut c_void,\n+                       buf.len())\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::write(self.fd,\n+                        buf.as_ptr() as *const c_void,\n+                        buf.len())\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn set_cloexec(&self) -> io::Result<()> {\n+        unimplemented!();\n+        /*\n+        unsafe {\n+            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD, 0))?;\n+            cvt(libc::fcntl(self.fd, libc::F_SETFD, previous | libc::FD_CLOEXEC))?;\n+            Ok(())\n+        }\n+        */\n+    }\n+\n+    pub fn set_nonblocking(&self, _nonblocking: bool) -> io::Result<()> {\n+        unimplemented!();\n+        /*\n+        unsafe {\n+            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n+            let new = if nonblocking {\n+                previous | libc::O_NONBLOCK\n+            } else {\n+                previous & !libc::O_NONBLOCK\n+            };\n+            cvt(libc::fcntl(self.fd, libc::F_SETFL, new))?;\n+            Ok(())\n+        }\n+        */\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<FileDesc> {\n+        let new_fd = cvt(unsafe { libc::dup(self.fd) })?;\n+        Ok(FileDesc::new(new_fd))\n+    }\n+}\n+\n+impl<'a> Read for &'a FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n+}\n+\n+impl AsInner<c_int> for FileDesc {\n+    fn as_inner(&self) -> &c_int { &self.fd }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        // Note that errors are ignored when closing a file descriptor. The\n+        // reason for this is that if an error occurs we don't actually know if\n+        // the file descriptor was closed or not, and if we retried (for\n+        // something like EINTR), we might close another valid file descriptor\n+        // (opened after we closed ours.\n+        let _ = unsafe { libc::close(self.fd) };\n+    }\n+}"}, {"sha": "56b1bf95ae813184b2502ec6659d13cd1b4b8b2c", "filename": "src/libstd/sys/redox/fs.rs", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,554 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use os::unix::prelude::*;\n+\n+use ffi::{CString, CStr, OsString, OsStr};\n+use fmt;\n+use io::{self, Error, ErrorKind, SeekFrom};\n+use libc::{self, c_int, mode_t};\n+use mem;\n+use path::{Path, PathBuf};\n+use sync::Arc;\n+use sys::fd::FileDesc;\n+use sys::time::SystemTime;\n+use sys::{cvt, cvt_r};\n+use sys_common::{AsInner, FromInner};\n+\n+use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off_t as off64_t,\n+           ftruncate as ftruncate64, lseek as lseek64, open as open64};\n+\n+pub struct File(FileDesc);\n+\n+#[derive(Clone)]\n+pub struct FileAttr {\n+    stat: stat64,\n+}\n+\n+pub struct ReadDir {\n+    data: Vec<u8>,\n+    i: usize,\n+    root: Arc<PathBuf>,\n+}\n+\n+struct Dir(FileDesc);\n+\n+unsafe impl Send for Dir {}\n+unsafe impl Sync for Dir {}\n+\n+pub struct DirEntry {\n+    root: Arc<PathBuf>,\n+    name: Box<[u8]>\n+}\n+\n+#[derive(Clone)]\n+pub struct OpenOptions {\n+    // generic\n+    read: bool,\n+    write: bool,\n+    append: bool,\n+    truncate: bool,\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    custom_flags: i32,\n+    mode: mode_t,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FilePermissions { mode: mode_t }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct FileType { mode: mode_t }\n+\n+pub struct DirBuilder { mode: mode_t }\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n+    pub fn perm(&self) -> FilePermissions {\n+        FilePermissions { mode: (self.stat.st_mode as mode_t) & 0o777 }\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        FileType { mode: self.stat.st_mode as mode_t }\n+    }\n+}\n+\n+impl FileAttr {\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_mtime as libc::time_t,\n+            tv_nsec: self.stat.st_mtime_nsec as i32,\n+        }))\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_atime as libc::time_t,\n+            tv_nsec: self.stat.st_atime_nsec as i32,\n+        }))\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_ctime as libc::time_t,\n+            tv_nsec: self.stat.st_ctime_nsec as i32,\n+        }))\n+    }\n+}\n+\n+impl AsInner<stat64> for FileAttr {\n+    fn as_inner(&self) -> &stat64 { &self.stat }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }\n+    pub fn set_readonly(&mut self, readonly: bool) {\n+        if readonly {\n+            self.mode &= !0o222;\n+        } else {\n+            self.mode |= 0o222;\n+        }\n+    }\n+    pub fn mode(&self) -> u32 { self.mode as u32 }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool { self.is(libc::MODE_DIR) }\n+    pub fn is_file(&self) -> bool { self.is(libc::MODE_FILE) }\n+    pub fn is_symlink(&self) -> bool { false }\n+\n+    pub fn is(&self, mode: mode_t) -> bool { self.mode & (libc::MODE_DIR | libc::MODE_FILE) == mode }\n+}\n+\n+impl FromInner<u32> for FilePermissions {\n+    fn from_inner(mode: u32) -> FilePermissions {\n+        FilePermissions { mode: mode as mode_t }\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n+        // Thus the result will be e g 'ReadDir(\"/home\")'\n+        fmt::Debug::fmt(&*self.root, f)\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        loop {\n+            let start = self.i;\n+            while self.i < self.data.len() {\n+                let i = self.i;\n+                self.i += 1;\n+                if self.data[i] == b'\\n' {\n+                    break;\n+                }\n+            }\n+            if start < self.i {\n+                let ret = DirEntry {\n+                    name: self.data[start .. self.i].to_owned().into_boxed_slice(),\n+                    root: self.root.clone()\n+                };\n+                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n+                    return Some(Ok(ret))\n+                }\n+            } else {\n+                return None;\n+            }\n+        }\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        self.root.join(OsStr::from_bytes(self.name_bytes()))\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        OsStr::from_bytes(self.name_bytes()).to_os_string()\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        lstat(&self.path())\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        stat(&self.path()).map(|m| m.file_type())\n+    }\n+\n+    fn name_bytes(&self) -> &[u8] {\n+        &*self.name\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            // generic\n+            read: false,\n+            write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            custom_flags: 0,\n+            mode: 0o666,\n+        }\n+    }\n+\n+    pub fn read(&mut self, read: bool) { self.read = read; }\n+    pub fn write(&mut self, write: bool) { self.write = write; }\n+    pub fn append(&mut self, append: bool) { self.append = append; }\n+    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+\n+    pub fn custom_flags(&mut self, flags: i32) { self.custom_flags = flags; }\n+    pub fn mode(&mut self, mode: u32) { self.mode = mode as mode_t; }\n+\n+    fn get_access_mode(&self) -> io::Result<c_int> {\n+        match (self.read, self.write, self.append) {\n+            (true,  false, false) => Ok(libc::O_RDONLY as c_int),\n+            (false, true,  false) => Ok(libc::O_WRONLY as c_int),\n+            (true,  true,  false) => Ok(libc::O_RDWR as c_int),\n+            (false, _,     true)  => Ok(libc::O_WRONLY as c_int | libc::O_APPEND as c_int),\n+            (true,  _,     true)  => Ok(libc::O_RDWR as c_int | libc::O_APPEND as c_int),\n+            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n+        }\n+    }\n+\n+    fn get_creation_mode(&self) -> io::Result<c_int> {\n+        match (self.write, self.append) {\n+            (true, false) => {}\n+            (false, false) =>\n+                if self.truncate || self.create || self.create_new {\n+                    return Err(Error::from_raw_os_error(libc::EINVAL));\n+                },\n+            (_, true) =>\n+                if self.truncate && !self.create_new {\n+                    return Err(Error::from_raw_os_error(libc::EINVAL));\n+                },\n+        }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => 0,\n+                (true,  false, false) => libc::O_CREAT as c_int,\n+                (false, true,  false) => libc::O_TRUNC as c_int,\n+                (true,  true,  false) => libc::O_CREAT as c_int | libc::O_TRUNC as c_int,\n+                (_,      _,    true)  => libc::O_CREAT as c_int | libc::O_EXCL as c_int,\n+           })\n+    }\n+}\n+\n+impl File {\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let path = cstr(path)?;\n+        File::open_c(&path, opts)\n+    }\n+\n+    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n+        let flags = libc::O_CLOEXEC as i32 |\n+                    opts.get_access_mode()? |\n+                    opts.get_creation_mode()? |\n+                    (opts.custom_flags as usize & !libc::O_ACCMODE) as i32;\n+        let fd = cvt_r(|| unsafe {\n+            open64(path.as_ptr(), flags, opts.mode as mode_t)\n+        })?;\n+        let fd = FileDesc::new(fd);\n+\n+        Ok(File(fd))\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        let mut stat: stat64 = unsafe { mem::zeroed() };\n+        cvt(unsafe {\n+            fstat64(self.0.raw(), &mut stat)\n+        })?;\n+        Ok(FileAttr { stat: stat })\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        cvt_r(|| unsafe { libc::fsync(self.0.raw()) })?;\n+        Ok(())\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n+        return Ok(());\n+\n+        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+        unsafe fn os_datasync(fd: c_int) -> c_int {\n+            libc::fcntl(fd, libc::F_FULLFSYNC)\n+        }\n+        #[cfg(target_os = \"linux\")]\n+        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fdatasync(fd) }\n+        #[cfg(not(any(target_os = \"macos\",\n+                      target_os = \"ios\",\n+                      target_os = \"linux\")))]\n+        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) }\n+    }\n+\n+    pub fn truncate(&self, size: u64) -> io::Result<()> {\n+        #[cfg(target_os = \"android\")]\n+        return ::sys::android::ftruncate64(self.0.raw(), size);\n+\n+        #[cfg(not(target_os = \"android\"))]\n+        return cvt_r(|| unsafe {\n+            ftruncate64(self.0.raw(), size as off64_t)\n+        }).map(|_| ());\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n+\n+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n+        let (whence, pos) = match pos {\n+            // Casting to `i64` is fine, too large values will end up as\n+            // negative which will cause an error in `lseek64`.\n+            SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),\n+            SeekFrom::End(off) => (libc::SEEK_END, off),\n+            SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n+        };\n+        let n = cvt(unsafe { lseek64(self.0.raw(), pos as usize, whence) } as isize)?;\n+        Ok(n as u64)\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        self.0.duplicate().map(File)\n+    }\n+\n+    pub fn dup(&self, buf: &[u8]) -> io::Result<File> {\n+        libc::dup_extra(*self.fd().as_inner() as usize, buf)\n+            .map(|fd| File(FileDesc::new(fd as i32)))\n+            .map_err(|err| Error::from_raw_os_error(err.errno))\n+    }\n+\n+    pub fn path(&self) -> io::Result<PathBuf> {\n+        let mut buf: [u8; 4096] = [0; 4096];\n+        match libc::fpath(*self.fd().as_inner() as usize, &mut buf) {\n+            Ok(count) => Ok(PathBuf::from(unsafe { String::from_utf8_unchecked(Vec::from(&buf[0..count])) })),\n+            Err(err) => Err(Error::from_raw_os_error(err.errno)),\n+        }\n+    }\n+\n+    pub fn fd(&self) -> &FileDesc { &self.0 }\n+\n+    pub fn into_fd(self) -> FileDesc { self.0 }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { mode: 0o777 }\n+    }\n+\n+    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n+        let p = cstr(p)?;\n+        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n+        Ok(())\n+    }\n+\n+    pub fn set_mode(&mut self, mode: u32) {\n+        self.mode = mode as mode_t;\n+    }\n+}\n+\n+fn cstr(path: &Path) -> io::Result<CString> {\n+    Ok(CString::new(path.as_os_str().as_bytes())?)\n+}\n+\n+impl FromInner<c_int> for File {\n+    fn from_inner(fd: c_int) -> File {\n+        File(FileDesc::new(fd))\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        #[cfg(target_os = \"linux\")]\n+        fn get_path(fd: c_int) -> Option<PathBuf> {\n+            let mut p = PathBuf::from(\"/proc/self/fd\");\n+            p.push(&fd.to_string());\n+            readlink(&p).ok()\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        fn get_path(fd: c_int) -> Option<PathBuf> {\n+            // FIXME: The use of PATH_MAX is generally not encouraged, but it\n+            // is inevitable in this case because OS X defines `fcntl` with\n+            // `F_GETPATH` in terms of `MAXPATHLEN`, and there are no\n+            // alternatives. If a better method is invented, it should be used\n+            // instead.\n+            let mut buf = vec![0;libc::PATH_MAX as usize];\n+            let n = unsafe { libc::fcntl(fd, libc::F_GETPATH, buf.as_ptr()) };\n+            if n == -1 {\n+                return None;\n+            }\n+            let l = buf.iter().position(|&c| c == 0).unwrap();\n+            buf.truncate(l as usize);\n+            buf.shrink_to_fit();\n+            Some(PathBuf::from(OsString::from_vec(buf)))\n+        }\n+\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+        fn get_path(_fd: c_int) -> Option<PathBuf> {\n+            // FIXME(#24570): implement this for other Unix platforms\n+            None\n+        }\n+\n+        #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n+            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n+            if mode == -1 {\n+                return None;\n+            }\n+            match mode & libc::O_ACCMODE {\n+                libc::O_RDONLY => Some((true, false)),\n+                libc::O_RDWR => Some((true, true)),\n+                libc::O_WRONLY => Some((false, true)),\n+                _ => None\n+            }\n+        }\n+\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+        fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n+            // FIXME(#24570): implement this for other Unix platforms\n+            None\n+        }\n+\n+        let fd = self.0.raw();\n+        let mut b = f.debug_struct(\"File\");\n+        b.field(\"fd\", &fd);\n+        if let Some(path) = get_path(fd) {\n+            b.field(\"path\", &path);\n+        }\n+        if let Some((read, write)) = get_mode(fd) {\n+            b.field(\"read\", &read).field(\"write\", &write);\n+        }\n+        b.finish()\n+    }\n+}\n+\n+pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n+    let root = Arc::new(p.to_path_buf());\n+    let p = cstr(p)?;\n+    unsafe {\n+        let fd = FileDesc::new(cvt(libc::open(p.as_ptr(), 0, 0))?);\n+        let mut data = Vec::new();\n+        fd.read_to_end(&mut data)?;\n+        Ok(ReadDir { data: data, i: 0, root: root })\n+    }\n+}\n+\n+pub fn unlink(p: &Path) -> io::Result<()> {\n+    let p = cstr(p)?;\n+    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n+    Ok(())\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    unimplemented!();\n+}\n+\n+pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n+    unimplemented!();\n+}\n+\n+pub fn rmdir(p: &Path) -> io::Result<()> {\n+    let p = cstr(p)?;\n+    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n+    Ok(())\n+}\n+\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    let filetype = lstat(path)?.file_type();\n+    if filetype.is_symlink() {\n+        unlink(path)\n+    } else {\n+        remove_dir_all_recursive(path)\n+    }\n+}\n+\n+fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n+    for child in readdir(path)? {\n+        let child = child?;\n+        if child.file_type()?.is_dir() {\n+            remove_dir_all_recursive(&child.path())?;\n+        } else {\n+            unlink(&child.path())?;\n+        }\n+    }\n+    rmdir(path)\n+}\n+\n+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n+    unimplemented!();\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unimplemented!();\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unimplemented!();\n+}\n+\n+pub fn stat(p: &Path) -> io::Result<FileAttr> {\n+    let p = cstr(p)?;\n+    let mut stat: stat64 = unsafe { mem::zeroed() };\n+    cvt(unsafe {\n+        stat64(p.as_ptr(), &mut stat as *mut _ as *mut _)\n+    })?;\n+    Ok(FileAttr { stat: stat })\n+}\n+\n+pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n+    let p = cstr(p)?;\n+    let mut stat: stat64 = unsafe { mem::zeroed() };\n+    cvt(unsafe {\n+        lstat64(p.as_ptr(), &mut stat as *mut _ as *mut _)\n+    })?;\n+    Ok(FileAttr { stat: stat })\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unimplemented!();\n+}\n+\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    use fs::{File, set_permissions};\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    let mut reader = File::open(from)?;\n+    let mut writer = File::create(to)?;\n+    let perm = reader.metadata()?.permissions();\n+\n+    let ret = io::copy(&mut reader, &mut writer)?;\n+    set_permissions(to, perm)?;\n+    Ok(ret)\n+}"}, {"sha": "4c314b7a472585b93faa63ae619a2aa28f727894", "filename": "src/libstd/sys/redox/memchr.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+pub use sys_common::memchr::fallback::{memchr, memrchr};"}, {"sha": "108ebb0800e4e09b62a79fe692b1ad010575472a", "filename": "src/libstd/sys/redox/mod.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,111 @@\n+#![allow(dead_code, missing_docs, bad_style)]\n+\n+use io::{self, ErrorKind};\n+use libc;\n+\n+pub mod args;\n+pub mod backtrace;\n+pub mod condvar;\n+pub mod env;\n+pub mod ext;\n+pub mod fd;\n+pub mod fs;\n+pub mod memchr;\n+pub mod mutex;\n+pub mod net;\n+pub mod os;\n+pub mod os_str;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod rand;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod stdio;\n+pub mod thread;\n+pub mod thread_local;\n+pub mod time;\n+\n+#[cfg(not(test))]\n+pub fn init() {\n+    use alloc::oom;\n+\n+    oom::set_oom_handler(oom_handler);\n+\n+    // A nicer handler for out-of-memory situations than the default one. This\n+    // one prints a message to stderr before aborting. It is critical that this\n+    // code does not allocate any memory since we are in an OOM situation. Any\n+    // errors are ignored while printing since there's nothing we can do about\n+    // them and we are about to exit anyways.\n+    fn oom_handler() -> ! {\n+        use intrinsics;\n+        let msg = \"fatal runtime error: out of memory\\n\";\n+        unsafe {\n+            libc::write(libc::STDERR_FILENO,\n+                        msg.as_ptr() as *const libc::c_void,\n+                        msg.len());\n+            intrinsics::abort();\n+        }\n+    }\n+}\n+\n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno as libc::c_int {\n+        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        libc::ECONNRESET => ErrorKind::ConnectionReset,\n+        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n+        libc::EPIPE => ErrorKind::BrokenPipe,\n+        libc::ENOTCONN => ErrorKind::NotConnected,\n+        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        libc::EADDRINUSE => ErrorKind::AddrInUse,\n+        libc::ENOENT => ErrorKind::NotFound,\n+        libc::EINTR => ErrorKind::Interrupted,\n+        libc::EINVAL => ErrorKind::InvalidInput,\n+        libc::ETIMEDOUT => ErrorKind::TimedOut,\n+        libc::EEXIST => ErrorKind::AlreadyExists,\n+\n+        // These two constants can have the same value on some systems,\n+        // but different values on others, so we can't use a match\n+        // clause\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+            ErrorKind::WouldBlock,\n+\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n+pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n+    where T: IsMinusOne,\n+          F: FnMut() -> T\n+{\n+    loop {\n+        match cvt(f()) {\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            other => return other,\n+        }\n+    }\n+}"}, {"sha": "5723443785a0d68e90608c4b9c096f7e4d95cbfe", "filename": "src/libstd/sys/redox/mutex.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,125 @@\n+use cell::UnsafeCell;\n+use intrinsics::{atomic_cxchg, atomic_xchg};\n+use ptr;\n+\n+use libc::{futex, FUTEX_WAIT, FUTEX_WAKE};\n+\n+pub unsafe fn mutex_try_lock(m: *mut i32) -> bool {\n+    atomic_cxchg(m, 0, 1).0 == 0\n+}\n+\n+pub unsafe fn mutex_lock(m: *mut i32) {\n+    let mut c = 0;\n+    //Set to larger value for longer spin test\n+    for _i in 0..100 {\n+        c = atomic_cxchg(m, 0, 1).0;\n+        if c == 0 {\n+            break;\n+        }\n+        //cpu_relax()\n+    }\n+    if c == 1 {\n+        c = atomic_xchg(m, 2);\n+    }\n+    while c != 0 {\n+        let _ = futex(m, FUTEX_WAIT, 2, 0, ptr::null_mut());\n+        c = atomic_xchg(m, 2);\n+    }\n+}\n+\n+pub unsafe fn mutex_unlock(m: *mut i32) {\n+    if *m == 2 {\n+        *m = 0;\n+    } else if atomic_xchg(m, 0) == 1 {\n+        return;\n+    }\n+    //Set to larger value for longer spin test\n+    for _i in 0..100 {\n+        if *m != 0 {\n+            if atomic_cxchg(m, 1, 2).0 != 0 {\n+                return;\n+            }\n+        }\n+        //cpu_relax()\n+    }\n+    let _ = futex(m, FUTEX_WAKE, 1, 0, ptr::null_mut());\n+}\n+\n+pub struct Mutex {\n+    pub lock: UnsafeCell<i32>,\n+}\n+\n+impl Mutex {\n+    /// Create a new mutex.\n+    pub const fn new() -> Self {\n+        Mutex {\n+            lock: UnsafeCell::new(0),\n+        }\n+    }\n+\n+    pub unsafe fn init(&self) {\n+\n+    }\n+\n+    /// Try to lock the mutex\n+    pub unsafe fn try_lock(&self) -> bool {\n+        mutex_try_lock(self.lock.get())\n+    }\n+\n+    /// Lock the mutex\n+    pub unsafe fn lock(&self) {\n+        mutex_lock(self.lock.get());\n+    }\n+\n+    /// Unlock the mutex\n+    pub unsafe fn unlock(&self) {\n+        mutex_unlock(self.lock.get());\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+\n+    }\n+}\n+\n+unsafe impl Send for Mutex {}\n+\n+unsafe impl Sync for Mutex {}\n+\n+pub struct ReentrantMutex {\n+    pub lock: UnsafeCell<i32>,\n+}\n+\n+impl ReentrantMutex {\n+    pub const fn uninitialized() -> Self {\n+        ReentrantMutex {\n+            lock: UnsafeCell::new(0),\n+        }\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+\n+    }\n+\n+    /// Try to lock the mutex\n+    pub unsafe fn try_lock(&self) -> bool {\n+        mutex_try_lock(self.lock.get())\n+    }\n+\n+    /// Lock the mutex\n+    pub unsafe fn lock(&self) {\n+        mutex_lock(self.lock.get());\n+    }\n+\n+    /// Unlock the mutex\n+    pub unsafe fn unlock(&self) {\n+        mutex_unlock(self.lock.get());\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+\n+    }\n+}\n+\n+unsafe impl Send for ReentrantMutex {}\n+\n+unsafe impl Sync for ReentrantMutex {}"}, {"sha": "c0450c11ed6b9885cd7fff9aac1ed0501d084c65", "filename": "src/libstd/sys/redox/net/dns/answer.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,12 @@\n+use string::String;\n+use vec::Vec;\n+\n+#[derive(Clone, Debug)]\n+pub struct DnsAnswer {\n+    pub name: String,\n+    pub a_type: u16,\n+    pub a_class: u16,\n+    pub ttl_a: u16,\n+    pub ttl_b: u16,\n+    pub data: Vec<u8>\n+}"}, {"sha": "4397b71b93914c9940feb69e3c3228c3ebeeda03", "filename": "src/libstd/sys/redox/net/dns/mod.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,207 @@\n+pub use self::answer::DnsAnswer;\n+pub use self::query::DnsQuery;\n+\n+use slice;\n+use u16;\n+use string::String;\n+use vec::Vec;\n+\n+mod answer;\n+mod query;\n+\n+#[unstable(feature = \"n16\", issue=\"0\")]\n+#[allow(non_camel_case_types)]\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct n16 {\n+    inner: u16\n+}\n+\n+impl n16 {\n+    #[unstable(feature = \"n16\", issue=\"0\")]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts((&self.inner as *const u16) as *const u8, 2) }\n+    }\n+\n+    #[unstable(feature = \"n16\", issue=\"0\")]\n+    pub fn from_bytes(bytes: &[u8]) -> Self {\n+        n16 {\n+            inner: unsafe { slice::from_raw_parts(bytes.as_ptr() as *const u16, bytes.len()/2)[0] }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"n16\", issue=\"0\")]\n+impl From<u16> for n16 {\n+    fn from(value: u16) -> Self {\n+        n16 {\n+            inner: value.to_be()\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"n16\", issue=\"0\")]\n+impl From<n16> for u16 {\n+    fn from(value: n16) -> Self {\n+        u16::from_be(value.inner)\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Dns {\n+    pub transaction_id: u16,\n+    pub flags: u16,\n+    pub queries: Vec<DnsQuery>,\n+    pub answers: Vec<DnsAnswer>\n+}\n+\n+impl Dns {\n+    pub fn compile(&self) -> Vec<u8> {\n+        let mut data = Vec::new();\n+\n+        macro_rules! push_u8 {\n+            ($value:expr) => {\n+                data.push($value);\n+            };\n+        };\n+\n+        macro_rules! push_n16 {\n+            ($value:expr) => {\n+                data.extend_from_slice(n16::from($value).as_bytes());\n+            };\n+        };\n+\n+        push_n16!(self.transaction_id);\n+        push_n16!(self.flags);\n+        push_n16!(self.queries.len() as u16);\n+        push_n16!(self.answers.len() as u16);\n+        push_n16!(0);\n+        push_n16!(0);\n+\n+        for query in self.queries.iter() {\n+            for part in query.name.split('.') {\n+                push_u8!(part.len() as u8);\n+                data.extend_from_slice(part.as_bytes());\n+            }\n+            push_u8!(0);\n+            push_n16!(query.q_type);\n+            push_n16!(query.q_class);\n+        }\n+\n+        data\n+    }\n+\n+    pub fn parse(data: &[u8]) -> Result<Self, String> {\n+        let mut i = 0;\n+\n+        macro_rules! pop_u8 {\n+            () => {\n+                {\n+                    i += 1;\n+                    if i > data.len() {\n+                        return Err(format!(\"{}: {}: pop_u8\", file!(), line!()));\n+                    }\n+                    data[i - 1]\n+                }\n+            };\n+        };\n+\n+        macro_rules! pop_n16 {\n+            () => {\n+                {\n+                    i += 2;\n+                    if i > data.len() {\n+                        return Err(format!(\"{}: {}: pop_n16\", file!(), line!()));\n+                    }\n+                    u16::from(n16::from_bytes(&data[i - 2 .. i]))\n+                }\n+            };\n+        };\n+\n+        macro_rules! pop_data {\n+            () => {\n+                {\n+                    let mut data = Vec::new();\n+\n+                    let data_len = pop_n16!();\n+                    for _data_i in 0..data_len {\n+                        data.push(pop_u8!());\n+                    }\n+\n+                    data\n+                }\n+            };\n+        };\n+\n+        macro_rules! pop_name {\n+            () => {\n+                {\n+                    let mut name = String::new();\n+\n+                    loop {\n+                        let name_len = pop_u8!();\n+                        if name_len == 0 {\n+                            break;\n+                        }\n+                        if ! name.is_empty() {\n+                            name.push('.');\n+                        }\n+                        for _name_i in 0..name_len {\n+                            name.push(pop_u8!() as char);\n+                        }\n+                    }\n+\n+                    name\n+                }\n+            };\n+        };\n+\n+        let transaction_id = pop_n16!();\n+        let flags = pop_n16!();\n+        let queries_len = pop_n16!();\n+        let answers_len = pop_n16!();\n+        pop_n16!();\n+        pop_n16!();\n+\n+        let mut queries = Vec::new();\n+        for _query_i in 0..queries_len {\n+            queries.push(DnsQuery {\n+                name: pop_name!(),\n+                q_type: pop_n16!(),\n+                q_class: pop_n16!()\n+            });\n+        }\n+\n+        let mut answers = Vec::new();\n+        for _answer_i in 0..answers_len {\n+            let name_ind = 0b11000000;\n+            let name_test = pop_u8!();\n+            i -= 1;\n+\n+            answers.push(DnsAnswer {\n+                name: if name_test & name_ind == name_ind {\n+                    let name_off = pop_n16!() - ((name_ind as u16) << 8);\n+                    let old_i = i;\n+                    i = name_off as usize;\n+                    let name = pop_name!();\n+                    i = old_i;\n+                    name\n+                } else {\n+                    pop_name!()\n+                },\n+                a_type: pop_n16!(),\n+                a_class: pop_n16!(),\n+                ttl_a: pop_n16!(),\n+                ttl_b: pop_n16!(),\n+                data: pop_data!()\n+            });\n+        }\n+\n+        Ok(Dns {\n+            transaction_id: transaction_id,\n+            flags: flags,\n+            queries: queries,\n+            answers: answers,\n+        })\n+    }\n+}"}, {"sha": "dcb554d82debbb6421357371d429911ecbb42ef0", "filename": "src/libstd/sys/redox/net/dns/query.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,8 @@\n+use string::String;\n+\n+#[derive(Clone, Debug)]\n+pub struct DnsQuery {\n+    pub name: String,\n+    pub q_type: u16,\n+    pub q_class: u16\n+}"}, {"sha": "1c8fde546efb444705f4c368c15141e5271a48dd", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,91 @@\n+use fs::File;\n+use io::{Error, Result, Read};\n+use iter::Iterator;\n+use net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n+use str::FromStr;\n+use string::{String, ToString};\n+use libc::EINVAL;\n+use time;\n+use vec::{IntoIter, Vec};\n+\n+use self::dns::{Dns, DnsQuery};\n+\n+pub extern crate libc as netc;\n+pub use self::tcp::{TcpStream, TcpListener};\n+pub use self::udp::UdpSocket;\n+\n+mod dns;\n+mod tcp;\n+mod udp;\n+\n+pub struct LookupHost(IntoIter<SocketAddr>);\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+pub fn lookup_host(host: &str) -> Result<LookupHost> {\n+    let mut ip_string = String::new();\n+    File::open(\"/etc/net/ip\")?.read_to_string(&mut ip_string)?;\n+    let ip: Vec<u8> = ip_string.trim().split(\".\").map(|part| part.parse::<u8>().unwrap_or(0)).collect();\n+\n+    let mut dns_string = String::new();\n+    File::open(\"/etc/net/dns\")?.read_to_string(&mut dns_string)?;\n+    let dns: Vec<u8> = dns_string.trim().split(\".\").map(|part| part.parse::<u8>().unwrap_or(0)).collect();\n+\n+    if ip.len() == 4 && dns.len() == 4 {\n+        let tid = (time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap().subsec_nanos() >> 16) as u16;\n+\n+        let packet = Dns {\n+            transaction_id: tid,\n+            flags: 0x0100,\n+            queries: vec![DnsQuery {\n+                name: host.to_string(),\n+                q_type: 0x0001,\n+                q_class: 0x0001,\n+            }],\n+            answers: vec![]\n+        };\n+\n+        let packet_data = packet.compile();\n+\n+        let socket = UdpSocket::bind(&SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]), 0)))?;\n+        socket.connect(&SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]), 53)))?;\n+        socket.send(&packet_data)?;\n+\n+        let mut buf = [0; 65536];\n+        let count = socket.recv(&mut buf)?;\n+\n+        match Dns::parse(&buf[.. count]) {\n+            Ok(response) => {\n+                let mut addrs = vec![];\n+                for answer in response.answers.iter() {\n+                    if answer.a_type == 0x0001 && answer.a_class == 0x0001 && answer.data.len() == 4 {\n+                        addrs.push(SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(answer.data[0], answer.data[1], answer.data[2], answer.data[3]), 0)));\n+                    }\n+                }\n+                Ok(LookupHost(addrs.into_iter()))\n+            },\n+            Err(_err) => Err(Error::from_raw_os_error(EINVAL))\n+        }\n+    } else {\n+        Err(Error::from_raw_os_error(EINVAL))\n+    }\n+}\n+\n+fn path_to_peer_addr(path_str: &str) -> SocketAddr {\n+    let mut parts = path_str.split('/').next().unwrap_or(\"\").split(':').skip(1);\n+    let host = Ipv4Addr::from_str(parts.next().unwrap_or(\"\")).unwrap_or(Ipv4Addr::new(0, 0, 0, 0));\n+    let port = parts.next().unwrap_or(\"\").parse::<u16>().unwrap_or(0);\n+    SocketAddr::V4(SocketAddrV4::new(host, port))\n+}\n+\n+fn path_to_local_addr(path_str: &str) -> SocketAddr {\n+    let mut parts = path_str.split('/').nth(1).unwrap_or(\"\").split(':');\n+    let host = Ipv4Addr::from_str(parts.next().unwrap_or(\"\")).unwrap_or(Ipv4Addr::new(0, 0, 0, 0));\n+    let port = parts.next().unwrap_or(\"\").parse::<u16>().unwrap_or(0);\n+    SocketAddr::V4(SocketAddrV4::new(host, port))\n+}"}, {"sha": "351c534c036df639223a570352bdb3bab227d5f8", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,160 @@\n+use io::{Error, ErrorKind, Result};\n+use net::{SocketAddr, Shutdown};\n+use path::Path;\n+use sys::fs::{File, OpenOptions};\n+use time::Duration;\n+use vec::Vec;\n+\n+use super::{path_to_peer_addr, path_to_local_addr};\n+\n+#[derive(Debug)]\n+pub struct TcpStream(File);\n+\n+impl TcpStream {\n+    pub fn connect(addr: &SocketAddr) -> Result<TcpStream> {\n+        let path = format!(\"tcp:{}\", addr);\n+        let mut options = OpenOptions::new();\n+        options.read(true);\n+        options.write(true);\n+        Ok(TcpStream(File::open(&Path::new(path.as_str()), &options)?))\n+    }\n+\n+    pub fn duplicate(&self) -> Result<TcpStream> {\n+        Ok(TcpStream(self.0.dup(&[])?))\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn take_error(&self) -> Result<Option<Error>> {\n+        Ok(None)\n+    }\n+\n+    pub fn peer_addr(&self) -> Result<SocketAddr> {\n+        let path = self.0.path()?;\n+        Ok(path_to_peer_addr(path.to_str().unwrap_or(\"\")))\n+    }\n+\n+    pub fn socket_addr(&self) -> Result<SocketAddr> {\n+        let path = self.0.path()?;\n+        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n+    }\n+\n+    pub fn shutdown(&self, _how: Shutdown) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::shutdown not implemented\"))\n+    }\n+\n+    pub fn nodelay(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::nodelay not implemented\"))\n+    }\n+\n+    pub fn nonblocking(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::nonblocking not implemented\"))\n+    }\n+\n+    pub fn only_v6(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::only_v6 not implemented\"))\n+    }\n+\n+    pub fn ttl(&self) -> Result<u32> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::ttl not implemented\"))\n+    }\n+\n+    pub fn read_timeout(&self) -> Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::read_timeout not implemented\"))\n+    }\n+\n+    pub fn write_timeout(&self) -> Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::write_timeout not implemented\"))\n+    }\n+\n+    pub fn set_nodelay(&self, _nodelay: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_nodelay not implemented\"))\n+    }\n+\n+    pub fn set_nonblocking(&self, _nonblocking: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_nonblocking not implemented\"))\n+    }\n+\n+    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_only_v6 not implemented\"))\n+    }\n+\n+    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_ttl not implemented\"))\n+    }\n+\n+    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_read_timeout not implemented\"))\n+    }\n+\n+    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_write_timeout not implemented\"))\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct TcpListener(File);\n+\n+impl TcpListener {\n+    pub fn bind(addr: &SocketAddr) -> Result<TcpListener> {\n+        let path = format!(\"tcp:/{}\", addr);\n+        let mut options = OpenOptions::new();\n+        options.read(true);\n+        options.write(true);\n+        Ok(TcpListener(File::open(&Path::new(path.as_str()), &options)?))\n+    }\n+\n+    pub fn accept(&self) -> Result<(TcpStream, SocketAddr)> {\n+        let file = self.0.dup(b\"listen\")?;\n+        let path = file.path()?;\n+        let peer_addr = path_to_peer_addr(path.to_str().unwrap_or(\"\"));\n+        Ok((TcpStream(file), peer_addr))\n+    }\n+\n+    pub fn duplicate(&self) -> Result<TcpListener> {\n+        Ok(TcpListener(self.0.dup(&[])?))\n+    }\n+\n+    pub fn take_error(&self) -> Result<Option<Error>> {\n+        Ok(None)\n+    }\n+\n+    pub fn socket_addr(&self) -> Result<SocketAddr> {\n+        let path = self.0.path()?;\n+        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n+    }\n+\n+    pub fn nonblocking(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::nonblocking not implemented\"))\n+    }\n+\n+    pub fn only_v6(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::only_v6 not implemented\"))\n+    }\n+\n+    pub fn ttl(&self) -> Result<u32> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::ttl not implemented\"))\n+    }\n+\n+    pub fn set_nonblocking(&self, _nonblocking: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::set_nonblocking not implemented\"))\n+    }\n+\n+    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::set_only_v6 not implemented\"))\n+    }\n+\n+    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::set_ttl not implemented\"))\n+    }\n+}"}, {"sha": "a259db6a4c0475cf4545b47749f9da962a8cbf9e", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,163 @@\n+use cell::UnsafeCell;\n+use io::{Error, ErrorKind, Result};\n+use net::{SocketAddr, Ipv4Addr, Ipv6Addr};\n+use path::Path;\n+use sys::fs::{File, OpenOptions};\n+use time::Duration;\n+\n+use super::{path_to_peer_addr, path_to_local_addr};\n+\n+#[derive(Debug)]\n+pub struct UdpSocket(File, UnsafeCell<Option<SocketAddr>>);\n+\n+impl UdpSocket {\n+    pub fn bind(addr: &SocketAddr) -> Result<UdpSocket> {\n+        let path = format!(\"udp:/{}\", addr);\n+        let mut options = OpenOptions::new();\n+        options.read(true);\n+        options.write(true);\n+        Ok(UdpSocket(File::open(&Path::new(path.as_str()), &options)?, UnsafeCell::new(None)))\n+    }\n+\n+    fn get_conn(&self) -> &mut Option<SocketAddr> {\n+        unsafe { &mut *(self.1.get()) }\n+    }\n+\n+    pub fn connect(&self, addr: &SocketAddr) -> Result<()> {\n+        unsafe { *self.1.get() = Some(*addr) };\n+        Ok(())\n+    }\n+\n+    pub fn duplicate(&self) -> Result<UdpSocket> {\n+        let new_bind = self.0.dup(&[])?;\n+        let new_conn = *self.get_conn();\n+        Ok(UdpSocket(new_bind, UnsafeCell::new(new_conn)))\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> Result<(usize, SocketAddr)> {\n+        let from = self.0.dup(b\"listen\")?;\n+        let path = from.path()?;\n+        let peer_addr = path_to_peer_addr(path.to_str().unwrap_or(\"\"));\n+        let count = from.read(buf)?;\n+        Ok((count, peer_addr))\n+    }\n+\n+    pub fn recv(&self, buf: &mut [u8]) -> Result<usize> {\n+        if let Some(addr) = *self.get_conn() {\n+            let from = self.0.dup(format!(\"{}\", addr).as_bytes())?;\n+            from.read(buf)\n+        } else {\n+            Err(Error::new(ErrorKind::Other, \"UdpSocket::recv not connected\"))\n+        }\n+    }\n+\n+    pub fn send_to(&self, buf: &[u8], addr: &SocketAddr) -> Result<usize> {\n+        let to = self.0.dup(format!(\"{}\", addr).as_bytes())?;\n+        to.write(buf)\n+    }\n+\n+    pub fn send(&self, buf: &[u8]) -> Result<usize> {\n+        if let Some(addr) = *self.get_conn() {\n+            self.send_to(buf, &addr)\n+        } else {\n+            Err(Error::new(ErrorKind::Other, \"UdpSocket::send not connected\"))\n+        }\n+    }\n+\n+    pub fn take_error(&self) -> Result<Option<Error>> {\n+        Ok(None)\n+    }\n+\n+    pub fn socket_addr(&self) -> Result<SocketAddr> {\n+        let path = self.0.path()?;\n+        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n+    }\n+\n+    pub fn broadcast(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::broadcast not implemented\"))\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_loop_v4 not implemented\"))\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_loop_v6 not implemented\"))\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> Result<u32> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_ttl_v4 not implemented\"))\n+    }\n+\n+    pub fn nonblocking(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::nonblocking not implemented\"))\n+    }\n+\n+    pub fn only_v6(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::only_v6 not implemented\"))\n+    }\n+\n+    pub fn ttl(&self) -> Result<u32> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::ttl not implemented\"))\n+    }\n+\n+    pub fn read_timeout(&self) -> Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::read_timeout not implemented\"))\n+    }\n+\n+    pub fn write_timeout(&self) -> Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::write_timeout not implemented\"))\n+    }\n+\n+    pub fn set_broadcast(&self, _broadcast: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_broadcast not implemented\"))\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _multicast_loop_v4: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_loop_v4 not implemented\"))\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _multicast_loop_v6: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_loop_v6 not implemented\"))\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _multicast_ttl_v4: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_ttl_v4 not implemented\"))\n+    }\n+\n+    pub fn set_nonblocking(&self, _nonblocking: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_nonblocking not implemented\"))\n+    }\n+\n+    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_only_v6 not implemented\"))\n+    }\n+\n+    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_ttl not implemented\"))\n+    }\n+\n+    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_read_timeout not implemented\"))\n+    }\n+\n+    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_write_timeout not implemented\"))\n+    }\n+\n+    pub fn join_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::join_multicast_v4 not implemented\"))\n+    }\n+\n+    pub fn join_multicast_v6(&self, _multiaddr: &Ipv6Addr, _interface: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::join_multicast_v6 not implemented\"))\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::leave_multicast_v4 not implemented\"))\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _multiaddr: &Ipv6Addr, _interface: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::leave_multicast_v6 not implemented\"))\n+    }\n+}"}, {"sha": "a2262369e9263ab1825344beee48d45baae90219", "filename": "src/libstd/sys/redox/os.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,246 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of `std::os` functionality for unix systems\n+\n+#![allow(unused_imports)] // lots of cfg code here\n+\n+use os::unix::prelude::*;\n+\n+use error::Error as StdError;\n+use ffi::{CString, CStr, OsString, OsStr};\n+use fmt;\n+use io;\n+use iter;\n+use libc::{self, c_int, c_char, c_void};\n+use marker::PhantomData;\n+use mem;\n+use memchr;\n+use path::{self, PathBuf};\n+use ptr;\n+use slice;\n+use str;\n+use sys_common::mutex::Mutex;\n+use sys::cvt;\n+use sys::fd;\n+use vec;\n+\n+const TMPBUF_SZ: usize = 128;\n+static ENV_LOCK: Mutex = Mutex::new();\n+\n+\n+extern {\n+    #[cfg(not(target_os = \"dragonfly\"))]\n+    #[cfg_attr(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"fuchsia\"),\n+               link_name = \"__errno_location\")]\n+    #[cfg_attr(any(target_os = \"bitrig\",\n+                   target_os = \"netbsd\",\n+                   target_os = \"openbsd\",\n+                   target_os = \"android\",\n+                   target_env = \"newlib\"),\n+               link_name = \"__errno\")]\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"___errno\")]\n+    #[cfg_attr(any(target_os = \"macos\",\n+                   target_os = \"ios\",\n+                   target_os = \"freebsd\"),\n+               link_name = \"__error\")]\n+    #[cfg_attr(target_os = \"haiku\", link_name = \"_errnop\")]\n+    fn errno_location() -> *mut c_int;\n+}\n+\n+/// Returns the platform-specific value of errno\n+#[cfg(not(target_os = \"dragonfly\"))]\n+pub fn errno() -> i32 {\n+    unsafe {\n+        (*errno_location()) as i32\n+    }\n+}\n+\n+/// Sets the platform-specific value of errno\n+#[cfg(target_os = \"solaris\")] // only needed for readdir so far\n+pub fn set_errno(e: i32) {\n+    unsafe {\n+        *errno_location() = e as c_int\n+    }\n+}\n+\n+#[cfg(target_os = \"dragonfly\")]\n+pub fn errno() -> i32 {\n+    extern {\n+        #[thread_local]\n+        static errno: c_int;\n+    }\n+\n+    errno as i32\n+}\n+\n+/// Gets a detailed string description for the given error number.\n+pub fn error_string(errno: i32) -> String {\n+    extern {\n+        #[cfg_attr(any(target_os = \"linux\", target_env = \"newlib\"),\n+                   link_name = \"__xpg_strerror_r\")]\n+        fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                      buflen: libc::size_t) -> c_int;\n+    }\n+\n+    let mut buf = [0 as c_char; TMPBUF_SZ];\n+\n+    let p = buf.as_mut_ptr();\n+    unsafe {\n+        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n+            panic!(\"strerror_r failure\");\n+        }\n+\n+        let p = p as *const _;\n+        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n+    }\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    let mut buf = Vec::with_capacity(512);\n+    loop {\n+        unsafe {\n+            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n+            if !libc::getcwd(ptr, buf.capacity()).is_null() {\n+                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n+                buf.set_len(len);\n+                buf.shrink_to_fit();\n+                return Ok(PathBuf::from(OsString::from_vec(buf)));\n+            } else {\n+                let error = io::Error::last_os_error();\n+                if error.raw_os_error() != Some(libc::ERANGE) {\n+                    return Err(error);\n+                }\n+            }\n+\n+            // Trigger the internal buffer resizing logic of `Vec` by requiring\n+            // more space than the current capacity.\n+            let cap = buf.capacity();\n+            buf.set_len(cap);\n+            buf.reserve(1);\n+        }\n+    }\n+}\n+\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n+    let p: &OsStr = p.as_ref();\n+    let p = CString::new(p.as_bytes())?;\n+    unsafe {\n+        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n+            true => Ok(()),\n+            false => Err(io::Error::last_os_error()),\n+        }\n+    }\n+}\n+\n+pub struct SplitPaths<'a> {\n+    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>,\n+                    fn(&'a [u8]) -> PathBuf>,\n+}\n+\n+pub fn split_paths(unparsed: &OsStr) -> SplitPaths {\n+    fn bytes_to_path(b: &[u8]) -> PathBuf {\n+        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n+    }\n+    fn is_colon(b: &u8) -> bool { *b == b':' }\n+    let unparsed = unparsed.as_bytes();\n+    SplitPaths {\n+        iter: unparsed.split(is_colon as fn(&u8) -> bool)\n+                      .map(bytes_to_path as fn(&[u8]) -> PathBuf)\n+    }\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+{\n+    let mut joined = Vec::new();\n+    let sep = b':';\n+\n+    for (i, path) in paths.enumerate() {\n+        let path = path.as_ref().as_bytes();\n+        if i > 0 { joined.push(sep) }\n+        if path.contains(&sep) {\n+            return Err(JoinPathsError)\n+        }\n+        joined.extend_from_slice(path);\n+    }\n+    Ok(OsStringExt::from_vec(joined))\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"path segment contains separator `:`\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str { \"failed to join paths\" }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    use io::ErrorKind;\n+    Err(io::Error::new(ErrorKind::Other, \"Not yet implemented on redox\"))\n+}\n+\n+pub struct Env {\n+    iter: vec::IntoIter<(OsString, OsString)>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env() -> Env {\n+    unimplemented!();\n+}\n+\n+pub fn getenv(_k: &OsStr) -> io::Result<Option<OsString>> {\n+    unimplemented!();\n+}\n+\n+pub fn setenv(_k: &OsStr, _v: &OsStr) -> io::Result<()> {\n+    unimplemented!();\n+}\n+\n+pub fn unsetenv(_n: &OsStr) -> io::Result<()> {\n+    unimplemented!();\n+}\n+\n+pub fn page_size() -> usize {\n+    4096\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    ::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| {\n+        PathBuf::from(\"/tmp\")\n+    })\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    return ::env::var_os(\"HOME\").map(PathBuf::from);\n+}\n+\n+pub fn exit(code: i32) -> ! {\n+    unsafe { libc::exit(code as c_int) }\n+}"}, {"sha": "5a733c0cb87637f7a235782b0bc3a415d60c4aca", "filename": "src/libstd/sys/redox/os_str.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Unix systems: just\n+/// a `Vec<u8>`/`[u8]`.\n+\n+use borrow::Cow;\n+use fmt::{self, Debug};\n+use str;\n+use mem;\n+use sys_common::{AsInner, IntoInner};\n+\n+#[derive(Clone, Hash)]\n+pub struct Buf {\n+    pub inner: Vec<u8>\n+}\n+\n+pub struct Slice {\n+    pub inner: [u8]\n+}\n+\n+impl Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.to_string_lossy().fmt(formatter)\n+    }\n+}\n+\n+impl Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.as_slice().fmt(formatter)\n+    }\n+}\n+\n+impl IntoInner<Vec<u8>> for Buf {\n+    fn into_inner(self) -> Vec<u8> {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<[u8]> for Buf {\n+    fn as_inner(&self) -> &[u8] {\n+        &self.inner\n+    }\n+}\n+\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: s.into_bytes() }\n+    }\n+\n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Buf {\n+        Buf {\n+            inner: Vec::with_capacity(capacity)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.inner.clear()\n+    }\n+\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.inner.capacity()\n+    }\n+\n+    #[inline]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.inner.reserve(additional)\n+    }\n+\n+    #[inline]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.inner.reserve_exact(additional)\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(&*self.inner) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.extend_from_slice(&s.inner)\n+    }\n+}\n+\n+impl Slice {\n+    fn from_u8_slice(s: &[u8]) -> &Slice {\n+        unsafe { mem::transmute(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> &Slice {\n+        Slice::from_u8_slice(s.as_bytes())\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        str::from_utf8(&self.inner).ok()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> Cow<str> {\n+        String::from_utf8_lossy(&self.inner)\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        Buf { inner: self.inner.to_vec() }\n+    }\n+}"}, {"sha": "bf9af7a4353a89b67992cf63ff18709db4e48086", "filename": "src/libstd/sys/redox/path.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path::Prefix;\n+use ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "f77f1e0dc688f81b1148a17926435a6dd7d61c73", "filename": "src/libstd/sys/redox/pipe.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use libc::{self, c_int};\n+use sys::fd::FileDesc;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Anonymous pipes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct AnonPipe(FileDesc);\n+\n+pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+    let mut fds = [0; 2];\n+\n+    libc::pipe2(&mut fds, libc::O_CLOEXEC).map_err(|err| io::Error::from_raw_os_error(err.errno))?;\n+\n+    let fd0 = FileDesc::new(fds[0] as c_int);\n+    let fd1 = FileDesc::new(fds[1] as c_int);\n+    Ok((AnonPipe::from_fd(fd0)?, AnonPipe::from_fd(fd1)?))\n+}\n+\n+impl AnonPipe {\n+    pub fn from_fd(fd: FileDesc) -> io::Result<AnonPipe> {\n+        fd.set_cloexec()?;\n+        Ok(AnonPipe(fd))\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn fd(&self) -> &FileDesc { &self.0 }\n+    pub fn into_fd(self) -> FileDesc { self.0 }\n+}\n+\n+pub fn read2(_p1: AnonPipe,\n+             _v1: &mut Vec<u8>,\n+             _p2: AnonPipe,\n+             _v2: &mut Vec<u8>) -> io::Result<()> {\n+    unimplemented!();\n+    /*\n+    // Set both pipes into nonblocking mode as we're gonna be reading from both\n+    // in the `select` loop below, and we wouldn't want one to block the other!\n+    let p1 = p1.into_fd();\n+    let p2 = p2.into_fd();\n+    p1.set_nonblocking(true)?;\n+    p2.set_nonblocking(true)?;\n+\n+    let max = cmp::max(p1.raw(), p2.raw());\n+    loop {\n+        // wait for either pipe to become readable using `select`\n+        cvt_r(|| unsafe {\n+            let mut read: libc::fd_set = mem::zeroed();\n+            libc::FD_SET(p1.raw(), &mut read);\n+            libc::FD_SET(p2.raw(), &mut read);\n+            libc::select(max + 1, &mut read, ptr::null_mut(), ptr::null_mut(),\n+                         ptr::null_mut())\n+        })?;\n+\n+        // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n+        // EAGAIN. If we hit EOF, then this will happen because the underlying\n+        // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n+        // this case we flip the other fd back into blocking mode and read\n+        // whatever's leftover on that file descriptor.\n+        let read = |fd: &FileDesc, dst: &mut Vec<u8>| {\n+            match fd.read_to_end(dst) {\n+                Ok(_) => Ok(true),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n+                       e.raw_os_error() == Some(libc::EAGAIN) {\n+                        Ok(false)\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        };\n+        if read(&p1, v1)? {\n+            p2.set_nonblocking(false)?;\n+            return p2.read_to_end(v2).map(|_| ());\n+        }\n+        if read(&p2, v2)? {\n+            p1.set_nonblocking(false)?;\n+            return p1.read_to_end(v1).map(|_| ());\n+        }\n+    }\n+    */\n+}"}, {"sha": "b025623fc9f77fae74040e235666b87dd16ef183", "filename": "src/libstd/sys/redox/process.rs", "status": "added", "additions": 593, "deletions": 0, "changes": 593, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,593 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use os::unix::prelude::*;\n+\n+use collections::hash_map::HashMap;\n+use env;\n+use ffi::{OsStr, CString, CStr};\n+use fmt;\n+use io::{self, Error, ErrorKind};\n+use libc::{self, pid_t, c_int, gid_t, uid_t};\n+use sys::fd::FileDesc;\n+use sys::fs::{File, OpenOptions};\n+use sys::pipe::{self, AnonPipe};\n+use sys::{self, cvt, cvt_r};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    // Currently we try hard to ensure that the call to `.exec()` doesn't\n+    // actually allocate any memory. While many platforms try to ensure that\n+    // memory allocation works after a fork in a multithreaded process, it's\n+    // been observed to be buggy and somewhat unreliable, so we do our best to\n+    // just not do it at all!\n+    //\n+    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n+    // what's gonna get passed to `execvp`. The `argv` array starts with the\n+    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n+    // also null-terminated.\n+    //\n+    // Right now we don't support removing arguments, so there's no much fancy\n+    // support there, but we support adding and removing environment variables,\n+    // so a side table is used to track where in the `envp` array each key is\n+    // located. Whenever we add a key we update it in place if it's already\n+    // present, and whenever we remove a key we update the locations of all\n+    // other keys.\n+    program: String,\n+    args: Vec<String>,\n+    env: HashMap<String, String>,\n+\n+    cwd: Option<CString>,\n+    uid: Option<uid_t>,\n+    gid: Option<gid_t>,\n+    saw_nul: bool,\n+    closures: Vec<Box<FnMut() -> io::Result<()> + Send + Sync>>,\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+// passed to do_exec() with configuration of what the child stdio should look\n+// like\n+struct ChildPipes {\n+    stdin: ChildStdio,\n+    stdout: ChildStdio,\n+    stderr: ChildStdio,\n+}\n+\n+enum ChildStdio {\n+    Inherit,\n+    Explicit(c_int),\n+    Owned(FileDesc),\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+    Fd(FileDesc),\n+}\n+\n+impl Command {\n+    pub fn new(program: &OsStr) -> Command {\n+        Command {\n+            program: program.to_str().unwrap().to_owned(),\n+            args: Vec::new(),\n+            env: HashMap::new(),\n+            cwd: None,\n+            uid: None,\n+            gid: None,\n+            saw_nul: false,\n+            closures: Vec::new(),\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+        }\n+    }\n+\n+    pub fn arg(&mut self, arg: &OsStr) {\n+        self.args.push(arg.to_str().unwrap().to_owned());\n+    }\n+\n+    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n+        self.env.insert(key.to_str().unwrap().to_owned(), val.to_str().unwrap().to_owned());\n+    }\n+\n+    pub fn env_remove(&mut self, key: &OsStr) {\n+        self.env.remove(key.to_str().unwrap());\n+    }\n+\n+    pub fn env_clear(&mut self) {\n+        self.env.clear();\n+    }\n+\n+    pub fn cwd(&mut self, dir: &OsStr) {\n+        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n+    }\n+    pub fn uid(&mut self, id: uid_t) {\n+        self.uid = Some(id);\n+    }\n+    pub fn gid(&mut self, id: gid_t) {\n+        self.gid = Some(id);\n+    }\n+\n+    pub fn before_exec(&mut self,\n+                       f: Box<FnMut() -> io::Result<()> + Send + Sync>) {\n+        self.closures.push(f);\n+    }\n+\n+    pub fn stdin(&mut self, stdin: Stdio) {\n+        self.stdin = Some(stdin);\n+    }\n+    pub fn stdout(&mut self, stdout: Stdio) {\n+        self.stdout = Some(stdout);\n+    }\n+    pub fn stderr(&mut self, stderr: Stdio) {\n+        self.stderr = Some(stderr);\n+    }\n+\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n+        if self.saw_nul {\n+            return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n+        }\n+\n+        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+        let (input, output) = sys::pipe::anon_pipe()?;\n+\n+        let pid = unsafe {\n+            match cvt(libc::fork() as isize)? {\n+                0 => {\n+                    drop(input);\n+                    let err = self.do_exec(theirs);\n+                    let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                    ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n+                    // we want to be sure we *don't* run at_exit destructors as\n+                    // we're being torn down regardless\n+                    assert!(output.write(&bytes).is_ok());\n+                    libc::_exit(1)\n+                }\n+                n => n as pid_t,\n+            }\n+        };\n+\n+        let mut p = Process { pid: pid, status: None };\n+        drop(output);\n+        let mut bytes = [0; 8];\n+\n+        // loop to handle EINTR\n+        loop {\n+            match input.read(&mut bytes) {\n+                Ok(0) => return Ok((p, ours)),\n+                Ok(8) => {\n+                    assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                            \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                    let errno = combine(&bytes[0.. 4]);\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    return Err(Error::from_raw_os_error(errno))\n+                }\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => {\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                },\n+                Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"short read on the CLOEXEC pipe\")\n+                }\n+            }\n+        }\n+\n+        fn combine(arr: &[u8]) -> i32 {\n+            let a = arr[0] as u32;\n+            let b = arr[1] as u32;\n+            let c = arr[2] as u32;\n+            let d = arr[3] as u32;\n+\n+            ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+        }\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        if self.saw_nul {\n+            return io::Error::new(ErrorKind::InvalidInput,\n+                                  \"nul byte found in provided data\")\n+        }\n+\n+        match self.setup_io(default, true) {\n+            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n+            Err(e) => e,\n+        }\n+    }\n+\n+    // And at this point we've reached a special time in the life of the\n+    // child. The child must now be considered hamstrung and unable to\n+    // do anything other than syscalls really. Consider the following\n+    // scenario:\n+    //\n+    //      1. Thread A of process 1 grabs the malloc() mutex\n+    //      2. Thread B of process 1 forks(), creating thread C\n+    //      3. Thread C of process 2 then attempts to malloc()\n+    //      4. The memory of process 2 is the same as the memory of\n+    //         process 1, so the mutex is locked.\n+    //\n+    // This situation looks a lot like deadlock, right? It turns out\n+    // that this is what pthread_atfork() takes care of, which is\n+    // presumably implemented across platforms. The first thing that\n+    // threads to *before* forking is to do things like grab the malloc\n+    // mutex, and then after the fork they unlock it.\n+    //\n+    // Despite this information, libnative's spawn has been witnessed to\n+    // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+    // all collected backtraces point at malloc/free traffic in the\n+    // child spawned process.\n+    //\n+    // For this reason, the block of code below should contain 0\n+    // invocations of either malloc of free (or their related friends).\n+    //\n+    // As an example of not having malloc/free traffic, we don't close\n+    // this file descriptor by dropping the FileDesc (which contains an\n+    // allocation). Instead we just close it manually. This will never\n+    // have the drop glue anyway because this code never returns (the\n+    // child will either exec() or invoke libc::exit)\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n+        macro_rules! t {\n+            ($e:expr) => (match $e {\n+                Ok(e) => e,\n+                Err(e) => return e,\n+            })\n+        }\n+\n+        if let Some(fd) = stdio.stderr.fd() {\n+            libc::close(libc::STDERR_FILENO);\n+            t!(cvt(libc::dup(fd)));\n+            libc::close(fd);\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            libc::close(libc::STDOUT_FILENO);\n+            t!(cvt(libc::dup(fd)));\n+            libc::close(fd);\n+        }\n+        if let Some(fd) = stdio.stdin.fd() {\n+            libc::close(libc::STDIN_FILENO);\n+            t!(cvt(libc::dup(fd)));\n+            libc::close(fd);\n+        }\n+\n+        if let Some(u) = self.gid {\n+            t!(cvt(libc::setgid(u as gid_t)));\n+        }\n+        if let Some(u) = self.uid {\n+            t!(cvt(libc::setuid(u as uid_t)));\n+        }\n+        if let Some(ref cwd) = self.cwd {\n+            t!(cvt(libc::chdir(cwd.as_ptr())));\n+        }\n+\n+        for callback in self.closures.iter_mut() {\n+            t!(callback());\n+        }\n+\n+        let mut args: Vec<[usize; 2]> = Vec::new();\n+        args.push([self.program.as_ptr() as usize, self.program.len()]);\n+        for arg in self.args.iter() {\n+            args.push([arg.as_ptr() as usize, arg.len()]);\n+        }\n+\n+        for (key, val) in self.env.iter() {\n+            env::set_var(key, val);\n+        }\n+\n+        if let Err(err) = libc::exec(&self.program, &args) {\n+            io::Error::from_raw_os_error(err.errno as i32)\n+        } else {\n+            panic!(\"return from exec without err\");\n+        }\n+    }\n+\n+\n+    fn setup_io(&self, default: Stdio, needs_stdin: bool)\n+                -> io::Result<(StdioPipes, ChildPipes)> {\n+        let null = Stdio::Null;\n+        let default_stdin = if needs_stdin {&default} else {&null};\n+        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n+        let stdout = self.stdout.as_ref().unwrap_or(&default);\n+        let stderr = self.stderr.as_ref().unwrap_or(&default);\n+        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n+        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n+        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n+        let ours = StdioPipes {\n+            stdin: our_stdin,\n+            stdout: our_stdout,\n+            stderr: our_stderr,\n+        };\n+        let theirs = ChildPipes {\n+            stdin: their_stdin,\n+            stdout: their_stdout,\n+            stderr: their_stderr,\n+        };\n+        Ok((ours, theirs))\n+    }\n+}\n+\n+fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n+    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"<string-with-nul>\").unwrap()\n+    })\n+}\n+\n+impl Stdio {\n+    fn to_child_stdio(&self, readable: bool)\n+                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+        match *self {\n+            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n+\n+            // Make sure that the source descriptors are not an stdio\n+            // descriptor, otherwise the order which we set the child's\n+            // descriptors may blow away a descriptor which we are hoping to\n+            // save. For example, suppose we want the child's stderr to be the\n+            // parent's stdout, and the child's stdout to be the parent's\n+            // stderr. No matter which we dup first, the second will get\n+            // overwritten prematurely.\n+            Stdio::Fd(ref fd) => {\n+                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n+                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n+                } else {\n+                    Ok((ChildStdio::Explicit(fd.raw()), None))\n+                }\n+            }\n+\n+            Stdio::MakePipe => {\n+                let (reader, writer) = pipe::anon_pipe()?;\n+                let (ours, theirs) = if readable {\n+                    (writer, reader)\n+                } else {\n+                    (reader, writer)\n+                };\n+                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n+            }\n+\n+            Stdio::Null => {\n+                let mut opts = OpenOptions::new();\n+                opts.read(readable);\n+                opts.write(!readable);\n+                let path = unsafe {\n+                    CStr::from_ptr(\"/dev/null\\0\".as_ptr() as *const _)\n+                };\n+                let fd = File::open_c(&path, &opts)?;\n+                Ok((ChildStdio::Owned(fd.into_fd()), None))\n+            }\n+        }\n+    }\n+}\n+\n+impl ChildStdio {\n+    fn fd(&self) -> Option<c_int> {\n+        match *self {\n+            ChildStdio::Inherit => None,\n+            ChildStdio::Explicit(fd) => Some(fd),\n+            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n+        }\n+    }\n+}\n+\n+fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n+    let (key, value) = (key.as_bytes(), value.as_bytes());\n+    let mut v = Vec::with_capacity(key.len() + value.len() + 1);\n+    v.extend(key);\n+    v.push(b'=');\n+    v.extend(value);\n+    CString::new(v).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"foo=bar\").unwrap()\n+    })\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.program)?;\n+        for arg in &self.args {\n+            write!(f, \" {:?}\", arg)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n+\n+impl ExitStatus {\n+    fn exited(&self) -> bool {\n+        true\n+    }\n+\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        if self.exited() {\n+            Some(self.0)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() {\n+            Some(self.0)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl From<c_int> for ExitStatus {\n+    fn from(a: c_int) -> ExitStatus {\n+        ExitStatus(a)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n+        }\n+    }\n+}\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pid: pid_t,\n+    status: Option<ExitStatus>,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        self.pid as u32\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n+        }\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+        let mut status = 0;\n+        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n+        self.status = Some(ExitStatus(status as i32));\n+        Ok(ExitStatus(status as i32))\n+    }\n+}\n+\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod tests {\n+    use super::*;\n+\n+    use ffi::OsStr;\n+    use mem;\n+    use ptr;\n+    use libc;\n+    use sys::cvt;\n+\n+    macro_rules! t {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"android\"))]\n+    extern {\n+        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n+        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n+    }\n+\n+    #[cfg(target_os = \"android\")]\n+    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n+        use slice;\n+\n+        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n+        let bit = (signum - 1) as usize;\n+        raw[bit / 8] |= 1 << (bit % 8);\n+        return 0;\n+    }\n+\n+    // See #14232 for more information, but it appears that signal delivery to a\n+    // newly spawned process may just be raced in the OSX, so to prevent this\n+    // test from being flaky we ignore it on OSX.\n+    #[test]\n+    #[cfg_attr(target_os = \"macos\", ignore)]\n+    #[cfg_attr(target_os = \"nacl\", ignore)] // no signals on NaCl.\n+    fn test_process_mask() {\n+        unsafe {\n+            // Test to make sure that a signal mask does not get inherited.\n+            let mut cmd = Command::new(OsStr::new(\"cat\"));\n+\n+            let mut set: libc::sigset_t = mem::uninitialized();\n+            let mut old_set: libc::sigset_t = mem::uninitialized();\n+            t!(cvt(libc::sigemptyset(&mut set)));\n+            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n+\n+            cmd.stdin(Stdio::MakePipe);\n+            cmd.stdout(Stdio::MakePipe);\n+\n+            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n+            let stdin_write = pipes.stdin.take().unwrap();\n+            let stdout_read = pipes.stdout.take().unwrap();\n+\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n+                                         ptr::null_mut())));\n+\n+            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n+            // We need to wait until SIGINT is definitely delivered. The\n+            // easiest way is to write something to cat, and try to read it\n+            // back: if SIGINT is unmasked, it'll get delivered when cat is\n+            // next scheduled.\n+            let _ = stdin_write.write(b\"Hello\");\n+            drop(stdin_write);\n+\n+            // Either EOF or failure (EPIPE) is okay.\n+            let mut buf = [0; 5];\n+            if let Ok(ret) = stdout_read.read(&mut buf) {\n+                assert!(ret == 0);\n+            }\n+\n+            t!(cat.wait());\n+        }\n+    }\n+}"}, {"sha": "6ea9a3fb1057f16036415a3b87bb6ab6f54e941f", "filename": "src/libstd/sys/redox/rand.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frand.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fs::File;\n+use io;\n+use rand::Rng;\n+use rand::reader::ReaderRng;\n+\n+pub struct OsRng {\n+    inner: ReaderRng<File>,\n+}\n+\n+impl OsRng {\n+    /// Create a new `OsRng`.\n+    pub fn new() -> io::Result<OsRng> {\n+        let reader = File::open(\"rand:\")?;\n+        let reader_rng = ReaderRng::new(reader);\n+\n+        Ok(OsRng { inner: reader_rng })\n+    }\n+}\n+\n+impl Rng for OsRng {\n+    fn next_u32(&mut self) -> u32 {\n+        self.inner.next_u32()\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        self.inner.next_u64()\n+    }\n+    fn fill_bytes(&mut self, v: &mut [u8]) {\n+        self.inner.fill_bytes(v)\n+    }\n+}"}, {"sha": "c2de1d50685f27e6056121d79f5b68de9f7d40d2", "filename": "src/libstd/sys/redox/rwlock.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct RWLock;\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        unimplemented!();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        unimplemented!();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        unimplemented!();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        unimplemented!();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        unimplemented!();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        unimplemented!();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+\n+    }\n+}"}, {"sha": "c8595d38b21c73bb9c59e4c4064efe661a61d90a", "filename": "src/libstd/sys/redox/stack_overflow.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(test, allow(dead_code))]\n+\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        unimplemented!();\n+    }\n+}\n+\n+pub unsafe fn init() {\n+\n+}\n+\n+pub unsafe fn cleanup() {\n+    unimplemented!();\n+}"}, {"sha": "0ed9de36c73dc14a0d098a8d6e464c681e0e9e5d", "filename": "src/libstd/sys/redox/stdio.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use libc;\n+use sys::fd::FileDesc;\n+\n+pub struct Stdin(());\n+pub struct Stdout(());\n+pub struct Stderr(());\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+\n+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDIN_FILENO);\n+        let ret = fd.read(data);\n+        fd.into_raw();\n+        ret\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDIN_FILENO);\n+        let ret = fd.read_to_end(buf);\n+        fd.into_raw();\n+        ret\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDOUT_FILENO);\n+        let ret = fd.write(data);\n+        fd.into_raw();\n+        ret\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDERR_FILENO);\n+        let ret = fd.write(data);\n+        fd.into_raw();\n+        ret\n+    }\n+}\n+\n+// FIXME: right now this raw stderr handle is used in a few places because\n+//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n+//        should go away\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Stderr::write(self, data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+pub const EBADF_ERR: i32 = ::libc::EBADF;"}, {"sha": "eaf908dc53ec4a7ede1521b5747e5b23f4bdedce", "filename": "src/libstd/sys/redox/thread.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::boxed::FnBox;\n+use cmp;\n+use ffi::CStr;\n+use io;\n+use libc;\n+use mem;\n+use sys::os;\n+use sys_common::thread::start_thread;\n+use time::Duration;\n+\n+pub struct Thread {\n+    id: libc::pid_t,\n+}\n+\n+// Some platforms may have pthread_t as a pointer in which case we still want\n+// a thread to be Send/Sync\n+unsafe impl Send for Thread {}\n+unsafe impl Sync for Thread {}\n+\n+impl Thread {\n+    pub unsafe fn new<'a>(_stack: usize, p: Box<FnBox() + 'a>) -> io::Result<Thread> {\n+        let p = box p;\n+\n+        start_thread(&*p as *const _ as *mut _);\n+\n+        unimplemented!();\n+    }\n+\n+    pub fn yield_now() {\n+        let ret = unsafe { libc::sched_yield() };\n+        debug_assert_eq!(ret, 0);\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+\n+    }\n+\n+    pub fn sleep(dur: Duration) {\n+        let mut secs = dur.as_secs();\n+        let mut nsecs = dur.subsec_nanos() as i32;\n+\n+        // If we're awoken with a signal then the return value will be -1 and\n+        // nanosleep will fill in `ts` with the remaining time.\n+        unsafe {\n+            while secs > 0 || nsecs > 0 {\n+                let mut ts = libc::timespec {\n+                    tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n+                    tv_nsec: nsecs,\n+                };\n+                secs -= ts.tv_sec as u64;\n+                if libc::nanosleep(&ts, &mut ts) == -1 {\n+                    assert_eq!(os::errno(), libc::EINTR);\n+                    secs += ts.tv_sec as u64;\n+                    nsecs = ts.tv_nsec;\n+                } else {\n+                    nsecs = 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn join(self) {\n+        panic!();\n+    }\n+\n+    pub fn id(&self) -> libc::pid_t { self.id }\n+\n+    pub fn into_id(self) -> libc::pid_t {\n+        let id = self.id;\n+        mem::forget(self);\n+        id\n+    }\n+}\n+\n+impl Drop for Thread {\n+    fn drop(&mut self) {\n+        panic!();\n+    }\n+}\n+\n+pub mod guard {\n+    pub unsafe fn current() -> Option<usize> { None }\n+    pub unsafe fn init() -> Option<usize> { None }\n+}"}, {"sha": "2639ef013dee38817e23326f359460db9f2f0071", "filename": "src/libstd/sys/redox/thread_local.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)] // not used on all platforms\n+\n+pub type Key = usize;\n+\n+#[inline]\n+pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    panic!(\"pthread key create not supported\");\n+    //let mut key = 0;\n+    //assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n+    //key\n+}\n+\n+#[inline]\n+pub unsafe fn set(_key: Key, _value: *mut u8) {\n+    panic!(\"pthread key set not supported\");\n+    //let r = libc::pthread_setspecific(key, value as *mut _);\n+    //debug_assert_eq!(r, 0);\n+}\n+\n+#[inline]\n+pub unsafe fn get(_key: Key) -> *mut u8 {\n+    panic!(\"pthread key get not supported\");\n+    //libc::pthread_getspecific(key) as *mut u8\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(_key: Key) {\n+    panic!(\"pthread key destroy not supported\");\n+    //let r = libc::pthread_key_delete(key);\n+    //debug_assert_eq!(r, 0);\n+}"}, {"sha": "5caaf20fdf80ad4e005e454a87d8585880a21525", "filename": "src/libstd/sys/redox/time.rs", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -0,0 +1,351 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cmp::Ordering;\n+use libc;\n+use time::Duration;\n+\n+pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n+\n+const NSEC_PER_SEC: u64 = 1_000_000_000;\n+\n+#[derive(Copy, Clone)]\n+struct Timespec {\n+    t: libc::timespec,\n+}\n+\n+impl Timespec {\n+    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n+        if self >= other {\n+            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n+                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n+                              (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+            } else {\n+                Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                              other.t.tv_nsec as u32)\n+            })\n+        } else {\n+            match other.sub_timespec(self) {\n+                Ok(d) => Err(d),\n+                Err(d) => Ok(d),\n+            }\n+        }\n+    }\n+\n+    fn add_duration(&self, other: &Duration) -> Timespec {\n+        let secs = (self.t.tv_sec as i64).checked_add(other.as_secs() as i64);\n+        let mut secs = secs.expect(\"overflow when adding duration to time\");\n+\n+        // Nano calculations can't overflow because nanos are <1B which fit\n+        // in a u32.\n+        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+        if nsec >= NSEC_PER_SEC as u32 {\n+            nsec -= NSEC_PER_SEC as u32;\n+            secs = secs.checked_add(1).expect(\"overflow when adding \\\n+                                               duration to time\");\n+        }\n+        Timespec {\n+            t: libc::timespec {\n+                tv_sec: secs as libc::time_t,\n+                tv_nsec: nsec as i32,\n+            },\n+        }\n+    }\n+\n+    fn sub_duration(&self, other: &Duration) -> Timespec {\n+        let secs = (self.t.tv_sec as i64).checked_sub(other.as_secs() as i64);\n+        let mut secs = secs.expect(\"overflow when subtracting duration \\\n+                                    from time\");\n+\n+        // Similar to above, nanos can't overflow.\n+        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        if nsec < 0 {\n+            nsec += NSEC_PER_SEC as i32;\n+            secs = secs.checked_sub(1).expect(\"overflow when subtracting \\\n+                                               duration from time\");\n+        }\n+        Timespec {\n+            t: libc::timespec {\n+                tv_sec: secs as libc::time_t,\n+                tv_nsec: nsec as i32,\n+            },\n+        }\n+    }\n+}\n+\n+impl PartialEq for Timespec {\n+    fn eq(&self, other: &Timespec) -> bool {\n+        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n+    }\n+}\n+\n+impl Eq for Timespec {}\n+\n+impl PartialOrd for Timespec {\n+    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Timespec {\n+    fn cmp(&self, other: &Timespec) -> Ordering {\n+        let me = (self.t.tv_sec, self.t.tv_nsec);\n+        let other = (other.t.tv_sec, other.t.tv_nsec);\n+        me.cmp(&other)\n+    }\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+mod inner {\n+    use fmt;\n+    use libc;\n+    use sync::Once;\n+    use sys::cvt;\n+    use sys_common::mul_div_u64;\n+    use time::Duration;\n+\n+    use super::NSEC_PER_SEC;\n+    use super::Timespec;\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+    pub struct Instant {\n+        t: u64\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    pub struct SystemTime {\n+        t: Timespec,\n+    }\n+\n+    pub const UNIX_EPOCH: SystemTime = SystemTime {\n+        t: Timespec {\n+            t: libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 0,\n+            },\n+        },\n+    };\n+\n+    impl Instant {\n+        pub fn now() -> Instant {\n+            Instant { t: unsafe { libc::mach_absolute_time() } }\n+        }\n+\n+        pub fn sub_instant(&self, other: &Instant) -> Duration {\n+            let info = info();\n+            let diff = self.t.checked_sub(other.t)\n+                           .expect(\"second instant is later than self\");\n+            let nanos = mul_div_u64(diff, info.numer as u64, info.denom as u64);\n+            Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32)\n+        }\n+\n+        pub fn add_duration(&self, other: &Duration) -> Instant {\n+            Instant {\n+                t: self.t.checked_add(dur2intervals(other))\n+                       .expect(\"overflow when adding duration to instant\"),\n+            }\n+        }\n+\n+        pub fn sub_duration(&self, other: &Duration) -> Instant {\n+            Instant {\n+                t: self.t.checked_sub(dur2intervals(other))\n+                       .expect(\"overflow when adding duration to instant\"),\n+            }\n+        }\n+    }\n+\n+    impl SystemTime {\n+        pub fn now() -> SystemTime {\n+            use ptr;\n+\n+            let mut s = libc::timeval {\n+                tv_sec: 0,\n+                tv_usec: 0,\n+            };\n+            cvt(unsafe {\n+                libc::gettimeofday(&mut s, ptr::null_mut())\n+            }).unwrap();\n+            return SystemTime::from(s)\n+        }\n+\n+        pub fn sub_time(&self, other: &SystemTime)\n+                        -> Result<Duration, Duration> {\n+            self.t.sub_timespec(&other.t)\n+        }\n+\n+        pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+            SystemTime { t: self.t.add_duration(other) }\n+        }\n+\n+        pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+            SystemTime { t: self.t.sub_duration(other) }\n+        }\n+    }\n+\n+    impl From<libc::timeval> for SystemTime {\n+        fn from(t: libc::timeval) -> SystemTime {\n+            SystemTime::from(libc::timespec {\n+                tv_sec: t.tv_sec,\n+                tv_nsec: (t.tv_usec * 1000) as libc::c_long,\n+            })\n+        }\n+    }\n+\n+    impl From<libc::timespec> for SystemTime {\n+        fn from(t: libc::timespec) -> SystemTime {\n+            SystemTime { t: Timespec { t: t } }\n+        }\n+    }\n+\n+    impl fmt::Debug for SystemTime {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.debug_struct(\"SystemTime\")\n+             .field(\"tv_sec\", &self.t.t.tv_sec)\n+             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+             .finish()\n+        }\n+    }\n+\n+    fn dur2intervals(dur: &Duration) -> u64 {\n+        let info = info();\n+        let nanos = dur.as_secs().checked_mul(NSEC_PER_SEC).and_then(|nanos| {\n+            nanos.checked_add(dur.subsec_nanos() as u64)\n+        }).expect(\"overflow converting duration to nanoseconds\");\n+        mul_div_u64(nanos, info.denom as u64, info.numer as u64)\n+    }\n+\n+    fn info() -> &'static libc::mach_timebase_info {\n+        static mut INFO: libc::mach_timebase_info = libc::mach_timebase_info {\n+            numer: 0,\n+            denom: 0,\n+        };\n+        static ONCE: Once = Once::new();\n+\n+        unsafe {\n+            ONCE.call_once(|| {\n+                libc::mach_timebase_info(&mut INFO);\n+            });\n+            &INFO\n+        }\n+    }\n+}\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+mod inner {\n+    use fmt;\n+    use libc;\n+    use sys::cvt;\n+    use time::Duration;\n+\n+    use super::Timespec;\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    pub struct Instant {\n+        t: Timespec,\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    pub struct SystemTime {\n+        t: Timespec,\n+    }\n+\n+    pub const UNIX_EPOCH: SystemTime = SystemTime {\n+        t: Timespec {\n+            t: libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 0,\n+            },\n+        },\n+    };\n+\n+    impl Instant {\n+        pub fn now() -> Instant {\n+            Instant { t: now(libc::CLOCK_MONOTONIC) }\n+        }\n+\n+        pub fn sub_instant(&self, other: &Instant) -> Duration {\n+            self.t.sub_timespec(&other.t).unwrap_or_else(|_| {\n+                panic!(\"other was less than the current instant\")\n+            })\n+        }\n+\n+        pub fn add_duration(&self, other: &Duration) -> Instant {\n+            Instant { t: self.t.add_duration(other) }\n+        }\n+\n+        pub fn sub_duration(&self, other: &Duration) -> Instant {\n+            Instant { t: self.t.sub_duration(other) }\n+        }\n+    }\n+\n+    impl fmt::Debug for Instant {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.debug_struct(\"Instant\")\n+             .field(\"tv_sec\", &self.t.t.tv_sec)\n+             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+             .finish()\n+        }\n+    }\n+\n+    impl SystemTime {\n+        pub fn now() -> SystemTime {\n+            SystemTime { t: now(libc::CLOCK_REALTIME) }\n+        }\n+\n+        pub fn sub_time(&self, other: &SystemTime)\n+                        -> Result<Duration, Duration> {\n+            self.t.sub_timespec(&other.t)\n+        }\n+\n+        pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+            SystemTime { t: self.t.add_duration(other) }\n+        }\n+\n+        pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+            SystemTime { t: self.t.sub_duration(other) }\n+        }\n+    }\n+\n+    impl From<libc::timespec> for SystemTime {\n+        fn from(t: libc::timespec) -> SystemTime {\n+            SystemTime { t: Timespec { t: t } }\n+        }\n+    }\n+\n+    impl fmt::Debug for SystemTime {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.debug_struct(\"SystemTime\")\n+             .field(\"tv_sec\", &self.t.t.tv_sec)\n+             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+             .finish()\n+        }\n+    }\n+\n+    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"redox\")))]\n+    pub type clock_t = libc::c_int;\n+    #[cfg(target_os = \"dragonfly\")]\n+    pub type clock_t = libc::c_ulong;\n+    #[cfg(target_os = \"redox\")]\n+    pub type clock_t = usize;\n+\n+    fn now(clock: clock_t) -> Timespec {\n+        let mut t = Timespec {\n+            t: libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 0,\n+            }\n+        };\n+        cvt(unsafe {\n+            libc::clock_gettime(clock, &mut t.t)\n+        }).unwrap();\n+        t\n+    }\n+}"}, {"sha": "a1ae2c1cb423a79701d2dde2a798f6ef82cbd1bf", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "patch": "@@ -358,7 +358,7 @@ pub mod elf {\n         }\n     }\n \n-    #[cfg(any(target_os = \"linux\", target_os = \"fuchsia\"))]\n+    #[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"redox\"))]\n     unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         // The fallback implementation uses a vanilla OS-based TLS key to track\n         // the list of destructors that need to be run for this thread. The key\n@@ -437,7 +437,7 @@ pub mod elf {\n \n     // Just use the thread_local fallback implementation, at least until there's\n     // a more direct implementation.\n-    #[cfg(target_os = \"fuchsia\")]\n+    #[cfg(any(target_os = \"fuchsia\", target_os = \"redox\"))]\n     unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         register_dtor_fallback(t, dtor);\n     }"}]}