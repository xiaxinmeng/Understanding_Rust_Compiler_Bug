{"sha": "2c9aada10cd9146138d76d182ccbd2a7627df204", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjOWFhZGExMGNkOTE0NjEzOGQ3NmQxODJjY2JkMmE3NjI3ZGYyMDQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-06-14T12:46:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-06-29T11:15:26Z"}, "message": "c_str: add `.as_ptr` & `.as_mut_ptr` to replace `.with_[mut_]ref`.\n\nThese forms return the pointer directly, rather than the added\nindirection, indentation, and inefficiencies of the closures in\n`.with_ref` and `.with_mut_ref`. The two closure functions are\ndeprecated.\n\nReplace\n\n    foo(c_str.with_ref(|p| p))\n\n    c_str.with_ref(|p| {\n        foo(p);\n        bar(p);\n    })\n\nwith\n\n    foo(c_str.as_ptr())\n\n    let p = c_str.as_ptr();\n    foo(p);\n    bar(p);\n\nThis change does mean that one has to be careful to avoid writing `let p\n= x.to_c_str().as_ptr();` since the `CString` will be freed at the end\nof the statement. Previously, `with_ref` was used (and `as_ptr` avoided)\nfor this reason, but Rust has strongly moved away from closures to more\nRAII-style code, and most uses of `.with_ref` where in the form\n`.with_ref(|p| p)` anyway, that is, they were exactly `.as_ptr`.\n\n[breaking-change]", "tree": {"sha": "aaccf0ce04070f2b8cea5856ae6c3f81fb1f0dd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaccf0ce04070f2b8cea5856ae6c3f81fb1f0dd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c9aada10cd9146138d76d182ccbd2a7627df204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c9aada10cd9146138d76d182ccbd2a7627df204", "html_url": "https://github.com/rust-lang/rust/commit/2c9aada10cd9146138d76d182ccbd2a7627df204", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c9aada10cd9146138d76d182ccbd2a7627df204/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a3695d54f14491c39da7910082df9ba9c833b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3695d54f14491c39da7910082df9ba9c833b37", "html_url": "https://github.com/rust-lang/rust/commit/6a3695d54f14491c39da7910082df9ba9c833b37"}], "stats": {"total": 69, "additions": 69, "deletions": 0}, "files": [{"sha": "bc3e64c519ad9f6037a176fc6868cb61a76756be", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2c9aada10cd9146138d76d182ccbd2a7627df204/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c9aada10cd9146138d76d182ccbd2a7627df204/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=2c9aada10cd9146138d76d182ccbd2a7627df204", "patch": "@@ -133,11 +133,79 @@ impl CString {\n         c_str.buf\n     }\n \n+    /// Return a pointer to the NUL-terminated string data.\n+    ///\n+    /// `.as_ptr` returns an internal pointer into the `CString`, and\n+    /// may be invalidated when the `CString` falls out of scope (the\n+    /// destructor will run, freeing the allocation if there is\n+    /// one).\n+    ///\n+    /// ```rust\n+    /// let foo = \"some string\";\n+    ///\n+    /// // right\n+    /// let x = foo.to_c_str();\n+    /// let p = x.as_ptr();\n+    ///\n+    /// // wrong (the CString will be freed, invalidating `p`)\n+    /// let p = foo.to_c_str().as_ptr();\n+    /// ```\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// extern crate libc;\n+    ///\n+    /// fn main() {\n+    ///     let c_str = \"foo bar\".to_c_str();\n+    ///     unsafe {\n+    ///         libc::puts(c_str.as_ptr());\n+    ///     }\n+    /// }\n+    /// ```\n+    pub fn as_ptr(&self) -> *const libc::c_char {\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+\n+        self.buf\n+    }\n+\n+    /// Return a mutable pointer to the NUL-terminated string data.\n+    ///\n+    /// `.as_mut_ptr` returns an internal pointer into the `CString`, and\n+    /// may be invalidated when the `CString` falls out of scope (the\n+    /// destructor will run, freeing the allocation if there is\n+    /// one).\n+    ///\n+    /// ```rust\n+    /// let foo = \"some string\";\n+    ///\n+    /// // right\n+    /// let mut x = foo.to_c_str();\n+    /// let p = x.as_mut_ptr();\n+    ///\n+    /// // wrong (the CString will be freed, invalidating `p`)\n+    /// let p = foo.to_c_str().as_mut_ptr();\n+    /// ```\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n+    pub fn as_mut_ptr(&mut self) -> *mut libc::c_char {\n+        if self.buf.is_null() { fail!(\"CString is null!\") }\n+\n+        self.buf as *mut _\n+    }\n+\n     /// Calls a closure with a reference to the underlying `*libc::c_char`.\n     ///\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n+    #[deprecated=\"use `.as_ptr()`\"]\n     pub fn with_ref<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n@@ -148,6 +216,7 @@ impl CString {\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n+    #[deprecated=\"use `.as_mut_ptr()`\"]\n     pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf as *mut libc::c_char)"}]}