{"sha": "ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNTRhYzhlNTk4YmZjNzFlODI3YzBiNjBlMzkyYzVmMGZiZDRkN2U=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-13T00:45:23Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-13T00:45:36Z"}, "message": "Rename vec::unsafe to vec::raw", "tree": {"sha": "c5c20cafe2c415f1f3aecbc2fa60770e3ca9f1e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c20cafe2c415f1f3aecbc2fa60770e3ca9f1e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "html_url": "https://github.com/rust-lang/rust/commit/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37cf649311bcf6fec2d9096b483ac4be81b70732", "url": "https://api.github.com/repos/rust-lang/rust/commits/37cf649311bcf6fec2d9096b483ac4be81b70732", "html_url": "https://github.com/rust-lang/rust/commit/37cf649311bcf6fec2d9096b483ac4be81b70732"}], "stats": {"total": 176, "additions": 88, "deletions": 88}, "files": [{"sha": "4fbc05821f8f6aa7f46bee7a795046f04ada7f06", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -15,7 +15,7 @@ export unsafe;\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                 ++v: **vec::unsafe::VecRepr,\n+                                 ++v: **vec::raw::VecRepr,\n                                  ++n: libc::size_t);\n }\n \n@@ -142,8 +142,8 @@ impl<T: Copy> @[T]: Add<&[const T],@[T]> {\n \n \n mod unsafe {\n-    type VecRepr = vec::unsafe::VecRepr;\n-    type SliceRepr = vec::unsafe::SliceRepr;\n+    type VecRepr = vec::raw::VecRepr;\n+    type SliceRepr = vec::raw::SliceRepr;\n \n     /**\n      * Sets the length of a vector"}, {"sha": "836ffabd0fc39e819b7675f89dd405d51805f99d", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -28,7 +28,7 @@ fn deflate_buf(buf: &[const u8]) -> ~[u8] {\n                                                    ptr::addr_of(outsz),\n                                                    lz_norm);\n             assert res as int != 0;\n-            let out = vec::unsafe::from_buf(res as *u8,\n+            let out = vec::raw::from_buf(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n             move out\n@@ -46,7 +46,7 @@ fn inflate_buf(buf: &[const u8]) -> ~[u8] {\n                                                      ptr::addr_of(outsz),\n                                                      0);\n             assert res as int != 0;\n-            let out = vec::unsafe::from_buf(res as *u8,\n+            let out = vec::raw::from_buf(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n             move out"}, {"sha": "5f96345d783f969eda2e3209d83f0bb68cd28857", "filename": "src/libcore/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -53,11 +53,11 @@ impl<T: Reader> T : ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8] {\n         let mut buf = ~[mut];\n         vec::reserve(buf, len);\n-        unsafe { vec::unsafe::set_len(buf, len); }\n+        unsafe { vec::raw::set_len(buf, len); }\n \n         let count = self.read(buf, len);\n \n-        unsafe { vec::unsafe::set_len(buf, count); }\n+        unsafe { vec::raw::set_len(buf, count); }\n         vec::from_mut(move buf)\n     }\n     fn read_line() -> ~str {\n@@ -682,7 +682,7 @@ impl MemBuffer: Writer {\n \n             let count = uint::max(buf_len, self.pos + v_len);\n             vec::reserve(buf, count);\n-            unsafe { vec::unsafe::set_len(buf, count); }\n+            unsafe { vec::raw::set_len(buf, count); }\n \n             vec::u8::memcpy(vec::mut_view(buf, self.pos, count), v, v_len);\n "}, {"sha": "c95e2aa6c7c0be922e9d4fa99165c1e665a034eb", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -265,14 +265,14 @@ fn test() {\n         let mut v0 = ~[32000u16, 32001u16, 32002u16];\n         let mut v1 = ~[0u16, 0u16, 0u16];\n \n-        ptr::memcpy(ptr::mut_offset(vec::unsafe::to_mut_ptr(v1), 1u),\n-                    ptr::offset(vec::unsafe::to_ptr(v0), 1u), 1u);\n+        ptr::memcpy(ptr::mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n+                    ptr::offset(vec::raw::to_ptr(v0), 1u), 1u);\n         assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-        ptr::memcpy(vec::unsafe::to_mut_ptr(v1),\n-                    ptr::offset(vec::unsafe::to_ptr(v0), 2u), 1u);\n+        ptr::memcpy(vec::raw::to_mut_ptr(v1),\n+                    ptr::offset(vec::raw::to_ptr(v0), 2u), 1u);\n         assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-        ptr::memcpy(ptr::mut_offset(vec::unsafe::to_mut_ptr(v1), 2u),\n-                    vec::unsafe::to_ptr(v0), 1u);\n+        ptr::memcpy(ptr::mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n+                    vec::raw::to_ptr(v0), 1u);\n         assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n     }\n }"}, {"sha": "88eb4a8d87de7a73d1f35cdac8140026e920241d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -439,15 +439,15 @@ Section: Transforming strings\n  */\n pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n     let mut v: ~[u8] = ::unsafe::transmute(from_slice(s));\n-    vec::unsafe::set_len(v, len(s));\n+    vec::raw::set_len(v, len(s));\n     move v\n }\n \n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n     do as_buf(s) |p,n| {\n-        unsafe { vec::unsafe::form_slice(p, n-1u, f) }\n+        unsafe { vec::raw::form_slice(p, n-1u, f) }\n     }\n }\n \n@@ -1996,7 +1996,7 @@ mod unsafe {\n             let vbuf = ::unsafe::transmute_mut_unsafe(vbuf);\n             ptr::memcpy(vbuf, buf as *u8, len)\n         });\n-        vec::unsafe::set_len(v, len);\n+        vec::raw::set_len(v, len);\n         vec::push(v, 0u8);\n \n         assert is_utf8(v);\n@@ -2054,7 +2054,7 @@ mod unsafe {\n                     let src = ptr::offset(sbuf, begin);\n                     ptr::memcpy(vbuf, src, end - begin);\n                 }\n-                vec::unsafe::set_len(v, end - begin);\n+                vec::raw::set_len(v, end - begin);\n                 vec::push(v, 0u8);\n                 ::unsafe::transmute(move v)\n             }\n@@ -2118,7 +2118,7 @@ mod unsafe {\n \n     /// Sets the length of the string and adds the null terminator\n     unsafe fn set_len(&v: ~str, new_len: uint) {\n-        let repr: *vec::unsafe::VecRepr = ::unsafe::reinterpret_cast(&v);\n+        let repr: *vec::raw::VecRepr = ::unsafe::reinterpret_cast(&v);\n         (*repr).fill = new_len + 1u;\n         let null = ptr::mut_offset(ptr::mut_addr_of((*repr).data), new_len);\n         *null = 0u8;\n@@ -2128,7 +2128,7 @@ mod unsafe {\n     fn test_from_buf_len() {\n         unsafe {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-            let b = vec::unsafe::to_ptr(a);\n+            let b = vec::raw::to_ptr(a);\n             let c = from_buf_len(b, 3u);\n             assert (c == ~\"AAA\");\n         }\n@@ -2940,7 +2940,7 @@ mod tests {\n     fn test_from_buf() {\n         unsafe {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-            let b = vec::unsafe::to_ptr(a);\n+            let b = vec::raw::to_ptr(a);\n             let c = unsafe::from_buf(b);\n             assert (c == ~\"AAAAAAA\");\n         }"}, {"sha": "879ba684698240f1db3f5c58e6bf128520274e30", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -239,7 +239,7 @@ pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n                 *ptr::mut_offset(mp, i) = '-' as u8;\n             }\n \n-            vec::unsafe::form_slice(ptr::offset(p, i),\n+            vec::raw::form_slice(ptr::offset(p, i),\n                                     len - i, f)\n         }\n     }"}, {"sha": "626cb886fb3093e592a77850b3a5d56fdb9c9bbe", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -87,7 +87,7 @@ export windowed;\n export as_buf;\n export as_mut_buf;\n export as_const_buf;\n-export unsafe;\n+export raw;\n export u8;\n export extensions;\n export ConstVector;\n@@ -101,7 +101,7 @@ export vec_concat;\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     fn vec_reserve_shared(++t: *sys::TypeDesc,\n-                          ++v: **unsafe::VecRepr,\n+                          ++v: **raw::VecRepr,\n                           ++n: libc::size_t);\n }\n \n@@ -139,7 +139,7 @@ pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n fn reserve<T>(&v: ~[const T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     if capacity(v) < n {\n-        let ptr = ptr::addr_of(v) as **unsafe::VecRepr;\n+        let ptr = ptr::addr_of(v) as **raw::VecRepr;\n         rustrt::vec_reserve_shared(sys::get_type_desc::<T>(),\n                                    ptr, n as size_t);\n     }\n@@ -168,7 +168,7 @@ fn reserve_at_least<T>(&v: ~[const T], n: uint) {\n #[inline(always)]\n pure fn capacity<T>(&&v: ~[const T]) -> uint {\n     unsafe {\n-        let repr: **unsafe::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n         (**repr).alloc / sys::size_of::<T>()\n     }\n }\n@@ -189,8 +189,8 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n     let mut v = ~[];\n     unchecked{reserve(v, n_elts);}\n     let mut i: uint = 0u;\n-    while i < n_elts unsafe { unsafe::set(v, i, op(i)); i += 1u; }\n-    unsafe { unsafe::set_len(v, n_elts); }\n+    while i < n_elts unsafe { raw::set(v, i, op(i)); i += 1u; }\n+    unsafe { raw::set_len(v, n_elts); }\n     move v\n }\n \n@@ -205,8 +205,8 @@ pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n     unchecked{reserve(v, n_elts)}\n     let mut i: uint = 0u;\n     unsafe { // because unsafe::set is unsafe\n-        while i < n_elts { unsafe::set(v, i, t); i += 1u; }\n-        unsafe { unsafe::set_len(v, n_elts); }\n+        while i < n_elts { raw::set(v, i, t); i += 1u; }\n+        unsafe { raw::set_len(v, n_elts); }\n     }\n     move v\n }\n@@ -478,15 +478,15 @@ fn shift<T>(&v: ~[T]) -> T {\n     unsafe {\n         let mut rr;\n         {\n-            let vv = unsafe::to_ptr(vv);\n+            let vv = raw::to_ptr(vv);\n             rr <- *vv;\n \n             for uint::range(1, ln) |i| {\n                 let r <- *ptr::offset(vv, i);\n                 push(v, move r);\n             }\n         }\n-        unsafe::set_len(vv, 0);\n+        raw::set_len(vv, 0);\n \n         move rr\n     }\n@@ -509,7 +509,7 @@ fn consume<T>(+v: ~[T], f: fn(uint, +T)) unsafe {\n         }\n     }\n \n-    unsafe::set_len(v, 0);\n+    raw::set_len(v, 0);\n }\n \n fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +T)) unsafe {\n@@ -520,7 +520,7 @@ fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +T)) unsafe {\n         }\n     }\n \n-    unsafe::set_len(v, 0);\n+    raw::set_len(v, 0);\n }\n \n /// Remove the last element from a vector and return it\n@@ -532,7 +532,7 @@ fn pop<T>(&v: ~[const T]) -> T {\n     let valptr = ptr::mut_addr_of(v[ln - 1u]);\n     unsafe {\n         let val <- *valptr;\n-        unsafe::set_len(v, ln - 1u);\n+        raw::set_len(v, ln - 1u);\n         move val\n     }\n }\n@@ -555,7 +555,7 @@ fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n             let valptr = ptr::mut_addr_of(v[index]);\n             *valptr <-> val;\n         }\n-        unsafe::set_len(v, ln - 1);\n+        raw::set_len(v, ln - 1);\n         move val\n     }\n }\n@@ -564,7 +564,7 @@ fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n #[inline(always)]\n fn push<T>(&v: ~[const T], +initval: T) {\n     unsafe {\n-        let repr: **unsafe::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).fill;\n         if (**repr).alloc > fill {\n             push_fast(v, move initval);\n@@ -578,7 +578,7 @@ fn push<T>(&v: ~[const T], +initval: T) {\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(&v: ~[const T], +initval: T) {\n-    let repr: **unsafe::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+    let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n     let fill = (**repr).fill;\n     (**repr).fill += sys::size_of::<T>();\n     let p = ptr::addr_of((**repr).data);\n@@ -597,7 +597,7 @@ fn push_all<T: Copy>(&v: ~[const T], rhs: &[const T]) {\n     reserve(v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n-        push(v, unsafe { unsafe::get(rhs, i) })\n+        push(v, unsafe { raw::get(rhs, i) })\n     }\n }\n \n@@ -611,7 +611,7 @@ fn push_all_move<T>(&v: ~[const T], -rhs: ~[const T]) {\n                 push(v, move x);\n             }\n         }\n-        unsafe::set_len(rhs, 0);\n+        raw::set_len(rhs, 0);\n     }\n }\n \n@@ -624,7 +624,7 @@ fn truncate<T>(&v: ~[const T], newlen: uint) {\n             for uint::range(newlen, oldlen) |i| {\n                 let _dropped <- *ptr::offset(p, i);\n             }\n-            unsafe::set_len(v, newlen);\n+            raw::set_len(v, newlen);\n         }\n     }\n }\n@@ -660,7 +660,7 @@ fn dedup<T: Eq>(&v: ~[const T]) unsafe {\n         }\n     }\n     // last_written < next_to_read == ln\n-    unsafe::set_len(v, last_written + 1);\n+    raw::set_len(v, last_written + 1);\n }\n \n \n@@ -1786,7 +1786,7 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n }\n \n /// Unsafe operations\n-mod unsafe {\n+mod raw {\n     // FIXME: This should have crate visibility (#1893 blocks that)\n     /// The internal representation of a vector\n     type VecRepr = {\n@@ -1936,8 +1936,8 @@ mod u8 {\n         let b_len = len(*b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n         let r = unsafe {\n-            libc::memcmp(unsafe::to_ptr(*a) as *libc::c_void,\n-                         unsafe::to_ptr(*b) as *libc::c_void, n) as int\n+            libc::memcmp(raw::to_ptr(*a) as *libc::c_void,\n+                         raw::to_ptr(*b) as *libc::c_void, n) as int\n         };\n \n         if r != 0 { r } else {\n@@ -1984,7 +1984,7 @@ mod u8 {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n \n-        unsafe { vec::unsafe::memcpy(dst, src, count) }\n+        unsafe { vec::raw::memcpy(dst, src, count) }\n     }\n \n     /**\n@@ -1997,7 +1997,7 @@ mod u8 {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n \n-        unsafe { vec::unsafe::memmove(dst, src, count) }\n+        unsafe { vec::raw::memmove(dst, src, count) }\n     }\n }\n \n@@ -2076,17 +2076,17 @@ mod tests {\n         unsafe {\n             // Test on-stack copy-from-buf.\n             let a = ~[1, 2, 3];\n-            let mut ptr = unsafe::to_ptr(a);\n-            let b = unsafe::from_buf(ptr, 3u);\n+            let mut ptr = raw::to_ptr(a);\n+            let b = raw::from_buf(ptr, 3u);\n             assert (len(b) == 3u);\n             assert (b[0] == 1);\n             assert (b[1] == 2);\n             assert (b[2] == 3);\n \n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n-            ptr = unsafe::to_ptr(c);\n-            let d = unsafe::from_buf(ptr, 5u);\n+            ptr = raw::to_ptr(c);\n+            let d = raw::from_buf(ptr, 5u);\n             assert (len(d) == 5u);\n             assert (d[0] == 1);\n             assert (d[1] == 2);\n@@ -2869,9 +2869,9 @@ mod tests {\n     fn to_mut_no_copy() {\n         unsafe {\n             let x = ~[1, 2, 3];\n-            let addr = unsafe::to_ptr(x);\n+            let addr = raw::to_ptr(x);\n             let x_mut = to_mut(x);\n-            let addr_mut = unsafe::to_ptr(x_mut);\n+            let addr_mut = raw::to_ptr(x_mut);\n             assert addr == addr_mut;\n         }\n     }\n@@ -2880,9 +2880,9 @@ mod tests {\n     fn from_mut_no_copy() {\n         unsafe {\n             let x = ~[mut 1, 2, 3];\n-            let addr = unsafe::to_ptr(x);\n+            let addr = raw::to_ptr(x);\n             let x_imm = from_mut(x);\n-            let addr_imm = unsafe::to_ptr(x_imm);\n+            let addr_imm = raw::to_ptr(x_imm);\n             assert addr == addr_imm;\n         }\n     }"}, {"sha": "637c7451de0eae694910b637c090e01d1277563b", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -89,7 +89,7 @@ fn round_up_to(base: uint, align: uint) -> uint {\n // in it.\n unsafe fn destroy_chunk(chunk: Chunk) {\n     let mut idx = 0;\n-    let buf = vec::unsafe::to_ptr(chunk.data);\n+    let buf = vec::raw::to_ptr(chunk.data);\n     let fill = chunk.fill;\n \n     while idx < fill {\n@@ -156,7 +156,7 @@ impl &Arena {\n         //       start, n_bytes, align, head.fill);\n \n         unsafe {\n-            ptr::offset(vec::unsafe::to_ptr(head.data), start)\n+            ptr::offset(vec::raw::to_ptr(head.data), start)\n         }\n     }\n \n@@ -200,7 +200,7 @@ impl &Arena {\n         //       start, n_bytes, align, head.fill);\n \n         unsafe {\n-            let buf = vec::unsafe::to_ptr(head.data);\n+            let buf = vec::raw::to_ptr(head.data);\n             return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n         }\n     }"}, {"sha": "31ef440e4a8e7f2e0fa0989ee82ff68ae62012ae", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -968,7 +968,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n     let stream_handle_ptr =\n         (*socket_data_ptr).stream_handle_ptr;\n     let write_buf_vec =  ~[ uv::ll::buf_init(\n-        vec::unsafe::to_ptr(raw_write_data),\n+        vec::raw::to_ptr(raw_write_data),\n         vec::len(raw_write_data)) ];\n     let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n     let result_po = core::comm::Port::<TcpWriteResult>();\n@@ -1103,7 +1103,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         log(debug, fmt!(\"tcp on_read_cb nread: %d\", nread as int));\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n-        let new_bytes = vec::unsafe::from_buf(buf_base, nread as uint);\n+        let new_bytes = vec::raw::from_buf(buf_base, nread as uint);\n         core::comm::send(reader_ch, result::Ok(new_bytes));\n       }\n     }"}, {"sha": "2fe410ec3ecdb2db63100083bcfc265f2e59d76a", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -749,7 +749,7 @@ unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n \n unsafe fn write<T>(req: *uv_write_t, stream: *T,\n          buf_in: *~[uv_buf_t], cb: *u8) -> libc::c_int {\n-    let buf_ptr = vec::unsafe::to_ptr(*buf_in);\n+    let buf_ptr = vec::raw::to_ptr(*buf_in);\n     let buf_cnt = vec::len(*buf_in) as i32;\n     return rustrt::rust_uv_write(req as *libc::c_void,\n                               stream as *libc::c_void,\n@@ -1046,7 +1046,7 @@ mod test {\n                   as *request_wrapper;\n             let buf_base = get_base_from_buf(buf);\n             let buf_len = get_len_from_buf(buf);\n-            let bytes = vec::unsafe::from_buf(buf_base, buf_len as uint);\n+            let bytes = vec::raw::from_buf(buf_base, buf_len as uint);\n             let read_chan = *((*client_data).read_chan);\n             let msg_from_server = str::from_bytes(bytes);\n             core::comm::send(read_chan, msg_from_server);\n@@ -1122,7 +1122,7 @@ mod test {\n         // struct that we'd cast to a void* and store as the\n         // data field in our uv_connect_t struct\n         let req_str_bytes = str::to_bytes(req_str);\n-        let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n+        let req_msg_ptr: *u8 = vec::raw::to_ptr(req_str_bytes);\n         log(debug, fmt!(\"req_msg ptr: %u\", req_msg_ptr as uint));\n         let req_msg = ~[\n             buf_init(req_msg_ptr, vec::len(req_str_bytes))\n@@ -1221,7 +1221,7 @@ mod test {\n                             buf_base as uint,\n                             buf_len as uint,\n                             nread));\n-            let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+            let bytes = vec::raw::from_buf(buf_base, buf_len);\n             let request_str = str::from_bytes(bytes);\n \n             let client_data = get_data_for_uv_handle(\n@@ -1370,7 +1370,7 @@ mod test {\n         let server_write_req_ptr = ptr::addr_of(server_write_req);\n \n         let resp_str_bytes = str::to_bytes(server_resp_msg);\n-        let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n+        let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n         log(debug, fmt!(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n         let resp_msg = ~[\n             buf_init(resp_msg_ptr, vec::len(resp_str_bytes))"}, {"sha": "4ccf8439d3fd38f8bc14ea3f44a7ad2842ec7cdb", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -1105,7 +1105,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n         let args = vec::from_elem(n_args, 0 as TypeRef);\n         unsafe {\n-            llvm::LLVMGetParamTypes(ty, vec::unsafe::to_ptr(args));\n+            llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n         }\n         s += tys_str(names, outer, args);\n         s += ~\") -> \";\n@@ -1117,7 +1117,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n         let elts = vec::from_elem(n_elts, 0 as TypeRef);\n         unsafe {\n-            llvm::LLVMGetStructElementTypes(ty, vec::unsafe::to_ptr(elts));\n+            llvm::LLVMGetStructElementTypes(ty, vec::raw::to_ptr(elts));\n         }\n         s += tys_str(names, outer, elts);\n         s += ~\"}\";\n@@ -1167,7 +1167,7 @@ fn float_width(llt: TypeRef) -> uint {\n fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] unsafe {\n     let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n                              0 as TypeRef);\n-    llvm::LLVMGetParamTypes(fn_ty, vec::unsafe::to_ptr(args));\n+    llvm::LLVMGetParamTypes(fn_ty, vec::raw::to_ptr(args));\n     return args;\n }\n "}, {"sha": "b19fa07d999e6c6986866f63a43f2e12183b78c2", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -193,7 +193,7 @@ fn get_metadata_section(os: os,\n                        vlen);\n                 let minsz = uint::min(vlen, csz);\n                 let mut version_ok = false;\n-                do vec::unsafe::form_slice(cvbuf, minsz) |buf0| {\n+                do vec::raw::form_slice(cvbuf, minsz) |buf0| {\n                     version_ok = (buf0 ==\n                                   encoder::metadata_encoding_version);\n                 }\n@@ -202,7 +202,7 @@ fn get_metadata_section(os: os,\n                 let cvbuf1 = ptr::offset(cvbuf, vlen);\n                 debug!(\"inflating %u bytes of compressed metadata\",\n                        csz - vlen);\n-                do vec::unsafe::form_slice(cvbuf1, csz-vlen) |buf| {\n+                do vec::raw::form_slice(cvbuf1, csz-vlen) |buf| {\n                     let inflated = flate::inflate_buf(buf);\n                     found = move Some(@(move inflated));\n                 }"}, {"sha": "b91d9e58e14b551cb4f080e0329ae544a0bef286", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -2018,7 +2018,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let args = ~[rust_main, llvm::LLVMGetParam(llfn, 0 as c_uint),\n                     llvm::LLVMGetParam(llfn, 1 as c_uint), crate_map];\n         let result = unsafe {\n-            llvm::LLVMBuildCall(bld, start, vec::unsafe::to_ptr(args),\n+            llvm::LLVMBuildCall(bld, start, vec::raw::to_ptr(args),\n                                 args.len() as c_uint, noname())\n         };\n         llvm::LLVMBuildRet(bld, result);"}, {"sha": "45cef99d0a22cd9c0b421028d822babbb4fa4867", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -87,7 +87,7 @@ fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n-        llvm::LLVMBuildAggregateRet(B(cx), vec::unsafe::to_ptr(RetVals),\n+        llvm::LLVMBuildAggregateRet(B(cx), vec::raw::to_ptr(RetVals),\n                                     RetVals.len() as c_uint);\n     }\n }\n@@ -148,7 +148,7 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n                         ~\", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");\n-        llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n+        llvm::LLVMBuildInvoke(B(cx), Fn, vec::raw::to_ptr(Args),\n                               Args.len() as c_uint, Then, Catch,\n                               noname());\n     }\n@@ -161,7 +161,7 @@ fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     cx.terminated = true;\n     unsafe {\n         count_insn(cx, \"fastinvoke\");\n-        let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n+        let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::raw::to_ptr(Args),\n                                       Args.len() as c_uint,\n                                       Then, Catch, noname());\n         lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n@@ -424,7 +424,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n     count_insn(cx, \"gep\");\n-    return llvm::LLVMBuildGEP(B(cx), Pointer, vec::unsafe::to_ptr(Indices),\n+    return llvm::LLVMBuildGEP(B(cx), Pointer, vec::raw::to_ptr(Indices),\n                                Indices.len() as c_uint, noname());\n     }\n }\n@@ -446,7 +446,7 @@ fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n     unsafe {\n         count_insn(cx, \"inboundsgep\");\n     return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n-                                       vec::unsafe::to_ptr(Indices),\n+                                       vec::raw::to_ptr(Indices),\n                                        Indices.len() as c_uint,\n                                        noname());\n     }\n@@ -619,8 +619,8 @@ fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n     let phi = EmptyPhi(cx, Ty);\n     unsafe {\n         count_insn(cx, \"addincoming\");\n-        llvm::LLVMAddIncoming(phi, vec::unsafe::to_ptr(vals),\n-                              vec::unsafe::to_ptr(bbs),\n+        llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n+                              vec::raw::to_ptr(bbs),\n                               vals.len() as c_uint);\n         return phi;\n     }\n@@ -689,7 +689,7 @@ fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"fastcall\");\n-        let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n+        let v = llvm::LLVMBuildCall(B(cx), Fn, vec::raw::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n         return v;\n@@ -701,7 +701,7 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"callwithconv\");\n-        let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n+        let v = llvm::LLVMBuildCall(B(cx), Fn, vec::raw::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, Conv);\n         return v;\n@@ -789,7 +789,7 @@ fn Trap(cx: block) {\n     let Args: ~[ValueRef] = ~[];\n     unsafe {\n         count_insn(cx, \"trap\");\n-        llvm::LLVMBuildCall(b, T, vec::unsafe::to_ptr(Args),\n+        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args),\n                             Args.len() as c_uint, noname());\n     }\n }"}, {"sha": "b6b073e1e350e6001c7d88c5318d31f09d880deb", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -4,7 +4,7 @@\n */\n \n use libc::c_uint;\n-use vec::unsafe::to_ptr;\n+use vec::raw::to_ptr;\n use std::map::{HashMap,Set};\n use syntax::{ast, ast_map};\n use driver::session;\n@@ -1052,7 +1052,7 @@ fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let mut i = 0u;\n     let mut elts: ~[ValueRef] = ~[];\n     while i < size { vec::push(elts, C_u8(0u)); i += 1u; }\n-    return llvm::LLVMConstArray(T_i8(), vec::unsafe::to_ptr(elts),\n+    return llvm::LLVMConstArray(T_i8(), vec::raw::to_ptr(elts),\n                              elts.len() as c_uint);\n }\n \n@@ -1069,19 +1069,19 @@ fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n }\n \n fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef unsafe {\n-    return llvm::LLVMConstArray(ty, vec::unsafe::to_ptr(elts),\n+    return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n                              elts.len() as c_uint);\n }\n \n fn C_bytes(bytes: ~[u8]) -> ValueRef unsafe {\n     return llvm::LLVMConstString(\n-        unsafe::reinterpret_cast(&vec::unsafe::to_ptr(bytes)),\n+        unsafe::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n         bytes.len() as c_uint, True);\n }\n \n fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef unsafe {\n     return llvm::LLVMConstString(\n-        unsafe::reinterpret_cast(&vec::unsafe::to_ptr(bytes)),\n+        unsafe::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n         bytes.len() as c_uint, False);\n }\n "}, {"sha": "fe5cdc8d1ed5c464ca9f706c7f9d1a970554414d", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -66,7 +66,7 @@ fn lli1(bval: bool) -> ValueRef {\n     C_bool(bval)\n }\n fn llmdnode(elems: ~[ValueRef]) -> ValueRef unsafe {\n-    llvm::LLVMMDNode(vec::unsafe::to_ptr(elems),\n+    llvm::LLVMMDNode(vec::raw::to_ptr(elems),\n                      vec::len(elems) as libc::c_uint)\n }\n fn llunused() -> ValueRef {"}, {"sha": "22b35eca9f25e7989700f1fafca8b8635a9f9af9", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "patch": "@@ -11,7 +11,7 @@ extern mod libc {\n fn strlen(str: ~str) -> uint unsafe {\n     // C string is terminated with a zero\n     let bytes = str::to_bytes(str) + ~[0u8];\n-    return libc::my_strlen(vec::unsafe::to_ptr(bytes));\n+    return libc::my_strlen(vec::raw::to_ptr(bytes));\n }\n \n fn main() {"}]}