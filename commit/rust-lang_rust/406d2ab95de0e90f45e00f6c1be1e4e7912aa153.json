{"sha": "406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNmQyYWI5NWRlMGU5MGY0NWUwMGY2YzFiZTFlNGU3OTEyYWExNTM=", "commit": {"author": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-07T00:56:29Z"}, "committer": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-09T00:32:03Z"}, "message": "rename mir -> thir around abstract consts", "tree": {"sha": "2e986e4fbf9db905d1f71f5ff7ebd20e0fc6fa53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e986e4fbf9db905d1f71f5ff7ebd20e0fc6fa53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "html_url": "https://github.com/rust-lang/rust/commit/406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15101c8e95db6941f8c7d55fb301ad1b62748c7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/15101c8e95db6941f8c7d55fb301ad1b62748c7b", "html_url": "https://github.com/rust-lang/rust/commit/15101c8e95db6941f8c7d55fb301ad1b62748c7b"}], "stats": {"total": 571, "additions": 287, "deletions": 284}, "files": [{"sha": "7ebea9ecc8ef23bafa8871dd03818202433445a2", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -26,6 +26,7 @@ use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, Body, Promoted};\n+use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt, Visibility};\n use rustc_serialize::{opaque, Decodable, Decoder};\n@@ -540,7 +541,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n         ty::codec::RefDecodable::decode(d)\n     }\n@@ -1198,14 +1199,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_mir_abstract_const(\n+    fn get_thir_abstract_const(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         self.root\n             .tables\n-            .mir_abstract_consts\n+            .thir_abstract_consts\n             .get(self, id)\n             .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }"}, {"sha": "1a147242619a761881e0548fbadc870ebb9b4519", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -117,7 +117,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n     mir_for_ctfe => { tcx.arena.alloc(cdata.get_mir_for_ctfe(tcx, def_id.index)) }\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n-    mir_abstract_const => { cdata.get_mir_abstract_const(tcx, def_id.index) }\n+    thir_abstract_const => { cdata.get_thir_abstract_const(tcx, def_id.index) }\n     unused_generic_params => { cdata.get_unused_generic_params(def_id.index) }\n     const_param_default => { tcx.mk_const(cdata.get_const_param_default(tcx, def_id.index)) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }"}, {"sha": "60d7f0f85bb57cd26f647078d7a1e500ec4d75a8", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -23,6 +23,7 @@ use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportLevel,\n };\n use rustc_middle::mir::interpret;\n+use rustc_middle::thir;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n@@ -344,7 +345,7 @@ impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         (**self).encode(s)\n     }\n@@ -1304,9 +1305,10 @@ impl EncodeContext<'a, 'tcx> {\n             if encode_const {\n                 record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- self.tcx.mir_for_ctfe(def_id));\n \n-                let abstract_const = self.tcx.mir_abstract_const(def_id);\n+                // FIXME this feels wrong to have in `encode_mir`\n+                let abstract_const = self.tcx.thir_abstract_const(def_id);\n                 if let Ok(Some(abstract_const)) = abstract_const {\n-                    record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n+                    record!(self.tables.thir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n                 }\n             }\n             record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));"}, {"sha": "e59e9ad5d15d678096c5b07464868d6be4cb8f3f", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir;\n+use rustc_middle::thir;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n@@ -305,7 +306,7 @@ define_tables! {\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n-    mir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [mir::abstract_const::Node<'tcx>])>,\n+    thir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n     const_defaults: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a"}, {"sha": "ba8ccc71954ffdd48c4bbc3e4dccadf5d84e8019", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -40,7 +40,6 @@ use self::graph_cyclic_cache::GraphIsCyclicCache;\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n-pub mod abstract_const;\n pub mod coverage;\n mod generic_graph;\n pub mod generic_graphviz;"}, {"sha": "a1c6a8bf99e79d7fbc29ddb497d4a22ef1e2ffb5", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -1,6 +1,7 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{abstract_const, Body, Promoted};\n+use crate::mir::{Body, Promoted};\n+use crate::thir::abstract_const;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n@@ -433,14 +434,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mir_abstract_const_opt_const_arg(\n+    pub fn thir_abstract_const_opt_const_arg(\n         self,\n         def: ty::WithOptConstParam<DefId>,\n     ) -> Result<Option<&'tcx [abstract_const::Node<'tcx>]>, ErrorReported> {\n         if let Some((did, param_did)) = def.as_const_arg() {\n-            self.mir_abstract_const_of_const_arg((did, param_did))\n+            self.thir_abstract_const_of_const_arg((did, param_did))\n         } else {\n-            self.mir_abstract_const(def.did)\n+            self.thir_abstract_const(def.did)\n         }\n     }\n }"}, {"sha": "19535195488b79a3da900fb12801297c4a768338", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -295,17 +295,17 @@ rustc_queries! {\n     }\n \n     /// Try to build an abstract representation of the given constant.\n-    query mir_abstract_const(\n+    query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         desc {\n             |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n         }\n     }\n     /// Try to build an abstract representation of the given constant.\n-    query mir_abstract_const_of_const_arg(\n+    query thir_abstract_const_of_const_arg(\n         key: (LocalDefId, DefId)\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         desc {\n             |tcx|\n             \"building an abstract representation for the const argument {}\","}, {"sha": "8d6fd1e729d3b52b5e4ec75dc6bd775317101924", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 3, "deletions": 243, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -33,6 +33,9 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n+pub mod abstract_const;\n+pub mod visit;\n+\n newtype_index! {\n     /// An index to an [`Arm`] stored in [`Thir::arms`]\n     #[derive(HashStable)]\n@@ -818,246 +821,3 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n         }\n     }\n }\n-\n-pub mod visit {\n-    use super::*;\n-    pub trait Visitor<'a, 'tcx: 'a>: Sized {\n-        fn thir(&self) -> &'a Thir<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &Expr<'tcx>) {\n-            walk_expr(self, expr);\n-        }\n-\n-        fn visit_stmt(&mut self, stmt: &Stmt<'tcx>) {\n-            walk_stmt(self, stmt);\n-        }\n-\n-        fn visit_block(&mut self, block: &Block) {\n-            walk_block(self, block);\n-        }\n-\n-        fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n-            walk_arm(self, arm);\n-        }\n-\n-        fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n-            walk_pat(self, pat);\n-        }\n-\n-        fn visit_const(&mut self, _cnst: &'tcx Const<'tcx>) {}\n-    }\n-\n-    pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {\n-        use ExprKind::*;\n-        match expr.kind {\n-            Scope { value, region_scope: _, lint_level: _ } => {\n-                visitor.visit_expr(&visitor.thir()[value])\n-            }\n-            Box { value } => visitor.visit_expr(&visitor.thir()[value]),\n-            If { cond, then, else_opt, if_then_scope: _ } => {\n-                visitor.visit_expr(&visitor.thir()[cond]);\n-                visitor.visit_expr(&visitor.thir()[then]);\n-                if let Some(else_expr) = else_opt {\n-                    visitor.visit_expr(&visitor.thir()[else_expr]);\n-                }\n-            }\n-            Call { fun, ref args, ty: _, from_hir_call: _, fn_span: _ } => {\n-                visitor.visit_expr(&visitor.thir()[fun]);\n-                for &arg in &**args {\n-                    visitor.visit_expr(&visitor.thir()[arg]);\n-                }\n-            }\n-            Deref { arg } => visitor.visit_expr(&visitor.thir()[arg]),\n-            Binary { lhs, rhs, op: _ } | LogicalOp { lhs, rhs, op: _ } => {\n-                visitor.visit_expr(&visitor.thir()[lhs]);\n-                visitor.visit_expr(&visitor.thir()[rhs]);\n-            }\n-            Unary { arg, op: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n-            Cast { source } => visitor.visit_expr(&visitor.thir()[source]),\n-            Use { source } => visitor.visit_expr(&visitor.thir()[source]),\n-            NeverToAny { source } => visitor.visit_expr(&visitor.thir()[source]),\n-            Pointer { source, cast: _ } => visitor.visit_expr(&visitor.thir()[source]),\n-            Let { expr, .. } => {\n-                visitor.visit_expr(&visitor.thir()[expr]);\n-            }\n-            Loop { body } => visitor.visit_expr(&visitor.thir()[body]),\n-            Match { scrutinee, ref arms } => {\n-                visitor.visit_expr(&visitor.thir()[scrutinee]);\n-                for &arm in &**arms {\n-                    visitor.visit_arm(&visitor.thir()[arm]);\n-                }\n-            }\n-            Block { ref body } => visitor.visit_block(body),\n-            Assign { lhs, rhs } | AssignOp { lhs, rhs, op: _ } => {\n-                visitor.visit_expr(&visitor.thir()[lhs]);\n-                visitor.visit_expr(&visitor.thir()[rhs]);\n-            }\n-            Field { lhs, name: _ } => visitor.visit_expr(&visitor.thir()[lhs]),\n-            Index { lhs, index } => {\n-                visitor.visit_expr(&visitor.thir()[lhs]);\n-                visitor.visit_expr(&visitor.thir()[index]);\n-            }\n-            VarRef { id: _ } | UpvarRef { closure_def_id: _, var_hir_id: _ } => {}\n-            Borrow { arg, borrow_kind: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n-            AddressOf { arg, mutability: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n-            Break { value, label: _ } => {\n-                if let Some(value) = value {\n-                    visitor.visit_expr(&visitor.thir()[value])\n-                }\n-            }\n-            Continue { label: _ } => {}\n-            Return { value } => {\n-                if let Some(value) = value {\n-                    visitor.visit_expr(&visitor.thir()[value])\n-                }\n-            }\n-            ConstBlock { value } => visitor.visit_const(value),\n-            Repeat { value, count } => {\n-                visitor.visit_expr(&visitor.thir()[value]);\n-                visitor.visit_const(count);\n-            }\n-            Array { ref fields } | Tuple { ref fields } => {\n-                for &field in &**fields {\n-                    visitor.visit_expr(&visitor.thir()[field]);\n-                }\n-            }\n-            Adt(box crate::thir::Adt {\n-                ref fields,\n-                ref base,\n-                adt_def: _,\n-                variant_index: _,\n-                substs: _,\n-                user_ty: _,\n-            }) => {\n-                for field in &**fields {\n-                    visitor.visit_expr(&visitor.thir()[field.expr]);\n-                }\n-                if let Some(base) = base {\n-                    visitor.visit_expr(&visitor.thir()[base.base]);\n-                }\n-            }\n-            PlaceTypeAscription { source, user_ty: _ }\n-            | ValueTypeAscription { source, user_ty: _ } => {\n-                visitor.visit_expr(&visitor.thir()[source])\n-            }\n-            Closure { closure_id: _, substs: _, upvars: _, movability: _, fake_reads: _ } => {}\n-            Literal { literal, user_ty: _, const_id: _ } => visitor.visit_const(literal),\n-            StaticRef { literal, def_id: _ } => visitor.visit_const(literal),\n-            InlineAsm { ref operands, template: _, options: _, line_spans: _ } => {\n-                for op in &**operands {\n-                    use InlineAsmOperand::*;\n-                    match op {\n-                        In { expr, reg: _ }\n-                        | Out { expr: Some(expr), reg: _, late: _ }\n-                        | InOut { expr, reg: _, late: _ }\n-                        | SymFn { expr } => visitor.visit_expr(&visitor.thir()[*expr]),\n-                        SplitInOut { in_expr, out_expr, reg: _, late: _ } => {\n-                            visitor.visit_expr(&visitor.thir()[*in_expr]);\n-                            if let Some(out_expr) = out_expr {\n-                                visitor.visit_expr(&visitor.thir()[*out_expr]);\n-                            }\n-                        }\n-                        Out { expr: None, reg: _, late: _ }\n-                        | Const { value: _, span: _ }\n-                        | SymStatic { def_id: _ } => {}\n-                    }\n-                }\n-            }\n-            ThreadLocalRef(_) => {}\n-            LlvmInlineAsm { ref outputs, ref inputs, asm: _ } => {\n-                for &out_expr in &**outputs {\n-                    visitor.visit_expr(&visitor.thir()[out_expr]);\n-                }\n-                for &in_expr in &**inputs {\n-                    visitor.visit_expr(&visitor.thir()[in_expr]);\n-                }\n-            }\n-            Yield { value } => visitor.visit_expr(&visitor.thir()[value]),\n-        }\n-    }\n-\n-    pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stmt<'tcx>) {\n-        match &stmt.kind {\n-            StmtKind::Expr { expr, scope: _ } => visitor.visit_expr(&visitor.thir()[*expr]),\n-            StmtKind::Let {\n-                initializer,\n-                remainder_scope: _,\n-                init_scope: _,\n-                ref pattern,\n-                lint_level: _,\n-            } => {\n-                if let Some(init) = initializer {\n-                    visitor.visit_expr(&visitor.thir()[*init]);\n-                }\n-                visitor.visit_pat(pattern);\n-            }\n-        }\n-    }\n-\n-    pub fn walk_block<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, block: &Block) {\n-        for &stmt in &*block.stmts {\n-            visitor.visit_stmt(&visitor.thir()[stmt]);\n-        }\n-        if let Some(expr) = block.expr {\n-            visitor.visit_expr(&visitor.thir()[expr]);\n-        }\n-    }\n-\n-    pub fn walk_arm<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, arm: &Arm<'tcx>) {\n-        match arm.guard {\n-            Some(Guard::If(expr)) => visitor.visit_expr(&visitor.thir()[expr]),\n-            Some(Guard::IfLet(ref pat, expr)) => {\n-                visitor.visit_pat(pat);\n-                visitor.visit_expr(&visitor.thir()[expr]);\n-            }\n-            None => {}\n-        }\n-        visitor.visit_pat(&arm.pattern);\n-        visitor.visit_expr(&visitor.thir()[arm.body]);\n-    }\n-\n-    pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'tcx>) {\n-        use PatKind::*;\n-        match pat.kind.as_ref() {\n-            AscribeUserType { subpattern, ascription: _ }\n-            | Deref { subpattern }\n-            | Binding {\n-                subpattern: Some(subpattern),\n-                mutability: _,\n-                mode: _,\n-                var: _,\n-                ty: _,\n-                is_primary: _,\n-                name: _,\n-            } => visitor.visit_pat(&subpattern),\n-            Binding { .. } | Wild => {}\n-            Variant { subpatterns, adt_def: _, substs: _, variant_index: _ }\n-            | Leaf { subpatterns } => {\n-                for subpattern in subpatterns {\n-                    visitor.visit_pat(&subpattern.pattern);\n-                }\n-            }\n-            Constant { value } => visitor.visit_const(value),\n-            Range(range) => {\n-                visitor.visit_const(range.lo);\n-                visitor.visit_const(range.hi);\n-            }\n-            Slice { prefix, slice, suffix } | Array { prefix, slice, suffix } => {\n-                for subpattern in prefix {\n-                    visitor.visit_pat(&subpattern);\n-                }\n-                if let Some(pat) = slice {\n-                    visitor.visit_pat(pat);\n-                }\n-                for subpattern in suffix {\n-                    visitor.visit_pat(&subpattern);\n-                }\n-            }\n-            Or { pats } => {\n-                for pat in pats {\n-                    visitor.visit_pat(&pat);\n-                }\n-            }\n-        };\n-    }\n-}"}, {"sha": "27849e4bdb0bf96014feeafeae44726286b97b39", "filename": "compiler/rustc_middle/src/thir/abstract_const.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "previous_filename": "compiler/rustc_middle/src/mir/abstract_const.rs"}, {"sha": "21826ac89d3a91c72b88b71f0c4dab05c663c5f7", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -0,0 +1,238 @@\n+use super::*;\n+pub trait Visitor<'a, 'tcx: 'a>: Sized {\n+    fn thir(&self) -> &'a Thir<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &Expr<'tcx>) {\n+        walk_expr(self, expr);\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &Stmt<'tcx>) {\n+        walk_stmt(self, stmt);\n+    }\n+\n+    fn visit_block(&mut self, block: &Block) {\n+        walk_block(self, block);\n+    }\n+\n+    fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n+        walk_arm(self, arm);\n+    }\n+\n+    fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n+        walk_pat(self, pat);\n+    }\n+\n+    fn visit_const(&mut self, _cnst: &'tcx Const<'tcx>) {}\n+}\n+\n+pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {\n+    use ExprKind::*;\n+    match expr.kind {\n+        Scope { value, region_scope: _, lint_level: _ } => {\n+            visitor.visit_expr(&visitor.thir()[value])\n+        }\n+        Box { value } => visitor.visit_expr(&visitor.thir()[value]),\n+        If { cond, then, else_opt, if_then_scope: _ } => {\n+            visitor.visit_expr(&visitor.thir()[cond]);\n+            visitor.visit_expr(&visitor.thir()[then]);\n+            if let Some(else_expr) = else_opt {\n+                visitor.visit_expr(&visitor.thir()[else_expr]);\n+            }\n+        }\n+        Call { fun, ref args, ty: _, from_hir_call: _, fn_span: _ } => {\n+            visitor.visit_expr(&visitor.thir()[fun]);\n+            for &arg in &**args {\n+                visitor.visit_expr(&visitor.thir()[arg]);\n+            }\n+        }\n+        Deref { arg } => visitor.visit_expr(&visitor.thir()[arg]),\n+        Binary { lhs, rhs, op: _ } | LogicalOp { lhs, rhs, op: _ } => {\n+            visitor.visit_expr(&visitor.thir()[lhs]);\n+            visitor.visit_expr(&visitor.thir()[rhs]);\n+        }\n+        Unary { arg, op: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n+        Cast { source } => visitor.visit_expr(&visitor.thir()[source]),\n+        Use { source } => visitor.visit_expr(&visitor.thir()[source]),\n+        NeverToAny { source } => visitor.visit_expr(&visitor.thir()[source]),\n+        Pointer { source, cast: _ } => visitor.visit_expr(&visitor.thir()[source]),\n+        Let { expr, .. } => {\n+            visitor.visit_expr(&visitor.thir()[expr]);\n+        }\n+        Loop { body } => visitor.visit_expr(&visitor.thir()[body]),\n+        Match { scrutinee, ref arms } => {\n+            visitor.visit_expr(&visitor.thir()[scrutinee]);\n+            for &arm in &**arms {\n+                visitor.visit_arm(&visitor.thir()[arm]);\n+            }\n+        }\n+        Block { ref body } => visitor.visit_block(body),\n+        Assign { lhs, rhs } | AssignOp { lhs, rhs, op: _ } => {\n+            visitor.visit_expr(&visitor.thir()[lhs]);\n+            visitor.visit_expr(&visitor.thir()[rhs]);\n+        }\n+        Field { lhs, name: _ } => visitor.visit_expr(&visitor.thir()[lhs]),\n+        Index { lhs, index } => {\n+            visitor.visit_expr(&visitor.thir()[lhs]);\n+            visitor.visit_expr(&visitor.thir()[index]);\n+        }\n+        VarRef { id: _ } | UpvarRef { closure_def_id: _, var_hir_id: _ } => {}\n+        Borrow { arg, borrow_kind: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n+        AddressOf { arg, mutability: _ } => visitor.visit_expr(&visitor.thir()[arg]),\n+        Break { value, label: _ } => {\n+            if let Some(value) = value {\n+                visitor.visit_expr(&visitor.thir()[value])\n+            }\n+        }\n+        Continue { label: _ } => {}\n+        Return { value } => {\n+            if let Some(value) = value {\n+                visitor.visit_expr(&visitor.thir()[value])\n+            }\n+        }\n+        ConstBlock { value } => visitor.visit_const(value),\n+        Repeat { value, count } => {\n+            visitor.visit_expr(&visitor.thir()[value]);\n+            visitor.visit_const(count);\n+        }\n+        Array { ref fields } | Tuple { ref fields } => {\n+            for &field in &**fields {\n+                visitor.visit_expr(&visitor.thir()[field]);\n+            }\n+        }\n+        Adt(box crate::thir::Adt {\n+            ref fields,\n+            ref base,\n+            adt_def: _,\n+            variant_index: _,\n+            substs: _,\n+            user_ty: _,\n+        }) => {\n+            for field in &**fields {\n+                visitor.visit_expr(&visitor.thir()[field.expr]);\n+            }\n+            if let Some(base) = base {\n+                visitor.visit_expr(&visitor.thir()[base.base]);\n+            }\n+        }\n+        PlaceTypeAscription { source, user_ty: _ } | ValueTypeAscription { source, user_ty: _ } => {\n+            visitor.visit_expr(&visitor.thir()[source])\n+        }\n+        Closure { closure_id: _, substs: _, upvars: _, movability: _, fake_reads: _ } => {}\n+        Literal { literal, user_ty: _, const_id: _ } => visitor.visit_const(literal),\n+        StaticRef { literal, def_id: _ } => visitor.visit_const(literal),\n+        InlineAsm { ref operands, template: _, options: _, line_spans: _ } => {\n+            for op in &**operands {\n+                use InlineAsmOperand::*;\n+                match op {\n+                    In { expr, reg: _ }\n+                    | Out { expr: Some(expr), reg: _, late: _ }\n+                    | InOut { expr, reg: _, late: _ }\n+                    | SymFn { expr } => visitor.visit_expr(&visitor.thir()[*expr]),\n+                    SplitInOut { in_expr, out_expr, reg: _, late: _ } => {\n+                        visitor.visit_expr(&visitor.thir()[*in_expr]);\n+                        if let Some(out_expr) = out_expr {\n+                            visitor.visit_expr(&visitor.thir()[*out_expr]);\n+                        }\n+                    }\n+                    Out { expr: None, reg: _, late: _ }\n+                    | Const { value: _, span: _ }\n+                    | SymStatic { def_id: _ } => {}\n+                }\n+            }\n+        }\n+        ThreadLocalRef(_) => {}\n+        LlvmInlineAsm { ref outputs, ref inputs, asm: _ } => {\n+            for &out_expr in &**outputs {\n+                visitor.visit_expr(&visitor.thir()[out_expr]);\n+            }\n+            for &in_expr in &**inputs {\n+                visitor.visit_expr(&visitor.thir()[in_expr]);\n+            }\n+        }\n+        Yield { value } => visitor.visit_expr(&visitor.thir()[value]),\n+    }\n+}\n+\n+pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stmt<'tcx>) {\n+    match &stmt.kind {\n+        StmtKind::Expr { expr, scope: _ } => visitor.visit_expr(&visitor.thir()[*expr]),\n+        StmtKind::Let {\n+            initializer,\n+            remainder_scope: _,\n+            init_scope: _,\n+            ref pattern,\n+            lint_level: _,\n+        } => {\n+            if let Some(init) = initializer {\n+                visitor.visit_expr(&visitor.thir()[*init]);\n+            }\n+            visitor.visit_pat(pattern);\n+        }\n+    }\n+}\n+\n+pub fn walk_block<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, block: &Block) {\n+    for &stmt in &*block.stmts {\n+        visitor.visit_stmt(&visitor.thir()[stmt]);\n+    }\n+    if let Some(expr) = block.expr {\n+        visitor.visit_expr(&visitor.thir()[expr]);\n+    }\n+}\n+\n+pub fn walk_arm<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, arm: &Arm<'tcx>) {\n+    match arm.guard {\n+        Some(Guard::If(expr)) => visitor.visit_expr(&visitor.thir()[expr]),\n+        Some(Guard::IfLet(ref pat, expr)) => {\n+            visitor.visit_pat(pat);\n+            visitor.visit_expr(&visitor.thir()[expr]);\n+        }\n+        None => {}\n+    }\n+    visitor.visit_pat(&arm.pattern);\n+    visitor.visit_expr(&visitor.thir()[arm.body]);\n+}\n+\n+pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'tcx>) {\n+    use PatKind::*;\n+    match pat.kind.as_ref() {\n+        AscribeUserType { subpattern, ascription: _ }\n+        | Deref { subpattern }\n+        | Binding {\n+            subpattern: Some(subpattern),\n+            mutability: _,\n+            mode: _,\n+            var: _,\n+            ty: _,\n+            is_primary: _,\n+            name: _,\n+        } => visitor.visit_pat(&subpattern),\n+        Binding { .. } | Wild => {}\n+        Variant { subpatterns, adt_def: _, substs: _, variant_index: _ } | Leaf { subpatterns } => {\n+            for subpattern in subpatterns {\n+                visitor.visit_pat(&subpattern.pattern);\n+            }\n+        }\n+        Constant { value } => visitor.visit_const(value),\n+        Range(range) => {\n+            visitor.visit_const(range.lo);\n+            visitor.visit_const(range.hi);\n+        }\n+        Slice { prefix, slice, suffix } | Array { prefix, slice, suffix } => {\n+            for subpattern in prefix {\n+                visitor.visit_pat(&subpattern);\n+            }\n+            if let Some(pat) = slice {\n+                visitor.visit_pat(pat);\n+            }\n+            for subpattern in suffix {\n+                visitor.visit_pat(&subpattern);\n+            }\n+        }\n+        Or { pats } => {\n+            for pat in pats {\n+                visitor.visit_pat(&pat);\n+            }\n+        }\n+    };\n+}"}, {"sha": "e21a2d1034cdd3e923e8bba1838fc515dca6832a", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -9,7 +9,7 @@ pub mod specialization_graph;\n mod structural_impls;\n \n use crate::infer::canonical::Canonical;\n-use crate::mir::abstract_const::NotConstEvaluatable;\n+use crate::thir::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n "}, {"sha": "8b70692960df9374645d95e5ab188486c04a26db", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -12,6 +12,7 @@ use crate::mir::{\n     self,\n     interpret::{AllocId, Allocation},\n };\n+use crate::thir;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, List, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n@@ -362,7 +363,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>,\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::Node<'tcx>] {\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::Node<'tcx>] {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         Ok(decoder.tcx().arena.alloc_from_iter(\n             (0..decoder.read_usize()?)\n@@ -372,7 +373,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::N\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::NodeId] {\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::NodeId] {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         Ok(decoder.tcx().arena.alloc_from_iter(\n             (0..decoder.read_usize()?)"}, {"sha": "0ee740a6463593de96e159b1ffd434919aaa75d8", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -48,11 +48,11 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     match def {\n         ty::WithOptConstParam { did, const_param_did: Some(const_param_did) } => {\n             tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did));\n-            tcx.ensure().mir_abstract_const_of_const_arg((did, const_param_did));\n+            tcx.ensure().thir_abstract_const_of_const_arg((did, const_param_did));\n         }\n         ty::WithOptConstParam { did, const_param_did: None } => {\n             tcx.ensure().thir_check_unsafety(did);\n-            tcx.ensure().mir_abstract_const(did);\n+            tcx.ensure().thir_abstract_const(did);\n         }\n     }\n "}, {"sha": "20232e635a2b88621926bc1ff608693c104e61f5", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -307,7 +307,6 @@ fn mir_promoted(\n     // this point, before we steal the mir-const result.\n     // Also this means promotion can rely on all const checks having been done.\n     let _ = tcx.mir_const_qualif_opt_const_arg(def);\n-    let _ = tcx.mir_abstract_const_opt_const_arg(def.to_global());\n     let mut body = tcx.mir_const(def).steal();\n \n     let mut required_consts = Vec::new();"}, {"sha": "4dcb98ae7e960352355163a08e32233411b893e8", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -19,8 +19,8 @@ use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc_middle::mir::abstract_const::Node as ACNode;\n use rustc_middle::span_bug;\n+use rustc_middle::thir::abstract_const::Node as ACNode;\n use rustc_middle::ty::fold::TypeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{InternalSubsts, Subst};"}, {"sha": "2903e220b3b070197d65c6bbb2c2cc3a3dfd9057", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -9,6 +9,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret};\n+use rustc_middle::thir;\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n@@ -906,7 +907,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         RefDecodable::decode(d)\n     }"}, {"sha": "8c2a3d4abf41b5ab759f3e54cfbdc84f253e827c", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -6,17 +6,17 @@\n //! this is not as easy.\n //!\n //! In this case we try to build an abstract representation of this constant using\n-//! `mir_abstract_const` which can then be checked for structural equality with other\n+//! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir;\n-use rustc_middle::mir::abstract_const::{Node, NodeId, NotConstEvaluatable};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir;\n+use rustc_middle::thir::abstract_const::{Node, NodeId, NotConstEvaluatable};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n@@ -197,7 +197,7 @@ impl<'tcx> AbstractConst<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         uv: ty::Unevaluated<'tcx, ()>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n-        let inner = tcx.mir_abstract_const_opt_const_arg(uv.def)?;\n+        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n         debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n         Ok(inner.map(|inner| AbstractConst { inner, substs: uv.substs(tcx) }))\n     }\n@@ -421,10 +421,10 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n }\n \n /// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n-pub(super) fn mir_abstract_const<'tcx>(\n+pub(super) fn thir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n     if tcx.features().generic_const_exprs {\n         match tcx.def_kind(def.did) {\n             // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n@@ -435,7 +435,7 @@ pub(super) fn mir_abstract_const<'tcx>(\n             DefKind::AnonConst => (),\n             _ => return Ok(None),\n         }\n-        \n+\n         let body = tcx.thir_body(def);\n         if body.0.borrow().exprs.is_empty() {\n             // type error in constant, there is no thir"}, {"sha": "4d3a8324d798714787c688c3b42083fe131d9b13", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -19,7 +19,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::{"}, {"sha": "b376f4292924963574d690c85d6426119479fa89", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -5,8 +5,8 @@ use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProce\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitEngineExt as _, TraitObligation};\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ToPredicate;"}, {"sha": "ef208c44471cbadf52d2b5dcdea6af83fc019092", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -827,16 +827,16 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_entries,\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n-        mir_abstract_const: |tcx, def_id| {\n+        thir_abstract_const: |tcx, def_id| {\n             let def_id = def_id.expect_local();\n             if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.mir_abstract_const_of_const_arg(def)\n+                tcx.thir_abstract_const_of_const_arg(def)\n             } else {\n-                const_evaluatable::mir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n+                const_evaluatable::thir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n             }\n         },\n-        mir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n-            const_evaluatable::mir_abstract_const(\n+        thir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n+            const_evaluatable::thir_abstract_const(\n                 tcx,\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )"}, {"sha": "e001bb7445e8cb911883735eda9977eb0db0e569", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -836,7 +836,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             //\n             // This shouldn't really matter though as we can't really use any\n             // constants which are not considered const evaluatable.\n-            use rustc_middle::mir::abstract_const::Node;\n+            use rustc_middle::thir::abstract_const::Node;\n             if let Ok(Some(ct)) = AbstractConst::new(self.tcx, uv.shrink()) {\n                 const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node.root() {\n                     Node::Leaf(leaf) => {"}, {"sha": "01a38ffa7d0b2344c742d14b441d89b7815eb8eb", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406d2ab95de0e90f45e00f6c1be1e4e7912aa153/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=406d2ab95de0e90f45e00f6c1be1e4e7912aa153", "patch": "@@ -34,8 +34,8 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;"}]}