{"sha": "d0d2786d2d999e18b64aa6f1b455612d5245e21e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZDI3ODZkMmQ5OTllMThiNjRhYTZmMWI0NTU2MTJkNTI0NWUyMWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-26T13:08:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-26T13:08:35Z"}, "message": "Merge #7433\n\n7433: Support Macro v2 in mbe r=jonas-schievink a=edwin0cheng\n\nAdded `mbe::MacroDef` for Macro v2.\r\n\r\ncc @jonas-schievink \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "4e43f2745f1dc56df6f5da4862f01acc6c14e2ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e43f2745f1dc56df6f5da4862f01acc6c14e2ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0d2786d2d999e18b64aa6f1b455612d5245e21e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgEBRTCRBK7hj4Ov3rIwAAdHIIAJlyohfC4md/yzKZzgA5OmE8\nDBCGl6wgZBxOOgVGHDiLKp5JxKiIo8uw8CXDGEPZqB3emWTPyzmidYf0erjGsVEB\n45BYStARCvJHVJpoFpFjdhR4JWt3uZCJldgAkvYIaq5X2lTwOrnd2kV1x5X9Gp5i\nsRrd3k64kWDmw326p4a/i1ZOtmwh//FDCtFtDk14GIagZ6Nt5Ro03DbCXLLzVZMZ\n6r0XCHvtvmED/taiCoXLAlD0zoxJaHVvJ8cMk1Lh1/7MOLSc1aBgJorsW/Tz80T4\nhuadgxpvpFSi8B0B/Ktj2m8dhctBUzxySDvLqC+xnIHiJR+I3d4RfZJZPyW1oK4=\n=tFP2\n-----END PGP SIGNATURE-----\n", "payload": "tree 4e43f2745f1dc56df6f5da4862f01acc6c14e2ec\nparent 19dc5195d01f184b0526ad0c9cd7f3b7f65c894b\nparent ce4eeec1bf805bd0be95651d38f95340c5b8848a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1611666515 +0000\ncommitter GitHub <noreply@github.com> 1611666515 +0000\n\nMerge #7433\n\n7433: Support Macro v2 in mbe r=jonas-schievink a=edwin0cheng\n\nAdded `mbe::MacroDef` for Macro v2.\r\n\r\ncc @jonas-schievink \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d2786d2d999e18b64aa6f1b455612d5245e21e", "html_url": "https://github.com/rust-lang/rust/commit/d0d2786d2d999e18b64aa6f1b455612d5245e21e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0d2786d2d999e18b64aa6f1b455612d5245e21e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19dc5195d01f184b0526ad0c9cd7f3b7f65c894b", "url": "https://api.github.com/repos/rust-lang/rust/commits/19dc5195d01f184b0526ad0c9cd7f3b7f65c894b", "html_url": "https://github.com/rust-lang/rust/commit/19dc5195d01f184b0526ad0c9cd7f3b7f65c894b"}, {"sha": "ce4eeec1bf805bd0be95651d38f95340c5b8848a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4eeec1bf805bd0be95651d38f95340c5b8848a", "html_url": "https://github.com/rust-lang/rust/commit/ce4eeec1bf805bd0be95651d38f95340c5b8848a"}], "stats": {"total": 317, "additions": 228, "deletions": 89}, "files": [{"sha": "43bc10490f1235360cf538ca37d3af7ec22e894f", "filename": "crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0d2786d2d999e18b64aa6f1b455612d5245e21e/crates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d0d2786d2d999e18b64aa6f1b455612d5245e21e/crates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2FCargo.toml?ref=d0d2786d2d999e18b64aa6f1b455612d5245e21e", "patch": "@@ -17,6 +17,5 @@ log = \"0.4.8\"\n syntax = { path = \"../syntax\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }\n tt = { path = \"../tt\", version = \"0.0.0\" }\n-\n-[dev-dependencies]\n test_utils = { path = \"../test_utils\" }\n+"}, {"sha": "35cde5f10cc9cca5c84d0a893cb8e1cc4c05797c", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d0d2786d2d999e18b64aa6f1b455612d5245e21e/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d2786d2d999e18b64aa6f1b455612d5245e21e/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=d0d2786d2d999e18b64aa6f1b455612d5245e21e", "patch": "@@ -14,6 +14,7 @@ mod tests;\n \n use std::fmt;\n \n+use test_utils::mark;\n pub use tt::{Delimiter, DelimiterKind, Punct};\n \n use crate::{\n@@ -76,6 +77,14 @@ pub struct MacroRules {\n     shift: Shift,\n }\n \n+/// For Macro 2.0\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct MacroDef {\n+    rules: Vec<Rule>,\n+    /// Highest id of the token we have in TokenMap\n+    shift: Shift,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n struct Rule {\n     lhs: MetaTemplate,\n@@ -179,7 +188,7 @@ impl MacroRules {\n         let mut src = TtIter::new(tt);\n         let mut rules = Vec::new();\n         while src.len() > 0 {\n-            let rule = Rule::parse(&mut src)?;\n+            let rule = Rule::parse(&mut src, true)?;\n             rules.push(rule);\n             if let Err(()) = src.expect_char(';') {\n                 if src.len() > 0 {\n@@ -200,7 +209,58 @@ impl MacroRules {\n         // apply shift\n         let mut tt = tt.clone();\n         self.shift.shift_all(&mut tt);\n-        mbe_expander::expand(self, &tt)\n+        mbe_expander::expand_rules(&self.rules, &tt)\n+    }\n+\n+    pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n+        self.shift.shift(id)\n+    }\n+\n+    pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, Origin) {\n+        match self.shift.unshift(id) {\n+            Some(id) => (id, Origin::Call),\n+            None => (id, Origin::Def),\n+        }\n+    }\n+}\n+\n+impl MacroDef {\n+    pub fn parse(tt: &tt::Subtree) -> Result<MacroDef, ParseError> {\n+        let mut src = TtIter::new(tt);\n+        let mut rules = Vec::new();\n+\n+        if Some(tt::DelimiterKind::Brace) == tt.delimiter_kind() {\n+            mark::hit!(parse_macro_def_rules);\n+            while src.len() > 0 {\n+                let rule = Rule::parse(&mut src, true)?;\n+                rules.push(rule);\n+                if let Err(()) = src.expect_char(';') {\n+                    if src.len() > 0 {\n+                        return Err(ParseError::Expected(\"expected `;`\".to_string()));\n+                    }\n+                    break;\n+                }\n+            }\n+        } else {\n+            mark::hit!(parse_macro_def_simple);\n+            let rule = Rule::parse(&mut src, false)?;\n+            if src.len() != 0 {\n+                return Err(ParseError::Expected(\"remain tokens in macro def\".to_string()));\n+            }\n+            rules.push(rule);\n+        }\n+        for rule in rules.iter() {\n+            validate(&rule.lhs)?;\n+        }\n+\n+        Ok(MacroDef { rules, shift: Shift::new(tt) })\n+    }\n+\n+    pub fn expand(&self, tt: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+        // apply shift\n+        let mut tt = tt.clone();\n+        self.shift.shift_all(&mut tt);\n+        mbe_expander::expand_rules(&self.rules, &tt)\n     }\n \n     pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n@@ -216,12 +276,14 @@ impl MacroRules {\n }\n \n impl Rule {\n-    fn parse(src: &mut TtIter) -> Result<Rule, ParseError> {\n+    fn parse(src: &mut TtIter, expect_arrow: bool) -> Result<Rule, ParseError> {\n         let lhs = src\n             .expect_subtree()\n             .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?;\n-        src.expect_char('=').map_err(|()| ParseError::Expected(\"expected `=`\".to_string()))?;\n-        src.expect_char('>').map_err(|()| ParseError::Expected(\"expected `>`\".to_string()))?;\n+        if expect_arrow {\n+            src.expect_char('=').map_err(|()| ParseError::Expected(\"expected `=`\".to_string()))?;\n+            src.expect_char('>').map_err(|()| ParseError::Expected(\"expected `>`\".to_string()))?;\n+        }\n         let rhs = src\n             .expect_subtree()\n             .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?;"}, {"sha": "802c8fb0ff9697ab292d3d459479558a653b7f6c", "filename": "crates/mbe/src/mbe_expander.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d0d2786d2d999e18b64aa6f1b455612d5245e21e/crates%2Fmbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d2786d2d999e18b64aa6f1b455612d5245e21e/crates%2Fmbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander.rs?ref=d0d2786d2d999e18b64aa6f1b455612d5245e21e", "patch": "@@ -10,11 +10,10 @@ use syntax::SmolStr;\n \n use crate::{ExpandError, ExpandResult};\n \n-pub(crate) fn expand(rules: &crate::MacroRules, input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n-    expand_rules(&rules.rules, input)\n-}\n-\n-fn expand_rules(rules: &[crate::Rule], input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+pub(crate) fn expand_rules(\n+    rules: &[crate::Rule],\n+    input: &tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n     let mut match_: Option<(matcher::Match, &crate::Rule)> = None;\n     for rule in rules {\n         let new_match = match matcher::match_(&rule.lhs, input) {"}, {"sha": "8d978163d6fadc5acf5cda0f242c66ed9cd0c92d", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 156, "deletions": 77, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/d0d2786d2d999e18b64aa6f1b455612d5245e21e/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d2786d2d999e18b64aa6f1b455612d5245e21e/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=d0d2786d2d999e18b64aa6f1b455612d5245e21e", "patch": "@@ -6,7 +6,7 @@ use syntax::{\n     SyntaxKind::{ERROR, IDENT},\n     SyntaxNode, WalkEvent, T,\n };\n-use test_utils::assert_eq_text;\n+use test_utils::{assert_eq_text, mark};\n \n use super::*;\n \n@@ -675,6 +675,36 @@ fn test_match_literal() {\n     .assert_expand_items(\"foo! ['('];\", \"fn foo () {}\");\n }\n \n+#[test]\n+fn test_parse_macro_def_simple() {\n+    mark::check!(parse_macro_def_simple);\n+\n+    parse_macro2(\n+        r#\"\n+macro foo($id:ident) {\n+    fn $id() {}\n+}\n+\"#,\n+    )\n+    .assert_expand_items(\"foo!(bar);\", \"fn bar () {}\");\n+}\n+\n+#[test]\n+fn test_parse_macro_def_rules() {\n+    mark::check!(parse_macro_def_rules);\n+\n+    parse_macro2(\n+        r#\"\n+macro foo {\n+    ($id:ident) => {\n+        fn $id() {}\n+    }\n+}\n+\"#,\n+    )\n+    .assert_expand_items(\"foo!(bar);\", \"fn bar () {}\");\n+}\n+\n // The following tests are port from intellij-rust directly\n // https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n \n@@ -1699,95 +1729,122 @@ pub(crate) struct MacroFixture {\n     rules: MacroRules,\n }\n \n-impl MacroFixture {\n-    pub(crate) fn expand_tt(&self, invocation: &str) -> tt::Subtree {\n-        self.try_expand_tt(invocation).unwrap()\n-    }\n-\n-    fn try_expand_tt(&self, invocation: &str) -> Result<tt::Subtree, ExpandError> {\n-        let source_file = ast::SourceFile::parse(invocation).tree();\n-        let macro_invocation =\n-            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-        let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap())\n-            .ok_or_else(|| ExpandError::ConversionError)?;\n+pub(crate) struct MacroFixture2 {\n+    rules: MacroDef,\n+}\n \n-        self.rules.expand(&invocation_tt).result()\n-    }\n+macro_rules! impl_fixture {\n+    ($name:ident) => {\n+        impl $name {\n+            pub(crate) fn expand_tt(&self, invocation: &str) -> tt::Subtree {\n+                self.try_expand_tt(invocation).unwrap()\n+            }\n \n-    fn assert_expand_err(&self, invocation: &str, err: &ExpandError) {\n-        assert_eq!(self.try_expand_tt(invocation).as_ref(), Err(err));\n-    }\n+            fn try_expand_tt(&self, invocation: &str) -> Result<tt::Subtree, ExpandError> {\n+                let source_file = ast::SourceFile::parse(invocation).tree();\n+                let macro_invocation =\n+                    source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-    fn expand_items(&self, invocation: &str) -> SyntaxNode {\n-        let expanded = self.expand_tt(invocation);\n-        token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node()\n-    }\n+                let (invocation_tt, _) = ast_to_token_tree(&macro_invocation.token_tree().unwrap())\n+                    .ok_or_else(|| ExpandError::ConversionError)?;\n \n-    fn expand_statements(&self, invocation: &str) -> SyntaxNode {\n-        let expanded = self.expand_tt(invocation);\n-        token_tree_to_syntax_node(&expanded, FragmentKind::Statements).unwrap().0.syntax_node()\n-    }\n+                self.rules.expand(&invocation_tt).result()\n+            }\n \n-    fn expand_expr(&self, invocation: &str) -> SyntaxNode {\n-        let expanded = self.expand_tt(invocation);\n-        token_tree_to_syntax_node(&expanded, FragmentKind::Expr).unwrap().0.syntax_node()\n-    }\n+            #[allow(unused)]\n+            fn assert_expand_err(&self, invocation: &str, err: &ExpandError) {\n+                assert_eq!(self.try_expand_tt(invocation).as_ref(), Err(err));\n+            }\n \n-    fn assert_expand_tt(&self, invocation: &str, expected: &str) {\n-        let expansion = self.expand_tt(invocation);\n-        assert_eq!(expansion.to_string(), expected);\n-    }\n+            #[allow(unused)]\n+            fn expand_items(&self, invocation: &str) -> SyntaxNode {\n+                let expanded = self.expand_tt(invocation);\n+                token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node()\n+            }\n \n-    fn assert_expand(&self, invocation: &str, expected: &str) {\n-        let expansion = self.expand_tt(invocation);\n-        let actual = format!(\"{:?}\", expansion);\n-        test_utils::assert_eq_text!(&expected.trim(), &actual.trim());\n-    }\n+            #[allow(unused)]\n+            fn expand_statements(&self, invocation: &str) -> SyntaxNode {\n+                let expanded = self.expand_tt(invocation);\n+                token_tree_to_syntax_node(&expanded, FragmentKind::Statements)\n+                    .unwrap()\n+                    .0\n+                    .syntax_node()\n+            }\n \n-    fn assert_expand_items(&self, invocation: &str, expected: &str) -> &MacroFixture {\n-        self.assert_expansion(FragmentKind::Items, invocation, expected);\n-        self\n-    }\n+            #[allow(unused)]\n+            fn expand_expr(&self, invocation: &str) -> SyntaxNode {\n+                let expanded = self.expand_tt(invocation);\n+                token_tree_to_syntax_node(&expanded, FragmentKind::Expr).unwrap().0.syntax_node()\n+            }\n \n-    fn assert_expand_statements(&self, invocation: &str, expected: &str) -> &MacroFixture {\n-        self.assert_expansion(FragmentKind::Statements, invocation, expected);\n-        self\n-    }\n+            #[allow(unused)]\n+            fn assert_expand_tt(&self, invocation: &str, expected: &str) {\n+                let expansion = self.expand_tt(invocation);\n+                assert_eq!(expansion.to_string(), expected);\n+            }\n \n-    fn assert_expansion(&self, kind: FragmentKind, invocation: &str, expected: &str) {\n-        let expanded = self.expand_tt(invocation);\n-        assert_eq!(expanded.to_string(), expected);\n-\n-        let expected = expected.replace(\"$crate\", \"C_C__C\");\n-\n-        // wrap the given text to a macro call\n-        let expected = {\n-            let wrapped = format!(\"wrap_macro!( {} )\", expected);\n-            let wrapped = ast::SourceFile::parse(&wrapped);\n-            let wrapped =\n-                wrapped.tree().syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-            let mut wrapped = ast_to_token_tree(&wrapped).unwrap().0;\n-            wrapped.delimiter = None;\n-            wrapped\n-        };\n+            #[allow(unused)]\n+            fn assert_expand(&self, invocation: &str, expected: &str) {\n+                let expansion = self.expand_tt(invocation);\n+                let actual = format!(\"{:?}\", expansion);\n+                test_utils::assert_eq_text!(&expected.trim(), &actual.trim());\n+            }\n \n-        let expanded_tree = token_tree_to_syntax_node(&expanded, kind).unwrap().0.syntax_node();\n-        let expanded_tree = debug_dump_ignore_spaces(&expanded_tree).trim().to_string();\n+            fn assert_expand_items(&self, invocation: &str, expected: &str) -> &$name {\n+                self.assert_expansion(FragmentKind::Items, invocation, expected);\n+                self\n+            }\n \n-        let expected_tree = token_tree_to_syntax_node(&expected, kind).unwrap().0.syntax_node();\n-        let expected_tree = debug_dump_ignore_spaces(&expected_tree).trim().to_string();\n+            #[allow(unused)]\n+            fn assert_expand_statements(&self, invocation: &str, expected: &str) -> &$name {\n+                self.assert_expansion(FragmentKind::Statements, invocation, expected);\n+                self\n+            }\n \n-        let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n-        assert_eq!(\n-            expanded_tree, expected_tree,\n-            \"\\nleft:\\n{}\\nright:\\n{}\",\n-            expanded_tree, expected_tree,\n-        );\n-    }\n+            fn assert_expansion(&self, kind: FragmentKind, invocation: &str, expected: &str) {\n+                let expanded = self.expand_tt(invocation);\n+                assert_eq!(expanded.to_string(), expected);\n+\n+                let expected = expected.replace(\"$crate\", \"C_C__C\");\n+\n+                // wrap the given text to a macro call\n+                let expected = {\n+                    let wrapped = format!(\"wrap_macro!( {} )\", expected);\n+                    let wrapped = ast::SourceFile::parse(&wrapped);\n+                    let wrapped = wrapped\n+                        .tree()\n+                        .syntax()\n+                        .descendants()\n+                        .find_map(ast::TokenTree::cast)\n+                        .unwrap();\n+                    let mut wrapped = ast_to_token_tree(&wrapped).unwrap().0;\n+                    wrapped.delimiter = None;\n+                    wrapped\n+                };\n+\n+                let expanded_tree =\n+                    token_tree_to_syntax_node(&expanded, kind).unwrap().0.syntax_node();\n+                let expanded_tree = debug_dump_ignore_spaces(&expanded_tree).trim().to_string();\n+\n+                let expected_tree =\n+                    token_tree_to_syntax_node(&expected, kind).unwrap().0.syntax_node();\n+                let expected_tree = debug_dump_ignore_spaces(&expected_tree).trim().to_string();\n+\n+                let expected_tree = expected_tree.replace(\"C_C__C\", \"$crate\");\n+                assert_eq!(\n+                    expanded_tree, expected_tree,\n+                    \"\\nleft:\\n{}\\nright:\\n{}\",\n+                    expanded_tree, expected_tree,\n+                );\n+            }\n+        }\n+    };\n }\n \n-fn parse_macro_to_tt(ra_fixture: &str) -> tt::Subtree {\n+impl_fixture!(MacroFixture);\n+impl_fixture!(MacroFixture2);\n+\n+fn parse_macro_rules_to_tt(ra_fixture: &str) -> tt::Subtree {\n     let source_file = ast::SourceFile::parse(ra_fixture).ok().unwrap();\n     let macro_definition =\n         source_file.syntax().descendants().find_map(ast::MacroRules::cast).unwrap();\n@@ -1804,14 +1861,36 @@ fn parse_macro_to_tt(ra_fixture: &str) -> tt::Subtree {\n     definition_tt\n }\n \n+fn parse_macro_def_to_tt(ra_fixture: &str) -> tt::Subtree {\n+    let source_file = ast::SourceFile::parse(ra_fixture).ok().unwrap();\n+    let macro_definition =\n+        source_file.syntax().descendants().find_map(ast::MacroDef::cast).unwrap();\n+\n+    let (definition_tt, _) = ast_to_token_tree(&macro_definition.body().unwrap()).unwrap();\n+\n+    let parsed =\n+        parse_to_token_tree(&ra_fixture[macro_definition.body().unwrap().syntax().text_range()])\n+            .unwrap()\n+            .0;\n+    assert_eq!(definition_tt, parsed);\n+\n+    definition_tt\n+}\n+\n pub(crate) fn parse_macro(ra_fixture: &str) -> MacroFixture {\n-    let definition_tt = parse_macro_to_tt(ra_fixture);\n+    let definition_tt = parse_macro_rules_to_tt(ra_fixture);\n     let rules = MacroRules::parse(&definition_tt).unwrap();\n     MacroFixture { rules }\n }\n \n+pub(crate) fn parse_macro2(ra_fixture: &str) -> MacroFixture2 {\n+    let definition_tt = parse_macro_def_to_tt(ra_fixture);\n+    let rules = MacroDef::parse(&definition_tt).unwrap();\n+    MacroFixture2 { rules }\n+}\n+\n pub(crate) fn parse_macro_error(ra_fixture: &str) -> ParseError {\n-    let definition_tt = parse_macro_to_tt(ra_fixture);\n+    let definition_tt = parse_macro_rules_to_tt(ra_fixture);\n \n     match MacroRules::parse(&definition_tt) {\n         Ok(_) => panic!(\"Expect error\"),"}]}