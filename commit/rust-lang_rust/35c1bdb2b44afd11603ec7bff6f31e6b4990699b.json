{"sha": "35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YzFiZGIyYjQ0YWZkMTE2MDNlYzdiZmY2ZjMxZTZiNDk5MDY5OWI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-03-31T06:10:11Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-04-02T10:34:26Z"}, "message": "syntax: Rewrite parsing of patterns", "tree": {"sha": "89b2b417d9b8708ec33eac7676d64c28cba360ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89b2b417d9b8708ec33eac7676d64c28cba360ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "html_url": "https://github.com/rust-lang/rust/commit/35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e30f05a05326018357c6fffdfb872e8a8d2367c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e30f05a05326018357c6fffdfb872e8a8d2367c", "html_url": "https://github.com/rust-lang/rust/commit/5e30f05a05326018357c6fffdfb872e8a8d2367c"}], "stats": {"total": 370, "additions": 136, "deletions": 234}, "files": [{"sha": "cb7b93d2ef24b7c3c76a5bb2cdf457bde80152bc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 127, "deletions": 225, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -40,8 +40,8 @@ use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n use ast::{MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n-use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n-use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n+use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatMac, PatRange, PatRegion};\n+use ast::{PatStruct, PatTup, PatVec, PatWild, PatWildMulti, PatWildSingle};\n use ast::{PolyTraitRef, QSelf};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n@@ -86,12 +86,10 @@ bitflags! {\n     flags Restrictions: u8 {\n         const UNRESTRICTED                  = 0b0000,\n         const RESTRICTION_STMT_EXPR         = 0b0001,\n-        const RESTRICTION_NO_BAR_OP         = 0b0010,\n-        const RESTRICTION_NO_STRUCT_LITERAL = 0b0100,\n+        const RESTRICTION_NO_STRUCT_LITERAL = 0b0010,\n     }\n }\n \n-\n type ItemInfo = (Ident, Item_, Option<Vec<Attribute> >);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n@@ -2603,13 +2601,6 @@ impl<'a> Parser<'a> {\n     pub fn parse_more_binops(&mut self, lhs: P<Expr>, min_prec: usize) -> P<Expr> {\n         if self.expr_is_complete(&*lhs) { return lhs; }\n \n-        // Prevent dynamic borrow errors later on by limiting the\n-        // scope of the borrows.\n-        if self.token == token::BinOp(token::Or) &&\n-            self.restrictions.contains(RESTRICTION_NO_BAR_OP) {\n-            return lhs;\n-        }\n-\n         self.expected_tokens.push(TokenType::Operator);\n \n         let cur_op_span = self.span;\n@@ -2956,6 +2947,22 @@ impl<'a> Parser<'a> {\n         };\n     }\n \n+    fn parse_pat_tuple_elements(&mut self) -> Vec<P<Pat>> {\n+        let mut fields = vec![];\n+        if !self.check(&token::CloseDelim(token::Paren)) {\n+            fields.push(self.parse_pat());\n+            if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n+                while self.eat(&token::Comma) && !self.check(&token::CloseDelim(token::Paren)) {\n+                    fields.push(self.parse_pat());\n+                }\n+            }\n+            if fields.len() == 1 {\n+                self.expect(&token::Comma);\n+            }\n+        }\n+        fields\n+    }\n+\n     fn parse_pat_vec_elements(\n         &mut self,\n     ) -> (Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>) {\n@@ -3087,250 +3094,145 @@ impl<'a> Parser<'a> {\n         return (fields, etc);\n     }\n \n+    fn parse_pat_range_end(&mut self) -> P<Expr> {\n+        if self.is_path_start() {\n+            let lo = self.span.lo;\n+            let path = self.parse_path(LifetimeAndTypesWithColons);\n+            let hi = self.last_span.hi;\n+            self.mk_expr(lo, hi, ExprPath(None, path))\n+        } else {\n+            self.parse_literal_maybe_minus()\n+        }\n+    }\n+\n+    fn is_path_start(&self) -> bool {\n+        (self.token == token::ModSep || self.token.is_ident() || self.token.is_path())\n+            && !self.token.is_keyword(keywords::True) && !self.token.is_keyword(keywords::False)\n+    }\n+\n     /// Parse a pattern.\n     pub fn parse_pat(&mut self) -> P<Pat> {\n         maybe_whole!(self, NtPat);\n \n         let lo = self.span.lo;\n-        let mut hi;\n         let pat;\n         match self.token {\n-            // parse _\n           token::Underscore => {\n+            // Parse _\n             self.bump();\n             pat = PatWild(PatWildSingle);\n-            hi = self.last_span.hi;\n-            return P(ast::Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: pat,\n-                span: mk_sp(lo, hi)\n-            })\n           }\n           token::BinOp(token::And) | token::AndAnd => {\n-            // parse &pat and &mut pat\n-            let lo = self.span.lo;\n+            // Parse &pat / &mut pat\n             self.expect_and();\n-            let mutability = if self.eat_keyword(keywords::Mut) {\n-                ast::MutMutable\n-            } else {\n-                ast::MutImmutable\n-            };\n-            let sub = self.parse_pat();\n-            pat = PatRegion(sub, mutability);\n-            hi = self.last_span.hi;\n-            return P(ast::Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: pat,\n-                span: mk_sp(lo, hi)\n-            })\n+            let mutbl = self.parse_mutability();\n+            let subpat = self.parse_pat();\n+            pat = PatRegion(subpat, mutbl);\n           }\n           token::OpenDelim(token::Paren) => {\n-            // parse (pat,pat,pat,...) as tuple\n+            // Parse (pat,pat,pat,...) as tuple pattern\n             self.bump();\n-            if self.check(&token::CloseDelim(token::Paren)) {\n-                self.bump();\n-                pat = PatTup(vec![]);\n-            } else {\n-                let mut fields = vec!(self.parse_pat());\n-                if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n-                    while self.check(&token::Comma) {\n-                        self.bump();\n-                        if self.check(&token::CloseDelim(token::Paren)) { break; }\n-                        fields.push(self.parse_pat());\n-                    }\n-                }\n-                if fields.len() == 1 { self.expect(&token::Comma); }\n-                self.expect(&token::CloseDelim(token::Paren));\n-                pat = PatTup(fields);\n-            }\n-            hi = self.last_span.hi;\n-            return P(ast::Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: pat,\n-                span: mk_sp(lo, hi)\n-            })\n+            let fields = self.parse_pat_tuple_elements();\n+            self.expect(&token::CloseDelim(token::Paren));\n+            pat = PatTup(fields);\n           }\n           token::OpenDelim(token::Bracket) => {\n-            // parse [pat,pat,...] as vector pattern\n+            // Parse [pat,pat,...] as vector pattern\n             self.bump();\n-            let (before, slice, after) =\n-                self.parse_pat_vec_elements();\n-\n+            let (before, slice, after) = self.parse_pat_vec_elements();\n             self.expect(&token::CloseDelim(token::Bracket));\n-            pat = ast::PatVec(before, slice, after);\n-            hi = self.last_span.hi;\n-            return P(ast::Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: pat,\n-                span: mk_sp(lo, hi)\n-            })\n+            pat = PatVec(before, slice, after);\n           }\n-          _ => {}\n-        }\n-        // at this point, token != _, ~, &, &&, (, [\n-\n-        if (!(self.token.is_ident() || self.token.is_path())\n-              && self.token != token::ModSep)\n-                || self.token.is_keyword(keywords::True)\n-                || self.token.is_keyword(keywords::False) {\n-            // Parse an expression pattern or exp ... exp.\n-            //\n-            // These expressions are limited to literals (possibly\n-            // preceded by unary-minus) or identifiers.\n-            let val = self.parse_literal_maybe_minus();\n-            if (self.check(&token::DotDotDot)) &&\n-                    self.look_ahead(1, |t| {\n-                        *t != token::Comma && *t != token::CloseDelim(token::Bracket)\n-                    }) {\n-                self.bump();\n-                let end = if self.token.is_ident() || self.token.is_path() {\n-                    let path = self.parse_path(LifetimeAndTypesWithColons);\n-                    let hi = self.span.hi;\n-                    self.mk_expr(lo, hi, ExprPath(None, path))\n-                } else {\n-                    self.parse_literal_maybe_minus()\n-                };\n-                pat = PatRange(val, end);\n-            } else {\n-                pat = PatLit(val);\n-            }\n-        } else if self.eat_keyword(keywords::Mut) {\n-            pat = self.parse_pat_ident(BindByValue(MutMutable));\n-        } else if self.eat_keyword(keywords::Ref) {\n-            // parse ref pat\n-            let mutbl = self.parse_mutability();\n-            pat = self.parse_pat_ident(BindByRef(mutbl));\n-        } else if self.eat_keyword(keywords::Box) {\n-            // `box PAT`\n-            //\n-            // FIXME(#13910): Rename to `PatBox` and extend to full DST\n-            // support.\n-            let sub = self.parse_pat();\n-            pat = PatBox(sub);\n-            hi = self.last_span.hi;\n-            return P(ast::Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: pat,\n-                span: mk_sp(lo, hi)\n-            })\n-        } else {\n-            let can_be_enum_or_struct = self.look_ahead(1, |t| {\n-                match *t {\n-                    token::OpenDelim(_) | token::Lt | token::ModSep => true,\n-                    _ => false,\n-                }\n-            });\n-\n-            if self.look_ahead(1, |t| *t == token::DotDotDot) &&\n-                    self.look_ahead(2, |t| {\n-                        *t != token::Comma && *t != token::CloseDelim(token::Bracket)\n-                    }) {\n-                let start = self.parse_expr_res(RESTRICTION_NO_BAR_OP);\n-                self.eat(&token::DotDotDot);\n-                let end = self.parse_expr_res(RESTRICTION_NO_BAR_OP);\n-                pat = PatRange(start, end);\n-            } else if self.token.is_plain_ident() && !can_be_enum_or_struct {\n-                let id = self.parse_ident();\n-                let id_span = self.last_span;\n-                let pth1 = codemap::Spanned{span:id_span, node: id};\n-                if self.eat(&token::Not) {\n-                    // macro invocation\n-                    let delim = self.expect_open_delim();\n-                    let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                    seq_sep_none(),\n-                                                    |p| p.parse_token_tree());\n-\n-                    let mac = MacInvocTT(ident_to_path(id_span,id), tts, EMPTY_CTXT);\n-                    pat = ast::PatMac(codemap::Spanned {node: mac, span: self.span});\n-                } else {\n-                    let sub = if self.eat(&token::At) {\n-                        // parse foo @ pat\n-                        Some(self.parse_pat())\n-                    } else {\n-                        // or just foo\n-                        None\n-                    };\n-                    pat = PatIdent(BindByValue(MutImmutable), pth1, sub);\n-                }\n-            } else if self.look_ahead(1, |t| *t == token::Lt) {\n-                self.bump();\n-                self.unexpected()\n-            } else {\n-                // parse an enum pat\n-                let enum_path = self.parse_path(LifetimeAndTypesWithColons);\n-                match self.token {\n-                    token::OpenDelim(token::Brace) => {\n-                        self.bump();\n-                        let (fields, etc) =\n-                            self.parse_pat_fields();\n+          _ => {\n+            // At this point, token != _, &, &&, (, [\n+            if self.eat_keyword(keywords::Mut) {\n+                // Parse mut ident @ pat\n+                pat = self.parse_pat_ident(BindByValue(MutMutable));\n+            } else if self.eat_keyword(keywords::Ref) {\n+                // Parse ref ident @ pat / ref mut ident @ pat\n+                let mutbl = self.parse_mutability();\n+                pat = self.parse_pat_ident(BindByRef(mutbl));\n+            } else if self.eat_keyword(keywords::Box) {\n+                // Parse box pat\n+                let subpat = self.parse_pat();\n+                pat = PatBox(subpat);\n+            } else if self.is_path_start() {\n+                // Parse pattern starting with a path\n+                if self.token.is_plain_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n+                        *t != token::OpenDelim(token::Brace) &&\n+                        *t != token::OpenDelim(token::Paren)) {\n+                    // Plain idents have some extra abilities here compared to general paths\n+                    if self.look_ahead(1, |t| *t == token::Not) {\n+                        // Parse macro invocation\n+                        let ident = self.parse_ident();\n+                        let ident_span = self.last_span;\n+                        let path = ident_to_path(ident_span, ident);\n                         self.bump();\n-                        pat = PatStruct(enum_path, fields, etc);\n+                        let delim = self.expect_open_delim();\n+                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                seq_sep_none(), |p| p.parse_token_tree());\n+                        let mac = MacInvocTT(path, tts, EMPTY_CTXT);\n+                        pat = PatMac(codemap::Spanned {node: mac, span: self.span});\n+                    } else {\n+                        // Parse ident @ pat\n+                        // This can give false positives and parse nullary enums,\n+                        // they are dealt with later in resolve\n+                        pat = self.parse_pat_ident(BindByValue(MutImmutable));\n                     }\n-                    token::DotDotDot => {\n+                } else {\n+                    // Parse as a general path\n+                    let path = self.parse_path(LifetimeAndTypesWithColons);\n+                    match self.token {\n+                      token::DotDotDot => {\n+                        // Parse range\n                         let hi = self.last_span.hi;\n-                        let start = self.mk_expr(lo, hi, ExprPath(None, enum_path));\n-                        self.eat(&token::DotDotDot);\n-                        let end = if self.token.is_ident() || self.token.is_path() {\n-                            let path = self.parse_path(LifetimeAndTypesWithColons);\n-                            let hi = self.span.hi;\n-                            self.mk_expr(lo, hi, ExprPath(None, path))\n+                        let begin = self.mk_expr(lo, hi, ExprPath(None, path));\n+                        self.bump();\n+                        let end = self.parse_pat_range_end();\n+                        pat = PatRange(begin, end);\n+                      }\n+                      token::OpenDelim(token::Brace) => {\n+                        // Parse struct pattern\n+                        self.bump();\n+                        let (fields, etc) = self.parse_pat_fields();\n+                        self.bump();\n+                        pat = PatStruct(path, fields, etc);\n+                      }\n+                      token::OpenDelim(token::Paren) => {\n+                        // Parse tuple struct or enum pattern\n+                        if self.look_ahead(1, |t| *t == token::DotDot) {\n+                            // This is a \"top constructor only\" pat\n+                            self.bump();\n+                            self.bump();\n+                            self.expect(&token::CloseDelim(token::Paren));\n+                            pat = PatEnum(path, None);\n                         } else {\n-                            self.parse_literal_maybe_minus()\n-                        };\n-                        pat = PatRange(start, end);\n-                    }\n-                    _ => {\n-                        let mut args: Vec<P<Pat>> = Vec::new();\n-                        match self.token {\n-                          token::OpenDelim(token::Paren) => {\n-                            let is_dotdot = self.look_ahead(1, |t| {\n-                                match *t {\n-                                    token::DotDot => true,\n-                                    _ => false,\n-                                }\n-                            });\n-                            if is_dotdot {\n-                                // This is a \"top constructor only\" pat\n-                                self.bump();\n-                                self.bump();\n-                                self.expect(&token::CloseDelim(token::Paren));\n-                                pat = PatEnum(enum_path, None);\n-                            } else {\n-                                args = self.parse_enum_variant_seq(\n-                                    &token::OpenDelim(token::Paren),\n+                            let args = self.parse_enum_variant_seq(&token::OpenDelim(token::Paren),\n                                     &token::CloseDelim(token::Paren),\n-                                    seq_sep_trailing_allowed(token::Comma),\n-                                    |p| p.parse_pat()\n-                                );\n-                                pat = PatEnum(enum_path, Some(args));\n-                            }\n-                          },\n-                          _ => {\n-                              if !enum_path.global &&\n-                                  enum_path.segments.len() == 1 &&\n-                                  enum_path.segments[0].parameters.is_empty()\n-                              {\n-                                // NB: If enum_path is a single identifier,\n-                                // this should not be reachable due to special\n-                                // handling further above.\n-                                //\n-                                // However, previously a PatIdent got emitted\n-                                // here, so we preserve the branch just in case.\n-                                //\n-                                // A rewrite of the logic in this function\n-                                // would probably make this obvious.\n-                                self.span_bug(enum_path.span,\n-                                              \"ident only path should have been covered already\");\n-                              } else {\n-                                  pat = PatEnum(enum_path, Some(args));\n-                              }\n-                          }\n+                                    seq_sep_trailing_allowed(token::Comma), |p| p.parse_pat());\n+                            pat = PatEnum(path, Some(args));\n                         }\n+                      }\n+                      _ => {\n+                        // Parse nullary enum\n+                        pat = PatEnum(path, Some(vec![]));\n+                      }\n                     }\n                 }\n+            } else {\n+                // Try to parse everything else as literal with optional minus\n+                let begin = self.parse_literal_maybe_minus();\n+                if self.eat(&token::DotDotDot) {\n+                    let end = self.parse_pat_range_end();\n+                    pat = PatRange(begin, end);\n+                } else {\n+                    pat = PatLit(begin);\n+                }\n             }\n+          }\n         }\n-        hi = self.last_span.hi;\n+\n+        let hi = self.last_span.hi;\n         P(ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: pat,"}, {"sha": "6d3d1207788303f7036e206441060274724d0707", "filename": "src/test/compile-fail/issue-22426-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fcompile-fail%2Fissue-22426-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fcompile-fail%2Fissue-22426-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22426-1.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n   match 42 {\n     x < 7 => (),\n-   //~^ error: unexpected token: `<`\n+   //~^ error: expected one of `=>`, `@`, `if`, or `|`, found `<`\n     _ => ()\n   }\n }"}, {"sha": "6a0653041d45b194d344a7cb6ab9d34dfae78c5c", "filename": "src/test/compile-fail/issue-22426-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fcompile-fail%2Fissue-22426-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fcompile-fail%2Fissue-22426-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22426-2.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n fn a(B<) {}\n-   //~^ error: unexpected token: `<`\n+   //~^ error: expected one of `:` or `@`, found `<`"}, {"sha": "8ea2bcf900c97066e7f4f798328b45bd57343acd", "filename": "src/test/compile-fail/issue-22426-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fcompile-fail%2Fissue-22426-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fcompile-fail%2Fissue-22426-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22426-3.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -14,7 +14,7 @@ impl<T> Foo<T> {\n     fn foo(&self) {\n         match *self {\n             Foo<T>(x, y) => {\n-            //~^ error: unexpected token: `<`\n+            //~^ error: expected one of `=>`, `@`, `if`, or `|`, found `<`\n               println!(\"Goodbye, World!\")\n             }\n         }"}, {"sha": "1ace57edba3d8152d5d7732f9ccace943e529747", "filename": "src/test/parse-fail/issue-22647.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fissue-22647.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fissue-22647.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-22647.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let caller<F> = |f: F|  //~ ERROR unexpected token: `<`\n+    let caller<F> = |f: F|  //~ ERROR expected one of `:`, `;`, `=`, or `@`, found `<`\n     where F: Fn() -> i32\n     {\n         let x = f();"}, {"sha": "ed936cdd9a934c486c90a15c0adf81f09207c633", "filename": "src/test/parse-fail/issue-22712.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fissue-22712.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fissue-22712.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-22712.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -13,7 +13,7 @@ struct Foo<B> {\n }\n \n fn bar() {\n-    let Foo<Vec<u8>>  //~ ERROR unexpected token: `<`\n+    let Foo<Vec<u8>>  //~ ERROR expected one of `:`, `;`, `=`, or `@`, found `<`\n }\n \n fn main() {}"}, {"sha": "0fc00c350748adeaf5169447159f7b91a2fd566e", "filename": "src/test/parse-fail/match-vec-invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fmatch-vec-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fmatch-vec-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmatch-vec-invalid.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let a = Vec::new();\n     match a {\n-        [1, tail.., tail..] => {}, //~ ERROR: expected one of `!`, `,`, or `@`, found `..`\n+        [1, tail.., tail..] => {}, //~ ERROR: expected one of `,` or `@`, found `..`\n         _ => ()\n     }\n }"}, {"sha": "2826d3b4af94213e2faa515e76299798d9eb9e20", "filename": "src/test/parse-fail/omitted-arg-in-item-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fomitted-arg-in-item-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fomitted-arg-in-item-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fomitted-arg-in-item-fn.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x) { //~ ERROR expected one of `!`, `:`, or `@`, found `)`\n+fn foo(x) { //~ ERROR expected one of `:` or `@`, found `)`\n }"}, {"sha": "116848c42c28e07eec74191f34262c048f9abbbd", "filename": "src/test/parse-fail/removed-syntax-larrow-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-init.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -11,5 +11,5 @@\n fn removed_moves() {\n     let mut x = 0;\n     let y <- x;\n-    //~^ ERROR expected one of `!`, `:`, `;`, `=`, or `@`, found `<-`\n+    //~^ ERROR expected one of `:`, `;`, `=`, or `@`, found `<-`\n }"}, {"sha": "85addc822939d15883d4f8c8996155e7f3955870", "filename": "src/test/parse-fail/struct-literal-in-match-discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c1bdb2b44afd11603ec7bff6f31e6b4990699b/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs?ref=35c1bdb2b44afd11603ec7bff6f31e6b4990699b", "patch": "@@ -14,7 +14,7 @@ struct Foo {\n \n fn main() {\n     match Foo {\n-        x: 3    //~ ERROR expected one of `!`, `=>`, `@`, `if`, or `|`, found `:`\n+        x: 3    //~ ERROR expected one of `=>`, `@`, `if`, or `|`, found `:`\n     } {\n         Foo {\n             x: x"}]}