{"sha": "971b5d5151f79582252fa1281edb09cf86fd63ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MWI1ZDUxNTFmNzk1ODIyNTJmYTEyODFlZGIwOWNmODZmZDYzZmY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-15T02:02:30Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-16T23:59:25Z"}, "message": "Started adding support for return checking and non-returning function annotations\n\n* Reorganized typestate into several modules.\n\n* Made typestate check that any function with a non-nil return type\n  returns a value. For now, the check is a warning and not an error\n  (see next item).\n\n* Added a \"bot\" type (prettyprinted as _|_), for constructs like be, ret, break, cont, and\n  fail that don't locally return a value that can be inspected. \"bot\"\n  is distinct from \"nil\". There is no concrete syntax for _|_, while\n  the concrete syntax for the nil type is ().\n\n* Added support to the parser for a ! annotation on functions whose\n  result type is _|_. Such a function is required to have either a\n  fail or a call to another ! function that is reached in all control\n  flow paths. The point of this annotation is to mark functions like\n  unimpl() and span_err(), so that an alt with a call to err() in one\n  case isn't a false positive for the return-value checker. I haven't\n  actually annotated anything with it yet.\n\n* Random bugfixes:\n\n* * Fixed bug in trans::trans_binary that was throwing away the\n    cleanups for nested subexpressions of an and or or\n    (tests: box-inside-if and box-inside-if2).\n\n** In typeck, unify the expected type arguments of a tag with the\n   actual specified arguments.", "tree": {"sha": "6d8801deed32b5dd4dad1e999ec58695a88a4b62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d8801deed32b5dd4dad1e999ec58695a88a4b62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/971b5d5151f79582252fa1281edb09cf86fd63ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/971b5d5151f79582252fa1281edb09cf86fd63ff", "html_url": "https://github.com/rust-lang/rust/commit/971b5d5151f79582252fa1281edb09cf86fd63ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/971b5d5151f79582252fa1281edb09cf86fd63ff/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c75125fcce8618229ca973dc3360ffa8c6cb9648", "url": "https://api.github.com/repos/rust-lang/rust/commits/c75125fcce8618229ca973dc3360ffa8c6cb9648", "html_url": "https://github.com/rust-lang/rust/commit/c75125fcce8618229ca973dc3360ffa8c6cb9648"}], "stats": {"total": 3327, "additions": 3276, "deletions": 51}, "files": [{"sha": "d9d5633d05dc85e9ff42ec71e4986a0435bee177", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -9,7 +9,7 @@ import middle::trans;\n import middle::resolve;\n import middle::ty;\n import middle::typeck;\n-import middle::typestate_check;\n+import middle::tstate::ck;\n import back::link;\n import lib::llvm;\n import util::common;\n@@ -105,7 +105,8 @@ fn compile_input(session::session sess,\n \n     if (sess.get_opts().run_typestate) {\n         crate = time(time_passes, \"typestate checking\",\n-                     bind typestate_check::check_crate(crate, def_map));\n+                     bind middle::tstate::ck::check_crate(node_type_table,\n+                                                          ty_cx, crate));\n     }\n \n     auto llmod = time[llvm::ModuleRef](time_passes, \"translation\","}, {"sha": "5dfc2d8ddfadb6736a16d7228ea65a245df035eb", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -1,4 +1,3 @@\n-\n import std::map::hashmap;\n import std::option;\n import std::_str;\n@@ -7,7 +6,7 @@ import util::common::span;\n import util::common::spanned;\n import util::common::ty_mach;\n import util::common::filename;\n-import util::typestate_ann::ts_ann;\n+import middle::tstate::ann::ts_ann;\n \n type ident = str;\n \n@@ -323,6 +322,12 @@ type ty_method = rec(proto proto, ident ident,\n type ty = spanned[ty_];\n tag ty_ {\n     ty_nil;\n+    ty_bot; /* return type of ! functions and type of\n+             ret/fail/break/cont. there is no syntax\n+             for this type. */\n+    /* bot represents the value of functions that don't return a value\n+       locally to their context. in contrast, things like log that do\n+       return, but don't return a meaningful value, have result type nil. */\n     ty_bool;\n     ty_int;\n     ty_uint;\n@@ -354,12 +359,19 @@ type constr = spanned[constr_];\n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n type fn_decl = rec(vec[arg] inputs,\n                    @ty output,\n-                   purity purity);\n+                   purity purity,\n+                   controlflow cf);\n tag purity {\n     pure_fn;   // declared with \"pred\"\n     impure_fn; // declared with \"fn\"\n }\n \n+tag controlflow {\n+    noreturn; // functions with return type _|_ that always\n+              // raise an error or exit (i.e. never return to the caller)\n+    return;  // everything else\n+}\n+\n type _fn = rec(fn_decl decl,\n                proto proto,\n                block body);"}, {"sha": "63270579075318ba0bc916ac5d8629db537b52cb", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -23,6 +23,11 @@ tag file_type {\n     SOURCE_FILE;\n }\n \n+tag ty_or_bang {\n+    a_ty(@ast::ty);\n+    a_bang;\n+}\n+\n state type parser =\n     state obj {\n           fn peek() -> token::token;\n@@ -448,6 +453,13 @@ fn parse_ty_constrs(@ast::ty t, parser p) -> @ast::ty {\n    ret t;\n }\n \n+fn parse_ty_or_bang(parser p) -> ty_or_bang {\n+    alt (p.peek()) {\n+        case (token::NOT) { p.bump(); ret a_bang; }\n+        case (_)         { ret a_ty(parse_ty(p)); }\n+    }\n+}\n+\n fn parse_ty(parser p) -> @ast::ty {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n@@ -1713,20 +1725,31 @@ fn parse_fn_decl(parser p, ast::purity purity) -> ast::fn_decl {\n          some(token::COMMA),\n          pf, p);\n \n-    let @ast::ty output;\n+    let ty_or_bang res;\n \n     // FIXME: dropping constrs on the floor at the moment.\n     // pick them up when they're used by typestate pass.\n     parse_constrs(p);\n \n     if (p.peek() == token::RARROW) {\n         p.bump();\n-        output = parse_ty(p);\n+        res = parse_ty_or_bang(p);\n     } else {\n-        output = @spanned(inputs.span.lo, inputs.span.hi, ast::ty_nil);\n+        res = a_ty(@spanned(inputs.span.lo, inputs.span.hi, ast::ty_nil));\n+    }\n+\n+    alt (res) {\n+        case (a_ty(?t)) {\n+            ret rec(inputs=inputs.node, output=t,\n+              purity=purity, cf=ast::return);\n+        }\n+        case (a_bang) {\n+            ret rec(inputs=inputs.node,\n+                    output=@spanned(p.get_lo_pos(),\n+                                    p.get_hi_pos(), ast::ty_bot),\n+                    purity=purity, cf=ast::noreturn);\n+        }\n     }\n-    // FIXME\n-    ret rec(inputs=inputs.node, output=output, purity=purity);\n }\n \n fn parse_fn(parser p, ast::proto proto, ast::purity purity) -> ast::_fn {\n@@ -1778,11 +1801,12 @@ fn parse_dtor(parser p) -> @ast::method {\n     let vec[ast::arg] inputs = vec();\n     let @ast::ty output = @spanned(lo, lo, ast::ty_nil);\n     let ast::fn_decl d = rec(inputs=inputs,\n-                            output=output,\n-                            purity=ast::impure_fn);\n+                             output=output,\n+                             purity=ast::impure_fn,\n+                             cf=ast::return); \n     let ast::_fn f = rec(decl = d,\n-                        proto = ast::proto_fn,\n-                        body = b);\n+                         proto = ast::proto_fn,\n+                         body = b);\n     let ast::method_ m = rec(ident=\"drop\",\n                             meth=f,\n                             id=p.next_def_id(),"}, {"sha": "81675fbeedfb16eafded30c5175933ac9e314791", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -7,13 +7,14 @@ import util::common::new_str_hash;\n import util::common::spanned;\n import util::common::span;\n import util::common::ty_mach;\n-import util::typestate_ann::ts_ann;\n+import middle::tstate::ann::ts_ann;\n \n import front::ast;\n import front::ast::fn_decl;\n import front::ast::ident;\n import front::ast::path;\n import front::ast::mutability;\n+import front::ast::controlflow;\n import front::ast::ty;\n import front::ast::expr;\n import front::ast::stmt;\n@@ -44,6 +45,7 @@ type ast_fold[ENV] =\n \n      // Type folds.\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_nil,\n+     (fn(&ENV e, &span sp) -> @ty)                fold_ty_bot,\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_bool,\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_int,\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_uint,\n@@ -314,7 +316,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e,\n          &vec[arg] inputs,\n          &@ty output,\n-         &purity p) -> ast::fn_decl)              fold_fn_decl,\n+         &purity p, &controlflow c) -> ast::fn_decl) fold_fn_decl,\n \n      (fn(&ENV e, &ast::_mod m) -> ast::_mod)      fold_mod,\n \n@@ -375,6 +377,7 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n \n     alt (t.node) {\n         case (ast::ty_nil) { ret fld.fold_ty_nil(env_, t.span); }\n+        case (ast::ty_bot) { ret fld.fold_ty_bot(env_, t.span); }\n         case (ast::ty_bool) { ret fld.fold_ty_bool(env_, t.span); }\n         case (ast::ty_int) { ret fld.fold_ty_int(env_, t.span); }\n         case (ast::ty_uint) { ret fld.fold_ty_uint(env_, t.span); }\n@@ -926,7 +929,7 @@ fn fold_fn_decl[ENV](&ENV env, &ast_fold[ENV] fld,\n         inputs += vec(fold_arg(env, fld, a));\n     }\n     auto output = fold_ty[ENV](env, fld, decl.output);\n-    ret fld.fold_fn_decl(env, inputs, output, decl.purity);\n+    ret fld.fold_fn_decl(env, inputs, output, decl.purity, decl.cf);\n }\n \n fn fold_fn[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_fn f) -> ast::_fn {\n@@ -1202,6 +1205,10 @@ fn identity_fold_ty_nil[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast::ty_nil);\n }\n \n+fn identity_fold_ty_bot[ENV](&ENV env, &span sp) -> @ty {\n+    ret @respan(sp, ast::ty_bot);\n+}\n+\n fn identity_fold_ty_bool[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast::ty_bool);\n }\n@@ -1622,8 +1629,8 @@ fn identity_fold_block[ENV](&ENV e, &span sp, &ast::block_ blk) -> block {\n fn identity_fold_fn_decl[ENV](&ENV e,\n                               &vec[arg] inputs,\n                               &@ty output,\n-                              &purity p) -> ast::fn_decl {\n-    ret rec(inputs=inputs, output=output, purity=p);\n+                              &purity p, &controlflow c) -> ast::fn_decl {\n+    ret rec(inputs=inputs, output=output, purity=p, cf=c);\n }\n \n fn identity_fold_fn[ENV](&ENV e,\n@@ -1722,6 +1729,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_path       = bind identity_fold_path[ENV](_,_,_),\n \n          fold_ty_nil     = bind identity_fold_ty_nil[ENV](_,_),\n+         fold_ty_bot     = bind identity_fold_ty_bot[ENV](_,_),\n          fold_ty_bool    = bind identity_fold_ty_bool[ENV](_,_),\n          fold_ty_int     = bind identity_fold_ty_int[ENV](_,_),\n          fold_ty_uint    = bind identity_fold_ty_uint[ENV](_,_),\n@@ -1821,7 +1829,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_ann = bind identity_fold_ann[ENV](_,_),\n \n          fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n-         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_),\n+         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_,_),\n          fold_mod = bind identity_fold_mod[ENV](_,_),\n          fold_native_mod = bind identity_fold_native_mod[ENV](_,_),\n          fold_crate = bind identity_fold_crate[ENV](_,_,_,_),"}, {"sha": "8d27d5cd4c99d8f96faf75786b2c08247aa8be25", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -10,7 +10,7 @@ import util::common::new_int_hash;\n import util::common::new_uint_hash;\n import util::common::new_str_hash;\n import util::common::span;\n-import util::typestate_ann::ts_ann;\n+import middle::tstate::ann::ts_ann;\n import std::map::hashmap;\n import std::list::list;\n import std::list::nil;"}, {"sha": "869ad125fccf2e9aa48f388e18766c1d55b24718", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -757,6 +757,7 @@ fn type_of_inner(&@crate_ctxt cx, &ty::t t) -> TypeRef {\n     alt (ty::struct(cx.tcx, t)) {\n         case (ty::ty_native) { llty = T_ptr(T_i8()); }\n         case (ty::ty_nil) { llty = T_nil(); }\n+        case (ty::ty_bot) { llty = T_nil(); } /* ...I guess? */\n         case (ty::ty_bool) { llty = T_bool(); }\n         case (ty::ty_int) { llty = T_int(); }\n         case (ty::ty_float) { llty = T_float(); }\n@@ -3186,8 +3187,8 @@ fn copy_ty(&@block_ctxt cx,\n     if (ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t) ||\n             ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, cx.build.Store(src, dst));\n-\n-    } else if (ty::type_is_nil(cx.fcx.lcx.ccx.tcx, t)) {\n+    } else if (ty::type_is_nil(cx.fcx.lcx.ccx.tcx, t) ||\n+               ty::type_is_bot(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, C_nil());\n \n     } else if (ty::type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -3552,6 +3553,8 @@ fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n             }\n         }\n     }\n+\n+    fail; // fools the return-checker\n }\n \n fn autoderefed_ty(&@crate_ctxt ccx, &ty::t t) -> ty::t {\n@@ -3567,6 +3570,8 @@ fn autoderefed_ty(&@crate_ctxt ccx, &ty::t t) -> ty::t {\n             }\n         }\n     }\n+\n+    fail; // fools the return-checker\n }\n \n fn trans_binary(&@block_ctxt cx, ast::binop op,\n@@ -3591,12 +3596,17 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n             auto lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n             auto lhs_false_res = res(lhs_false_cx, C_bool(false));\n \n+            // The following line ensures that any cleanups for rhs\n+            // are done within the block for rhs. This is necessary \n+            // because and/or are lazy. So the rhs may never execute,\n+            // and the cleanups can't be pushed into later code.\n+            auto rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n+\n             lhs_res.bcx.build.CondBr(lhs_res.val,\n                                      rhs_cx.llbb,\n                                      lhs_false_cx.llbb);\n-\n             ret join_results(cx, T_bool(),\n-                             vec(lhs_false_res, rhs_res));\n+                  vec(lhs_false_res, rec(bcx=rhs_bcx with rhs_res)));\n         }\n \n         case (ast::or) {\n@@ -3615,12 +3625,15 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n             auto lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n             auto lhs_true_res = res(lhs_true_cx, C_bool(true));\n \n+            // see the and case for an explanation\n+            auto rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n+\n             lhs_res.bcx.build.CondBr(lhs_res.val,\n                                      lhs_true_cx.llbb,\n                                      rhs_cx.llbb);\n \n             ret join_results(cx, T_bool(),\n-                             vec(lhs_true_res, rhs_res));\n+                  vec(lhs_true_res, rec(bcx=rhs_bcx with rhs_res)));\n         }\n \n         case (_) {\n@@ -4984,6 +4997,8 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             ret res(bcx, pair_v);\n         }\n     }\n+\n+    fail; // sadly needed b/c the compiler doesn't know yet that unimpl fails\n }\n \n fn trans_arg_expr(&@block_ctxt cx,"}, {"sha": "6dbc3970a2560c2b6d44a63e450fab61efce4bf9", "filename": "src/comp/middle/tstate/ann.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -111,13 +111,13 @@ fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n-fn set_precondition(&ts_ann a, &precond p) -> () {\n+fn set_precondition(@ts_ann a, &precond p) -> () {\n   bitv::copy(a.conditions.precondition, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_postcondition(&ts_ann a, &postcond p) -> () {\n+fn set_postcondition(@ts_ann a, &postcond p) -> () {\n   bitv::copy(a.conditions.postcondition, p);\n }\n \n@@ -158,6 +158,10 @@ fn ann_prestate(&ts_ann a) -> prestate {\n   ret a.states.prestate;\n }\n \n+fn ann_poststate(&ts_ann a) -> poststate {\n+  ret a.states.poststate;\n+}\n+\n fn pp_clone(&pre_and_post p) -> pre_and_post {\n   ret rec(precondition=clone(p.precondition),\n           postcondition=clone(p.postcondition));", "previous_filename": "src/comp/util/typestate_ann.rs"}, {"sha": "b2d35a401ee14eaa16f1a78bb8b6d75e962263b2", "filename": "src/comp/middle/tstate/annotate.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,492 @@\n+import std::_vec;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+\n+import front::ast;\n+\n+import front::ast::ident;\n+import front::ast::def_id;\n+import front::ast::ann;\n+import front::ast::item;\n+import front::ast::_fn;\n+import front::ast::_mod;\n+import front::ast::crate;\n+import front::ast::_obj;\n+import front::ast::ty_param;\n+import front::ast::item_fn;\n+import front::ast::item_obj;\n+import front::ast::item_ty;\n+import front::ast::item_tag;\n+import front::ast::item_const;\n+import front::ast::item_mod;\n+import front::ast::item_native_mod;\n+import front::ast::expr;\n+import front::ast::elt;\n+import front::ast::field;\n+import front::ast::decl;\n+import front::ast::decl_local;\n+import front::ast::decl_item;\n+import front::ast::initializer;\n+import front::ast::local;\n+import front::ast::arm;\n+import front::ast::expr_call;\n+import front::ast::expr_vec;\n+import front::ast::expr_tup;\n+import front::ast::expr_path;\n+import front::ast::expr_field;\n+import front::ast::expr_index;\n+import front::ast::expr_log;\n+import front::ast::expr_block;\n+import front::ast::expr_rec;\n+import front::ast::expr_if;\n+import front::ast::expr_binary;\n+import front::ast::expr_unary;\n+import front::ast::expr_assign;\n+import front::ast::expr_assign_op;\n+import front::ast::expr_while;\n+import front::ast::expr_do_while;\n+import front::ast::expr_alt;\n+import front::ast::expr_lit;\n+import front::ast::expr_ret;\n+import front::ast::expr_self_method;\n+import front::ast::expr_bind;\n+import front::ast::expr_spawn;\n+import front::ast::expr_ext;\n+import front::ast::expr_fail;\n+import front::ast::expr_break;\n+import front::ast::expr_cont;\n+import front::ast::expr_send;\n+import front::ast::expr_recv;\n+import front::ast::expr_put;\n+import front::ast::expr_port;\n+import front::ast::expr_chan;\n+import front::ast::expr_be;\n+import front::ast::expr_check;\n+import front::ast::expr_assert;\n+import front::ast::expr_cast;\n+import front::ast::expr_for;\n+import front::ast::expr_for_each;\n+import front::ast::stmt;\n+import front::ast::stmt_decl;\n+import front::ast::stmt_expr;\n+import front::ast::block;\n+import front::ast::block_;\n+import front::ast::method;\n+\n+import middle::fold;\n+import middle::fold::respan;\n+import middle::fold::new_identity_fold;\n+import middle::fold::fold_crate;\n+import middle::fold::fold_item;\n+import middle::fold::fold_method;\n+\n+import util::common::uistr;\n+import util::common::span;\n+import util::common::new_str_hash;\n+\n+import middle::tstate::aux::fn_info;\n+import middle::tstate::aux::fn_info_map;\n+import middle::tstate::aux::num_locals;\n+import middle::tstate::aux::init_ann;\n+import middle::tstate::aux::init_blank_ann;\n+import middle::tstate::aux::get_fn_info;\n+\n+fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &_fn f,\n+                vec[ty_param] ty_params, def_id id, ann a) -> @item {\n+\n+    assert (fm.contains_key(id));\n+    auto f_info = fm.get(id);\n+\n+    log(i + \" has \" + uistr(num_locals(f_info)) + \" local vars\");\n+\n+    auto fld0 = new_identity_fold[fn_info]();\n+\n+    fld0 = @rec(fold_ann = bind init_ann(_,_) \n+                    with *fld0);\n+\n+    ret fold_item[fn_info]\n+           (f_info, fld0, @respan(sp, item_fn(i, f, ty_params, id, a))); \n+}\n+\n+/* FIXME: rewrite this with walk instead of fold */\n+\n+/* This is painstakingly written as an explicit recursion b/c the\n+   standard ast.fold doesn't traverse in the correct order:\n+   consider\n+   fn foo() {\n+      fn bar() {\n+        auto x = 5;\n+        log(x);\n+      }\n+   }\n+   With fold, first bar() would be processed and its subexps would\n+   correctly be annotated with length-1 bit vectors.\n+   But then, the process would be repeated with (fn bar()...) as\n+   a subexp of foo, which has 0 local variables -- so then\n+   the body of bar() would be incorrectly annotated with length-0 bit\n+   vectors. */\n+fn annotate_exprs(&fn_info_map fm, &vec[@expr] es) -> vec[@expr] {\n+    fn one(fn_info_map fm, &@expr e) -> @expr {\n+        ret annotate_expr(fm, e);\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec::map[@expr, @expr](f, es);\n+}\n+fn annotate_elts(&fn_info_map fm, &vec[elt] es) -> vec[elt] {\n+    fn one(fn_info_map fm, &elt e) -> elt {\n+        ret rec(mut=e.mut,\n+                expr=annotate_expr(fm, e.expr));\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec::map[elt, elt](f, es);\n+}\n+fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n+    fn one(fn_info_map fm, &field f) -> field {\n+        ret rec(mut=f.mut,\n+                 ident=f.ident,\n+                 expr=annotate_expr(fm, f.expr));\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec::map[field, field](f, fs);\n+}\n+fn annotate_option_exp(&fn_info_map fm, &option::t[@expr] o)\n+  -> option::t[@expr] {\n+    fn one(fn_info_map fm, &@expr e) -> @expr {\n+        ret annotate_expr(fm, e);\n+    }\n+    auto f = bind one(fm,_);\n+    ret option::map[@expr, @expr](f, o);\n+}\n+fn annotate_option_exprs(&fn_info_map fm, &vec[option::t[@expr]] es)\n+  -> vec[option::t[@expr]] {\n+    fn one(fn_info_map fm, &option::t[@expr] o) -> option::t[@expr] {\n+        ret annotate_option_exp(fm, o);\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec::map[option::t[@expr], option::t[@expr]](f, es);\n+}\n+fn annotate_decl(&fn_info_map fm, &@decl d) -> @decl {\n+    auto d1 = d.node;\n+    alt (d.node) {\n+        case (decl_local(?l)) {\n+            alt(l.init) {\n+                case (some[initializer](?init)) {\n+                    let option::t[initializer] an_i =\n+                        some[initializer]\n+                          (rec(expr=annotate_expr(fm, init.expr)\n+                                 with init));\n+                    let @local new_l = @rec(init=an_i with *l);\n+                    d1 = decl_local(new_l);\n+                }\n+                case (_) { /* do nothing */ }\n+            }\n+        }\n+        case (decl_item(?item)) {\n+            d1 = decl_item(annotate_item(fm, item));\n+        }\n+    }\n+    ret @respan(d.span, d1);\n+}\n+fn annotate_alts(&fn_info_map fm, &vec[arm] alts) -> vec[arm] {\n+    fn one(fn_info_map fm, &arm a) -> arm {\n+        ret rec(pat=a.pat,\n+                 block=annotate_block(fm, a.block));\n+    }\n+    auto f = bind one(fm,_);\n+    ret _vec::map[arm, arm](f, alts);\n+\n+}\n+fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n+    auto e1 = e.node;\n+    alt (e.node) {\n+        case (expr_vec(?es, ?m, ?a)) {\n+            e1 = expr_vec(annotate_exprs(fm, es), m, a);\n+        }\n+        case (expr_tup(?es, ?a)) {\n+            e1 = expr_tup(annotate_elts(fm, es), a);\n+        }\n+        case (expr_rec(?fs, ?maybe_e, ?a)) {\n+            e1 = expr_rec(annotate_fields(fm, fs),\n+                          annotate_option_exp(fm, maybe_e), a);\n+        }\n+        case (expr_call(?e, ?es, ?a)) {\n+            e1 = expr_call(annotate_expr(fm, e),\n+                          annotate_exprs(fm, es), a);\n+        }\n+        case (expr_self_method(_,_)) {\n+            // no change\n+        }\n+        case (expr_bind(?e, ?maybe_es, ?a)) {\n+            e1 = expr_bind(annotate_expr(fm, e),\n+                           annotate_option_exprs(fm, maybe_es),\n+                           a);\n+        }\n+        case (expr_spawn(?s, ?maybe_s, ?e, ?es, ?a)) {\n+            e1 = expr_spawn(s, maybe_s, annotate_expr(fm, e),\n+                            annotate_exprs(fm, es), a);\n+        }\n+        case (expr_binary(?bop, ?w, ?x, ?a)) {\n+            e1 = expr_binary(bop, annotate_expr(fm, w),\n+                             annotate_expr(fm, x), a);\n+        }\n+        case (expr_unary(?uop, ?w, ?a)) {\n+            e1 = expr_unary(uop, annotate_expr(fm, w), a);\n+        }\n+        case (expr_lit(_,_)) {\n+            /* no change */\n+        }\n+        case (expr_cast(?e,?t,?a)) {\n+            e1 = expr_cast(annotate_expr(fm, e), t, a);\n+        }\n+        case (expr_if(?e, ?b, ?maybe_e, ?a)) {\n+            e1 = expr_if(annotate_expr(fm, e),\n+                         annotate_block(fm, b),\n+                         annotate_option_exp(fm, maybe_e), a);\n+        }\n+        case (expr_while(?e, ?b, ?a)) {\n+            e1 = expr_while(annotate_expr(fm, e),\n+                            annotate_block(fm, b), a);\n+        }\n+        case (expr_for(?d, ?e, ?b, ?a)) {\n+            e1 = expr_for(annotate_decl(fm, d),\n+                          annotate_expr(fm, e),\n+                          annotate_block(fm, b), a);\n+        }\n+        case (expr_for_each(?d, ?e, ?b, ?a)) {\n+            e1 = expr_for_each(annotate_decl(fm, d),\n+                          annotate_expr(fm, e),\n+                          annotate_block(fm, b), a);\n+        }\n+        case (expr_do_while(?b, ?e, ?a)) {\n+            e1 = expr_do_while(annotate_block(fm, b),\n+                               annotate_expr(fm, e), a);\n+        }\n+        case (expr_alt(?e, ?alts, ?a)) {\n+            e1 = expr_alt(annotate_expr(fm, e),\n+                          annotate_alts(fm, alts), a);\n+        }\n+        case (expr_block(?b, ?a)) {\n+            e1 = expr_block(annotate_block(fm, b), a);\n+        }\n+        case (expr_assign(?l, ?r, ?a)) {\n+            e1 = expr_assign(annotate_expr(fm, l), annotate_expr(fm, r), a);\n+        }\n+        case (expr_assign_op(?bop, ?l, ?r, ?a)) {\n+            e1 = expr_assign_op(bop,\n+               annotate_expr(fm, l), annotate_expr(fm, r), a);\n+        }\n+        case (expr_send(?l, ?r, ?a)) {\n+            e1 = expr_send(annotate_expr(fm, l),\n+                           annotate_expr(fm, r), a);\n+        }\n+        case (expr_recv(?l, ?r, ?a)) {\n+           e1 = expr_recv(annotate_expr(fm, l),\n+                           annotate_expr(fm, r), a);\n+        }\n+        case (expr_field(?e, ?i, ?a)) {\n+            e1 = expr_field(annotate_expr(fm, e),\n+                            i, a);\n+        }\n+        case (expr_index(?e, ?sub, ?a)) {\n+            e1 = expr_index(annotate_expr(fm, e),\n+                            annotate_expr(fm, sub), a);\n+        }\n+        case (expr_path(_,_)) {\n+            /* no change */\n+        }\n+        case (expr_ext(?p, ?es, ?s_opt, ?e, ?a)) {\n+            e1 = expr_ext(p, annotate_exprs(fm, es),\n+                          s_opt,\n+                          annotate_expr(fm, e), a);\n+        }\n+        /* no change, next 3 cases */\n+        case (expr_fail(_)) { }\n+        case (expr_break(_)) { }\n+        case (expr_cont(_)) { }\n+        case (expr_ret(?maybe_e, ?a)) {\n+            e1 = expr_ret(annotate_option_exp(fm, maybe_e), a);\n+        }\n+        case (expr_put(?maybe_e, ?a)) {\n+            e1 = expr_put(annotate_option_exp(fm, maybe_e), a);\n+        }\n+        case (expr_be(?e, ?a)) {\n+            e1 = expr_be(annotate_expr(fm, e), a);\n+        }\n+        case (expr_log(?n, ?e, ?a)) {\n+            e1 = expr_log(n, annotate_expr(fm, e), a);\n+        }\n+        case (expr_assert(?e, ?a)) {\n+            e1 = expr_assert(annotate_expr(fm, e), a);\n+        }\n+        case (expr_check(?e, ?a)) {\n+            e1 = expr_check(annotate_expr(fm, e), a);\n+        }\n+        case (expr_port(_)) { /* no change */ }\n+        case (expr_chan(?e, ?a)) {\n+            e1 = expr_chan(annotate_expr(fm, e), a);\n+        }\n+    }\n+    ret @respan(e.span, e1);\n+}\n+\n+fn annotate_stmt(&fn_info_map fm, &@stmt s) -> @stmt {\n+    alt (s.node) {\n+        case (stmt_decl(?d, ?a)) {\n+            ret @respan(s.span, stmt_decl(annotate_decl(fm, d), a));\n+        }\n+        case (stmt_expr(?e, ?a)) {\n+            ret @respan(s.span, stmt_expr(annotate_expr(fm, e), a));\n+        }\n+    }\n+}\n+fn annotate_block(&fn_info_map fm, &block b) -> block {\n+    let vec[@stmt] new_stmts = vec();\n+   \n+    for (@stmt s in b.node.stmts) {\n+        auto new_s = annotate_stmt(fm, s);\n+        _vec::push[@stmt](new_stmts, new_s);\n+    }\n+    fn ann_e(fn_info_map fm, &@expr e) -> @expr {\n+        ret annotate_expr(fm, e);\n+    }\n+    auto f = bind ann_e(fm,_);\n+\n+    auto new_e = option::map[@expr, @expr](f, b.node.expr);\n+\n+    ret respan(b.span,\n+          rec(stmts=new_stmts, expr=new_e with b.node));\n+}\n+fn annotate_fn(&fn_info_map fm, &_fn f) -> _fn {\n+    // subexps have *already* been annotated based on\n+    // f's number-of-locals\n+    ret rec(body=annotate_block(fm, f.body) with f);\n+}\n+fn annotate_mod(&fn_info_map fm, &_mod m) -> _mod {\n+    let vec[@item] new_items = vec();\n+   \n+    for (@item i in m.items) {\n+        auto new_i = annotate_item(fm, i);\n+        _vec::push[@item](new_items, new_i);\n+    }\n+    ret rec(items=new_items with m);\n+}\n+fn annotate_method(&fn_info_map fm, &@method m) -> @method {\n+    auto f_info = get_fn_info(fm, m.node.id);\n+    auto fld0 = new_identity_fold[fn_info]();\n+    fld0 = @rec(fold_ann = bind init_ann(_,_) \n+                with *fld0);\n+    auto outer = fold_method[fn_info](f_info, fld0, m);\n+    auto new_fn = annotate_fn(fm, outer.node.meth);\n+    ret @respan(m.span,\n+                rec(meth=new_fn with m.node));\n+}\n+\n+fn annotate_obj(&fn_info_map fm, &_obj o) -> _obj {\n+    fn one(fn_info_map fm, &@method m) -> @method {\n+        ret annotate_method(fm, m);\n+    }\n+    auto f = bind one(fm,_);\n+    auto new_methods = _vec::map[@method, @method](f, o.methods);\n+    auto new_dtor    = option::map[@method, @method](f, o.dtor);\n+    ret rec(methods=new_methods, dtor=new_dtor with o);\n+}\n+\n+ \n+// Only annotates the components of the item recursively.\n+fn annotate_item_inner(&fn_info_map fm, &@item item) -> @item {\n+    alt (item.node) {\n+        /* FIXME can't skip this case -- exprs contain blocks contain stmts,\n+         which contain decls */\n+        case (item_const(_,_,_,_,_)) {\n+            // this has already been annotated by annotate_item\n+            ret item;\n+        }\n+        case (item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n+            ret @respan(item.span,\n+                       item_fn(ident, annotate_fn(fm, ff), tps, id, ann));\n+        }\n+        case (item_mod(?ident, ?mm, ?id)) {\n+            ret @respan(item.span,\n+                       item_mod(ident, annotate_mod(fm, mm), id));\n+        }\n+        case (item_native_mod(?ident, ?mm, ?id)) {\n+            ret item;\n+        }\n+        case (item_ty(_,_,_,_,_)) {\n+            ret item;\n+        }\n+        case (item_tag(_,_,_,_,_)) {\n+            ret item;\n+        }\n+        case (item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n+            ret @respan(item.span,\n+              item_obj(ident, annotate_obj(fm, ob), tps, odid, ann));\n+        }\n+    } \n+}\n+\n+fn annotate_item(&fn_info_map fm, &@item item) -> @item {\n+    // Using a fold, recursively set all anns in this item\n+    // to be blank.\n+    // *Then*, call annotate_item recursively to do the right\n+    // thing for any nested items inside this one.\n+    \n+    alt (item.node) {\n+        case (item_const(_,_,_,_,_)) {\n+            auto fld0 = new_identity_fold[()]();\n+            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n+                        with *fld0);\n+            ret fold_item[()]((), fld0, item);\n+        }\n+        case (item_fn(?i,?ff,?tps,?id,?ann)) {\n+            auto f_info = get_fn_info(fm, id);\n+            auto fld0 = new_identity_fold[fn_info]();\n+            fld0 = @rec(fold_ann = bind init_ann(_,_) \n+                        with *fld0);\n+            auto outer = fold_item[fn_info](f_info, fld0, item);\n+            // now recurse into any nested items\n+            ret annotate_item_inner(fm, outer);\n+         }\n+        case (item_mod(?i, ?mm, ?id)) {\n+            auto fld0 = new_identity_fold[()]();\n+            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n+                        with *fld0);\n+            auto outer = fold_item[()]((), fld0, item);\n+            ret annotate_item_inner(fm, outer);\n+        }\n+        case (item_native_mod(?i, ?nm, ?id)) {\n+            ret item;\n+        }\n+        case (item_ty(_,_,_,_,_)) {\n+            ret item;\n+        }\n+        case (item_tag(_,_,_,_,_)) {\n+            ret item;\n+        }\n+        case (item_obj(?i,?ob,?tps,?odid,?ann)) {\n+            auto fld0 = new_identity_fold[()]();\n+            fld0 = @rec(fold_ann = bind init_blank_ann(_,_) \n+                        with *fld0);\n+            auto outer = fold_item[()]((), fld0, item);\n+            ret annotate_item_inner(fm, outer);\n+        }\n+    }\n+}\n+\n+fn annotate_module(&fn_info_map fm, &_mod module) -> _mod {\n+    let vec[@item] new_items = vec();\n+   \n+    for (@item i in module.items) {\n+        auto new_item = annotate_item(fm, i);\n+        _vec::push[@item](new_items, new_item);\n+    }\n+\n+    ret rec(items = new_items with module);\n+}\n+\n+fn annotate_crate(&fn_info_map fm, &@crate crate) -> @crate {\n+    ret @respan(crate.span,\n+               rec(module = annotate_module(fm, crate.node.module)\n+                   with crate.node));\n+}"}, {"sha": "45d1aed94a1dae80d9323984c59c927cc211ec69", "filename": "src/comp/middle/tstate/aux.rs", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Faux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Faux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Faux.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,482 @@\n+import std::bitv;\n+import std::_vec::len;\n+import std::_vec::pop;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+import std::option::maybe;\n+\n+import front::ast;\n+import front::ast::ann_tag;\n+import front::ast::def;\n+import front::ast::def_fn;\n+import front::ast::_fn;\n+import front::ast::def_obj_field;\n+import front::ast::def_id;\n+import front::ast::expr_path;\n+import front::ast::ident;\n+import front::ast::controlflow;\n+import front::ast::ann;\n+import front::ast::ann_none;\n+import front::ast::ann_type;\n+import front::ast::ts_ann;\n+import front::ast::stmt;\n+import front::ast::expr;\n+import front::ast::block;\n+import front::ast::block_;\n+import front::ast::stmt_decl;\n+import front::ast::stmt_expr;\n+import front::ast::stmt_crate_directive;\n+import front::ast::return;\n+import front::ast::expr_field;\n+\n+import middle::ty::expr_ann;\n+import middle::fold;\n+import middle::fold::respan;\n+import middle::fold::new_identity_fold;\n+import middle::fold::fold_block;\n+\n+import util::common;\n+import util::common::span;\n+import util::common::log_block;\n+import util::common::new_def_hash;\n+import util::common::log_expr_err;\n+import util::common::uistr;\n+\n+import tstate::ann::pre_and_post;\n+import tstate::ann::pre_and_post_state;\n+import tstate::ann::empty_ann;\n+import tstate::ann::prestate;\n+import tstate::ann::poststate;\n+import tstate::ann::precond;\n+import tstate::ann::postcond;\n+import tstate::ann::empty_states;\n+import tstate::ann::pps_len;\n+import tstate::ann::set_prestate;\n+import tstate::ann::set_poststate;\n+import tstate::ann::extend_prestate;\n+import tstate::ann::extend_poststate;\n+import tstate::ann::set_precondition;\n+import tstate::ann::set_postcondition;\n+\n+/* logging funs */\n+\n+fn bitv_to_str(fn_info enclosing, bitv::t v) -> str {\n+  auto s = \"\";\n+\n+  for each (@tup(def_id, tup(uint, ident)) p in enclosing.vars.items()) {\n+    if (bitv::get(v, p._1._0)) {\n+      s += \" \" + p._1._1 + \" \";\n+    }\n+  }\n+  ret s;\n+}\n+\n+fn log_bitv(fn_info enclosing, bitv::t v) {\n+    log(bitv_to_str(enclosing, v));\n+}\n+\n+fn log_bitv_err(fn_info enclosing, bitv::t v) {\n+    log_err(bitv_to_str(enclosing, v));\n+}\n+\n+fn tos (vec[uint] v) -> str {\n+  auto res = \"\";\n+  for (uint i in v) {\n+    if (i == 0u) {\n+      res += \"0\";\n+    }\n+    else {\n+      res += \"1\";\n+    }\n+  }\n+  ret res;\n+}\n+\n+fn log_cond(vec[uint] v) -> () {\n+    log(tos(v));\n+}\n+fn log_cond_err(vec[uint] v) -> () {\n+    log_err(tos(v));\n+}\n+\n+fn log_pp(&pre_and_post pp) -> () {\n+  auto p1 = bitv::to_vec(pp.precondition);\n+  auto p2 = bitv::to_vec(pp.postcondition);\n+  log(\"pre:\");\n+  log_cond(p1);\n+  log(\"post:\");\n+  log_cond(p2);\n+}\n+\n+fn log_pp_err(&pre_and_post pp) -> () {\n+  auto p1 = bitv::to_vec(pp.precondition);\n+  auto p2 = bitv::to_vec(pp.postcondition);\n+  log_err(\"pre:\");\n+  log_cond_err(p1);\n+  log_err(\"post:\");\n+  log_cond_err(p2);\n+}\n+\n+fn log_states(&pre_and_post_state pp) -> () {\n+  auto p1 = bitv::to_vec(pp.prestate);\n+  auto p2 = bitv::to_vec(pp.poststate);\n+  log(\"prestate:\");\n+  log_cond(p1);\n+  log(\"poststate:\");\n+  log_cond(p2);\n+}\n+\n+fn log_states_err(&pre_and_post_state pp) -> () {\n+  auto p1 = bitv::to_vec(pp.prestate);\n+  auto p2 = bitv::to_vec(pp.poststate);\n+  log_err(\"prestate:\");\n+  log_cond_err(p1);\n+  log_err(\"poststate:\");\n+  log_cond_err(p2);\n+}\n+\n+fn print_ident(&ident i) -> () {\n+  log(\" \" + i + \" \");\n+}\n+\n+fn print_idents(vec[ident] idents) -> () {\n+  if (len[ident](idents) == 0u) {\n+    ret;\n+  }\n+  else {\n+    log(\"an ident: \" + pop[ident](idents));\n+    print_idents(idents);\n+  }\n+}\n+\n+\n+/* data structures */\n+\n+/**********************************************************************/\n+/* mapping from variable name (def_id is assumed to be for a local\n+   variable in a given function) to bit number \n+   (also remembers the ident for error-logging purposes) */\n+type var_info     = tup(uint, ident);\n+type fn_info      = rec(@std::map::hashmap[def_id, var_info] vars,\n+                        controlflow cf);\n+/* mapping from function name to fn_info map */\n+type fn_info_map = @std::map::hashmap[def_id, fn_info];\n+\n+type fn_ctxt    = rec(fn_info enclosing,\n+                      def_id id,\n+                      ident name,\n+                      crate_ctxt ccx);\n+\n+type crate_ctxt = rec(ty::ctxt tcx,\n+                      ty::node_type_table node_types,\n+                      fn_info_map fm);\n+\n+fn get_fn_info(fn_info_map fm, def_id did) -> fn_info {\n+    assert (fm.contains_key(did));\n+    ret fm.get(did);\n+}\n+\n+/********* utils ********/\n+\n+\n+fn ann_to_ts_ann(ann a, uint nv) -> @ts_ann {\n+    alt (ann_to_ts_ann_fail(a)) {\n+        case (none[@ts_ann])         { ret @empty_ann(nv); }\n+        case (some[@ts_ann](?t))     { ret t; }\n+    }\n+}\n+\n+\n+fn ann_to_ts_ann_fail(ann a) -> option::t[@ts_ann] {\n+  alt (a) {\n+    case (ann_none(_)) { \n+          log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n+          fail;\n+      }\n+    case (ann_type(_,_,_,?ty)) {\n+          ret ty;\n+      }\n+  }\n+}\n+\n+fn ann_to_ts_ann_strict(ann a) -> @ts_ann {\n+    alt (ann_to_ts_ann_fail(a)) {\n+        case (none[@ts_ann])         {    \n+            log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n+            fail;\n+        }\n+        case (some[@ts_ann](?t))        {     \n+            ret t;\n+        }\n+    }\n+}\n+\n+fn ann_to_poststate(ann a) -> poststate {\n+    ret (ann_to_ts_ann_strict(a)).states.poststate;\n+}\n+\n+fn stmt_to_ann(&stmt s) -> option::t[@ts_ann] {\n+  alt (s.node) {\n+    case (stmt_decl(_,?a)) {\n+        ret ann_to_ts_ann_fail(a);\n+    }\n+    case (stmt_expr(_,?a)) {\n+        ret ann_to_ts_ann_fail(a);\n+    }\n+    case (stmt_crate_directive(_)) {\n+      ret none[@ts_ann];\n+    }\n+  }\n+}\n+\n+fn stmt_to_ann_strict(&stmt s) -> @ts_ann {\n+    alt (stmt_to_ann(s)) {\n+        case (none[@ts_ann]) {\n+            log_err(\"stmt_to_ann_strict: didn't expect none here\");\n+            fail;\n+        }\n+        case (some[@ts_ann](?a)) { ret a; }\n+    }\n+}\n+\n+/* fails if e has no annotation */\n+fn expr_states(@expr e) -> pre_and_post_state {\n+    ret (ann_to_ts_ann_strict(expr_ann(e)).states);\n+}\n+\n+/* fails if e has no annotation */\n+fn expr_pp(@expr e) -> pre_and_post {\n+    ret (ann_to_ts_ann_strict(expr_ann(e)).conditions);\n+}\n+\n+fn stmt_pp(&stmt s) -> pre_and_post {\n+    ret (stmt_to_ann_strict(s).conditions);\n+}\n+\n+/* fails if b has no annotation */\n+fn block_pp(&block b) -> pre_and_post {\n+    ret (ann_to_ts_ann_strict(b.node.a).conditions);\n+}\n+\n+fn block_states(&block b) -> pre_and_post_state {\n+    ret (ann_to_ts_ann_strict(b.node.a).states);\n+}\n+\n+fn stmt_states(&stmt s, uint nv) -> pre_and_post_state {\n+  alt (stmt_to_ann(s)) {\n+    case (none[@ts_ann]) {\n+      ret empty_states(nv);\n+    }\n+    case (some[@ts_ann](?a)) {\n+      ret a.states;\n+    }\n+  }\n+}\n+\n+fn expr_precond(@expr e) -> precond {\n+  ret (expr_pp(e)).precondition;\n+}\n+\n+fn expr_postcond(@expr e) -> postcond {\n+  ret (expr_pp(e)).postcondition;\n+}\n+\n+fn expr_prestate(@expr e) -> prestate {\n+  ret (expr_states(e)).prestate;\n+}\n+\n+fn expr_poststate(@expr e) -> poststate {\n+  ret (expr_states(e)).poststate;\n+}\n+\n+fn stmt_precond(&stmt s) -> precond {\n+  ret (stmt_pp(s)).precondition;\n+}\n+\n+fn stmt_postcond(&stmt s) -> postcond {\n+  ret (stmt_pp(s)).postcondition;\n+}\n+\n+fn states_to_poststate(&pre_and_post_state ss) -> poststate {\n+  ret ss.poststate;\n+}\n+\n+fn stmt_prestate(&stmt s, uint nv) -> prestate {\n+  ret (stmt_states(s, nv)).prestate;\n+}\n+\n+fn stmt_poststate(&stmt s, uint nv) -> poststate {\n+  ret (stmt_states(s, nv)).poststate;\n+}\n+\n+fn block_postcond(&block b) -> postcond {\n+    ret (block_pp(b)).postcondition;\n+}\n+\n+fn block_poststate(&block b) -> poststate {\n+    ret (block_states(b)).poststate;\n+}\n+\n+/* returns a new annotation where the pre_and_post is p */\n+fn with_pp(ann a, pre_and_post p) -> ann {\n+  alt (a) {\n+    case (ann_none(_)) {\n+      log(\"with_pp: the impossible happened\");\n+      fail; /* shouldn't happen b/c code is typechecked */\n+    }\n+    case (ann_type(?i, ?t, ?ps, _)) {\n+        ret (ann_type(i, t, ps,\n+                    some[@ts_ann]\n+                    (@rec(conditions=p,\n+                          states=empty_states(pps_len(p))))));\n+    }\n+  }\n+}\n+\n+fn set_prestate_ann(&ann a, &prestate pre) -> bool {\n+    ret set_prestate(ann_to_ts_ann_strict(a), pre);\n+}\n+\n+\n+fn extend_prestate_ann(&ann a, &prestate pre) -> bool {\n+    ret extend_prestate(ann_to_ts_ann_strict(a).states.prestate, pre);\n+}\n+\n+fn set_poststate_ann(&ann a, &poststate post) -> bool {\n+    ret set_poststate(ann_to_ts_ann_strict(a), post);\n+}\n+\n+fn extend_poststate_ann(&ann a, &poststate post) -> bool {\n+    ret extend_poststate(ann_to_ts_ann_strict(a).states.poststate, post);\n+}\n+\n+fn set_pre_and_post(&ann a, &pre_and_post pp) -> () {\n+    auto t = ann_to_ts_ann_strict(a);\n+    set_precondition(t, pp.precondition);\n+    set_postcondition(t, pp.postcondition);\n+}\n+\n+fn pure_exp(&ann a, &prestate p) -> bool {\n+  auto changed = false;\n+  changed = extend_prestate_ann(a, p) || changed;\n+  changed = extend_poststate_ann(a, p) || changed;\n+  ret changed;\n+}\n+\n+fn fixed_point_states(&fn_ctxt fcx,\n+    fn (&fn_ctxt, &_fn) -> bool f, &_fn start) -> () {\n+\n+  auto changed = f(fcx, start);\n+\n+  if (changed) {\n+    ret fixed_point_states(fcx, f, start);\n+  }\n+  else {\n+    // we're done!\n+    ret;\n+  }\n+}\n+\n+fn init_ann(&fn_info fi, &ann a) -> ann {\n+    alt (a) {\n+        case (ann_none(_)) {\n+            //            log(\"init_ann: shouldn't see ann_none\");\n+            // fail;\n+            log(\"warning: init_ann: saw ann_none\");\n+            ret a; // Would be better to fail so we can catch bugs that\n+            // result in an uninitialized ann -- but don't want to have to\n+            // write code to handle native_mods properly\n+        }\n+        case (ann_type(?i, ?t, ?ps, _)) {\n+            ret ann_type(i, t, ps, some[@ts_ann](@empty_ann(num_locals(fi))));\n+        }\n+    }\n+}\n+\n+fn init_blank_ann(&() ignore, &ann a) -> ann {\n+    alt (a) {\n+        case (ann_none(_)) {\n+            //            log(\"init_blank_ann: shouldn't see ann_none\");\n+            //fail;\n+            log(\"warning: init_blank_ann: saw ann_none\");\n+            ret a;\n+        }\n+        case (ann_type(?i, ?t, ?ps,_)) {\n+            ret ann_type(i, t, ps, some[@ts_ann](@empty_ann(0u)));\n+        }\n+    }\n+}\n+\n+fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n+    log(\"init_block:\");\n+    log_block(respan(sp, b));\n+    alt(b.a) {\n+        case (ann_none(_)) {\n+            log(\"init_block: shouldn't see ann_none\");\n+            fail;\n+        }\n+        case (ann_type(_, _, _, _)) {\n+            auto fld0 = new_identity_fold[fn_info]();\n+\n+            fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n+            ret fold_block[fn_info](fi, fld0, respan(sp, b)); \n+        }\n+    }\n+}\n+\n+fn num_locals(fn_info m) -> uint {\n+  ret m.vars.size();\n+}\n+\n+fn new_crate_ctxt(ty::node_type_table nt, ty::ctxt cx) -> crate_ctxt {\n+    ret rec(tcx=cx, node_types=nt, fm=@new_def_hash[fn_info]());\n+}\n+\n+fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n+    alt (ccx.fm.find(d)) {\n+        case (some[fn_info](?fi)) { ret fi.cf; }\n+        case (none[fn_info])      { ret return; } \n+    }\n+}\n+\n+/* conservative approximation: uses the mapping if e refers to a known\n+   function or method, assumes returning otherwise.\n+   There's no case for fail b/c we assume e is the callee and it\n+   seems unlikely that one would apply \"fail\" to arguments. */\n+fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n+    auto f = ann_tag(expr_ann(e));\n+    alt (ccx.tcx.def_map.find(f)) {\n+        case (some[def](def_fn(?d)))        { ret controlflow_def_id(ccx, d); }\n+        case (some[def](def_obj_field(?d))) { ret controlflow_def_id(ccx, d); }\n+        case (_)                            { ret return; }\n+    }\n+}\n+\n+fn ann_to_def_strict(&crate_ctxt ccx, &ann a) -> def {\n+    alt (ccx.tcx.def_map.find(ann_tag(a))) {\n+        case (none[def]) { \n+            log_err(\"ann_to_def: node_id \" +\n+                    uistr(ann_tag(a)) +\n+                    \" has no def\");\n+            fail;\n+        }\n+        case (some[def](?d)) { ret d; }\n+    }\n+}\n+\n+fn ann_to_def(&crate_ctxt ccx, &ann a) -> option::t[def] {\n+    ret ccx.tcx.def_map.find(ann_tag(a));\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//\n+"}, {"sha": "667a0889e24ea0724147ca60f16a472692f9f224", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,137 @@\n+import std::bitv;\n+import std::_vec;\n+import std::_vec::len;\n+import std::_vec::slice;\n+\n+import front::ast;\n+import front::ast::def_id;\n+import front::ast::expr;\n+import front::ast::ann;\n+\n+import aux::fn_ctxt;\n+import aux::fn_info;\n+import aux::log_bitv;\n+import aux::num_locals;\n+import aux::ann_to_ts_ann_strict;\n+\n+import tstate::ann::pre_and_post;\n+import tstate::ann::precond;\n+import tstate::ann::postcond;\n+import tstate::ann::prestate;\n+import tstate::ann::poststate;\n+import tstate::ann::relax_prestate;\n+import tstate::ann::pps_len;\n+import tstate::ann::true_precond;\n+import tstate::ann::empty_prestate;\n+import tstate::ann::difference;\n+import tstate::ann::union;\n+import tstate::ann::intersect;\n+import tstate::ann::clone;\n+import tstate::ann::set_in_postcond;\n+import tstate::ann::set_in_poststate;\n+             \n+fn bit_num(def_id v, fn_info m) -> uint {\n+  assert (m.vars.contains_key(v));\n+  ret m.vars.get(v)._0;\n+}\n+\n+fn promises(&poststate p, def_id v, fn_info m) -> bool {\n+    ret bitv::get(p, bit_num(v, m));\n+}\n+\n+// Given a list of pres and posts for exprs e0 ... en,\n+// return the precondition for evaluating each expr in order.\n+// So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n+// precondition shouldn't include x.\n+fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n+  let uint sz = len[pre_and_post](pps);\n+  let uint num_vars = num_locals(enclosing);\n+\n+  if (sz >= 1u) {\n+    auto first   = pps.(0);\n+    assert (pps_len(first) == num_vars);\n+    let precond rest = seq_preconds(enclosing,\n+                         slice[pre_and_post](pps, 1u, sz));\n+    difference(rest, first.postcondition);\n+    auto res = clone(first.precondition);\n+    union(res, rest);\n+\n+    log(\"seq_preconds:\");\n+    log(\"first.postcondition =\");\n+    log_bitv(enclosing, first.postcondition);\n+    log(\"rest =\");\n+    log_bitv(enclosing, rest);\n+    log(\"returning\");\n+    log_bitv(enclosing, res);\n+\n+    ret res;\n+  }\n+  else {\n+      ret true_precond(num_vars);\n+  }\n+}\n+\n+/* works on either postconds or preconds\n+ should probably rethink the whole type synonym situation */\n+fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n+  auto sz = _vec::len[postcond](rest);\n+\n+  if (sz > 0u) {\n+    auto other = rest.(0);\n+    union(first, other);\n+    union_postconds_go(first, slice[postcond](rest, 1u, len[postcond](rest)));\n+  }\n+\n+  ret first;\n+}\n+\n+fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n+  if (len[postcond](pcs) > 0u) {\n+      ret union_postconds_go(bitv::clone(pcs.(0)), pcs);\n+  }\n+  else {\n+      ret empty_prestate(nv);\n+  }\n+}\n+\n+/* Gee, maybe we could use foldl or something */\n+fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n+  auto sz = _vec::len[postcond](rest);\n+\n+  if (sz > 0u) {\n+    auto other = rest.(0);\n+    intersect(first, other);\n+    intersect_postconds_go(first, slice[postcond](rest, 1u,\n+                                                  len[postcond](rest)));\n+  }\n+\n+  ret first;\n+}\n+\n+fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n+  assert (len[postcond](pcs) > 0u);\n+\n+  ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n+}\n+\n+fn gen(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n+  assert (fcx.enclosing.vars.contains_key(id));\n+  let uint i = (fcx.enclosing.vars.get(id))._0;\n+  ret set_in_postcond(i, (ann_to_ts_ann_strict(a)).conditions);\n+}\n+\n+fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n+   -> prestate {\n+    assert (enclosing.vars.contains_key(id));\n+    let uint i = (enclosing.vars.get(id))._0;\n+    auto res = clone(pre);\n+    relax_prestate(i, res);\n+    ret res;\n+}\n+\n+fn gen_poststate(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n+  assert (fcx.enclosing.vars.contains_key(id));\n+  let uint i = (fcx.enclosing.vars.get(id))._0;\n+  ret set_in_poststate(i, (ann_to_ts_ann_strict(a)).states);\n+}\n+"}, {"sha": "a1df6e0f55cb735365537f3a0e4d0e095586da61", "filename": "src/comp/middle/tstate/ck.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,231 @@\n+import front::ast;\n+import front::ast::method;\n+import front::ast::ann;\n+import front::ast::item;\n+import front::ast::item_fn;\n+import front::ast::_fn;\n+import front::ast::obj_field;\n+import front::ast::_obj;\n+import front::ast::stmt;\n+import front::ast::ident;\n+import front::ast::def_id;\n+import front::ast::ty_param;\n+import front::ast::crate;\n+\n+import front::ast::expr;\n+import middle::fold::respan;\n+import middle::fold::new_identity_fold;\n+import middle::fold::fold_crate;\n+import middle::ty::type_is_nil;\n+import middle::ty::ret_ty_of_fn;\n+import util::common::span;\n+import tstate::ann::ts_ann;\n+import tstate::ann::empty_poststate;\n+import tstate::ann::true_precond;\n+import tstate::ann::true_postcond;\n+import tstate::ann::false_postcond;\n+import tstate::ann::precond;\n+import tstate::ann::postcond;\n+import tstate::ann::poststate;\n+import tstate::ann::prestate;\n+import tstate::ann::implies;\n+import tstate::ann::ann_precond;\n+import tstate::ann::ann_prestate;\n+import std::_vec::map;\n+import std::_vec;\n+import std::_vec::slice;\n+import std::_vec::unzip;\n+import std::_vec::plus_option;\n+import std::_vec::cat_options;\n+\n+import std::option;\n+import std::option::t;\n+import std::option::some;\n+import std::option::none;\n+\n+import aux::fn_ctxt;\n+import aux::crate_ctxt;\n+import aux::new_crate_ctxt;\n+import aux::expr_precond;\n+import aux::expr_prestate;\n+import aux::expr_poststate;\n+import aux::stmt_poststate;\n+import aux::stmt_to_ann;\n+import aux::num_locals;\n+import aux::fixed_point_states;\n+import aux::bitv_to_str;\n+\n+import util::common::ty_to_str;\n+import bitvectors::promises;\n+\n+import annotate::annotate_crate;\n+import collect_locals::mk_f_to_fn_info;\n+import pre_post_conditions::check_item_fn;\n+import states::find_pre_post_state_fn;\n+\n+fn check_states_expr(&fn_ctxt fcx, @expr e) -> () {\n+  let precond prec    = expr_precond(e);\n+  let prestate pres   = expr_prestate(e);\n+\n+  if (!implies(pres, prec)) {\n+      auto s = \"\";\n+      s += (\"Unsatisfied precondition constraint for expression:\\n\");\n+      s += util::common::expr_to_str(e);\n+      s += (\"Precondition: \");\n+      s += bitv_to_str(fcx.enclosing, prec);\n+      s += (\"Prestate: \");\n+      s += bitv_to_str(fcx.enclosing, pres);\n+      fcx.ccx.tcx.sess.span_err(e.span, s);\n+  }\n+}\n+\n+fn check_states_stmt(&fn_ctxt fcx, &stmt s) -> () {\n+  alt (stmt_to_ann(s)) {\n+    case (none[@ts_ann]) {\n+      ret;\n+    }\n+    case (some[@ts_ann](?a)) {\n+      let precond prec    = ann_precond(*a);\n+      let prestate pres   = ann_prestate(*a);\n+\n+      /*\n+      log(\"check_states_stmt:\");\n+      log_stmt(s);\n+      log(\"prec = \");\n+      log_bitv(enclosing, prec);\n+      log(\"pres = \");\n+      log_bitv(enclosing, pres);\n+      */\n+\n+      if (!implies(pres, prec)) {\n+          auto ss = \"\";\n+          ss += (\"Unsatisfied precondition constraint for statement:\\n\");\n+          ss += util::common::stmt_to_str(s);\n+          ss += (\"Precondition: \");\n+          ss += bitv_to_str(fcx.enclosing, prec);\n+          ss += (\"Prestate: \");\n+          ss += bitv_to_str(fcx.enclosing, pres);\n+          fcx.ccx.tcx.sess.span_err(s.span, ss);\n+      }\n+    }\n+  }\n+}\n+\n+fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n+    auto enclosing = fcx.enclosing;\n+    auto nv   = num_locals(enclosing);\n+    auto post = @empty_poststate(nv);\n+\n+    fn do_one_(fn_ctxt fcx, &@stmt s, @poststate post, uint nv) -> () {\n+        check_states_stmt(fcx, *s);\n+        *post = stmt_poststate(*s, nv);\n+    }\n+\n+    auto do_one = bind do_one_(fcx, _, post, nv);\n+ \n+  _vec::map[@stmt, ()](do_one, f.body.node.stmts);\n+  fn do_inner_(fn_ctxt fcx, &@expr e, @poststate post) -> () {\n+    check_states_expr(fcx, e);\n+    *post = expr_poststate(e);\n+  }\n+  auto do_inner = bind do_inner_(fcx, _, post);\n+  option::map[@expr, ()](do_inner, f.body.node.expr);\n+  \n+  /* Finally, check that the return value is initialized */\n+  if (f.proto == ast::proto_fn\n+      && ! promises(*post, fcx.id, enclosing)\n+      && ! type_is_nil(fcx.ccx.tcx,\n+                       ret_ty_of_fn(fcx.ccx.node_types, fcx.ccx.tcx, a)) ) {\n+      /* FIXME: make this an error, not warning, once I finish implementing\n+         ! annotations */\n+        /* fcx.ccx.tcx.sess.span_err(f.body.span, \"Function \" +\n+           fcx.name + \" may not return. Its declared return type is \"\n+           + util.common.ty_to_str(*f.decl.output)); */\n+        log_err(\"WARNING: Function \" +\n+           fcx.name + \" may not return. Its declared return type is \"\n+                + ty_to_str(*f.decl.output));\n+    }\n+\n+}\n+\n+fn check_fn_states(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n+    /* Compute the pre- and post-states for this function */\n+    auto g = find_pre_post_state_fn;\n+    fixed_point_states(fcx, g, f);\n+    \n+    /* Now compare each expr's pre-state to its precondition\n+       and post-state to its postcondition */\n+    check_states_against_conditions(fcx, f, a);\n+}\n+\n+fn check_item_fn_state(&crate_ctxt ccx, &span sp, &ident i,\n+                       &_fn f, &vec[ty_param] ty_params,\n+                       &def_id id, &ann a) -> @item {\n+\n+    /* Look up the var-to-bit-num map for this function */\n+    assert (ccx.fm.contains_key(id));\n+    auto f_info = ccx.fm.get(id);\n+\n+    auto fcx = rec(enclosing=f_info, id=id, name=i, ccx=ccx);\n+    check_fn_states(fcx, f, a);\n+\n+    /* Rebuild the same function */\n+    ret @respan(sp, item_fn(i, f, ty_params, id, a));\n+}\n+\n+fn check_method_states(&crate_ctxt ccx, @method m) -> () {\n+    assert (ccx.fm.contains_key(m.node.id));\n+    auto fcx = rec(enclosing=ccx.fm.get(m.node.id),\n+                   id=m.node.id, name=m.node.ident, ccx=ccx);\n+    check_fn_states(fcx, m.node.meth, m.node.ann);\n+}\n+\n+fn check_obj_state(&crate_ctxt ccx, &vec[obj_field] fields,\n+                   &vec[@method] methods,\n+                   &option::t[@method] dtor) -> _obj {\n+    fn one(crate_ctxt ccx, &@method m) -> () {\n+        ret check_method_states(ccx, m);\n+    }\n+    auto f = bind one(ccx,_);\n+    _vec::map[@method, ()](f, methods);\n+    option::map[@method, ()](f, dtor);\n+    ret rec(fields=fields, methods=methods, dtor=dtor);\n+}\n+\n+/* FIXME use walk instead of fold where possible */\n+\n+fn check_crate(ty::node_type_table nt, ty::ctxt cx, @crate crate) -> @crate {\n+    let crate_ctxt ccx = new_crate_ctxt(nt, cx);\n+\n+    /* Build the global map from function id to var-to-bit-num-map */\n+    mk_f_to_fn_info(ccx, crate);\n+  \n+    /* Add a blank ts_ann to every statement (and expression) */\n+    auto with_anns = annotate_crate(ccx.fm, crate);\n+\n+    /* Compute the pre and postcondition for every subexpression */\n+    \n+    auto fld = new_identity_fold[crate_ctxt]();\n+    fld = @rec(fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_) with *fld);\n+    auto with_pre_postconditions =\n+           fold_crate[crate_ctxt](ccx, fld, with_anns);\n+    \n+    auto fld1 = new_identity_fold[crate_ctxt]();\n+\n+    fld1 = @rec(fold_item_fn = bind check_item_fn_state(_,_,_,_,_,_,_),\n+                fold_obj     = bind check_obj_state(_,_,_,_)\n+                with *fld1);\n+    \n+    ret fold_crate[crate_ctxt](ccx, fld1, with_pre_postconditions);\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "79761ceb72df14023cbe11f6c7a0732cd71f53e6", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,122 @@\n+import std::_vec;\n+import std::_vec::plus_option;\n+\n+import front::ast;\n+import front::ast::crate;\n+import front::ast::ann;\n+import front::ast::arg;\n+import front::ast::method;\n+import front::ast::local;\n+import front::ast::item;\n+import front::ast::item_fn;\n+import front::ast::item_obj;\n+import front::ast::_obj;\n+import front::ast::obj_def_ids;\n+import front::ast::_fn;\n+import front::ast::ty_param;\n+import front::ast::_mod;\n+import front::ast::decl;\n+import front::ast::decl_local;\n+import front::ast::def_id;\n+import front::ast::ident;\n+import middle::fold::span;\n+import middle::fold::respan;\n+import middle::fold::new_identity_fold;\n+import middle::fold::fold_block;\n+import middle::fold::fold_fn;\n+import middle::fold::fold_crate;\n+\n+import aux::fn_info;\n+import aux::var_info;\n+import aux::crate_ctxt;\n+\n+import util::common::new_def_hash;\n+\n+fn var_is_local(def_id v, fn_info m) -> bool {\n+  ret (m.vars.contains_key(v));\n+}\n+\n+fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, &@local loc)\n+    -> @decl {\n+    log(\"collect_local: pushing \" + loc.ident);\n+    _vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+    ret @respan(sp, decl_local(loc));\n+}\n+\n+fn find_locals(_fn f) -> @vec[tup(ident,def_id)] {\n+  auto res = @_vec::alloc[tup(ident,def_id)](0u);\n+\n+  auto fld = new_identity_fold[@vec[tup(ident, def_id)]]();\n+  fld = @rec(fold_decl_local = bind collect_local(_,_,_) with *fld);\n+  auto ignore = fold_fn[@vec[tup(ident, def_id)]](res, fld, f);\n+\n+  ret res;\n+}\n+\n+\n+fn add_var(def_id v, ident nm, uint next, fn_info tbl) -> uint {\n+  log(nm + \" |-> \" + util::common::uistr(next));\n+  tbl.vars.insert(v, tup(next,nm));\n+  ret (next + 1u);\n+}\n+\n+/* builds a table mapping each local var defined in f\n+   to a bit number in the precondition/postcondition vectors */\n+fn mk_fn_info(_fn f, def_id f_id, ident f_name) -> fn_info {\n+    auto res = rec(vars=@new_def_hash[var_info](),\n+                   cf=f.decl.cf);\n+    let uint next = 0u;\n+    let vec[arg] f_args = f.decl.inputs;\n+\n+    /* ignore args, which we know are initialized;\n+       just collect locally declared vars */\n+\n+    let @vec[tup(ident,def_id)] locals = find_locals(f);\n+    // log (uistr(_vec::len[tup(ident, def_id)](locals)) + \" locals\");\n+    for (tup(ident,def_id) p in *locals) {\n+        next = add_var(p._1, p._0, next, res);\n+    }\n+    /* add a pseudo-entry for the function's return value\n+       we can safely use the function's name itself for this purpose */\n+    add_var(f_id, f_name, next, res);\n+\n+    ret res;\n+}\n+\n+/* extends mk_fn_info to a function item, side-effecting the map fi from\n+   function IDs to fn_info maps */\n+fn mk_fn_info_item_fn(&crate_ctxt ccx, &span sp, &ident i, &_fn f,\n+                 &vec[ty_param] ty_params, &def_id id, &ann a) -> @item {\n+    auto f_inf = mk_fn_info(f, id, i);\n+    ccx.fm.insert(id, f_inf);\n+    //  log_err(\"inserting: \" + i);\n+    ret @respan(sp, item_fn(i, f, ty_params, id, a));\n+}\n+\n+/* extends mk_fn_info to an obj item, side-effecting the map fi from\n+   function IDs to fn_info maps */\n+fn mk_fn_info_item_obj(&crate_ctxt ccx, &span sp, &ident i, &_obj o,\n+                       &vec[ty_param] ty_params,\n+                       &obj_def_ids odid, &ann a) -> @item {\n+    auto all_methods = _vec::clone[@method](o.methods);\n+    plus_option[@method](all_methods, o.dtor);\n+    auto f_inf;\n+    for (@method m in all_methods) {\n+        f_inf = mk_fn_info(m.node.meth, m.node.id, m.node.ident);\n+        ccx.fm.insert(m.node.id, f_inf);\n+    }\n+    ret @respan(sp, item_obj(i, o, ty_params, odid, a));\n+}\n+\n+\n+/* initializes the global fn_info_map (mapping each function ID, including\n+   nested locally defined functions, onto a mapping from local variable name\n+   to bit number) */\n+fn mk_f_to_fn_info(&crate_ctxt ccx, @crate c) -> () {\n+\n+  auto fld = new_identity_fold[crate_ctxt]();\n+  fld = @rec(fold_item_fn  = bind mk_fn_info_item_fn(_,_,_,_,_,_,_),\n+             fold_item_obj = bind mk_fn_info_item_obj(_,_,_,_,_,_,_)\n+               with *fld);\n+  fold_crate[crate_ctxt](ccx, fld, c);\n+}"}, {"sha": "68c40191fa6dea11c3841f5abba08453f59db86a", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "added", "additions": 711, "deletions": 0, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,711 @@\n+import std::_vec;\n+import std::_vec::plus_option;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+\n+import tstate::ann::pre_and_post;\n+import tstate::ann::get_post;\n+import tstate::ann::postcond;\n+import tstate::ann::true_precond;\n+import tstate::ann::false_postcond;\n+import tstate::ann::empty_pre_post;\n+import tstate::ann::empty_poststate;\n+import tstate::ann::require_and_preserve;\n+import tstate::ann::union;\n+import tstate::ann::intersect;\n+import tstate::ann::pp_clone;\n+import tstate::ann::empty_prestate;\n+import aux::var_info;\n+import aux::crate_ctxt;\n+import aux::fn_ctxt;\n+import aux::num_locals;\n+import aux::expr_pp;\n+import aux::stmt_pp;\n+import aux::block_pp;\n+import aux::set_pre_and_post;\n+import aux::expr_precond;\n+import aux::expr_postcond;\n+import aux::expr_prestate;\n+import aux::expr_poststate;\n+import aux::block_postcond;\n+import aux::fn_info;\n+import aux::log_pp;\n+import aux::ann_to_def;\n+import aux::ann_to_def_strict;\n+\n+import bitvectors::seq_preconds;\n+import bitvectors::union_postconds;\n+import bitvectors::intersect_postconds;\n+import bitvectors::declare_var;\n+import bitvectors::bit_num;\n+import bitvectors::gen;\n+\n+import front::ast::_mod;\n+import front::ast;\n+import front::ast::method;\n+import front::ast::ann;\n+import front::ast::ty;\n+import front::ast::mutability;\n+import front::ast::item;\n+import front::ast::item_const;\n+import front::ast::item_mod;\n+import front::ast::item_ty;\n+import front::ast::item_tag;\n+import front::ast::item_native_mod;\n+import front::ast::obj_field;\n+import front::ast::stmt;\n+import front::ast::stmt_;\n+import front::ast::stmt_decl;\n+import front::ast::ident;\n+import front::ast::def_id;\n+import front::ast::ann;\n+import front::ast::expr;\n+import front::ast::path;\n+import front::ast::crate_directive;\n+import front::ast::fn_decl;\n+import front::ast::_obj;\n+import front::ast::native_mod;\n+import front::ast::variant;\n+import front::ast::ty_param;\n+import front::ast::ty;\n+import front::ast::proto;\n+import front::ast::pat;\n+import front::ast::binop;\n+import front::ast::unop;\n+import front::ast::def;\n+import front::ast::lit;\n+import front::ast::init_op;\n+import front::ast::controlflow;\n+import front::ast::return;\n+import front::ast::noreturn;\n+import front::ast::_fn;\n+import front::ast::ann_none;\n+import front::ast::ann_type;\n+import front::ast::_obj;\n+import front::ast::_mod;\n+import front::ast::crate;\n+import front::ast::item_fn;\n+import front::ast::item_obj;\n+import front::ast::def_local;\n+import front::ast::def_fn;\n+import front::ast::ident;\n+import front::ast::def_id;\n+import front::ast::ann;\n+import front::ast::item;\n+import front::ast::item_fn;\n+import front::ast::expr;\n+import front::ast::elt;\n+import front::ast::field;\n+import front::ast::decl;\n+import front::ast::decl_local;\n+import front::ast::decl_item;\n+import front::ast::initializer;\n+import front::ast::local;\n+import front::ast::arm;\n+import front::ast::expr_call;\n+import front::ast::expr_vec;\n+import front::ast::expr_tup;\n+import front::ast::expr_path;\n+import front::ast::expr_field;\n+import front::ast::expr_index;\n+import front::ast::expr_log;\n+import front::ast::expr_block;\n+import front::ast::expr_rec;\n+import front::ast::expr_if;\n+import front::ast::expr_binary;\n+import front::ast::expr_unary;\n+import front::ast::expr_assign;\n+import front::ast::expr_assign_op;\n+import front::ast::expr_while;\n+import front::ast::expr_do_while;\n+import front::ast::expr_alt;\n+import front::ast::expr_lit;\n+import front::ast::expr_ret;\n+import front::ast::expr_self_method;\n+import front::ast::expr_bind;\n+import front::ast::expr_spawn;\n+import front::ast::expr_ext;\n+import front::ast::expr_fail;\n+import front::ast::expr_break;\n+import front::ast::expr_cont;\n+import front::ast::expr_send;\n+import front::ast::expr_recv;\n+import front::ast::expr_put;\n+import front::ast::expr_port;\n+import front::ast::expr_chan;\n+import front::ast::expr_be;\n+import front::ast::expr_check;\n+import front::ast::expr_assert;\n+import front::ast::expr_cast;\n+import front::ast::expr_for;\n+import front::ast::expr_for_each;\n+import front::ast::stmt;\n+import front::ast::stmt_decl;\n+import front::ast::stmt_expr;\n+import front::ast::block;\n+import front::ast::block_;\n+import front::ast::method;\n+\n+import middle::fold::span;\n+import middle::fold::respan;\n+\n+import util::common::new_def_hash;\n+import util::common::decl_lhs;\n+import util::common::uistr;\n+import util::common::log_expr;\n+import util::common::log_fn;\n+import util::common::elt_exprs;\n+import util::common::field_exprs;\n+import util::common::has_nonlocal_exits;\n+import util::common::log_stmt;\n+import util::common::log_expr_err;\n+\n+fn find_pre_post_mod(&_mod m) -> _mod {\n+    log(\"implement find_pre_post_mod!\");\n+    fail;\n+}\n+\n+fn find_pre_post_native_mod(&native_mod m) -> native_mod {\n+    log(\"implement find_pre_post_native_mod\");\n+    fail;\n+}\n+\n+\n+fn find_pre_post_obj(&crate_ctxt ccx, _obj o) -> () {\n+    fn do_a_method(crate_ctxt ccx, &@method m) -> () {\n+        assert (ccx.fm.contains_key(m.node.id));\n+        let fn_ctxt fcx = rec(enclosing=ccx.fm.get(m.node.id),\n+                       id=m.node.id, name=m.node.ident, ccx=ccx);\n+        find_pre_post_fn(fcx, m.node.meth);\n+    }\n+    auto f = bind do_a_method(ccx,_);\n+    _vec::map[@method, ()](f, o.methods);\n+    option::map[@method, ()](f, o.dtor);\n+}\n+\n+fn find_pre_post_item(&crate_ctxt ccx, &item i) -> () {\n+    alt (i.node) {\n+        case (item_const(?id, ?t, ?e, ?di, ?a)) {\n+            // make a fake fcx\n+            auto fake_fcx = rec(enclosing=rec(vars=@new_def_hash[var_info](),\n+                                              cf=return),\n+                                id=tup(0,0),\n+                                name=\"\",\n+                                ccx=ccx);\n+            find_pre_post_expr(fake_fcx, e);\n+        }\n+        case (item_fn(?id, ?f, ?ps, ?di, ?a)) {\n+            assert (ccx.fm.contains_key(di));\n+            auto fcx = rec(enclosing=ccx.fm.get(di),\n+                           id=di, name=id, ccx=ccx);\n+            find_pre_post_fn(fcx, f);\n+        }\n+        case (item_mod(?id, ?m, ?di)) {\n+            find_pre_post_mod(m);\n+        }\n+        case (item_native_mod(?id, ?nm, ?di)) {\n+            find_pre_post_native_mod(nm);\n+        }\n+        case (item_ty(_,_,_,_,_)) {\n+            ret;\n+        }\n+        case (item_tag(_,_,_,_,_)) {\n+            ret;\n+        }\n+        case (item_obj(?id, ?o, ?ps, ?di, ?a)) {\n+            find_pre_post_obj(ccx, o);\n+        }\n+    }\n+}\n+\n+/* Finds the pre and postcondition for each expr in <args>;\n+   sets the precondition in a to be the result of combining\n+   the preconditions for <args>, and the postcondition in a to \n+   be the union of all postconditions for <args> */\n+fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n+    auto enclosing = fcx.enclosing;\n+    auto fm        = fcx.ccx.fm;\n+    auto nv        = num_locals(enclosing);\n+\n+    fn do_one(fn_ctxt fcx, &@expr e) -> () {\n+        find_pre_post_expr(fcx, e);\n+    }\n+    auto f = bind do_one(fcx, _);\n+\n+    _vec::map[@expr, ()](f, args);\n+\n+    fn get_pp(&@expr e) -> pre_and_post {\n+        ret expr_pp(e);\n+    }\n+    auto g = get_pp;\n+    auto pps = _vec::map[@expr, pre_and_post](g, args);\n+    auto h = get_post;\n+\n+    set_pre_and_post(a,\n+       rec(precondition=seq_preconds(enclosing, pps),\n+           postcondition=union_postconds\n+           (nv, (_vec::map[pre_and_post, postcond](h, pps)))));\n+}\n+\n+fn find_pre_post_loop(&fn_ctxt fcx, &@decl d, &@expr index,\n+      &block body, &ann a) -> () {\n+    find_pre_post_expr(fcx, index);\n+    find_pre_post_block(fcx, body);\n+    auto loop_precond = declare_var(fcx.enclosing, decl_lhs(d),\n+           seq_preconds(fcx.enclosing, vec(expr_pp(index),\n+                                       block_pp(body))));\n+    auto loop_postcond = intersect_postconds\n+        (vec(expr_postcond(index), block_postcond(body)));\n+    set_pre_and_post(a, rec(precondition=loop_precond,\n+                            postcondition=loop_postcond));\n+}\n+\n+fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, &ann larger_ann, &ann new_var) -> () {\n+  alt (ann_to_def(fcx.ccx, new_var)) {\n+    case (some[def](def_local(?d_id))) {\n+      find_pre_post_expr(fcx, rhs);\n+      set_pre_and_post(larger_ann, expr_pp(rhs));\n+      gen(fcx, larger_ann, d_id);\n+    }\n+    case (_) { find_pre_post_exprs(fcx, vec(lhs, rhs), larger_ann); }\n+  }\n+}\n+\n+/* Fills in annotations as a side effect. Does not rebuild the expr */\n+fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n+    auto enclosing      = fcx.enclosing;\n+    auto num_local_vars = num_locals(enclosing);\n+\n+    fn do_rand_(fn_ctxt fcx, &@expr e) -> () {\n+        find_pre_post_expr(fcx, e);\n+    }\n+    fn pp_one(&@expr e) -> pre_and_post {\n+        ret expr_pp(e);\n+    }\n+    \n+    /*\n+    log_err(\"find_pre_post_expr (num_locals =\" +\n+        uistr(num_local_vars) + \"):\");\n+    log_expr_err(*e);\n+    */\n+\n+    alt (e.node) {\n+        case (expr_call(?operator, ?operands, ?a)) {\n+            auto args = _vec::clone[@expr](operands);\n+            _vec::push[@expr](args, operator);\n+            find_pre_post_exprs(fcx, args, a);\n+        }\n+        case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n+            auto args = _vec::clone[@expr](operands);\n+            _vec::push[@expr](args, operator);\n+            find_pre_post_exprs(fcx, args, a);\n+        }\n+        case (expr_vec(?args, _, ?a)) {\n+            find_pre_post_exprs(fcx, args, a);\n+        }\n+        case (expr_tup(?elts, ?a)) {\n+            find_pre_post_exprs(fcx, elt_exprs(elts), a);\n+        }\n+        case (expr_path(?p, ?a)) {\n+            auto res = empty_pre_post(num_local_vars);\n+\t    \n+\t    auto df = ann_to_def_strict(fcx.ccx, a);\n+            alt (df) {\n+                case (def_local(?d_id)) {\n+                    auto i = bit_num(d_id, enclosing);\n+                    require_and_preserve(i, res);\n+                }\n+                case (_) { /* nothing to check */ }\n+            }\n+\n+            // Otherwise, variable is global, so it must be initialized\n+            set_pre_and_post(a, res);\n+        }\n+        case (expr_self_method(?v, ?a)) {\n+            /* v is a method of the enclosing obj, so it must be\n+               initialized, right? */\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n+        case(expr_log(_, ?arg, ?a)) {\n+            find_pre_post_expr(fcx, arg);\n+            set_pre_and_post(a, expr_pp(arg));\n+        }\n+        case (expr_chan(?arg, ?a)) {\n+            find_pre_post_expr(fcx, arg);\n+            set_pre_and_post(a, expr_pp(arg));\n+        }\n+        case(expr_put(?opt, ?a)) {\n+            alt (opt) {\n+                case (some[@expr](?arg)) {\n+                    find_pre_post_expr(fcx, arg);\n+                    set_pre_and_post(a, expr_pp(arg));\n+                }\n+                case (none[@expr]) {\n+                    set_pre_and_post(a, empty_pre_post(num_local_vars));\n+                }\n+            }\n+        }\n+        case (expr_block(?b, ?a)) {\n+            find_pre_post_block(fcx, b);\n+            set_pre_and_post(a, block_pp(b));\n+        }\n+        case (expr_rec(?fields,?maybe_base,?a)) {\n+            auto es = field_exprs(fields);\n+            _vec::plus_option[@expr](es, maybe_base);\n+            find_pre_post_exprs(fcx, es, a);\n+        }\n+        case (expr_assign(?lhs, ?rhs, ?a)) {\n+            alt (lhs.node) {\n+                case (expr_path(?p, ?a_lhs)) {\n+\t\t  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n+                }\n+                case (_) {\n+                    find_pre_post_exprs(fcx, vec(lhs, rhs), a);\n+                }\n+            }\n+        }\n+        case (expr_recv(?lhs, ?rhs, ?a)) {\n+            alt (lhs.node) {\n+                case (expr_path(?p, ?a_lhs)) {\n+\t\t  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n+                }\n+                case (_) {\n+                    // doesn't check that lhs is an lval, but\n+                    // that's probably ok\n+                    find_pre_post_exprs(fcx, vec(lhs, rhs), a);\n+                }\n+            }\n+        }\n+        case (expr_assign_op(_, ?lhs, ?rhs, ?a)) {\n+            /* Different from expr_assign in that the lhs *must*\n+               already be initialized */\n+            find_pre_post_exprs(fcx, vec(lhs, rhs), a);\n+        }\n+        case (expr_lit(_,?a)) {\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n+        case (expr_ret(?maybe_val, ?a)) {\n+            alt (maybe_val) {\n+                case (none[@expr]) {\n+                    set_pre_and_post(a,\n+                      rec(precondition=true_precond(num_local_vars),\n+                          postcondition=false_postcond(num_local_vars)));\n+                }\n+                case (some[@expr](?ret_val)) {\n+                    find_pre_post_expr(fcx, ret_val);\n+                    let pre_and_post pp =\n+                        rec(precondition=expr_precond(ret_val),\n+                            postcondition=false_postcond(num_local_vars));\n+                    set_pre_and_post(a, pp);\n+                }\n+            }\n+        }\n+        case (expr_be(?e, ?a)) {\n+            find_pre_post_expr(fcx, e);\n+            set_pre_and_post(a,\n+               rec(precondition=expr_prestate(e),\n+                   postcondition=false_postcond(num_local_vars)));\n+        }\n+        case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n+            find_pre_post_expr(fcx, antec);\n+            find_pre_post_block(fcx, conseq);\n+            alt (maybe_alt) {\n+                case (none[@expr]) {\n+                    auto precond_res = seq_preconds(enclosing,\n+                                                    vec(expr_pp(antec),\n+                                                        block_pp(conseq)));\n+                    set_pre_and_post(a, rec(precondition=precond_res,\n+                                            postcondition=\n+                                            expr_poststate(antec)));\n+                }\n+                case (some[@expr](?altern)) {\n+                    find_pre_post_expr(fcx, altern);\n+                    auto precond_true_case =\n+                        seq_preconds(enclosing,\n+                                     vec(expr_pp(antec), block_pp(conseq)));\n+                    auto postcond_true_case = union_postconds\n+                        (num_local_vars,\n+                         vec(expr_postcond(antec), block_postcond(conseq)));\n+                    auto precond_false_case = seq_preconds\n+                        (enclosing,\n+                         vec(expr_pp(antec), expr_pp(altern)));\n+                    auto postcond_false_case = union_postconds\n+                        (num_local_vars,\n+                         vec(expr_postcond(antec), expr_postcond(altern)));\n+                    auto precond_res = union_postconds\n+                        (num_local_vars,\n+                         vec(precond_true_case, precond_false_case));\n+                    auto postcond_res = intersect_postconds\n+                        (vec(postcond_true_case, postcond_false_case));\n+                    set_pre_and_post(a, rec(precondition=precond_res,\n+                                            postcondition=postcond_res));\n+                }\n+            }\n+        }\n+        case (expr_binary(?bop,?l,?r,?a)) {\n+            /* *unless* bop is lazy (e.g. and, or)? \n+               FIXME */\n+            find_pre_post_exprs(fcx, vec(l, r), a);\n+        }\n+        case (expr_send(?l, ?r, ?a)) {\n+            find_pre_post_exprs(fcx, vec(l, r), a);\n+        }\n+        case (expr_unary(_,?operand,?a)) {\n+            find_pre_post_expr(fcx, operand);\n+            set_pre_and_post(a, expr_pp(operand));\n+        }\n+        case (expr_cast(?operand, _, ?a)) {\n+            find_pre_post_expr(fcx, operand);\n+            set_pre_and_post(a, expr_pp(operand));\n+        }\n+        case (expr_while(?test, ?body, ?a)) {\n+            find_pre_post_expr(fcx, test);\n+            find_pre_post_block(fcx, body);\n+            set_pre_and_post(a,\n+              rec(precondition=\n+                    seq_preconds(enclosing,\n+                               vec(expr_pp(test), \n+                                   block_pp(body))),\n+                  postcondition=\n+                    intersect_postconds(vec(expr_postcond(test),\n+                                            block_postcond(body)))));\n+        }\n+        case (expr_do_while(?body, ?test, ?a)) {\n+            find_pre_post_block(fcx, body);\n+            find_pre_post_expr(fcx, test);\n+   \n+            auto loop_postcond = union_postconds(num_local_vars,\n+                   vec(block_postcond(body), expr_postcond(test)));\n+            /* conservative approximination: if the body\n+               could break or cont, the test may never be executed */\n+            if (has_nonlocal_exits(body)) {\n+                loop_postcond = empty_poststate(num_local_vars);\n+            }\n+\n+            set_pre_and_post(a, \n+              rec(precondition=seq_preconds(enclosing,\n+                                            vec(block_pp(body),\n+                                                expr_pp(test))),\n+                  postcondition=loop_postcond));\n+        }\n+        case (expr_for(?d, ?index, ?body, ?a)) {\n+            find_pre_post_loop(fcx, d, index, body, a);\n+        }\n+        case (expr_for_each(?d, ?index, ?body, ?a)) {\n+            find_pre_post_loop(fcx, d, index, body, a);\n+        }\n+        case (expr_index(?e, ?sub, ?a)) {\n+            find_pre_post_exprs(fcx, vec(e, sub), a);\n+        }\n+        case (expr_alt(?e, ?alts, ?a)) {\n+            find_pre_post_expr(fcx, e);\n+            fn do_an_alt(&fn_ctxt fcx, &arm an_alt) -> pre_and_post {\n+                find_pre_post_block(fcx, an_alt.block);\n+                ret block_pp(an_alt.block);\n+            }\n+            auto f = bind do_an_alt(fcx, _);\n+            auto alt_pps = _vec::map[arm, pre_and_post](f, alts);\n+            fn combine_pp(pre_and_post antec, \n+                          fn_info enclosing, &pre_and_post pp,\n+                          &pre_and_post next) -> pre_and_post {\n+                union(pp.precondition, seq_preconds(enclosing,\n+                                                    vec(antec, next)));\n+                intersect(pp.postcondition, next.postcondition);\n+                ret pp;\n+            }\n+            auto antec_pp = pp_clone(expr_pp(e)); \n+            auto e_pp  = rec(precondition=empty_prestate(num_local_vars),\n+                             postcondition=false_postcond(num_local_vars));\n+            auto g = bind combine_pp(antec_pp, fcx.enclosing, _, _);\n+\n+            auto alts_overall_pp = _vec::foldl[pre_and_post, pre_and_post]\n+                                    (g, e_pp, alt_pps);\n+\n+            set_pre_and_post(a, alts_overall_pp);\n+        }\n+        case (expr_field(?operator, _, ?a)) {\n+            find_pre_post_expr(fcx, operator);\n+            set_pre_and_post(a, expr_pp(operator));\n+        }\n+        case (expr_fail(?a)) {\n+            set_pre_and_post(a,\n+                             /* if execution continues after fail,\n+                                then everything is true! */\n+               rec(precondition=empty_prestate(num_local_vars),\n+                   postcondition=false_postcond(num_local_vars)));\n+        }\n+        case (expr_assert(?p, ?a)) {\n+            find_pre_post_expr(fcx, p);\n+            set_pre_and_post(a, expr_pp(p));\n+        }\n+        case (expr_check(?p, ?a)) {\n+            /* will need to change when we support arbitrary predicates... */\n+            find_pre_post_expr(fcx, p);\n+            set_pre_and_post(a, expr_pp(p));\n+        }\n+        case(expr_bind(?operator, ?maybe_args, ?a)) {\n+            auto args = _vec::cat_options[@expr](maybe_args);\n+            _vec::push[@expr](args, operator); /* ??? order of eval? */\n+            find_pre_post_exprs(fcx, args, a);\n+        }\n+        case (expr_break(?a)) {\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n+        case (expr_cont(?a)) {\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n+        case (expr_port(?a)) {\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n+        case (expr_ext(_, _, _, ?expanded, ?a)) {\n+            find_pre_post_expr(fcx, expanded);\n+            set_pre_and_post(a, expr_pp(expanded));\n+        }\n+    }\n+}\n+\n+\n+fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n+    -> () {\n+    log(\"stmt =\");\n+    log_stmt(s);\n+\n+    auto enclosing      = fcx.enclosing;\n+    auto num_local_vars = num_locals(enclosing);\n+    alt(s.node) {\n+        case(stmt_decl(?adecl, ?a)) {\n+            alt(adecl.node) {\n+                case(decl_local(?alocal)) {\n+                    alt(alocal.init) {\n+                        case(some[initializer](?an_init)) {\n+                            find_pre_post_expr(fcx, an_init.expr);\n+                            auto rhs_pp = expr_pp(an_init.expr);\n+                            set_pre_and_post(alocal.ann, rhs_pp);\n+\n+                            /* Inherit ann from initializer, and add var being\n+                               initialized to the postcondition */\n+                            set_pre_and_post(a, rhs_pp);\n+                            /*  log(\"gen (decl):\");\n+                                log_stmt(s); */\n+                            gen(fcx, a, alocal.id); \n+                            /*                     log_err(\"for stmt\");\n+                                                   log_stmt(s);\n+                                                   log_err(\"pp = \");\n+                                                   log_pp(stmt_pp(s)); */\n+                        }\n+                        case(none[initializer]) {\n+                            auto pp = empty_pre_post(num_local_vars);\n+                            set_pre_and_post(alocal.ann, pp);\n+                            set_pre_and_post(a, pp);\n+                        }\n+                    }\n+                }\n+                case(decl_item(?anitem)) {\n+                    auto pp = empty_pre_post(num_local_vars);\n+                    set_pre_and_post(a, pp);\n+                    find_pre_post_item(fcx.ccx, *anitem);\n+                }\n+            }\n+        }\n+        case(stmt_expr(?e,?a)) {\n+            find_pre_post_expr(fcx, e);\n+            set_pre_and_post(a, expr_pp(e));\n+        }    \n+    }\n+}\n+\n+fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n+    /* Want to say that if there is a break or cont in this\n+     block, then that invalidates the poststate upheld by\n+    any of the stmts after it. \n+    Given that the typechecker has run, we know any break will be in\n+    a block that forms a loop body. So that's ok. There'll never be an\n+    expr_break outside a loop body, therefore, no expr_break outside a block.\n+    */\n+\n+    /* Conservative approximation for now: This says that if a block contains\n+     *any* breaks or conts, then its postcondition doesn't promise anything.\n+     This will mean that:\n+     x = 0;\n+     break;\n+\n+     won't have a postcondition that says x is initialized, but that's ok.\n+     */\n+    auto nv = num_locals(fcx.enclosing);\n+\n+    fn do_one_(fn_ctxt fcx, &@stmt s) -> () {\n+        find_pre_post_stmt(fcx, *s);\n+        log(\"pre_post for stmt:\");\n+        log_stmt(*s);\n+        log(\"is:\");\n+        log_pp(stmt_pp(*s));\n+    }\n+    auto do_one = bind do_one_(fcx, _);\n+    \n+    _vec::map[@stmt, ()](do_one, b.node.stmts);\n+    fn do_inner_(fn_ctxt fcx, &@expr e) -> () {\n+        find_pre_post_expr(fcx, e);\n+    }\n+    auto do_inner = bind do_inner_(fcx, _);\n+    option::map[@expr, ()](do_inner, b.node.expr);\n+\n+    let vec[pre_and_post] pps = vec();\n+\n+    fn get_pp_stmt(&@stmt s) -> pre_and_post {\n+        ret stmt_pp(*s);\n+    }\n+    auto f = get_pp_stmt;\n+    pps += _vec::map[@stmt, pre_and_post](f, b.node.stmts);\n+    fn get_pp_expr(&@expr e) -> pre_and_post {\n+        ret expr_pp(e);\n+    }\n+    auto g = get_pp_expr;\n+    plus_option[pre_and_post](pps,\n+       option::map[@expr, pre_and_post](g, b.node.expr));\n+\n+    auto block_precond  = seq_preconds(fcx.enclosing, pps);\n+    auto h = get_post;\n+    auto postconds =  _vec::map[pre_and_post, postcond](h, pps);\n+    /* A block may be empty, so this next line ensures that the postconds\n+       vector is non-empty. */\n+    _vec::push[postcond](postconds, block_precond);\n+    auto block_postcond = empty_poststate(nv);\n+    /* conservative approximation */\n+    if (! has_nonlocal_exits(b)) {\n+        block_postcond = union_postconds(nv, postconds);\n+    }\n+\n+    set_pre_and_post(b.node.a, rec(precondition=block_precond,\n+                                   postcondition=block_postcond));\n+}\n+\n+fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) -> () {\n+    find_pre_post_block(fcx, f.body);\n+}\n+\n+fn check_item_fn(&crate_ctxt ccx, &span sp, &ident i, &_fn f,\n+                 &vec[ty_param] ty_params,\n+                 &def_id id, &ann a) -> @item {\n+    log(\"check_item_fn:\");\n+    log_fn(f, i, ty_params);\n+\n+    assert (ccx.fm.contains_key(id));\n+    auto fcx = rec(enclosing=ccx.fm.get(id),\n+                   id=id, name=i, ccx=ccx);\n+    find_pre_post_fn(fcx, f);  \n+\n+    ret @respan(sp, item_fn(i, f, ty_params, id, a));\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//\n+"}, {"sha": "58de564dab560235b8978e144c099bafaf3f7e03", "filename": "src/comp/middle/tstate/states.rs", "status": "added", "additions": 802, "deletions": 0, "changes": 802, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,802 @@\n+import std::bitv;\n+import std::_vec;\n+import std::_vec::plus_option;\n+import std::_vec::cat_options;\n+import std::option;\n+import std::option::get;\n+import std::option::is_none;\n+import std::option::none;\n+import std::option::some;\n+import std::option::maybe;\n+\n+import tstate::ann::pre_and_post;\n+import tstate::ann::get_post;\n+import tstate::ann::postcond;\n+import tstate::ann::empty_pre_post;\n+import tstate::ann::empty_poststate;\n+import tstate::ann::require_and_preserve;\n+import tstate::ann::union;\n+import tstate::ann::intersect;\n+import tstate::ann::pp_clone;\n+import tstate::ann::empty_prestate;\n+import tstate::ann::prestate;\n+import tstate::ann::poststate;\n+import tstate::ann::false_postcond;\n+import tstate::ann::ts_ann;\n+import tstate::ann::extend_prestate;\n+import tstate::ann::extend_poststate;\n+import aux::var_info;\n+import aux::crate_ctxt;\n+import aux::fn_ctxt;\n+import aux::num_locals;\n+import aux::expr_pp;\n+import aux::stmt_pp;\n+import aux::block_pp;\n+import aux::set_pre_and_post;\n+import aux::expr_prestate;\n+import aux::stmt_poststate;\n+import aux::expr_poststate;\n+import aux::block_poststate;\n+import aux::fn_info;\n+import aux::log_pp;\n+import aux::extend_prestate_ann;\n+import aux::extend_poststate_ann;\n+import aux::set_prestate_ann;\n+import aux::set_poststate_ann;\n+import aux::pure_exp;\n+import aux::log_bitv;\n+import aux::stmt_to_ann;\n+import aux::log_states;\n+import aux::block_states;\n+import aux::controlflow_expr;\n+import aux::ann_to_def;\n+\n+import bitvectors::seq_preconds;\n+import bitvectors::union_postconds;\n+import bitvectors::intersect_postconds;\n+import bitvectors::declare_var;\n+import bitvectors::bit_num;\n+import bitvectors::gen_poststate;\n+\n+import front::ast::_mod;\n+import front::ast;\n+import front::ast::_fn;\n+import front::ast::method;\n+import front::ast::ann;\n+import front::ast::ty;\n+import front::ast::mutability;\n+import front::ast::item;\n+import front::ast::obj_field;\n+import front::ast::stmt;\n+import front::ast::stmt_;\n+import front::ast::stmt_decl;\n+import front::ast::ident;\n+import front::ast::def_id;\n+import front::ast::ann;\n+import front::ast::expr;\n+import front::ast::path;\n+import front::ast::crate_directive;\n+import front::ast::fn_decl;\n+import front::ast::_obj;\n+import front::ast::native_mod;\n+import front::ast::variant;\n+import front::ast::ty_param;\n+import front::ast::ty;\n+import front::ast::proto;\n+import front::ast::pat;\n+import front::ast::binop;\n+import front::ast::unop;\n+import front::ast::def;\n+import front::ast::lit;\n+import front::ast::init_op;\n+import front::ast::controlflow;\n+import front::ast::return;\n+import front::ast::noreturn;\n+import front::ast::ann_none;\n+import front::ast::ann_type;\n+import front::ast::_obj;\n+import front::ast::_mod;\n+import front::ast::crate;\n+import front::ast::item_fn;\n+import front::ast::item_mod;\n+import front::ast::item_ty;\n+import front::ast::item_tag;\n+import front::ast::item_native_mod;\n+import front::ast::item_obj;\n+import front::ast::item_const;\n+import front::ast::def_local;\n+import front::ast::def_fn;\n+import front::ast::ident;\n+import front::ast::def_id;\n+import front::ast::ann;\n+import front::ast::item;\n+import front::ast::item_fn;\n+import front::ast::expr;\n+import front::ast::elt;\n+import front::ast::field;\n+import front::ast::decl;\n+import front::ast::decl_local;\n+import front::ast::decl_item;\n+import front::ast::initializer;\n+import front::ast::local;\n+import front::ast::arm;\n+import front::ast::expr_call;\n+import front::ast::expr_vec;\n+import front::ast::expr_tup;\n+import front::ast::expr_path;\n+import front::ast::expr_field;\n+import front::ast::expr_index;\n+import front::ast::expr_log;\n+import front::ast::expr_block;\n+import front::ast::expr_rec;\n+import front::ast::expr_if;\n+import front::ast::expr_binary;\n+import front::ast::expr_unary;\n+import front::ast::expr_assign;\n+import front::ast::expr_assign_op;\n+import front::ast::expr_while;\n+import front::ast::expr_do_while;\n+import front::ast::expr_alt;\n+import front::ast::expr_lit;\n+import front::ast::expr_ret;\n+import front::ast::expr_self_method;\n+import front::ast::expr_bind;\n+import front::ast::expr_spawn;\n+import front::ast::expr_ext;\n+import front::ast::expr_fail;\n+import front::ast::expr_break;\n+import front::ast::expr_cont;\n+import front::ast::expr_send;\n+import front::ast::expr_recv;\n+import front::ast::expr_put;\n+import front::ast::expr_port;\n+import front::ast::expr_chan;\n+import front::ast::expr_be;\n+import front::ast::expr_check;\n+import front::ast::expr_assert;\n+import front::ast::expr_cast;\n+import front::ast::expr_for;\n+import front::ast::expr_for_each;\n+import front::ast::stmt;\n+import front::ast::stmt_decl;\n+import front::ast::stmt_expr;\n+import front::ast::block;\n+import front::ast::block_;\n+import front::ast::method;\n+\n+import middle::fold::span;\n+import middle::fold::respan;\n+\n+import util::common::new_def_hash;\n+import util::common::decl_lhs;\n+import util::common::uistr;\n+import util::common::log_expr;\n+import util::common::log_block;\n+import util::common::log_fn;\n+import util::common::elt_exprs;\n+import util::common::field_exprs;\n+import util::common::has_nonlocal_exits;\n+import util::common::log_stmt;\n+import util::common::log_expr_err;\n+\n+fn find_pre_post_state_mod(&_mod m) -> bool {\n+    log(\"implement find_pre_post_state_mod!\");\n+    fail;\n+}\n+\n+fn find_pre_post_state_native_mod(&native_mod m) -> bool {\n+    log(\"implement find_pre_post_state_native_mod!\");\n+    fail;\n+}\n+\n+fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs)\n+     -> tup(bool, poststate) {\n+  auto changed = false;\n+  auto post = pres;\n+\n+  for (@expr e in exprs) {\n+    changed = find_pre_post_state_expr(fcx, post, e) || changed;\n+    post = expr_poststate(e);\n+  }\n+\n+  ret tup(changed, post);\n+}\n+\n+fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres,\n+                             &ann a, &vec[@expr] es) -> bool {\n+    auto res = seq_states(fcx, pres, es);\n+    auto changed = res._0;\n+    changed = extend_prestate_ann(a, pres) || changed;\n+    changed = extend_poststate_ann(a, res._1) || changed;\n+    ret changed;\n+}\n+\n+fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@decl d,\n+  &@expr index, &block body, &ann a) -> bool {\n+    auto changed = false;\n+\n+    /* same issues as while */\n+    changed = extend_prestate_ann(a, pres) || changed;\n+    changed = find_pre_post_state_expr(fcx, pres, index) || changed;\n+    /* in general, would need the intersection of\n+       (poststate of index, poststate of body) */\n+    changed = find_pre_post_state_block(fcx, expr_poststate(index), body)\n+                || changed;\n+    auto res_p = intersect_postconds(vec(expr_poststate(index),\n+                                         block_poststate(body)));\n+  \n+    changed = extend_poststate_ann(a, res_p) || changed;\n+    ret changed;\n+}\n+\n+fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a) -> bool {\n+  alt (ann_to_def(fcx.ccx, a_new_var)) {\n+    case (some[def](def_local(?d))) { ret gen_poststate(fcx, a, d); }\n+    case (_) { ret false; }\n+  }\n+}\n+\n+fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n+  auto changed = false;\n+  auto num_local_vars = num_locals(fcx.enclosing);\n+\n+  /*\n+  log_err(\"states:\");\n+  log_expr_err(*e);\n+  log_err(ast.ann_tag(middle.ty.expr_ann(e)));\n+  */\n+\n+  /* FIXME could get rid of some of the copy/paste */\n+  alt (e.node) {\n+    case (expr_vec(?elts, _, ?a)) {\n+        ret find_pre_post_state_exprs(fcx, pres, a, elts); \n+    }\n+    case (expr_tup(?elts, ?a)) {\n+      ret find_pre_post_state_exprs(fcx, pres, a, elt_exprs(elts));\n+    }\n+    case (expr_call(?operator, ?operands, ?a)) {\n+      /* do the prestate for the rator */\n+      changed = find_pre_post_state_expr(fcx, pres, operator)\n+        || changed;\n+      /* rands go left-to-right */\n+      changed = find_pre_post_state_exprs(fcx,\n+                                    expr_poststate(operator), a, operands)\n+          || changed;\n+      /* if this is a failing call, it sets the return value */\n+       alt (controlflow_expr(fcx.ccx, operator)) {\n+          case (noreturn) {\n+\t    /*\n+\t    log_err(\"Call that might fail! to\");\n+\t    log_expr_err(*operator);\n+\t    */\n+\t    changed = gen_poststate(fcx, a, fcx.id) || changed;\n+          }\n+          case (_) { \n+\t    /*\t    log_err(\"non-failing call, to:\");\n+\t    log_expr_err(*operator);\n+\t    */\n+\t  }\n+      }\n+      ret changed;\n+    }\n+    case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n+        changed = find_pre_post_state_expr(fcx, pres, operator);\n+        ret(find_pre_post_state_exprs(fcx,\n+                 expr_poststate(operator), a, operands)\n+          || changed);\n+    }\n+    case (expr_bind(?operator, ?maybe_args, ?a)) {\n+        changed = find_pre_post_state_expr(fcx, pres, operator)\n+            || changed;\n+        ret (find_pre_post_state_exprs(fcx,\n+          expr_poststate(operator), a, cat_options[@expr](maybe_args))\n+            || changed);\n+    }\n+    case (expr_path(_,?a)) {\n+      ret pure_exp(a, pres);\n+    }\n+    case (expr_log(_,?e,?a)) {\n+        /* factor out the \"one exp\" pattern */\n+        changed = find_pre_post_state_expr(fcx, pres, e);\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        ret changed;\n+    }\n+    case (expr_chan(?e, ?a)) {\n+        changed = find_pre_post_state_expr(fcx, pres, e);\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        ret changed;\n+    }\n+    case (expr_ext(_, _, _, ?expanded, ?a)) {\n+        changed = find_pre_post_state_expr(fcx, pres, expanded);\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(expanded))\n+           || changed;\n+        ret changed;\n+    }\n+    case (expr_put(?maybe_e, ?a)) {\n+        alt (maybe_e) {\n+            case (some[@expr](?arg)) {\n+                changed = find_pre_post_state_expr(fcx, pres, arg);\n+                changed = extend_prestate_ann(a, pres) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(arg))\n+                    || changed;\n+                ret changed;\n+            }\n+            case (none[@expr]) {\n+                ret pure_exp(a, pres);\n+            }\n+        }\n+    }\n+    case (expr_lit(?l,?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_block(?b,?a)) {\n+        changed = find_pre_post_state_block(fcx, pres, b)\n+           || changed;\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, block_poststate(b)) || changed;\n+        ret changed;\n+    }\n+    case (expr_rec(?fields,?maybe_base,?a)) {\n+        changed = find_pre_post_state_exprs(fcx, pres, a,\n+                                            field_exprs(fields)) || changed;\n+        alt (maybe_base) {\n+            case (none[@expr]) { /* do nothing */ }\n+            case (some[@expr](?base)) {\n+                changed = find_pre_post_state_expr(fcx, pres, base)\n+                    || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(base))\n+                    || changed;\n+            }\n+        }\n+        ret changed;\n+    }\n+    case (expr_assign(?lhs, ?rhs, ?a)) {\n+        extend_prestate_ann(a, pres);\n+\n+        alt (lhs.node) {\n+            case (expr_path(?p, ?a_lhs)) {\n+                // assignment to local var\n+                changed = pure_exp(a_lhs, pres) || changed;\n+                changed = find_pre_post_state_expr(fcx, pres, rhs)\n+                    || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                    || changed;\n+                changed = gen_if_local(fcx, a_lhs, a)|| changed;\n+            }\n+            case (_) {\n+                // assignment to something that must already have been init'd\n+                changed = find_pre_post_state_expr(fcx, pres, lhs)\n+                    || changed;\n+                changed = find_pre_post_state_expr(fcx,\n+                     expr_poststate(lhs), rhs) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                    || changed;\n+            }\n+        }\n+        ret changed;\n+    }\n+    case (expr_recv(?lhs, ?rhs, ?a)) {\n+        extend_prestate_ann(a, pres);\n+\n+        alt (lhs.node) {\n+            case (expr_path(?p, ?a_lhs)) {\n+                // receive to local var\n+                changed = pure_exp(a_lhs, pres) || changed;\n+                changed = find_pre_post_state_expr(fcx, pres, rhs)\n+                    || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                    || changed;\n+                changed = gen_if_local(fcx, a_lhs, a) || changed;\n+            }\n+            case (_) {\n+                // receive to something that must already have been init'd\n+                changed = find_pre_post_state_expr(fcx, pres, lhs)\n+                    || changed;\n+                changed = find_pre_post_state_expr(fcx,\n+                     expr_poststate(lhs), rhs) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                    || changed;\n+            }\n+        }\n+        ret changed;\n+    }\n+\n+    case (expr_ret(?maybe_ret_val, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        set_poststate_ann(a, false_postcond(num_local_vars));\n+        alt(maybe_ret_val) {\n+            case (none[@expr]) { /* do nothing */ }\n+            case (some[@expr](?ret_val)) {\n+                changed = find_pre_post_state_expr(fcx,\n+                             pres, ret_val) || changed;\n+            }\n+        }\n+        ret changed;\n+    }\n+    case (expr_be(?e, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        set_poststate_ann(a, false_postcond(num_local_vars));\n+        changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+        ret changed;\n+    }\n+    case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fcx, pres, antec)\n+            || changed;\n+        changed = find_pre_post_state_block(fcx,\n+          expr_poststate(antec), conseq) || changed;\n+        alt (maybe_alt) {\n+            case (none[@expr]) {\n+                changed = extend_poststate_ann(a, expr_poststate(antec))\n+                    || changed;\n+            }\n+            case (some[@expr](?altern)) {\n+                changed = find_pre_post_state_expr(fcx,\n+                   expr_poststate(antec), altern) || changed;\n+                auto poststate_res = intersect_postconds\n+                    (vec(block_poststate(conseq), expr_poststate(altern)));\n+                changed = extend_poststate_ann(a, poststate_res) || changed;\n+            }\n+        }\n+        log(\"if:\");\n+        log_expr(*e);\n+        log(\"new prestate:\");\n+        log_bitv(fcx.enclosing, pres);\n+        log(\"new poststate:\");\n+        log_bitv(fcx.enclosing, expr_poststate(e));\n+\n+        ret changed;\n+    }\n+    case (expr_binary(?bop, ?l, ?r, ?a)) {\n+        /* FIXME: what if bop is lazy? */\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fcx, pres, l)\n+                    || changed;\n+        changed = find_pre_post_state_expr(fcx, expr_poststate(l), r)\n+                    || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n+        ret changed;\n+    }\n+    case (expr_send(?l, ?r, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fcx, pres, l)\n+                    || changed;\n+        changed = find_pre_post_state_expr(fcx, expr_poststate(l), r)\n+                    || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n+        ret changed;\n+    }\n+    case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n+        /* quite similar to binary -- should abstract this */\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fcx, pres, lhs)\n+                    || changed;\n+        changed = find_pre_post_state_expr(fcx, expr_poststate(lhs), rhs)\n+                    || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n+        ret changed;\n+    }\n+    case (expr_while(?test, ?body, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        /* to handle general predicates, we need to pass in\n+            pres `intersect` (poststate(a)) \n+         like: auto test_pres = intersect_postconds(pres, expr_postcond(a));\n+         However, this doesn't work right now because we would be passing\n+         in an all-zero prestate initially\n+           FIXME\n+           maybe need a \"don't know\" state in addition to 0 or 1?\n+        */\n+        changed = find_pre_post_state_expr(fcx, pres, test)\n+            || changed;\n+        changed = find_pre_post_state_block(fcx, expr_poststate(test), body)\n+                    || changed; \n+        changed = extend_poststate_ann(a,\n+                    intersect_postconds(vec(expr_poststate(test),\n+                                        block_poststate(body)))) || changed;\n+        ret changed;\n+    }\n+    case (expr_do_while(?body, ?test, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_block(fcx, pres, body)\n+            || changed;\n+        changed = find_pre_post_state_expr(fcx,\n+                     block_poststate(body), test) || changed;\n+\n+        /* conservative approximination: if the body of the loop\n+           could break or cont, we revert to the prestate\n+           (TODO: could treat cont differently from break, since\n+           if there's a cont, the test will execute) */\n+        if (has_nonlocal_exits(body)) {\n+            changed = set_poststate_ann(a, pres) || changed;\n+        }\n+        else {\n+            changed = extend_poststate_ann(a, expr_poststate(test))\n+              || changed;\n+        }\n+\n+        ret changed;\n+    }\n+    case (expr_for(?d, ?index, ?body, ?a)) {\n+        ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n+    }\n+    case (expr_for_each(?d, ?index, ?body, ?a)) {\n+        ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n+    }\n+    case (expr_index(?e, ?sub, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed; \n+        changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+        changed = find_pre_post_state_expr(fcx,\n+                     expr_poststate(e), sub) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(sub));\n+        ret changed;\n+    }\n+    case (expr_alt(?e, ?alts, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed; \n+        changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+        auto e_post = expr_poststate(e);\n+        auto a_post;\n+        if (_vec::len[arm](alts) > 0u) {\n+            a_post = false_postcond(num_local_vars);\n+            for (arm an_alt in alts) {\n+                changed = find_pre_post_state_block(fcx, e_post,\n+                                                    an_alt.block) || changed;\n+                changed = intersect(a_post, block_poststate(an_alt.block))\n+                    || changed; \n+            }\n+        }\n+        else {\n+            // No alts; poststate is the poststate of the test\n+            a_post = e_post;\n+        }\n+        changed = extend_poststate_ann(a, a_post);\n+        ret changed;\n+    }\n+    case (expr_field(?e, _, ?a)) {\n+        changed = find_pre_post_state_expr(fcx, pres, e);\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n+        ret changed;\n+    }\n+    case (expr_unary(_,?operand,?a)) {\n+        changed = find_pre_post_state_expr(fcx, pres, operand)\n+          || changed;\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(operand))\n+          || changed;\n+        ret changed;\n+    }\n+    case (expr_cast(?operand, _, ?a)) {\n+           changed = find_pre_post_state_expr(fcx, pres, operand)\n+          || changed;\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(operand))\n+          || changed;\n+        ret changed;\n+    }\n+    case (expr_fail(?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        /* if execution continues after fail, then everything is true! woo! */\n+        changed = set_poststate_ann(a, false_postcond(num_local_vars))\n+          || changed;\n+        ret changed;\n+    }\n+    case (expr_assert(?p, ?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_check(?p, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n+        /* FIXME: update the postcondition to reflect that p holds */\n+        changed = extend_poststate_ann(a, pres) || changed;\n+        ret changed;\n+    }\n+    case (expr_break(?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_cont(?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_port(?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_self_method(_, ?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+  }\n+}\n+\n+fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n+  auto changed = false;\n+  auto stmt_ann_ = stmt_to_ann(*s);\n+  assert (!is_none[@ts_ann](stmt_ann_));\n+  auto stmt_ann = *(get[@ts_ann](stmt_ann_));\n+              log(\"*At beginning: stmt = \");\n+              log_stmt(*s);\n+              log(\"*prestate = \");\n+              log(bitv::to_str(stmt_ann.states.prestate));\n+              log(\"*poststate =\");\n+              log(bitv::to_str(stmt_ann.states.poststate));\n+              log(\"*changed =\");\n+              log(changed);\n+  \n+  alt (s.node) {\n+    case (stmt_decl(?adecl, ?a)) {\n+      alt (adecl.node) {\n+        case (decl_local(?alocal)) {\n+          alt (alocal.init) {\n+            case (some[initializer](?an_init)) {\n+                changed = extend_prestate(stmt_ann.states.prestate, pres)\n+                    || changed;\n+                changed = find_pre_post_state_expr\n+                    (fcx, pres, an_init.expr) || changed;\n+                changed = extend_poststate(stmt_ann.states.poststate,\n+                                           expr_poststate(an_init.expr))\n+                    || changed;\n+                changed = gen_poststate(fcx, a, alocal.id)\n+                            || changed;\n+              log(\"Summary: stmt = \");\n+              log_stmt(*s);\n+              log(\"prestate = \");\n+              log(bitv::to_str(stmt_ann.states.prestate));\n+              log_bitv(fcx.enclosing, stmt_ann.states.prestate);\n+              log(\"poststate =\");\n+              log_bitv(fcx.enclosing, stmt_ann.states.poststate);\n+              log(\"changed =\");\n+              log(changed);\n+  \n+              ret changed;\n+            }\n+            case (none[initializer]) {\n+              changed = extend_prestate(stmt_ann.states.prestate, pres)\n+                  || changed;\n+              changed = extend_poststate(stmt_ann.states.poststate, pres)\n+                  || changed;\n+              ret changed;\n+            }\n+          }\n+        }\n+        case (decl_item(?an_item)) {\n+            changed = extend_prestate(stmt_ann.states.prestate, pres)\n+               || changed;\n+            changed = extend_poststate(stmt_ann.states.poststate, pres)\n+               || changed;\n+            ret (find_pre_post_state_item(fcx, an_item) || changed);\n+        }\n+      }\n+    }\n+    case (stmt_expr(?e, _)) {\n+      changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+      changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(e))\n+          || changed;\n+      changed = extend_poststate(stmt_ann.states.poststate,\n+                                 expr_poststate(e)) || changed;\n+      /*\n+                    log(\"Summary: stmt = \");\n+              log_stmt(*s);\n+              log(\"prestate = \");\n+              log(bitv::to_str(stmt_ann.states.prestate));\n+              log_bitv(enclosing, stmt_ann.states.prestate);\n+              log(\"poststate =\");\n+              log(bitv::to_str(stmt_ann.states.poststate));\n+              log_bitv(enclosing, stmt_ann.states.poststate);\n+              log(\"changed =\");\n+              log(changed);\n+      */\n+      ret changed;\n+    }\n+    case (_) { ret false; }\n+  }\n+}\n+\n+/* Updates the pre- and post-states of statements in the block,\n+   returns a boolean flag saying whether any pre- or poststates changed */\n+fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n+  -> bool {\n+    \n+  auto changed = false;\n+  auto num_local_vars = num_locals(fcx.enclosing);\n+\n+  /* First, set the pre-states and post-states for every expression */\n+  auto pres = pres0;\n+  \n+  /* Iterate over each stmt. The new prestate is <pres>. The poststate\n+   consist of improving <pres> with whatever variables this stmt initializes.\n+  Then <pres> becomes the new poststate. */ \n+  for (@stmt s in b.node.stmts) {\n+    changed = find_pre_post_state_stmt(fcx, pres, s) || changed;\n+    pres = stmt_poststate(*s, num_local_vars);\n+  }\n+\n+  auto post = pres;\n+\n+  alt (b.node.expr) {\n+    case (none[@expr]) {}\n+    case (some[@expr](?e)) {\n+      changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n+      post = expr_poststate(e);\n+    }\n+  }\n+\n+  /*\n+  log_err(\"block:\");\n+  log_block_err(b);\n+  log_err(\"has non-local exits?\");\n+  log_err(has_nonlocal_exits(b));\n+  */\n+\n+  /* conservative approximation: if a block contains a break\n+     or cont, we assume nothing about the poststate */\n+  if (has_nonlocal_exits(b)) {\n+      post = pres0;\n+  }\n+  \n+  set_prestate_ann(b.node.a, pres0);\n+  set_poststate_ann(b.node.a, post);\n+\n+  log(\"For block:\");\n+  log_block(b);\n+  log(\"poststate = \");\n+  log_states(block_states(b));\n+  log(\"pres0:\");\n+  log_bitv(fcx.enclosing, pres0);\n+  log(\"post:\");\n+  log_bitv(fcx.enclosing, post);\n+\n+  ret changed;\n+}\n+\n+fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n+    /* FIXME: where do we set args as being initialized?\n+       What about for methods? */\n+    auto num_local_vars = num_locals(fcx.enclosing);\n+    ret find_pre_post_state_block(fcx,\n+          empty_prestate(num_local_vars), f.body);\n+}\n+\n+fn find_pre_post_state_obj(crate_ctxt ccx, _obj o) -> bool {\n+    fn do_a_method(crate_ctxt ccx, &@method m) -> bool {\n+        assert (ccx.fm.contains_key(m.node.id));\n+        ret find_pre_post_state_fn(rec(enclosing=ccx.fm.get(m.node.id),\n+                                       id=m.node.id,\n+                                       name=m.node.ident,\n+                                       ccx=ccx),\n+                                   m.node.meth);\n+    }\n+    auto f = bind do_a_method(ccx,_);\n+    auto flags = _vec::map[@method, bool](f, o.methods);\n+    auto changed = _vec::or(flags);\n+    changed = changed || maybe[@method, bool](false, f, o.dtor);\n+    ret changed;\n+}\n+\n+fn find_pre_post_state_item(&fn_ctxt fcx, @item i) -> bool {\n+    alt (i.node) {\n+        case (item_const(?id, ?t, ?e, ?di, ?a)) {\n+            ret find_pre_post_state_expr(fcx,\n+                  empty_prestate(num_locals(fcx.enclosing)), e);\n+        }\n+        case (item_fn(?id, ?f, ?ps, ?di, ?a)) {\n+            assert (fcx.ccx.fm.contains_key(di));\n+            ret find_pre_post_state_fn(rec(enclosing=fcx.ccx.fm.get(di),\n+                                           id=di, name=id with fcx), f);\n+        }\n+        case (item_mod(?id, ?m, ?di)) {\n+            ret find_pre_post_state_mod(m);\n+        }\n+        case (item_native_mod(?id, ?nm, ?di)) {\n+            ret find_pre_post_state_native_mod(nm);\n+        }\n+        case (item_ty(_,_,_,_,_)) {\n+            ret false;\n+        }\n+        case (item_tag(_,_,_,_,_)) {\n+            ret false;\n+        }\n+        case (item_obj(?id, ?o, ?ps, ?di, ?a)) {\n+            ret find_pre_post_state_obj(fcx.ccx, o);\n+        }\n+    }\n+}"}, {"sha": "bd076fd6ce58a86ad47baa9f82e731d5084384f8", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -31,7 +31,7 @@ import util::common::ty_f64;\n \n import util::common::new_def_hash;\n import util::common::span;\n-import util::typestate_ann::ts_ann;\n+import middle::tstate::ann::ts_ann;\n \n import util::interner;\n \n@@ -86,6 +86,7 @@ type t = uint;\n // AST structure in front/ast::rs as well.\n tag sty {\n     ty_nil;\n+    ty_bot;\n     ty_bool;\n     ty_int;\n     ty_float;\n@@ -159,7 +160,8 @@ const uint idx_str      = 16u;\n const uint idx_task     = 17u;\n const uint idx_native   = 18u;\n const uint idx_type     = 19u;\n-const uint idx_first_others = 20u;\n+const uint idx_bot      = 20u;\n+const uint idx_first_others = 21u;\n \n type type_store = interner::interner[raw_t];\n \n@@ -190,6 +192,7 @@ fn mk_type_store() -> @type_store {\n     intern(ts, ty_task, none[str]);\n     intern(ts, ty_native, none[str]);\n     intern(ts, ty_type, none[str]);\n+    intern(ts, ty_bot, none[str]);\n \n     assert _vec::len(ts.vect) == idx_first_others;\n \n@@ -368,6 +371,7 @@ fn gen_ty(&ctxt cx, &sty st) -> t {\n }\n \n fn mk_nil(&ctxt cx) -> t          { ret idx_nil; }\n+fn mk_bot(&ctxt cx) -> t          { ret idx_bot; }\n fn mk_bool(&ctxt cx) -> t         { ret idx_bool; }\n fn mk_int(&ctxt cx) -> t          { ret idx_int; }\n fn mk_float(&ctxt cx) -> t        { ret idx_float; }\n@@ -564,6 +568,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n     alt (struct(cx, typ)) {\n         case (ty_native)       { s += \"native\";                         }\n         case (ty_nil)          { s += \"()\";                             }\n+        case (ty_bot)          { s += \"_|_\";                            }\n         case (ty_bool)         { s += \"bool\";                           }\n         case (ty_int)          { s += \"int\";                            }\n         case (ty_float)        { s += \"float\";                          }\n@@ -576,6 +581,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n         case (ty_port(?t))     { s += \"port[\" + ty_to_str(cx, t) + \"]\"; }\n         case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n         case (ty_type)         { s += \"type\";                           }\n+        case (ty_task)         { s += \"task\";                           }\n \n         case (ty_tup(?elems)) {\n             auto f = bind mt_to_str(cx, _);\n@@ -632,6 +638,11 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n             s += \"''\" + _str::unsafe_from_bytes(vec(('a' as u8) +\n                                                     (id as u8)));\n         }\n+\n+        case (_) {\n+            s += ty_to_short_str(cx, typ);\n+        }\n+\n     }\n \n     ret s;\n@@ -652,6 +663,7 @@ type ty_walk = fn(t);\n fn walk_ty(ctxt cx, ty_walk walker, t ty) {\n     alt (struct(cx, ty)) {\n         case (ty_nil)           { /* no-op */ }\n+        case (ty_bot)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n         case (ty_int)           { /* no-op */ }\n         case (ty_uint)          { /* no-op */ }\n@@ -716,6 +728,7 @@ fn fold_ty(ctxt cx, ty_fold fld, t ty_0) -> t {\n     auto ty = ty_0;\n     alt (struct(cx, ty)) {\n         case (ty_nil)           { /* no-op */ }\n+        case (ty_bot)           { /* no-op */ }\n         case (ty_bool)          { /* no-op */ }\n         case (ty_int)           { /* no-op */ }\n         case (ty_uint)          { /* no-op */ }\n@@ -821,7 +834,13 @@ fn type_is_nil(&ctxt cx, &t ty) -> bool {\n         case (ty_nil) { ret true; }\n         case (_) { ret false; }\n     }\n-    fail;\n+}\n+\n+fn type_is_bot(&ctxt cx, &t ty) -> bool {\n+    alt (struct(cx, ty)) {\n+        case (ty_bot) { ret true; }\n+        case (_) { ret false; }\n+    }\n }\n \n fn type_is_bool(&ctxt cx, &t ty) -> bool {\n@@ -1130,6 +1149,7 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_bound_param(?pid)) { ret hash_uint(31u, pid); }\n         case (ty_type) { ret 32u; }\n         case (ty_native) { ret 33u; }\n+        case (ty_bot) { ret 34u; }\n     }\n }\n \n@@ -1182,6 +1202,12 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (_) { ret false; }\n             }\n         }\n+        case (ty_bot) {\n+            alt(b) {\n+                case (ty_bot) { ret true; }\n+                case (_)      { ret false; }\n+            }\n+        }\n         case (ty_bool) {\n             alt (b) {\n                 case (ty_bool) { ret true; }\n@@ -1476,7 +1502,12 @@ fn triv_ann(uint node_id, t typ) -> ast::ann {\n \n // Creates a nil type annotation.\n fn plain_ann(uint node_id, ctxt tcx) -> ast::ann {\n-    ret ast::ann_type(node_id, mk_nil(tcx), none[vec[ty::t]], none[@ts_ann]);\n+    ret ast::ann_type(node_id, mk_nil(tcx), none[vec[t]], none[@ts_ann]);\n+}\n+\n+// Creates a _|_ type annotation.\n+fn bot_ann(uint node_id, ctxt tcx) -> ast::ann {\n+    ret ast::ann_type(node_id, mk_bot(tcx), none[vec[t]], none[@ts_ann]);\n }\n \n \n@@ -2099,6 +2130,7 @@ mod unify {\n \n         alt (struct(cx.tcx, expected)) {\n             case (ty::ty_nil)        { ret struct_cmp(cx, expected, actual); }\n+            case (ty::ty_bot)        { ret struct_cmp(cx, expected, actual); }\n             case (ty::ty_bool)       { ret struct_cmp(cx, expected, actual); }\n             case (ty::ty_int)        { ret struct_cmp(cx, expected, actual); }\n             case (ty::ty_uint)       { ret struct_cmp(cx, expected, actual); }\n@@ -2675,6 +2707,20 @@ fn lookup_item_type(session::session sess,\n     }\n }\n \n+fn ret_ty_of_fn_ty(ty_ctxt tcx, t a_ty) -> t {\n+    alt (ty::struct(tcx, a_ty)) {\n+        case (ty::ty_fn(_, _, ?ret_ty)) {\n+            ret ret_ty;\n+        }\n+        case (_) { \n+            fail;\n+        }\n+    }\n+}\n+\n+fn ret_ty_of_fn(node_type_table ntt, ty_ctxt tcx, ast::ann ann) -> t {\n+    ret ret_ty_of_fn_ty(tcx, ann_to_type(ntt, ann));\n+}\n \n // Local Variables:\n // mode: rust"}, {"sha": "f8ce34683594f4c644a7422785af9ae74e8420e2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -25,6 +25,7 @@ import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n import middle::ty::path_to_str;\n import middle::ty::plain_ann;\n+import middle::ty::bot_ann;\n import middle::ty::struct;\n import middle::ty::triv_ann;\n import middle::ty::ty_param_substs_opt_and_ty;\n@@ -46,7 +47,7 @@ import std::option::none;\n import std::option::some;\n import std::option::from_maybe;\n \n-import util::typestate_ann::ts_ann;\n+import middle::tstate::ann::ts_ann;\n \n type ty_table = hashmap[ast::def_id, ty::t];\n \n@@ -271,6 +272,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n     auto cname = none[str];\n     alt (ast_ty.node) {\n         case (ast::ty_nil)          { typ = ty::mk_nil(tcx); }\n+        case (ast::ty_bot)          { typ = ty::mk_bot(tcx); }\n         case (ast::ty_bool)         { typ = ty::mk_bool(tcx); }\n         case (ast::ty_int)          { typ = ty::mk_int(tcx); }\n         case (ast::ty_uint)         { typ = ty::mk_uint(tcx); }\n@@ -1060,6 +1062,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n         }\n     }\n \n+    /* result is a vector of the *expected* types of all the fields */\n     ret result;\n }\n \n@@ -1120,11 +1123,29 @@ mod Pushdown {\n                 }\n \n                 // Get the types of the arguments of the variant.\n+              \n+                let vec[ty::t] tparams = vec();\n+                auto j = 0u;\n+                auto actual_ty_params =\n+                  ty::ann_to_type_params(fcx.ccx.node_types, ann);\n+\n+                for (ty::t some_ty in tag_tps) {\n+                    let ty::t t1 = some_ty;\n+                    let ty::t t2 = actual_ty_params.(j);\n+                    \n+                    let ty::t res = Demand::simple(fcx, \n+                                                   pat.span,\n+                                                   t1, t2);\n+                    \n+                    _vec::push(tparams, res);\n+                    j += 1u;\n+                }\n+\n                 auto arg_tys;\n                 alt (fcx.ccx.tcx.def_map.get(ast::ann_tag(ann))) {\n                     case (ast::def_variant(_, ?vdefid)) {\n                         arg_tys = variant_arg_types(fcx.ccx, pat.span, vdefid,\n-                                                    tag_tps);\n+                                                    tparams);\n                     }\n                 }\n \n@@ -1134,10 +1155,22 @@ mod Pushdown {\n                     i += 1u;\n                 }\n \n+                auto tps = ty::ann_to_type_params(fcx.ccx.node_types, ann);\n+                auto tt  = ann_to_type(fcx.ccx.node_types, ann);\n+                \n+                let ty_param_substs_and_ty res_t = Demand::full(fcx, pat.span,\n+                      expected, tt, tps, NO_AUTODEREF);\n+\n+                auto a_1 = ast::ann_type(ast::ann_tag(ann),\n+                                               res_t._1,\n+                                               some[vec[ty::t]](res_t._0),\n+                                         none[@ts_ann]);\n+\n                 // TODO: push down type from \"expected\".\n-                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                write_type(fcx.ccx.node_types, ast::ann_tag(a_1),\n                     ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n-                                                          ann));\n+                                                          a_1));\n+                    \n             }\n         }\n     }\n@@ -1843,8 +1876,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             case (ty::ty_native_fn(?abi, _, _))   {\n                 t_0 = ty::mk_native_fn(fcx.ccx.tcx, abi, arg_tys_0, rt_0);\n             }\n-            case (_) {\n-                log_err \"check_call_or_bind(): fn expr doesn't have fn type\";\n+            case (?u) {\n+                fcx.ccx.sess.span_err(f.span,\n+                \"check_call_or_bind(): fn expr doesn't have fn type,\"\n+                + \" instead having: \" +\n+                ty_to_str(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx,\n+                                              fcx.ccx.node_types, f_0)));\n                 fail;\n             }\n         }\n@@ -2015,29 +2052,26 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         }\n \n         case (ast::expr_fail(?a)) {\n-            // TODO: should be something like 'a or noret\n-            auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n+            auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_fail(new_ann));\n         }\n \n         case (ast::expr_break(?a)) {\n-            // TODO: should be something like 'a or noret\n-            auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n+            auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n             ret @fold::respan[ast::expr_](expr.span,\n                                           ast::expr_break(new_ann));\n         }\n \n         case (ast::expr_cont(?a)) {\n             // TODO: should be something like 'a or noret\n-            auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n+            auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n             ret @fold::respan[ast::expr_](expr.span, ast::expr_cont(new_ann));\n         }\n \n         case (ast::expr_ret(?expr_opt, ?a)) {\n-            // TODO: should be something like 'a or noret\n             alt (expr_opt) {\n                 case (none[@ast::expr]) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n@@ -2046,7 +2080,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                                          + \"returning non-nil\");\n                     }\n \n-                    auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n+                    auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n                     write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n                                    ast::ann_tag(a));\n \n@@ -2060,7 +2094,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto expr_1 = Pushdown::pushdown_expr(fcx, fcx.ret_ty,\n                                                          expr_0);\n \n-                    auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n+                    auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n                     write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n                                    ast::ann_tag(a));\n \n@@ -2109,8 +2143,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             assert (ast::is_call_expr(e));\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = Pushdown::pushdown_expr(fcx, fcx.ret_ty, expr_0);\n-\n-            auto new_ann = plain_ann(ast::ann_tag(a), fcx.ccx.tcx);\n+            auto new_ann = bot_ann(ast::ann_tag(a), fcx.ccx.tcx);\n             write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, ast::ann_tag(a));\n \n             ret @fold::respan(expr.span, ast::expr_be(expr_1, new_ann));"}, {"sha": "f8a5c2888747943493ab6b6fcdbc4c28ee1b6168", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -135,6 +135,7 @@ fn walk_ty(&ast_visitor v, @ast::ty t) {\n     v.visit_ty_pre(t);\n     alt (t.node) {\n         case (ast::ty_nil) {}\n+        case (ast::ty_bot) {}\n         case (ast::ty_bool) {}\n         case (ast::ty_int) {}\n         case (ast::ty_uint) {}"}, {"sha": "e07ed285457dcd0e2934055b68449cdb1baf4770", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -18,9 +18,21 @@ mod middle {\n     mod metadata;\n     mod resolve;\n     mod typeck;\n-    mod typestate_check;\n+    \n+    mod tstate {\n+        mod ck;\n+        mod annotate;\n+        mod aux;\n+        mod bitvectors;\n+        mod collect_locals;\n+        mod pre_post_conditions;\n+        mod states;\n+        mod ann;\n+    }\n+    \n }\n \n+\n mod pretty {\n     mod pprust;\n     mod pp;\n@@ -53,7 +65,6 @@ mod driver {\n mod util {\n     mod common;\n     mod interner;\n-    mod typestate_ann;\n }\n \n auth front::creader::load_crate = unsafe;"}, {"sha": "602b1458cf961f4dc5840dfe19594c96043214be", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -5,7 +5,9 @@ import std::_int;\n import std::_vec;\n import std::option::none;\n import front::ast;\n-import util::typestate_ann::ts_ann;\n+import front::ast::ty;\n+import front::ast::pat;\n+import middle::tstate::ann::ts_ann;\n \n import middle::fold;\n import middle::fold::respan;\n@@ -17,6 +19,7 @@ import pretty::pprust::print_block;\n import pretty::pprust::print_expr;\n import pretty::pprust::print_decl;\n import pretty::pprust::print_fn;\n+import pretty::pprust::print_type;\n import pretty::pp::mkstate;\n \n type filename = str;\n@@ -127,6 +130,16 @@ fn expr_to_str(&@ast::expr e) -> str {\n   ret s.get_str();\n }\n \n+fn ty_to_str(&ty t) -> str {\n+  let str_writer s = string_writer();\n+  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out = @rec(s=out_,\n+                  comments=none[vec[front::lexer::cmnt]],\n+                  mutable cur_cmnt=0u);\n+  print_type(out, @t);\n+  ret s.get_str();\n+}\n+\n fn log_expr(&ast::expr e) -> () {\n     log(expr_to_str(@e));\n }\n@@ -135,6 +148,14 @@ fn log_expr_err(&ast::expr e) -> () {\n     log_err(expr_to_str(@e));\n }\n \n+fn log_ty_err(&ty t) -> () {\n+    log_err(ty_to_str(t));\n+}\n+\n+fn log_pat_err(&@pat p) -> () {\n+    log_err(pretty::pprust::pat_to_str(p));\n+}\n+\n fn block_to_str(&ast::block b) -> str {\n   let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n@@ -269,6 +290,7 @@ fn has_nonlocal_exits(&ast::block b) -> bool {\n \n     ret (has_exits.size() > 0u);\n }\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "6b62c20567118ed04ed7b641b86dde9a9d2afc45", "filename": "src/test/compile-fail/forgot-ret.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,21 @@\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+// -*- rust -*-\n+\n+// error-pattern: may not return\n+\n+fn god_exists(int a) -> bool {\n+  be god_exists(a);\n+}\n+\n+fn f(int a) -> int {\n+  if (god_exists(a)) {\n+    ret 5;\n+  }\n+}\n+\n+fn main() {\n+  f(12);\n+}"}, {"sha": "1d9ea28a46b47a5c3926d777ed32a10cb9146a0b", "filename": "src/test/run-pass/box-inside-if.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,25 @@\n+// -*- rust -*-\n+// xfail-stage0\n+use std;\n+import std::_vec;\n+\n+fn some_vec(int x) -> vec[int] {\n+  ret vec();\n+}\n+\n+fn is_odd(int n) -> bool { ret true; }\n+\n+fn length_is_even(vec[int] vs) -> bool {\n+  ret true;\n+}\n+\n+fn foo(int acc, int n) -> () {\n+ \n+  if (is_odd(n) && length_is_even(some_vec(1))) {\n+    log_err(\"bloop\");\n+  }\n+}\n+\n+fn main() {\n+  foo(67, 5);\n+}"}, {"sha": "60a7c91a43e41a05f48976dd3c6411268257da7f", "filename": "src/test/run-pass/box-inside-if2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b5d5151f79582252fa1281edb09cf86fd63ff/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs?ref=971b5d5151f79582252fa1281edb09cf86fd63ff", "patch": "@@ -0,0 +1,25 @@\n+// -*- rust -*-\n+// xfail-stage0\n+use std;\n+import std::_vec;\n+\n+fn some_vec(int x) -> vec[int] {\n+  ret vec();\n+}\n+\n+fn is_odd(int n) -> bool { ret true; }\n+\n+fn length_is_even(vec[int] vs) -> bool {\n+  ret true;\n+}\n+\n+fn foo(int acc, int n) -> () {\n+ \n+  if (is_odd(n) || length_is_even(some_vec(1))) {\n+    log_err(\"bloop\");\n+  }\n+}\n+\n+fn main() {\n+  foo(67, 5);\n+}"}]}