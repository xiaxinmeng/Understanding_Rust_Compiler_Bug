{"sha": "2a6f197bf4358f6ed9211777e59553128caa459b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNmYxOTdiZjQzNThmNmVkOTIxMTc3N2U1OTU1MzEyOGNhYTQ1OWI=", "commit": {"author": {"name": "Chase Southwood", "email": "chase.southwood@gmail.com", "date": "2014-11-25T08:15:28Z"}, "committer": {"name": "Chase Southwood", "email": "chase.southwood@gmail.com", "date": "2014-11-25T08:15:28Z"}, "message": "Implement union, intersection, and difference functions for TrieSet.", "tree": {"sha": "e326424400a24b75a760160ec5750ff0a651a021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e326424400a24b75a760160ec5750ff0a651a021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a6f197bf4358f6ed9211777e59553128caa459b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a6f197bf4358f6ed9211777e59553128caa459b", "html_url": "https://github.com/rust-lang/rust/commit/2a6f197bf4358f6ed9211777e59553128caa459b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a6f197bf4358f6ed9211777e59553128caa459b/comments", "author": {"login": "csouth3", "id": 6758080, "node_id": "MDQ6VXNlcjY3NTgwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6758080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csouth3", "html_url": "https://github.com/csouth3", "followers_url": "https://api.github.com/users/csouth3/followers", "following_url": "https://api.github.com/users/csouth3/following{/other_user}", "gists_url": "https://api.github.com/users/csouth3/gists{/gist_id}", "starred_url": "https://api.github.com/users/csouth3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csouth3/subscriptions", "organizations_url": "https://api.github.com/users/csouth3/orgs", "repos_url": "https://api.github.com/users/csouth3/repos", "events_url": "https://api.github.com/users/csouth3/events{/privacy}", "received_events_url": "https://api.github.com/users/csouth3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csouth3", "id": 6758080, "node_id": "MDQ6VXNlcjY3NTgwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6758080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csouth3", "html_url": "https://github.com/csouth3", "followers_url": "https://api.github.com/users/csouth3/followers", "following_url": "https://api.github.com/users/csouth3/following{/other_user}", "gists_url": "https://api.github.com/users/csouth3/gists{/gist_id}", "starred_url": "https://api.github.com/users/csouth3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csouth3/subscriptions", "organizations_url": "https://api.github.com/users/csouth3/orgs", "repos_url": "https://api.github.com/users/csouth3/repos", "events_url": "https://api.github.com/users/csouth3/events{/privacy}", "received_events_url": "https://api.github.com/users/csouth3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7222ba965038897168f4f4abe9a464bc36266982", "url": "https://api.github.com/repos/rust-lang/rust/commits/7222ba965038897168f4f4abe9a464bc36266982", "html_url": "https://github.com/rust-lang/rust/commit/7222ba965038897168f4f4abe9a464bc36266982"}], "stats": {"total": 269, "additions": 268, "deletions": 1}, "files": [{"sha": "dd884b6ee41d88a5ab82a10c1335ef6c230ce92f", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 268, "deletions": 1, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/2a6f197bf4358f6ed9211777e59553128caa459b/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a6f197bf4358f6ed9211777e59553128caa459b/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=2a6f197bf4358f6ed9211777e59553128caa459b", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // FIXME(conventions): implement bounded iterators\n-// FIXME(conventions): implement union family of fns\n // FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n // FIXME(conventions): replace each_reverse by making iter DoubleEnded\n // FIXME(conventions): implement iter_mut and into_iter\n@@ -19,6 +18,7 @@ use core::prelude::*;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n+use core::iter::Peekable;\n use std::hash::Hash;\n \n use trie_map::{TrieMap, Entries};\n@@ -172,6 +172,106 @@ impl TrieSet {\n         SetItems{iter: self.map.upper_bound(val)}\n     }\n \n+    /// Visits the values representing the difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1 then 2\n+    /// }\n+    ///\n+    /// let diff1: TrieSet = a.difference(&b).collect();\n+    /// assert_eq!(diff1, [1, 2].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff2: TrieSet = b.difference(&a).collect();\n+    /// assert_eq!(diff2, [4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn difference<'a>(&'a self, other: &'a TrieSet) -> DifferenceItems<'a> {\n+        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the symmetric difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 4, 5 in ascending order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: TrieSet = a.symmetric_difference(&b).collect();\n+    /// let diff2: TrieSet = b.symmetric_difference(&a).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle.\"]\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a TrieSet) -> SymDifferenceItems<'a> {\n+        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the intersection, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TrieSet = [2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in ascending order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TrieSet = a.intersection(&b).collect();\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn intersection<'a>(&'a self, other: &'a TrieSet) -> IntersectionItems<'a> {\n+        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the union, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4, 5 in ascending order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TrieSet = a.union(&b).collect();\n+    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn union<'a>(&'a self, other: &'a TrieSet) -> UnionItems<'a> {\n+        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n     /// Return the number of elements in the set\n     ///\n     /// # Example\n@@ -368,6 +468,39 @@ pub struct SetItems<'a> {\n     iter: Entries<'a, ()>\n }\n \n+/// An iterator producing elements in the set difference (in-order).\n+pub struct DifferenceItems<'a> {\n+    a: Peekable<uint, SetItems<'a>>,\n+    b: Peekable<uint, SetItems<'a>>,\n+}\n+\n+/// An iterator producing elements in the set symmetric difference (in-order).\n+pub struct SymDifferenceItems<'a> {\n+    a: Peekable<uint, SetItems<'a>>,\n+    b: Peekable<uint, SetItems<'a>>,\n+}\n+\n+/// An iterator producing elements in the set intersection (in-order).\n+pub struct IntersectionItems<'a> {\n+    a: Peekable<uint, SetItems<'a>>,\n+    b: Peekable<uint, SetItems<'a>>,\n+}\n+\n+/// An iterator producing elements in the set union (in-order).\n+pub struct UnionItems<'a> {\n+    a: Peekable<uint, SetItems<'a>>,\n+    b: Peekable<uint, SetItems<'a>>,\n+}\n+\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+fn cmp_opt(x: Option<&uint>, y: Option<&uint>, short: Ordering, long: Ordering) -> Ordering {\n+    match (x, y) {\n+        (None    , _       ) => short,\n+        (_       , None    ) => long,\n+        (Some(x1), Some(y1)) => x1.cmp(y1),\n+    }\n+}\n+\n impl<'a> Iterator<uint> for SetItems<'a> {\n     fn next(&mut self) -> Option<uint> {\n         self.iter.next().map(|(key, _)| key)\n@@ -378,6 +511,60 @@ impl<'a> Iterator<uint> for SetItems<'a> {\n     }\n }\n \n+impl<'a> Iterator<uint> for DifferenceItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<uint> for SymDifferenceItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less => return self.a.next(),\n+                Equal => { self.a.next(); self.b.next(); }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<uint> for IntersectionItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        loop {\n+            let o_cmp = match (self.a.peek(), self.b.peek()) {\n+                (None    , _       ) => None,\n+                (_       , None    ) => None,\n+                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n+            };\n+            match o_cmp {\n+                None          => return None,\n+                Some(Less)    => { self.a.next(); }\n+                Some(Equal)   => { self.b.next(); return self.a.next() }\n+                Some(Greater) => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<uint> for UnionItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.b.next(); return self.a.next() }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use std::prelude::*;\n@@ -471,4 +658,84 @@ mod test {\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n+\n+    fn check(a: &[uint],\n+             b: &[uint],\n+             expected: &[uint],\n+             f: |&TrieSet, &TrieSet, f: |uint| -> bool| -> bool) {\n+        let mut set_a = TrieSet::new();\n+        let mut set_b = TrieSet::new();\n+\n+        for x in a.iter() { assert!(set_a.insert(*x)) }\n+        for y in b.iter() { assert!(set_b.insert(*y)) }\n+\n+        let mut i = 0;\n+        f(&set_a, &set_b, |x| {\n+            assert_eq!(x, expected[i]);\n+            i += 1;\n+            true\n+        });\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        fn check_intersection(a: &[uint], b: &[uint], expected: &[uint]) {\n+            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n+        }\n+\n+        check_intersection(&[], &[], &[]);\n+        check_intersection(&[1, 2, 3], &[], &[]);\n+        check_intersection(&[], &[1, 2, 3], &[]);\n+        check_intersection(&[2], &[1, 2, 3], &[2]);\n+        check_intersection(&[1, 2, 3], &[2], &[2]);\n+        check_intersection(&[11, 1, 3, 77, 103, 5],\n+                           &[2, 11, 77, 5, 3],\n+                           &[3, 5, 11, 77]);\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        fn check_difference(a: &[uint], b: &[uint], expected: &[uint]) {\n+            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n+        }\n+\n+        check_difference(&[], &[], &[]);\n+        check_difference(&[1, 12], &[], &[1, 12]);\n+        check_difference(&[], &[1, 2, 3, 9], &[]);\n+        check_difference(&[1, 3, 5, 9, 11],\n+                         &[3, 9],\n+                         &[1, 5, 11]);\n+        check_difference(&[11, 22, 33, 40, 42],\n+                         &[14, 23, 34, 38, 39, 50],\n+                         &[11, 22, 33, 40, 42]);\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        fn check_symmetric_difference(a: &[uint], b: &[uint], expected: &[uint]) {\n+            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n+        }\n+\n+        check_symmetric_difference(&[], &[], &[]);\n+        check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n+        check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n+        check_symmetric_difference(&[1, 3, 5, 9, 11],\n+                                   &[3, 9, 14, 22],\n+                                   &[1, 5, 11, 14, 22]);\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        fn check_union(a: &[uint], b: &[uint], expected: &[uint]) {\n+            check(a, b, expected, |x, y, f| x.union(y).all(f))\n+        }\n+\n+        check_union(&[], &[], &[]);\n+        check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n+        check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n+        check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n+                    &[1, 5, 9, 13, 19],\n+                    &[1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+    }\n }"}]}