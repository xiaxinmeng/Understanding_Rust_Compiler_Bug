{"sha": "d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4MDJjMWZiZDJiM2E5ZDFiMTY5NzczNzliOTNjNWYzMDk1ZDZmMzg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-23T12:41:10Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-23T16:00:19Z"}, "message": "Various cleanups and optimizations in core::str", "tree": {"sha": "331274f2a0310ea8a73acbb8a6499d94b45e754a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/331274f2a0310ea8a73acbb8a6499d94b45e754a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "html_url": "https://github.com/rust-lang/rust/commit/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35e9192762f30ec893e4e72f49abffe7f77c4615", "url": "https://api.github.com/repos/rust-lang/rust/commits/35e9192762f30ec893e4e72f49abffe7f77c4615", "html_url": "https://github.com/rust-lang/rust/commit/35e9192762f30ec893e4e72f49abffe7f77c4615"}], "stats": {"total": 666, "additions": 270, "deletions": 396}, "files": [{"sha": "fd966b408846ebf28e3a6f9d0c3506776485fe4a", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "patch": "@@ -440,8 +440,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n               none {\n                 let name =\n                     {\n-                        let os = str::split_byte(\n-                                   fs::basename(output), '.' as u8);\n+                        let os = str::split_char(fs::basename(output), '.');\n                         if (vec::len(os) < 2u) {\n                             sess.fatal(#fmt(\"Output file name %s doesn't\\\n                               appear to have an extension\", output));\n@@ -576,7 +575,7 @@ fn link_binary(sess: session,\n             } else { ret filename; }\n         };\n         fn rmext(filename: str) -> str {\n-            let parts = str::split_byte(filename, '.' as u8);\n+            let parts = str::split_char(filename, '.');\n             vec::pop(parts);\n             ret str::connect(parts, \".\");\n         }"}, {"sha": "cc74efa82cfd579a5fcd84c3355545a1a42e1a09", "filename": "src/comp/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Fcomp%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Fcomp%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Frpath.rs?ref=d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "patch": "@@ -121,8 +121,8 @@ fn get_relative_to(abs1: fs::path, abs2: fs::path) -> fs::path {\n            abs1, abs2);\n     let normal1 = fs::normalize(abs1);\n     let normal2 = fs::normalize(abs2);\n-    let split1 = str::split_byte(normal1, os_fs::path_sep as u8);\n-    let split2 = str::split_byte(normal2, os_fs::path_sep as u8);\n+    let split1 = str::split_char(normal1, os_fs::path_sep);\n+    let split2 = str::split_char(normal2, os_fs::path_sep);\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n     assert len1 > 0u;"}, {"sha": "e9dd1a010c5f8e6d83a3c30ee41769222a7f1f8d", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "patch": "@@ -119,7 +119,7 @@ fn get_used_libraries(cstore: cstore) -> [str] {\n }\n \n fn add_used_link_args(cstore: cstore, args: str) {\n-    p(cstore).used_link_args += str::split_byte(args, ' ' as u8);\n+    p(cstore).used_link_args += str::split_char(args, ' ');\n }\n \n fn get_used_link_args(cstore: cstore) -> [str] {"}, {"sha": "9520d9fd3413f672b2a9a790f1d511ee5da4bb8c", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "patch": "@@ -176,16 +176,16 @@ fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n }\n \n fn span_to_snippet(sp: span, cm: codemap::codemap) -> str {\n-    let begin = lookup_byte_offset(cm,sp.lo);\n-    let end   = lookup_byte_offset(cm,sp.hi);\n+    let begin = lookup_byte_offset(cm, sp.lo);\n+    let end = lookup_byte_offset(cm, sp.hi);\n     assert begin.fm == end.fm;\n-    ret str::slice_chars(*begin.fm.src, begin.pos, end.pos);\n+    ret str::slice(*begin.fm.src, begin.pos, end.pos);\n }\n \n fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> str\n {\n     let fm = cm.files[fidx];\n-    ret str::slice_chars(*fm.src, lo, hi)\n+    ret str::slice(*fm.src, lo, hi)\n }\n \n fn get_filemap(cm: codemap, filename: str) -> filemap {"}, {"sha": "70b1d9e96207a0ceb15c601a6085fef51143b86b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 255, "deletions": 372, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "patch": "@@ -13,7 +13,7 @@ export\n    // Creating a string\n    from_bytes,\n    from_byte,\n-   //push_utf8_bytes,\n+   push_char,\n    from_char,\n    from_chars,\n    from_cstr,\n@@ -35,17 +35,12 @@ export\n    chars,\n    substr,\n    slice,\n-   slice_chars,\n-   split,\n+   split, splitn, split_nonempty,\n+   split_char, splitn_char, split_char_nonempty,\n    split_str,\n-   split_char,\n-   splitn_char,\n-   split_byte,\n-   splitn_byte,\n    lines,\n    lines_any,\n    words,\n-   windowed,\n    to_lower,\n    to_upper,\n    replace,\n@@ -95,6 +90,7 @@ export\n    substr_len_chars,\n    utf8_char_width,\n    char_range_at,\n+   is_char_boundary,\n    char_at,\n    substr_all,\n    escape_char,\n@@ -135,42 +131,49 @@ Function: from_byte\n \n Convert a byte to a UTF-8 string.  Fails if invalid UTF-8.\n */\n-fn from_byte(uu: u8) -> str {\n-    from_bytes([uu])\n+fn from_byte(b: u8) -> str unsafe {\n+    assert b < 128u8;\n+    let v = [b, 0u8];\n+    let s: str = ::unsafe::reinterpret_cast(v);\n+    ::unsafe::leak(v);\n+    s\n }\n \n-fn push_utf8_bytes(&s: str, ch: char) unsafe {\n+/*\n+Function: push_char\n+\n+Appends a character at the end of a string.\n+*/\n+fn push_char(&s: str, ch: char) unsafe {\n     let code = ch as uint;\n-    let bytes =\n-        if code < max_one_b {\n-            [code as u8]\n-        } else if code < max_two_b {\n-            [(code >> 6u & 31u | tag_two_b) as u8,\n-             (code & 63u | tag_cont) as u8]\n-        } else if code < max_three_b {\n-            [(code >> 12u & 15u | tag_three_b) as u8,\n-             (code >> 6u & 63u | tag_cont) as u8,\n-             (code & 63u | tag_cont) as u8]\n-        } else if code < max_four_b {\n-            [(code >> 18u & 7u | tag_four_b) as u8,\n-             (code >> 12u & 63u | tag_cont) as u8,\n-             (code >> 6u & 63u | tag_cont) as u8,\n-             (code & 63u | tag_cont) as u8]\n-        } else if code < max_five_b {\n-            [(code >> 24u & 3u | tag_five_b) as u8,\n-             (code >> 18u & 63u | tag_cont) as u8,\n-             (code >> 12u & 63u | tag_cont) as u8,\n-             (code >> 6u & 63u | tag_cont) as u8,\n-             (code & 63u | tag_cont) as u8]\n-        } else {\n-            [(code >> 30u & 1u | tag_six_b) as u8,\n-             (code >> 24u & 63u | tag_cont) as u8,\n-             (code >> 18u & 63u | tag_cont) as u8,\n-             (code >> 12u & 63u | tag_cont) as u8,\n-             (code >> 6u & 63u | tag_cont) as u8,\n-             (code & 63u | tag_cont) as u8]\n-        };\n-    unsafe::push_bytes(s, bytes);\n+    if code < max_one_b {\n+        rustrt::rust_str_push(s, code as u8);\n+    } else if code < max_two_b {\n+        rustrt::rust_str_push(s, (code >> 6u & 31u | tag_two_b) as u8);\n+        rustrt::rust_str_push(s, (code & 63u | tag_cont) as u8);\n+    } else if code < max_three_b {\n+        rustrt::rust_str_push(s, (code >> 12u & 15u | tag_three_b) as u8);\n+        rustrt::rust_str_push(s, (code >> 6u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code & 63u | tag_cont) as u8);\n+    } else if code < max_four_b {\n+        rustrt::rust_str_push(s, (code >> 18u & 7u | tag_four_b) as u8);\n+        rustrt::rust_str_push(s, (code >> 12u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code >> 6u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code & 63u | tag_cont) as u8);\n+    } else if code < max_five_b {\n+        rustrt::rust_str_push(s, (code >> 24u & 3u | tag_five_b) as u8);\n+        rustrt::rust_str_push(s, (code >> 18u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code >> 12u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code >> 6u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code & 63u | tag_cont) as u8);\n+    } else {\n+        rustrt::rust_str_push(s, (code >> 30u & 1u | tag_six_b) as u8);\n+        rustrt::rust_str_push(s, (code >> 24u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code >> 18u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code >> 12u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code >> 6u & 63u | tag_cont) as u8);\n+        rustrt::rust_str_push(s, (code & 63u | tag_cont) as u8);\n+    }\n }\n \n /*\n@@ -180,7 +183,7 @@ Convert a char to a string\n */\n fn from_char(ch: char) -> str {\n     let buf = \"\";\n-    push_utf8_bytes(buf, ch);\n+    push_char(buf, ch);\n     ret buf;\n }\n \n@@ -191,7 +194,8 @@ Convert a vector of chars to a string\n */\n fn from_chars(chs: [char]) -> str {\n     let buf = \"\";\n-    for ch: char in chs { push_utf8_bytes(buf, ch); }\n+    reserve(buf, chs.len());\n+    for ch in chs { push_char(buf, ch); }\n     ret buf;\n }\n \n@@ -201,12 +205,10 @@ Function: from_cstr\n Create a Rust string from a null-terminated C string\n */\n fn from_cstr(cstr: sbuf) -> str unsafe {\n-    let start = cstr;\n-    let curr = start;\n-    let i = 0u;\n+    let curr = cstr, i = 0u;\n     while *curr != 0u8 {\n         i += 1u;\n-        curr = ptr::offset(start, i);\n+        curr = ptr::offset(cstr, i);\n     }\n     ret from_cstr_len(cstr, i);\n }\n@@ -246,8 +248,7 @@ Function: connect\n Concatenate a vector of strings, placing a given separator between each\n */\n fn connect(v: [str], sep: str) -> str {\n-    let s: str = \"\";\n-    let first: bool = true;\n+    let s = \"\", first = true;\n     for ss: str in v {\n         if first { first = false; } else { s += sep; }\n         s += ss;\n@@ -259,13 +260,6 @@ fn connect(v: [str], sep: str) -> str {\n Section: Adding to and removing from a string\n */\n \n-/*\n-Function: push_char\n-\n-Append a character to a string\n-*/\n-fn push_char(&s: str, ch: char) { s += from_char(ch); }\n-\n /*\n Function: pop_char\n \n@@ -276,6 +270,7 @@ If the string does not contain any characters.\n */\n fn pop_char(&s: str) -> char {\n     let end = len(s);\n+    assert end > 0u;\n     let {ch, prev} = char_range_at_reverse(s, end);\n     unsafe { unsafe::set_len(s, prev); }\n     ret ch;\n@@ -291,9 +286,9 @@ Failure:\n If the string does not contain any characters.\n */\n fn shift_char(&s: str) -> char unsafe {\n-    let r = char_range_at(s, 0u);\n-    s = unsafe::slice_bytes(s, r.next, len(s));\n-    ret r.ch;\n+    let {ch, next} = char_range_at(s, 0u);\n+    s = unsafe::slice_bytes(s, next, len(s));\n+    ret ch;\n }\n \n /*\n@@ -369,13 +364,11 @@ Function: chars\n Convert a string to a vector of characters\n */\n fn chars(s: str) -> [char] {\n-    let buf: [char] = [];\n-    let i = 0u;\n-    let len = len(s);\n+    let buf = [], i = 0u, len = len(s);\n     while i < len {\n-        let cur = char_range_at(s, i);\n-        buf += [cur.ch];\n-        i = cur.next;\n+        let {ch, next} = char_range_at(s, i);\n+        buf += [ch];\n+        i = next;\n     }\n     ret buf;\n }\n@@ -399,94 +392,106 @@ fn substr(s: str, begin: uint, len: uint) -> str {\n // Return a slice of the given string from the byte range [`begin`..`end`)\n // or else fail when `begin` and `end` do not point to valid characters or\n // beyond the last character of the string\n-fn slice(ss: str, begin: uint, end: uint) -> str {\n-   alt maybe_slice(ss, begin, end) {\n-      some(sli) { ret sli; }\n-      none      { fail \"slice requires a valid start and end\"; }\n-   }\n+fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n+    assert is_char_boundary(s, begin);\n+    assert is_char_boundary(s, end);\n+    unsafe::slice_bytes(s, begin, end)\n }\n \n-// Function: maybe_slice\n+// Function: split_char\n //\n-// Like slice, only returns an option<str>\n-fn maybe_slice(ss: str, begin: uint, end: uint) -> option<str> unsafe {\n-   let sli = unsafe::slice_bytes(ss, begin, end);\n-\n-   if is_utf8(bytes(sli)) {\n-      ret some(sli);\n-   } else {\n-      ret none;\n-   }\n+// Splits a string into substrings at each occurrence of a given\n+// character\n+fn split_char(s: str, sep: char) -> [str] {\n+    split_char_inner(s, sep, len(s), true)\n }\n \n-/*\n-Function: slice_chars\n+// Function: splitn_char\n+//\n+// Splits a string into substrings at each occurrence of a given\n+// character up to 'count' times\n+//\n+// The byte must be a valid UTF-8/ASCII byte\n+fn splitn_char(s: str, sep: char, count: uint) -> [str] {\n+    split_char_inner(s, sep, count, true)\n+}\n \n-Unicode-safe slice. Returns a slice of the given string containing\n-the characters in the range [`begin`..`end`). `begin` and `end` are\n-character indexes, not byte indexes.\n+// Function: split_char_nonempty\n+//\n+// Like `split_char`, but omits empty strings from the returned vector.\n+fn split_char_nonempty(s: str, sep: char) -> [str] {\n+    split_char_inner(s, sep, len(s), false)\n+}\n+\n+fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n+    -> [str] unsafe {\n+    if sep < 128u as char {\n+        let result = [], b = sep as u8, l = len(s), done = 0u;\n+        let i = 0u, start = 0u;\n+        while i < l && done < count {\n+            if s[i] == b {\n+                if allow_empty || start < i {\n+                    result += [unsafe::slice_bytes(s, start, i)];\n+                }\n+                start = i + 1u;\n+                done += 1u;\n+            }\n+            i += 1u;\n+        }\n+        if allow_empty || start < l {\n+            result += [unsafe::slice_bytes(s, start, l)];\n+        }\n+        result\n+    } else {\n+        splitn(s, {|cur| cur == sep}, count)\n+    }\n+}\n \n-Failure:\n \n-- If begin is greater than end\n-- If end is greater than the character length of the string\n+/*\n+Function: split\n \n-FIXME: make faster by avoiding char conversion\n-FIXME: delete?\n+Splits a string into substrings using a character function\n */\n-fn slice_chars(s: str, begin: uint, end: uint) -> str {\n-    from_chars(vec::slice(chars(s), begin, end))\n+fn split(s: str, sepfn: fn(char) -> bool) -> [str] {\n+    split_inner(s, sepfn, len(s), true)\n }\n \n-// Function: split_byte\n-//\n-// Splits a string into substrings at each occurrence of a given byte\n-//\n-// The byte must be a valid UTF-8/ASCII byte\n-fn split_byte(ss: str, sep: u8) -> [str] unsafe {\n-    // still safe if we only split on an ASCII byte\n-    assert u8::is_ascii(sep);\n-\n-    let vv = [];\n-    let start = 0u, current = 0u;\n-\n-    str::bytes_iter(ss) {|cc|\n-        if sep == cc {\n-            vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n-            start = current + 1u;\n-        }\n-        current += 1u;\n-    }\n+/*\n+Function: splitn\n \n-    vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n-    ret vv;\n+Splits a string into substrings using a character function, cutting at\n+most [count] times.\n+*/\n+fn splitn(s: str, sepfn: fn(char) -> bool, count: uint) -> [str] {\n+    split_inner(s, sepfn, count, true)\n }\n \n-// Function: splitn_byte\n+// Function: split_nonempty\n //\n-// Splits a string into substrings at each occurrence of a given byte\n-// up to 'count' times\n-//\n-// The byte must be a valid UTF-8/ASCII byte\n-fn splitn_byte(ss: str, sep: u8, count: uint) -> [str] unsafe {\n-    // still safe if we only split on an ASCII byte\n-    assert u8::is_ascii(sep);\n-\n-    let vv = [];\n-    let start = 0u, current = 0u, len = len(ss);\n-    let splits_done = 0u;\n-\n-    while splits_done < count && current < len {\n-        if sep == ss[current] {\n-            vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n-            start = current + 1u;\n-            splits_done += 1u;\n+// Like `split`, but omits empty strings from the returned vector.\n+fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n+    split_inner(s, sepfn, len(s), false)\n+}\n+\n+fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n+               allow_empty: bool) -> [str] unsafe {\n+    let result = [], i = 0u, l = len(s), start = 0u, done = 0u;\n+    while i < l && done < count {\n+        let {ch, next} = char_range_at(s, i);\n+        if sepfn(ch) {\n+            if allow_empty || start < i {\n+                result += [unsafe::slice_bytes(s, start, i)];\n+            }\n+            start = next;\n+            done += 1u;\n         }\n-        current += 1u;\n+        i = next;\n     }\n-\n-    vec::push(vv, str::unsafe::slice_bytes(ss, start, len));\n-    ret vv;\n+    if allow_empty || start < l {\n+        result += [unsafe::slice_bytes(s, start, l)];\n+    }\n+    result\n }\n \n /*\n@@ -499,104 +504,35 @@ Note that this has recently been changed.  For example:\n \n FIXME: Boyer-Moore should be faster\n */\n-fn split_str(ss: str, sep: str) -> [str] unsafe {\n-    // unsafe is justified: we are splitting\n-    // UTF-8 with UTF-8, so the results will be OK\n-\n-    let sep_len = len(sep);\n+fn split_str(s: str, sep: str) -> [str] unsafe {\n+    let sep_len = len(sep), l = len(s);\n     assert sep_len > 0u;\n-    let vv = [];\n-    let start = 0u, start_match = 0u, current = 0u, matching = 0u;\n-\n-    str::bytes_iter(ss) {|cc|\n-        if sep[matching] == cc {\n-            matching += 1u;\n-        } else {\n-            start_match += 1u;\n-        }\n-\n-        if matching == sep_len {\n-            // found a separator\n-            // push whatever is before it, including \"\"\n-            vec::push(vv, str::unsafe::slice_bytes(ss, start, start_match));\n-\n-            // reset cursors and counters\n-            start = current + 1u;\n-            start_match = current + 1u;\n-            matching = 0u;\n-        }\n-\n-        current += 1u;\n-    }\n-\n-    // whether we have a \"\", or something meaningful, push it\n-    vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n-    ret vv;\n-}\n-\n-/*\n-Function: split\n-\n-Splits a string into substrings using a character function\n-(unicode safe)\n-*/\n-fn split(ss: str, sepfn: fn(cc: char)->bool) -> [str] {\n-    let vv: [str] = [];\n-    let accum: str = \"\";\n-    let ends_with_sep: bool = false;\n-\n-    chars_iter(ss, {|cc| if sepfn(cc) {\n-            vv += [accum];\n-            accum = \"\";\n-            ends_with_sep = true;\n+    let result = [], i = 0u, start = 0u;\n+    let match_start = 0u, match_i = 0u;\n+\n+    while i < l {\n+        if s[i] == sep[match_i] {\n+            if match_i == 0u { match_start = i; }\n+            match_i += 1u;\n+            // Found a match\n+            if match_i == sep_len {\n+                result += [unsafe::slice_bytes(s, start, match_start)];\n+                match_i = 0u;\n+                start = i + 1u;\n+            }\n+            i += 1u;\n         } else {\n-            str::push_char(accum, cc);\n-            ends_with_sep = false;\n+            // Failed match, backtrack\n+            if match_i > 0u {\n+                match_i = 0u;\n+                i = match_start + 1u;\n+            } else {\n+                i += 1u;\n+            }\n         }\n-    });\n-\n-    if len_chars(accum) >= 0u || ends_with_sep {\n-        vv += [accum];\n     }\n-\n-    ret vv;\n-}\n-\n-/*\n-Function: split_char\n-\n-Splits a string into a vector of the substrings separated by a given character\n-*/\n-fn split_char(ss: str, cc: char) -> [str] {\n-   split(ss, {|kk| kk == cc})\n-}\n-\n-/*\n-Function: splitn_char\n-\n-Splits a string into a vector of the substrings separated by a given character\n-up to `count` times\n-*/\n-fn splitn_char(ss: str, sep: char, count: uint) -> [str] unsafe {\n-\n-   let vv = [];\n-   let start = 0u, current = 0u, len = len(ss);\n-   let splits_done = 0u;\n-\n-   while splits_done < count && current < len {\n-      // grab a char...\n-      let {ch, next} = char_range_at(ss, current);\n-\n-      if sep == ch {\n-         vec::push(vv, str::unsafe::slice_bytes(ss, start, current));\n-         start = next;\n-         splits_done += 1u;\n-      }\n-      current = next;\n-   }\n-\n-   vec::push(vv, str::unsafe::slice_bytes(ss, start, len));\n-   ret vv;\n+    result += [unsafe::slice_bytes(s, start, l)];\n+    result\n }\n \n /*\n@@ -605,18 +541,22 @@ Function: lines\n Splits a string into a vector of the substrings\n separated by LF ('\\n')\n */\n-fn lines(ss: str) -> [str] {\n-    split(ss, {|cc| cc == '\\n'})\n-}\n+fn lines(s: str) -> [str] { split_char(s, '\\n') }\n \n /*\n Function: lines_any\n \n Splits a string into a vector of the substrings\n separated by LF ('\\n') and/or CR LF ('\\r\\n')\n */\n-fn lines_any(ss: str) -> [str] {\n-    vec::map(lines(ss), {|s| trim_right(s)})\n+fn lines_any(s: str) -> [str] {\n+    vec::map(lines(s), {|s|\n+        let l = len(s), cp = s;\n+        if l > 0u && s[l - 1u] == '\\r' as u8 {\n+            unsafe { unsafe::set_len(cp, l - 1u); }\n+        }\n+        cp\n+    })\n }\n \n /*\n@@ -625,30 +565,8 @@ Function: words\n Splits a string into a vector of the substrings\n separated by whitespace\n */\n-fn words(ss: str) -> [str] {\n-    ret vec::filter( split(ss, {|cc| char::is_whitespace(cc)}),\n-                     {|w| 0u < str::len_chars(w)});\n-}\n-\n-/*\n-Function: windowed\n-\n-Create a vector of substrings of size `nn`\n-*/\n-fn windowed(nn: uint, ss: str) -> [str] {\n-    let ww = [];\n-    let len = str::len_chars(ss);\n-\n-    assert 1u <= nn;\n-\n-    let ii = 0u;\n-    while ii+nn <= len {\n-        let w = slice_chars( ss, ii, ii+nn );\n-        vec::push(ww,w);\n-        ii += 1u;\n-    }\n-\n-    ret ww;\n+fn words(s: str) -> [str] {\n+    split_nonempty(s, {|c| char::is_whitespace(c)})\n }\n \n /*\n@@ -1308,6 +1226,18 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     ret {ch: val as char, next: i};\n }\n \n+/*\n+Function is_char_boundary\n+\n+Returns false if the index points into the middle of a multi-byte\n+character sequence.\n+*/\n+pure fn is_char_boundary(s: str, index: uint) -> bool {\n+    if index == len(s) { ret true; }\n+    let b = s[index];\n+    ret b < 128u8 || b >= 192u8;\n+}\n+\n /*\n Function: char_at\n \n@@ -1647,43 +1577,42 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_split_byte() {\n+    fn test_split_char() {\n         fn t(s: str, c: char, u: [str]) {\n             log(debug, \"split_byte: \" + s);\n-            let v = split_byte(s, c as u8);\n-            #debug(\"split_byte to: \");\n-            log(debug, v);\n-            assert (vec::all2(v, u, { |a,b| a == b }));\n+            let v = split_char(s, c);\n+            #debug(\"split_byte to: %?\", v);\n+            assert vec::all2(v, u, { |a,b| a == b });\n         }\n         t(\"abc.hello.there\", '.', [\"abc\", \"hello\", \"there\"]);\n         t(\".hello.there\", '.', [\"\", \"hello\", \"there\"]);\n         t(\"...hello.there.\", '.', [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n \n         assert [\"\", \"\", \"\", \"hello\", \"there\", \"\"]\n-            == split_byte(\"...hello.there.\", '.' as u8);\n+            == split_char(\"...hello.there.\", '.');\n \n-        assert [\"\"] == split_byte(\"\", 'z' as u8);\n-        assert [\"\",\"\"] == split_byte(\"z\", 'z' as u8);\n-        assert [\"ok\"] == split_byte(\"ok\", 'z' as u8);\n+        assert [\"\"] == split_char(\"\", 'z');\n+        assert [\"\",\"\"] == split_char(\"z\", 'z');\n+        assert [\"ok\"] == split_char(\"ok\", 'z');\n     }\n \n     #[test]\n-    fn test_split_byte_2() {\n+    fn test_split_char_2() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]\n-            == split_byte(data, 'V' as u8);\n+            == split_char(data, 'V');\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\", \"\u0e28\u0e44\", \"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+            == split_char(data, '\u0e17');\n     }\n \n     #[test]\n-    fn test_splitn_byte() {\n+    fn test_splitn_char() {\n         fn t(s: str, c: char, n: uint, u: [str]) {\n             log(debug, \"splitn_byte: \" + s);\n-            let v = splitn_byte(s, c as u8, n);\n-            #debug(\"split_byte to: \");\n-            log(debug, v);\n-            #debug(\"comparing vs. \");\n-            log(debug, u);\n-            assert (vec::all2(v, u, { |a,b| a == b }));\n+            let v = splitn_char(s, c, n);\n+            #debug(\"split_byte to: %?\", v);\n+            #debug(\"comparing vs. %?\", u);\n+            assert vec::all2(v, u, { |a,b| a == b });\n         }\n         t(\"abc.hello.there\", '.', 0u, [\"abc.hello.there\"]);\n         t(\"abc.hello.there\", '.', 1u, [\"abc\", \"hello.there\"]);\n@@ -1694,19 +1623,36 @@ mod tests {\n         t(\"...hello.there.\", '.', 3u, [\"\", \"\", \"\", \"hello.there.\"]);\n         t(\"...hello.there.\", '.', 5u, [\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n \n-        assert [\"\"] == splitn_byte(\"\", 'z' as u8, 5u);\n-        assert [\"\",\"\"] == splitn_byte(\"z\", 'z' as u8, 5u);\n-        assert [\"ok\"] == splitn_byte(\"ok\", 'z' as u8, 5u);\n-        assert [\"z\"] == splitn_byte(\"z\", 'z' as u8, 0u);\n-        assert [\"w.x.y\"] == splitn_byte(\"w.x.y\", '.' as u8, 0u);\n-        assert [\"w\",\"x.y\"] == splitn_byte(\"w.x.y\", '.' as u8, 1u);\n+        assert [\"\"] == splitn_char(\"\", 'z', 5u);\n+        assert [\"\",\"\"] == splitn_char(\"z\", 'z', 5u);\n+        assert [\"ok\"] == splitn_char(\"ok\", 'z', 5u);\n+        assert [\"z\"] == splitn_char(\"z\", 'z', 0u);\n+        assert [\"w.x.y\"] == splitn_char(\"w.x.y\", '.', 0u);\n+        assert [\"w\",\"x.y\"] == splitn_char(\"w.x.y\", '.', 1u);\n+    }\n+\n+    #[test]\n+    fn test_splitn_char_2 () {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+            == splitn_char(data, '\u534e', 1u);\n+\n+        assert [\"\", \"\", \"XXX\", \"YYYzWWWz\"]\n+            == splitn_char(\"zzXXXzYYYzWWWz\", 'z', 3u);\n+        assert [\"\",\"\"] == splitn_char(\"z\", 'z', 5u);\n+        assert [\"\"] == splitn_char(\"\", 'z', 5u);\n+        assert [\"ok\"] == splitn_char(\"ok\", 'z', 5u);\n     }\n \n+\n     #[test]\n-    fn test_splitn_byte_2() {\n+    fn test_splitn_char_3() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]\n-            == splitn_byte(data, 'V' as u8, 1u);\n+            == splitn_char(data, 'V', 1u);\n+        assert [\"\u0e1b\u0e23\u0e30\u0e40\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+            == splitn_char(data, '\u0e17', 1u);\n+\n     }\n \n     #[test]\n@@ -1716,6 +1662,7 @@ mod tests {\n             assert eq(v[i], k);\n         }\n \n+        t(\"--1233345--\", \"12345\", 0, \"--1233345--\");\n         t(\"abc::hello::there\", \"::\", 0, \"abc\");\n         t(\"abc::hello::there\", \"::\", 1, \"hello\");\n         t(\"abc::hello::there\", \"::\", 2, \"there\");\n@@ -1744,7 +1691,7 @@ mod tests {\n \n \n     #[test]\n-    fn test_split () {\n+    fn test_split() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n             == split (data, {|cc| cc == '\u534e'});\n@@ -1761,33 +1708,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_split_char () {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n-            == split_char(data, '\u534e');\n-\n-        assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n-            == split_char(\"zzXXXzYYYz\", 'z');\n-        assert [\"\",\"\"] == split_char(\"z\", 'z');\n-        assert [\"\"] == split_char(\"\", 'z');\n-        assert [\"ok\"] == split_char(\"ok\", 'z');\n-    }\n-\n-    #[test]\n-    fn test_splitn_char () {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n-            == splitn_char(data, '\u534e', 1u);\n-\n-        assert [\"\", \"\", \"XXX\", \"YYYzWWWz\"]\n-            == splitn_char(\"zzXXXzYYYzWWWz\", 'z', 3u);\n-        assert [\"\",\"\"] == splitn_char(\"z\", 'z', 5u);\n-        assert [\"\"] == splitn_char(\"\", 'z', 5u);\n-        assert [\"ok\"] == splitn_char(\"ok\", 'z', 5u);\n-    }\n-\n-    #[test]\n-    fn test_lines () {\n+    fn test_lines() {\n         let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = \"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n@@ -2045,10 +1966,10 @@ mod tests {\n         assert (eq(\"\\u65e5\", slice(\"\\u65e5\\u672c\", 0u, 3u)));\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert (eq(\"\u0e1b\", slice(data, 0u, 3u)));\n-        assert (eq(\"\u0e23\", slice(data, 3u, 6u)));\n-        assert (eq(\"\", slice(data, 1u, 1u)));\n-        assert (eq(\"\u534e\", slice(data, 30u, 33u)));\n+        assert \"\u0e1b\" == slice(data, 0u, 3u);\n+        assert \"\u0e23\" == slice(data, 3u, 6u);\n+        assert \"\" == slice(data, 3u, 3u);\n+        assert \"\u534e\" == slice(data, 30u, 33u);\n \n         fn a_million_letter_X() -> str {\n             let i = 0;\n@@ -2062,22 +1983,25 @@ mod tests {\n             while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n             ret rs;\n         }\n-        assert (eq(half_a_million_letter_X(),\n-                        slice(a_million_letter_X(), 0u, (3u * 500000u))));\n+        assert eq(half_a_million_letter_X(),\n+                  slice(a_million_letter_X(), 0u, 3u * 500000u));\n     }\n \n     #[test]\n-    fn test_maybe_slice() {\n-       let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    fn test_slice_2() {\n+        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+\n+        assert \"\u534e\" == slice(ss, 3u, 6u);\n+        assert \"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u);\n \n-       assert none == maybe_slice(ss, 0u, 2u);\n-       assert none == maybe_slice(ss, 1u, 3u);\n-       assert none == maybe_slice(ss, 1u, 2u);\n-       assert some(\"\u534e\") == maybe_slice(ss, 3u, 6u);\n-       assert some(\"Vi\u1ec7t Nam\") == maybe_slice(ss, 6u, 16u);\n-       assert none == maybe_slice(ss, 4u, 16u);\n+        assert \"ab\" == slice(\"abc\", 0u, 2u);\n+        assert \"bc\" == slice(\"abc\", 1u, 3u);\n+        assert \"\" == slice(\"abc\", 1u, 1u);\n \n-       /* 0: \u4e2d\n+        assert \"\u4e2d\" == slice(ss, 0u, 3u);\n+        assert \"\u534eV\" == slice(ss, 3u, 7u);\n+        assert \"\" == slice(ss, 3u, 3u);\n+        /*0: \u4e2d\n           3: \u534e\n           6: V\n           7: i\n@@ -2090,32 +2014,10 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_slice_chars() {\n-        assert (eq(\"ab\", slice_chars(\"abc\", 0u, 2u)));\n-        assert (eq(\"bc\", slice_chars(\"abc\", 1u, 3u)));\n-        assert (eq(\"\", slice_chars(\"abc\", 1u, 1u)));\n-        assert (eq(\"\\u65e5\", slice_chars(\"\\u65e5\\u672c\", 0u, 1u)));\n-\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert (eq(\"\u0e1b\", slice_chars(data, 0u, 1u)));\n-        assert (eq(\"\u0e23\", slice_chars(data, 1u, 2u)));\n-        assert (eq(\"\u534e\", slice_chars(data, 10u, 11u)));\n-        assert (eq(\"\", slice_chars(data, 1u, 1u)));\n-\n-        fn a_million_letter_X() -> str {\n-            let i = 0;\n-            let rs = \"\";\n-            while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n-            ret rs;\n-        }\n-        fn half_a_million_letter_X() -> str {\n-            let i = 0;\n-            let rs = \"\";\n-            while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n-            ret rs;\n-        }\n-        assert (eq(half_a_million_letter_X(),\n-                        slice_chars(a_million_letter_X(), 0u, 500000u)));\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_slice_fail() {\n+        slice(\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n     }\n \n     #[test]\n@@ -2438,25 +2340,6 @@ mod tests {\n         assert true == any(\"Ymcy\", char::is_uppercase);\n     }\n \n-    #[test]\n-    fn test_windowed() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-\n-        assert [\"\u0e1b\u0e23\u0e30\", \"\u0e23\u0e30\u0e40\", \"\u0e30\u0e40\u0e17\", \"\u0e40\u0e17\u0e28\", \"\u0e17\u0e28\u0e44\", \"\u0e28\u0e44\u0e17\", \"\u0e44\u0e17\u0e22\", \"\u0e17\u0e22\u4e2d\"]\n-            == windowed(3u, data);\n-\n-        assert [data] == windowed(10u, data);\n-\n-        assert [] == windowed(6u, \"abcd\");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_windowed_() {\n-        let _x = windowed(0u, \"abcd\");\n-    }\n-\n     #[test]\n     fn test_chars() {\n         let ss = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";"}, {"sha": "8e835bad7f6c90dccd86c48ffa5b2b325769e48b", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "patch": "@@ -254,16 +254,9 @@ the first element of the returned vector will be the drive letter\n followed by a colon.\n */\n fn split(p: path) -> [path] {\n-    // FIXME: use UTF-8 safe str, and/or various other string formats\n-    let split1 = str::split_byte(p, os_fs::path_sep as u8);\n-    let split2 = [];\n-    for s in split1 {\n-        split2 += str::split_byte(s, os_fs::alt_path_sep as u8);\n-    }\n-\n-    // filter out \"\"\n-    let split3 = vec::filter(split2, {|seg| \"\" != seg});\n-    ret split3;\n+    str::split_nonempty(p, {|c|\n+        c == os_fs::path_sep || c == os_fs::alt_path_sep\n+    })\n }\n \n /*\n@@ -276,13 +269,12 @@ path includes directory components then they are included in the filename part\n of the result pair.\n */\n fn splitext(p: path) -> (str, str) {\n-    // FIXME: use UTF-8 safe str, and/or various other string formats\n     if str::is_empty(p) { (\"\", \"\") }\n     else {\n-        let parts = str::split_byte(p, '.' as u8);\n+        let parts = str::split_char(p, '.');\n         if vec::len(parts) > 1u {\n             let base = str::connect(vec::init(parts), \".\");\n-            let ext = \".\" + option::get(vec::last(parts));\n+            let ext = \".\" + vec::last_total(parts);\n \n             fn is_dotfile(base: str) -> bool {\n                 str::is_empty(base)"}, {"sha": "06db7f7d7c8cd6217e4a6682ffb1c227ccea64d5", "filename": "src/libstd/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d802c1fbd2b3a9d1b16977379b93c5f3095d6f38/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=d802c1fbd2b3a9d1b16977379b93c5f3095d6f38", "patch": "@@ -49,7 +49,7 @@ Failure:\n String must be a valid IPv4 address\n */\n fn parse_addr(ip: str) -> ip_addr {\n-    let parts = vec::map(str::split_byte(ip, \".\"[0]), {|s|\n+    let parts = vec::map(str::split_char(ip, '.'), {|s|\n         alt uint::from_str(s) {\n           some(n) if n <= 255u { n }\n           _ { fail \"Invalid IP Address part.\" }"}]}