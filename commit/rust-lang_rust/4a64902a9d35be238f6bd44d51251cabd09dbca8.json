{"sha": "4a64902a9d35be238f6bd44d51251cabd09dbca8", "node_id": "C_kwDOAAsO6NoAKDRhNjQ5MDJhOWQzNWJlMjM4ZjZiZDQ0ZDUxMjUxY2FiZDA5ZGJjYTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-02T13:48:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-02T13:48:14Z"}, "message": "Auto merge of #2711 - RalfJung:btrack, r=RalfJung\n\nslight simplifications for borrow tracking\n\nand some renaming for consistency", "tree": {"sha": "988fc48d34fa04f9ad924b37f204e981b346edd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/988fc48d34fa04f9ad924b37f204e981b346edd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a64902a9d35be238f6bd44d51251cabd09dbca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a64902a9d35be238f6bd44d51251cabd09dbca8", "html_url": "https://github.com/rust-lang/rust/commit/4a64902a9d35be238f6bd44d51251cabd09dbca8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a64902a9d35be238f6bd44d51251cabd09dbca8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89dd322512280a8757864be4c5795b2878ccdcef", "url": "https://api.github.com/repos/rust-lang/rust/commits/89dd322512280a8757864be4c5795b2878ccdcef", "html_url": "https://github.com/rust-lang/rust/commit/89dd322512280a8757864be4c5795b2878ccdcef"}, {"sha": "b12ce552ff14ba0a7d85a934f0e984a0fe66903d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b12ce552ff14ba0a7d85a934f0e984a0fe66903d", "html_url": "https://github.com/rust-lang/rust/commit/b12ce552ff14ba0a7d85a934f0e984a0fe66903d"}], "stats": {"total": 146, "additions": 62, "deletions": 84}, "files": [{"sha": "10e6e252e94b70428b58a4a7511522307c305266", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -55,9 +55,9 @@ impl fmt::Debug for BorTag {\n     }\n }\n \n-/// Per-frame data for borrow tracking\n+/// Per-call-stack-frame data for borrow tracking\n #[derive(Debug)]\n-pub struct FrameExtra {\n+pub struct FrameState {\n     /// The ID of the call this frame corresponds to.\n     pub call_id: CallId,\n \n@@ -72,7 +72,7 @@ pub struct FrameExtra {\n     pub protected_tags: SmallVec<[BorTag; 2]>,\n }\n \n-impl VisitTags for FrameExtra {\n+impl VisitTags for FrameState {\n     fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // `protected_tags` are fine to GC.\n     }\n@@ -190,17 +190,17 @@ impl GlobalStateInner {\n         id\n     }\n \n-    pub fn new_frame(&mut self, machine: &MiriMachine<'_, '_>) -> FrameExtra {\n+    pub fn new_frame(&mut self, machine: &MiriMachine<'_, '_>) -> FrameState {\n         let call_id = self.next_call_id;\n         trace!(\"new_frame: Assigning call ID {}\", call_id);\n         if self.tracked_call_ids.contains(&call_id) {\n             machine.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n         }\n         self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n-        FrameExtra { call_id, protected_tags: SmallVec::new() }\n+        FrameState { call_id, protected_tags: SmallVec::new() }\n     }\n \n-    pub fn end_call(&mut self, frame: &machine::FrameData<'_>) {\n+    pub fn end_call(&mut self, frame: &machine::FrameExtra<'_>) {\n         for tag in &frame\n             .borrow_tracker\n             .as_ref()\n@@ -253,10 +253,10 @@ impl GlobalStateInner {\n         alloc_size: Size,\n         kind: MemoryKind<machine::MiriMemoryKind>,\n         machine: &MiriMachine<'_, '_>,\n-    ) -> AllocExtra {\n+    ) -> AllocState {\n         match self.borrow_tracker_method {\n             BorrowTrackerMethod::StackedBorrows =>\n-                AllocExtra::StackedBorrows(Box::new(RefCell::new(Stacks::new_allocation(\n+                AllocState::StackedBorrows(Box::new(RefCell::new(Stacks::new_allocation(\n                     id, alloc_size, self, kind, machine,\n                 )))),\n         }\n@@ -292,24 +292,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n /// Extra per-allocation data for borrow tracking\n #[derive(Debug, Clone)]\n-pub enum AllocExtra {\n+pub enum AllocState {\n     /// Data corresponding to Stacked Borrows\n-    StackedBorrows(Box<RefCell<stacked_borrows::AllocExtra>>),\n+    StackedBorrows(Box<RefCell<stacked_borrows::AllocState>>),\n }\n \n-impl AllocExtra {\n-    pub fn assert_sb(&self) -> &RefCell<stacked_borrows::AllocExtra> {\n-        match self {\n-            AllocExtra::StackedBorrows(ref sb) => sb,\n+impl machine::AllocExtra {\n+    #[track_caller]\n+    pub fn borrow_tracker_sb(&self) -> &RefCell<stacked_borrows::AllocState> {\n+        match self.borrow_tracker {\n+            Some(AllocState::StackedBorrows(ref sb)) => sb,\n+            _ => panic!(\"expected Stacked Borrows borrow tracking, got something else\"),\n         }\n     }\n \n-    pub fn assert_sb_mut(&mut self) -> &mut RefCell<stacked_borrows::AllocExtra> {\n-        match self {\n-            AllocExtra::StackedBorrows(ref mut sb) => sb,\n+    #[track_caller]\n+    pub fn borrow_tracker_sb_mut(&mut self) -> &mut RefCell<stacked_borrows::AllocState> {\n+        match self.borrow_tracker {\n+            Some(AllocState::StackedBorrows(ref mut sb)) => sb,\n+            _ => panic!(\"expected Stacked Borrows borrow tracking, got something else\"),\n         }\n     }\n+}\n \n+impl AllocState {\n     pub fn before_memory_read<'tcx>(\n         &self,\n         alloc_id: AllocId,\n@@ -318,7 +324,7 @@ impl AllocExtra {\n         machine: &MiriMachine<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         match self {\n-            AllocExtra::StackedBorrows(sb) =>\n+            AllocState::StackedBorrows(sb) =>\n                 sb.borrow_mut().before_memory_read(alloc_id, prov_extra, range, machine),\n         }\n     }\n@@ -331,7 +337,7 @@ impl AllocExtra {\n         machine: &mut MiriMachine<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         match self {\n-            AllocExtra::StackedBorrows(sb) =>\n+            AllocState::StackedBorrows(sb) =>\n                 sb.get_mut().before_memory_write(alloc_id, prov_extra, range, machine),\n         }\n     }\n@@ -344,22 +350,22 @@ impl AllocExtra {\n         machine: &mut MiriMachine<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         match self {\n-            AllocExtra::StackedBorrows(sb) =>\n+            AllocState::StackedBorrows(sb) =>\n                 sb.get_mut().before_memory_deallocation(alloc_id, prov_extra, range, machine),\n         }\n     }\n \n     pub fn remove_unreachable_tags(&self, tags: &FxHashSet<BorTag>) {\n         match self {\n-            AllocExtra::StackedBorrows(sb) => sb.borrow_mut().remove_unreachable_tags(tags),\n+            AllocState::StackedBorrows(sb) => sb.borrow_mut().remove_unreachable_tags(tags),\n         }\n     }\n }\n \n-impl VisitTags for AllocExtra {\n+impl VisitTags for AllocState {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n-            AllocExtra::StackedBorrows(sb) => sb.visit_tags(visit),\n+            AllocState::StackedBorrows(sb) => sb.visit_tags(visit),\n         }\n     }\n }"}, {"sha": "50c2ad75ca71e6113334dd5b965b86ef6fb06683", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 6, "deletions": 34, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -25,7 +25,7 @@ mod stack;\n pub use stack::Stack;\n pub mod diagnostics;\n \n-pub type AllocExtra = Stacks;\n+pub type AllocState = Stacks;\n \n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n@@ -500,10 +500,6 @@ impl Stacks {\n         })?;\n         Ok(())\n     }\n-\n-    fn expose_tag(&mut self, tag: BorTag) {\n-        self.exposed_tags.insert(tag);\n-    }\n }\n \n /// Retagging/reborrowing.  There is some policy in here, such as which permissions\n@@ -567,10 +563,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     // uncovers a non-supported `extern static`.\n                     let extra = this.get_alloc_extra(alloc_id)?;\n                     let mut stacked_borrows = extra\n-                        .borrow_tracker\n-                        .as_ref()\n-                        .expect(\"We should have borrow tracking data\")\n-                        .assert_sb()\n+                        .borrow_tracker_sb()\n                         .borrow_mut();\n                     // Note that we create a *second* `DiagnosticCxBuilder` below for the actual retag.\n                     // FIXME: can this be done cleaner?\n@@ -681,12 +674,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n                 let alloc_extra = this.get_alloc_extra(alloc_id)?;\n-                let mut stacked_borrows = alloc_extra\n-                    .borrow_tracker\n-                    .as_ref()\n-                    .expect(\"We should have borrow tracking data\")\n-                    .assert_sb()\n-                    .borrow_mut();\n+                let mut stacked_borrows = alloc_extra.borrow_tracker_sb().borrow_mut();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -736,12 +724,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let stacked_borrows = alloc_extra\n-            .borrow_tracker\n-            .as_mut()\n-            .expect(\"We should have borrow tracking data\")\n-            .assert_sb_mut()\n-            .get_mut();\n+        let stacked_borrows = alloc_extra.borrow_tracker_sb_mut().get_mut();\n         let item = Item::new(new_tag, perm, protect.is_some());\n         let range = alloc_range(base_offset, size);\n         let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n@@ -993,13 +976,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // uncovers a non-supported `extern static`.\n                 let alloc_extra = this.get_alloc_extra(alloc_id)?;\n                 trace!(\"Stacked Borrows tag {tag:?} exposed in {alloc_id:?}\");\n-                alloc_extra\n-                    .borrow_tracker\n-                    .as_ref()\n-                    .expect(\"We should have borrow tracking data\")\n-                    .assert_sb()\n-                    .borrow_mut()\n-                    .expose_tag(tag);\n+                alloc_extra.borrow_tracker_sb().borrow_mut().exposed_tags.insert(tag);\n             }\n             AllocKind::Function | AllocKind::VTable | AllocKind::Dead => {\n                 // No stacked borrows on these allocations.\n@@ -1011,12 +988,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn print_stacks(&mut self, alloc_id: AllocId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let alloc_extra = this.get_alloc_extra(alloc_id)?;\n-        let stacks = alloc_extra\n-            .borrow_tracker\n-            .as_ref()\n-            .expect(\"We should have borrow tracking data\")\n-            .assert_sb()\n-            .borrow();\n+        let stacks = alloc_extra.borrow_tracker_sb().borrow();\n         for (range, stack) in stacks.stacks.iter_all() {\n             print!(\"{range:?}: [\");\n             if let Some(bottom) = stack.unknown_bottom() {"}, {"sha": "dd2102043d29016783b0173988b151b951a5e0ca", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -59,7 +59,7 @@ use super::{\n     weak_memory::EvalContextExt as _,\n };\n \n-pub type AllocExtra = VClockAlloc;\n+pub type AllocState = VClockAlloc;\n \n /// Valid atomic read-write orderings, alias of atomic::Ordering (not non-exhaustive).\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "03f9ed351fb694db10a0d7e7f9a081db80bc29b8", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -113,7 +113,7 @@ pub struct Thread<'mir, 'tcx> {\n     thread_name: Option<Vec<u8>>,\n \n     /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>>,\n+    stack: Vec<Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>>,\n \n     /// The function to call when the stack ran empty, to figure out what to do next.\n     /// Conceptually, this is the interpreter implementation of the things that happen 'after' the\n@@ -232,7 +232,7 @@ impl VisitTags for Thread<'_, '_> {\n     }\n }\n \n-impl VisitTags for Frame<'_, '_, Provenance, FrameData<'_>> {\n+impl VisitTags for Frame<'_, '_, Provenance, FrameExtra<'_>> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Frame {\n             return_place,\n@@ -385,20 +385,20 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Borrow the stack of the active thread.\n-    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>] {\n+    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>] {\n         &self.threads[self.active_thread].stack\n     }\n \n     /// Mutably borrow the stack of the active thread.\n     fn active_thread_stack_mut(\n         &mut self,\n-    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>> {\n         &mut self.threads[self.active_thread].stack\n     }\n \n     pub fn all_stacks(\n         &self,\n-    ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>]> {\n+    ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>]> {\n         self.threads.iter().map(|t| &t.stack[..])\n     }\n \n@@ -921,15 +921,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     #[inline]\n-    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>] {\n+    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>] {\n         let this = self.eval_context_ref();\n         this.machine.threads.active_thread_stack()\n     }\n \n     #[inline]\n     fn active_thread_stack_mut(\n         &mut self,\n-    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>> {\n         let this = self.eval_context_mut();\n         this.machine.threads.active_thread_stack_mut()\n     }"}, {"sha": "391681444d9ba03ce2c26b413a77ebe7eee2acf4", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -93,7 +93,7 @@ use super::{\n     vector_clock::{VClock, VTimestamp, VectorIdx},\n };\n \n-pub type AllocExtra = StoreBufferAlloc;\n+pub type AllocState = StoreBufferAlloc;\n \n // Each store buffer must be bounded otherwise it will grow indefinitely.\n // However, bounding the store buffer means restricting the amount of weak"}, {"sha": "8f6a5fbc1f01cfe65b0152711f8529fd1ef01a00", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -988,7 +988,7 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n         self.stack()[frame_idx].current_span()\n     }\n \n-    fn stack(&self) -> &[Frame<'mir, 'tcx, Provenance, machine::FrameData<'tcx>>] {\n+    fn stack(&self) -> &[Frame<'mir, 'tcx, Provenance, machine::FrameExtra<'tcx>>] {\n         self.threads.active_thread_stack()\n     }\n "}, {"sha": "42519797976b7795805ca245c1ccd0c3ec80640d", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -106,7 +106,7 @@ pub use crate::eval::{\n pub use crate::helpers::EvalContextExt as _;\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,\n+    AllocExtra, FrameExtra, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,\n     PrimitiveLayouts, Provenance, ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;"}, {"sha": "c110229c985db78600cd18626a2b1899852047df", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -37,9 +37,9 @@ pub const STACK_ADDR: u64 = 32 * PAGE_SIZE; // not really about the \"stack\", but\n pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n \n /// Extra data stored with each stack frame\n-pub struct FrameData<'tcx> {\n+pub struct FrameExtra<'tcx> {\n     /// Extra data for Stacked Borrows.\n-    pub borrow_tracker: Option<borrow_tracker::FrameExtra>,\n+    pub borrow_tracker: Option<borrow_tracker::FrameState>,\n \n     /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n     /// called by `try`). When this frame is popped during unwinding a panic,\n@@ -58,20 +58,20 @@ pub struct FrameData<'tcx> {\n     pub is_user_relevant: bool,\n }\n \n-impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n+impl<'tcx> std::fmt::Debug for FrameExtra<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { borrow_tracker, catch_unwind, timing: _, is_user_relevant: _ } = self;\n+        let FrameExtra { borrow_tracker, catch_unwind, timing: _, is_user_relevant: _ } = self;\n         f.debug_struct(\"FrameData\")\n             .field(\"borrow_tracker\", borrow_tracker)\n             .field(\"catch_unwind\", catch_unwind)\n             .finish()\n     }\n }\n \n-impl VisitTags for FrameData<'_> {\n+impl VisitTags for FrameExtra<'_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n-        let FrameData { catch_unwind, borrow_tracker, timing: _, is_user_relevant: _ } = self;\n+        let FrameExtra { catch_unwind, borrow_tracker, timing: _, is_user_relevant: _ } = self;\n \n         catch_unwind.visit_tags(visit);\n         borrow_tracker.visit_tags(visit);\n@@ -255,13 +255,13 @@ impl ProvenanceExtra {\n #[derive(Debug, Clone)]\n pub struct AllocExtra {\n     /// Global state of the borrow tracker, if enabled.\n-    pub borrow_tracker: Option<borrow_tracker::AllocExtra>,\n+    pub borrow_tracker: Option<borrow_tracker::AllocState>,\n     /// Data race detection via the use of a vector-clock,\n     ///  this is only added if it is enabled.\n-    pub data_race: Option<data_race::AllocExtra>,\n+    pub data_race: Option<data_race::AllocState>,\n     /// Weak memory emulation via the use of store buffers,\n     ///  this is only added if it is enabled.\n-    pub weak_memory: Option<weak_memory::AllocExtra>,\n+    pub weak_memory: Option<weak_memory::AllocState>,\n }\n \n impl VisitTags for AllocExtra {\n@@ -736,7 +736,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     type MemoryKind = MiriMemoryKind;\n     type ExtraFnVal = Dlsym;\n \n-    type FrameExtra = FrameData<'tcx>;\n+    type FrameExtra = FrameExtra<'tcx>;\n     type AllocExtra = AllocExtra;\n \n     type Provenance = Provenance;\n@@ -908,14 +908,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             .map(|bt| bt.borrow_mut().new_allocation(id, alloc.size(), kind, &ecx.machine));\n \n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n-            data_race::AllocExtra::new_allocation(\n+            data_race::AllocState::new_allocation(\n                 data_race,\n                 &ecx.machine.threads,\n                 alloc.size(),\n                 kind,\n             )\n         });\n-        let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocExtra::new_allocation);\n+        let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocState::new_allocation);\n         let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n             &ecx.tcx,\n             AllocExtra { borrow_tracker, data_race: race_alloc, weak_memory: buffer_alloc },\n@@ -1070,7 +1070,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn init_frame_extra(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         frame: Frame<'mir, 'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>> {\n         // Start recording our event before doing anything else\n         let timing = if let Some(profiler) = ecx.machine.profiler.as_ref() {\n             let fn_name = frame.instance.to_string();\n@@ -1088,7 +1088,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n         let borrow_tracker = ecx.machine.borrow_tracker.as_ref();\n \n-        let extra = FrameData {\n+        let extra = FrameExtra {\n             borrow_tracker: borrow_tracker.map(|bt| bt.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n@@ -1157,7 +1157,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     #[inline(always)]\n     fn after_stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        mut frame: Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>,\n+        mut frame: Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         if frame.extra.is_user_relevant {"}, {"sha": "db3e42facadd03958c1d8725b7c44be4645692db", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a64902a9d35be238f6bd44d51251cabd09dbca8/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=4a64902a9d35be238f6bd44d51251cabd09dbca8", "patch": "@@ -125,7 +125,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn handle_stack_pop_unwind(\n         &mut self,\n-        mut extra: FrameData<'tcx>,\n+        mut extra: FrameExtra<'tcx>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         let this = self.eval_context_mut();"}]}