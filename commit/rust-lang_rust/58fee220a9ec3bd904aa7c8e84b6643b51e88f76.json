{"sha": "58fee220a9ec3bd904aa7c8e84b6643b51e88f76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZmVlMjIwYTllYzNiZDkwNGFhN2M4ZTg0YjY2NDNiNTFlODhmNzY=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-09-17T05:27:18Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-09-17T05:27:23Z"}, "message": "fix indentation", "tree": {"sha": "9073adf5710da41005093390b4e590ee3b7f1bde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9073adf5710da41005093390b4e590ee3b7f1bde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58fee220a9ec3bd904aa7c8e84b6643b51e88f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58fee220a9ec3bd904aa7c8e84b6643b51e88f76", "html_url": "https://github.com/rust-lang/rust/commit/58fee220a9ec3bd904aa7c8e84b6643b51e88f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58fee220a9ec3bd904aa7c8e84b6643b51e88f76/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68d4b3af127372c02aab0c2308f5c2bc81fec785", "url": "https://api.github.com/repos/rust-lang/rust/commits/68d4b3af127372c02aab0c2308f5c2bc81fec785", "html_url": "https://github.com/rust-lang/rust/commit/68d4b3af127372c02aab0c2308f5c2bc81fec785"}], "stats": {"total": 62, "additions": 31, "deletions": 31}, "files": [{"sha": "d22fc4817f3637e4828d85b54c5dcfa6c0bb7b3d", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58fee220a9ec3bd904aa7c8e84b6643b51e88f76/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fee220a9ec3bd904aa7c8e84b6643b51e88f76/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=58fee220a9ec3bd904aa7c8e84b6643b51e88f76", "patch": "@@ -34,9 +34,9 @@ impl LintPass for CollapsibleIf {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tif !in_macro(cx, expr.span) {\n-\t\t\tcheck_if(cx, expr)\n-\t\t}\n+        if !in_macro(cx, expr.span) {\n+            check_if(cx, expr)\n+        }\n     }\n }\n "}, {"sha": "a49a7b2b7a3dacaa43baf87ff7777c9eb3d2d4ed", "filename": "src/utils.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/58fee220a9ec3bd904aa7c8e84b6643b51e88f76/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fee220a9ec3bd904aa7c8e84b6643b51e88f76/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=58fee220a9ec3bd904aa7c8e84b6643b51e88f76", "patch": "@@ -28,34 +28,34 @@ pub fn in_macro(cx: &Context, span: Span) -> bool {\n /// returns true if the macro that expanded the crate was outside of\n /// the current crate or was a compiler plugin\n pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n-\t/// invokes in_macro with the expansion info of the given span\n-\t/// slightly heavy, try to use this after other checks have already happened\n-\tfn in_macro_ext(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n-\t\t// no ExpnInfo = no macro\n-\t\topt_info.map_or(false, |info| {\n-\t\t\tmatch info.callee.format {\n-\t\t\t\tExpnFormat::CompilerExpansion(..) => {\n-\t\t\t\t\tif info.callee.name() == \"closure expansion\" {\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t},\n-\t\t\t\tExpnFormat::MacroAttribute(..) => {\n-\t\t\t\t\t// these are all plugins\n-\t\t\t\t\treturn true;\n-\t\t\t\t},\n-\t\t\t\t_ => (),\n-\t\t\t}\n-\t\t\t// no span for the callee = external macro\n-\t\t\tinfo.callee.span.map_or(true, |span| {\n-\t\t\t\t// no snippet = external macro or compiler-builtin expansion\n-\t\t\t\tcx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code|\n-\t\t\t\t\t// macro doesn't start with \"macro_rules\"\n-\t\t\t\t\t// = compiler plugin\n-\t\t\t\t\t!code.starts_with(\"macro_rules\")\n-\t\t\t\t)\n-\t\t\t})\n-\t\t})\n-\t}\n+    /// invokes in_macro with the expansion info of the given span\n+    /// slightly heavy, try to use this after other checks have already happened\n+    fn in_macro_ext(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n+        // no ExpnInfo = no macro\n+        opt_info.map_or(false, |info| {\n+            match info.callee.format {\n+                ExpnFormat::CompilerExpansion(..) => {\n+                    if info.callee.name() == \"closure expansion\" {\n+                        return false;\n+                    }\n+                },\n+                ExpnFormat::MacroAttribute(..) => {\n+                    // these are all plugins\n+                    return true;\n+                },\n+                _ => (),\n+            }\n+            // no span for the callee = external macro\n+            info.callee.span.map_or(true, |span| {\n+                // no snippet = external macro or compiler-builtin expansion\n+                cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code|\n+                    // macro doesn't start with \"macro_rules\"\n+                    // = compiler plugin\n+                    !code.starts_with(\"macro_rules\")\n+                )\n+            })\n+        })\n+    }\n \n     cx.sess().codemap().with_expn_info(span.expn_id,\n             |info| in_macro_ext(cx, info))"}]}