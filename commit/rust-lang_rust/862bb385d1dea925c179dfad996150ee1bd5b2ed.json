{"sha": "862bb385d1dea925c179dfad996150ee1bd5b2ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MmJiMzg1ZDFkZWE5MjVjMTc5ZGZhZDk5NjE1MGVlMWJkNWIyZWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T03:13:57Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:15:47Z"}, "message": "typeck/pat.rs: simplify `check_pat_walk`.", "tree": {"sha": "8d5fb3fdae3e44adecf3ea396fc7e0484ffdcdb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d5fb3fdae3e44adecf3ea396fc7e0484ffdcdb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/862bb385d1dea925c179dfad996150ee1bd5b2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/862bb385d1dea925c179dfad996150ee1bd5b2ed", "html_url": "https://github.com/rust-lang/rust/commit/862bb385d1dea925c179dfad996150ee1bd5b2ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/862bb385d1dea925c179dfad996150ee1bd5b2ed/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f09f1a71396c8e416f67ac16ca559dc1d62f05df", "url": "https://api.github.com/repos/rust-lang/rust/commits/f09f1a71396c8e416f67ac16ca559dc1d62f05df", "html_url": "https://github.com/rust-lang/rust/commit/f09f1a71396c8e416f67ac16ca559dc1d62f05df"}], "stats": {"total": 42, "additions": 19, "deletions": 23}, "files": [{"sha": "c08d777c34e3e06f1b3886f560007c41bbf21804", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/862bb385d1dea925c179dfad996150ee1bd5b2ed/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862bb385d1dea925c179dfad996150ee1bd5b2ed/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=862bb385d1dea925c179dfad996150ee1bd5b2ed", "patch": "@@ -61,57 +61,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n         let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n \n-        let ty = match pat.node {\n-            PatKind::Wild => {\n-                expected\n-            }\n-            PatKind::Lit(ref lt) => {\n-                self.check_pat_lit(pat.span, lt, expected, discrim_span)\n-            }\n-            PatKind::Range(ref begin, ref end, _) => {\n+        let ty = match &pat.node {\n+            PatKind::Wild => expected,\n+            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, discrim_span),\n+            PatKind::Range(begin, end, _) => {\n                 match self.check_pat_range(pat.span, begin, end, expected, discrim_span) {\n                     None => return,\n                     Some(ty) => ty,\n                 }\n             }\n-            PatKind::Binding(ba, var_id, _, ref sub) => {\n+            PatKind::Binding(ba, var_id, _, sub) => {\n                 let sub = sub.as_deref();\n-                self.check_pat_ident(pat, ba, var_id, sub, expected, def_bm, discrim_span)\n+                self.check_pat_ident(pat, *ba, *var_id, sub, expected, def_bm, discrim_span)\n             }\n-            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n+            PatKind::TupleStruct(qpath, subpats, ddpos) => {\n                 self.check_pat_tuple_struct(\n                     pat,\n                     qpath,\n-                    &subpats,\n-                    ddpos,\n+                    subpats,\n+                    *ddpos,\n                     expected,\n                     def_bm,\n                     discrim_span,\n                 )\n             }\n-            PatKind::Path(ref qpath) => {\n+            PatKind::Path(qpath) => {\n                 self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n             }\n-            PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n+            PatKind::Struct(qpath, fields, etc) => {\n+                self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n             }\n-            PatKind::Or(ref pats) => {\n+            PatKind::Or(pats) => {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 for pat in pats {\n                     self.check_pat_walk(pat, expected, def_bm, discrim_span);\n                 }\n                 expected_ty\n             }\n-            PatKind::Tuple(ref elements, ddpos) => {\n-                self.check_pat_tuple(pat.span, elements, ddpos, expected, def_bm, discrim_span)\n+            PatKind::Tuple(elements, ddpos) => {\n+                self.check_pat_tuple(pat.span, elements, *ddpos, expected, def_bm, discrim_span)\n             }\n-            PatKind::Box(ref inner) => {\n+            PatKind::Box(inner) => {\n                 self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n             }\n-            PatKind::Ref(ref inner, mutbl) => {\n-                self.check_pat_ref(pat, inner, mutbl, expected, def_bm, discrim_span)\n+            PatKind::Ref(inner, mutbl) => {\n+                self.check_pat_ref(pat, inner, *mutbl, expected, def_bm, discrim_span)\n             }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n+            PatKind::Slice(before, slice, after) => {\n                 let slice = slice.as_deref();\n                 self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, discrim_span)\n             }"}]}