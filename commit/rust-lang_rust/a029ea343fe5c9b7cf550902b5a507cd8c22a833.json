{"sha": "a029ea343fe5c9b7cf550902b5a507cd8c22a833", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMjllYTM0M2ZlNWM5YjdjZjU1MDkwMmI1YTUwN2NkOGMyMmE4MzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-03T07:11:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-03T07:11:18Z"}, "message": "Auto merge of #35957 - alexcrichton:macros-1.1, r=nrc\n\nrustc: Implement custom derive (macros 1.1)\n\nThis commit is an implementation of [RFC 1681] which adds support to the\ncompiler for first-class user-define custom `#[derive]` modes with a far more\nstable API than plugins have today.\n\n[RFC 1681]: https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md\n\nThe main features added by this commit are:\n\n* A new `rustc-macro` crate-type. This crate type represents one which will\n  provide custom `derive` implementations and perhaps eventually flower into the\n  implementation of macros 2.0 as well.\n\n* A new `rustc_macro` crate in the standard distribution. This crate will\n  provide the runtime interface between macro crates and the compiler. The API\n  here is particularly conservative right now but has quite a bit of room to\n  expand into any manner of APIs required by macro authors.\n\n* The ability to load new derive modes through the `#[macro_use]` annotations on\n  other crates.\n\nAll support added here is gated behind the `rustc_macro` feature gate, both for\nthe library support (the `rustc_macro` crate) as well as the language features.\n\nThere are a few minor differences from the implementation outlined in the RFC,\nsuch as the `rustc_macro` crate being available as a dylib and all symbols are\n`dlsym`'d directly instead of having a shim compiled. These should only affect\nthe implementation, however, not the public interface.\n\nThis commit also ended up touching a lot of code related to `#[derive]`, making\na few notable changes:\n\n* Recognized derive attributes are no longer desugared to `derive_Foo`. Wasn't\n  sure how to keep this behavior and *not* expose it to custom derive.\n\n* Derive attributes no longer have access to unstable features by default, they\n  have to opt in on a granular level.\n\n* The `derive(Copy,Clone)` optimization is now done through another \"obscure\n  attribute\" which is just intended to ferry along in the compiler that such an\n  optimization is possible. The `derive(PartialEq,Eq)` optimization was also\n  updated to do something similar.\n\n---\n\nOne part of this PR which needs to be improved before stabilizing are the errors\nand exact interfaces here. The error messages are relatively poor quality and\nthere are surprising spects of this such as `#[derive(PartialEq, Eq, MyTrait)]`\nnot working by default. The custom attributes added by the compiler end up\nbecoming unstable again when going through a custom impl.\n\nHopefully though this is enough to start allowing experimentation on crates.io!", "tree": {"sha": "73d964c30fcb5e94686d3d6e788c66ff06799b8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73d964c30fcb5e94686d3d6e788c66ff06799b8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a029ea343fe5c9b7cf550902b5a507cd8c22a833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a029ea343fe5c9b7cf550902b5a507cd8c22a833", "html_url": "https://github.com/rust-lang/rust/commit/a029ea343fe5c9b7cf550902b5a507cd8c22a833", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a029ea343fe5c9b7cf550902b5a507cd8c22a833/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d128e6bc74ce750ab94dffa422a77e740eba877a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d128e6bc74ce750ab94dffa422a77e740eba877a", "html_url": "https://github.com/rust-lang/rust/commit/d128e6bc74ce750ab94dffa422a77e740eba877a"}, {"sha": "ecc6c39e876b69496bc88ef47ff3a339662346b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc6c39e876b69496bc88ef47ff3a339662346b1", "html_url": "https://github.com/rust-lang/rust/commit/ecc6c39e876b69496bc88ef47ff3a339662346b1"}], "stats": {"total": 2488, "additions": 2211, "deletions": 277}, "files": [{"sha": "06ad07de136b1acea1de0f6db88140c22c66f851", "filename": "mk/crates.mk", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -59,7 +59,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_platform_intrinsics rustc_errors \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n-                rustc_const_eval rustc_const_math rustc_incremental\n+                rustc_const_eval rustc_const_math rustc_incremental rustc_macro\n HOST_CRATES := syntax syntax_ext proc_macro syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n \t\tflate arena graphviz rbml log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n@@ -99,7 +99,7 @@ DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n \n DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n-DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros\n+DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros rustc_macro\n DEPS_proc_macro := syntax syntax_pos rustc_plugin log\n DEPS_syntax_pos := serialize\n \n@@ -118,11 +118,13 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n                      rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n                      rustc_metadata syntax_ext proc_macro \\\n                      rustc_passes rustc_save_analysis rustc_const_eval \\\n-                     rustc_incremental syntax_pos rustc_errors\n+                     rustc_incremental syntax_pos rustc_errors rustc_macro\n DEPS_rustc_errors := log libc serialize syntax_pos\n DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n-DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rbml rustc_const_math\n+DEPS_rustc_macro := std syntax\n+DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rbml rustc_const_math \\\n+\t\t\trustc_macro syntax_ext\n DEPS_rustc_passes := syntax syntax_pos rustc core rustc_const_eval rustc_errors\n DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags\n DEPS_rustc_resolve := arena rustc log syntax syntax_pos rustc_errors"}, {"sha": "7822fe2536f1f7d06dba29ef227eb4689622b8ca", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -139,8 +139,13 @@ fn calculate_type(sess: &session::Session,\n             }\n         }\n \n-        // Everything else falls through below\n-        config::CrateTypeExecutable | config::CrateTypeDylib => {},\n+        // Everything else falls through below. This will happen either with the\n+        // `-C prefer-dynamic` or because we're a rustc-macro crate. Note that\n+        // rustc-macro crates are required to be dylibs, and they're currently\n+        // required to link to libsyntax as well.\n+        config::CrateTypeExecutable |\n+        config::CrateTypeDylib |\n+        config::CrateTypeRustcMacro => {},\n     }\n \n     let mut formats = FnvHashMap();"}, {"sha": "1f9738556d9252b7dee6cf55e8c02c4ecce9fad0", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -138,7 +138,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Creates a new reachability computation context.\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n-            *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib\n+            *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n+            *ty == config::CrateTypeRustcMacro\n         });\n         ReachableContext {\n             tcx: tcx,"}, {"sha": "c2f275e6deaf82671a27c49f4aad8e88b1bf43ad", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -70,6 +70,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     let needs_check = sess.crate_types.borrow().iter().any(|kind| {\n         match *kind {\n             config::CrateTypeDylib |\n+            config::CrateTypeRustcMacro |\n             config::CrateTypeCdylib |\n             config::CrateTypeExecutable |\n             config::CrateTypeStaticlib => true,"}, {"sha": "a2f926aa92c5232dce362799e18caa16c105a5d9", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -475,6 +475,7 @@ pub enum CrateType {\n     CrateTypeRlib,\n     CrateTypeStaticlib,\n     CrateTypeCdylib,\n+    CrateTypeRustcMacro,\n }\n \n #[derive(Clone, Hash)]\n@@ -962,6 +963,9 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     if sess.opts.debug_assertions {\n         ret.push(attr::mk_word_item(InternedString::new(\"debug_assertions\")));\n     }\n+    if sess.opts.crate_types.contains(&CrateTypeRustcMacro) {\n+        ret.push(attr::mk_word_item(InternedString::new(\"rustc_macro\")));\n+    }\n     return ret;\n }\n \n@@ -1547,6 +1551,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n                 \"dylib\"     => CrateTypeDylib,\n                 \"cdylib\"    => CrateTypeCdylib,\n                 \"bin\"       => CrateTypeExecutable,\n+                \"rustc-macro\" => CrateTypeRustcMacro,\n                 _ => {\n                     return Err(format!(\"unknown crate type: `{}`\",\n                                        part));\n@@ -1635,6 +1640,7 @@ impl fmt::Display for CrateType {\n             CrateTypeRlib => \"rlib\".fmt(f),\n             CrateTypeStaticlib => \"staticlib\".fmt(f),\n             CrateTypeCdylib => \"cdylib\".fmt(f),\n+            CrateTypeRustcMacro => \"rustc-macro\".fmt(f),\n         }\n     }\n }"}, {"sha": "ee2837e7bf1ab5abc6ebaf626a1196439b69a49c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -62,6 +62,7 @@ pub struct Session {\n     pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n     pub entry_type: Cell<Option<config::EntryFnType>>,\n     pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n+    pub derive_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub default_sysroot: Option<PathBuf>,\n     // The name of the root source file of the crate, in the local file system.\n     // The path is always expected to be absolute. `None` means that there is no\n@@ -314,6 +315,12 @@ impl Session {\n         format!(\"__rustc_plugin_registrar__{}_{}\", svh, index.as_usize())\n     }\n \n+    pub fn generate_derive_registrar_symbol(&self,\n+                                            svh: &Svh,\n+                                            index: DefIndex) -> String {\n+        format!(\"__rustc_derive_registrar__{}_{}\", svh, index.as_usize())\n+    }\n+\n     pub fn sysroot<'a>(&'a self) -> &'a Path {\n         match self.opts.maybe_sysroot {\n             Some (ref sysroot) => sysroot,\n@@ -501,6 +508,7 @@ pub fn build_session_(sopts: config::Options,\n         entry_fn: RefCell::new(None),\n         entry_type: Cell::new(None),\n         plugin_registrar_fn: Cell::new(None),\n+        derive_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n         working_dir: env::current_dir().unwrap(),"}, {"sha": "725bbf6adfd42c333d1433286a386c13d7f7ec1a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -495,6 +495,10 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Cache for layouts computed from types.\n     pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n+\n+    /// Map from function to the `#[derive]` mode that it's defining. Only used\n+    /// by `rustc-macro` crates.\n+    pub derive_macros: RefCell<NodeMap<token::InternedString>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -756,6 +760,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             crate_name: token::intern_and_get_ident(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FnvHashMap()),\n+            derive_macros: RefCell::new(NodeMap()),\n        }, f)\n     }\n }"}, {"sha": "ea7621e16e7b7de192c4054bc4862f0064d9c044", "filename": "src/librustc_driver/derive_registrar.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_driver%2Fderive_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_driver%2Fderive_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fderive_registrar.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::dep_graph::DepNode;\n+use rustc::hir::intravisit::Visitor;\n+use rustc::hir::map::Map;\n+use rustc::hir;\n+use syntax::ast;\n+use syntax::attr;\n+\n+pub fn find(hir_map: &Map) -> Option<ast::NodeId> {\n+    let _task = hir_map.dep_graph.in_task(DepNode::PluginRegistrar);\n+    let krate = hir_map.krate();\n+\n+    let mut finder = Finder { registrar: None };\n+    krate.visit_all_items(&mut finder);\n+    finder.registrar\n+}\n+\n+struct Finder {\n+    registrar: Option<ast::NodeId>,\n+}\n+\n+impl<'v> Visitor<'v> for Finder {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        if attr::contains_name(&item.attrs, \"rustc_derive_registrar\") {\n+            self.registrar = Some(item.id);\n+        }\n+    }\n+}"}, {"sha": "47a0399b63283ec4898d27a7cf462791c6e52253", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -55,6 +55,8 @@ use syntax::util::node_count::NodeCounter;\n use syntax;\n use syntax_ext;\n \n+use derive_registrar;\n+\n #[derive(Clone)]\n pub struct Resolutions {\n     pub def_map: DefMap,\n@@ -696,6 +698,18 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n                                          sess.diagnostic())\n     });\n \n+    krate = time(time_passes, \"maybe creating a macro crate\", || {\n+        let crate_types = sess.crate_types.borrow();\n+        let is_rustc_macro_crate = crate_types.contains(&config::CrateTypeRustcMacro);\n+        let num_crate_types = crate_types.len();\n+        syntax_ext::rustc_macro_registrar::modify(&sess.parse_sess,\n+                                                  krate,\n+                                                  is_rustc_macro_crate,\n+                                                  num_crate_types,\n+                                                  sess.diagnostic(),\n+                                                  &sess.features.borrow())\n+    });\n+\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess, make_glob_map, &resolver_arenas);\n \n@@ -838,6 +852,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     sess.plugin_registrar_fn.set(time(time_passes, \"looking for plugin registrar\", || {\n         plugin::build::find_plugin_registrar(sess.diagnostic(), &hir_map)\n     }));\n+    sess.derive_registrar_fn.set(derive_registrar::find(&hir_map));\n \n     let region_map = time(time_passes,\n                           \"region resolution\",\n@@ -1171,6 +1186,9 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                          Some(ref n) if *n == \"staticlib\" => {\n                              Some(config::CrateTypeStaticlib)\n                          }\n+                         Some(ref n) if *n == \"rustc-macro\" => {\n+                             Some(config::CrateTypeRustcMacro)\n+                         }\n                          Some(ref n) if *n == \"bin\" => Some(config::CrateTypeExecutable),\n                          Some(_) => {\n                              session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,"}, {"sha": "6616e9579e818dd2c190e9e645521302ad2b23e3", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -107,7 +107,7 @@ pub mod test;\n pub mod driver;\n pub mod pretty;\n pub mod target_features;\n-\n+mod derive_registrar;\n \n const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n                                       md#bug-reports\";"}, {"sha": "6b3ee21d9acebf074b48643b5227a0377a708b38", "filename": "src/librustc_macro/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macro%2FCargo.toml?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_macro\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_macro\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "c2a2cc2ecd64d9c7414aafea261843b3858db034", "filename": "src/librustc_macro/lib.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macro%2Flib.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A support library for macro authors when defining new macros.\n+//!\n+//! This library, provided by the standard distribution, provides the types\n+//! consumed in the interfaces of procedurally defined macro definitions.\n+//! Currently the primary use of this crate is to provide the ability to define\n+//! new custom derive modes through `#[rustc_macro_derive]`.\n+//!\n+//! Added recently as part of [RFC 1681] this crate is currently *unstable* and\n+//! requires the `#![feature(rustc_macro_lib)]` directive to use. Eventually,\n+//! though, it is intended for this crate to become stable to use (perhaps under\n+//! a different name).\n+//!\n+//! [RFC 1681]: https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md\n+//!\n+//! Note that this crate is intentionally very bare-bones currently. The main\n+//! type, `TokenStream`, only supports `fmt::Display` and `FromStr`\n+//! implementations, indicating that it can only go to and come from a string.\n+//! This functionality is intended to be expanded over time as more surface\n+//! area for macro authors is stabilized.\n+\n+#![crate_name = \"rustc_macro\"]\n+#![unstable(feature = \"rustc_macro_lib\", issue = \"27812\")]\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(missing_docs)]\n+\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+#![feature(lang_items)]\n+\n+extern crate syntax;\n+\n+use std::fmt;\n+use std::str::FromStr;\n+\n+use syntax::ast;\n+use syntax::parse;\n+use syntax::ptr::P;\n+\n+/// The main type provided by this crate, representing an abstract stream of\n+/// tokens.\n+///\n+/// This is both the input and output of `#[rustc_macro_derive]` definitions.\n+/// Currently it's required to be a list of valid Rust items, but this\n+/// restriction may be lifted in the future.\n+///\n+/// The API of this type is intentionally bare-bones, but it'll be expanded over\n+/// time!\n+pub struct TokenStream {\n+    inner: Vec<P<ast::Item>>,\n+}\n+\n+/// Error returned from `TokenStream::from_str`.\n+#[derive(Debug)]\n+pub struct LexError {\n+    _inner: (),\n+}\n+\n+/// Permanently unstable internal implementation details of this crate. This\n+/// should not be used.\n+///\n+/// These methods are used by the rest of the compiler to generate instances of\n+/// `TokenStream` to hand to macro definitions, as well as consume the output.\n+///\n+/// Note that this module is also intentionally separate from the rest of the\n+/// crate. This allows the `#[unstable]` directive below to naturally apply to\n+/// all of the contents.\n+#[unstable(feature = \"rustc_macro_internals\", issue = \"27812\")]\n+#[doc(hidden)]\n+pub mod __internal {\n+    use std::cell::Cell;\n+\n+    use syntax::ast;\n+    use syntax::ptr::P;\n+    use syntax::parse::ParseSess;\n+    use super::TokenStream;\n+\n+    pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {\n+        TokenStream { inner: vec![item] }\n+    }\n+\n+    pub fn token_stream_items(stream: TokenStream) -> Vec<P<ast::Item>> {\n+        stream.inner\n+    }\n+\n+    pub trait Registry {\n+        fn register_custom_derive(&mut self,\n+                                  trait_name: &str,\n+                                  expand: fn(TokenStream) -> TokenStream);\n+    }\n+\n+    // Emulate scoped_thread_local!() here essentially\n+    thread_local! {\n+        static CURRENT_SESS: Cell<*const ParseSess> = Cell::new(0 as *const _);\n+    }\n+\n+    pub fn set_parse_sess<F, R>(sess: &ParseSess, f: F) -> R\n+        where F: FnOnce() -> R\n+    {\n+        struct Reset { prev: *const ParseSess }\n+\n+        impl Drop for Reset {\n+            fn drop(&mut self) {\n+                CURRENT_SESS.with(|p| p.set(self.prev));\n+            }\n+        }\n+\n+        CURRENT_SESS.with(|p| {\n+            let _reset = Reset { prev: p.get() };\n+            p.set(sess);\n+            f()\n+        })\n+    }\n+\n+    pub fn with_parse_sess<F, R>(f: F) -> R\n+        where F: FnOnce(&ParseSess) -> R\n+    {\n+        let p = CURRENT_SESS.with(|p| p.get());\n+        assert!(!p.is_null());\n+        f(unsafe { &*p })\n+    }\n+}\n+\n+impl FromStr for TokenStream {\n+    type Err = LexError;\n+\n+    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n+        __internal::with_parse_sess(|sess| {\n+            let src = src.to_string();\n+            let cfg = Vec::new();\n+            let name = \"rustc-macro source code\".to_string();\n+            let mut parser = parse::new_parser_from_source_str(sess, cfg, name,\n+                                                               src);\n+            let mut ret = TokenStream { inner: Vec::new() };\n+            loop {\n+                match parser.parse_item() {\n+                    Ok(Some(item)) => ret.inner.push(item),\n+                    Ok(None) => return Ok(ret),\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        return Err(LexError { _inner: () })\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+impl fmt::Display for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for item in self.inner.iter() {\n+            let item = syntax::print::pprust::item_to_string(item);\n+            try!(f.write_str(&item));\n+            try!(f.write_str(\"\\n\"));\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "d70510896b96e97f7bd28a589a4bc16c79b48b72", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -19,6 +19,8 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_macro = { path = \"../librustc_macro\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_ext = { path = \"../libsyntax_ext\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "1e6c74bef8da570e2e3d8ec86a99c80dfd6609fa", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -234,6 +234,8 @@ pub fn rustc_version() -> String {\n \n pub const tag_panic_strategy: usize = 0x114;\n \n+pub const tag_macro_derive_registrar: usize = 0x115;\n+\n // NB: increment this if you change the format of metadata such that\n // rustc_version can't be found.\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2];"}, {"sha": "2524348dc1a96e52f47fde721ee4236c31cd1159", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 148, "deletions": 56, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -130,18 +130,23 @@ struct ExtensionCrate {\n     metadata: PMDSource,\n     dylib: Option<PathBuf>,\n     target_only: bool,\n+\n+    ident: String,\n+    name: String,\n+    span: Span,\n+    should_link: bool,\n }\n \n enum PMDSource {\n     Registered(Rc<cstore::CrateMetadata>),\n-    Owned(MetadataBlob),\n+    Owned(loader::Library),\n }\n \n impl PMDSource {\n     pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n         match *self {\n             PMDSource::Registered(ref cmd) => cmd.data(),\n-            PMDSource::Owned(ref mdb) => mdb.as_slice(),\n+            PMDSource::Owned(ref lib) => lib.metadata.as_slice(),\n         }\n     }\n }\n@@ -151,6 +156,17 @@ enum LoadResult {\n     Loaded(loader::Library),\n }\n \n+pub struct Macros {\n+    pub macro_rules: Vec<ast::MacroDef>,\n+\n+    /// An array of pairs where the first element is the name of the custom\n+    /// derive (e.g. the trait being derived) and the second element is the\n+    /// index of the definition.\n+    pub custom_derive_registrar: Option<DefIndex>,\n+    pub svh: Svh,\n+    pub dylib: Option<PathBuf>,\n+}\n+\n impl<'a> CrateReader<'a> {\n     pub fn new(sess: &'a Session,\n                cstore: &'a CStore,\n@@ -281,6 +297,7 @@ impl<'a> CrateReader<'a> {\n                       explicitly_linked: bool)\n                       -> (ast::CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n+        info!(\"register crate `extern crate {} as {}`\", name, ident);\n         self.verify_no_symbol_conflicts(span, &lib.metadata);\n \n         // Claim this crate number and cache it\n@@ -319,6 +336,11 @@ impl<'a> CrateReader<'a> {\n             explicitly_linked: Cell::new(explicitly_linked),\n         });\n \n+        if decoder::get_derive_registrar_fn(cmeta.data.as_slice()).is_some() {\n+            self.sess.span_err(span, \"crates of the `rustc-macro` crate type \\\n+                                      cannot be linked at runtime\");\n+        }\n+\n         let source = cstore::CrateSource {\n             dylib: dylib,\n             rlib: rlib,\n@@ -349,9 +371,11 @@ impl<'a> CrateReader<'a> {\n                      kind: PathKind,\n                      explicitly_linked: bool)\n                      -> (ast::CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n+        info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n         let result = match self.existing_match(name, hash, kind) {\n             Some(cnum) => LoadResult::Previous(cnum),\n             None => {\n+                info!(\"falling back to a load\");\n                 let mut load_ctxt = loader::Context {\n                     sess: self.sess,\n                     span: span,\n@@ -412,6 +436,7 @@ impl<'a> CrateReader<'a> {\n             self.cstore.iter_crate_data(|cnum, data| {\n                 if data.name() == meta_name && meta_hash == data.hash() {\n                     assert!(loader.hash.is_none());\n+                    info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n                 }\n             });\n@@ -483,6 +508,8 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n+        info!(\"read extension crate {} `extern crate {} as {}` linked={}\",\n+              info.id, info.name, info.ident, info.should_link);\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n@@ -533,16 +560,7 @@ impl<'a> CrateReader<'a> {\n             }\n             LoadResult::Loaded(library) => {\n                 let dylib = library.dylib.clone();\n-                let metadata = if should_link {\n-                    // Register crate now to avoid double-reading metadata\n-                    let (_, cmd, _) = self.register_crate(&None, &info.ident,\n-                                                          &info.name, span,\n-                                                          library, true);\n-                    PMDSource::Registered(cmd)\n-                } else {\n-                    // Not registering the crate; just hold on to the metadata\n-                    PMDSource::Owned(library.metadata)\n-                };\n+                let metadata = PMDSource::Owned(library);\n                 (dylib, metadata)\n             }\n         };\n@@ -551,59 +569,97 @@ impl<'a> CrateReader<'a> {\n             metadata: metadata,\n             dylib: dylib.map(|p| p.0),\n             target_only: target_only,\n+            name: info.name.to_string(),\n+            ident: info.ident.to_string(),\n+            span: span,\n+            should_link: should_link,\n         }\n     }\n \n-    /// Read exported macros.\n-    pub fn read_exported_macros(&mut self, item: &ast::Item) -> Vec<ast::MacroDef> {\n+    pub fn read_macros(&mut self, item: &ast::Item) -> Macros {\n         let ci = self.extract_crate_info(item).unwrap();\n         let ekrate = self.read_extension_crate(item.span, &ci);\n \n         let source_name = format!(\"<{} macros>\", item.ident);\n-        let mut macros = vec![];\n+        let mut ret = Macros {\n+            macro_rules: Vec::new(),\n+            custom_derive_registrar: None,\n+            svh: decoder::get_crate_hash(ekrate.metadata.as_slice()),\n+            dylib: None,\n+        };\n         decoder::each_exported_macro(ekrate.metadata.as_slice(),\n-            |name, attrs, span, body| {\n-                // NB: Don't use parse::parse_tts_from_source_str because it parses with\n-                // quote_depth > 0.\n-                let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n-                                                              self.local_crate_config.clone(),\n-                                                              source_name.clone(),\n-                                                              body);\n-                let lo = p.span.lo;\n-                let body = match p.parse_all_token_trees() {\n-                    Ok(body) => body,\n-                    Err(mut err) => {\n-                        err.emit();\n-                        self.sess.abort_if_errors();\n-                        unreachable!();\n-                    }\n-                };\n-                let local_span = mk_sp(lo, p.last_span.hi);\n-\n-                // Mark the attrs as used\n-                for attr in &attrs {\n-                    attr::mark_used(attr);\n+                                     |name, attrs, span, body| {\n+            // NB: Don't use parse::parse_tts_from_source_str because it parses with\n+            // quote_depth > 0.\n+            let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n+                                                          self.local_crate_config.clone(),\n+                                                          source_name.clone(),\n+                                                          body);\n+            let lo = p.span.lo;\n+            let body = match p.parse_all_token_trees() {\n+                Ok(body) => body,\n+                Err(mut err) => {\n+                    err.emit();\n+                    self.sess.abort_if_errors();\n+                    unreachable!();\n                 }\n+            };\n+            let local_span = mk_sp(lo, p.last_span.hi);\n \n-                macros.push(ast::MacroDef {\n-                    ident: ast::Ident::with_empty_ctxt(name),\n-                    attrs: attrs,\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: local_span,\n-                    imported_from: Some(item.ident),\n-                    // overridden in plugin/load.rs\n-                    export: false,\n-                    use_locally: false,\n-                    allow_internal_unstable: false,\n-\n-                    body: body,\n-                });\n-                self.sess.imported_macro_spans.borrow_mut()\n-                    .insert(local_span, (name.as_str().to_string(), span));\n-                true\n+            // Mark the attrs as used\n+            for attr in &attrs {\n+                attr::mark_used(attr);\n+            }\n+\n+            ret.macro_rules.push(ast::MacroDef {\n+                ident: ast::Ident::with_empty_ctxt(name),\n+                attrs: attrs,\n+                id: ast::DUMMY_NODE_ID,\n+                span: local_span,\n+                imported_from: Some(item.ident),\n+                // overridden in plugin/load.rs\n+                export: false,\n+                use_locally: false,\n+                allow_internal_unstable: false,\n+\n+                body: body,\n+            });\n+            self.sess.imported_macro_spans.borrow_mut()\n+                .insert(local_span, (name.as_str().to_string(), span));\n+            true\n+        });\n+\n+        match decoder::get_derive_registrar_fn(ekrate.metadata.as_slice()) {\n+            Some(id) => ret.custom_derive_registrar = Some(id),\n+\n+            // If this crate is not a rustc-macro crate then we might be able to\n+            // register it with the local crate store to prevent loading the\n+            // metadata twice.\n+            //\n+            // If it's a rustc-macro crate, though, then we definitely don't\n+            // want to register it with the local crate store as we're just\n+            // going to use it as we would a plugin.\n+            None => {\n+                ekrate.register(self);\n+                return ret\n             }\n-        );\n-        macros\n+        }\n+\n+        self.cstore.add_used_for_derive_macros(item);\n+        ret.dylib = ekrate.dylib.clone();\n+        if ret.dylib.is_none() {\n+            span_bug!(item.span, \"rustc-macro crate not dylib\");\n+        }\n+\n+        if ekrate.target_only {\n+            let message = format!(\"rustc-macro crate is not available for \\\n+                                   triple `{}` (only found {})\",\n+                                  config::host_triple(),\n+                                  self.sess.opts.target_triple);\n+            self.sess.span_fatal(item.span, &message);\n+        }\n+\n+        return ret\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate\n@@ -774,6 +830,7 @@ impl<'a> CrateReader<'a> {\n             match *ct {\n                 config::CrateTypeExecutable => need_exe_alloc = true,\n                 config::CrateTypeDylib |\n+                config::CrateTypeRustcMacro |\n                 config::CrateTypeCdylib |\n                 config::CrateTypeStaticlib => need_lib_alloc = true,\n                 config::CrateTypeRlib => {}\n@@ -858,6 +915,27 @@ impl<'a> CrateReader<'a> {\n     }\n }\n \n+impl ExtensionCrate {\n+    fn register(self, creader: &mut CrateReader) {\n+        if !self.should_link {\n+            return\n+        }\n+\n+        let library = match self.metadata {\n+            PMDSource::Owned(lib) => lib,\n+            PMDSource::Registered(_) => return,\n+        };\n+\n+        // Register crate now to avoid double-reading metadata\n+        creader.register_crate(&None,\n+                               &self.ident,\n+                               &self.name,\n+                               self.span,\n+                               library,\n+                               true);\n+    }\n+}\n+\n impl<'a> LocalCrateReader<'a> {\n     fn new(sess: &'a Session,\n            cstore: &'a CStore,\n@@ -906,11 +984,25 @@ impl<'a> LocalCrateReader<'a> {\n     fn process_item(&mut self, i: &ast::Item) {\n         match i.node {\n             ast::ItemKind::ExternCrate(_) => {\n-                if !should_link(i) {\n-                    return;\n+                // If this `extern crate` item has `#[macro_use]` then we can\n+                // safely skip it. These annotations were processed during macro\n+                // expansion and are already loaded (if necessary) into our\n+                // crate store.\n+                //\n+                // Note that it's important we *don't* fall through below as\n+                // some `#[macro_use]` crate are explicitly not linked (e.g.\n+                // macro crates) so we want to ensure we avoid `resolve_crate`\n+                // with those.\n+                if attr::contains_name(&i.attrs, \"macro_use\") {\n+                    if self.cstore.was_used_for_derive_macros(i) {\n+                        return\n+                    }\n                 }\n \n                 if let Some(info) = self.creader.extract_crate_info(i) {\n+                    if !info.should_link {\n+                        return;\n+                    }\n                     let (cnum, _, _) = self.creader.resolve_crate(&None,\n                                                                   &info.ident,\n                                                                   &info.name,"}, {"sha": "952d7008d0f272546ea8bac832c178f131e5d234", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -28,13 +28,13 @@ use rustc::hir::svh::Svh;\n use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n+use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap, FnvHashSet};\n \n use std::cell::{RefCell, Ref, Cell};\n use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n-use syntax::ast;\n+use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::codemap;\n use syntax_pos;\n@@ -115,6 +115,7 @@ pub struct CStore {\n     pub inlined_item_cache: RefCell<DefIdMap<Option<CachedInlinedItem>>>,\n     pub defid_for_inlined_node: RefCell<NodeMap<DefId>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n+    pub used_for_derive_macro: RefCell<FnvHashSet<Ident>>,\n }\n \n impl CStore {\n@@ -130,6 +131,7 @@ impl CStore {\n             visible_parent_map: RefCell::new(FnvHashMap()),\n             inlined_item_cache: RefCell::new(FnvHashMap()),\n             defid_for_inlined_node: RefCell::new(FnvHashMap()),\n+            used_for_derive_macro: RefCell::new(FnvHashSet()),\n         }\n     }\n \n@@ -286,6 +288,14 @@ impl CStore {\n     {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n+\n+    pub fn was_used_for_derive_macros(&self, i: &ast::Item) -> bool {\n+        self.used_for_derive_macro.borrow().contains(&i.ident)\n+    }\n+\n+    pub fn add_used_for_derive_macros(&self, i: &ast::Item) {\n+        self.used_for_derive_macro.borrow_mut().insert(i.ident);\n+    }\n }\n \n impl CrateMetadata {"}, {"sha": "9a13be8ade52a9ff26d79e61a54db41a9d5f2046", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -1398,6 +1398,11 @@ pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n     }\n }\n \n+pub fn get_derive_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n+    reader::maybe_get_doc(rbml::Doc::new(data), tag_macro_derive_registrar)\n+        .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n+}\n+\n pub fn get_macro_span(doc: rbml::Doc) -> Span {\n     let lo_doc = reader::get_doc(doc, tag_macro_def_span_lo);\n     let lo = BytePos(reader::doc_as_u32(lo_doc));"}, {"sha": "bb4cf70bd3b3e0435c1fa7633a3edac86815b380", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -31,7 +31,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n \n use rustc::hir::svh::Svh;\n use rustc::mir::mir_map::MirMap;\n-use rustc::session::config::{self, PanicStrategy};\n+use rustc::session::config::{self, PanicStrategy, CrateTypeRustcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n use rustc_serialize::Encodable;\n@@ -1567,7 +1567,8 @@ fn encode_codemap(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n /// Serialize the text of the exported macros\n fn encode_macro_defs(rbml_w: &mut Encoder,\n-                     krate: &hir::Crate) {\n+                     krate: &hir::Crate,\n+                     tcx: TyCtxt) {\n     rbml_w.start_tag(tag_macro_defs);\n     for def in &krate.exported_macros {\n         rbml_w.start_tag(tag_macro_def);\n@@ -1585,6 +1586,12 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n+\n+    if tcx.sess.crate_types.borrow().contains(&CrateTypeRustcMacro) {\n+        let id = tcx.sess.derive_registrar_fn.get().unwrap();\n+        let did = tcx.map.local_def_id(id);\n+        rbml_w.wr_tagged_u32(tag_macro_derive_registrar, did.index.as_u32());\n+    }\n }\n \n fn encode_struct_field_attrs(ecx: &EncodeContext,\n@@ -1882,7 +1889,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n \n     // Encode macro definitions\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_macro_defs(rbml_w, krate);\n+    encode_macro_defs(rbml_w, krate, ecx.tcx);\n     stats.macro_defs_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking."}, {"sha": "a3afb9d84bd30d22e19283b9a5eec3639bdf001c", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -19,11 +19,13 @@\n \n #![feature(box_patterns)]\n #![feature(enumset)]\n+#![feature(question_mark)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_macro_lib)]\n+#![feature(rustc_macro_internals)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -33,12 +35,14 @@ extern crate flate;\n extern crate rbml;\n extern crate serialize as rustc_serialize; // used by deriving\n extern crate rustc_errors as errors;\n+extern crate syntax_ext;\n \n #[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_back;\n extern crate rustc_llvm;\n+extern crate rustc_macro;\n extern crate rustc_const_math;\n \n pub use rustc::middle;"}, {"sha": "22691975050e5f8750416b2d44f926e3e00e85d2", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 90, "deletions": 11, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -10,16 +10,25 @@\n \n //! Used by `rustc` when loading a crate with exported macros.\n \n-use creader::CrateReader;\n+use std::collections::HashSet;\n+use std::env;\n+use std::mem;\n+\n+use creader::{CrateReader, Macros};\n use cstore::CStore;\n \n+use rustc::hir::def_id::DefIndex;\n use rustc::session::Session;\n-use rustc::util::nodemap::{FnvHashSet, FnvHashMap};\n-\n-use syntax::parse::token;\n+use rustc::util::nodemap::FnvHashMap;\n+use rustc_back::dynamic_lib::DynamicLibrary;\n+use rustc_macro::TokenStream;\n+use rustc_macro::__internal::Registry;\n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::base::LoadedMacro;\n use syntax::ext;\n+use syntax::parse::token;\n+use syntax_ext::deriving::custom::CustomDerive;\n use syntax_pos::Span;\n \n pub struct MacroLoader<'a> {\n@@ -47,7 +56,9 @@ pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n \n impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n-    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<ast::MacroDef> {\n+    fn load_crate(&mut self,\n+                  extern_crate: &ast::Item,\n+                  allows_macros: bool) -> Vec<LoadedMacro> {\n         // Parse the attributes relating to macros.\n         let mut import = Some(FnvHashMap());  // None => load all\n         let mut reexport = FnvHashMap();\n@@ -105,7 +116,7 @@ impl<'a> MacroLoader<'a> {\n                        allows_macros: bool,\n                        import: Option<MacroSelection>,\n                        reexport: MacroSelection)\n-                       -> Vec<ast::MacroDef> {\n+                       -> Vec<LoadedMacro> {\n         if let Some(sel) = import.as_ref() {\n             if sel.is_empty() && reexport.is_empty() {\n                 return Vec::new();\n@@ -118,10 +129,11 @@ impl<'a> MacroLoader<'a> {\n             return Vec::new();\n         }\n \n-        let mut macros = Vec::new();\n-        let mut seen = FnvHashSet();\n+        let mut macros = self.reader.read_macros(vi);\n+        let mut ret = Vec::new();\n+        let mut seen = HashSet::new();\n \n-        for mut def in self.reader.read_exported_macros(vi) {\n+        for mut def in macros.macro_rules.drain(..) {\n             let name = def.ident.name.as_str();\n \n             def.use_locally = match import.as_ref() {\n@@ -132,10 +144,29 @@ impl<'a> MacroLoader<'a> {\n             def.allow_internal_unstable = attr::contains_name(&def.attrs,\n                                                               \"allow_internal_unstable\");\n             debug!(\"load_macros: loaded: {:?}\", def);\n-            macros.push(def);\n+            ret.push(LoadedMacro::Def(def));\n             seen.insert(name);\n         }\n \n+        if let Some(index) = macros.custom_derive_registrar {\n+            // custom derive crates currently should not have any macro_rules!\n+            // exported macros, enforced elsewhere\n+            assert_eq!(ret.len(), 0);\n+\n+            if import.is_some() {\n+                self.sess.span_err(vi.span, \"`rustc-macro` crates cannot be \\\n+                                             selectively imported from, must \\\n+                                             use `#[macro_use]`\");\n+            }\n+\n+            if reexport.len() > 0 {\n+                self.sess.span_err(vi.span, \"`rustc-macro` crates cannot be \\\n+                                             reexported from\");\n+            }\n+\n+            self.load_derive_macros(vi.span, &macros, index, &mut ret);\n+        }\n+\n         if let Some(sel) = import.as_ref() {\n             for (name, span) in sel {\n                 if !seen.contains(&name) {\n@@ -152,6 +183,54 @@ impl<'a> MacroLoader<'a> {\n             }\n         }\n \n-        macros\n+        return ret\n+    }\n+\n+    /// Load the custom derive macros into the list of macros we're loading.\n+    ///\n+    /// Note that this is intentionally similar to how we load plugins today,\n+    /// but also intentionally separate. Plugins are likely always going to be\n+    /// implemented as dynamic libraries, but we have a possible future where\n+    /// custom derive (and other macro-1.1 style features) are implemented via\n+    /// executables and custom IPC.\n+    fn load_derive_macros(&mut self,\n+                          span: Span,\n+                          macros: &Macros,\n+                          index: DefIndex,\n+                          ret: &mut Vec<LoadedMacro>) {\n+        // Make sure the path contains a / or the linker will search for it.\n+        let path = macros.dylib.as_ref().unwrap();\n+        let path = env::current_dir().unwrap().join(path);\n+        let lib = match DynamicLibrary::open(Some(&path)) {\n+            Ok(lib) => lib,\n+            Err(err) => self.sess.span_fatal(span, &err),\n+        };\n+\n+        let sym = self.sess.generate_derive_registrar_symbol(&macros.svh, index);\n+        let registrar = unsafe {\n+            let sym = match lib.symbol(&sym) {\n+                Ok(f) => f,\n+                Err(err) => self.sess.span_fatal(span, &err),\n+            };\n+            mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n+        };\n+\n+        struct MyRegistrar<'a>(&'a mut Vec<LoadedMacro>);\n+\n+        impl<'a> Registry for MyRegistrar<'a> {\n+            fn register_custom_derive(&mut self,\n+                                      trait_name: &str,\n+                                      expand: fn(TokenStream) -> TokenStream) {\n+                let derive = Box::new(CustomDerive::new(expand));\n+                self.0.push(LoadedMacro::CustomDerive(trait_name.to_string(),\n+                                                      derive));\n+            }\n+        }\n+\n+        registrar(&mut MyRegistrar(ret));\n+\n+        // Intentionally leak the dynamic library. We can't ever unload it\n+        // since the library can make things that will live arbitrarily long.\n+        mem::forget(lib);\n     }\n }"}, {"sha": "6db821b2cd8d19e3001110f251000e10c62cf243", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -156,7 +156,6 @@ impl<'a> Registry<'a> {\n         self.llvm_passes.push(name.to_owned());\n     }\n \n-\n     /// Register an attribute with an attribute type.\n     ///\n     /// Registered attributes will bypass the `custom_attribute` feature gate."}, {"sha": "b970c63a2243369d66785f66b757d6b7456a6a1e", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -238,6 +238,7 @@ pub fn invalid_output_for_target(sess: &Session,\n     match (sess.target.target.options.dynamic_linking,\n            sess.target.target.options.executables, crate_type) {\n         (false, _, config::CrateTypeCdylib) |\n+        (false, _, config::CrateTypeRustcMacro) |\n         (false, _, config::CrateTypeDylib) => true,\n         (_, false, config::CrateTypeExecutable) => true,\n         _ => false\n@@ -261,6 +262,7 @@ pub fn filename_for_input(sess: &Session,\n             outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeCdylib |\n+        config::CrateTypeRustcMacro |\n         config::CrateTypeDylib => {\n             let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n                                     &sess.target.target.options.dll_suffix);\n@@ -291,7 +293,8 @@ pub fn each_linked_rlib(sess: &Session,\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n                    .or_else(|| fmts.get(&config::CrateTypeStaticlib))\n-                   .or_else(|| fmts.get(&config::CrateTypeCdylib));\n+                   .or_else(|| fmts.get(&config::CrateTypeCdylib))\n+                   .or_else(|| fmts.get(&config::CrateTypeRustcMacro));\n     let fmts = fmts.unwrap_or_else(|| {\n         bug!(\"could not find formats for rlibs\")\n     });\n@@ -738,7 +741,8 @@ fn link_args(cmd: &mut Linker,\n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n-    if crate_type == config::CrateTypeDylib {\n+    if crate_type == config::CrateTypeDylib ||\n+       crate_type == config::CrateTypeRustcMacro {\n         cmd.add_object(&outputs.with_extension(\"metadata.o\"));\n     }\n "}, {"sha": "58cad5c117f934a5b7908935c49cc340c15cc66c", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::HashMap;\n use std::ffi::OsString;\n use std::fs::{self, File};\n-use std::io::{self, BufWriter};\n use std::io::prelude::*;\n+use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n@@ -28,16 +29,16 @@ use syntax::ast;\n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n pub struct LinkerInfo {\n-    dylib_exports: Vec<String>,\n-    cdylib_exports: Vec<String>\n+    exports: HashMap<CrateType, Vec<String>>,\n }\n \n impl<'a, 'tcx> LinkerInfo {\n     pub fn new(scx: &SharedCrateContext<'a, 'tcx>,\n                reachable: &[String]) -> LinkerInfo {\n         LinkerInfo {\n-            dylib_exports: exported_symbols(scx, reachable, CrateType::CrateTypeDylib),\n-            cdylib_exports: exported_symbols(scx, reachable, CrateType::CrateTypeCdylib)\n+            exports: scx.sess().crate_types.borrow().iter().map(|&c| {\n+                (c, exported_symbols(scx, reachable, c))\n+            }).collect(),\n         }\n     }\n \n@@ -243,7 +244,8 @@ impl<'a> Linker for GnuLinker<'a> {\n         // exported symbols to ensure we don't expose any more. The object files\n         // have far more public symbols than we actually want to export, so we\n         // hide them all here.\n-        if crate_type == CrateType::CrateTypeDylib {\n+        if crate_type == CrateType::CrateTypeDylib ||\n+           crate_type == CrateType::CrateTypeRustcMacro {\n             return\n         }\n \n@@ -254,7 +256,7 @@ impl<'a> Linker for GnuLinker<'a> {\n             let res = (|| -> io::Result<()> {\n                 let mut f = BufWriter::new(File::create(&path)?);\n                 writeln!(f, \"{{\\n  global:\")?;\n-                for sym in &self.info.cdylib_exports {\n+                for sym in self.info.exports[&crate_type].iter() {\n                     writeln!(f, \"    {};\", sym)?;\n                 }\n                 writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n@@ -274,7 +276,7 @@ impl<'a> Linker for GnuLinker<'a> {\n             };\n             let res = (|| -> io::Result<()> {\n                 let mut f = BufWriter::new(File::create(&path)?);\n-                for sym in &self.info.cdylib_exports {\n+                for sym in self.info.exports[&crate_type].iter() {\n                     writeln!(f, \"{}{}\", prefix, sym)?;\n                 }\n                 Ok(())\n@@ -427,12 +429,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n             // straight to exports.\n             writeln!(f, \"LIBRARY\")?;\n             writeln!(f, \"EXPORTS\")?;\n-            let symbols = if crate_type == CrateType::CrateTypeCdylib {\n-                &self.info.cdylib_exports\n-            } else {\n-                &self.info.dylib_exports\n-            };\n-            for symbol in symbols {\n+            for symbol in self.info.exports[&crate_type].iter() {\n                 writeln!(f, \"  {}\", symbol)?;\n             }\n             Ok(())\n@@ -450,13 +447,10 @@ fn exported_symbols(scx: &SharedCrateContext,\n                     reachable: &[String],\n                     crate_type: CrateType)\n                     -> Vec<String> {\n-    if !scx.sess().crate_types.borrow().contains(&crate_type) {\n-        return vec![];\n-    }\n-\n     // See explanation in GnuLinker::export_symbols, for\n     // why we don't ever need dylib symbols on non-MSVC.\n-    if crate_type == CrateType::CrateTypeDylib {\n+    if crate_type == CrateType::CrateTypeDylib ||\n+       crate_type == CrateType::CrateTypeRustcMacro {\n         if !scx.sess().target.target.options.is_like_msvc {\n             return vec![];\n         }"}, {"sha": "143275fa7117b4eed8755191b8de8e147a426864", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -188,6 +188,11 @@ impl<'a, 'tcx> Instance<'tcx> {\n                 let idx = def_id.index;\n                 return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n             }\n+            if scx.sess().derive_registrar_fn.get() == Some(id) {\n+                let svh = &scx.link_meta().crate_hash;\n+                let idx = def_id.index;\n+                return scx.sess().generate_derive_registrar_symbol(svh, idx);\n+            }\n         }\n \n         // FIXME(eddyb) Precompute a custom symbol name based on attributes."}, {"sha": "3b1c01319c492fc6b825250da7433c35038a50e1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -27,10 +27,10 @@ use ptr::P;\n use util::small_vector::SmallVector;\n use util::lev_distance::find_best_match_for_name;\n use fold::Folder;\n+use feature_gate;\n \n use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n-use std::default::Default;\n use tokenstream;\n \n \n@@ -568,12 +568,18 @@ fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n }\n \n pub trait MacroLoader {\n-    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<ast::MacroDef>;\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool)\n+                  -> Vec<LoadedMacro>;\n+}\n+\n+pub enum LoadedMacro {\n+    Def(ast::MacroDef),\n+    CustomDerive(String, Box<MultiItemModifier>),\n }\n \n pub struct DummyMacroLoader;\n impl MacroLoader for DummyMacroLoader {\n-    fn load_crate(&mut self, _: &ast::Item, _: bool) -> Vec<ast::MacroDef> {\n+    fn load_crate(&mut self, _: &ast::Item, _: bool) -> Vec<LoadedMacro> {\n         Vec::new()\n     }\n }\n@@ -593,6 +599,7 @@ pub struct ExtCtxt<'a> {\n     pub exported_macros: Vec<ast::MacroDef>,\n \n     pub syntax_env: SyntaxEnv,\n+    pub derive_modes: HashMap<InternedString, Box<MultiItemModifier>>,\n     pub recursion_count: usize,\n \n     pub filename: Option<String>,\n@@ -616,6 +623,7 @@ impl<'a> ExtCtxt<'a> {\n             exported_macros: Vec::new(),\n             loader: loader,\n             syntax_env: env,\n+            derive_modes: HashMap::new(),\n             recursion_count: 0,\n \n             filename: None,\n@@ -714,6 +722,25 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n+    pub fn insert_custom_derive(&mut self,\n+                                name: &str,\n+                                ext: Box<MultiItemModifier>,\n+                                sp: Span) {\n+        if !self.ecfg.enable_rustc_macro() {\n+            feature_gate::emit_feature_err(&self.parse_sess.span_diagnostic,\n+                                           \"rustc_macro\",\n+                                           sp,\n+                                           feature_gate::GateIssue::Language,\n+                                           \"loading custom derive macro crates \\\n+                                            is experimentally supported\");\n+        }\n+        let name = token::intern_and_get_ident(name);\n+        if self.derive_modes.insert(name.clone(), ext).is_some() {\n+            self.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\",\n+                                       name));\n+        }\n+    }\n+\n     pub fn struct_span_warn(&self,\n                             sp: Span,\n                             msg: &str)"}, {"sha": "d06b77a5b0549a0eb2d5c32d0096667996b045c8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -440,8 +440,7 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n                 callee: NameAndSpan {\n                     format: MacroAttribute(intern(&attr.name())),\n                     span: Some(attr.span),\n-                    // attributes can do whatever they like, for now\n-                    allow_internal_unstable: true,\n+                    allow_internal_unstable: false,\n                 }\n             });\n \n@@ -538,7 +537,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     // We need to error on `#[macro_use] extern crate` when it isn't at the\n                     // crate root, because `$crate` won't work properly.\n                     for def in self.cx.loader.load_crate(item, self.at_crate_root) {\n-                        self.cx.insert_macro(def);\n+                        match def {\n+                            LoadedMacro::Def(def) => self.cx.insert_macro(def),\n+                            LoadedMacro::CustomDerive(name, ext) => {\n+                                self.cx.insert_custom_derive(&name, ext, item.span);\n+                            }\n+                        }\n                     }\n                 } else {\n                     let at_crate_root = ::std::mem::replace(&mut self.at_crate_root, false);\n@@ -688,6 +692,7 @@ impl<'feat> ExpansionConfig<'feat> {\n         fn enable_allow_internal_unstable = allow_internal_unstable,\n         fn enable_custom_derive = custom_derive,\n         fn enable_pushpop_unsafe = pushpop_unsafe,\n+        fn enable_rustc_macro = rustc_macro,\n     }\n }\n "}, {"sha": "683d5277359e84e430dd8504a81aab2bf4d0fe64", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -47,7 +47,7 @@ macro_rules! setter {\n }\n \n macro_rules! declare_features {\n-    ($((active, $feature: ident, $ver: expr, $issue: expr)),+) => {\n+    ($((active, $feature: ident, $ver: expr, $issue: expr),)+) => {\n         /// Represents active features that are currently being implemented or\n         /// currently being considered for addition/removal.\n         const ACTIVE_FEATURES: &'static [(&'static str, &'static str,\n@@ -75,14 +75,14 @@ macro_rules! declare_features {\n         }\n     };\n \n-    ($((removed, $feature: ident, $ver: expr, $issue: expr)),+) => {\n+    ($((removed, $feature: ident, $ver: expr, $issue: expr),)+) => {\n         /// Represents features which has since been removed (it was once Active)\n         const REMOVED_FEATURES: &'static [(&'static str, &'static str, Option<u32>)] = &[\n             $((stringify!($feature), $ver, $issue)),+\n         ];\n     };\n \n-    ($((accepted, $feature: ident, $ver: expr, $issue: expr)),+) => {\n+    ($((accepted, $feature: ident, $ver: expr, $issue: expr),)+) => {\n         /// Those language feature has since been Accepted (it was once Active)\n         const ACCEPTED_FEATURES: &'static [(&'static str, &'static str, Option<u32>)] = &[\n             $((stringify!($feature), $ver, $issue)),+\n@@ -288,7 +288,10 @@ declare_features! (\n     (active, abi_sysv64, \"1.13.0\", Some(36167)),\n \n     // Use the import semantics from RFC 1560.\n-    (active, item_like_imports, \"1.13.0\", Some(35120))\n+    (active, item_like_imports, \"1.13.0\", Some(35120)),\n+\n+    // Macros 1.1\n+    (active, rustc_macro, \"1.13.0\", Some(35900)),\n );\n \n declare_features! (\n@@ -302,7 +305,6 @@ declare_features! (\n     (removed, struct_inherit, \"1.0.0\", None),\n     (removed, test_removed_feature, \"1.0.0\", None),\n     (removed, visible_private_types, \"1.0.0\", None),\n-    (removed, unsafe_no_drop_flag, \"1.0.0\", None)\n );\n \n declare_features! (\n@@ -330,7 +332,7 @@ declare_features! (\n     (accepted, type_macros, \"1.13.0\", Some(27245)),\n     (accepted, while_let, \"1.0.0\", None),\n     // Allows `#[deprecated]` attribute\n-    (accepted, deprecated, \"1.9.0\", Some(29935))\n+    (accepted, deprecated, \"1.9.0\", Some(29935)),\n );\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -543,6 +545,15 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                    is an experimental feature\",\n                                   cfg_fn!(linked_from))),\n \n+    (\"rustc_macro_derive\", Normal, Gated(\"rustc_macro\",\n+                                         \"the `#[rustc_macro_derive]` attribute \\\n+                                          is an experimental feature\",\n+                                         cfg_fn!(rustc_macro))),\n+\n+    (\"rustc_copy_clone_marker\", Whitelisted, Gated(\"rustc_attrs\",\n+                                                   \"internal implementation detail\",\n+                                                   cfg_fn!(rustc_attrs))),\n+\n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted, Ungated),\n \n@@ -616,6 +627,7 @@ const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)]\n     (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(cfg_target_vendor)),\n     (\"target_thread_local\", \"cfg_target_thread_local\", cfg_fn!(cfg_target_thread_local)),\n     (\"target_has_atomic\", \"cfg_target_has_atomic\", cfg_fn!(cfg_target_has_atomic)),\n+    (\"rustc_macro\", \"rustc_macro\", cfg_fn!(rustc_macro)),\n ];\n \n #[derive(Debug, Eq, PartialEq)]"}, {"sha": "6910e6400d4f8e42966c11ee1d8e793742d5bdd6", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -11,6 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n fmt_macros = { path = \"../libfmt_macros\" }\n log = { path = \"../liblog\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_macro = { path = \"../librustc_macro\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n\\ No newline at end of file"}, {"sha": "c7afaaf4796a4d7229276f39771370e371f1cddc", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -49,7 +49,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                 ItemKind::Struct(_, Generics { ref ty_params, .. }) |\n                 ItemKind::Enum(_, Generics { ref ty_params, .. })\n                     if ty_params.is_empty() &&\n-                       attr::contains_name(&annitem.attrs, \"derive_Copy\") => {\n+                       attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") => {\n \n                     bounds = vec![Literal(path_std!(cx, core::marker::Copy))];\n                     unify_fieldless_variants = true;\n@@ -110,12 +110,12 @@ fn cs_clone(name: &str,\n         Mode::Shallow => cx.std_path(&[\"clone\", \"assert_receiver_is_clone\"]),\n         Mode::Deep => cx.std_path(&[\"clone\", \"Clone\", \"clone\"]),\n     };\n-    let subcall = |field: &FieldInfo| {\n+    let subcall = |cx: &mut ExtCtxt, field: &FieldInfo| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n \n         let span = if mode == Mode::Shallow {\n             // set the expn ID so we can call the unstable method\n-            Span { expn_id: cx.backtrace(), ..trait_span }\n+            super::allow_unstable(cx, field.span, \"derive(Clone)\")\n         } else {\n             field.span\n         };\n@@ -147,8 +147,10 @@ fn cs_clone(name: &str,\n \n     match mode {\n         Mode::Shallow => {\n-            let mut stmts: Vec<_> =\n-                all_fields.iter().map(subcall).map(|e| cx.stmt_expr(e)).collect();\n+            let mut stmts = all_fields.iter().map(|f| {\n+                let call = subcall(cx, f);\n+                cx.stmt_expr(call)\n+            }).collect::<Vec<_>>();\n             stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n             cx.expr_block(cx.block(trait_span, stmts))\n         }\n@@ -166,14 +168,15 @@ fn cs_clone(name: &str,\n                                                          name))\n                                 }\n                             };\n-                            cx.field_imm(field.span, ident, subcall(field))\n+                            let call = subcall(cx, field);\n+                            cx.field_imm(field.span, ident, call)\n                         })\n                         .collect::<Vec<_>>();\n \n                     cx.expr_struct(trait_span, ctor_path, fields)\n                 }\n                 VariantData::Tuple(..) => {\n-                    let subcalls = all_fields.iter().map(subcall).collect();\n+                    let subcalls = all_fields.iter().map(|f| subcall(cx, f)).collect();\n                     let path = cx.expr_path(ctor_path);\n                     cx.expr_call(trait_span, path, subcalls)\n                 }"}, {"sha": "1f9c24a0dcd699ca7c191a9b97b1f96aff1d6b44", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::panic;\n+\n+use rustc_macro::{TokenStream, __internal};\n+use syntax::ast::{self, ItemKind};\n+use syntax::codemap::Span;\n+use syntax::ext::base::*;\n+use syntax::fold::{self, Folder};\n+use errors::FatalError;\n+\n+pub struct CustomDerive {\n+    inner: fn(TokenStream) -> TokenStream,\n+}\n+\n+impl CustomDerive {\n+    pub fn new(inner: fn(TokenStream) -> TokenStream) -> CustomDerive {\n+        CustomDerive { inner: inner }\n+    }\n+}\n+\n+impl MultiItemModifier for CustomDerive {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt,\n+              span: Span,\n+              _meta_item: &ast::MetaItem,\n+              item: Annotatable)\n+              -> Vec<Annotatable> {\n+        let item = match item {\n+            Annotatable::Item(item) => item,\n+            Annotatable::ImplItem(_) |\n+            Annotatable::TraitItem(_) => {\n+                ecx.span_err(span, \"custom derive attributes may only be \\\n+                                    applied to struct/enum items\");\n+                return Vec::new()\n+            }\n+        };\n+        match item.node {\n+            ItemKind::Struct(..) |\n+            ItemKind::Enum(..) => {}\n+            _ => {\n+                ecx.span_err(span, \"custom derive attributes may only be \\\n+                                    applied to struct/enum items\");\n+                return Vec::new()\n+            }\n+        }\n+\n+        let input = __internal::new_token_stream(item);\n+        let res = __internal::set_parse_sess(&ecx.parse_sess, || {\n+            let inner = self.inner;\n+            panic::catch_unwind(panic::AssertUnwindSafe(|| inner(input)))\n+        });\n+        let item = match res {\n+            Ok(stream) => __internal::token_stream_items(stream),\n+            Err(e) => {\n+                let msg = \"custom derive attribute panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.downcast_ref::<String>() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+                if let Some(s) = e.downcast_ref::<&'static str>() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                panic!(FatalError);\n+            }\n+        };\n+\n+        // Right now we have no knowledge of spans at all in custom derive\n+        // macros, everything is just parsed as a string. Reassign all spans to\n+        // the #[derive] attribute for better errors here.\n+        item.into_iter().flat_map(|item| {\n+            ChangeSpan { span: span }.fold_item(item)\n+        }).map(Annotatable::Item).collect()\n+    }\n+}\n+\n+struct ChangeSpan { span: Span }\n+\n+impl Folder for ChangeSpan {\n+    fn new_span(&mut self, _sp: Span) -> Span {\n+        self.span\n+    }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n+    }\n+}"}, {"sha": "5582166c12e9cb6c5cd293bbeca139fea0e41aa8", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 171, "deletions": 125, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -12,7 +12,7 @@\n \n use syntax::ast::{self, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n-use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n+use syntax::ext::base::MultiModifier;\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::codemap;\n@@ -61,6 +61,7 @@ pub mod decodable;\n pub mod hash;\n pub mod debug;\n pub mod default;\n+pub mod custom;\n \n #[path=\"cmp/partial_eq.rs\"]\n pub mod partial_eq;\n@@ -74,156 +75,201 @@ pub mod ord;\n \n pub mod generic;\n \n+fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n+    Span {\n+        expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+            call_site: span,\n+            callee: codemap::NameAndSpan {\n+                format: codemap::MacroAttribute(intern(attr_name)),\n+                span: Some(span),\n+                allow_internal_unstable: true,\n+            },\n+        }),\n+        ..span\n+    }\n+}\n+\n fn expand_derive(cx: &mut ExtCtxt,\n                  span: Span,\n                  mitem: &MetaItem,\n                  annotatable: Annotatable)\n-                 -> Annotatable {\n+                 -> Vec<Annotatable> {\n     debug!(\"expand_derive: span = {:?}\", span);\n     debug!(\"expand_derive: mitem = {:?}\", mitem);\n     debug!(\"expand_derive: annotatable input  = {:?}\", annotatable);\n-    let annot = annotatable.map_item_or(|item| {\n-        item.map(|mut item| {\n-            if mitem.value_str().is_some() {\n-                cx.span_err(mitem.span, \"unexpected value in `derive`\");\n-            }\n+    let mut item = match annotatable {\n+        Annotatable::Item(item) => item,\n+        other => {\n+            cx.span_err(span, \"`derive` can only be applied to items\");\n+            return vec![other]\n+        }\n+    };\n \n-            let traits = mitem.meta_item_list().unwrap_or(&[]);\n-            if traits.is_empty() {\n-                cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n-            }\n+    if mitem.value_str().is_some() {\n+        cx.span_err(mitem.span, \"unexpected value in `derive`\");\n+    }\n \n-            let mut found_partial_eq = false;\n-            let mut eq_span = None;\n-\n-            for titem in traits.iter().rev() {\n-                let tname = if let Some(word) = titem.word() {\n-                    word.name()\n-                } else {\n-                    cx.span_err(titem.span, \"malformed `derive` entry\");\n-                    continue;\n-                };\n-\n-                if !(is_builtin_trait(&tname) || cx.ecfg.enable_custom_derive()) {\n-                    feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n-                                                   \"custom_derive\",\n-                                                   titem.span,\n-                                                   feature_gate::GateIssue::Language,\n-                                                   feature_gate::EXPLAIN_CUSTOM_DERIVE);\n-                    continue;\n-                }\n+    let traits = mitem.meta_item_list().unwrap_or(&[]);\n+    if traits.is_empty() {\n+        cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n+    }\n \n-                let span = Span {\n-                    expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                        call_site: titem.span,\n-                        callee: codemap::NameAndSpan {\n-                            format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n-                            span: Some(titem.span),\n-                            allow_internal_unstable: true,\n-                        },\n-                    }),\n-                    ..titem.span\n-                };\n-\n-                if &tname[..] == \"Eq\" {\n-                    eq_span = Some(span);\n-                } else if &tname[..] == \"PartialEq\" {\n-                    found_partial_eq = true;\n-                }\n+    // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n+    // `#[structural_match]` attribute.\n+    if traits.iter().filter_map(|t| t.name()).any(|t| t == \"PartialEq\") &&\n+       traits.iter().filter_map(|t| t.name()).any(|t| t == \"Eq\") {\n+        let structural_match = intern_and_get_ident(\"structural_match\");\n+        let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n+        let meta = cx.meta_word(span, structural_match);\n+        item = item.map(|mut i| {\n+            i.attrs.push(cx.attribute(span, meta));\n+            i\n+        });\n+    }\n \n-                // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n-                item.attrs.push(cx.attribute(span,\n-                               cx.meta_word(titem.span,\n-                                            intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n-            }\n+    // RFC #1521. `Clone` can assume that `Copy` types' clone implementation is\n+    // the same as the copy implementation.\n+    //\n+    // Add a marker attribute here picked up during #[derive(Clone)]\n+    if traits.iter().filter_map(|t| t.name()).any(|t| t == \"Clone\") &&\n+       traits.iter().filter_map(|t| t.name()).any(|t| t == \"Copy\") {\n+        let marker = intern_and_get_ident(\"rustc_copy_clone_marker\");\n+        let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n+        let meta = cx.meta_word(span, marker);\n+        item = item.map(|mut i| {\n+            i.attrs.push(cx.attribute(span, meta));\n+            i\n+        });\n+    }\n \n-            // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n-            // `#[structural_match]` attribute.\n-            if let Some(eq_span) = eq_span {\n-                if found_partial_eq {\n-                    let structural_match = intern_and_get_ident(\"structural_match\");\n-                    item.attrs.push(cx.attribute(eq_span, cx.meta_word(eq_span, structural_match)));\n-                }\n+    let mut other_items = Vec::new();\n+\n+    let mut iter = traits.iter();\n+    while let Some(titem) = iter.next() {\n+\n+        let tword = match titem.word() {\n+            Some(name) => name,\n+            None => {\n+                cx.span_err(titem.span, \"malformed `derive` entry\");\n+                continue\n             }\n+        };\n+        let tname = tword.name();\n+\n+        // If this is a built-in derive mode, then we expand it immediately\n+        // here.\n+        if is_builtin_trait(&tname) {\n+            let name = intern_and_get_ident(&format!(\"derive({})\", tname));\n+            let mitem = cx.meta_word(titem.span, name);\n+\n+            let span = Span {\n+                expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+                    call_site: titem.span,\n+                    callee: codemap::NameAndSpan {\n+                        format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n+                        span: Some(titem.span),\n+                        allow_internal_unstable: true,\n+                    },\n+                }),\n+                ..titem.span\n+            };\n+\n+            let my_item = Annotatable::Item(item);\n+            expand_builtin(&tname, cx, span, &mitem, &my_item, &mut |a| {\n+                other_items.push(a);\n+            });\n+            item = my_item.expect_item();\n+\n+        // Otherwise if this is a `rustc_macro`-style derive mode, we process it\n+        // here. The logic here is to:\n+        //\n+        // 1. Collect the remaining `#[derive]` annotations into a list. If\n+        //    there are any left, attach a `#[derive]` attribute to the item\n+        //    that we're currently expanding with the remaining derive modes.\n+        // 2. Manufacture a `#[derive(Foo)]` attribute to pass to the expander.\n+        // 3. Expand the current item we're expanding, getting back a list of\n+        //    items that replace it.\n+        // 4. Extend the returned list with the current list of items we've\n+        //    collected so far.\n+        // 5. Return everything!\n+        //\n+        // If custom derive extensions end up threading through the `#[derive]`\n+        // attribute, we'll get called again later on to continue expanding\n+        // those modes.\n+        } else if let Some(ext) = cx.derive_modes.remove(&tname) {\n+            let remaining_derives = iter.cloned().collect::<Vec<_>>();\n+            if remaining_derives.len() > 0 {\n+                let list = cx.meta_list(titem.span,\n+                                        intern_and_get_ident(\"derive\"),\n+                                        remaining_derives);\n+                let attr = cx.attribute(titem.span, list);\n+                item = item.map(|mut i| {\n+                    i.attrs.push(attr);\n+                    i\n+                });\n+            }\n+            let titem = cx.meta_list_item_word(titem.span, tname.clone());\n+            let mitem = cx.meta_list(titem.span,\n+                                     intern_and_get_ident(\"derive\"),\n+                                     vec![titem]);\n+            let item = Annotatable::Item(item);\n+            let mut items = ext.expand(cx, mitem.span, &mitem, item);\n+            items.extend(other_items);\n+            cx.derive_modes.insert(tname.clone(), ext);\n+            return items\n+\n+        // If we've gotten this far then it means that we're in the territory of\n+        // the old custom derive mechanism. If the feature isn't enabled, we\n+        // issue an error, otherwise manufacture the `derive_Foo` attribute.\n+        } else if !cx.ecfg.enable_custom_derive() {\n+            feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n+                                           \"custom_derive\",\n+                                           titem.span,\n+                                           feature_gate::GateIssue::Language,\n+                                           feature_gate::EXPLAIN_CUSTOM_DERIVE);\n+        } else {\n+            let name = intern_and_get_ident(&format!(\"derive_{}\", tname));\n+            let mitem = cx.meta_word(titem.span, name);\n+            item = item.map(|mut i| {\n+                i.attrs.push(cx.attribute(mitem.span, mitem));\n+                i\n+            });\n+        }\n+    }\n \n-            item\n-        })\n-    },\n-                                        |a| {\n-                                            cx.span_err(span,\n-                                                        \"`derive` can only be applied to items\");\n-                                            a\n-                                        });\n-    debug!(\"expand_derive: annotatable output = {:?}\", annot);\n-    annot\n+    other_items.insert(0, Annotatable::Item(item));\n+    return other_items\n }\n \n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn register_all(env: &mut SyntaxEnv) {\n-            // Define the #[derive_*] extensions.\n-            $({\n-                struct DeriveExtension;\n-\n-                impl MultiItemDecorator for DeriveExtension {\n-                    fn expand(&self,\n-                              ecx: &mut ExtCtxt,\n-                              sp: Span,\n-                              mitem: &MetaItem,\n-                              annotatable: &Annotatable,\n-                              push: &mut FnMut(Annotatable)) {\n-                        if !ecx.parse_sess.codemap().span_allows_unstable(sp)\n-                            && !ecx.ecfg.features.unwrap().custom_derive {\n-                            // FIXME:\n-                            // https://github.com/rust-lang/rust/pull/32671#issuecomment-206245303\n-                            // This is just to avoid breakage with syntex.\n-                            // Remove that to spawn an error instead.\n-                            let cm = ecx.parse_sess.codemap();\n-                            let parent = cm.with_expn_info(ecx.backtrace(),\n-                                                           |info| info.unwrap().call_site.expn_id);\n-                            cm.with_expn_info(parent, |info| {\n-                                if info.is_some() {\n-                                    let mut w = ecx.parse_sess.span_diagnostic.struct_span_warn(\n-                                        sp, feature_gate::EXPLAIN_DERIVE_UNDERSCORE,\n-                                    );\n-                                    if option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_none() {\n-                                        w.help(\n-                                            &format!(\"add #![feature(custom_derive)] to \\\n-                                                      the crate attributes to enable\")\n-                                        );\n-                                    }\n-                                    w.emit();\n-                                } else {\n-                                    feature_gate::emit_feature_err(\n-                                        &ecx.parse_sess.span_diagnostic,\n-                                        \"custom_derive\", sp, feature_gate::GateIssue::Language,\n-                                        feature_gate::EXPLAIN_DERIVE_UNDERSCORE\n-                                    );\n-\n-                                    return;\n-                                }\n-                            })\n-                        }\n-\n-                        warn_if_deprecated(ecx, sp, $name);\n-                        $func(ecx, sp, mitem, annotatable, push);\n-                    }\n-                }\n-\n-                env.insert(intern(concat!(\"derive_\", $name)),\n-                           MultiDecorator(Box::new(DeriveExtension)));\n-            })+\n-\n-            env.insert(intern(\"derive\"),\n-                       MultiModifier(Box::new(expand_derive)));\n+            env.insert(intern(\"derive\"), MultiModifier(Box::new(expand_derive)));\n         }\n \n-        fn is_builtin_trait(name: &str) -> bool {\n+        pub fn is_builtin_trait(name: &str) -> bool {\n             match name {\n                 $( $name )|+ => true,\n                 _ => false,\n             }\n         }\n+\n+        fn expand_builtin(name: &str,\n+                          ecx: &mut ExtCtxt,\n+                          span: Span,\n+                          mitem: &MetaItem,\n+                          item: &Annotatable,\n+                          push: &mut FnMut(Annotatable)) {\n+            match name {\n+                $(\n+                    $name => {\n+                        warn_if_deprecated(ecx, span, $name);\n+                        $func(ecx, span, mitem, item, push);\n+                    }\n+                )*\n+                _ => panic!(\"not a builtin derive mode: {}\", name),\n+            }\n+        }\n     }\n }\n "}, {"sha": "4bae9ec5a1a1f8c994b65564840614364a58a69c", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -19,6 +19,8 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(rustc_macro_lib)]\n+#![feature(rustc_macro_internals)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n@@ -28,6 +30,7 @@ extern crate log;\n #[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n+extern crate rustc_macro;\n extern crate rustc_errors as errors;\n \n use syntax::ext::base::{MacroExpanderFn, NormalTT};\n@@ -44,6 +47,8 @@ mod format;\n mod log_syntax;\n mod trace_macros;\n \n+pub mod rustc_macro_registrar;\n+\n // for custom_derive\n pub mod deriving;\n "}, {"sha": "7693e2416f4b0b883476d9975dfde608d0bfcbc0", "filename": "src/libsyntax_ext/rustc_macro_registrar.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,280 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+use errors;\n+use syntax::ast::{self, Ident, NodeId};\n+use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n+use syntax::ext::base::{ExtCtxt, DummyMacroLoader};\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::expand::ExpansionConfig;\n+use syntax::parse::ParseSess;\n+use syntax::parse::token::{self, InternedString};\n+use syntax::feature_gate::Features;\n+use syntax::ptr::P;\n+use syntax_pos::{Span, DUMMY_SP};\n+use syntax::visit::{self, Visitor};\n+\n+use deriving;\n+\n+struct CustomDerive {\n+    trait_name: InternedString,\n+    function_name: Ident,\n+    span: Span,\n+}\n+\n+struct CollectCustomDerives<'a> {\n+    derives: Vec<CustomDerive>,\n+    in_root: bool,\n+    handler: &'a errors::Handler,\n+    is_rustc_macro_crate: bool,\n+}\n+\n+pub fn modify(sess: &ParseSess,\n+              mut krate: ast::Crate,\n+              is_rustc_macro_crate: bool,\n+              num_crate_types: usize,\n+              handler: &errors::Handler,\n+              features: &Features) -> ast::Crate {\n+    let mut loader = DummyMacroLoader;\n+    let mut cx = ExtCtxt::new(sess,\n+                              Vec::new(),\n+                              ExpansionConfig::default(\"rustc_macro\".to_string()),\n+                              &mut loader);\n+\n+    let mut collect = CollectCustomDerives {\n+        derives: Vec::new(),\n+        in_root: true,\n+        handler: handler,\n+        is_rustc_macro_crate: is_rustc_macro_crate,\n+    };\n+    visit::walk_crate(&mut collect, &krate);\n+\n+    if !is_rustc_macro_crate {\n+        return krate\n+    } else if !features.rustc_macro {\n+        let mut err = handler.struct_err(\"the `rustc-macro` crate type is \\\n+                                          experimental\");\n+        err.help(\"add #![feature(rustc_macro)] to the crate attributes to \\\n+                  enable\");\n+        err.emit();\n+    }\n+\n+    if num_crate_types > 1 {\n+        handler.err(\"cannot mix `rustc-macro` crate type with others\");\n+    }\n+\n+    krate.module.items.push(mk_registrar(&mut cx, &collect.derives));\n+\n+    if krate.exported_macros.len() > 0 {\n+        handler.err(\"cannot export macro_rules! macros from a `rustc-macro` \\\n+                     crate type currently\");\n+    }\n+\n+    return krate\n+}\n+\n+impl<'a> CollectCustomDerives<'a> {\n+    fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n+        if self.is_rustc_macro_crate &&\n+           self.in_root &&\n+           *vis == ast::Visibility::Public {\n+            self.handler.span_err(sp,\n+                                  \"`rustc-macro` crate types cannot \\\n+                                   export any items other than functions \\\n+                                   tagged with `#[rustc_macro_derive]` \\\n+                                   currently\");\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor for CollectCustomDerives<'a> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        // First up, make sure we're checking a bare function. If we're not then\n+        // we're just not interested in this item.\n+        //\n+        // If we find one, try to locate a `#[rustc_macro_derive]` attribute on\n+        // it.\n+        match item.node {\n+            ast::ItemKind::Fn(..) => {}\n+            _ => {\n+                self.check_not_pub_in_root(&item.vis, item.span);\n+                return visit::walk_item(self, item)\n+            }\n+        }\n+\n+        let mut attrs = item.attrs.iter()\n+                            .filter(|a| a.check_name(\"rustc_macro_derive\"));\n+        let attr = match attrs.next() {\n+            Some(attr) => attr,\n+            None => {\n+                self.check_not_pub_in_root(&item.vis, item.span);\n+                return visit::walk_item(self, item)\n+            }\n+        };\n+\n+        if let Some(a) = attrs.next() {\n+            self.handler.span_err(a.span(), \"multiple `#[rustc_macro_derive]` \\\n+                                             attributes found\");\n+        }\n+\n+        if !self.is_rustc_macro_crate {\n+            self.handler.span_err(attr.span(),\n+                                  \"the `#[rustc_macro_derive]` attribute is \\\n+                                   only usable with crates of the `rustc-macro` \\\n+                                   crate type\");\n+        }\n+\n+        // Once we've located the `#[rustc_macro_derive]` attribute, verify\n+        // that it's of the form `#[rustc_macro_derive(Foo)]`\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => {\n+                self.handler.span_err(attr.span(),\n+                                      \"attribute must be of form: \\\n+                                       #[rustc_macro_derive(TraitName)]\");\n+                return\n+            }\n+        };\n+        if list.len() != 1 {\n+            self.handler.span_err(attr.span(),\n+                                  \"attribute must only have one argument\");\n+            return\n+        }\n+        let attr = &list[0];\n+        let trait_name = match attr.name() {\n+            Some(name) => name,\n+            _ => {\n+                self.handler.span_err(attr.span(), \"not a meta item\");\n+                return\n+            }\n+        };\n+        if !attr.is_word() {\n+            self.handler.span_err(attr.span(), \"must only be one word\");\n+        }\n+\n+        if deriving::is_builtin_trait(&trait_name) {\n+            self.handler.span_err(attr.span(),\n+                                  \"cannot override a built-in #[derive] mode\");\n+        }\n+\n+        if self.derives.iter().any(|d| d.trait_name == trait_name) {\n+            self.handler.span_err(attr.span(),\n+                                  \"derive mode defined twice in this crate\");\n+        }\n+\n+        if self.in_root {\n+            self.derives.push(CustomDerive {\n+                span: item.span,\n+                trait_name: trait_name,\n+                function_name: item.ident,\n+            });\n+        } else {\n+            let msg = \"functions tagged with `#[rustc_macro_derive]` must \\\n+                       currently reside in the root of the crate\";\n+            self.handler.span_err(item.span, msg);\n+        }\n+\n+        visit::walk_item(self, item);\n+    }\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, _s: Span, id: NodeId) {\n+        let mut prev_in_root = self.in_root;\n+        if id != ast::CRATE_NODE_ID {\n+            prev_in_root = mem::replace(&mut self.in_root, false);\n+        }\n+        visit::walk_mod(self, m);\n+        self.in_root = prev_in_root;\n+    }\n+\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        visit::walk_mac(self, mac)\n+    }\n+}\n+\n+// Creates a new module which looks like:\n+//\n+//      mod $gensym {\n+//          extern crate rustc_macro;\n+//\n+//          use rustc_macro::__internal::Registry;\n+//\n+//          #[plugin_registrar]\n+//          fn registrar(registrar: &mut Registry) {\n+//              registrar.register_custom_derive($name_trait1, ::$name1);\n+//              registrar.register_custom_derive($name_trait2, ::$name2);\n+//              // ...\n+//          }\n+//      }\n+fn mk_registrar(cx: &mut ExtCtxt,\n+                custom_derives: &[CustomDerive]) -> P<ast::Item> {\n+    let eid = cx.codemap().record_expansion(ExpnInfo {\n+        call_site: DUMMY_SP,\n+        callee: NameAndSpan {\n+            format: MacroAttribute(token::intern(\"rustc_macro\")),\n+            span: None,\n+            allow_internal_unstable: true,\n+        }\n+    });\n+    let span = Span { expn_id: eid, ..DUMMY_SP };\n+\n+    let rustc_macro = token::str_to_ident(\"rustc_macro\");\n+    let krate = cx.item(span,\n+                        rustc_macro,\n+                        Vec::new(),\n+                        ast::ItemKind::ExternCrate(None));\n+\n+    let __internal = token::str_to_ident(\"__internal\");\n+    let registry = token::str_to_ident(\"Registry\");\n+    let registrar = token::str_to_ident(\"registrar\");\n+    let register_custom_derive = token::str_to_ident(\"register_custom_derive\");\n+    let stmts = custom_derives.iter().map(|cd| {\n+        let path = cx.path_global(cd.span, vec![cd.function_name]);\n+        let trait_name = cx.expr_str(cd.span, cd.trait_name.clone());\n+        (path, trait_name)\n+    }).map(|(path, trait_name)| {\n+        let registrar = cx.expr_ident(span, registrar);\n+        let ufcs_path = cx.path(span, vec![rustc_macro, __internal, registry,\n+                                           register_custom_derive]);\n+        cx.expr_call(span,\n+                     cx.expr_path(ufcs_path),\n+                     vec![registrar, trait_name, cx.expr_path(path)])\n+    }).map(|expr| {\n+        cx.stmt_expr(expr)\n+    }).collect::<Vec<_>>();\n+\n+    let path = cx.path(span, vec![rustc_macro, __internal, registry]);\n+    let registrar_path = cx.ty_path(path);\n+    let arg_ty = cx.ty_rptr(span, registrar_path, None, ast::Mutability::Mutable);\n+    let func = cx.item_fn(span,\n+                          registrar,\n+                          vec![cx.arg(span, registrar, arg_ty)],\n+                          cx.ty(span, ast::TyKind::Tup(Vec::new())),\n+                          cx.block(span, stmts));\n+\n+    let derive_registrar = token::intern_and_get_ident(\"rustc_derive_registrar\");\n+    let derive_registrar = cx.meta_word(span, derive_registrar);\n+    let derive_registrar = cx.attribute(span, derive_registrar);\n+    let func = func.map(|mut i| {\n+        i.attrs.push(derive_registrar);\n+        i.vis = ast::Visibility::Public;\n+        i\n+    });\n+    let module = cx.item_mod(span,\n+                             span,\n+                             ast::Ident::with_empty_ctxt(token::gensym(\"registrar\")),\n+                             Vec::new(),\n+                             vec![krate, func]);\n+    module.map(|mut i| {\n+        i.vis = ast::Visibility::Public;\n+        i\n+    })\n+}"}, {"sha": "3377fc43d8a605cd511c81c483b9c87b33f1a1b3", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -214,6 +214,13 @@ dependencies = [\n  \"rustc_bitflags 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_macro\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"syntax 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_metadata\"\n version = \"0.0.0\"\n@@ -228,8 +235,10 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n+ \"rustc_macro 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n@@ -400,6 +409,7 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"log 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_macro 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "fa0b5763803ffd43c8a1fa15138ce63d11438924", "filename": "src/test/compile-fail-fulldeps/rustc-macro/append-impl.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fappend-impl.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:append-impl.rs\n+\n+#![feature(rustc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate append_impl;\n+\n+trait Append {\n+    fn foo(&self);\n+}\n+\n+#[derive(PartialEq,\n+         Append,\n+         Eq)]\n+//~^^ ERROR: the semantics of constant patterns is not yet settled\n+struct A {\n+    inner: u32,\n+}\n+\n+fn main() {\n+    A { inner: 3 }.foo();\n+}"}, {"sha": "46724523d1c701b2957d5a2c4df479bcb3e918fb", "filename": "src/test/compile-fail-fulldeps/rustc-macro/at-the-root.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fat-the-root.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fat-the-root.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fat-the-root.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+\n+extern crate rustc_macro;\n+\n+pub mod a { //~ `rustc-macro` crate types cannot export any items\n+    use rustc_macro::TokenStream;\n+\n+    #[rustc_macro_derive(B)]\n+    pub fn bar(a: TokenStream) -> TokenStream {\n+    //~^ ERROR: must currently reside in the root of the crate\n+        a\n+    }\n+}\n+"}, {"sha": "7740238aeacc96f23246a0a283266a2e2f261c07", "filename": "src/test/compile-fail-fulldeps/rustc-macro/attribute.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fattribute.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+\n+extern crate rustc_macro;\n+\n+#[rustc_macro_derive]\n+//~^ ERROR: attribute must be of form: #[rustc_macro_derive(TraitName)]\n+pub fn foo1(input: rustc_macro::TokenStream) -> rustc_macro::TokenStream {\n+    input\n+}\n+\n+#[rustc_macro_derive = \"foo\"]\n+//~^ ERROR: attribute must be of form: #[rustc_macro_derive(TraitName)]\n+pub fn foo2(input: rustc_macro::TokenStream) -> rustc_macro::TokenStream {\n+    input\n+}\n+\n+#[rustc_macro_derive(\n+    a = \"b\"\n+)]\n+//~^^ ERROR: must only be one word\n+pub fn foo3(input: rustc_macro::TokenStream) -> rustc_macro::TokenStream {\n+    input\n+}\n+\n+#[rustc_macro_derive(b, c)]\n+//~^ ERROR: attribute must only have one argument\n+pub fn foo4(input: rustc_macro::TokenStream) -> rustc_macro::TokenStream {\n+    input\n+}\n+\n+#[rustc_macro_derive(d(e))]\n+//~^ ERROR: must only be one word\n+pub fn foo5(input: rustc_macro::TokenStream) -> rustc_macro::TokenStream {\n+    input\n+}"}, {"sha": "c3d295e02c163f7ec3236efae3506985fc77c5f7", "filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/append-impl.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+#![crate_type = \"rustc-macro\"]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(Append)]\n+pub fn derive_a(input: TokenStream) -> TokenStream {\n+    let mut input = input.to_string();\n+    input.push_str(\"\n+        impl Append for A {\n+            fn foo(&self) {}\n+        }\n+    \");\n+    input.parse().unwrap()\n+}"}, {"sha": "ff00a9d96a30ac45ac3a8c309f022e15911159a2", "filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/derive-a-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a-2.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+#![crate_type = \"rustc-macro\"]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(A)]\n+pub fn derive_a(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "ff00a9d96a30ac45ac3a8c309f022e15911159a2", "filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/derive-a.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+#![crate_type = \"rustc-macro\"]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(A)]\n+pub fn derive_a(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "5dd42d28b7be148fcc7bdbdf9f436ace866d73ba", "filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/derive-bad.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-bad.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+// force-host\n+\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+#![crate_type = \"rustc-macro\"]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(A)]\n+pub fn derive_a(_input: TokenStream) -> TokenStream {\n+    \"struct A { inner }\".parse().unwrap()\n+}\n+"}, {"sha": "d867082ed5e525a9a6d5582aa6c43cb50268f3ed", "filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/derive-panic.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-panic.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+// force-host\n+\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+#![crate_type = \"rustc-macro\"]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(A)]\n+pub fn derive_a(_input: TokenStream) -> TokenStream {\n+    panic!(\"nope!\");\n+}"}, {"sha": "9eebad897564a51744c92876e367fb914c0c7752", "filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/derive-unstable-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-unstable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-unstable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-unstable-2.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+#![crate_type = \"rustc-macro\"]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(Unstable)]\n+pub fn derive(_input: TokenStream) -> TokenStream {\n+\n+    \"\n+        #[rustc_foo]\n+        fn foo() {}\n+    \".parse().unwrap()\n+}"}, {"sha": "f4a1ec9970067f79cdb9ed344e09694bbd5514af", "filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/derive-unstable.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-unstable.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+#![crate_type = \"rustc-macro\"]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(Unstable)]\n+pub fn derive(_input: TokenStream) -> TokenStream {\n+\n+    \"unsafe fn foo() -> u32 { ::std::intrinsics::init() }\".parse().unwrap()\n+}"}, {"sha": "1f135330a9995a6ef6e4adc0e70af354bef8d4bc", "filename": "src/test/compile-fail-fulldeps/rustc-macro/cannot-link.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fcannot-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fcannot-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fcannot-link.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-a.rs\n+\n+extern crate derive_a;\n+//~^ ERROR: crates of the `rustc-macro` crate type cannot be linked at runtime\n+\n+fn main() {}"}, {"sha": "e4f21dc23840bf35365619c694a0dad68fa41ba7", "filename": "src/test/compile-fail-fulldeps/rustc-macro/define-two.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fdefine-two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fdefine-two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fdefine-two.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(A)]\n+pub fn foo(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[rustc_macro_derive(A)] //~ ERROR: derive mode defined twice in this crate\n+pub fn bar(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "f3a73af299357d08a356dde6648e46b78c65b112", "filename": "src/test/compile-fail-fulldeps/rustc-macro/derive-bad.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fderive-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fderive-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fderive-bad.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-bad.rs\n+\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate derive_bad;\n+\n+#[derive(\n+    A\n+)]\n+//~^^ ERROR: custom derive attribute panicked\n+//~| HELP: called `Result::unwrap()` on an `Err` value: LexError\n+struct A;\n+\n+fn main() {}"}, {"sha": "a46d79f517f7d000ef9dd4547ed54b7ba5cbabd4", "filename": "src/test/compile-fail-fulldeps/rustc-macro/derive-still-gated.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fderive-still-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fderive-still-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fderive-still-gated.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-a.rs\n+\n+#![feature(rustc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_a;\n+\n+#[derive_A] //~ ERROR: attributes of the form `#[derive_*]` are reserved for the compiler\n+struct A;\n+\n+fn main() {}"}, {"sha": "29b9fd228094a63717ef53f25203bcf8a8a69e6e", "filename": "src/test/compile-fail-fulldeps/rustc-macro/expand-to-unstable-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexpand-to-unstable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexpand-to-unstable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexpand-to-unstable-2.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-unstable-2.rs\n+\n+#![feature(rustc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_unstable_2;\n+\n+#[derive(Unstable)]\n+//~^ ERROR: reserved for internal compiler\n+struct A;\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "874081760f662f9f35625d0183b97e9a61050ece", "filename": "src/test/compile-fail-fulldeps/rustc-macro/expand-to-unstable.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexpand-to-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexpand-to-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexpand-to-unstable.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-unstable.rs\n+\n+#![feature(rustc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_unstable;\n+\n+#[derive(Unstable)]\n+//~^ ERROR: use of unstable library feature\n+struct A;\n+\n+fn main() {\n+    unsafe { foo(); }\n+}"}, {"sha": "759f3d32e16e654135668781a0cf34f58009da2f", "filename": "src/test/compile-fail-fulldeps/rustc-macro/export-macro.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexport-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexport-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexport-macro.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: cannot export macro_rules! macros from a `rustc-macro` crate\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+\n+#[macro_export]\n+macro_rules! foo {\n+    ($e:expr) => ($e)\n+}"}, {"sha": "e985356dc5844352a7efe5e0128ee8d3b92666bf", "filename": "src/test/compile-fail-fulldeps/rustc-macro/exports.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fexports.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rustc-macro\"]\n+#![allow(warnings)]\n+\n+pub fn a() {} //~ ERROR: cannot export any items\n+pub struct B; //~ ERROR: cannot export any items\n+pub enum C {} //~ ERROR: cannot export any items\n+pub mod d {} //~ ERROR: cannot export any items\n+\n+mod e {}\n+struct F;\n+enum G {}\n+fn h() {}"}, {"sha": "86afc08cae861763962c6b05f2dfdc0bdfad0e42", "filename": "src/test/compile-fail-fulldeps/rustc-macro/feature-gate-1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-1.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: the `rustc-macro` crate type is experimental\n+\n+#![crate_type = \"rustc-macro\"]"}, {"sha": "1a19f6046d9e1325cd1dbdded977ee645989b520", "filename": "src/test/compile-fail-fulldeps/rustc-macro/feature-gate-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-2.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate rustc_macro; //~ ERROR: use of unstable library feature\n+\n+fn main() {}"}, {"sha": "9f47f07bd023d5f0589c48f7d0eb092b6cdffdf8", "filename": "src/test/compile-fail-fulldeps/rustc-macro/feature-gate-3.rs", "status": "renamed", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-3.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n+#![crate_type = \"rustc-macro\"]\n \n-#![feature(custom_derive)]\n-\n-#[derive_Clone]\n-struct Test;\n-\n-pub fn main() {\n-    Test.clone();\n+#[rustc_macro_derive(Foo)] //~ ERROR: is an experimental feature\n+pub fn foo() {\n }", "previous_filename": "src/test/run-pass/single-derive-attr-with-gate.rs"}, {"sha": "0fdd13bc30cce38eae17dfb62832cac69e98ce98", "filename": "src/test/compile-fail-fulldeps/rustc-macro/feature-gate-4.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-4.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-a.rs\n+\n+#[macro_use]\n+extern crate derive_a;\n+//~^ ERROR: loading custom derive macro crates is experimentally supported"}, {"sha": "e44b29a1705174364e80fff19a97722189040430", "filename": "src/test/compile-fail-fulldeps/rustc-macro/feature-gate-5.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ffeature-gate-5.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[cfg(rustc_macro)] //~ ERROR: experimental and subject to change\n+fn foo() {}"}, {"sha": "c1d0823cb6b84db8ad2d2e19f01a1745b6e6becb", "filename": "src/test/compile-fail-fulldeps/rustc-macro/import.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fimport.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-a.rs\n+\n+#![feature(rustc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_a;\n+\n+use derive_a::derive_a;\n+//~^ ERROR: unresolved import `derive_a::derive_a`\n+\n+fn main() {}"}, {"sha": "0d08d27c38e46652e126e90afe34f46f79e8d5a8", "filename": "src/test/compile-fail-fulldeps/rustc-macro/load-panic.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fload-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fload-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fload-panic.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-panic.rs\n+\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate derive_panic;\n+\n+#[derive(A)]\n+//~^ ERROR: custom derive attribute panicked\n+//~| HELP: message: nope!\n+struct Foo;\n+\n+fn main() {}"}, {"sha": "cdc50acea9262148fa2c15bab1383a66434452d2", "filename": "src/test/compile-fail-fulldeps/rustc-macro/require-rustc-macro-crate-type.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Frequire-rustc-macro-crate-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Frequire-rustc-macro-crate-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Frequire-rustc-macro-crate-type.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_macro)]\n+\n+extern crate rustc_macro;\n+\n+#[rustc_macro_derive(Foo)]\n+//~^ ERROR: only usable with crates of the `rustc-macro` crate type\n+pub fn foo(a: rustc_macro::TokenStream) -> rustc_macro::TokenStream {\n+    a\n+}\n+\n+fn main() {}"}, {"sha": "1353a234b48365ebd3165bf7c482b3472dffb768", "filename": "src/test/compile-fail-fulldeps/rustc-macro/shadow-builtin.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fshadow-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fshadow-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fshadow-builtin.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(PartialEq)]\n+//~^ ERROR: cannot override a built-in #[derive] mode\n+pub fn foo(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "33330ed8f6a059f061e3affcfc41695841208ae5", "filename": "src/test/compile-fail-fulldeps/rustc-macro/shadow.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fshadow.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-a.rs\n+// aux-build:derive-a-2.rs\n+\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate derive_a;\n+#[macro_use]\n+extern crate derive_a_2; //~ ERROR: cannot shadow existing derive mode `A`\n+\n+fn main() {}"}, {"sha": "9662cc69e1e14d0d025893123a440847ac4d3d7a", "filename": "src/test/compile-fail-fulldeps/rustc-macro/signature.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fsignature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fsignature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Fsignature.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+#![allow(warnings)]\n+\n+extern crate rustc_macro;\n+\n+#[rustc_macro_derive(A)]\n+unsafe extern fn foo(a: i32, b: u32) -> u32 {\n+    //~^ ERROR: mismatched types\n+    //~| NOTE: expected normal fn, found unsafe fn\n+    //~| NOTE: expected type `fn(rustc_macro::TokenStream) -> rustc_macro::TokenStream`\n+    //~| NOTE: found type `unsafe extern \"C\" fn(i32, u32) -> u32 {foo}`\n+    loop {}\n+}"}, {"sha": "35f6149ad49465d8699cae3268b99c51ec462e6e", "filename": "src/test/compile-fail-fulldeps/rustc-macro/two-crate-types-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ftwo-crate-types-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ftwo-crate-types-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ftwo-crate-types-1.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: cannot mix `rustc-macro` crate type with others\n+\n+#![crate_type = \"rustc-macro\"]\n+#![crate_type = \"rlib\"]"}, {"sha": "ec95e3e4685be980ba9e535d6de4e606d17b88a8", "filename": "src/test/compile-fail-fulldeps/rustc-macro/two-crate-types-2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ftwo-crate-types-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ftwo-crate-types-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Frustc-macro%2Ftwo-crate-types-2.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: cannot mix `rustc-macro` crate type with others\n+// compile-flags: --crate-type rlib --crate-type rustc-macro"}, {"sha": "25ecd5d08626ddc0ccdf699ff66be735889efff8", "filename": "src/test/compile-fail/issue-32655.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -13,7 +13,7 @@\n \n macro_rules! foo (\n     () => (\n-        #[derive_Clone] //~ WARN attributes of the form\n+        #[derive_Clone] //~ ERROR attributes of the form\n         struct T;\n     );\n );\n@@ -25,9 +25,8 @@ macro_rules! bar (\n foo!();\n \n bar!(\n-    #[derive_Clone] //~ WARN attributes of the form\n+    #[derive_Clone] //~ ERROR attributes of the form\n     struct S;\n );\n \n-#[rustc_error]\n-fn main() {} //~ ERROR compilation successful\n+fn main() {}"}, {"sha": "226c082564ae4f145490b3c562728f88c98d6fc2", "filename": "src/test/run-pass-fulldeps/rustc-macro/add-impl.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fadd-impl.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:add-impl.rs\n+\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate add_impl;\n+\n+#[derive(AddImpl)]\n+struct B;\n+\n+fn main() {\n+    B.foo();\n+    foo();\n+    bar::foo();\n+}"}, {"sha": "8aab423af0a3baeb19f129201f52f5812364d5ff", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/add-impl.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fadd-impl.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(AddImpl)]\n+// #[cfg(rustc_macro)]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    (input.to_string() + \"\n+        impl B {\n+            fn foo(&self) {}\n+        }\n+\n+        fn foo() {}\n+\n+        mod bar { pub fn foo() {} }\n+    \").parse().unwrap()\n+}"}, {"sha": "4dd6ad88b757c5f00d2cfb2dbd5c0f538152396f", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/derive-a.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(A)]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    let input = input.to_string();\n+    assert!(input.contains(\"struct A;\"));\n+    assert!(input.contains(\"#[derive(Eq, Copy, Clone)]\"));\n+    \"#[derive(Eq, Copy, Clone)] struct A;\".parse().unwrap()\n+}"}, {"sha": "5b85e2b2a7c4b887b8b3a2ae92311d57087871d5", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/derive-atob.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-atob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-atob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-atob.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(AToB)]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    let input = input.to_string();\n+    assert_eq!(input, \"struct A;\\n\");\n+    \"struct B;\".parse().unwrap()\n+}"}, {"sha": "54f8dff509ab02b4181e4223b98558b31a5d4922", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/derive-ctod.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-ctod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-ctod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-ctod.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(CToD)]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    let input = input.to_string();\n+    assert_eq!(input, \"struct C;\\n\");\n+    \"struct D;\".parse().unwrap()\n+}"}, {"sha": "d83e352e3b175520712527293fa51bcb9d46c93a", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/derive-same-struct.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-same-struct.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+// compile-flags:--crate-type rustc-macro\n+\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(AToB)]\n+pub fn derive1(input: TokenStream) -> TokenStream {\n+    println!(\"input1: {:?}\", input.to_string());\n+    assert_eq!(input.to_string(), \"#[derive(BToC)]\\nstruct A;\\n\");\n+    \"#[derive(BToC)] struct B;\".parse().unwrap()\n+}\n+\n+#[rustc_macro_derive(BToC)]\n+pub fn derive2(input: TokenStream) -> TokenStream {\n+    assert_eq!(input.to_string(), \"struct B;\\n\");\n+    \"struct C;\".parse().unwrap()\n+}"}, {"sha": "96aea407e6e74f8216a77ea80e723d4e5558bee1", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/expand-with-a-macro.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"rustc-macro\"]\n+#![feature(rustc_macro)]\n+#![feature(rustc_macro_lib)]\n+#![deny(warnings)]\n+\n+extern crate rustc_macro;\n+\n+use rustc_macro::TokenStream;\n+\n+#[rustc_macro_derive(A)]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    let input = input.to_string();\n+    assert!(input.contains(\"struct A;\"));\n+    r#\"\n+        struct A;\n+\n+        impl A {\n+            fn a(&self) {\n+                panic!(\"hello\");\n+            }\n+        }\n+    \"#.parse().unwrap()\n+}\n+"}, {"sha": "ee0d594564883979393c991602495f2fecdeb822", "filename": "src/test/run-pass-fulldeps/rustc-macro/derive-same-struct.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fderive-same-struct.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-same-struct.rs\n+\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate derive_same_struct;\n+\n+#[derive(AToB, BToC)]\n+struct A;\n+\n+fn main() {\n+    C;\n+}"}, {"sha": "cc59be2d75df3ab9b6dbbe0689384c5c820893fc", "filename": "src/test/run-pass-fulldeps/rustc-macro/expand-with-a-macro.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fexpand-with-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fexpand-with-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fexpand-with-a-macro.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:expand-with-a-macro.rs\n+// ignore-stage1\n+\n+#![feature(rustc_macro)]\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate expand_with_a_macro;\n+\n+use std::panic;\n+\n+#[derive(A)]\n+struct A;\n+\n+fn main() {\n+    assert!(panic::catch_unwind(|| {\n+        A.a();\n+    }).is_err());\n+}\n+"}, {"sha": "1500970f02dadf97827395372426f42c167ea63b", "filename": "src/test/run-pass-fulldeps/rustc-macro/load-two.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fload-two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fload-two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fload-two.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-atob.rs\n+// aux-build:derive-ctod.rs\n+\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate derive_atob;\n+#[macro_use]\n+extern crate derive_ctod;\n+\n+#[derive(AToB)]\n+struct A;\n+\n+#[derive(CToD)]\n+struct C;\n+\n+fn main() {\n+    B;\n+    D;\n+}"}, {"sha": "588380f1140c9ce07ed6d8312bd8fdfdece9fe74", "filename": "src/test/run-pass-fulldeps/rustc-macro/smoke.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fsmoke.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-a.rs\n+// ignore-stage1\n+\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate derive_a;\n+\n+#[derive(Debug, PartialEq, A, Eq, Copy, Clone)]\n+struct A;\n+\n+fn main() {\n+    A;\n+    assert_eq!(A, A);\n+    A.clone();\n+    let a = A;\n+    let _c = a;\n+    let _d = a;\n+}"}, {"sha": "517033d58702d60fb01686dd76eb6111636724af", "filename": "src/test/run-pass/associated-types-normalize-unifield-struct.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -11,9 +11,6 @@\n // Regression test for issue #21010: Normalize associated types in\n // various special paths in the `type_is_immediate` function.\n \n-\n-// pretty-expanded FIXME #23616\n-\n pub trait OffsetState: Sized {}\n pub trait Offset {\n     type State: OffsetState;"}, {"sha": "3259b1cc0679e516954471b7091ccb3aa209d956", "filename": "src/test/run-pass/builtin-superkinds-in-metadata.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -13,8 +13,6 @@\n \n // Tests (correct) usage of trait super-builtin-kinds cross-crate.\n \n-// pretty-expanded FIXME #23616\n-\n extern crate trait_superkinds_in_metadata;\n use trait_superkinds_in_metadata::{RequiresRequiresShareAndSend, RequiresShare};\n use trait_superkinds_in_metadata::RequiresCopy;"}, {"sha": "d7c21340afc390977dee417ab2f0b5268bfe705a", "filename": "src/test/run-pass/coherence-impl-in-fn.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n pub fn main() {\n     #[derive(Copy, Clone)]\n     enum x { foo }"}, {"sha": "6d0a43997bc47a41890c9f90c336ed1e8a7c749e", "filename": "src/test/run-pass/deriving-bounds.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fderiving-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fderiving-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-bounds.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #[derive(Copy, Clone)]\n struct Test;\n "}, {"sha": "de952436650828a4170e33aa894da126445db2dd", "filename": "src/test/run-pass/issue-20797.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20797.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -10,8 +10,6 @@\n \n // Regression test for #20797.\n \n-// pretty-expanded FIXME #23616\n-\n #![feature(question_mark)]\n \n use std::default::Default;"}, {"sha": "379715f539039a0089ad4460c52a323861f757d4", "filename": "src/test/run-pass/issue-2288.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2288.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n "}, {"sha": "45ac334dc1d768b845754c72555d62fdd55a33ec", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a029ea343fe5c9b7cf550902b5a507cd8c22a833/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=a029ea343fe5c9b7cf550902b5a507cd8c22a833", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![allow(warnings)]\n #![feature(collections)]\n #![feature(drain, enumset, collections_bound, btree_range, vecmap)]"}]}