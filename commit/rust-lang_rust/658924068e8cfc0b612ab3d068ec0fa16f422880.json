{"sha": "658924068e8cfc0b612ab3d068ec0fa16f422880", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ODkyNDA2OGU4Y2ZjMGI2MTJhYjNkMDY4ZWMwZmExNmY0MjI4ODA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-28T00:52:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-01T04:59:50Z"}, "message": "rustdoc: Show all implementors of traits\n\nWhen inlining documentation across crates, primitive implementors of traits were\nnot shown. This commit tweaks the infrastructure to treat primitive and\nPath-like impls the same way, displaying all implementors everywhere.\n\ncc #14462", "tree": {"sha": "23d626e96e60f7b7533ce4abecfb6613c4868fc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23d626e96e60f7b7533ce4abecfb6613c4868fc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/658924068e8cfc0b612ab3d068ec0fa16f422880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/658924068e8cfc0b612ab3d068ec0fa16f422880", "html_url": "https://github.com/rust-lang/rust/commit/658924068e8cfc0b612ab3d068ec0fa16f422880", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/658924068e8cfc0b612ab3d068ec0fa16f422880/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0777ce86e1adc55362e1190db7b74e8f29559b3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0777ce86e1adc55362e1190db7b74e8f29559b3d", "html_url": "https://github.com/rust-lang/rust/commit/0777ce86e1adc55362e1190db7b74e8f29559b3d"}], "stats": {"total": 106, "additions": 43, "deletions": 63}, "files": [{"sha": "c5e6c73e38fc407e11d9933392808b1f3bf78acc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 37, "deletions": 55, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/658924068e8cfc0b612ab3d068ec0fa16f422880/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658924068e8cfc0b612ab3d068ec0fa16f422880/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=658924068e8cfc0b612ab3d068ec0fa16f422880", "patch": "@@ -102,13 +102,11 @@ pub enum ExternalLocation {\n     Unknown,\n }\n \n-/// Different ways an implementor of a trait can be rendered.\n-pub enum Implementor {\n-    /// Paths are displayed specially by omitting the `impl XX for` cruft\n-    PathType(clean::Type),\n-    /// This is the generic representation of a trait implementor, used for\n-    /// primitive types and otherwise non-path types.\n-    OtherType(clean::Generics, /* trait */ clean::Type, /* for */ clean::Type),\n+/// Metadata about an implementor of a trait.\n+pub struct Implementor {\n+    generics: clean::Generics,\n+    trait_: clean::Type,\n+    for_: clean::Type,\n }\n \n /// This cache is used to store information about the `clean::Crate` being\n@@ -312,6 +310,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     // for future parallelization opportunities\n     let cache = Arc::new(cache);\n     cache_key.replace(Some(cache.clone()));\n+    current_location_key.replace(Some(Vec::new()));\n \n     try!(write_shared(&cx, &krate, &*cache, index));\n     let krate = try!(render_sources(&mut cx, krate));\n@@ -476,7 +475,6 @@ fn write_shared(cx: &Context,\n     let dst = cx.dst.join(\"implementors\");\n     try!(mkdir(&dst));\n     for (&did, imps) in cache.implementors.iter() {\n-        if ast_util::is_local(did) { continue }\n         let &(ref remote_path, remote_item_type) = cache.paths.get(&did);\n \n         let mut mydst = dst.clone();\n@@ -495,25 +493,15 @@ fn write_shared(cx: &Context,\n         try!(writeln!(&mut f, r\"(function() \\{var implementors = \\{\\};\"));\n \n         for implementor in all_implementors.iter() {\n-            try!(writeln!(&mut f, \"{}\", *implementor));\n+            try!(write!(&mut f, \"{}\", *implementor));\n         }\n \n-        try!(write!(&mut f, r\"implementors['{}'] = \\{\", krate.name));\n+        try!(write!(&mut f, r\"implementors['{}'] = [\", krate.name));\n         for imp in imps.iter() {\n-            let &(ref path, item_type) = match *imp {\n-                PathType(clean::ResolvedPath { did, .. }) => {\n-                    cache.paths.get(&did)\n-                }\n-                PathType(..) | OtherType(..) => continue,\n-            };\n-            try!(write!(&mut f, r#\"{}:\"#, *path.get(path.len() - 1)));\n-            try!(write!(&mut f, r#\"\"{}\"#,\n-                        path.slice_to(path.len() - 1).connect(\"/\")));\n-            try!(write!(&mut f, r#\"/{}.{}.html\",\"#,\n-                        item_type.to_static_str(),\n-                        *path.get(path.len() - 1)));\n+            try!(write!(&mut f, r#\"\"impl{} {} for {}\",\"#,\n+                        imp.generics, imp.trait_, imp.for_));\n         }\n-        try!(writeln!(&mut f, r\"\\};\"));\n+        try!(writeln!(&mut f, r\"];\"));\n         try!(writeln!(&mut f, \"{}\", r\"\n             if (window.register_implementors) {\n                 window.register_implementors(implementors);\n@@ -737,16 +725,11 @@ impl DocFolder for Cache {\n                         let v = self.implementors.find_or_insert_with(did, |_| {\n                             Vec::new()\n                         });\n-                        match i.for_ {\n-                            clean::ResolvedPath{..} => {\n-                                v.unshift(PathType(i.for_.clone()));\n-                            }\n-                            _ => {\n-                                v.push(OtherType(i.generics.clone(),\n-                                                 i.trait_.get_ref().clone(),\n-                                                 i.for_.clone()));\n-                            }\n-                        }\n+                        v.push(Implementor {\n+                            generics: i.generics.clone(),\n+                            trait_: i.trait_.get_ref().clone(),\n+                            for_: i.for_.clone(),\n+                        });\n                     }\n                     Some(..) | None => {}\n                 }\n@@ -1489,34 +1472,33 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"</div>\"));\n     }\n \n-    match cache_key.get().unwrap().implementors.find(&it.def_id) {\n+    let cache = cache_key.get().unwrap();\n+    try!(write!(w, \"\n+        <h2 id='implementors'>Implementors</h2>\n+        <ul class='item-list' id='implementors-list'>\n+    \"));\n+    match cache.implementors.find(&it.def_id) {\n         Some(implementors) => {\n-            try!(write!(w, \"\n-                <h2 id='implementors'>Implementors</h2>\n-                <ul class='item-list' id='implementors-list'>\n-            \"));\n             for i in implementors.iter() {\n-                match *i {\n-                    PathType(ref ty) => {\n-                        try!(write!(w, \"<li><code>{}</code></li>\", *ty));\n-                    }\n-                    OtherType(ref generics, ref trait_, ref for_) => {\n-                        try!(write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n-                                      *generics, *trait_, *for_));\n-                    }\n-                }\n+                try!(writeln!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                              i.generics, i.trait_, i.for_));\n             }\n-            try!(write!(w, \"</ul>\"));\n-            try!(write!(w, r#\"<script type=\"text/javascript\" async\n-                                      src=\"{}/implementors/{}/{}.{}.js\"></script>\"#,\n-                        cx.current.iter().map(|_| \"..\")\n-                                  .collect::<Vec<&str>>().connect(\"/\"),\n-                        cx.current.connect(\"/\"),\n-                        shortty(it).to_static_str(),\n-                        *it.name.get_ref()));\n         }\n         None => {}\n     }\n+    try!(write!(w, \"</ul>\"));\n+    try!(write!(w, r#\"<script type=\"text/javascript\" async\n+                              src=\"{root_path}/implementors/{path}/\\\n+                                   {ty}.{name}.js\"></script>\"#,\n+                root_path = Vec::from_elem(cx.current.len(), \"..\").connect(\"/\"),\n+                path = if ast_util::is_local(it.def_id) {\n+                    cx.current.connect(\"/\")\n+                } else {\n+                    let path = cache.external_paths.get(&it.def_id);\n+                    path.slice_to(path.len() - 1).connect(\"/\")\n+                },\n+                ty = shortty(it).to_static_str(),\n+                name = *it.name.get_ref()));\n     Ok(())\n }\n "}, {"sha": "d153728ccce54899ffcf560738b50045b0a8c9bd", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/658924068e8cfc0b612ab3d068ec0fa16f422880/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/658924068e8cfc0b612ab3d068ec0fa16f422880/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=658924068e8cfc0b612ab3d068ec0fa16f422880", "patch": "@@ -658,15 +658,13 @@\n         var list = $('#implementors-list');\n         var libs = Object.getOwnPropertyNames(imp);\n         for (var i = 0; i < libs.length; i++) {\n-            var structs = Object.getOwnPropertyNames(imp[libs[i]]);\n+            if (libs[i] == currentCrate) continue;\n+            var structs = imp[libs[i]];\n             for (var j = 0; j < structs.length; j++) {\n-                console.log(i, structs[j]);\n-                var path = rootPath + imp[libs[i]][structs[j]];\n-                var klass = path.contains(\"type.\") ? \"type\" : \"struct\";\n-                var link = $('<a>').text(structs[j])\n-                                   .attr('href', path)\n-                                   .attr('class', klass);\n-                var code = $('<code>').append(link);\n+                var code = $('<code>').append(structs[j]);\n+                $.each(code.find('a'), function(idx, a) {\n+                    $(a).attr('href', rootPath + $(a).attr('href'));\n+                });\n                 var li = $('<li>').append(code);\n                 list.append(li);\n             }"}]}