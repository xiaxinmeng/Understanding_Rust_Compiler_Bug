{"sha": "c8bcac56649b21ae291e9d224c7e1ddb2f5c62a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YmNhYzU2NjQ5YjIxYWUyOTFlOWQyMjRjN2UxZGRiMmY1YzYyYTA=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-20T14:14:25Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-22T16:40:59Z"}, "message": "Reintroduce the original `check_bounds_ptr` checks", "tree": {"sha": "1167ce5a77f04ca13677137493d093c19615ccda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1167ce5a77f04ca13677137493d093c19615ccda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8bcac56649b21ae291e9d224c7e1ddb2f5c62a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8bcac56649b21ae291e9d224c7e1ddb2f5c62a0", "html_url": "https://github.com/rust-lang/rust/commit/c8bcac56649b21ae291e9d224c7e1ddb2f5c62a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8bcac56649b21ae291e9d224c7e1ddb2f5c62a0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8ddb47fcebf2c73e8d92d65925c4ed72d22171f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8ddb47fcebf2c73e8d92d65925c4ed72d22171f", "html_url": "https://github.com/rust-lang/rust/commit/d8ddb47fcebf2c73e8d92d65925c4ed72d22171f"}], "stats": {"total": 32, "additions": 21, "deletions": 11}, "files": [{"sha": "e5245c24c8c6accd06fbee3b961865547701a481", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c8bcac56649b21ae291e9d224c7e1ddb2f5c62a0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8bcac56649b21ae291e9d224c7e1ddb2f5c62a0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c8bcac56649b21ae291e9d224c7e1ddb2f5c62a0", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         ptr: Pointer<M::PointerTag>,\n         liveness: InboundsCheck,\n     ) -> EvalResult<'tcx, Align> {\n-        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id);\n+        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id, liveness)?;\n         ptr.check_in_alloc(allocation_size, liveness)?;\n         Ok(align)\n     }\n@@ -427,27 +427,37 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_size_and_align(&self, id: AllocId) -> (Size, Align) {\n+    /// Obtain the size and alignment of an allocation, even if that allocation has been deallocated\n+    ///\n+    /// If `liveness` is `InboundsCheck::Dead`, this function always returns `Ok`\n+    pub fn get_size_and_align(\n+        &self,\n+        id: AllocId,\n+        liveness: InboundsCheck,\n+    ) -> EvalResult<'static, (Size, Align)> {\n         if let Ok(alloc) = self.get(id) {\n-            return (Size::from_bytes(alloc.bytes.len() as u64), alloc.align);\n+            return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n         }\n         // Could also be a fn ptr or extern static\n         match self.tcx.alloc_map.lock().get(id) {\n-            Some(AllocKind::Function(..)) => (Size::ZERO, Align::from_bytes(1).unwrap()),\n+            Some(AllocKind::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n             Some(AllocKind::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n                 // Use size and align of the type\n                 let ty = self.tcx.type_of(did);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                (layout.size, layout.align.abi)\n-            }\n-            _ => {\n-                // Must be a deallocated pointer\n-                *self.dead_alloc_map.get(&id).expect(\n-                    \"allocation missing in dead_alloc_map\"\n-                )\n+                Ok((layout.size, layout.align.abi))\n             }\n+            _ => match liveness {\n+                InboundsCheck::MaybeDead => {\n+                    // Must be a deallocated pointer\n+                    Ok(*self.dead_alloc_map.get(&id).expect(\n+                        \"allocation missing in dead_alloc_map\"\n+                    ))\n+                },\n+                InboundsCheck::Live => err!(DanglingPointerDeref),\n+            },\n         }\n     }\n "}]}