{"sha": "64db428967131be1f3966b82748fe8818eadb25b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZGI0Mjg5NjcxMzFiZTFmMzk2NmI4Mjc0OGZlODgxOGVhZGIyNWI=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-12T17:28:41Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-22T16:57:43Z"}, "message": "Don't use `*` for deref-coercion", "tree": {"sha": "bc4e8fbd1259cfad341f2d9773a0d951abd7ce56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc4e8fbd1259cfad341f2d9773a0d951abd7ce56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64db428967131be1f3966b82748fe8818eadb25b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64db428967131be1f3966b82748fe8818eadb25b", "html_url": "https://github.com/rust-lang/rust/commit/64db428967131be1f3966b82748fe8818eadb25b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64db428967131be1f3966b82748fe8818eadb25b/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "884ba4f11f4cac31b9fda402cbd925af4bc286d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/884ba4f11f4cac31b9fda402cbd925af4bc286d4", "html_url": "https://github.com/rust-lang/rust/commit/884ba4f11f4cac31b9fda402cbd925af4bc286d4"}], "stats": {"total": 155, "additions": 77, "deletions": 78}, "files": [{"sha": "8baa19023640b8c16ce0305174d85071c6d3eca9", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -120,7 +120,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.local, proj_base, *self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.local, proj_base, self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access."}, {"sha": "bea1d319fe794d93a25364556a888844664f9c38", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(*self.mir, bx.tcx()).ty;\n+        let ty = location.ty(self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n@@ -572,7 +572,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let extra_args = extra_args\n             .iter()\n             .map(|op_arg| {\n-                let op_ty = op_arg.ty(*self.mir, bx.tcx());\n+                let op_ty = op_arg.ty(self.mir, bx.tcx());\n                 self.monomorphize(&op_ty)\n             })\n             .collect::<Vec<_>>();"}, {"sha": "aaba2ec1362ac77e25b1b4b5331c59983a7d8fad", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, *self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, self.mir, tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "19a0138d9cb6d026fd23a2a95dc044bb985aa6cf", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(*self.mir, bx.tcx());\n+                let discr_ty = rvalue.ty(self.mir, bx.tcx());\n                 let discr = self\n                     .codegen_place(&mut bx, place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n@@ -529,7 +529,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Repeat(..) | mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(*self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 let operand =\n                     OperandRef::new_zst(&mut bx, self.cx.layout_of(self.monomorphize(&ty)));\n                 (bx, operand)\n@@ -749,7 +749,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(*self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "860300d834d09d3f07686f481eb79aa0d70bc60c", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -186,7 +186,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             let ty =\n-                Place::ty_from(used_place.local, used_place.projection, *self.body, self.infcx.tcx)\n+                Place::ty_from(used_place.local, used_place.projection, self.body, self.infcx.tcx)\n                     .ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n@@ -202,7 +202,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(*self.body, self.infcx.tcx).ty;\n+                let ty = place.ty(self.body, self.infcx.tcx).ty;\n                 let opt_name =\n                     self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n@@ -591,7 +591,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let union_ty = |place_base, place_projection| {\n-            let ty = Place::ty_from(place_base, place_projection, *self.body, self.infcx.tcx).ty;\n+            let ty = Place::ty_from(place_base, place_projection, self.body, self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n \n@@ -1486,15 +1486,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(place.local, proj_base, *self.body, tcx).ty.is_box(),\n+                                Place::ty_from(place.local, proj_base, self.body, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(place.local, proj_base, *self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(place.local, proj_base, self.body, tcx).ty;\n                         match base_ty.kind {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor"}, {"sha": "91d8d853eafdb780d86321de0c525a3dc64c4a45", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -331,8 +331,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n-                        Place::ty_from(place.local, place.projection, *self.body, self.infcx.tcx)\n-                            .ty;\n+                        Place::ty_from(place.local, place.projection, self.body, self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -449,7 +448,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }) = bbd.terminator\n                     {\n                         if let Some(source) =\n-                            BorrowedContentSource::from_call(func.ty(*self.body, tcx), tcx)\n+                            BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n                         {\n                             return source;\n                         }\n@@ -462,7 +461,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = Place::ty_from(deref_base.local, deref_base.projection, *self.body, tcx).ty;\n+        let base_ty = Place::ty_from(deref_base.local, deref_base.projection, self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_ptr() {"}, {"sha": "457e263a46611912cbadca99819e455ebe2020dd", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -296,7 +296,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n-        let ty = deref_target_place.ty(*self.body, self.infcx.tcx).ty;\n+        let ty = deref_target_place.ty(self.body, self.infcx.tcx).ty;\n         let upvar_field = self\n             .prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         };\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-            let def_id = match move_place.ty(*self.body, self.infcx.tcx).ty.kind {\n+            let def_id = match move_place.ty(self.body, self.infcx.tcx).ty.kind {\n                 ty::Adt(self_def, _) => self_def.did,\n                 ty::Foreign(def_id)\n                 | ty::FnDef(def_id, _)\n@@ -441,7 +441,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 if binds_to.is_empty() {\n-                    let place_ty = move_from.ty(*self.body, self.infcx.tcx).ty;\n+                    let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => \"value\".to_string(),\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // No binding. Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n-                let place_ty = original_path.ty(*self.body, self.infcx.tcx).ty;\n+                let place_ty = original_path.ty(self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => \"value\".to_string(),"}, {"sha": "c0aee31781e4fcf811e6a1e6e924377edd28ee7f", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         Place::ty_from(\n                             the_place_err.local,\n                             the_place_err.projection,\n-                            *self.body,\n+                            self.body,\n                             self.infcx.tcx\n                         )\n                         .ty\n@@ -197,7 +197,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));"}, {"sha": "a1f005e3b45d985375777666216c08d626c54555", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -619,7 +619,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(*self.body, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n@@ -871,7 +871,7 @@ impl InitializationRequiringAction {\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn body(&self) -> &'cx Body<'tcx> {\n-        *self.body\n+        self.body\n     }\n \n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows"}, {"sha": "7350167684f7a64638d11e765dfb2eb4d7d5bb87", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -120,7 +120,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.local, proj_base, *self.body, self.tcx).ty;\n+                    let ty = Place::ty_from(cursor.local, proj_base, self.body, self.tcx).ty;\n                     match ty.kind {\n                         ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared"}, {"sha": "f706ac26d07c8c039c3d79273eb84dfc42447338", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -200,7 +200,7 @@ fn type_check_internal<'a, 'tcx, R>(\n ) -> R {\n     let mut checker = TypeChecker::new(\n         infcx,\n-        *body,\n+        body,\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -209,7 +209,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         universal_region_relations,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, *body, promoted);\n+        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n         verifier.visit_body(&body);\n         verifier.errors_reported\n     };\n@@ -341,11 +341,11 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     };\n \n                     if !self.errors_reported {\n-                        let promoted_body = self.promoted[promoted];\n+                        let promoted_body = &self.promoted[promoted];\n                         self.sanitize_promoted(promoted_body, location);\n \n                         let promoted_ty = promoted_body.return_ty();\n-                        check_err(self, &promoted_body, ty, promoted_ty);\n+                        check_err(self, promoted_body, ty, promoted_ty);\n                     }\n                 } else {\n                     if let Err(terr) = self.cx.fully_perform_op(\n@@ -534,7 +534,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_body = mem::replace(&mut self.body, *promoted_body);\n+        let parent_body = mem::replace(&mut self.body, promoted_body);\n \n         // Use new sets of constraints and closure bounds so that we can\n         // modify their locations.\n@@ -1433,9 +1433,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(*body, tcx).ty;\n+                let place_ty = place.ty(body, tcx).ty;\n                 let place_ty = self.normalize(place_ty, location);\n-                let rv_ty = rv.ty(*body, tcx);\n+                let rv_ty = rv.ty(body, tcx);\n                 let rv_ty = self.normalize(rv_ty, location);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1484,7 +1484,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::SetDiscriminant { ref place, variant_index } => {\n-                let place_type = place.ty(*body, tcx).ty;\n+                let place_type = place.ty(body, tcx).ty;\n                 let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1506,7 +1506,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(box (ref place, ref projection), variance) => {\n-                let place_ty = place.ty(*body, tcx).ty;\n+                let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1996,7 +1996,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         // While this is located in `nll::typeck` this error is not an NLL error, it's\n                         // a required check to make sure that repeated elements implement `Copy`.\n                         let span = body.source_info(location).span;\n-                        let ty = operand.ty(*body, tcx);\n+                        let ty = operand.ty(body, tcx);\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                             // To determine if `const_in_array_repeat_expressions` feature gate should\n                             // be mentioned, need to check if the rvalue is promotable.\n@@ -2060,7 +2060,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Cast(cast_kind, op, ty) => {\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        let fn_sig = op.ty(*body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2089,7 +2089,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(*body, tcx).kind {\n+                        let sig = match op.ty(body, tcx).kind {\n                             ty::Closure(_, substs) => substs.as_closure().sig(),\n                             _ => bug!(),\n                         };\n@@ -2113,7 +2113,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        let fn_sig = op.ty(*body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2145,7 +2145,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n                             def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(*body, tcx), &[ty.into()]),\n+                            substs: tcx.mk_substs_trait(op.ty(body, tcx), &[ty.into()]),\n                         };\n \n                         self.prove_trait_ref(\n@@ -2156,7 +2156,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(*body, tcx).kind {\n+                        let ty_from = match op.ty(body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::Mutability::Mut,\n@@ -2204,7 +2204,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ArrayToPointer) => {\n-                        let ty_from = op.ty(*body, tcx);\n+                        let ty_from = op.ty(body, tcx);\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(ty::TypeAndMut {\n@@ -2264,7 +2264,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        let ty_from = op.ty(*body, tcx);\n+                        let ty_from = op.ty(body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n@@ -2295,9 +2295,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 left,\n                 right,\n             ) => {\n-                let ty_left = left.ty(*body, tcx);\n+                let ty_left = left.ty(body, tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n-                    let ty_right = right.ty(*body, tcx);\n+                    let ty_right = right.ty(body, tcx);\n                     let common_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::MiscVariable,\n                         span: body.source_info(location).span,"}, {"sha": "cb146059fb1bf93ddea4cbc60b27de92c6b74dc3", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -226,7 +226,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def, None) {\n-            Ok(body) => *body,\n+            Ok(body) => body,\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(did)) = err.kind {\n                     let path = ecx.tcx.def_path_str(did);"}, {"sha": "5f50e073e29a6f6f75d8c3a24f1224abf33d0705", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -113,7 +113,7 @@ where\n     F: FnMut(Local) -> bool,\n {\n     match rvalue {\n-        Rvalue::NullaryOp(..) => Q::in_any_value_of_ty(cx, rvalue.ty(*cx.body, cx.tcx)),\n+        Rvalue::NullaryOp(..) => Q::in_any_value_of_ty(cx, rvalue.ty(cx.body, cx.tcx)),\n \n         Rvalue::Discriminant(place) | Rvalue::Len(place) => {\n             in_place::<Q, _>(cx, in_local, place.as_ref())\n@@ -131,7 +131,7 @@ where\n         Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n             // Special-case reborrows to be more like a copy of the reference.\n             if let &[ref proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx).ty;\n+                let base_ty = Place::ty_from(place.local, proj_base, cx.body, cx.tcx).ty;\n                 if let ty::Ref(..) = base_ty.kind {\n                     return in_place::<Q, _>(\n                         cx,\n@@ -178,7 +178,7 @@ where\n             | ProjectionElem::Index(_) => {}\n         }\n \n-        let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx);\n+        let base_ty = Place::ty_from(place.local, proj_base, cx.body, cx.tcx);\n         let proj_ty = base_ty.projection_ty(cx.tcx, proj_elem).ty;\n         if !Q::in_any_value_of_ty(cx, proj_ty) {\n             return false;"}, {"sha": "6ae314b973ffea8a450c3bb5bc61dc920247d46b", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -72,7 +72,7 @@ where\n     ) {\n         // We cannot reason about another function's internals, so use conservative type-based\n         // qualification for the result of a function call.\n-        let return_ty = return_place.ty(*self.item.body, self.item.tcx).ty;\n+        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n         let qualif = Q::in_any_value_of_ty(self.item, return_ty);\n \n         if !return_place.is_indirect() {"}, {"sha": "a3127d4fd258f127a9c81a7635190132c9220cd7", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -39,9 +39,9 @@ struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n     pub fn new(q: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n         let cursor = FlowSensitiveAnalysis::new(q, item)\n-            .into_engine(item.tcx, &item.body, item.def_id)\n+            .into_engine(item.tcx, item.body, item.def_id)\n             .iterate_to_fixpoint()\n-            .into_results_cursor(*item.body);\n+            .into_results_cursor(item.body);\n \n         let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n         for (local, decl) in item.body.local_decls.iter_enumerated() {\n@@ -148,11 +148,11 @@ impl Validator<'a, 'mir, 'tcx> {\n         //\n         // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n         // without breaking stable code?\n-        let indirectly_mutable = MaybeMutBorrowedLocals::mut_borrows_only(tcx, *body, param_env)\n+        let indirectly_mutable = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n             .unsound_ignore_borrow_on_drop()\n-            .into_engine(tcx, *body, def_id)\n+            .into_engine(tcx, body, def_id)\n             .iterate_to_fixpoint()\n-            .into_results_cursor(*body);\n+            .into_results_cursor(body);\n \n         let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n \n@@ -261,7 +261,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         // Special-case reborrows to be more like a copy of a reference.\n         match *rvalue {\n             Rvalue::Ref(_, kind, place) => {\n-                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n+                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n                     let ctx = match kind {\n                         BorrowKind::Shared => {\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow)\n@@ -282,7 +282,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 }\n             }\n             Rvalue::AddressOf(mutbl, place) => {\n-                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n+                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n                     let ctx = match mutbl {\n                         Mutability::Not => {\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf)\n@@ -313,7 +313,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n             Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n             | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place) => {\n-                let ty = place.ty(*self.body, self.tcx).ty;\n+                let ty = place.ty(self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n                     ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut => {\n@@ -355,7 +355,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(*self.body, self.tcx);\n+                let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n \n@@ -365,7 +365,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(*self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     assert!(\n                         op == BinOp::Eq\n                             || op == BinOp::Ne\n@@ -426,7 +426,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_local, proj_base, self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n                         if let (local, []) = (place_local, proj_base) {\n@@ -450,7 +450,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_local, proj_base, self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -498,7 +498,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match &terminator.kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(*self.body, self.tcx);\n+                let fn_ty = func.ty(self.body, self.tcx);\n \n                 let (def_id, substs) = match fn_ty.kind {\n                     ty::FnDef(def_id, substs) => (def_id, substs),\n@@ -553,7 +553,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // Check to see if the type of this place can ever have a drop impl. If not, this\n                 // `Drop` terminator is frivolous.\n                 let ty_needs_drop =\n-                    dropped_place.ty(*self.body, self.tcx).ty.needs_drop(self.tcx, self.param_env);\n+                    dropped_place.ty(self.body, self.tcx).ty.needs_drop(self.tcx, self.param_env);\n \n                 if !ty_needs_drop {\n                     return;"}, {"sha": "c1705b0ff7e0b60e0e28243200caf9f553e928fe", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -468,7 +468,7 @@ impl Inliner<'tcx> {\n                         destination.0,\n                     );\n \n-                    let ty = dest.ty(&**caller_body, self.tcx);\n+                    let ty = dest.ty(caller_body, self.tcx);\n \n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n@@ -568,7 +568,7 @@ impl Inliner<'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::from(tuple);\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(&**caller_body, tcx).ty.kind {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.kind {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");\n@@ -619,7 +619,7 @@ impl Inliner<'tcx> {\n         // Otherwise, create a temporary for the arg\n         let arg = Rvalue::Use(arg);\n \n-        let ty = arg.ty(&**caller_body, self.tcx);\n+        let ty = arg.ty(caller_body, self.tcx);\n \n         let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n         let arg_tmp = caller_body.local_decls.push(arg_tmp);"}, {"sha": "9c18a298b24ffda7b41b786600dd1a517e64142f", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64db428967131be1f3966b82748fe8818eadb25b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=64db428967131be1f3966b82748fe8818eadb25b", "patch": "@@ -329,7 +329,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 // FIXME(eddyb) this is probably excessive, with\n                                 // the exception of `union` member accesses.\n                                 let ty =\n-                                    Place::ty_from(place.local, proj_base, *self.body, self.tcx)\n+                                    Place::ty_from(place.local, proj_base, self.body, self.tcx)\n                                         .projection_ty(self.tcx, elem)\n                                         .ty;\n                                 if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -350,7 +350,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         }\n \n                         if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(*self.body, self.tcx).ty;\n+                            let ty = place.ty(self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n@@ -494,7 +494,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n+                                Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -539,7 +539,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n-                let operand_ty = operand.ty(*self.body, self.tcx);\n+                let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -552,7 +552,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(*self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     assert!(\n                         op == BinOp::Eq\n                             || op == BinOp::Ne\n@@ -592,7 +592,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Raw reborrows can come from reference to pointer coercions,\n                 // so are allowed.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         return self.validate_place(PlaceRef {\n                             local: place.local,\n@@ -605,7 +605,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(*self.body, self.tcx).ty;\n+                    let ty = place.ty(self.body, self.tcx).ty;\n \n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -631,7 +631,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         place = PlaceRef { local: place.local, projection: proj_base };\n                     }\n@@ -650,7 +650,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx)\n+                        let ty = Place::ty_from(place.local, proj_base, self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -683,7 +683,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n-        let fn_ty = callee.ty(*self.body, self.tcx);\n+        let fn_ty = callee.ty(self.body, self.tcx);\n \n         if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {"}]}