{"sha": "83ad51108b43cc5605c3d91b28aa4a2069660f11", "node_id": "C_kwDOAAsO6NoAKDgzYWQ1MTEwOGI0M2NjNTYwNWMzZDkxYjI4YWE0YTIwNjk2NjBmMTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-16T23:01:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-16T23:01:02Z"}, "message": "Auto merge of #7982 - Blckbrry-Pi:master, r=llogiq\n\nFix `needless_collect`'s tendency to suggest code requiring multiple mutable borrows of the same value.\n\nFixes error specified in #7975.\n\nchangelog: [`needless_collect`] no longer suggests removal of `collect` when removal would create code requiring mutably borrowing a value multiple times.", "tree": {"sha": "467f1d01a91c8950e8f942a801618f217af9b64f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467f1d01a91c8950e8f942a801618f217af9b64f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83ad51108b43cc5605c3d91b28aa4a2069660f11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83ad51108b43cc5605c3d91b28aa4a2069660f11", "html_url": "https://github.com/rust-lang/rust/commit/83ad51108b43cc5605c3d91b28aa4a2069660f11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83ad51108b43cc5605c3d91b28aa4a2069660f11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b1b65b876b500e15de45155a04d055ff3cd126f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1b65b876b500e15de45155a04d055ff3cd126f", "html_url": "https://github.com/rust-lang/rust/commit/5b1b65b876b500e15de45155a04d055ff3cd126f"}, {"sha": "c52b389b161e1a403647a6ca482a9ef8fc391549", "url": "https://api.github.com/repos/rust-lang/rust/commits/c52b389b161e1a403647a6ca482a9ef8fc391549", "html_url": "https://github.com/rust-lang/rust/commit/c52b389b161e1a403647a6ca482a9ef8fc391549"}], "stats": {"total": 209, "additions": 183, "deletions": 26}, "files": [{"sha": "6f3acb45ba4f89e55c24f5600d238b152d4d7940", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 152, "deletions": 26, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/83ad51108b43cc5605c3d91b28aa4a2069660f11/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ad51108b43cc5605c3d91b28aa4a2069660f11/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=83ad51108b43cc5605c3d91b28aa4a2069660f11", "patch": "@@ -3,13 +3,16 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_trait_method, path_to_local_id};\n+use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local, path_to_local_id, CaptureKind};\n use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, TyS};\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n@@ -83,7 +86,8 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                     is_type_diagnostic_item(cx, ty, sym::VecDeque) ||\n                     is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n                     is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, id);\n+                let iter_ty = cx.typeck_results().expr_ty(iter_source);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, id, cx, get_captured_ids(cx, iter_ty));\n                 if let [iter_call] = &*iter_calls;\n                 then {\n                     let mut used_count_visitor = UsedCountVisitor {\n@@ -167,37 +171,89 @@ enum IterFunctionKind {\n     Contains(Span),\n }\n \n-struct IterFunctionVisitor {\n-    uses: Vec<IterFunction>,\n+struct IterFunctionVisitor<'a, 'tcx> {\n+    illegal_mutable_capture_ids: HirIdSet,\n+    current_mutably_captured_ids: HirIdSet,\n+    cx: &'a LateContext<'tcx>,\n+    uses: Vec<Option<IterFunction>>,\n+    hir_id_uses_map: FxHashMap<HirId, usize>,\n+    current_statement_hir_id: Option<HirId>,\n     seen_other: bool,\n     target: HirId,\n }\n-impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n+    fn visit_block(&mut self, block: &'tcx Block<'tcx>) {\n+        for (expr, hir_id) in block.stmts.iter().filter_map(get_expr_and_hir_id_from_stmt) {\n+            self.visit_block_expr(expr, hir_id);\n+        }\n+        if let Some(expr) = block.expr {\n+            self.visit_block_expr(expr, None);\n+        }\n+    }\n+\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n         if let ExprKind::MethodCall(method_name, _, [recv, args @ ..], _) = &expr.kind {\n+            if method_name.ident.name == sym!(collect) && is_trait_method(self.cx, expr, sym::Iterator) {\n+                self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(recv));\n+                self.visit_expr(recv);\n+                return;\n+            }\n+\n             if path_to_local_id(recv, self.target) {\n-                match &*method_name.ident.name.as_str() {\n-                    \"into_iter\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::IntoIter,\n-                        span: expr.span,\n-                    }),\n-                    \"len\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::Len,\n-                        span: expr.span,\n-                    }),\n-                    \"is_empty\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::IsEmpty,\n-                        span: expr.span,\n-                    }),\n-                    \"contains\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::Contains(args[0].span),\n-                        span: expr.span,\n-                    }),\n-                    _ => self.seen_other = true,\n+                if self\n+                    .illegal_mutable_capture_ids\n+                    .intersection(&self.current_mutably_captured_ids)\n+                    .next()\n+                    .is_none()\n+                {\n+                    if let Some(hir_id) = self.current_statement_hir_id {\n+                        self.hir_id_uses_map.insert(hir_id, self.uses.len());\n+                    }\n+                    match &*method_name.ident.name.as_str() {\n+                        \"into_iter\" => self.uses.push(Some(IterFunction {\n+                            func: IterFunctionKind::IntoIter,\n+                            span: expr.span,\n+                        })),\n+                        \"len\" => self.uses.push(Some(IterFunction {\n+                            func: IterFunctionKind::Len,\n+                            span: expr.span,\n+                        })),\n+                        \"is_empty\" => self.uses.push(Some(IterFunction {\n+                            func: IterFunctionKind::IsEmpty,\n+                            span: expr.span,\n+                        })),\n+                        \"contains\" => self.uses.push(Some(IterFunction {\n+                            func: IterFunctionKind::Contains(args[0].span),\n+                            span: expr.span,\n+                        })),\n+                        _ => {\n+                            self.seen_other = true;\n+                            if let Some(hir_id) = self.current_statement_hir_id {\n+                                self.hir_id_uses_map.remove(&hir_id);\n+                            }\n+                        },\n+                    }\n                 }\n                 return;\n             }\n+\n+            if let Some(hir_id) = path_to_local(recv) {\n+                if let Some(index) = self.hir_id_uses_map.remove(&hir_id) {\n+                    if self\n+                        .illegal_mutable_capture_ids\n+                        .intersection(&self.current_mutably_captured_ids)\n+                        .next()\n+                        .is_none()\n+                    {\n+                        if let Some(hir_id) = self.current_statement_hir_id {\n+                            self.hir_id_uses_map.insert(hir_id, index);\n+                        }\n+                    } else {\n+                        self.uses[index] = None;\n+                    }\n+                }\n+            }\n         }\n         // Check if the collection is used for anything else\n         if path_to_local_id(expr, self.target) {\n@@ -213,6 +269,28 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     }\n }\n \n+impl<'tcx> IterFunctionVisitor<'_, 'tcx> {\n+    fn visit_block_expr(&mut self, expr: &'tcx Expr<'tcx>, hir_id: Option<HirId>) {\n+        self.current_statement_hir_id = hir_id;\n+        self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(expr));\n+        self.visit_expr(expr);\n+    }\n+}\n+\n+fn get_expr_and_hir_id_from_stmt<'v>(stmt: &'v Stmt<'v>) -> Option<(&'v Expr<'v>, Option<HirId>)> {\n+    match stmt.kind {\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some((expr, None)),\n+        StmtKind::Item(..) => None,\n+        StmtKind::Local(Local { init, pat, .. }) => {\n+            if let PatKind::Binding(_, hir_id, ..) = pat.kind {\n+                init.map(|init_expr| (init_expr, Some(hir_id)))\n+            } else {\n+                init.map(|init_expr| (init_expr, None))\n+            }\n+        },\n+    }\n+}\n+\n struct UsedCountVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     id: HirId,\n@@ -237,12 +315,60 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n \n /// Detect the occurrences of calls to `iter` or `into_iter` for the\n /// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, id: HirId) -> Option<Vec<IterFunction>> {\n+fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n+    block: &'tcx Block<'tcx>,\n+    id: HirId,\n+    cx: &'a LateContext<'tcx>,\n+    captured_ids: HirIdSet,\n+) -> Option<Vec<IterFunction>> {\n     let mut visitor = IterFunctionVisitor {\n         uses: Vec::new(),\n         target: id,\n         seen_other: false,\n+        cx,\n+        current_mutably_captured_ids: HirIdSet::default(),\n+        illegal_mutable_capture_ids: captured_ids,\n+        hir_id_uses_map: FxHashMap::default(),\n+        current_statement_hir_id: None,\n     };\n     visitor.visit_block(block);\n-    if visitor.seen_other { None } else { Some(visitor.uses) }\n+    if visitor.seen_other {\n+        None\n+    } else {\n+        Some(visitor.uses.into_iter().flatten().collect())\n+    }\n+}\n+\n+fn get_captured_ids(cx: &LateContext<'tcx>, ty: &'_ TyS<'_>) -> HirIdSet {\n+    fn get_captured_ids_recursive(cx: &LateContext<'tcx>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n+        match ty.kind() {\n+            ty::Adt(_, generics) => {\n+                for generic in *generics {\n+                    if let GenericArgKind::Type(ty) = generic.unpack() {\n+                        get_captured_ids_recursive(cx, ty, set);\n+                    }\n+                }\n+            },\n+            ty::Closure(def_id, _) => {\n+                let closure_hir_node = cx.tcx.hir().get_if_local(*def_id).unwrap();\n+                if let Node::Expr(closure_expr) = closure_hir_node {\n+                    can_move_expr_to_closure(cx, closure_expr)\n+                        .unwrap()\n+                        .into_iter()\n+                        .for_each(|(hir_id, capture_kind)| {\n+                            if matches!(capture_kind, CaptureKind::Ref(Mutability::Mut)) {\n+                                set.insert(hir_id);\n+                            }\n+                        });\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    let mut set = HirIdSet::default();\n+\n+    get_captured_ids_recursive(cx, ty, &mut set);\n+\n+    set\n }"}, {"sha": "1f11d1f8d563c2bcb213f6924ac169512950d762", "filename": "tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/83ad51108b43cc5605c3d91b28aa4a2069660f11/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ad51108b43cc5605c3d91b28aa4a2069660f11/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=83ad51108b43cc5605c3d91b28aa4a2069660f11", "patch": "@@ -76,6 +76,37 @@ mod issue7110 {\n     }\n }\n \n+mod issue7975 {\n+    use super::*;\n+\n+    fn direct_mapping_with_used_mutable_reference() -> Vec<()> {\n+        let test_vec: Vec<()> = vec![];\n+        let mut vec_2: Vec<()> = vec![];\n+        let mut_ref = &mut vec_2;\n+        let collected_vec: Vec<_> = test_vec.into_iter().map(|_| mut_ref.push(())).collect();\n+        collected_vec.into_iter().map(|_| mut_ref.push(())).collect()\n+    }\n+\n+    fn indirectly_mapping_with_used_mutable_reference() -> Vec<()> {\n+        let test_vec: Vec<()> = vec![];\n+        let mut vec_2: Vec<()> = vec![];\n+        let mut_ref = &mut vec_2;\n+        let collected_vec: Vec<_> = test_vec.into_iter().map(|_| mut_ref.push(())).collect();\n+        let iter = collected_vec.into_iter();\n+        iter.map(|_| mut_ref.push(())).collect()\n+    }\n+\n+    fn indirect_collect_after_indirect_mapping_with_used_mutable_reference() -> Vec<()> {\n+        let test_vec: Vec<()> = vec![];\n+        let mut vec_2: Vec<()> = vec![];\n+        let mut_ref = &mut vec_2;\n+        let collected_vec: Vec<_> = test_vec.into_iter().map(|_| mut_ref.push(())).collect();\n+        let iter = collected_vec.into_iter();\n+        let mapped_iter = iter.map(|_| mut_ref.push(()));\n+        mapped_iter.collect()\n+    }\n+}\n+\n fn allow_test() {\n     #[allow(clippy::needless_collect)]\n     let v = [1].iter().collect::<Vec<_>>();"}]}