{"sha": "4f171d7fe3cc9e24adb5917f226b00f287466771", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMTcxZDdmZTNjYzllMjRhZGI1OTE3ZjIyNmIwMGYyODc0NjY3NzE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-17T12:31:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-17T12:31:59Z"}, "message": "stop relying on c_str/wide_str helpers in rustc", "tree": {"sha": "687bec6b5b0c6857fb89e90a1799505af53358ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/687bec6b5b0c6857fb89e90a1799505af53358ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f171d7fe3cc9e24adb5917f226b00f287466771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f171d7fe3cc9e24adb5917f226b00f287466771", "html_url": "https://github.com/rust-lang/rust/commit/4f171d7fe3cc9e24adb5917f226b00f287466771", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f171d7fe3cc9e24adb5917f226b00f287466771/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "516e905cab88f7dcd09962d091739b0274ed8c1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/516e905cab88f7dcd09962d091739b0274ed8c1f", "html_url": "https://github.com/rust-lang/rust/commit/516e905cab88f7dcd09962d091739b0274ed8c1f"}], "stats": {"total": 109, "additions": 83, "deletions": 26}, "files": [{"sha": "ef5ea9447808cb344d3107d40fde0d057c974f64", "filename": "src/helpers.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=4f171d7fe3cc9e24adb5917f226b00f287466771", "patch": "@@ -566,6 +566,51 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Duration::new(seconds, nanoseconds)\n         })\n     }\n+\n+    fn read_c_str<'a>(&'a self, sptr: Scalar<Tag>) -> InterpResult<'tcx, &'a [u8]>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        let this = self.eval_context_ref();\n+        let size1 = Size::from_bytes(1);\n+        let ptr = this.force_ptr(sptr)?; // We need to read at least 1 byte, so we can eagerly get a ptr.\n+\n+        // Step 1: determine the length.\n+        let alloc = this.memory.get_raw(ptr.alloc_id)?;\n+        let mut len = Size::ZERO;\n+        loop {\n+            let byte = alloc.read_scalar(this, ptr.offset(len, this)?, size1)?.to_u8()?;\n+            if byte == 0 {\n+                break;\n+            } else {\n+                len = len + size1;\n+            }\n+        }\n+\n+        // Step 2: get the bytes.\n+        this.memory.read_bytes(ptr.into(), len)\n+    }\n+\n+    fn read_wide_str(&self, sptr: Scalar<Tag>) -> InterpResult<'tcx, Vec<u16>> {\n+        let this = self.eval_context_ref();\n+        let size2 = Size::from_bytes(2);\n+\n+        let mut ptr = this.force_ptr(sptr)?; // We need to read at least 1 wchar, so we can eagerly get a ptr.\n+        let mut wchars = Vec::new();\n+        let alloc = this.memory.get_raw(ptr.alloc_id)?;\n+        loop {\n+            let wchar = alloc.read_scalar(this, ptr, size2)?.to_u16()?;\n+            if wchar == 0 {\n+                break;\n+            } else {\n+                wchars.push(wchar);\n+                ptr = ptr.offset(size2, this)?;\n+            }\n+        }\n+\n+        Ok(wchars)\n+    }\n }\n \n /// Check that the number of args is what we expect."}, {"sha": "47d939e69722680c810b4a1450c2822b6b29f718", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=4f171d7fe3cc9e24adb5917f226b00f287466771", "patch": "@@ -405,7 +405,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n-                let n = this.memory.read_c_str(ptr)?.len();\n+                let n = this.read_c_str(ptr)?.len();\n                 this.write_scalar(Scalar::from_machine_usize(u64::try_from(n).unwrap(), this), dest)?;\n             }\n "}, {"sha": "f1f14fa828f85dfb01377217737bdad9c76841df", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=4f171d7fe3cc9e24adb5917f226b00f287466771", "patch": "@@ -9,7 +9,7 @@ use std::os::unix::ffi::{OsStrExt, OsStringExt};\n #[cfg(windows)]\n use std::os::windows::ffi::{OsStrExt, OsStringExt};\n \n-use rustc_target::abi::LayoutOf;\n+use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n \n@@ -50,19 +50,19 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle.\n-    fn read_os_str_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, &'a OsStr>\n+    fn read_os_str_from_c_str<'a>(&'a self, sptr: Scalar<Tag>) -> InterpResult<'tcx, &'a OsStr>\n     where\n         'tcx: 'a,\n         'mir: 'a,\n     {\n         let this = self.eval_context_ref();\n-        let bytes = this.memory.read_c_str(scalar)?;\n+        let bytes = this.read_c_str(sptr)?;\n         bytes_to_os_str(bytes)\n     }\n \n     /// Helper function to read an OsString from a 0x0000-terminated sequence of u16,\n     /// which is what the Windows APIs usually handle.\n-    fn read_os_str_from_wide_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, OsString>\n+    fn read_os_str_from_wide_str<'a>(&'a self, sptr: Scalar<Tag>) -> InterpResult<'tcx, OsString>\n     where\n         'tcx: 'a,\n         'mir: 'a,\n@@ -78,7 +78,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(s.into())\n         }\n \n-        let u16_vec = self.eval_context_ref().memory.read_wide_str(scalar)?;\n+        let u16_vec = self.eval_context_ref().read_wide_str(sptr)?;\n         u16vec_to_osstring(u16_vec)\n     }\n \n@@ -90,7 +90,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_os_str_to_c_str(\n         &mut self,\n         os_str: &OsStr,\n-        scalar: Scalar<Tag>,\n+        sptr: Scalar<Tag>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let bytes = os_str_to_bytes(os_str)?;\n@@ -102,7 +102,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         self.eval_context_mut()\n             .memory\n-            .write_bytes(scalar, bytes.iter().copied().chain(iter::once(0u8)))?;\n+            .write_bytes(sptr, bytes.iter().copied().chain(iter::once(0u8)))?;\n         Ok((true, string_length))\n     }\n \n@@ -114,7 +114,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_os_str_to_wide_str(\n         &mut self,\n         os_str: &OsStr,\n-        scalar: Scalar<Tag>,\n+        sptr: Scalar<Tag>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         #[cfg(windows)]\n@@ -136,15 +136,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n         // 0x0000 terminator to memory would cause an out-of-bounds access.\n         let string_length = u64::try_from(u16_vec.len()).unwrap();\n-        if size <= string_length {\n+        let string_length = string_length.checked_add(1).unwrap();\n+        if size < string_length {\n             return Ok((false, string_length));\n         }\n \n         // Store the UTF-16 string.\n-        self.eval_context_mut()\n-            .memory\n-            .write_u16s(scalar, u16_vec.into_iter().chain(iter::once(0x0000)))?;\n-        Ok((true, string_length))\n+        let size2 = Size::from_bytes(2);\n+        let this = self.eval_context_mut();\n+        let tcx = &*this.tcx;\n+        let ptr = this.force_ptr(sptr)?; // we need to write at least the 0 terminator\n+        let alloc = this.memory.get_raw_mut(ptr.alloc_id)?;\n+        for (offset, wchar) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n+            let offset = u64::try_from(offset).unwrap();\n+            alloc.write_scalar(\n+                tcx,\n+                ptr.offset(size2 * offset, tcx)?,\n+                Scalar::from_u16(wchar).into(),\n+                size2,\n+            )?;\n+        }\n+        Ok((true, string_length - 1))\n     }\n \n     /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of bytes.\n@@ -178,13 +190,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Read a null-terminated sequence of bytes, and perform path separator conversion if needed.\n-    fn read_path_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, Cow<'a, Path>>\n+    fn read_path_from_c_str<'a>(&'a self, sptr: Scalar<Tag>) -> InterpResult<'tcx, Cow<'a, Path>>\n     where\n         'tcx: 'a,\n         'mir: 'a,\n     {\n         let this = self.eval_context_ref();\n-        let os_str = this.read_os_str_from_c_str(scalar)?;\n+        let os_str = this.read_os_str_from_c_str(sptr)?;\n \n         Ok(match this.convert_path_separator(Cow::Borrowed(os_str), PathConversion::TargetToHost) {\n             Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)),\n@@ -193,9 +205,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Read a null-terminated sequence of `u16`s, and perform path separator conversion if needed.\n-    fn read_path_from_wide_str(&self, scalar: Scalar<Tag>) -> InterpResult<'tcx, PathBuf> {\n+    fn read_path_from_wide_str(&self, sptr: Scalar<Tag>) -> InterpResult<'tcx, PathBuf> {\n         let this = self.eval_context_ref();\n-        let os_str = this.read_os_str_from_wide_str(scalar)?;\n+        let os_str = this.read_os_str_from_wide_str(sptr)?;\n \n         Ok(this\n             .convert_path_separator(Cow::Owned(os_str), PathConversion::TargetToHost)\n@@ -208,27 +220,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_path_to_c_str(\n         &mut self,\n         path: &Path,\n-        scalar: Scalar<Tag>,\n+        sptr: Scalar<Tag>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n         let os_str = this\n             .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n-        this.write_os_str_to_c_str(&os_str, scalar, size)\n+        this.write_os_str_to_c_str(&os_str, sptr, size)\n     }\n \n     /// Write a Path to the machine memory (as a null-terminated sequence of `u16`s),\n     /// adjusting path separators if needed.\n     fn write_path_to_wide_str(\n         &mut self,\n         path: &Path,\n-        scalar: Scalar<Tag>,\n+        sptr: Scalar<Tag>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n         let os_str = this\n             .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n-        this.write_os_str_to_wide_str(&os_str, scalar, size)\n+        this.write_os_str_to_wide_str(&os_str, sptr, size)\n     }\n \n     fn convert_path_separator<'a>("}, {"sha": "52b41b49bd5e97e7720e9dad0f5887f93593891e", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=4f171d7fe3cc9e24adb5917f226b00f287466771", "patch": "@@ -187,7 +187,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let &[ref handle, ref symbol] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_usize(this)?;\n                 let symbol = this.read_scalar(symbol)?.check_init()?;\n-                let symbol_name = this.memory.read_c_str(symbol)?;\n+                let symbol_name = this.read_c_str(symbol)?;\n                 if let Some(dlsym) = Dlsym::from_str(symbol_name, &this.tcx.sess.target.os)? {\n                     let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n                     this.write_scalar(Scalar::from(ptr), dest)?;"}, {"sha": "1e4597848914bcd7c416dd94b4fbbdafbbe27150", "filename": "src/shims/posix/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fposix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fposix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fthread.rs?ref=4f171d7fe3cc9e24adb5917f226b00f287466771", "patch": "@@ -111,7 +111,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let option = this.read_scalar(option)?.to_i32()?;\n         if option == this.eval_libc_i32(\"PR_SET_NAME\")? {\n             let address = this.read_scalar(arg2)?.check_init()?;\n-            let mut name = this.memory.read_c_str(address)?.to_owned();\n+            let mut name = this.read_c_str(address)?.to_owned();\n             // The name should be no more than 16 bytes, including the null\n             // byte. Since `read_c_str` returns the string without the null\n             // byte, we need to truncate to 15.\n@@ -134,7 +134,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"pthread_setname_np\");\n \n-        let name = this.memory.read_c_str(name)?.to_owned();\n+        let name = this.read_c_str(name)?.to_owned();\n         this.set_active_thread_name(name);\n \n         Ok(())"}, {"sha": "b246ccc33cf723bcd2a59845c332a587ec2155bd", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f171d7fe3cc9e24adb5917f226b00f287466771/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=4f171d7fe3cc9e24adb5917f226b00f287466771", "patch": "@@ -271,7 +271,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 #[allow(non_snake_case)]\n                 let &[ref hModule, ref lpProcName] = check_arg_count(args)?;\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n-                let name = this.memory.read_c_str(this.read_scalar(lpProcName)?.check_init()?)?;\n+                let name = this.read_c_str(this.read_scalar(lpProcName)?.check_init()?)?;\n                 if let Some(dlsym) = Dlsym::from_str(name, &this.tcx.sess.target.os)? {\n                     let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n                     this.write_scalar(Scalar::from(ptr), dest)?;"}]}