{"sha": "a41602561c996d73256097e7b8cb5ab8db9fcc53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTYwMjU2MWM5OTZkNzMyNTYwOTdlN2I4Y2I1YWI4ZGI5ZmNjNTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-14T04:57:13Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-25T08:30:02Z"}, "message": "move validation to its own file", "tree": {"sha": "55a5ff189b861805f04bd480d13fa3cb7423de13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55a5ff189b861805f04bd480d13fa3cb7423de13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a41602561c996d73256097e7b8cb5ab8db9fcc53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a41602561c996d73256097e7b8cb5ab8db9fcc53", "html_url": "https://github.com/rust-lang/rust/commit/a41602561c996d73256097e7b8cb5ab8db9fcc53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a41602561c996d73256097e7b8cb5ab8db9fcc53/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "359e5360d88ccb70879e9fac94a3010abb493cdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/359e5360d88ccb70879e9fac94a3010abb493cdd", "html_url": "https://github.com/rust-lang/rust/commit/359e5360d88ccb70879e9fac94a3010abb493cdd"}], "stats": {"total": 483, "additions": 246, "deletions": 237}, "files": [{"sha": "e4ab3d90a5c1abc924eae433a00b4ed1628fc3f7", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 5, "deletions": 236, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/a41602561c996d73256097e7b8cb5ab8db9fcc53/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41602561c996d73256097e7b8cb5ab8db9fcc53/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=a41602561c996d73256097e7b8cb5ab8db9fcc53", "patch": "@@ -1,14 +1,12 @@\n-use rustc::hir::Mutability as TyMutability;\n-use rustc::mir::{self, ValidationOp};\n+use rustc::mir;\n use rustc::ty::layout::{Size, Align};\n use rustc::ty::{self, Ty};\n-use rustc::middle::region::CodeExtent;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n-use memory::{MemoryPointer, AccessKind};\n+use memory::MemoryPointer;\n use value::{PrimVal, Pointer, Value};\n \n #[derive(Copy, Clone, Debug)]\n@@ -351,7 +349,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n     }\n \n-    fn val_to_lvalue(&mut self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn val_to_lvalue(&mut self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = val.into_ptr_vtable_pair(&mut self.memory)?;\n@@ -365,7 +363,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         })\n     }\n \n-    fn lvalue_index(&mut self, base: Lvalue<'tcx>, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn lvalue_index(&mut self, base: Lvalue<'tcx>, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n         let base = self.force_allocation(base)?;\n         let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n@@ -377,7 +375,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned })\n     }\n \n-    fn eval_lvalue_projection(\n+    pub(super) fn eval_lvalue_projection(\n         &mut self,\n         base: Lvalue<'tcx>,\n         base_ty: Ty<'tcx>,\n@@ -467,232 +465,3 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(lvalue.ty(self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n     }\n }\n-\n-// Validity checks\n-#[derive(Copy, Clone, Debug)]\n-pub struct ValidationCtx {\n-    op: ValidationOp,\n-    region: Option<CodeExtent>,\n-    mutbl: TyMutability,\n-}\n-\n-impl ValidationCtx {\n-    pub fn new(op: ValidationOp) -> Self {\n-        ValidationCtx {\n-            op, region: None, mutbl: TyMutability::MutMutable,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    fn validate_variant(\n-        &mut self,\n-        lvalue: Lvalue<'tcx>,\n-        ty: Ty<'tcx>,\n-        variant: &ty::VariantDef,\n-        subst: &ty::subst::Substs<'tcx>,\n-        vctx: ValidationCtx,\n-    ) -> EvalResult<'tcx> {\n-        // TODO: Take visibility/privacy into account.\n-        for (idx, field) in variant.fields.iter().enumerate() {\n-            let field_ty = field.ty(self.tcx, subst);\n-            let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n-            self.validate(field_lvalue, field_ty, vctx)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, vctx: ValidationCtx) -> EvalResult<'tcx> {\n-        // Check alignment and non-NULLness\n-        let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n-        let ptr = val.into_ptr(&mut self.memory)?;\n-        self.memory.check_align(ptr, align)?;\n-\n-        // Recurse\n-        let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n-        self.validate(pointee_lvalue, pointee_ty, vctx)\n-    }\n-\n-    /// Validate the lvalue at the given type. If `release` is true, just do a release of all write locks\n-    pub(super) fn validate(&mut self, lvalue: Lvalue<'tcx>, ty: Ty<'tcx>, mut vctx: ValidationCtx) -> EvalResult<'tcx>\n-    {\n-        use rustc::ty::TypeVariants::*;\n-        use rustc::ty::RegionKind::*;\n-        use rustc::ty::AdtKind;\n-        use self::TyMutability::*;\n-\n-        trace!(\"Validating {:?} at type {}, context {:?}\", lvalue, ty, vctx);\n-\n-        // Decide whether this type *owns* the memory it covers (like integers), or whether it\n-        // just assembles pieces (that each own their memory) together to a larger whole.\n-        // TODO: Currently, we don't acquire locks for padding and discriminants. We should.\n-        let is_owning = match ty.sty {\n-            TyInt(_) | TyUint(_) | TyRawPtr(_) |\n-            TyBool | TyFloat(_) | TyChar | TyStr |\n-            TyRef(..) | TyFnPtr(..) | TyNever => true,\n-            TyAdt(adt, _) if adt.is_box() => true,\n-            TySlice(_) | TyAdt(_, _) | TyTuple(..) | TyClosure(..) | TyArray(..) => false,\n-            TyParam(_) | TyInfer(_) => bug!(\"I got an incomplete type for validation\"),\n-            _ => return Err(EvalError::Unimplemented(format!(\"Unimplemented type encountered when checking validity.\"))),\n-        };\n-        if is_owning {\n-            match lvalue {\n-                Lvalue::Ptr { ptr, extra, aligned: _ } => {\n-                    // Determine the size\n-                    // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n-                    let len = match self.type_size(ty)? {\n-                        Some(size) => {\n-                            assert_eq!(extra, LvalueExtra::None, \"Got a fat ptr to a sized type\");\n-                            size\n-                        }\n-                        None => {\n-                            // The only unsized typ we concider \"owning\" is TyStr.\n-                            assert_eq!(ty.sty, TyStr, \"Found a surprising unsized owning type\");\n-                            // The extra must be the length, in bytes.\n-                            match extra {\n-                                LvalueExtra::Length(len) => len,\n-                                _ => bug!(\"TyStr must have a length as extra\"),\n-                            }\n-                        }\n-                    };\n-                    // Handle locking\n-                    if len > 0 {\n-                        let ptr = ptr.to_ptr()?;\n-                        let access = match vctx.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n-                        match vctx.op {\n-                            ValidationOp::Acquire => self.memory.acquire_lock(ptr, len, vctx.region, access)?,\n-                            ValidationOp::Release => self.memory.release_write_lock_until(ptr, len, None)?,\n-                            ValidationOp::Suspend(region) => self.memory.release_write_lock_until(ptr, len, Some(region))?,\n-                        }\n-                    }\n-                }\n-                Lvalue::Local { ..} | Lvalue::Global(..) => {\n-                    // These are not backed by memory, so we have nothing to do.\n-                }\n-            }\n-        }\n-\n-        match ty.sty {\n-            TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n-                // TODO: Make sure these are not undef.\n-                // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n-                Ok(())\n-            }\n-            TyBool | TyFloat(_) | TyChar | TyStr => {\n-                // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n-                Ok(())\n-            }\n-            TyNever => {\n-                Err(EvalError::ValidationFailure(format!(\"The empty type is never valid.\")))\n-            }\n-            TyRef(region, ty::TypeAndMut { ty: pointee_ty, mutbl }) => {\n-                let val = self.read_lvalue(lvalue)?;\n-                // Sharing restricts our context\n-                if mutbl == MutImmutable {\n-                    // Actually, in case of releasing-validation, this means we are done.\n-                    if vctx.op != ValidationOp::Acquire {\n-                        return Ok(());\n-                    }\n-                    vctx.mutbl = MutImmutable;\n-                }\n-                // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n-                // we record the region of this borrow to the context.\n-                if vctx.region == None {\n-                    match *region {\n-                        ReScope(ce) => vctx.region = Some(ce),\n-                        // It is possible for us to encode erased lifetimes here because the lifetimes in\n-                        // this functions' Subst will be erased.\n-                        _ => {},\n-                    }\n-                }\n-                self.validate_ptr(val, pointee_ty, vctx)\n-            }\n-            TyAdt(adt, _) if adt.is_box() => {\n-                let val = self.read_lvalue(lvalue)?;\n-                self.validate_ptr(val, ty.boxed_ty(), vctx)\n-            }\n-            TyFnPtr(_sig) => {\n-                // TODO: The function names here could need some improvement.\n-                let ptr = self.read_lvalue(lvalue)?.into_ptr(&mut self.memory)?.to_ptr()?;\n-                self.memory.get_fn(ptr)?;\n-                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                Ok(())\n-            }\n-\n-            // Compound types\n-            TySlice(elem_ty) => {\n-                let len = match lvalue {\n-                    Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n-                    _ => bug!(\"acquire_valid of a TySlice given non-slice lvalue: {:?}\", lvalue),\n-                };\n-                for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(lvalue, ty, i)?;\n-                    self.validate(inner_lvalue, elem_ty, vctx)?;\n-                }\n-                Ok(())\n-            }\n-            TyArray(elem_ty, len) => {\n-                for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(lvalue, ty, i as u64)?;\n-                    self.validate(inner_lvalue, elem_ty, vctx)?;\n-                }\n-                Ok(())\n-            }\n-            TyAdt(adt, subst) => {\n-                match adt.adt_kind() {\n-                    AdtKind::Enum => {\n-                        // TODO: Can we get the discriminant without forcing an allocation?\n-                        let ptr = self.force_allocation(lvalue)?.to_ptr()?;\n-                        let discr = self.read_discriminant_value(ptr, ty)?;\n-\n-                        // Get variant index for discriminant\n-                        let variant_idx = adt.discriminants(self.tcx)\n-                            .position(|variant_discr| variant_discr.to_u128_unchecked() == discr)\n-                            .ok_or(EvalError::InvalidDiscriminant)?;\n-                        let variant = &adt.variants[variant_idx];\n-\n-                        if variant.fields.len() > 0 {\n-                            // Downcast to this variant, if needed\n-                            let lvalue = if adt.variants.len() > 1 {\n-                                self.eval_lvalue_projection(lvalue, ty, &mir::ProjectionElem::Downcast(adt, variant_idx))?\n-                            } else {\n-                                lvalue\n-                            };\n-\n-                            // Recursively validate the fields\n-                            self.validate_variant(lvalue, ty, variant, subst, vctx)\n-                        } else {\n-                            // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n-                            Ok(())\n-                        }\n-                    }\n-                    AdtKind::Struct => {\n-                        self.validate_variant(lvalue, ty, adt.struct_variant(), subst, vctx)\n-                    }\n-                    AdtKind::Union => {\n-                        // No guarantees are provided for union types.\n-                        // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n-                        Ok(())\n-                    }\n-                }\n-            }\n-            TyTuple(ref types, _) => {\n-                for (idx, field_ty) in types.iter().enumerate() {\n-                    let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n-                    self.validate(field_lvalue, field_ty, vctx)?;\n-                }\n-                Ok(())\n-            }\n-            TyClosure(def_id, ref closure_substs) => {\n-                for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n-                    let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n-                    self.validate(field_lvalue, field_ty, vctx)?;\n-                }\n-                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                // Is there other things we can/should check?  Like vtable pointers?\n-                Ok(())\n-            }\n-            _ => bug!(\"We already establishd that this is a type we support.\")\n-        }\n-    }\n-}"}, {"sha": "66b4cd01d0e8b033d419a4934bf45a25a85f3c0b", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a41602561c996d73256097e7b8cb5ab8db9fcc53/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41602561c996d73256097e7b8cb5ab8db9fcc53/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=a41602561c996d73256097e7b8cb5ab8db9fcc53", "patch": "@@ -22,6 +22,7 @@ mod const_eval;\n mod error;\n mod eval_context;\n mod lvalue;\n+mod validation;\n mod memory;\n mod operator;\n mod step;"}, {"sha": "7c8f3764f2b7971b689cc078835015d9c0e29bba", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41602561c996d73256097e7b8cb5ab8db9fcc53/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41602561c996d73256097e7b8cb5ab8db9fcc53/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=a41602561c996d73256097e7b8cb5ab8db9fcc53", "patch": "@@ -14,7 +14,8 @@ use rustc::infer::TransNormalize;\n \n use error::{EvalResult, EvalError};\n use eval_context::{EvalContext, StackPopCleanup};\n-use lvalue::{Global, GlobalId, Lvalue, ValidationCtx};\n+use lvalue::{Global, GlobalId, Lvalue};\n+use validation::ValidationCtx;\n use value::{Value, PrimVal};\n use syntax::codemap::Span;\n use syntax::ast::Mutability;"}, {"sha": "766a16c95edd51174393a78c9a603f843458a81b", "filename": "src/librustc_mir/interpret/validation.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/a41602561c996d73256097e7b8cb5ab8db9fcc53/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41602561c996d73256097e7b8cb5ab8db9fcc53/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=a41602561c996d73256097e7b8cb5ab8db9fcc53", "patch": "@@ -0,0 +1,238 @@\n+use rustc::hir::Mutability;\n+use rustc::mir::{self, ValidationOp};\n+use rustc::ty::{self, Ty};\n+use rustc::middle::region::CodeExtent;\n+\n+use error::{EvalError, EvalResult};\n+use eval_context::{EvalContext};\n+use memory::AccessKind;\n+use value::Value;\n+use lvalue::{Lvalue, LvalueExtra};\n+\n+// Validity checks\n+#[derive(Copy, Clone, Debug)]\n+pub struct ValidationCtx {\n+    op: ValidationOp,\n+    region: Option<CodeExtent>,\n+    mutbl: Mutability,\n+}\n+\n+impl ValidationCtx {\n+    pub fn new(op: ValidationOp) -> Self {\n+        ValidationCtx {\n+            op, region: None, mutbl: Mutability::MutMutable,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    fn validate_variant(\n+        &mut self,\n+        lvalue: Lvalue<'tcx>,\n+        ty: Ty<'tcx>,\n+        variant: &ty::VariantDef,\n+        subst: &ty::subst::Substs<'tcx>,\n+        vctx: ValidationCtx,\n+    ) -> EvalResult<'tcx> {\n+        // TODO: Take visibility/privacy into account.\n+        for (idx, field) in variant.fields.iter().enumerate() {\n+            let field_ty = field.ty(self.tcx, subst);\n+            let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n+            self.validate(field_lvalue, field_ty, vctx)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, vctx: ValidationCtx) -> EvalResult<'tcx> {\n+        // Check alignment and non-NULLness\n+        let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n+        let ptr = val.into_ptr(&mut self.memory)?;\n+        self.memory.check_align(ptr, align)?;\n+\n+        // Recurse\n+        let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n+        self.validate(pointee_lvalue, pointee_ty, vctx)\n+    }\n+\n+    /// Validate the lvalue at the given type. If `release` is true, just do a release of all write locks\n+    pub(super) fn validate(&mut self, lvalue: Lvalue<'tcx>, ty: Ty<'tcx>, mut vctx: ValidationCtx) -> EvalResult<'tcx>\n+    {\n+        use rustc::ty::TypeVariants::*;\n+        use rustc::ty::RegionKind::*;\n+        use rustc::ty::AdtKind;\n+        use self::Mutability::*;\n+        trace!(\"Validating {:?} at type {}, context {:?}\", lvalue, ty, vctx);\n+\n+        // Decide whether this type *owns* the memory it covers (like integers), or whether it\n+        // just assembles pieces (that each own their memory) together to a larger whole.\n+        // TODO: Currently, we don't acquire locks for padding and discriminants. We should.\n+        let is_owning = match ty.sty {\n+            TyInt(_) | TyUint(_) | TyRawPtr(_) |\n+            TyBool | TyFloat(_) | TyChar | TyStr |\n+            TyRef(..) | TyFnPtr(..) | TyNever => true,\n+            TyAdt(adt, _) if adt.is_box() => true,\n+            TySlice(_) | TyAdt(_, _) | TyTuple(..) | TyClosure(..) | TyArray(..) => false,\n+            TyParam(_) | TyInfer(_) => bug!(\"I got an incomplete type for validation\"),\n+            _ => return Err(EvalError::Unimplemented(format!(\"Unimplemented type encountered when checking validity.\"))),\n+        };\n+        if is_owning {\n+            match lvalue {\n+                Lvalue::Ptr { ptr, extra, aligned: _ } => {\n+                    // Determine the size\n+                    // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n+                    let len = match self.type_size(ty)? {\n+                        Some(size) => {\n+                            assert_eq!(extra, LvalueExtra::None, \"Got a fat ptr to a sized type\");\n+                            size\n+                        }\n+                        None => {\n+                            // The only unsized typ we concider \"owning\" is TyStr.\n+                            assert_eq!(ty.sty, TyStr, \"Found a surprising unsized owning type\");\n+                            // The extra must be the length, in bytes.\n+                            match extra {\n+                                LvalueExtra::Length(len) => len,\n+                                _ => bug!(\"TyStr must have a length as extra\"),\n+                            }\n+                        }\n+                    };\n+                    // Handle locking\n+                    if len > 0 {\n+                        let ptr = ptr.to_ptr()?;\n+                        let access = match vctx.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n+                        match vctx.op {\n+                            ValidationOp::Acquire => self.memory.acquire_lock(ptr, len, vctx.region, access)?,\n+                            ValidationOp::Release => self.memory.release_write_lock_until(ptr, len, None)?,\n+                            ValidationOp::Suspend(region) => self.memory.release_write_lock_until(ptr, len, Some(region))?,\n+                        }\n+                    }\n+                }\n+                Lvalue::Local { ..} | Lvalue::Global(..) => {\n+                    // These are not backed by memory, so we have nothing to do.\n+                }\n+            }\n+        }\n+\n+        match ty.sty {\n+            TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n+                // TODO: Make sure these are not undef.\n+                // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n+                Ok(())\n+            }\n+            TyBool | TyFloat(_) | TyChar | TyStr => {\n+                // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n+                Ok(())\n+            }\n+            TyNever => {\n+                Err(EvalError::ValidationFailure(format!(\"The empty type is never valid.\")))\n+            }\n+            TyRef(region, ty::TypeAndMut { ty: pointee_ty, mutbl }) => {\n+                let val = self.read_lvalue(lvalue)?;\n+                // Sharing restricts our context\n+                if mutbl == MutImmutable {\n+                    // Actually, in case of releasing-validation, this means we are done.\n+                    if vctx.op != ValidationOp::Acquire {\n+                        return Ok(());\n+                    }\n+                    vctx.mutbl = MutImmutable;\n+                }\n+                // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n+                // we record the region of this borrow to the context.\n+                if vctx.region == None {\n+                    match *region {\n+                        ReScope(ce) => vctx.region = Some(ce),\n+                        // It is possible for us to encode erased lifetimes here because the lifetimes in\n+                        // this functions' Subst will be erased.\n+                        _ => {},\n+                    }\n+                }\n+                self.validate_ptr(val, pointee_ty, vctx)\n+            }\n+            TyAdt(adt, _) if adt.is_box() => {\n+                let val = self.read_lvalue(lvalue)?;\n+                self.validate_ptr(val, ty.boxed_ty(), vctx)\n+            }\n+            TyFnPtr(_sig) => {\n+                // TODO: The function names here could need some improvement.\n+                let ptr = self.read_lvalue(lvalue)?.into_ptr(&mut self.memory)?.to_ptr()?;\n+                self.memory.get_fn(ptr)?;\n+                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                Ok(())\n+            }\n+\n+            // Compound types\n+            TySlice(elem_ty) => {\n+                let len = match lvalue {\n+                    Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n+                    _ => bug!(\"acquire_valid of a TySlice given non-slice lvalue: {:?}\", lvalue),\n+                };\n+                for i in 0..len {\n+                    let inner_lvalue = self.lvalue_index(lvalue, ty, i)?;\n+                    self.validate(inner_lvalue, elem_ty, vctx)?;\n+                }\n+                Ok(())\n+            }\n+            TyArray(elem_ty, len) => {\n+                for i in 0..len {\n+                    let inner_lvalue = self.lvalue_index(lvalue, ty, i as u64)?;\n+                    self.validate(inner_lvalue, elem_ty, vctx)?;\n+                }\n+                Ok(())\n+            }\n+            TyAdt(adt, subst) => {\n+                match adt.adt_kind() {\n+                    AdtKind::Enum => {\n+                        // TODO: Can we get the discriminant without forcing an allocation?\n+                        let ptr = self.force_allocation(lvalue)?.to_ptr()?;\n+                        let discr = self.read_discriminant_value(ptr, ty)?;\n+\n+                        // Get variant index for discriminant\n+                        let variant_idx = adt.discriminants(self.tcx)\n+                            .position(|variant_discr| variant_discr.to_u128_unchecked() == discr)\n+                            .ok_or(EvalError::InvalidDiscriminant)?;\n+                        let variant = &adt.variants[variant_idx];\n+\n+                        if variant.fields.len() > 0 {\n+                            // Downcast to this variant, if needed\n+                            let lvalue = if adt.variants.len() > 1 {\n+                                self.eval_lvalue_projection(lvalue, ty, &mir::ProjectionElem::Downcast(adt, variant_idx))?\n+                            } else {\n+                                lvalue\n+                            };\n+\n+                            // Recursively validate the fields\n+                            self.validate_variant(lvalue, ty, variant, subst, vctx)\n+                        } else {\n+                            // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n+                            Ok(())\n+                        }\n+                    }\n+                    AdtKind::Struct => {\n+                        self.validate_variant(lvalue, ty, adt.struct_variant(), subst, vctx)\n+                    }\n+                    AdtKind::Union => {\n+                        // No guarantees are provided for union types.\n+                        // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n+                        Ok(())\n+                    }\n+                }\n+            }\n+            TyTuple(ref types, _) => {\n+                for (idx, field_ty) in types.iter().enumerate() {\n+                    let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n+                    self.validate(field_lvalue, field_ty, vctx)?;\n+                }\n+                Ok(())\n+            }\n+            TyClosure(def_id, ref closure_substs) => {\n+                for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n+                    let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n+                    self.validate(field_lvalue, field_ty, vctx)?;\n+                }\n+                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                // Is there other things we can/should check?  Like vtable pointers?\n+                Ok(())\n+            }\n+            _ => bug!(\"We already establishd that this is a type we support.\")\n+        }\n+    }\n+}"}]}