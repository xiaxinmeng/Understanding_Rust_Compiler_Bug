{"sha": "c0e249ce675924f760e94b0426fbb450f1d1c2cb", "node_id": "C_kwDOAAsO6NoAKGMwZTI0OWNlNjc1OTI0Zjc2MGU5NGIwNDI2ZmJiNDUwZjFkMWMyY2I", "commit": {"author": {"name": "Markus Reiter", "email": "me@reitermark.us", "date": "2022-09-01T23:11:20Z"}, "committer": {"name": "Markus Reiter", "email": "me@reitermark.us", "date": "2022-09-12T17:04:17Z"}, "message": "Fix clippy.", "tree": {"sha": "8d0647aa97b22781a13651d8fa26a4b1283c4a96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d0647aa97b22781a13651d8fa26a4b1283c4a96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0e249ce675924f760e94b0426fbb450f1d1c2cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e249ce675924f760e94b0426fbb450f1d1c2cb", "html_url": "https://github.com/rust-lang/rust/commit/c0e249ce675924f760e94b0426fbb450f1d1c2cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0e249ce675924f760e94b0426fbb450f1d1c2cb/comments", "author": {"login": "reitermarkus", "id": 1309829, "node_id": "MDQ6VXNlcjEzMDk4Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1309829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reitermarkus", "html_url": "https://github.com/reitermarkus", "followers_url": "https://api.github.com/users/reitermarkus/followers", "following_url": "https://api.github.com/users/reitermarkus/following{/other_user}", "gists_url": "https://api.github.com/users/reitermarkus/gists{/gist_id}", "starred_url": "https://api.github.com/users/reitermarkus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reitermarkus/subscriptions", "organizations_url": "https://api.github.com/users/reitermarkus/orgs", "repos_url": "https://api.github.com/users/reitermarkus/repos", "events_url": "https://api.github.com/users/reitermarkus/events{/privacy}", "received_events_url": "https://api.github.com/users/reitermarkus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reitermarkus", "id": 1309829, "node_id": "MDQ6VXNlcjEzMDk4Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1309829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reitermarkus", "html_url": "https://github.com/reitermarkus", "followers_url": "https://api.github.com/users/reitermarkus/followers", "following_url": "https://api.github.com/users/reitermarkus/following{/other_user}", "gists_url": "https://api.github.com/users/reitermarkus/gists{/gist_id}", "starred_url": "https://api.github.com/users/reitermarkus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reitermarkus/subscriptions", "organizations_url": "https://api.github.com/users/reitermarkus/orgs", "repos_url": "https://api.github.com/users/reitermarkus/repos", "events_url": "https://api.github.com/users/reitermarkus/events{/privacy}", "received_events_url": "https://api.github.com/users/reitermarkus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42361da5d976297cf856de606916812390c298ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/42361da5d976297cf856de606916812390c298ca", "html_url": "https://github.com/rust-lang/rust/commit/42361da5d976297cf856de606916812390c298ca"}], "stats": {"total": 81, "additions": 65, "deletions": 16}, "files": [{"sha": "39c8e9a93f06d269e5c721ae74f395f57dac43c3", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c0e249ce675924f760e94b0426fbb450f1d1c2cb/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e249ce675924f760e94b0426fbb450f1d1c2cb/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=c0e249ce675924f760e94b0426fbb450f1d1c2cb", "patch": "@@ -2,7 +2,7 @@ use super::REDUNDANT_PATTERN_MATCHING;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::ty::{is_type_diagnostic_item, needs_ordered_drop};\n use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n use clippy_utils::{higher, is_lang_ctor, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n@@ -12,7 +12,7 @@ use rustc_hir::LangItem::{OptionNone, PollPending};\n use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n-use rustc_span::sym;\n+use rustc_span::{sym, Symbol, def_id::DefId};\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n@@ -75,9 +75,9 @@ fn find_sugg_for_if_let<'tcx>(\n                     (\"is_some()\", op_ty)\n                 } else if Some(id) == lang_items.poll_ready_variant() {\n                     (\"is_ready()\", op_ty)\n-                } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n+                } else if is_pat_variant(cx, check_pat, qpath, &paths::IPADDR_V4, Item::Diag(sym!(IpAddr), sym!(V4))) {\n                     (\"is_ipv4()\", op_ty)\n-                } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n+                } else if is_pat_variant(cx, check_pat, qpath, &paths::IPADDR_V6, Item::Diag(sym!(IpAddr), sym!(V6))) {\n                     (\"is_ipv6()\", op_ty)\n                 } else {\n                     return;\n@@ -174,6 +174,7 @@ fn find_sugg_for_if_let<'tcx>(\n \n pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n     if arms.len() == 2 {\n+        let lang_items = cx.tcx.lang_items();\n         let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n \n         let found_good_method = match node_pair {\n@@ -188,7 +189,9 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                         path_left,\n                         path_right,\n                         &paths::RESULT_OK,\n+                        Item::Lang(lang_items.result_ok_variant()),\n                         &paths::RESULT_ERR,\n+                        Item::Lang(lang_items.result_err_variant()),\n                         \"is_ok()\",\n                         \"is_err()\",\n                     )\n@@ -199,7 +202,9 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                             path_left,\n                             path_right,\n                             &paths::IPADDR_V4,\n+                            Item::Diag(sym!(IpAddr), sym!(V4)),\n                             &paths::IPADDR_V6,\n+                            Item::Diag(sym!(IpAddr), sym!(V6)),\n                             \"is_ipv4()\",\n                             \"is_ipv6()\",\n                         )\n@@ -213,13 +218,16 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                 if patterns.len() == 1 =>\n             {\n                 if let PatKind::Wild = patterns[0].kind {\n+\n                     find_good_method_for_match(\n                         cx,\n                         arms,\n                         path_left,\n                         path_right,\n                         &paths::OPTION_SOME,\n+                        Item::Lang(lang_items.option_some_variant()),\n                         &paths::OPTION_NONE,\n+                        Item::Lang(lang_items.option_none_variant()),\n                         \"is_some()\",\n                         \"is_none()\",\n                     )\n@@ -230,7 +238,9 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n                             path_left,\n                             path_right,\n                             &paths::POLL_READY,\n+                            Item::Lang(lang_items.poll_ready_variant()),\n                             &paths::POLL_PENDING,\n+                            Item::Lang(lang_items.poll_pending_variant()),\n                             \"is_ready()\",\n                             \"is_pending()\",\n                         )\n@@ -266,28 +276,67 @@ pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op\n     }\n }\n \n+#[derive(Clone, Copy)]\n+enum Item {\n+  Lang(Option<DefId>),\n+  Diag(Symbol, Symbol),\n+}\n+\n+fn is_pat_variant(cx: &LateContext<'_>, pat: &Pat<'_>, path: &QPath<'_>, expected_path: &[&str], expected_item: Item) -> bool {\n+    let Some(id) = cx.typeck_results().qpath_res(path, pat.hir_id).opt_def_id() else { return false };\n+\n+    // TODO: Path matching can be removed when `IpAddr` is a diagnostic item.\n+    if match_def_path(cx, id, expected_path) {\n+        return true\n+    }\n+\n+    match expected_item {\n+        Item::Lang(expected_id) => {\n+            Some(cx.tcx.parent(id)) == expected_id\n+        },\n+        Item::Diag(expected_ty, expected_variant) => {\n+            let ty = cx.typeck_results().pat_ty(pat);\n+\n+            if is_type_diagnostic_item(cx, ty, expected_ty) {\n+                let variant = ty.ty_adt_def()\n+                    .expect(\"struct pattern type is not an ADT\")\n+                    .variant_of_res(cx.qpath_res(path, pat.hir_id));\n+\n+                return variant.name == expected_variant\n+            }\n+\n+            false\n+        }\n+    }\n+}\n+\n #[expect(clippy::too_many_arguments)]\n fn find_good_method_for_match<'a>(\n     cx: &LateContext<'_>,\n     arms: &[Arm<'_>],\n     path_left: &QPath<'_>,\n     path_right: &QPath<'_>,\n-    expected_left: &[&str],\n-    expected_right: &[&str],\n+    expected_path_left: &[&str],\n+    expected_item_left: Item,\n+    expected_path_right: &[&str],\n+    expected_item_right: Item,\n     should_be_left: &'a str,\n     should_be_right: &'a str,\n ) -> Option<&'a str> {\n-    let left_id = cx\n-        .typeck_results()\n-        .qpath_res(path_left, arms[0].pat.hir_id)\n-        .opt_def_id()?;\n-    let right_id = cx\n-        .typeck_results()\n-        .qpath_res(path_right, arms[1].pat.hir_id)\n-        .opt_def_id()?;\n-    let body_node_pair = if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+    let pat_left = arms[0].pat;\n+    let pat_right = arms[1].pat;\n+\n+    let body_node_pair = if (\n+        is_pat_variant(cx, pat_left, path_left, expected_path_left, expected_item_left)\n+    ) && (\n+        is_pat_variant(cx, pat_right, path_right, expected_path_right, expected_item_right)\n+    ) {\n         (&arms[0].body.kind, &arms[1].body.kind)\n-    } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+    } else if (\n+        is_pat_variant(cx, pat_left, path_left, expected_path_right, expected_item_right)\n+    ) && (\n+        is_pat_variant(cx, pat_right, path_right, expected_path_left, expected_item_left)\n+    ) {\n         (&arms[1].body.kind, &arms[0].body.kind)\n     } else {\n         return None;"}]}