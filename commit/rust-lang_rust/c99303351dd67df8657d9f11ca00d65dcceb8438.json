{"sha": "c99303351dd67df8657d9f11ca00d65dcceb8438", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5OTMwMzM1MWRkNjdkZjg2NTdkOWYxMWNhMDBkNjVkY2NlYjg0Mzg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-03-11T14:14:24Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-03-11T14:14:24Z"}, "message": "Revised warning-downgrade strategy for nested impl trait.\n\nInstead of a sticky-boolean flag that would downgrade errors to\nwarnings during further recursion into the type (which is overly broad\nbecause we were not missing errors at arbitrarily deep levels), this\ninstead tracks state closer to what the original bug actually was.\n\nIn particular, the actual original bug was that we were failing to\nrecord the existence of an outer `impl Trait` solely when it occurred\nas an *immediate child* during the walk of the child types in\n`visit_generic_args`.\n\nTherefore, the correct way to precisely model when that bug would\nmanifest itself (and thus downgrade the error-to-warning accordingly)\nis to track when those outer `impl Trait` cases were previously\nunrecorded.\n\nThat's what this code does, by storing a flag with the recorded outer\n`impl Trait` indicating at which point in the compiler's control flow\nit had been stored.\n\nI will note that this commit passes the current test suite. A\nfollow-up commit will also include tests illustrating the cases that\nthis commit gets right (and were handled incorrectly by the previous\nsticky boolean).", "tree": {"sha": "b0af8a2c94edc6a17097b357e2de1dab44531797", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0af8a2c94edc6a17097b357e2de1dab44531797"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c99303351dd67df8657d9f11ca00d65dcceb8438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c99303351dd67df8657d9f11ca00d65dcceb8438", "html_url": "https://github.com/rust-lang/rust/commit/c99303351dd67df8657d9f11ca00d65dcceb8438", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c99303351dd67df8657d9f11ca00d65dcceb8438/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6cee67c27cae727e24f266f76d6613e2781f7b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6cee67c27cae727e24f266f76d6613e2781f7b6", "html_url": "https://github.com/rust-lang/rust/commit/d6cee67c27cae727e24f266f76d6613e2781f7b6"}], "stats": {"total": 104, "additions": 77, "deletions": 27}, "files": [{"sha": "1dc58921592954fbcbd6985f159128d48e6d0d34", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 77, "deletions": 27, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c99303351dd67df8657d9f11ca00d65dcceb8438/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c99303351dd67df8657d9f11ca00d65dcceb8438/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c99303351dd67df8657d9f11ca00d65dcceb8438", "patch": "@@ -24,6 +24,31 @@ use syntax_pos::Span;\n use errors::Applicability;\n use log::debug;\n \n+#[derive(Copy, Clone, Debug)]\n+struct OuterImplTrait {\n+    span: Span,\n+\n+    /// rust-lang/rust#57979: a bug in original implementation caused\n+    /// us to fail sometimes to record an outer `impl Trait`.\n+    /// Therefore, in order to reliably issue a warning (rather than\n+    /// an error) in the *precise* places where we are newly injecting\n+    /// the diagnostic, we have to distinguish between the places\n+    /// where the outer `impl Trait` has always been recorded, versus\n+    /// the places where it has only recently started being recorded.\n+    only_recorded_since_pull_request_57730: bool,\n+}\n+\n+impl OuterImplTrait {\n+    /// This controls whether we should downgrade the nested impl\n+    /// trait diagnostic to a warning rather than an error, based on\n+    /// whether the outer impl trait had been improperly skipped in\n+    /// earlier implementations of the analysis on the stable\n+    /// compiler.\n+    fn should_warn_instead_of_error(&self) -> bool {\n+        self.only_recorded_since_pull_request_57730\n+    }\n+}\n+\n struct AstValidator<'a> {\n     session: &'a Session,\n     has_proc_macro_decls: bool,\n@@ -32,7 +57,7 @@ struct AstValidator<'a> {\n     // Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n     // Nested `impl Trait` _is_ allowed in associated type position,\n     // e.g `impl Iterator<Item=impl Debug>`\n-    outer_impl_trait: Option<Span>,\n+    outer_impl_trait: Option<OuterImplTrait>,\n \n     // Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n     // or `Foo::Bar<impl Trait>`\n@@ -44,18 +69,11 @@ struct AstValidator<'a> {\n     // impl trait in projections), and thus miss some cases. We track\n     // whether we should downgrade to a warning for short-term via\n     // these booleans.\n-    warning_period_57979_nested_impl_trait: bool,\n+    warning_period_57979_didnt_record_next_impl_trait: bool,\n     warning_period_57979_impl_trait_in_proj: bool,\n }\n \n impl<'a> AstValidator<'a> {\n-    fn with_nested_impl_trait_warning<T>(&mut self, v: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let old = mem::replace(&mut self.warning_period_57979_nested_impl_trait, v);\n-        let ret = f(self);\n-        self.warning_period_57979_nested_impl_trait = old;\n-        ret\n-    }\n-\n     fn with_impl_trait_in_proj_warning<T>(&mut self, v: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n         let old = mem::replace(&mut self.warning_period_57979_impl_trait_in_proj, v);\n         let ret = f(self);\n@@ -69,17 +87,53 @@ impl<'a> AstValidator<'a> {\n         self.is_impl_trait_banned = old;\n     }\n \n-    fn with_impl_trait(&mut self, outer_impl_trait: Option<Span>, f: impl FnOnce(&mut Self)) {\n-        let old = mem::replace(&mut self.outer_impl_trait, outer_impl_trait);\n+    fn with_impl_trait(&mut self, outer: Option<OuterImplTrait>, f: impl FnOnce(&mut Self)) {\n+        let old = mem::replace(&mut self.outer_impl_trait, outer);\n         f(self);\n         self.outer_impl_trait = old;\n     }\n \n+    fn visit_assoc_type_binding_from_generic_args(&mut self, type_binding: &'a TypeBinding) {\n+        // rust-lang/rust#57979: bug in old visit_generic_args called\n+        // walk_ty rather than visit_ty, skipping outer `impl Trait`\n+        // if it happened to occur at `type_binding.ty`\n+        if let TyKind::ImplTrait(..) = type_binding.ty.node {\n+            self.warning_period_57979_didnt_record_next_impl_trait = true;\n+        }\n+        self.visit_assoc_type_binding(type_binding);\n+    }\n+\n+    fn visit_ty_from_generic_args(&mut self, ty: &'a Ty) {\n+        // rust-lang/rust#57979: bug in old visit_generic_args called\n+        // walk_ty rather than visit_ty, skippping outer `impl Trait`\n+        // if it happened to occur at `ty`\n+        if let TyKind::ImplTrait(..) = ty.node {\n+            self.warning_period_57979_didnt_record_next_impl_trait = true;\n+        }\n+        self.visit_ty(ty);\n+    }\n+\n+    fn outer_impl_trait(&mut self, span: Span) -> OuterImplTrait {\n+        let only_recorded_since_pull_request_57730 =\n+            self.warning_period_57979_didnt_record_next_impl_trait;\n+\n+        // (this flag is designed to be set to true and then only\n+        // reach the construction point for the outer impl trait once,\n+        // so its safe and easiest to unconditionally reset it to\n+        // false)\n+        self.warning_period_57979_didnt_record_next_impl_trait = false;\n+\n+        OuterImplTrait {\n+            span, only_recorded_since_pull_request_57730,\n+        }\n+    }\n+\n     // Mirrors visit::walk_ty, but tracks relevant state\n     fn walk_ty(&mut self, t: &'a Ty) {\n         match t.node {\n             TyKind::ImplTrait(..) => {\n-                self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n+                let outer_impl_trait = self.outer_impl_trait(t.span);\n+                self.with_impl_trait(Some(outer_impl_trait), |this| visit::walk_ty(this, t))\n             }\n             TyKind::Path(ref qself, ref path) => {\n                 // We allow these:\n@@ -441,18 +495,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n \n                 if let Some(outer_impl_trait) = self.outer_impl_trait {\n-                    if self.warning_period_57979_nested_impl_trait {\n+                    if outer_impl_trait.should_warn_instead_of_error() {\n                         self.session.buffer_lint_with_diagnostic(\n                             NESTED_IMPL_TRAIT, ty.id, ty.span,\n                             \"nested `impl Trait` is not allowed\",\n                             BuiltinLintDiagnostics::NestedImplTrait {\n-                                outer_impl_trait_span: outer_impl_trait,\n+                                outer_impl_trait_span: outer_impl_trait.span,\n                                 inner_impl_trait_span: ty.span,\n                             });\n                     } else {\n                         struct_span_err!(self.session, ty.span, E0666,\n                             \"nested `impl Trait` is not allowed\")\n-                            .span_label(outer_impl_trait, \"outer `impl Trait`\")\n+                            .span_label(outer_impl_trait.span, \"outer `impl Trait`\")\n                             .span_label(ty.span, \"nested `impl Trait` here\")\n                             .emit();\n                     }\n@@ -650,22 +704,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }, arg.span(), None)\n                 }), GenericPosition::Arg, generic_args.span());\n \n-                self.with_nested_impl_trait_warning(true, |this| {\n-                    // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n-                    // are allowed to contain nested `impl Trait`.\n-                    this.with_impl_trait(None, |this| {\n-                        walk_list!(this, visit_assoc_type_binding, &data.bindings);\n-                    });\n+                // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n+                // are allowed to contain nested `impl Trait`.\n+                self.with_impl_trait(None, |this| {\n+                    walk_list!(this, visit_assoc_type_binding_from_generic_args, &data.bindings);\n                 });\n             }\n             GenericArgs::Parenthesized(ref data) => {\n                 walk_list!(self, visit_ty, &data.inputs);\n                 if let Some(ref type_) = data.output {\n-                    self.with_nested_impl_trait_warning(true, |this| {\n-                        // `-> Foo` syntax is essentially an associated type binding,\n-                        // so it is also allowed to contain nested `impl Trait`.\n-                        this.with_impl_trait(None, |this| this.visit_ty(type_));\n-                    });\n+                    // `-> Foo` syntax is essentially an associated type binding,\n+                    // so it is also allowed to contain nested `impl Trait`.\n+                    self.with_impl_trait(None, |this| this.visit_ty_from_generic_args(type_));\n                 }\n             }\n         }\n@@ -767,7 +817,7 @@ pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n         has_global_allocator: false,\n         outer_impl_trait: None,\n         is_impl_trait_banned: false,\n-        warning_period_57979_nested_impl_trait: false,\n+        warning_period_57979_didnt_record_next_impl_trait: false,\n         warning_period_57979_impl_trait_in_proj: false,\n     };\n     visit::walk_crate(&mut validator, krate);"}]}