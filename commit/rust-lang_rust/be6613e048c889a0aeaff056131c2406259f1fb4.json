{"sha": "be6613e048c889a0aeaff056131c2406259f1fb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNjYxM2UwNDhjODg5YTBhZWFmZjA1NjEzMWMyNDA2MjU5ZjFmYjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-19T01:56:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-27T02:13:54Z"}, "message": "Remove the crate language", "tree": {"sha": "1067f383db3a97a6b85e11637ef23b0a0a6a3549", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1067f383db3a97a6b85e11637ef23b0a0a6a3549"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be6613e048c889a0aeaff056131c2406259f1fb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be6613e048c889a0aeaff056131c2406259f1fb4", "html_url": "https://github.com/rust-lang/rust/commit/be6613e048c889a0aeaff056131c2406259f1fb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be6613e048c889a0aeaff056131c2406259f1fb4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81a79603c0c9c2425d0a8475d29b4ef77fae8607", "url": "https://api.github.com/repos/rust-lang/rust/commits/81a79603c0c9c2425d0a8475d29b4ef77fae8607", "html_url": "https://github.com/rust-lang/rust/commit/81a79603c0c9c2425d0a8475d29b4ef77fae8607"}], "stats": {"total": 8606, "additions": 4720, "deletions": 3886}, "files": [{"sha": "166672988a75a9e576375b076cf6528d509e31b1", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -26,6 +26,198 @@ mod common;\n #[legacy_exports]\n mod errors;\n \n+use std::getopts;\n+use std::test;\n+\n+use core::result;\n+use result::{Ok, Err};\n+\n+use common::config;\n+use common::mode_run_pass;\n+use common::mode_run_fail;\n+use common::mode_compile_fail;\n+use common::mode_pretty;\n+use common::mode;\n+use util::logv;\n+\n+fn main() {\n+    let args = os::args();\n+    let config = parse_config(args);\n+    log_config(config);\n+    run_tests(config);\n+}\n+\n+fn parse_config(args: ~[~str]) -> config {\n+    let opts =\n+        ~[getopts::reqopt(~\"compile-lib-path\"),\n+          getopts::reqopt(~\"run-lib-path\"),\n+          getopts::reqopt(~\"rustc-path\"), getopts::reqopt(~\"src-base\"),\n+          getopts::reqopt(~\"build-base\"), getopts::reqopt(~\"aux-base\"),\n+          getopts::reqopt(~\"stage-id\"),\n+          getopts::reqopt(~\"mode\"), getopts::optflag(~\"ignored\"),\n+          getopts::optopt(~\"runtool\"), getopts::optopt(~\"rustcflags\"),\n+          getopts::optflag(~\"verbose\"),\n+          getopts::optopt(~\"logfile\"),\n+          getopts::optflag(~\"jit\")];\n+\n+    assert (vec::is_not_empty(args));\n+    let args_ = vec::tail(args);\n+    let matches =\n+        match getopts::getopts(args_, opts) {\n+          Ok(m) => m,\n+          Err(f) => fail getopts::fail_str(f)\n+        };\n+\n+    fn opt_path(m: getopts::Matches, nm: ~str) -> Path {\n+        Path(getopts::opt_str(m, nm))\n+    }\n+\n+    return {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n+         run_lib_path: getopts::opt_str(matches, ~\"run-lib-path\"),\n+         rustc_path: opt_path(matches, ~\"rustc-path\"),\n+         src_base: opt_path(matches, ~\"src-base\"),\n+         build_base: opt_path(matches, ~\"build-base\"),\n+         aux_base: opt_path(matches, ~\"aux-base\"),\n+         stage_id: getopts::opt_str(matches, ~\"stage-id\"),\n+         mode: str_mode(getopts::opt_str(matches, ~\"mode\")),\n+         run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n+         filter:\n+             if vec::len(matches.free) > 0u {\n+                 option::Some(matches.free[0])\n+             } else { option::None },\n+         logfile: option::map(&getopts::opt_maybe_str(matches,\n+                                                     ~\"logfile\"),\n+                              |s| Path(*s)),\n+         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n+         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n+         jit: getopts::opt_present(matches, ~\"jit\"),\n+         verbose: getopts::opt_present(matches, ~\"verbose\")};\n+}\n+\n+fn log_config(config: config) {\n+    let c = config;\n+    logv(c, fmt!(\"configuration:\"));\n+    logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n+    logv(c, fmt!(\"run_lib_path: %s\", config.run_lib_path));\n+    logv(c, fmt!(\"rustc_path: %s\", config.rustc_path.to_str()));\n+    logv(c, fmt!(\"src_base: %s\", config.src_base.to_str()));\n+    logv(c, fmt!(\"build_base: %s\", config.build_base.to_str()));\n+    logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n+    logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n+    logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n+    logv(c, fmt!(\"filter: %s\", opt_str(config.filter)));\n+    logv(c, fmt!(\"runtool: %s\", opt_str(config.runtool)));\n+    logv(c, fmt!(\"rustcflags: %s\", opt_str(config.rustcflags)));\n+    logv(c, fmt!(\"jit: %b\", config.jit));\n+    logv(c, fmt!(\"verbose: %b\", config.verbose));\n+    logv(c, fmt!(\"\\n\"));\n+}\n+\n+fn opt_str(maybestr: Option<~str>) -> ~str {\n+    match maybestr { option::Some(s) => s, option::None => ~\"(none)\" }\n+}\n+\n+fn str_opt(maybestr: ~str) -> Option<~str> {\n+    if maybestr != ~\"(none)\" { option::Some(maybestr) } else { option::None }\n+}\n+\n+fn str_mode(s: ~str) -> mode {\n+    match s {\n+      ~\"compile-fail\" => mode_compile_fail,\n+      ~\"run-fail\" => mode_run_fail,\n+      ~\"run-pass\" => mode_run_pass,\n+      ~\"pretty\" => mode_pretty,\n+      _ => fail ~\"invalid mode\"\n+    }\n+}\n+\n+fn mode_str(mode: mode) -> ~str {\n+    match mode {\n+      mode_compile_fail => ~\"compile-fail\",\n+      mode_run_fail => ~\"run-fail\",\n+      mode_run_pass => ~\"run-pass\",\n+      mode_pretty => ~\"pretty\"\n+    }\n+}\n+\n+fn run_tests(config: config) {\n+    let opts = test_opts(config);\n+    let tests = make_tests(config);\n+    let res = test::run_tests_console(&opts, tests);\n+    if !res { fail ~\"Some tests failed\"; }\n+}\n+\n+fn test_opts(config: config) -> test::TestOpts {\n+    {filter:\n+         match config.filter {\n+           option::Some(s) => option::Some(s),\n+           option::None => option::None\n+         },\n+     run_ignored: config.run_ignored,\n+     logfile:\n+         match config.logfile {\n+           option::Some(s) => option::Some(s.to_str()),\n+           option::None => option::None\n+         }\n+    }\n+}\n+\n+fn make_tests(config: config) -> ~[test::TestDesc] {\n+    debug!(\"making tests from %s\",\n+           config.src_base.to_str());\n+    let mut tests = ~[];\n+    for os::list_dir_path(&config.src_base).each |file| {\n+        let file = copy *file;\n+        debug!(\"inspecting file %s\", file.to_str());\n+        if is_test(config, file) {\n+            tests.push(make_test(config, file))\n+        }\n+    }\n+    move tests\n+}\n+\n+fn is_test(config: config, testfile: &Path) -> bool {\n+    // Pretty-printer does not work with .rc files yet\n+    let valid_extensions =\n+        match config.mode {\n+          mode_pretty => ~[~\".rs\"],\n+          _ => ~[~\".rc\", ~\".rs\"]\n+        };\n+    let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n+    let name = testfile.filename().get();\n+\n+    let mut valid = false;\n+\n+    for valid_extensions.each |ext| {\n+        if str::ends_with(name, *ext) { valid = true; }\n+    }\n+\n+    for invalid_prefixes.each |pre| {\n+        if str::starts_with(name, *pre) { valid = false; }\n+    }\n+\n+    return valid;\n+}\n+\n+fn make_test(config: config, testfile: &Path) ->\n+   test::TestDesc {\n+    {\n+        name: make_test_name(config, testfile),\n+        testfn: make_test_closure(config, testfile),\n+        ignore: header::is_test_ignored(config, testfile),\n+        should_fail: false\n+    }\n+}\n+\n+fn make_test_name(config: config, testfile: &Path) -> ~str {\n+    fmt!(\"[%s] %s\", mode_str(config.mode), testfile.to_str())\n+}\n+\n+fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n+    let testfile = testfile.to_str();\n+    fn~() { runtest::run(config, testfile) }\n+}\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "e147ddc3ed7f440e73448c418c8b591fa1e025a3", "filename": "src/compiletest/compiletest.rs", "status": "removed", "additions": 0, "deletions": 198, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,198 +0,0 @@\n-use std::getopts;\n-use std::test;\n-\n-use core::result;\n-use result::{Ok, Err};\n-\n-use common::config;\n-use common::mode_run_pass;\n-use common::mode_run_fail;\n-use common::mode_compile_fail;\n-use common::mode_pretty;\n-use common::mode;\n-use util::logv;\n-\n-fn main() {\n-    let args = os::args();\n-    let config = parse_config(args);\n-    log_config(config);\n-    run_tests(config);\n-}\n-\n-fn parse_config(args: ~[~str]) -> config {\n-    let opts =\n-        ~[getopts::reqopt(~\"compile-lib-path\"),\n-          getopts::reqopt(~\"run-lib-path\"),\n-          getopts::reqopt(~\"rustc-path\"), getopts::reqopt(~\"src-base\"),\n-          getopts::reqopt(~\"build-base\"), getopts::reqopt(~\"aux-base\"),\n-          getopts::reqopt(~\"stage-id\"),\n-          getopts::reqopt(~\"mode\"), getopts::optflag(~\"ignored\"),\n-          getopts::optopt(~\"runtool\"), getopts::optopt(~\"rustcflags\"),\n-          getopts::optflag(~\"verbose\"),\n-          getopts::optopt(~\"logfile\"),\n-          getopts::optflag(~\"jit\")];\n-\n-    assert (vec::is_not_empty(args));\n-    let args_ = vec::tail(args);\n-    let matches =\n-        match getopts::getopts(args_, opts) {\n-          Ok(m) => m,\n-          Err(f) => fail getopts::fail_str(f)\n-        };\n-\n-    fn opt_path(m: getopts::Matches, nm: ~str) -> Path {\n-        Path(getopts::opt_str(m, nm))\n-    }\n-\n-    return {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n-         run_lib_path: getopts::opt_str(matches, ~\"run-lib-path\"),\n-         rustc_path: opt_path(matches, ~\"rustc-path\"),\n-         src_base: opt_path(matches, ~\"src-base\"),\n-         build_base: opt_path(matches, ~\"build-base\"),\n-         aux_base: opt_path(matches, ~\"aux-base\"),\n-         stage_id: getopts::opt_str(matches, ~\"stage-id\"),\n-         mode: str_mode(getopts::opt_str(matches, ~\"mode\")),\n-         run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n-         filter:\n-             if vec::len(matches.free) > 0u {\n-                 option::Some(matches.free[0])\n-             } else { option::None },\n-         logfile: option::map(&getopts::opt_maybe_str(matches,\n-                                                     ~\"logfile\"),\n-                              |s| Path(*s)),\n-         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n-         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n-         jit: getopts::opt_present(matches, ~\"jit\"),\n-         verbose: getopts::opt_present(matches, ~\"verbose\")};\n-}\n-\n-fn log_config(config: config) {\n-    let c = config;\n-    logv(c, fmt!(\"configuration:\"));\n-    logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n-    logv(c, fmt!(\"run_lib_path: %s\", config.run_lib_path));\n-    logv(c, fmt!(\"rustc_path: %s\", config.rustc_path.to_str()));\n-    logv(c, fmt!(\"src_base: %s\", config.src_base.to_str()));\n-    logv(c, fmt!(\"build_base: %s\", config.build_base.to_str()));\n-    logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n-    logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n-    logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n-    logv(c, fmt!(\"filter: %s\", opt_str(config.filter)));\n-    logv(c, fmt!(\"runtool: %s\", opt_str(config.runtool)));\n-    logv(c, fmt!(\"rustcflags: %s\", opt_str(config.rustcflags)));\n-    logv(c, fmt!(\"jit: %b\", config.jit));\n-    logv(c, fmt!(\"verbose: %b\", config.verbose));\n-    logv(c, fmt!(\"\\n\"));\n-}\n-\n-fn opt_str(maybestr: Option<~str>) -> ~str {\n-    match maybestr { option::Some(s) => s, option::None => ~\"(none)\" }\n-}\n-\n-fn str_opt(maybestr: ~str) -> Option<~str> {\n-    if maybestr != ~\"(none)\" { option::Some(maybestr) } else { option::None }\n-}\n-\n-fn str_mode(s: ~str) -> mode {\n-    match s {\n-      ~\"compile-fail\" => mode_compile_fail,\n-      ~\"run-fail\" => mode_run_fail,\n-      ~\"run-pass\" => mode_run_pass,\n-      ~\"pretty\" => mode_pretty,\n-      _ => fail ~\"invalid mode\"\n-    }\n-}\n-\n-fn mode_str(mode: mode) -> ~str {\n-    match mode {\n-      mode_compile_fail => ~\"compile-fail\",\n-      mode_run_fail => ~\"run-fail\",\n-      mode_run_pass => ~\"run-pass\",\n-      mode_pretty => ~\"pretty\"\n-    }\n-}\n-\n-fn run_tests(config: config) {\n-    let opts = test_opts(config);\n-    let tests = make_tests(config);\n-    let res = test::run_tests_console(&opts, tests);\n-    if !res { fail ~\"Some tests failed\"; }\n-}\n-\n-fn test_opts(config: config) -> test::TestOpts {\n-    {filter:\n-         match config.filter {\n-           option::Some(s) => option::Some(s),\n-           option::None => option::None\n-         },\n-     run_ignored: config.run_ignored,\n-     logfile:\n-         match config.logfile {\n-           option::Some(s) => option::Some(s.to_str()),\n-           option::None => option::None\n-         }\n-    }\n-}\n-\n-fn make_tests(config: config) -> ~[test::TestDesc] {\n-    debug!(\"making tests from %s\",\n-           config.src_base.to_str());\n-    let mut tests = ~[];\n-    for os::list_dir_path(&config.src_base).each |file| {\n-        let file = copy *file;\n-        debug!(\"inspecting file %s\", file.to_str());\n-        if is_test(config, file) {\n-            tests.push(make_test(config, file))\n-        }\n-    }\n-    move tests\n-}\n-\n-fn is_test(config: config, testfile: &Path) -> bool {\n-    // Pretty-printer does not work with .rc files yet\n-    let valid_extensions =\n-        match config.mode {\n-          mode_pretty => ~[~\".rs\"],\n-          _ => ~[~\".rc\", ~\".rs\"]\n-        };\n-    let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n-    let name = testfile.filename().get();\n-\n-    let mut valid = false;\n-\n-    for valid_extensions.each |ext| {\n-        if str::ends_with(name, *ext) { valid = true; }\n-    }\n-\n-    for invalid_prefixes.each |pre| {\n-        if str::starts_with(name, *pre) { valid = false; }\n-    }\n-\n-    return valid;\n-}\n-\n-fn make_test(config: config, testfile: &Path) ->\n-   test::TestDesc {\n-    {\n-        name: make_test_name(config, testfile),\n-        testfn: make_test_closure(config, testfile),\n-        ignore: header::is_test_ignored(config, testfile),\n-        should_fail: false\n-    }\n-}\n-\n-fn make_test_name(config: config, testfile: &Path) -> ~str {\n-    fmt!(\"[%s] %s\", mode_str(config.mode), testfile.to_str())\n-}\n-\n-fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n-    let testfile = testfile.to_str();\n-    fn~() { runtest::run(config, testfile) }\n-}\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "1d94318bef4865431093f1b82f4895cc5e288376", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 1979, "deletions": 0, "changes": 1979, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -36,3 +36,1982 @@ use core::*;\n \n #[legacy_exports]\n mod pgp;\n+\n+use syntax::{ast, codemap, parse, visit, attr};\n+use syntax::diagnostic::span_handler;\n+use codemap::span;\n+use rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest,\n+                                     get_cargo_sysroot, libdir};\n+use syntax::diagnostic;\n+\n+use result::{Ok, Err};\n+use io::WriterUtil;\n+use send_map::linear::LinearMap;\n+use std::{map, json, tempfile, term, sort, getopts};\n+use map::HashMap;\n+use to_str::to_str;\n+use getopts::{optflag, optopt, opt_present};\n+use dvec::DVec;\n+\n+struct Package {\n+    name: ~str,\n+    uuid: ~str,\n+    url: ~str,\n+    method: ~str,\n+    description: ~str,\n+    reference: Option<~str>,\n+    tags: ~[~str],\n+    versions: ~[(~str, ~str)]\n+}\n+\n+impl Package : cmp::Ord {\n+    #[cfg(stage0)]\n+    pure fn lt(other: &Package) -> bool {\n+        if self.name.lt(&(*other).name) { return true; }\n+        if (*other).name.lt(&self.name) { return false; }\n+        if self.uuid.lt(&(*other).uuid) { return true; }\n+        if (*other).uuid.lt(&self.uuid) { return false; }\n+        if self.url.lt(&(*other).url) { return true; }\n+        if (*other).url.lt(&self.url) { return false; }\n+        if self.method.lt(&(*other).method) { return true; }\n+        if (*other).method.lt(&self.method) { return false; }\n+        if self.description.lt(&(*other).description) { return true; }\n+        if (*other).description.lt(&self.description) { return false; }\n+        if self.tags.lt(&(*other).tags) { return true; }\n+        if (*other).tags.lt(&self.tags) { return false; }\n+        if self.versions.lt(&(*other).versions) { return true; }\n+        return false;\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &Package) -> bool {\n+        if (*self).name.lt(&(*other).name) { return true; }\n+        if (*other).name.lt(&(*self).name) { return false; }\n+        if (*self).uuid.lt(&(*other).uuid) { return true; }\n+        if (*other).uuid.lt(&(*self).uuid) { return false; }\n+        if (*self).url.lt(&(*other).url) { return true; }\n+        if (*other).url.lt(&(*self).url) { return false; }\n+        if (*self).method.lt(&(*other).method) { return true; }\n+        if (*other).method.lt(&(*self).method) { return false; }\n+        if (*self).description.lt(&(*other).description) { return true; }\n+        if (*other).description.lt(&(*self).description) { return false; }\n+        if (*self).tags.lt(&(*other).tags) { return true; }\n+        if (*other).tags.lt(&(*self).tags) { return false; }\n+        if (*self).versions.lt(&(*other).versions) { return true; }\n+        return false;\n+    }\n+    #[cfg(stage0)]\n+    pure fn le(other: &Package) -> bool { !(*other).lt(&self) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &Package) -> bool { !(*other).lt(&(*self)) }\n+    #[cfg(stage0)]\n+    pure fn ge(other: &Package) -> bool { !self.lt(other)     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &Package) -> bool { !(*self).lt(other)     }\n+    #[cfg(stage0)]\n+    pure fn gt(other: &Package) -> bool { (*other).lt(&self)  }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &Package) -> bool { (*other).lt(&(*self))  }\n+}\n+\n+struct Source {\n+    name: ~str,\n+    mut url: ~str,\n+    mut method: ~str,\n+    mut key: Option<~str>,\n+    mut keyfp: Option<~str>,\n+    packages: DVec<Package>\n+}\n+\n+struct Cargo {\n+    pgp: bool,\n+    root: Path,\n+    installdir: Path,\n+    bindir: Path,\n+    libdir: Path,\n+    workdir: Path,\n+    sourcedir: Path,\n+    sources: map::HashMap<~str, @Source>,\n+    mut current_install: ~str,\n+    dep_cache: map::HashMap<~str, bool>,\n+    opts: Options\n+}\n+\n+struct Crate {\n+    name: ~str,\n+    vers: ~str,\n+    uuid: ~str,\n+    desc: Option<~str>,\n+    sigs: Option<~str>,\n+    crate_type: Option<~str>,\n+    deps: ~[~str]\n+}\n+\n+struct Options {\n+    test: bool,\n+    mode: Mode,\n+    free: ~[~str],\n+    help: bool,\n+}\n+\n+enum Mode { SystemMode, UserMode, LocalMode }\n+\n+impl Mode : cmp::Eq {\n+    #[cfg(stage0)]\n+    pure fn eq(other: &Mode) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Mode) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n+    pure fn ne(other: &Mode) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Mode) -> bool { !(*self).eq(other) }\n+}\n+\n+fn opts() -> ~[getopts::Opt] {\n+    ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n+     optflag(~\"h\"), optflag(~\"help\")]\n+}\n+\n+fn info(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_green);\n+        out.write_str(~\"info: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    } else { out.write_line(~\"info: \" + msg); }\n+}\n+\n+fn warn(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_yellow);\n+        out.write_str(~\"warning: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    }else { out.write_line(~\"warning: \" + msg); }\n+}\n+\n+fn error(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_red);\n+        out.write_str(~\"error: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    }\n+    else { out.write_line(~\"error: \" + msg); }\n+}\n+\n+fn is_uuid(id: ~str) -> bool {\n+    let parts = str::split_str(id, ~\"-\");\n+    if vec::len(parts) == 5u {\n+        let mut correct = 0u;\n+        for vec::eachi(parts) |i, part| {\n+            fn is_hex_digit(+ch: char) -> bool {\n+                ('0' <= ch && ch <= '9') ||\n+                ('a' <= ch && ch <= 'f') ||\n+                ('A' <= ch && ch <= 'F')\n+            }\n+\n+            if !part.all(is_hex_digit) {\n+                return false;\n+            }\n+\n+            match i {\n+                0u => {\n+                    if part.len() == 8u {\n+                        correct += 1u;\n+                    }\n+                }\n+                1u | 2u | 3u => {\n+                    if part.len() == 4u {\n+                        correct += 1u;\n+                    }\n+                }\n+                4u => {\n+                    if part.len() == 12u {\n+                        correct += 1u;\n+                    }\n+                }\n+                _ => { }\n+            }\n+        }\n+        if correct >= 5u {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+#[test]\n+fn test_is_uuid() {\n+    assert is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaafAF09\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"\");\n+    assert !is_uuid(~\"aaaaaaaa-aaa -aaaa-aaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"aaaaaaaa-aaa!-aaaa-aaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa-a\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n+}\n+\n+// FIXME (#2661): implement url/URL parsing so we don't have to resort\n+// to weak checks\n+\n+fn has_archive_extension(p: ~str) -> bool {\n+    str::ends_with(p, ~\".tar\") ||\n+    str::ends_with(p, ~\".tar.gz\") ||\n+    str::ends_with(p, ~\".tar.bz2\") ||\n+    str::ends_with(p, ~\".tar.Z\") ||\n+    str::ends_with(p, ~\".tar.lz\") ||\n+    str::ends_with(p, ~\".tar.xz\") ||\n+    str::ends_with(p, ~\".tgz\") ||\n+    str::ends_with(p, ~\".tbz\") ||\n+    str::ends_with(p, ~\".tbz2\") ||\n+    str::ends_with(p, ~\".tb2\") ||\n+    str::ends_with(p, ~\".taz\") ||\n+    str::ends_with(p, ~\".tlz\") ||\n+    str::ends_with(p, ~\".txz\")\n+}\n+\n+fn is_archive_path(u: ~str) -> bool {\n+    has_archive_extension(u) && os::path_exists(&Path(u))\n+}\n+\n+fn is_archive_url(u: ~str) -> bool {\n+    // FIXME (#2661): this requires the protocol bit - if we had proper\n+    // url parsing, we wouldn't need it\n+\n+    match str::find_str(u, ~\"://\") {\n+        option::Some(_) => has_archive_extension(u),\n+        _ => false\n+    }\n+}\n+\n+fn is_git_url(url: ~str) -> bool {\n+    if str::ends_with(url, ~\"/\") { str::ends_with(url, ~\".git/\") }\n+    else {\n+        str::starts_with(url, ~\"git://\") || str::ends_with(url, ~\".git\")\n+    }\n+}\n+\n+fn assume_source_method(url: ~str) -> ~str {\n+    if is_git_url(url) {\n+        return ~\"git\";\n+    }\n+    if str::starts_with(url, ~\"file://\") || os::path_exists(&Path(url)) {\n+        return ~\"file\";\n+    }\n+\n+    ~\"curl\"\n+}\n+\n+fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                         Option<~str>,\n+                                         Option<~str>) {\n+    let mut name = None;\n+    let mut vers = None;\n+    let mut uuid = None;\n+    for mis.each |a| {\n+        match a.node {\n+            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n+                match v {\n+                    ~\"name\" => name = Some(*s),\n+                    ~\"vers\" => vers = Some(*s),\n+                    ~\"uuid\" => uuid = Some(*s),\n+                    _ => { }\n+                }\n+            }\n+            _ => fail ~\"load_link: meta items must be name-values\"\n+        }\n+    }\n+    (name, vers, uuid)\n+}\n+\n+fn load_crate(filename: &Path) -> Option<Crate> {\n+    let sess = parse::new_parse_sess(None);\n+    let c = parse::parse_crate_from_file(filename, ~[], sess);\n+\n+    let mut name = None;\n+    let mut vers = None;\n+    let mut uuid = None;\n+    let mut desc = None;\n+    let mut sigs = None;\n+    let mut crate_type = None;\n+\n+    for c.node.attrs.each |a| {\n+        match a.node.value.node {\n+            ast::meta_name_value(v, {node: ast::lit_str(_), span: _}) => {\n+                match v {\n+                    ~\"desc\" => desc = Some(v),\n+                    ~\"sigs\" => sigs = Some(v),\n+                    ~\"crate_type\" => crate_type = Some(v),\n+                    _ => { }\n+                }\n+            }\n+            ast::meta_list(v, mis) => {\n+                if v == ~\"link\" {\n+                    let (n, v, u) = load_link(mis);\n+                    name = n;\n+                    vers = v;\n+                    uuid = u;\n+                }\n+            }\n+            _ => {\n+                fail ~\"crate attributes may not contain \" +\n+                     ~\"meta_words\";\n+            }\n+        }\n+    }\n+\n+    type env = @{\n+        mut deps: ~[~str]\n+    };\n+\n+    fn goto_view_item(ps: syntax::parse::parse_sess, e: env,\n+                      i: @ast::view_item) {\n+        match i.node {\n+            ast::view_item_use(ident, metas, _) => {\n+                let name_items =\n+                    attr::find_meta_items_by_name(metas, ~\"name\");\n+                let m = if name_items.is_empty() {\n+                    metas + ~[attr::mk_name_value_item_str(\n+                        ~\"name\", *ps.interner.get(ident))]\n+                } else {\n+                    metas\n+                };\n+                let mut attr_name = ident;\n+                let mut attr_vers = ~\"\";\n+                let mut attr_from = ~\"\";\n+\n+              for m.each |item| {\n+                    match attr::get_meta_item_value_str(*item) {\n+                        Some(value) => {\n+                            let name = attr::get_meta_item_name(*item);\n+\n+                            match name {\n+                                ~\"vers\" => attr_vers = value,\n+                                ~\"from\" => attr_from = value,\n+                                _ => ()\n+                            }\n+                        }\n+                        None => ()\n+                    }\n+                }\n+\n+                let query = if !str::is_empty(attr_from) {\n+                    attr_from\n+                } else {\n+                    if !str::is_empty(attr_vers) {\n+                        ps.interner.get(attr_name) + ~\"@\" + attr_vers\n+                    } else { *ps.interner.get(attr_name) }\n+                };\n+\n+                match *ps.interner.get(attr_name) {\n+                    ~\"std\" | ~\"core\" => (),\n+                    _ => e.deps.push(query)\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+    fn goto_item(_e: env, _i: @ast::item) {\n+    }\n+\n+    let e = @{\n+        mut deps: ~[]\n+    };\n+    let v = visit::mk_simple_visitor(@{\n+        visit_view_item: |a| goto_view_item(sess, e, a),\n+        visit_item: |a| goto_item(e, a),\n+        .. *visit::default_simple_visitor()\n+    });\n+\n+    visit::visit_crate(*c, (), v);\n+\n+    let deps = copy e.deps;\n+\n+    match (name, vers, uuid) {\n+        (Some(name0), Some(vers0), Some(uuid0)) => {\n+            Some(Crate {\n+                name: name0,\n+                vers: vers0,\n+                uuid: uuid0,\n+                desc: desc,\n+                sigs: sigs,\n+                crate_type: crate_type,\n+                deps: deps })\n+        }\n+        _ => return None\n+    }\n+}\n+\n+fn print(s: ~str) {\n+    io::stdout().write_line(s);\n+}\n+\n+fn rest(s: ~str, start: uint) -> ~str {\n+    if (start >= str::len(s)) {\n+        ~\"\"\n+    } else {\n+        str::slice(s, start, str::len(s))\n+    }\n+}\n+\n+fn need_dir(s: &Path) {\n+    if os::path_is_dir(s) { return; }\n+    if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n+        fail fmt!(\"can't make_dir %s\", s.to_str());\n+    }\n+}\n+\n+fn valid_pkg_name(s: &str) -> bool {\n+    fn is_valid_digit(+c: char) -> bool {\n+        ('0' <= c && c <= '9') ||\n+        ('a' <= c && c <= 'z') ||\n+        ('A' <= c && c <= 'Z') ||\n+        c == '-' ||\n+        c == '_'\n+    }\n+\n+    s.all(is_valid_digit)\n+}\n+\n+fn parse_source(name: ~str, j: &json::Json) -> @Source {\n+    if !valid_pkg_name(name) {\n+        fail fmt!(\"'%s' is an invalid source name\", name);\n+    }\n+\n+    match *j {\n+        json::Object(j) => {\n+            let mut url = match j.find(&~\"url\") {\n+                Some(json::String(u)) => u,\n+                _ => fail ~\"needed 'url' field in source\"\n+            };\n+            let method = match j.find(&~\"method\") {\n+                Some(json::String(u)) => u,\n+                _ => assume_source_method(url)\n+            };\n+            let key = match j.find(&~\"key\") {\n+                Some(json::String(u)) => Some(u),\n+                _ => None\n+            };\n+            let keyfp = match j.find(&~\"keyfp\") {\n+                Some(json::String(u)) => Some(u),\n+                _ => None\n+            };\n+            if method == ~\"file\" {\n+                url = os::make_absolute(&Path(url)).to_str();\n+            }\n+            return @Source {\n+                name: name,\n+                mut url: url,\n+                mut method: method,\n+                mut key: key,\n+                mut keyfp: keyfp,\n+                packages: DVec() };\n+        }\n+        _ => fail ~\"needed dict value in source\"\n+    };\n+}\n+\n+fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n+    if !os::path_exists(filename)  { return; }\n+    let c = io::read_whole_file_str(filename);\n+    match json::from_str(c.get()) {\n+        Ok(json::Object(j)) => {\n+            for j.each |k, v| {\n+                sources.insert(copy *k, parse_source(*k, v));\n+                debug!(\"source: %s\", *k);\n+            }\n+        }\n+        Ok(_) => fail ~\"malformed sources.json\",\n+        Err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n+    }\n+}\n+\n+fn load_one_source_package(src: @Source, p: &json::Object) {\n+    let name = match p.find(&~\"name\") {\n+        Some(json::String(n)) => {\n+            if !valid_pkg_name(n) {\n+                warn(~\"malformed source json: \"\n+                     + src.name + ~\", '\" + n + ~\"'\"+\n+                     ~\" is an invalid name (alphanumeric, underscores and\" +\n+                     ~\" dashes only)\");\n+                return;\n+            }\n+            n\n+        }\n+        _ => {\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n+            return;\n+        }\n+    };\n+\n+    let uuid = match p.find(&~\"uuid\") {\n+        Some(json::String(n)) => {\n+            if !is_uuid(n) {\n+                warn(~\"malformed source json: \"\n+                     + src.name + ~\", '\" + n + ~\"'\"+\n+                     ~\" is an invalid uuid\");\n+                return;\n+            }\n+            n\n+        }\n+        _ => {\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n+            return;\n+        }\n+    };\n+\n+    let url = match p.find(&~\"url\") {\n+        Some(json::String(n)) => n,\n+        _ => {\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n+            return;\n+        }\n+    };\n+\n+    let method = match p.find(&~\"method\") {\n+        Some(json::String(n)) => n,\n+        _ => {\n+            warn(~\"malformed source json: \"\n+                 + src.name + ~\" (missing method)\");\n+            return;\n+        }\n+    };\n+\n+    let reference = match p.find(&~\"ref\") {\n+        Some(json::String(n)) => Some(n),\n+        _ => None\n+    };\n+\n+    let mut tags = ~[];\n+    match p.find(&~\"tags\") {\n+        Some(json::List(js)) => {\n+          for js.each |j| {\n+                match *j {\n+                    json::String(ref j) => tags.grow(1u, j),\n+                    _ => ()\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    let description = match p.find(&~\"description\") {\n+        Some(json::String(n)) => n,\n+        _ => {\n+            warn(~\"malformed source json: \" + src.name\n+                 + ~\" (missing description)\");\n+            return;\n+        }\n+    };\n+\n+    let newpkg = Package {\n+        name: name,\n+        uuid: uuid,\n+        url: url,\n+        method: method,\n+        description: description,\n+        reference: reference,\n+        tags: tags,\n+        versions: ~[]\n+    };\n+\n+    match src.packages.position(|pkg| pkg.uuid == uuid) {\n+        Some(idx) => {\n+            src.packages.set_elt(idx, newpkg);\n+            log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n+        }\n+        None => {\n+            src.packages.push(newpkg);\n+        }\n+    }\n+\n+    log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n+}\n+\n+fn load_source_info(c: &Cargo, src: @Source) {\n+    let dir = c.sourcedir.push(src.name);\n+    let srcfile = dir.push(\"source.json\");\n+    if !os::path_exists(&srcfile) { return; }\n+    let srcstr = io::read_whole_file_str(&srcfile);\n+    match json::from_str(srcstr.get()) {\n+        Ok(ref json @ json::Object(_)) => {\n+            let o = parse_source(src.name, json);\n+\n+            src.key = o.key;\n+            src.keyfp = o.keyfp;\n+        }\n+        Ok(_) => {\n+            warn(~\"malformed source.json: \" + src.name +\n+                 ~\"(source info is not a dict)\");\n+        }\n+        Err(e) => {\n+            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n+        }\n+    };\n+}\n+fn load_source_packages(c: &Cargo, src: @Source) {\n+    log(debug, ~\"loading source: \" + src.name);\n+    let dir = c.sourcedir.push(src.name);\n+    let pkgfile = dir.push(\"packages.json\");\n+    if !os::path_exists(&pkgfile) { return; }\n+    let pkgstr = io::read_whole_file_str(&pkgfile);\n+    match json::from_str(pkgstr.get()) {\n+        Ok(json::List(js)) => {\n+          for js.each |j| {\n+                match *j {\n+                    json::Object(p) => {\n+                        load_one_source_package(src, p);\n+                    }\n+                    _ => {\n+                        warn(~\"malformed source json: \" + src.name +\n+                             ~\" (non-dict pkg)\");\n+                    }\n+                }\n+            }\n+        }\n+        Ok(_) => {\n+            warn(~\"malformed packages.json: \" + src.name +\n+                 ~\"(packages is not a list)\");\n+        }\n+        Err(e) => {\n+            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n+        }\n+    };\n+}\n+\n+fn build_cargo_options(argv: ~[~str]) -> Options {\n+    let matches = match getopts::getopts(argv, opts()) {\n+        result::Ok(m) => m,\n+        result::Err(f) => {\n+            fail fmt!(\"%s\", getopts::fail_str(f));\n+        }\n+    };\n+\n+    let test = opt_present(matches, ~\"test\");\n+    let G    = opt_present(matches, ~\"G\");\n+    let g    = opt_present(matches, ~\"g\");\n+    let help = opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\");\n+    let len  = vec::len(matches.free);\n+\n+    let is_install = len > 1u && matches.free[1] == ~\"install\";\n+    let is_uninstall = len > 1u && matches.free[1] == ~\"uninstall\";\n+\n+    if G && g { fail ~\"-G and -g both provided\"; }\n+\n+    if !is_install && !is_uninstall && (g || G) {\n+        fail ~\"-g and -G are only valid for `install` and `uninstall|rm`\";\n+    }\n+\n+    let mode =\n+        if (!is_install && !is_uninstall) || g { UserMode }\n+        else if G { SystemMode }\n+        else { LocalMode };\n+\n+    Options {test: test, mode: mode, free: matches.free, help: help}\n+}\n+\n+fn configure(opts: Options) -> Cargo {\n+    let home = match get_cargo_root() {\n+        Ok(home) => home,\n+        Err(_err) => get_cargo_sysroot().get()\n+    };\n+\n+    let get_cargo_dir = match opts.mode {\n+        SystemMode => get_cargo_sysroot,\n+        UserMode => get_cargo_root,\n+        LocalMode => get_cargo_root_nearest\n+    };\n+\n+    let p = get_cargo_dir().get();\n+\n+    let sources = HashMap();\n+    try_parse_sources(&home.push(\"sources.json\"), sources);\n+    try_parse_sources(&home.push(\"local-sources.json\"), sources);\n+\n+    let dep_cache = HashMap();\n+\n+    let mut c = Cargo {\n+        pgp: pgp::supported(),\n+        root: home,\n+        installdir: p,\n+        bindir: p.push(\"bin\"),\n+        libdir: p.push(\"lib\"),\n+        workdir: p.push(\"work\"),\n+        sourcedir: home.push(\"sources\"),\n+        sources: sources,\n+        mut current_install: ~\"\",\n+        dep_cache: dep_cache,\n+        opts: opts\n+    };\n+\n+    need_dir(&c.root);\n+    need_dir(&c.installdir);\n+    need_dir(&c.sourcedir);\n+    need_dir(&c.workdir);\n+    need_dir(&c.libdir);\n+    need_dir(&c.bindir);\n+\n+    for sources.each_key |k| {\n+        let mut s = sources.get(k);\n+        load_source_packages(&c, s);\n+        sources.insert(k, s);\n+    }\n+\n+    if c.pgp {\n+        pgp::init(&c.root);\n+    } else {\n+        warn(~\"command `gpg` was not found\");\n+        warn(~\"you have to install gpg from source \" +\n+             ~\" or package manager to get it to work correctly\");\n+    }\n+\n+    move c\n+}\n+\n+fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n+    for c.sources.each_value |v| {\n+        for v.packages.each |p| {\n+            b(v, p);\n+        }\n+    }\n+}\n+\n+// Runs all programs in directory <buildpath>\n+fn run_programs(buildpath: &Path) {\n+    let newv = os::list_dir_path(buildpath);\n+    for newv.each |ct| {\n+        run::run_program(ct.to_str(), ~[]);\n+    }\n+}\n+\n+// Runs rustc in <path + subdir> with the given flags\n+// and returns <patho + subdir>\n+fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n+                    extra_flags: ~[~str]) -> Option<Path> {\n+    let buildpath = path.push_rel(subdir);\n+    need_dir(&buildpath);\n+    debug!(\"%s: %s -> %s\", what, cf.to_str(), buildpath.to_str());\n+    let p = run::program_output(rustc_sysroot(),\n+                                ~[~\"--out-dir\",\n+                                  buildpath.to_str(),\n+                                  cf.to_str()] + extra_flags);\n+    if p.status != 0 {\n+        error(fmt!(\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out));\n+        return None;\n+    }\n+    Some(buildpath)\n+}\n+\n+fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n+    let buildpath = match run_in_buildpath(~\"testing\", path,\n+                                           &Path(\"test\"),\n+                                           cf,\n+                                           ~[ ~\"--test\"]) {\n+      None => return,\n+    Some(bp) => bp\n+  };\n+  run_programs(&buildpath);\n+}\n+\n+fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n+    let buildpath = match run_in_buildpath(~\"installing\", path,\n+                                           &Path(\"build\"),\n+                                           cf, ~[]) {\n+      None => return,\n+      Some(bp) => bp\n+    };\n+    let newv = os::list_dir_path(&buildpath);\n+    let exec_suffix = os::exe_suffix();\n+    for newv.each |ct| {\n+        if (exec_suffix != ~\"\" && str::ends_with(ct.to_str(),\n+                                                 exec_suffix)) ||\n+            (exec_suffix == ~\"\" &&\n+             !str::starts_with(ct.filename().get(),\n+                               ~\"lib\")) {\n+            debug!(\"  bin: %s\", ct.to_str());\n+            install_to_dir(*ct, &c.bindir);\n+            if c.opts.mode == SystemMode {\n+                // FIXME (#2662): Put this file in PATH / symlink it so it can\n+                // be used as a generic executable\n+                // `cargo install -G rustray` and `rustray file.obj`\n+            }\n+        } else {\n+            debug!(\"  lib: %s\", ct.to_str());\n+            install_to_dir(*ct, &c.libdir);\n+        }\n+    }\n+}\n+\n+\n+fn rustc_sysroot() -> ~str {\n+    match os::self_exe_path() {\n+        Some(path) => {\n+            let rustc = path.push_many([~\"..\", ~\"bin\", ~\"rustc\"]);\n+            debug!(\"  rustc: %s\", rustc.to_str());\n+            rustc.to_str()\n+        }\n+        None => ~\"rustc\"\n+    }\n+}\n+\n+fn install_source(c: &Cargo, path: &Path) {\n+    debug!(\"source: %s\", path.to_str());\n+    os::change_dir(path);\n+\n+    let mut cratefiles = ~[];\n+    for os::walk_dir(&Path(\".\")) |p| {\n+        if p.filetype() == Some(~\".rc\") {\n+            cratefiles.push(*p);\n+        }\n+    }\n+\n+    if vec::is_empty(cratefiles) {\n+        fail ~\"this doesn't look like a rust package (no .rc files)\";\n+    }\n+\n+    for cratefiles.each |cf| {\n+        match load_crate(cf) {\n+            None => loop,\n+            Some(crate) => {\n+              for crate.deps.each |query| {\n+                    // FIXME (#1356): handle cyclic dependencies\n+                    // (n.b. #1356 says \"Cyclic dependency is an error\n+                    // condition\")\n+\n+                    let wd = get_temp_workdir(c);\n+                    install_query(c, &wd, *query);\n+                }\n+\n+                os::change_dir(path);\n+\n+                if c.opts.test {\n+                    test_one_crate(c, path, cf);\n+                }\n+                install_one_crate(c, path, cf);\n+            }\n+        }\n+    }\n+}\n+\n+fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n+    run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n+    if reference.is_some() {\n+        let r = reference.get();\n+        os::change_dir(wd);\n+        run::run_program(~\"git\", ~[~\"checkout\", r]);\n+    }\n+\n+    install_source(c, wd);\n+}\n+\n+fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n+    let tarpath = wd.push(\"pkg.tar\");\n+    let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n+                                         tarpath.to_str(), url]);\n+    if p.status != 0 {\n+        fail fmt!(\"fetch of %s failed: %s\", url, p.err);\n+    }\n+    run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n+                               ~\"-C\", wd.to_str(),\n+                               ~\"-f\", tarpath.to_str()]);\n+    install_source(c, wd);\n+}\n+\n+fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n+    run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n+                                  ~\"-C\", wd.to_str(),\n+                                  ~\"-f\", path.to_str()]);\n+    install_source(c, wd);\n+}\n+\n+fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n+    let url = copy pkg.url;\n+    let method = match pkg.method {\n+        ~\"git\" => ~\"git\",\n+        ~\"file\" => ~\"file\",\n+        _ => ~\"curl\"\n+    };\n+\n+    info(fmt!(\"installing %s/%s via %s...\", src, pkg.name, method));\n+\n+    match method {\n+        ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n+        ~\"file\" => install_file(c, wd, &Path(url)),\n+        ~\"curl\" => install_curl(c, wd, url),\n+        _ => ()\n+    }\n+}\n+\n+fn cargo_suggestion(c: &Cargo, fallback: fn())\n+{\n+    if c.sources.size() == 0u {\n+        error(~\"no sources defined - you may wish to run \" +\n+              ~\"`cargo init`\");\n+        return;\n+    }\n+    fallback();\n+}\n+\n+fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n+    let mut ps = ~[];\n+    for_each_package(c, |s, p| {\n+        if p.uuid == uuid {\n+            vec::push(&mut ps, (s.name, copy *p));\n+        }\n+    });\n+    if vec::len(ps) == 1u {\n+        let (sname, p) = copy ps[0];\n+        install_package(c, sname, wd, p);\n+        return;\n+    } else if vec::len(ps) == 0u {\n+        cargo_suggestion(c, || {\n+            error(~\"can't find package: \" + uuid);\n+        });\n+        return;\n+    }\n+    error(~\"found multiple packages:\");\n+    for ps.each |elt| {\n+        let (sname,p) = copy *elt;\n+        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n+    }\n+}\n+\n+fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n+    let mut ps = ~[];\n+    for_each_package(c, |s, p| {\n+        if p.name == name {\n+            vec::push(&mut ps, (s.name, copy *p));\n+        }\n+    });\n+    if vec::len(ps) == 1u {\n+        let (sname, p) = copy ps[0];\n+        install_package(c, sname, wd, p);\n+        return;\n+    } else if vec::len(ps) == 0u {\n+        cargo_suggestion(c, || {\n+            error(~\"can't find package: \" + name);\n+        });\n+        return;\n+    }\n+    error(~\"found multiple packages:\");\n+    for ps.each |elt| {\n+        let (sname,p) = copy *elt;\n+        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n+    }\n+}\n+\n+fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n+    match c.sources.find(src) {\n+        Some(s) => {\n+            for s.packages.each |p| {\n+                if p.uuid == uuid {\n+                    install_package(c, src, wd, *p);\n+                    return;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+    error(~\"can't find package: \" + src + ~\"/\" + uuid);\n+}\n+\n+fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n+    match c.sources.find(src) {\n+        Some(s) => {\n+            for s.packages.each |p| {\n+                if p.name == name {\n+                    install_package(c, src, wd, *p);\n+                    return;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+    error(~\"can't find package: \" + src + ~\"/\" + name);\n+}\n+\n+fn cmd_uninstall(c: &Cargo) {\n+    if vec::len(c.opts.free) < 3u {\n+        cmd_usage();\n+        return;\n+    }\n+\n+    let lib = &c.libdir;\n+    let bin = &c.bindir;\n+    let target = c.opts.free[2u];\n+\n+    // FIXME (#2662): needs stronger pattern matching\n+    // FIXME (#2662): needs to uninstall from a specified location in a\n+    // cache instead of looking for it (binaries can be uninstalled by\n+    // name only)\n+\n+    fn try_uninstall(p: &Path) -> bool {\n+        if os::remove_file(p) {\n+            info(~\"uninstalled: '\" + p.to_str() + ~\"'\");\n+            true\n+        } else {\n+            error(~\"could not uninstall: '\" +\n+                  p.to_str() + ~\"'\");\n+            false\n+        }\n+    }\n+\n+    if is_uuid(target) {\n+        for os::list_dir(lib).each |file| {\n+            match str::find_str(*file, ~\"-\" + target + ~\"-\") {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n+              None => ()\n+            }\n+        }\n+        error(~\"can't find package with uuid: \" + target);\n+    } else {\n+        for os::list_dir(lib).each |file| {\n+            match str::find_str(*file, ~\"lib\" + target + ~\"-\") {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n+              None => ()\n+            }\n+        }\n+        for os::list_dir(bin).each |file| {\n+            match str::find_str(*file, target) {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n+              None => ()\n+            }\n+        }\n+\n+        error(~\"can't find package with name: \" + target);\n+    }\n+}\n+\n+fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n+    match c.dep_cache.find(target) {\n+        Some(inst) => {\n+            if inst {\n+                return;\n+            }\n+        }\n+        None => ()\n+    }\n+\n+    c.dep_cache.insert(target, true);\n+\n+    if is_archive_path(target) {\n+        install_file(c, wd, &Path(target));\n+        return;\n+    } else if is_git_url(target) {\n+        let reference = if c.opts.free.len() >= 4u {\n+            Some(c.opts.free[3u])\n+        } else {\n+            None\n+        };\n+        install_git(c, wd, target, reference);\n+    } else if !valid_pkg_name(target) && has_archive_extension(target) {\n+        install_curl(c, wd, target);\n+        return;\n+    } else {\n+        let mut ps = copy target;\n+\n+        match str::find_char(ps, '/') {\n+            option::Some(idx) => {\n+                let source = str::slice(ps, 0u, idx);\n+                ps = str::slice(ps, idx + 1u, str::len(ps));\n+                if is_uuid(ps) {\n+                    install_uuid_specific(c, wd, source, ps);\n+                } else {\n+                    install_named_specific(c, wd, source, ps);\n+                }\n+            }\n+            option::None => {\n+                if is_uuid(ps) {\n+                    install_uuid(c, wd, ps);\n+                } else {\n+                    install_named(c, wd, ps);\n+                }\n+            }\n+        }\n+    }\n+\n+    // FIXME (#2662): This whole dep_cache and current_install thing is\n+    // a bit of a hack. It should be cleaned up in the future.\n+\n+    if target == c.current_install {\n+        for c.dep_cache.each |k, _v| {\n+            c.dep_cache.remove(k);\n+        }\n+\n+        c.current_install = ~\"\";\n+    }\n+}\n+\n+fn get_temp_workdir(c: &Cargo) -> Path {\n+    match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n+      Some(wd) => wd,\n+      None => fail fmt!(\"needed temp dir: %s\",\n+                        c.workdir.to_str())\n+    }\n+}\n+\n+fn cmd_install(c: &Cargo) unsafe {\n+    let wd = get_temp_workdir(c);\n+\n+    if vec::len(c.opts.free) == 2u {\n+        let cwd = os::getcwd();\n+        let status = run::run_program(~\"cp\", ~[~\"-R\", cwd.to_str(),\n+                                               wd.to_str()]);\n+\n+        if status != 0 {\n+            fail fmt!(\"could not copy directory: %s\", cwd.to_str());\n+        }\n+\n+        install_source(c, &wd);\n+        return;\n+    }\n+\n+    sync(c);\n+\n+    let query = c.opts.free[2];\n+    c.current_install = query.to_str();\n+\n+    install_query(c, &wd, query);\n+}\n+\n+fn sync(c: &Cargo) {\n+    for c.sources.each_key |k| {\n+        let mut s = c.sources.get(k);\n+        sync_one(c, s);\n+        c.sources.insert(k, s);\n+    }\n+}\n+\n+fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+    let name = src.name;\n+    let srcfile = dir.push(\"source.json.new\");\n+    let destsrcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json.new\");\n+    let destpkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n+    let url = Path(src.url);\n+    let mut has_src_file = false;\n+\n+    if !os::copy_file(&url.push(\"packages.json\"), &pkgfile) {\n+        error(fmt!(\"fetch for source %s (url %s) failed\",\n+                   name, url.to_str()));\n+        return false;\n+    }\n+\n+    if os::copy_file(&url.push(\"source.json\"), &srcfile) {\n+        has_src_file = false;\n+    }\n+\n+    os::copy_file(&url.push(\"source.json.sig\"), &srcsigfile);\n+    os::copy_file(&url.push(\"packages.json.sig\"), &sigfile);\n+\n+    match copy src.key {\n+        Some(u) => {\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n+            if p.status != 0 {\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n+                return false;\n+            }\n+            pgp::add(&c.root, &keyfile);\n+        }\n+        _ => ()\n+    }\n+    match (src.key, src.keyfp) {\n+        (Some(_), Some(f)) => {\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n+\n+            if !r {\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n+                return false;\n+            }\n+\n+            if has_src_file {\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n+\n+                if !e {\n+                    error(fmt!(\"signature verification failed for source %s \\\n+                                with key %s\", name, f));\n+                    return false;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    copy_warn(&pkgfile, &destpkgfile);\n+\n+    if has_src_file {\n+        copy_warn(&srcfile, &destsrcfile);\n+    }\n+\n+    os::remove_file(&keyfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&srcsigfile);\n+    os::remove_file(&pkgfile);\n+    os::remove_file(&sigfile);\n+\n+    info(fmt!(\"synced source: %s\", name));\n+\n+    return true;\n+}\n+\n+fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+    let name = src.name;\n+    let srcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n+    let url = src.url;\n+\n+    fn rollback(name: ~str, dir: &Path, insecure: bool) {\n+        fn msg(name: ~str, insecure: bool) {\n+            error(fmt!(\"could not rollback source: %s\", name));\n+\n+            if insecure {\n+                warn(~\"a past security check failed on source \" +\n+                     name + ~\" and rolling back the source failed -\"\n+                     + ~\" this source may be compromised\");\n+            }\n+        }\n+\n+        if !os::change_dir(dir) {\n+            msg(name, insecure);\n+        }\n+        else {\n+            let p = run::program_output(~\"git\", ~[~\"reset\", ~\"--hard\",\n+                                                ~\"HEAD@{1}\"]);\n+\n+            if p.status != 0 {\n+                msg(name, insecure);\n+            }\n+        }\n+    }\n+\n+    if !os::path_exists(&dir.push(\".git\")) {\n+        let p = run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]);\n+\n+        if p.status != 0 {\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+            return false;\n+        }\n+    }\n+    else {\n+        if !os::change_dir(dir) {\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+            return false;\n+        }\n+\n+        let p = run::program_output(~\"git\", ~[~\"pull\"]);\n+\n+        if p.status != 0 {\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+            return false;\n+        }\n+    }\n+\n+    let has_src_file = os::path_exists(&srcfile);\n+\n+    match copy src.key {\n+        Some(u) => {\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n+            if p.status != 0 {\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n+                rollback(name, dir, false);\n+                return false;\n+            }\n+            pgp::add(&c.root, &keyfile);\n+        }\n+        _ => ()\n+    }\n+    match (src.key, src.keyfp) {\n+        (Some(_), Some(f)) => {\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n+\n+            if !r {\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n+                rollback(name, dir, false);\n+                return false;\n+            }\n+\n+            if has_src_file {\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n+\n+                if !e {\n+                    error(fmt!(\"signature verification failed for source %s \\\n+                                with key %s\", name, f));\n+                    rollback(name, dir, false);\n+                    return false;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    os::remove_file(&keyfile);\n+\n+    info(fmt!(\"synced source: %s\", name));\n+\n+    return true;\n+}\n+\n+fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+    let name = src.name;\n+    let srcfile = dir.push(\"source.json.new\");\n+    let destsrcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json.new\");\n+    let destpkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n+    let mut url = src.url;\n+    let smart = !str::ends_with(src.url, ~\"packages.json\");\n+    let mut has_src_file = false;\n+\n+    if smart {\n+        url += ~\"/packages.json\";\n+    }\n+\n+    let p = run::program_output(~\"curl\",\n+                                ~[~\"-f\", ~\"-s\",\n+                                  ~\"-o\", pkgfile.to_str(), url]);\n+\n+    if p.status != 0 {\n+        error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+        return false;\n+    }\n+    if smart {\n+        url = src.url + ~\"/source.json\";\n+        let p =\n+            run::program_output(~\"curl\",\n+                                ~[~\"-f\", ~\"-s\",\n+                                  ~\"-o\", srcfile.to_str(), url]);\n+\n+        if p.status == 0 {\n+            has_src_file = true;\n+        }\n+    }\n+\n+    match copy src.key {\n+       Some(u) => {\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n+            if p.status != 0 {\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n+                return false;\n+            }\n+            pgp::add(&c.root, &keyfile);\n+        }\n+        _ => ()\n+    }\n+    match (src.key, src.keyfp) {\n+        (Some(_), Some(f)) => {\n+            if smart {\n+                url = src.url + ~\"/packages.json.sig\";\n+            }\n+            else {\n+                url = src.url + ~\".sig\";\n+            }\n+\n+            let mut p = run::program_output(~\"curl\",\n+                                            ~[~\"-f\", ~\"-s\", ~\"-o\",\n+                                              sigfile.to_str(), url]);\n+            if p.status != 0 {\n+                error(fmt!(\"fetch for source %s (sig %s) failed\", name, url));\n+                return false;\n+            }\n+\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n+\n+            if !r {\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n+                return false;\n+            }\n+\n+            if smart && has_src_file {\n+                url = src.url + ~\"/source.json.sig\";\n+\n+                p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\", ~\"-o\",\n+                                          srcsigfile.to_str(), url]);\n+                if p.status != 0 {\n+                    error(fmt!(\"fetch for source %s (sig %s) failed\",\n+                          name, url));\n+                    return false;\n+                }\n+\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n+\n+                if !e {\n+                    error(~\"signature verification failed for \" +\n+                          ~\"source \" + name + ~\" with key \" + f);\n+                    return false;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    copy_warn(&pkgfile, &destpkgfile);\n+\n+    if smart && has_src_file {\n+        copy_warn(&srcfile, &destsrcfile);\n+    }\n+\n+    os::remove_file(&keyfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&srcsigfile);\n+    os::remove_file(&pkgfile);\n+    os::remove_file(&sigfile);\n+\n+    info(fmt!(\"synced source: %s\", name));\n+\n+    return true;\n+}\n+\n+fn sync_one(c: &Cargo, src: @Source) {\n+    let name = src.name;\n+    let dir = c.sourcedir.push(name);\n+\n+    info(fmt!(\"syncing source: %s...\", name));\n+\n+    need_dir(&dir);\n+\n+    let result = match src.method {\n+        ~\"git\" => sync_one_git(c, &dir, src),\n+        ~\"file\" => sync_one_file(c, &dir, src),\n+        _ => sync_one_curl(c, &dir, src)\n+    };\n+\n+    if result {\n+        load_source_info(c, src);\n+        load_source_packages(c, src);\n+    }\n+}\n+\n+fn cmd_init(c: &Cargo) {\n+    let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n+    let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n+\n+    let srcfile = c.root.push(\"sources.json.new\");\n+    let sigfile = c.root.push(\"sources.json.sig\");\n+    let destsrcfile = c.root.push(\"sources.json\");\n+\n+    let p =\n+        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n+                                       ~\"-o\", srcfile.to_str(), srcurl]);\n+    if p.status != 0 {\n+        error(fmt!(\"fetch of sources.json failed: %s\", p.out));\n+        return;\n+    }\n+\n+    let p =\n+        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n+                                       ~\"-o\", sigfile.to_str(), sigurl]);\n+    if p.status != 0 {\n+        error(fmt!(\"fetch of sources.json.sig failed: %s\", p.out));\n+        return;\n+    }\n+\n+    let r = pgp::verify(&c.root, &srcfile, &sigfile);\n+    if !r {\n+        error(fmt!(\"signature verification failed for '%s'\",\n+                   srcfile.to_str()));\n+        return;\n+    }\n+\n+    copy_warn(&srcfile, &destsrcfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&sigfile);\n+\n+    info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n+}\n+\n+fn print_pkg(s: @Source, p: &Package) {\n+    let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n+    if vec::len(p.tags) > 0u {\n+        m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n+    }\n+    info(m);\n+    if p.description != ~\"\" {\n+        print(~\"   >> \" + p.description + ~\"\\n\")\n+    }\n+}\n+\n+fn print_source(s: @Source) {\n+    info(s.name + ~\" (\" + s.url + ~\")\");\n+\n+    let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n+    let l = vec::len(pks);\n+\n+    print(io::with_str_writer(|writer| {\n+        let mut list = ~\"   >> \";\n+\n+        for vec::eachi(pks) |i, pk| {\n+            if str::len(list) > 78u {\n+                writer.write_line(list);\n+                list = ~\"   >> \";\n+            }\n+            list += pk.name + (if l - 1u == i { ~\"\" } else { ~\", \" });\n+        }\n+\n+        writer.write_line(list);\n+    }));\n+}\n+\n+fn cmd_list(c: &Cargo) {\n+    sync(c);\n+\n+    if vec::len(c.opts.free) >= 3u {\n+        let v = vec::view(c.opts.free, 2u, vec::len(c.opts.free));\n+        for vec::each(v) |name| {\n+            if !valid_pkg_name(*name) {\n+                error(fmt!(\"'%s' is an invalid source name\", *name));\n+            } else {\n+                match c.sources.find(*name) {\n+                    Some(source) => {\n+                        print_source(source);\n+                    }\n+                    None => {\n+                        error(fmt!(\"no such source: %s\", *name));\n+                    }\n+                }\n+            }\n+        }\n+    } else {\n+        for c.sources.each_value |v| {\n+            print_source(v);\n+        }\n+    }\n+}\n+\n+fn cmd_search(c: &Cargo) {\n+    if vec::len(c.opts.free) < 3u {\n+        cmd_usage();\n+        return;\n+    }\n+\n+    sync(c);\n+\n+    let mut n = 0;\n+    let name = c.opts.free[2];\n+    let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n+    for_each_package(c, |s, p| {\n+        if (str::contains(p.name, name) || name == ~\"*\") &&\n+            vec::all(tags, |t| vec::contains(p.tags, t) ) {\n+            print_pkg(s, p);\n+            n += 1;\n+        }\n+    });\n+    info(fmt!(\"found %d packages\", n));\n+}\n+\n+fn install_to_dir(srcfile: &Path, destdir: &Path) {\n+    let newfile = destdir.push(srcfile.filename().get());\n+\n+    let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile.to_str(),\n+                                           newfile.to_str()]);\n+    if status == 0 {\n+        info(fmt!(\"installed: '%s'\", newfile.to_str()));\n+    } else {\n+        error(fmt!(\"could not install: '%s'\", newfile.to_str()));\n+    }\n+}\n+\n+fn dump_cache(c: &Cargo) {\n+    need_dir(&c.root);\n+\n+    let out = c.root.push(\"cache.json\");\n+    let _root = json::Object(~LinearMap());\n+\n+    if os::path_exists(&out) {\n+        copy_warn(&out, &c.root.push(\"cache.json.old\"));\n+    }\n+}\n+fn dump_sources(c: &Cargo) {\n+    if c.sources.size() < 1u {\n+        return;\n+    }\n+\n+    need_dir(&c.root);\n+\n+    let out = c.root.push(\"sources.json\");\n+\n+    if os::path_exists(&out) {\n+        copy_warn(&out, &c.root.push(\"sources.json.old\"));\n+    }\n+\n+    match io::buffered_file_writer(&out) {\n+        result::Ok(writer) => {\n+            let mut hash = ~LinearMap();\n+\n+            for c.sources.each |k, v| {\n+                let mut chash = ~LinearMap();\n+\n+                chash.insert(~\"url\", json::String(v.url));\n+                chash.insert(~\"method\", json::String(v.method));\n+\n+                match copy v.key {\n+                    Some(key) => {\n+                        chash.insert(~\"key\", json::String(copy key));\n+                    }\n+                    _ => ()\n+                }\n+                match copy v.keyfp {\n+                    Some(keyfp) => {\n+                        chash.insert(~\"keyfp\", json::String(copy keyfp));\n+                    }\n+                    _ => ()\n+                }\n+\n+                hash.insert(copy k, json::Object(move chash));\n+            }\n+\n+            json::to_writer(writer, &json::Object(move hash))\n+        }\n+        result::Err(e) => {\n+            error(fmt!(\"could not dump sources: %s\", e));\n+        }\n+    }\n+}\n+\n+fn copy_warn(srcfile: &Path, destfile: &Path) {\n+    if !os::copy_file(srcfile, destfile) {\n+        warn(fmt!(\"copying %s to %s failed\",\n+                  srcfile.to_str(), destfile.to_str()));\n+    }\n+}\n+\n+fn cmd_sources(c: &Cargo) {\n+    if vec::len(c.opts.free) < 3u {\n+        for c.sources.each_value |v| {\n+            info(fmt!(\"%s (%s) via %s\",\n+                      v.name, v.url, v.method));\n+        }\n+        return;\n+    }\n+\n+    let action = c.opts.free[2u];\n+\n+    match action {\n+        ~\"clear\" => {\n+          for c.sources.each_key |k| {\n+                c.sources.remove(k);\n+            }\n+\n+            info(~\"cleared sources\");\n+        }\n+        ~\"add\" => {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let url = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+\n+            if c.sources.contains_key(name) {\n+                error(fmt!(\"source already exists: %s\", name));\n+            } else {\n+                c.sources.insert(name, @Source {\n+                    name: name,\n+                    mut url: url,\n+                    mut method: assume_source_method(url),\n+                    mut key: None,\n+                    mut keyfp: None,\n+                    packages: DVec()\n+                });\n+                info(fmt!(\"added source: %s\", name));\n+            }\n+        }\n+        ~\"remove\" => {\n+            if vec::len(c.opts.free) < 4u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+\n+            if c.sources.contains_key(name) {\n+                c.sources.remove(name);\n+                info(fmt!(\"removed source: %s\", name));\n+            } else {\n+                error(fmt!(\"no such source: %s\", name));\n+            }\n+        }\n+        ~\"set-url\" => {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let url = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+\n+            match c.sources.find(name) {\n+                Some(source) => {\n+                    let old = copy source.url;\n+                    let method = assume_source_method(url);\n+\n+                    source.url = url;\n+                    source.method = method;\n+\n+                    c.sources.insert(name, source);\n+\n+                    info(fmt!(\"changed source url: '%s' to '%s'\", old, url));\n+                }\n+                None => {\n+                    error(fmt!(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        ~\"set-method\" => {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let method = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+\n+            match c.sources.find(name) {\n+                Some(source) => {\n+                    let old = copy source.method;\n+\n+                    source.method = match method {\n+                        ~\"git\" => ~\"git\",\n+                        ~\"file\" => ~\"file\",\n+                        _ => ~\"curl\"\n+                    };\n+\n+                    c.sources.insert(name, source);\n+\n+                    info(fmt!(\"changed source method: '%s' to '%s'\", old,\n+                         method));\n+                }\n+                None => {\n+                    error(fmt!(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        ~\"rename\" => {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let newn = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+            if !valid_pkg_name(newn) {\n+                error(fmt!(\"'%s' is an invalid source name\", newn));\n+                return;\n+            }\n+\n+            match c.sources.find(name) {\n+                Some(source) => {\n+                    c.sources.remove(name);\n+                    c.sources.insert(newn, source);\n+                    info(fmt!(\"renamed source: %s to %s\", name, newn));\n+                }\n+                None => {\n+                    error(fmt!(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        _ => cmd_usage()\n+    }\n+}\n+\n+fn cmd_usage() {\n+    print(~\"Usage: cargo <cmd> [options] [args..]\n+e.g. cargo install <name>\n+\n+Where <cmd> is one of:\n+    init, install, list, search, sources,\n+    uninstall, usage\n+\n+Options:\n+\n+    -h, --help                  Display this message\n+    <cmd> -h, <cmd> --help      Display help for <cmd>\n+\");\n+}\n+\n+fn cmd_usage_init() {\n+    print(~\"cargo init\n+\n+Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n+default sources from <www.rust-lang.org/sources.json>.\");\n+}\n+\n+fn cmd_usage_install() {\n+    print(~\"cargo install\n+cargo install [source/]<name>[@version]\n+cargo install [source/]<uuid>[@version]\n+cargo install <git url> [ref]\n+cargo install <tarball url>\n+cargo install <tarball file>\n+\n+Options:\n+    --test      Run crate tests before installing\n+    -g          Install to the user level (~/.cargo/bin/ instead of\n+                locally in ./.cargo/bin/ by default)\n+    -G          Install to the system level (/usr/local/lib/cargo/bin/)\n+\n+Install a crate. If no arguments are supplied, it installs from\n+the current working directory. If a source is provided, only install\n+from that source, otherwise it installs from any source.\");\n+}\n+\n+fn cmd_usage_uninstall() {\n+    print(~\"cargo uninstall [source/]<name>[@version]\n+cargo uninstall [source/]<uuid>[@version]\n+cargo uninstall <meta-name>[@version]\n+cargo uninstall <meta-uuid>[@version]\n+\n+Options:\n+    -g          Remove from the user level (~/.cargo/bin/ instead of\n+                locally in ./.cargo/bin/ by default)\n+    -G          Remove from the system level (/usr/local/lib/cargo/bin/)\n+\n+Remove a crate. If a source is provided, only remove\n+from that source, otherwise it removes from any source.\n+If a crate was installed directly (git, tarball, etc.), you can remove\n+it by metadata.\");\n+}\n+\n+fn cmd_usage_list() {\n+    print(~\"cargo list [sources..]\n+\n+If no arguments are provided, list all sources and their packages.\n+If source names are provided, list those sources and their packages.\n+\");\n+}\n+\n+fn cmd_usage_search() {\n+    print(~\"cargo search <query | '*'> [tags..]\n+\n+Search packages.\");\n+}\n+\n+fn cmd_usage_sources() {\n+    print(~\"cargo sources\n+cargo sources add <name> <url>\n+cargo sources remove <name>\n+cargo sources rename <name> <new>\n+cargo sources set-url <name> <url>\n+cargo sources set-method <name> <method>\n+\n+If no arguments are supplied, list all sources (but not their packages).\n+\n+Commands:\n+    add             Add a source. The source method will be guessed\n+                    from the URL.\n+    remove          Remove a source.\n+    rename          Rename a source.\n+    set-url         Change the URL for a source.\n+    set-method      Change the method for a source.\");\n+}\n+\n+fn main() {\n+    let argv = os::args();\n+    let o = build_cargo_options(argv);\n+\n+    if vec::len(o.free) < 2u {\n+        cmd_usage();\n+        return;\n+    }\n+    if o.help {\n+        match o.free[1] {\n+            ~\"init\" => cmd_usage_init(),\n+            ~\"install\" => cmd_usage_install(),\n+            ~\"uninstall\" => cmd_usage_uninstall(),\n+            ~\"list\" => cmd_usage_list(),\n+            ~\"search\" => cmd_usage_search(),\n+            ~\"sources\" => cmd_usage_sources(),\n+            _ => cmd_usage()\n+        }\n+        return;\n+    }\n+    if o.free[1] == ~\"usage\" {\n+        cmd_usage();\n+        return;\n+    }\n+\n+    let mut c = configure(o);\n+    let home = c.root;\n+    let first_time = os::path_exists(&home.push(\"sources.json\"));\n+\n+    if !first_time && o.free[1] != ~\"init\" {\n+        cmd_init(&c);\n+\n+        // FIXME (#2662): shouldn't need to reconfigure\n+        c = configure(o);\n+    }\n+\n+    let c = &move c;\n+\n+    match o.free[1] {\n+        ~\"init\" => cmd_init(c),\n+        ~\"install\" => cmd_install(c),\n+        ~\"uninstall\" => cmd_uninstall(c),\n+        ~\"list\" => cmd_list(c),\n+        ~\"search\" => cmd_search(c),\n+        ~\"sources\" => cmd_sources(c),\n+        _ => cmd_usage()\n+    }\n+\n+    dump_cache(c);\n+    dump_sources(c);\n+}"}, {"sha": "f05ccfffa8a80e00cf8bdf24f0520815eaf83a65", "filename": "src/libcargo/cargo.rs", "status": "removed", "additions": 0, "deletions": 1982, "changes": 1982, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Flibcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Flibcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,1982 +0,0 @@\n-// cargo.rs - Rust package manager\n-\n-#[legacy_exports];\n-\n-use syntax::{ast, codemap, parse, visit, attr};\n-use syntax::diagnostic::span_handler;\n-use codemap::span;\n-use rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest,\n-                                     get_cargo_sysroot, libdir};\n-use syntax::diagnostic;\n-\n-use result::{Ok, Err};\n-use io::WriterUtil;\n-use send_map::linear::LinearMap;\n-use std::{map, json, tempfile, term, sort, getopts};\n-use map::HashMap;\n-use to_str::to_str;\n-use getopts::{optflag, optopt, opt_present};\n-use dvec::DVec;\n-\n-struct Package {\n-    name: ~str,\n-    uuid: ~str,\n-    url: ~str,\n-    method: ~str,\n-    description: ~str,\n-    reference: Option<~str>,\n-    tags: ~[~str],\n-    versions: ~[(~str, ~str)]\n-}\n-\n-impl Package : cmp::Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &Package) -> bool {\n-        if self.name.lt(&(*other).name) { return true; }\n-        if (*other).name.lt(&self.name) { return false; }\n-        if self.uuid.lt(&(*other).uuid) { return true; }\n-        if (*other).uuid.lt(&self.uuid) { return false; }\n-        if self.url.lt(&(*other).url) { return true; }\n-        if (*other).url.lt(&self.url) { return false; }\n-        if self.method.lt(&(*other).method) { return true; }\n-        if (*other).method.lt(&self.method) { return false; }\n-        if self.description.lt(&(*other).description) { return true; }\n-        if (*other).description.lt(&self.description) { return false; }\n-        if self.tags.lt(&(*other).tags) { return true; }\n-        if (*other).tags.lt(&self.tags) { return false; }\n-        if self.versions.lt(&(*other).versions) { return true; }\n-        return false;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn lt(&self, other: &Package) -> bool {\n-        if (*self).name.lt(&(*other).name) { return true; }\n-        if (*other).name.lt(&(*self).name) { return false; }\n-        if (*self).uuid.lt(&(*other).uuid) { return true; }\n-        if (*other).uuid.lt(&(*self).uuid) { return false; }\n-        if (*self).url.lt(&(*other).url) { return true; }\n-        if (*other).url.lt(&(*self).url) { return false; }\n-        if (*self).method.lt(&(*other).method) { return true; }\n-        if (*other).method.lt(&(*self).method) { return false; }\n-        if (*self).description.lt(&(*other).description) { return true; }\n-        if (*other).description.lt(&(*self).description) { return false; }\n-        if (*self).tags.lt(&(*other).tags) { return true; }\n-        if (*other).tags.lt(&(*self).tags) { return false; }\n-        if (*self).versions.lt(&(*other).versions) { return true; }\n-        return false;\n-    }\n-    #[cfg(stage0)]\n-    pure fn le(other: &Package) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn le(&self, other: &Package) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &Package) -> bool { !self.lt(other)     }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ge(&self, other: &Package) -> bool { !(*self).lt(other)     }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &Package) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn gt(&self, other: &Package) -> bool { (*other).lt(&(*self))  }\n-}\n-\n-struct Source {\n-    name: ~str,\n-    mut url: ~str,\n-    mut method: ~str,\n-    mut key: Option<~str>,\n-    mut keyfp: Option<~str>,\n-    packages: DVec<Package>\n-}\n-\n-struct Cargo {\n-    pgp: bool,\n-    root: Path,\n-    installdir: Path,\n-    bindir: Path,\n-    libdir: Path,\n-    workdir: Path,\n-    sourcedir: Path,\n-    sources: map::HashMap<~str, @Source>,\n-    mut current_install: ~str,\n-    dep_cache: map::HashMap<~str, bool>,\n-    opts: Options\n-}\n-\n-struct Crate {\n-    name: ~str,\n-    vers: ~str,\n-    uuid: ~str,\n-    desc: Option<~str>,\n-    sigs: Option<~str>,\n-    crate_type: Option<~str>,\n-    deps: ~[~str]\n-}\n-\n-struct Options {\n-    test: bool,\n-    mode: Mode,\n-    free: ~[~str],\n-    help: bool,\n-}\n-\n-enum Mode { SystemMode, UserMode, LocalMode }\n-\n-impl Mode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Mode) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn eq(&self, other: &Mode) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Mode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ne(&self, other: &Mode) -> bool { !(*self).eq(other) }\n-}\n-\n-fn opts() -> ~[getopts::Opt] {\n-    ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n-     optflag(~\"h\"), optflag(~\"help\")]\n-}\n-\n-fn info(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_green);\n-        out.write_str(~\"info: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    } else { out.write_line(~\"info: \" + msg); }\n-}\n-\n-fn warn(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_yellow);\n-        out.write_str(~\"warning: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    }else { out.write_line(~\"warning: \" + msg); }\n-}\n-\n-fn error(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_red);\n-        out.write_str(~\"error: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    }\n-    else { out.write_line(~\"error: \" + msg); }\n-}\n-\n-fn is_uuid(id: ~str) -> bool {\n-    let parts = str::split_str(id, ~\"-\");\n-    if vec::len(parts) == 5u {\n-        let mut correct = 0u;\n-        for vec::eachi(parts) |i, part| {\n-            fn is_hex_digit(+ch: char) -> bool {\n-                ('0' <= ch && ch <= '9') ||\n-                ('a' <= ch && ch <= 'f') ||\n-                ('A' <= ch && ch <= 'F')\n-            }\n-\n-            if !part.all(is_hex_digit) {\n-                return false;\n-            }\n-\n-            match i {\n-                0u => {\n-                    if part.len() == 8u {\n-                        correct += 1u;\n-                    }\n-                }\n-                1u | 2u | 3u => {\n-                    if part.len() == 4u {\n-                        correct += 1u;\n-                    }\n-                }\n-                4u => {\n-                    if part.len() == 12u {\n-                        correct += 1u;\n-                    }\n-                }\n-                _ => { }\n-            }\n-        }\n-        if correct >= 5u {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-#[test]\n-fn test_is_uuid() {\n-    assert is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaafAF09\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"\");\n-    assert !is_uuid(~\"aaaaaaaa-aaa -aaaa-aaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"aaaaaaaa-aaa!-aaaa-aaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa-a\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n-}\n-\n-// FIXME (#2661): implement url/URL parsing so we don't have to resort\n-// to weak checks\n-\n-fn has_archive_extension(p: ~str) -> bool {\n-    str::ends_with(p, ~\".tar\") ||\n-    str::ends_with(p, ~\".tar.gz\") ||\n-    str::ends_with(p, ~\".tar.bz2\") ||\n-    str::ends_with(p, ~\".tar.Z\") ||\n-    str::ends_with(p, ~\".tar.lz\") ||\n-    str::ends_with(p, ~\".tar.xz\") ||\n-    str::ends_with(p, ~\".tgz\") ||\n-    str::ends_with(p, ~\".tbz\") ||\n-    str::ends_with(p, ~\".tbz2\") ||\n-    str::ends_with(p, ~\".tb2\") ||\n-    str::ends_with(p, ~\".taz\") ||\n-    str::ends_with(p, ~\".tlz\") ||\n-    str::ends_with(p, ~\".txz\")\n-}\n-\n-fn is_archive_path(u: ~str) -> bool {\n-    has_archive_extension(u) && os::path_exists(&Path(u))\n-}\n-\n-fn is_archive_url(u: ~str) -> bool {\n-    // FIXME (#2661): this requires the protocol bit - if we had proper\n-    // url parsing, we wouldn't need it\n-\n-    match str::find_str(u, ~\"://\") {\n-        option::Some(_) => has_archive_extension(u),\n-        _ => false\n-    }\n-}\n-\n-fn is_git_url(url: ~str) -> bool {\n-    if str::ends_with(url, ~\"/\") { str::ends_with(url, ~\".git/\") }\n-    else {\n-        str::starts_with(url, ~\"git://\") || str::ends_with(url, ~\".git\")\n-    }\n-}\n-\n-fn assume_source_method(url: ~str) -> ~str {\n-    if is_git_url(url) {\n-        return ~\"git\";\n-    }\n-    if str::starts_with(url, ~\"file://\") || os::path_exists(&Path(url)) {\n-        return ~\"file\";\n-    }\n-\n-    ~\"curl\"\n-}\n-\n-fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                         Option<~str>,\n-                                         Option<~str>) {\n-    let mut name = None;\n-    let mut vers = None;\n-    let mut uuid = None;\n-    for mis.each |a| {\n-        match a.node {\n-            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n-                match v {\n-                    ~\"name\" => name = Some(*s),\n-                    ~\"vers\" => vers = Some(*s),\n-                    ~\"uuid\" => uuid = Some(*s),\n-                    _ => { }\n-                }\n-            }\n-            _ => fail ~\"load_link: meta items must be name-values\"\n-        }\n-    }\n-    (name, vers, uuid)\n-}\n-\n-fn load_crate(filename: &Path) -> Option<Crate> {\n-    let sess = parse::new_parse_sess(None);\n-    let c = parse::parse_crate_from_crate_file(filename, ~[], sess);\n-\n-    let mut name = None;\n-    let mut vers = None;\n-    let mut uuid = None;\n-    let mut desc = None;\n-    let mut sigs = None;\n-    let mut crate_type = None;\n-\n-    for c.node.attrs.each |a| {\n-        match a.node.value.node {\n-            ast::meta_name_value(v, {node: ast::lit_str(_), span: _}) => {\n-                match v {\n-                    ~\"desc\" => desc = Some(v),\n-                    ~\"sigs\" => sigs = Some(v),\n-                    ~\"crate_type\" => crate_type = Some(v),\n-                    _ => { }\n-                }\n-            }\n-            ast::meta_list(v, mis) => {\n-                if v == ~\"link\" {\n-                    let (n, v, u) = load_link(mis);\n-                    name = n;\n-                    vers = v;\n-                    uuid = u;\n-                }\n-            }\n-            _ => {\n-                fail ~\"crate attributes may not contain \" +\n-                     ~\"meta_words\";\n-            }\n-        }\n-    }\n-\n-    type env = @{\n-        mut deps: ~[~str]\n-    };\n-\n-    fn goto_view_item(ps: syntax::parse::parse_sess, e: env,\n-                      i: @ast::view_item) {\n-        match i.node {\n-            ast::view_item_use(ident, metas, _) => {\n-                let name_items =\n-                    attr::find_meta_items_by_name(metas, ~\"name\");\n-                let m = if name_items.is_empty() {\n-                    metas + ~[attr::mk_name_value_item_str(\n-                        ~\"name\", *ps.interner.get(ident))]\n-                } else {\n-                    metas\n-                };\n-                let mut attr_name = ident;\n-                let mut attr_vers = ~\"\";\n-                let mut attr_from = ~\"\";\n-\n-              for m.each |item| {\n-                    match attr::get_meta_item_value_str(*item) {\n-                        Some(value) => {\n-                            let name = attr::get_meta_item_name(*item);\n-\n-                            match name {\n-                                ~\"vers\" => attr_vers = value,\n-                                ~\"from\" => attr_from = value,\n-                                _ => ()\n-                            }\n-                        }\n-                        None => ()\n-                    }\n-                }\n-\n-                let query = if !str::is_empty(attr_from) {\n-                    attr_from\n-                } else {\n-                    if !str::is_empty(attr_vers) {\n-                        ps.interner.get(attr_name) + ~\"@\" + attr_vers\n-                    } else { *ps.interner.get(attr_name) }\n-                };\n-\n-                match *ps.interner.get(attr_name) {\n-                    ~\"std\" | ~\"core\" => (),\n-                    _ => e.deps.push(query)\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-    fn goto_item(_e: env, _i: @ast::item) {\n-    }\n-\n-    let e = @{\n-        mut deps: ~[]\n-    };\n-    let v = visit::mk_simple_visitor(@{\n-        visit_view_item: |a| goto_view_item(sess, e, a),\n-        visit_item: |a| goto_item(e, a),\n-        .. *visit::default_simple_visitor()\n-    });\n-\n-    visit::visit_crate(*c, (), v);\n-\n-    let deps = copy e.deps;\n-\n-    match (name, vers, uuid) {\n-        (Some(name0), Some(vers0), Some(uuid0)) => {\n-            Some(Crate {\n-                name: name0,\n-                vers: vers0,\n-                uuid: uuid0,\n-                desc: desc,\n-                sigs: sigs,\n-                crate_type: crate_type,\n-                deps: deps })\n-        }\n-        _ => return None\n-    }\n-}\n-\n-fn print(s: ~str) {\n-    io::stdout().write_line(s);\n-}\n-\n-fn rest(s: ~str, start: uint) -> ~str {\n-    if (start >= str::len(s)) {\n-        ~\"\"\n-    } else {\n-        str::slice(s, start, str::len(s))\n-    }\n-}\n-\n-fn need_dir(s: &Path) {\n-    if os::path_is_dir(s) { return; }\n-    if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n-        fail fmt!(\"can't make_dir %s\", s.to_str());\n-    }\n-}\n-\n-fn valid_pkg_name(s: &str) -> bool {\n-    fn is_valid_digit(+c: char) -> bool {\n-        ('0' <= c && c <= '9') ||\n-        ('a' <= c && c <= 'z') ||\n-        ('A' <= c && c <= 'Z') ||\n-        c == '-' ||\n-        c == '_'\n-    }\n-\n-    s.all(is_valid_digit)\n-}\n-\n-fn parse_source(name: ~str, j: &json::Json) -> @Source {\n-    if !valid_pkg_name(name) {\n-        fail fmt!(\"'%s' is an invalid source name\", name);\n-    }\n-\n-    match *j {\n-        json::Object(j) => {\n-            let mut url = match j.find(&~\"url\") {\n-                Some(json::String(u)) => u,\n-                _ => fail ~\"needed 'url' field in source\"\n-            };\n-            let method = match j.find(&~\"method\") {\n-                Some(json::String(u)) => u,\n-                _ => assume_source_method(url)\n-            };\n-            let key = match j.find(&~\"key\") {\n-                Some(json::String(u)) => Some(u),\n-                _ => None\n-            };\n-            let keyfp = match j.find(&~\"keyfp\") {\n-                Some(json::String(u)) => Some(u),\n-                _ => None\n-            };\n-            if method == ~\"file\" {\n-                url = os::make_absolute(&Path(url)).to_str();\n-            }\n-            return @Source {\n-                name: name,\n-                mut url: url,\n-                mut method: method,\n-                mut key: key,\n-                mut keyfp: keyfp,\n-                packages: DVec() };\n-        }\n-        _ => fail ~\"needed dict value in source\"\n-    };\n-}\n-\n-fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n-    if !os::path_exists(filename)  { return; }\n-    let c = io::read_whole_file_str(filename);\n-    match json::from_str(c.get()) {\n-        Ok(json::Object(j)) => {\n-            for j.each |k, v| {\n-                sources.insert(copy *k, parse_source(*k, v));\n-                debug!(\"source: %s\", *k);\n-            }\n-        }\n-        Ok(_) => fail ~\"malformed sources.json\",\n-        Err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n-    }\n-}\n-\n-fn load_one_source_package(src: @Source, p: &json::Object) {\n-    let name = match p.find(&~\"name\") {\n-        Some(json::String(n)) => {\n-            if !valid_pkg_name(n) {\n-                warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + n + ~\"'\"+\n-                     ~\" is an invalid name (alphanumeric, underscores and\" +\n-                     ~\" dashes only)\");\n-                return;\n-            }\n-            n\n-        }\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n-            return;\n-        }\n-    };\n-\n-    let uuid = match p.find(&~\"uuid\") {\n-        Some(json::String(n)) => {\n-            if !is_uuid(n) {\n-                warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + n + ~\"'\"+\n-                     ~\" is an invalid uuid\");\n-                return;\n-            }\n-            n\n-        }\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n-            return;\n-        }\n-    };\n-\n-    let url = match p.find(&~\"url\") {\n-        Some(json::String(n)) => n,\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n-            return;\n-        }\n-    };\n-\n-    let method = match p.find(&~\"method\") {\n-        Some(json::String(n)) => n,\n-        _ => {\n-            warn(~\"malformed source json: \"\n-                 + src.name + ~\" (missing method)\");\n-            return;\n-        }\n-    };\n-\n-    let reference = match p.find(&~\"ref\") {\n-        Some(json::String(n)) => Some(n),\n-        _ => None\n-    };\n-\n-    let mut tags = ~[];\n-    match p.find(&~\"tags\") {\n-        Some(json::List(js)) => {\n-          for js.each |j| {\n-                match *j {\n-                    json::String(ref j) => tags.grow(1u, j),\n-                    _ => ()\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    let description = match p.find(&~\"description\") {\n-        Some(json::String(n)) => n,\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name\n-                 + ~\" (missing description)\");\n-            return;\n-        }\n-    };\n-\n-    let newpkg = Package {\n-        name: name,\n-        uuid: uuid,\n-        url: url,\n-        method: method,\n-        description: description,\n-        reference: reference,\n-        tags: tags,\n-        versions: ~[]\n-    };\n-\n-    match src.packages.position(|pkg| pkg.uuid == uuid) {\n-        Some(idx) => {\n-            src.packages.set_elt(idx, newpkg);\n-            log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n-        }\n-        None => {\n-            src.packages.push(newpkg);\n-        }\n-    }\n-\n-    log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n-}\n-\n-fn load_source_info(c: &Cargo, src: @Source) {\n-    let dir = c.sourcedir.push(src.name);\n-    let srcfile = dir.push(\"source.json\");\n-    if !os::path_exists(&srcfile) { return; }\n-    let srcstr = io::read_whole_file_str(&srcfile);\n-    match json::from_str(srcstr.get()) {\n-        Ok(ref json @ json::Object(_)) => {\n-            let o = parse_source(src.name, json);\n-\n-            src.key = o.key;\n-            src.keyfp = o.keyfp;\n-        }\n-        Ok(_) => {\n-            warn(~\"malformed source.json: \" + src.name +\n-                 ~\"(source info is not a dict)\");\n-        }\n-        Err(e) => {\n-            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n-        }\n-    };\n-}\n-fn load_source_packages(c: &Cargo, src: @Source) {\n-    log(debug, ~\"loading source: \" + src.name);\n-    let dir = c.sourcedir.push(src.name);\n-    let pkgfile = dir.push(\"packages.json\");\n-    if !os::path_exists(&pkgfile) { return; }\n-    let pkgstr = io::read_whole_file_str(&pkgfile);\n-    match json::from_str(pkgstr.get()) {\n-        Ok(json::List(js)) => {\n-          for js.each |j| {\n-                match *j {\n-                    json::Object(p) => {\n-                        load_one_source_package(src, p);\n-                    }\n-                    _ => {\n-                        warn(~\"malformed source json: \" + src.name +\n-                             ~\" (non-dict pkg)\");\n-                    }\n-                }\n-            }\n-        }\n-        Ok(_) => {\n-            warn(~\"malformed packages.json: \" + src.name +\n-                 ~\"(packages is not a list)\");\n-        }\n-        Err(e) => {\n-            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n-        }\n-    };\n-}\n-\n-fn build_cargo_options(argv: ~[~str]) -> Options {\n-    let matches = match getopts::getopts(argv, opts()) {\n-        result::Ok(m) => m,\n-        result::Err(f) => {\n-            fail fmt!(\"%s\", getopts::fail_str(f));\n-        }\n-    };\n-\n-    let test = opt_present(matches, ~\"test\");\n-    let G    = opt_present(matches, ~\"G\");\n-    let g    = opt_present(matches, ~\"g\");\n-    let help = opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\");\n-    let len  = vec::len(matches.free);\n-\n-    let is_install = len > 1u && matches.free[1] == ~\"install\";\n-    let is_uninstall = len > 1u && matches.free[1] == ~\"uninstall\";\n-\n-    if G && g { fail ~\"-G and -g both provided\"; }\n-\n-    if !is_install && !is_uninstall && (g || G) {\n-        fail ~\"-g and -G are only valid for `install` and `uninstall|rm`\";\n-    }\n-\n-    let mode =\n-        if (!is_install && !is_uninstall) || g { UserMode }\n-        else if G { SystemMode }\n-        else { LocalMode };\n-\n-    Options {test: test, mode: mode, free: matches.free, help: help}\n-}\n-\n-fn configure(opts: Options) -> Cargo {\n-    let home = match get_cargo_root() {\n-        Ok(home) => home,\n-        Err(_err) => get_cargo_sysroot().get()\n-    };\n-\n-    let get_cargo_dir = match opts.mode {\n-        SystemMode => get_cargo_sysroot,\n-        UserMode => get_cargo_root,\n-        LocalMode => get_cargo_root_nearest\n-    };\n-\n-    let p = get_cargo_dir().get();\n-\n-    let sources = HashMap();\n-    try_parse_sources(&home.push(\"sources.json\"), sources);\n-    try_parse_sources(&home.push(\"local-sources.json\"), sources);\n-\n-    let dep_cache = HashMap();\n-\n-    let mut c = Cargo {\n-        pgp: pgp::supported(),\n-        root: home,\n-        installdir: p,\n-        bindir: p.push(\"bin\"),\n-        libdir: p.push(\"lib\"),\n-        workdir: p.push(\"work\"),\n-        sourcedir: home.push(\"sources\"),\n-        sources: sources,\n-        mut current_install: ~\"\",\n-        dep_cache: dep_cache,\n-        opts: opts\n-    };\n-\n-    need_dir(&c.root);\n-    need_dir(&c.installdir);\n-    need_dir(&c.sourcedir);\n-    need_dir(&c.workdir);\n-    need_dir(&c.libdir);\n-    need_dir(&c.bindir);\n-\n-    for sources.each_key |k| {\n-        let mut s = sources.get(k);\n-        load_source_packages(&c, s);\n-        sources.insert(k, s);\n-    }\n-\n-    if c.pgp {\n-        pgp::init(&c.root);\n-    } else {\n-        warn(~\"command `gpg` was not found\");\n-        warn(~\"you have to install gpg from source \" +\n-             ~\" or package manager to get it to work correctly\");\n-    }\n-\n-    move c\n-}\n-\n-fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n-    for c.sources.each_value |v| {\n-        for v.packages.each |p| {\n-            b(v, p);\n-        }\n-    }\n-}\n-\n-// Runs all programs in directory <buildpath>\n-fn run_programs(buildpath: &Path) {\n-    let newv = os::list_dir_path(buildpath);\n-    for newv.each |ct| {\n-        run::run_program(ct.to_str(), ~[]);\n-    }\n-}\n-\n-// Runs rustc in <path + subdir> with the given flags\n-// and returns <patho + subdir>\n-fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n-                    extra_flags: ~[~str]) -> Option<Path> {\n-    let buildpath = path.push_rel(subdir);\n-    need_dir(&buildpath);\n-    debug!(\"%s: %s -> %s\", what, cf.to_str(), buildpath.to_str());\n-    let p = run::program_output(rustc_sysroot(),\n-                                ~[~\"--out-dir\",\n-                                  buildpath.to_str(),\n-                                  cf.to_str()] + extra_flags);\n-    if p.status != 0 {\n-        error(fmt!(\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out));\n-        return None;\n-    }\n-    Some(buildpath)\n-}\n-\n-fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n-    let buildpath = match run_in_buildpath(~\"testing\", path,\n-                                           &Path(\"test\"),\n-                                           cf,\n-                                           ~[ ~\"--test\"]) {\n-      None => return,\n-    Some(bp) => bp\n-  };\n-  run_programs(&buildpath);\n-}\n-\n-fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n-    let buildpath = match run_in_buildpath(~\"installing\", path,\n-                                           &Path(\"build\"),\n-                                           cf, ~[]) {\n-      None => return,\n-      Some(bp) => bp\n-    };\n-    let newv = os::list_dir_path(&buildpath);\n-    let exec_suffix = os::exe_suffix();\n-    for newv.each |ct| {\n-        if (exec_suffix != ~\"\" && str::ends_with(ct.to_str(),\n-                                                 exec_suffix)) ||\n-            (exec_suffix == ~\"\" &&\n-             !str::starts_with(ct.filename().get(),\n-                               ~\"lib\")) {\n-            debug!(\"  bin: %s\", ct.to_str());\n-            install_to_dir(*ct, &c.bindir);\n-            if c.opts.mode == SystemMode {\n-                // FIXME (#2662): Put this file in PATH / symlink it so it can\n-                // be used as a generic executable\n-                // `cargo install -G rustray` and `rustray file.obj`\n-            }\n-        } else {\n-            debug!(\"  lib: %s\", ct.to_str());\n-            install_to_dir(*ct, &c.libdir);\n-        }\n-    }\n-}\n-\n-\n-fn rustc_sysroot() -> ~str {\n-    match os::self_exe_path() {\n-        Some(path) => {\n-            let rustc = path.push_many([~\"..\", ~\"bin\", ~\"rustc\"]);\n-            debug!(\"  rustc: %s\", rustc.to_str());\n-            rustc.to_str()\n-        }\n-        None => ~\"rustc\"\n-    }\n-}\n-\n-fn install_source(c: &Cargo, path: &Path) {\n-    debug!(\"source: %s\", path.to_str());\n-    os::change_dir(path);\n-\n-    let mut cratefiles = ~[];\n-    for os::walk_dir(&Path(\".\")) |p| {\n-        if p.filetype() == Some(~\".rc\") {\n-            cratefiles.push(*p);\n-        }\n-    }\n-\n-    if vec::is_empty(cratefiles) {\n-        fail ~\"this doesn't look like a rust package (no .rc files)\";\n-    }\n-\n-    for cratefiles.each |cf| {\n-        match load_crate(cf) {\n-            None => loop,\n-            Some(crate) => {\n-              for crate.deps.each |query| {\n-                    // FIXME (#1356): handle cyclic dependencies\n-                    // (n.b. #1356 says \"Cyclic dependency is an error\n-                    // condition\")\n-\n-                    let wd = get_temp_workdir(c);\n-                    install_query(c, &wd, *query);\n-                }\n-\n-                os::change_dir(path);\n-\n-                if c.opts.test {\n-                    test_one_crate(c, path, cf);\n-                }\n-                install_one_crate(c, path, cf);\n-            }\n-        }\n-    }\n-}\n-\n-fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n-    run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n-    if reference.is_some() {\n-        let r = reference.get();\n-        os::change_dir(wd);\n-        run::run_program(~\"git\", ~[~\"checkout\", r]);\n-    }\n-\n-    install_source(c, wd);\n-}\n-\n-fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n-    let tarpath = wd.push(\"pkg.tar\");\n-    let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                         tarpath.to_str(), url]);\n-    if p.status != 0 {\n-        fail fmt!(\"fetch of %s failed: %s\", url, p.err);\n-    }\n-    run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                               ~\"-C\", wd.to_str(),\n-                               ~\"-f\", tarpath.to_str()]);\n-    install_source(c, wd);\n-}\n-\n-fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n-    run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                                  ~\"-C\", wd.to_str(),\n-                                  ~\"-f\", path.to_str()]);\n-    install_source(c, wd);\n-}\n-\n-fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n-    let url = copy pkg.url;\n-    let method = match pkg.method {\n-        ~\"git\" => ~\"git\",\n-        ~\"file\" => ~\"file\",\n-        _ => ~\"curl\"\n-    };\n-\n-    info(fmt!(\"installing %s/%s via %s...\", src, pkg.name, method));\n-\n-    match method {\n-        ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n-        ~\"file\" => install_file(c, wd, &Path(url)),\n-        ~\"curl\" => install_curl(c, wd, url),\n-        _ => ()\n-    }\n-}\n-\n-fn cargo_suggestion(c: &Cargo, fallback: fn())\n-{\n-    if c.sources.size() == 0u {\n-        error(~\"no sources defined - you may wish to run \" +\n-              ~\"`cargo init`\");\n-        return;\n-    }\n-    fallback();\n-}\n-\n-fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n-    let mut ps = ~[];\n-    for_each_package(c, |s, p| {\n-        if p.uuid == uuid {\n-            vec::push(&mut ps, (s.name, copy *p));\n-        }\n-    });\n-    if vec::len(ps) == 1u {\n-        let (sname, p) = copy ps[0];\n-        install_package(c, sname, wd, p);\n-        return;\n-    } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, || {\n-            error(~\"can't find package: \" + uuid);\n-        });\n-        return;\n-    }\n-    error(~\"found multiple packages:\");\n-    for ps.each |elt| {\n-        let (sname,p) = copy *elt;\n-        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n-    }\n-}\n-\n-fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n-    let mut ps = ~[];\n-    for_each_package(c, |s, p| {\n-        if p.name == name {\n-            vec::push(&mut ps, (s.name, copy *p));\n-        }\n-    });\n-    if vec::len(ps) == 1u {\n-        let (sname, p) = copy ps[0];\n-        install_package(c, sname, wd, p);\n-        return;\n-    } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, || {\n-            error(~\"can't find package: \" + name);\n-        });\n-        return;\n-    }\n-    error(~\"found multiple packages:\");\n-    for ps.each |elt| {\n-        let (sname,p) = copy *elt;\n-        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n-    }\n-}\n-\n-fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n-    match c.sources.find(src) {\n-        Some(s) => {\n-            for s.packages.each |p| {\n-                if p.uuid == uuid {\n-                    install_package(c, src, wd, *p);\n-                    return;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-    error(~\"can't find package: \" + src + ~\"/\" + uuid);\n-}\n-\n-fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n-    match c.sources.find(src) {\n-        Some(s) => {\n-            for s.packages.each |p| {\n-                if p.name == name {\n-                    install_package(c, src, wd, *p);\n-                    return;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-    error(~\"can't find package: \" + src + ~\"/\" + name);\n-}\n-\n-fn cmd_uninstall(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    let lib = &c.libdir;\n-    let bin = &c.bindir;\n-    let target = c.opts.free[2u];\n-\n-    // FIXME (#2662): needs stronger pattern matching\n-    // FIXME (#2662): needs to uninstall from a specified location in a\n-    // cache instead of looking for it (binaries can be uninstalled by\n-    // name only)\n-\n-    fn try_uninstall(p: &Path) -> bool {\n-        if os::remove_file(p) {\n-            info(~\"uninstalled: '\" + p.to_str() + ~\"'\");\n-            true\n-        } else {\n-            error(~\"could not uninstall: '\" +\n-                  p.to_str() + ~\"'\");\n-            false\n-        }\n-    }\n-\n-    if is_uuid(target) {\n-        for os::list_dir(lib).each |file| {\n-            match str::find_str(*file, ~\"-\" + target + ~\"-\") {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-        error(~\"can't find package with uuid: \" + target);\n-    } else {\n-        for os::list_dir(lib).each |file| {\n-            match str::find_str(*file, ~\"lib\" + target + ~\"-\") {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-        for os::list_dir(bin).each |file| {\n-            match str::find_str(*file, target) {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-\n-        error(~\"can't find package with name: \" + target);\n-    }\n-}\n-\n-fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n-    match c.dep_cache.find(target) {\n-        Some(inst) => {\n-            if inst {\n-                return;\n-            }\n-        }\n-        None => ()\n-    }\n-\n-    c.dep_cache.insert(target, true);\n-\n-    if is_archive_path(target) {\n-        install_file(c, wd, &Path(target));\n-        return;\n-    } else if is_git_url(target) {\n-        let reference = if c.opts.free.len() >= 4u {\n-            Some(c.opts.free[3u])\n-        } else {\n-            None\n-        };\n-        install_git(c, wd, target, reference);\n-    } else if !valid_pkg_name(target) && has_archive_extension(target) {\n-        install_curl(c, wd, target);\n-        return;\n-    } else {\n-        let mut ps = copy target;\n-\n-        match str::find_char(ps, '/') {\n-            option::Some(idx) => {\n-                let source = str::slice(ps, 0u, idx);\n-                ps = str::slice(ps, idx + 1u, str::len(ps));\n-                if is_uuid(ps) {\n-                    install_uuid_specific(c, wd, source, ps);\n-                } else {\n-                    install_named_specific(c, wd, source, ps);\n-                }\n-            }\n-            option::None => {\n-                if is_uuid(ps) {\n-                    install_uuid(c, wd, ps);\n-                } else {\n-                    install_named(c, wd, ps);\n-                }\n-            }\n-        }\n-    }\n-\n-    // FIXME (#2662): This whole dep_cache and current_install thing is\n-    // a bit of a hack. It should be cleaned up in the future.\n-\n-    if target == c.current_install {\n-        for c.dep_cache.each |k, _v| {\n-            c.dep_cache.remove(k);\n-        }\n-\n-        c.current_install = ~\"\";\n-    }\n-}\n-\n-fn get_temp_workdir(c: &Cargo) -> Path {\n-    match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n-      Some(wd) => wd,\n-      None => fail fmt!(\"needed temp dir: %s\",\n-                        c.workdir.to_str())\n-    }\n-}\n-\n-fn cmd_install(c: &Cargo) unsafe {\n-    let wd = get_temp_workdir(c);\n-\n-    if vec::len(c.opts.free) == 2u {\n-        let cwd = os::getcwd();\n-        let status = run::run_program(~\"cp\", ~[~\"-R\", cwd.to_str(),\n-                                               wd.to_str()]);\n-\n-        if status != 0 {\n-            fail fmt!(\"could not copy directory: %s\", cwd.to_str());\n-        }\n-\n-        install_source(c, &wd);\n-        return;\n-    }\n-\n-    sync(c);\n-\n-    let query = c.opts.free[2];\n-    c.current_install = query.to_str();\n-\n-    install_query(c, &wd, query);\n-}\n-\n-fn sync(c: &Cargo) {\n-    for c.sources.each_key |k| {\n-        let mut s = c.sources.get(k);\n-        sync_one(c, s);\n-        c.sources.insert(k, s);\n-    }\n-}\n-\n-fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json.new\");\n-    let destsrcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json.new\");\n-    let destpkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let url = Path(src.url);\n-    let mut has_src_file = false;\n-\n-    if !os::copy_file(&url.push(\"packages.json\"), &pkgfile) {\n-        error(fmt!(\"fetch for source %s (url %s) failed\",\n-                   name, url.to_str()));\n-        return false;\n-    }\n-\n-    if os::copy_file(&url.push(\"source.json\"), &srcfile) {\n-        has_src_file = false;\n-    }\n-\n-    os::copy_file(&url.push(\"source.json.sig\"), &srcsigfile);\n-    os::copy_file(&url.push(\"packages.json.sig\"), &sigfile);\n-\n-    match copy src.key {\n-        Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                return false;\n-            }\n-\n-            if has_src_file {\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(fmt!(\"signature verification failed for source %s \\\n-                                with key %s\", name, f));\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    copy_warn(&pkgfile, &destpkgfile);\n-\n-    if has_src_file {\n-        copy_warn(&srcfile, &destsrcfile);\n-    }\n-\n-    os::remove_file(&keyfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&srcsigfile);\n-    os::remove_file(&pkgfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let url = src.url;\n-\n-    fn rollback(name: ~str, dir: &Path, insecure: bool) {\n-        fn msg(name: ~str, insecure: bool) {\n-            error(fmt!(\"could not rollback source: %s\", name));\n-\n-            if insecure {\n-                warn(~\"a past security check failed on source \" +\n-                     name + ~\" and rolling back the source failed -\"\n-                     + ~\" this source may be compromised\");\n-            }\n-        }\n-\n-        if !os::change_dir(dir) {\n-            msg(name, insecure);\n-        }\n-        else {\n-            let p = run::program_output(~\"git\", ~[~\"reset\", ~\"--hard\",\n-                                                ~\"HEAD@{1}\"]);\n-\n-            if p.status != 0 {\n-                msg(name, insecure);\n-            }\n-        }\n-    }\n-\n-    if !os::path_exists(&dir.push(\".git\")) {\n-        let p = run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]);\n-\n-        if p.status != 0 {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-    }\n-    else {\n-        if !os::change_dir(dir) {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-\n-        let p = run::program_output(~\"git\", ~[~\"pull\"]);\n-\n-        if p.status != 0 {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-    }\n-\n-    let has_src_file = os::path_exists(&srcfile);\n-\n-    match copy src.key {\n-        Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                rollback(name, dir, false);\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                rollback(name, dir, false);\n-                return false;\n-            }\n-\n-            if has_src_file {\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(fmt!(\"signature verification failed for source %s \\\n-                                with key %s\", name, f));\n-                    rollback(name, dir, false);\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    os::remove_file(&keyfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json.new\");\n-    let destsrcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json.new\");\n-    let destpkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let mut url = src.url;\n-    let smart = !str::ends_with(src.url, ~\"packages.json\");\n-    let mut has_src_file = false;\n-\n-    if smart {\n-        url += ~\"/packages.json\";\n-    }\n-\n-    let p = run::program_output(~\"curl\",\n-                                ~[~\"-f\", ~\"-s\",\n-                                  ~\"-o\", pkgfile.to_str(), url]);\n-\n-    if p.status != 0 {\n-        error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-        return false;\n-    }\n-    if smart {\n-        url = src.url + ~\"/source.json\";\n-        let p =\n-            run::program_output(~\"curl\",\n-                                ~[~\"-f\", ~\"-s\",\n-                                  ~\"-o\", srcfile.to_str(), url]);\n-\n-        if p.status == 0 {\n-            has_src_file = true;\n-        }\n-    }\n-\n-    match copy src.key {\n-       Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            if smart {\n-                url = src.url + ~\"/packages.json.sig\";\n-            }\n-            else {\n-                url = src.url + ~\".sig\";\n-            }\n-\n-            let mut p = run::program_output(~\"curl\",\n-                                            ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                              sigfile.to_str(), url]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (sig %s) failed\", name, url));\n-                return false;\n-            }\n-\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                return false;\n-            }\n-\n-            if smart && has_src_file {\n-                url = src.url + ~\"/source.json.sig\";\n-\n-                p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                          srcsigfile.to_str(), url]);\n-                if p.status != 0 {\n-                    error(fmt!(\"fetch for source %s (sig %s) failed\",\n-                          name, url));\n-                    return false;\n-                }\n-\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(~\"signature verification failed for \" +\n-                          ~\"source \" + name + ~\" with key \" + f);\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    copy_warn(&pkgfile, &destpkgfile);\n-\n-    if smart && has_src_file {\n-        copy_warn(&srcfile, &destsrcfile);\n-    }\n-\n-    os::remove_file(&keyfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&srcsigfile);\n-    os::remove_file(&pkgfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-fn sync_one(c: &Cargo, src: @Source) {\n-    let name = src.name;\n-    let dir = c.sourcedir.push(name);\n-\n-    info(fmt!(\"syncing source: %s...\", name));\n-\n-    need_dir(&dir);\n-\n-    let result = match src.method {\n-        ~\"git\" => sync_one_git(c, &dir, src),\n-        ~\"file\" => sync_one_file(c, &dir, src),\n-        _ => sync_one_curl(c, &dir, src)\n-    };\n-\n-    if result {\n-        load_source_info(c, src);\n-        load_source_packages(c, src);\n-    }\n-}\n-\n-fn cmd_init(c: &Cargo) {\n-    let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n-    let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n-\n-    let srcfile = c.root.push(\"sources.json.new\");\n-    let sigfile = c.root.push(\"sources.json.sig\");\n-    let destsrcfile = c.root.push(\"sources.json\");\n-\n-    let p =\n-        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n-                                       ~\"-o\", srcfile.to_str(), srcurl]);\n-    if p.status != 0 {\n-        error(fmt!(\"fetch of sources.json failed: %s\", p.out));\n-        return;\n-    }\n-\n-    let p =\n-        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n-                                       ~\"-o\", sigfile.to_str(), sigurl]);\n-    if p.status != 0 {\n-        error(fmt!(\"fetch of sources.json.sig failed: %s\", p.out));\n-        return;\n-    }\n-\n-    let r = pgp::verify(&c.root, &srcfile, &sigfile);\n-    if !r {\n-        error(fmt!(\"signature verification failed for '%s'\",\n-                   srcfile.to_str()));\n-        return;\n-    }\n-\n-    copy_warn(&srcfile, &destsrcfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n-}\n-\n-fn print_pkg(s: @Source, p: &Package) {\n-    let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n-    if vec::len(p.tags) > 0u {\n-        m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n-    }\n-    info(m);\n-    if p.description != ~\"\" {\n-        print(~\"   >> \" + p.description + ~\"\\n\")\n-    }\n-}\n-\n-fn print_source(s: @Source) {\n-    info(s.name + ~\" (\" + s.url + ~\")\");\n-\n-    let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n-    let l = vec::len(pks);\n-\n-    print(io::with_str_writer(|writer| {\n-        let mut list = ~\"   >> \";\n-\n-        for vec::eachi(pks) |i, pk| {\n-            if str::len(list) > 78u {\n-                writer.write_line(list);\n-                list = ~\"   >> \";\n-            }\n-            list += pk.name + (if l - 1u == i { ~\"\" } else { ~\", \" });\n-        }\n-\n-        writer.write_line(list);\n-    }));\n-}\n-\n-fn cmd_list(c: &Cargo) {\n-    sync(c);\n-\n-    if vec::len(c.opts.free) >= 3u {\n-        let v = vec::view(c.opts.free, 2u, vec::len(c.opts.free));\n-        for vec::each(v) |name| {\n-            if !valid_pkg_name(*name) {\n-                error(fmt!(\"'%s' is an invalid source name\", *name));\n-            } else {\n-                match c.sources.find(*name) {\n-                    Some(source) => {\n-                        print_source(source);\n-                    }\n-                    None => {\n-                        error(fmt!(\"no such source: %s\", *name));\n-                    }\n-                }\n-            }\n-        }\n-    } else {\n-        for c.sources.each_value |v| {\n-            print_source(v);\n-        }\n-    }\n-}\n-\n-fn cmd_search(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    sync(c);\n-\n-    let mut n = 0;\n-    let name = c.opts.free[2];\n-    let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n-    for_each_package(c, |s, p| {\n-        if (str::contains(p.name, name) || name == ~\"*\") &&\n-            vec::all(tags, |t| vec::contains(p.tags, t) ) {\n-            print_pkg(s, p);\n-            n += 1;\n-        }\n-    });\n-    info(fmt!(\"found %d packages\", n));\n-}\n-\n-fn install_to_dir(srcfile: &Path, destdir: &Path) {\n-    let newfile = destdir.push(srcfile.filename().get());\n-\n-    let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile.to_str(),\n-                                           newfile.to_str()]);\n-    if status == 0 {\n-        info(fmt!(\"installed: '%s'\", newfile.to_str()));\n-    } else {\n-        error(fmt!(\"could not install: '%s'\", newfile.to_str()));\n-    }\n-}\n-\n-fn dump_cache(c: &Cargo) {\n-    need_dir(&c.root);\n-\n-    let out = c.root.push(\"cache.json\");\n-    let _root = json::Object(~LinearMap());\n-\n-    if os::path_exists(&out) {\n-        copy_warn(&out, &c.root.push(\"cache.json.old\"));\n-    }\n-}\n-fn dump_sources(c: &Cargo) {\n-    if c.sources.size() < 1u {\n-        return;\n-    }\n-\n-    need_dir(&c.root);\n-\n-    let out = c.root.push(\"sources.json\");\n-\n-    if os::path_exists(&out) {\n-        copy_warn(&out, &c.root.push(\"sources.json.old\"));\n-    }\n-\n-    match io::buffered_file_writer(&out) {\n-        result::Ok(writer) => {\n-            let mut hash = ~LinearMap();\n-\n-            for c.sources.each |k, v| {\n-                let mut chash = ~LinearMap();\n-\n-                chash.insert(~\"url\", json::String(v.url));\n-                chash.insert(~\"method\", json::String(v.method));\n-\n-                match copy v.key {\n-                    Some(key) => {\n-                        chash.insert(~\"key\", json::String(copy key));\n-                    }\n-                    _ => ()\n-                }\n-                match copy v.keyfp {\n-                    Some(keyfp) => {\n-                        chash.insert(~\"keyfp\", json::String(copy keyfp));\n-                    }\n-                    _ => ()\n-                }\n-\n-                hash.insert(copy k, json::Object(move chash));\n-            }\n-\n-            json::to_writer(writer, &json::Object(move hash))\n-        }\n-        result::Err(e) => {\n-            error(fmt!(\"could not dump sources: %s\", e));\n-        }\n-    }\n-}\n-\n-fn copy_warn(srcfile: &Path, destfile: &Path) {\n-    if !os::copy_file(srcfile, destfile) {\n-        warn(fmt!(\"copying %s to %s failed\",\n-                  srcfile.to_str(), destfile.to_str()));\n-    }\n-}\n-\n-fn cmd_sources(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        for c.sources.each_value |v| {\n-            info(fmt!(\"%s (%s) via %s\",\n-                      v.name, v.url, v.method));\n-        }\n-        return;\n-    }\n-\n-    let action = c.opts.free[2u];\n-\n-    match action {\n-        ~\"clear\" => {\n-          for c.sources.each_key |k| {\n-                c.sources.remove(k);\n-            }\n-\n-            info(~\"cleared sources\");\n-        }\n-        ~\"add\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let url = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            if c.sources.contains_key(name) {\n-                error(fmt!(\"source already exists: %s\", name));\n-            } else {\n-                c.sources.insert(name, @Source {\n-                    name: name,\n-                    mut url: url,\n-                    mut method: assume_source_method(url),\n-                    mut key: None,\n-                    mut keyfp: None,\n-                    packages: DVec()\n-                });\n-                info(fmt!(\"added source: %s\", name));\n-            }\n-        }\n-        ~\"remove\" => {\n-            if vec::len(c.opts.free) < 4u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            if c.sources.contains_key(name) {\n-                c.sources.remove(name);\n-                info(fmt!(\"removed source: %s\", name));\n-            } else {\n-                error(fmt!(\"no such source: %s\", name));\n-            }\n-        }\n-        ~\"set-url\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let url = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            match c.sources.find(name) {\n-                Some(source) => {\n-                    let old = copy source.url;\n-                    let method = assume_source_method(url);\n-\n-                    source.url = url;\n-                    source.method = method;\n-\n-                    c.sources.insert(name, source);\n-\n-                    info(fmt!(\"changed source url: '%s' to '%s'\", old, url));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        ~\"set-method\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let method = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            match c.sources.find(name) {\n-                Some(source) => {\n-                    let old = copy source.method;\n-\n-                    source.method = match method {\n-                        ~\"git\" => ~\"git\",\n-                        ~\"file\" => ~\"file\",\n-                        _ => ~\"curl\"\n-                    };\n-\n-                    c.sources.insert(name, source);\n-\n-                    info(fmt!(\"changed source method: '%s' to '%s'\", old,\n-                         method));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        ~\"rename\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let newn = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-            if !valid_pkg_name(newn) {\n-                error(fmt!(\"'%s' is an invalid source name\", newn));\n-                return;\n-            }\n-\n-            match c.sources.find(name) {\n-                Some(source) => {\n-                    c.sources.remove(name);\n-                    c.sources.insert(newn, source);\n-                    info(fmt!(\"renamed source: %s to %s\", name, newn));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        _ => cmd_usage()\n-    }\n-}\n-\n-fn cmd_usage() {\n-    print(~\"Usage: cargo <cmd> [options] [args..]\n-e.g. cargo install <name>\n-\n-Where <cmd> is one of:\n-    init, install, list, search, sources,\n-    uninstall, usage\n-\n-Options:\n-\n-    -h, --help                  Display this message\n-    <cmd> -h, <cmd> --help      Display help for <cmd>\n-\");\n-}\n-\n-fn cmd_usage_init() {\n-    print(~\"cargo init\n-\n-Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n-default sources from <www.rust-lang.org/sources.json>.\");\n-}\n-\n-fn cmd_usage_install() {\n-    print(~\"cargo install\n-cargo install [source/]<name>[@version]\n-cargo install [source/]<uuid>[@version]\n-cargo install <git url> [ref]\n-cargo install <tarball url>\n-cargo install <tarball file>\n-\n-Options:\n-    --test      Run crate tests before installing\n-    -g          Install to the user level (~/.cargo/bin/ instead of\n-                locally in ./.cargo/bin/ by default)\n-    -G          Install to the system level (/usr/local/lib/cargo/bin/)\n-\n-Install a crate. If no arguments are supplied, it installs from\n-the current working directory. If a source is provided, only install\n-from that source, otherwise it installs from any source.\");\n-}\n-\n-fn cmd_usage_uninstall() {\n-    print(~\"cargo uninstall [source/]<name>[@version]\n-cargo uninstall [source/]<uuid>[@version]\n-cargo uninstall <meta-name>[@version]\n-cargo uninstall <meta-uuid>[@version]\n-\n-Options:\n-    -g          Remove from the user level (~/.cargo/bin/ instead of\n-                locally in ./.cargo/bin/ by default)\n-    -G          Remove from the system level (/usr/local/lib/cargo/bin/)\n-\n-Remove a crate. If a source is provided, only remove\n-from that source, otherwise it removes from any source.\n-If a crate was installed directly (git, tarball, etc.), you can remove\n-it by metadata.\");\n-}\n-\n-fn cmd_usage_list() {\n-    print(~\"cargo list [sources..]\n-\n-If no arguments are provided, list all sources and their packages.\n-If source names are provided, list those sources and their packages.\n-\");\n-}\n-\n-fn cmd_usage_search() {\n-    print(~\"cargo search <query | '*'> [tags..]\n-\n-Search packages.\");\n-}\n-\n-fn cmd_usage_sources() {\n-    print(~\"cargo sources\n-cargo sources add <name> <url>\n-cargo sources remove <name>\n-cargo sources rename <name> <new>\n-cargo sources set-url <name> <url>\n-cargo sources set-method <name> <method>\n-\n-If no arguments are supplied, list all sources (but not their packages).\n-\n-Commands:\n-    add             Add a source. The source method will be guessed\n-                    from the URL.\n-    remove          Remove a source.\n-    rename          Rename a source.\n-    set-url         Change the URL for a source.\n-    set-method      Change the method for a source.\");\n-}\n-\n-fn main() {\n-    let argv = os::args();\n-    let o = build_cargo_options(argv);\n-\n-    if vec::len(o.free) < 2u {\n-        cmd_usage();\n-        return;\n-    }\n-    if o.help {\n-        match o.free[1] {\n-            ~\"init\" => cmd_usage_init(),\n-            ~\"install\" => cmd_usage_install(),\n-            ~\"uninstall\" => cmd_usage_uninstall(),\n-            ~\"list\" => cmd_usage_list(),\n-            ~\"search\" => cmd_usage_search(),\n-            ~\"sources\" => cmd_usage_sources(),\n-            _ => cmd_usage()\n-        }\n-        return;\n-    }\n-    if o.free[1] == ~\"usage\" {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    let mut c = configure(o);\n-    let home = c.root;\n-    let first_time = os::path_exists(&home.push(\"sources.json\"));\n-\n-    if !first_time && o.free[1] != ~\"init\" {\n-        cmd_init(&c);\n-\n-        // FIXME (#2662): shouldn't need to reconfigure\n-        c = configure(o);\n-    }\n-\n-    let c = &move c;\n-\n-    match o.free[1] {\n-        ~\"init\" => cmd_init(c),\n-        ~\"install\" => cmd_install(c),\n-        ~\"uninstall\" => cmd_uninstall(c),\n-        ~\"list\" => cmd_list(c),\n-        ~\"search\" => cmd_search(c),\n-        ~\"sources\" => cmd_sources(c),\n-        _ => cmd_usage()\n-    }\n-\n-    dump_cache(c);\n-    dump_sources(c);\n-}"}, {"sha": "74f8d6b5cecd80bb75a2a34ca8cbf3af6962d342", "filename": "src/libcore/alternate_crate.rc", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Falternate_crate.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Falternate_crate.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falternate_crate.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,273 @@\n+/*!\n+\n+The Rust core library.\n+\n+The Rust core library provides runtime features required by the language,\n+including the task scheduler and memory allocators, as well as library\n+support for Rust built-in types, platform abstractions, and other commonly\n+used features.\n+\n+`core` includes modules corresponding to each of the integer types, each of\n+the floating point types, the `bool` type, tuples, characters, strings,\n+vectors (`vec`), shared boxes (`box`), and unsafe and borrowed pointers\n+(`ptr`).  Additionally, `core` provides task management and creation (`task`),\n+communication primitives (`comm` and `pipes`), an efficient vector builder\n+(`dvec`), platform abstractions (`os` and `path`), basic I/O abstractions\n+(`io`), common traits (`cmp`, `num`, `to_str`), and complete bindings\n+to the C standard library (`libc`).\n+\n+`core` is linked to all crates by default and its contents imported.\n+Implicitly, all crates behave as if they included the following prologue:\n+\n+    extern mod core;\n+    use core::*;\n+\n+*/\n+\n+#[link(name = \"core\",\n+       vers = \"0.5\",\n+       uuid = \"c70c24a7-5551-4f73-8e37-380b11d80be8\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/libcore\")];\n+\n+#[comment = \"The Rust core library\"];\n+#[license = \"MIT\"];\n+#[crate_type = \"lib\"];\n+\n+// Don't link to core. We are core.\n+#[no_core];\n+\n+#[warn(deprecated_mode)];\n+#[warn(deprecated_pattern)];\n+\n+#[warn(vecs_implicitly_copyable)];\n+#[deny(non_camel_case_types)];\n+\n+// Built-in-type support modules\n+\n+/// Operations and constants for `int`\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/intb.rs\"]\n+pub mod int;\n+\n+/// Operations and constants for `i8`\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i8b.rs\"]\n+pub mod i8;\n+\n+/// Operations and constants for `i16`\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i16b.rs\"]\n+pub mod i16;\n+\n+/// Operations and constants for `i32`\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i32b.rs\"]\n+pub mod i32;\n+\n+/// Operations and constants for `i64`\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i64b.rs\"]\n+pub mod i64;\n+\n+/// Operations and constants for `uint`\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/uintb.rs\"]\n+pub mod uint;\n+\n+/// Operations and constants for `u8`\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u8b.rs\"]\n+pub mod u8;\n+\n+/// Operations and constants for `u16`\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u16b.rs\"]\n+pub mod u16;\n+\n+/// Operations and constants for `u32`\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u32b.rs\"]\n+pub mod u32;\n+\n+/// Operations and constants for `u64`\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u64b.rs\"]\n+pub mod u64;\n+\n+\n+pub mod box;\n+pub mod char;\n+pub mod float;\n+pub mod f32;\n+pub mod f64;\n+pub mod str;\n+pub mod ptr;\n+pub mod vec;\n+pub mod at_vec;\n+pub mod bool;\n+pub mod tuple;\n+pub mod unit;\n+pub mod owned;\n+\n+// Ubiquitous-utility-type modules\n+\n+#[cfg(notest)]\n+pub mod ops;\n+pub mod cmp;\n+pub mod num;\n+pub mod hash;\n+pub mod either;\n+pub mod iter;\n+pub mod logging;\n+pub mod option;\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/optionb.rs\"]\n+pub mod option_iter;\n+pub mod result;\n+pub mod to_str;\n+pub mod to_bytes;\n+pub mod from_str;\n+pub mod util;\n+\n+// Data structure modules\n+\n+pub mod dvec;\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/dvecb.rs\"]\n+pub mod dvec_iter;\n+pub mod dlist;\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/dlistb.rs\"]\n+pub mod dlist_iter;\n+pub mod send_map;\n+\n+// Concurrency\n+pub mod comm;\n+#[merge = \"task/mod.rs\"]\n+pub mod task;\n+pub mod pipes;\n+\n+// Runtime and language-primitive support\n+\n+pub mod gc;\n+pub mod io;\n+pub mod libc;\n+pub mod os;\n+pub mod path;\n+pub mod rand;\n+pub mod run;\n+pub mod sys;\n+pub mod cast;\n+pub mod mutable;\n+pub mod flate;\n+pub mod repr;\n+pub mod cleanup;\n+pub mod reflect;\n+pub mod condition;\n+\n+// Modules supporting compiler-generated code\n+// Exported but not part of the public interface\n+\n+pub mod extfmt;\n+// The test harness links against core, so don't include runtime in tests.\n+#[cfg(notest)]\n+#[legacy_exports]\n+pub mod rt;\n+\n+// Ideally not exported, but currently is.\n+pub mod private;\n+\n+// For internal use, not exported.\n+mod unicode;\n+mod cmath;\n+mod stackwalk;\n+\n+// Top-level, visible-everywhere definitions.\n+\n+// Export various ubiquitous types, constructors, methods.\n+\n+pub use option::{Some, None};\n+pub use Option = option::Option;\n+pub use result::{Result, Ok, Err};\n+\n+pub use Path = path::Path;\n+pub use GenericPath = path::GenericPath;\n+pub use WindowsPath = path::WindowsPath;\n+pub use PosixPath = path::PosixPath;\n+\n+pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n+pub use str::{StrSlice, Trimmable};\n+pub use vec::{ConstVector, CopyableVector, ImmutableVector};\n+pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n+pub use vec::{MutableVector, MutableCopyableVector};\n+pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n+pub use num::Num;\n+pub use ptr::Ptr;\n+pub use to_str::ToStr;\n+\n+// The following exports are the core operators and kinds\n+// The compiler has special knowlege of these so we must not duplicate them\n+// when compiling for testing\n+#[cfg(notest)]\n+pub use ops::{Const, Copy, Send, Owned};\n+#[cfg(notest)]\n+pub use ops::{Drop};\n+#[cfg(notest)]\n+pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n+#[cfg(notest)]\n+pub use ops::{Shl, Shr, Index};\n+\n+#[cfg(test)]\n+extern mod coreops(name = \"core\", vers = \"0.5\");\n+\n+#[cfg(test)]\n+pub use coreops::ops::{Const, Copy, Send, Owned};\n+#[cfg(test)]\n+pub use coreops::ops::{Drop};\n+#[cfg(test)]\n+pub use coreops::ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr};\n+#[cfg(test)]\n+pub use coreops::ops::{BitXor};\n+#[cfg(test)]\n+pub use coreops::ops::{Shl, Shr, Index};\n+\n+\n+// Export the log levels as global constants. Higher levels mean\n+// more-verbosity. Error is the bottom level, default logging level is\n+// warn-and-below.\n+\n+/// The error log level\n+pub const error : u32 = 1_u32;\n+/// The warning log level\n+pub const warn : u32 = 2_u32;\n+/// The info log level\n+pub const info : u32 = 3_u32;\n+/// The debug log level\n+pub const debug : u32 = 4_u32;\n+\n+// A curious inner-module that's not exported that contains the binding\n+// 'core' so that macro-expanded references to core::error and such\n+// can be resolved within libcore.\n+#[doc(hidden)] // FIXME #3538\n+mod core {\n+    pub const error : u32 = 1_u32;\n+    pub const warn : u32 = 2_u32;\n+    pub const info : u32 = 3_u32;\n+    pub const debug : u32 = 4_u32;\n+}\n+\n+// Similar to above. Some magic to make core testable.\n+#[cfg(test)]\n+mod std {\n+    extern mod std(vers = \"0.5\");\n+    pub use std::test;\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "86417c936168ba16190d8278ac0eaf1684951776", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,3 +1,5 @@\n+// DIVERT\n+\n /*!\n \n The Rust core library."}, {"sha": "b24eb86e4ae169f9bd47d205c9afb71d64a28387", "filename": "src/libcore/int-template/i16b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fi16b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fi16b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi16b.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = i16;\n+    pub const bits: uint = u16::bits;\n+}\n\\ No newline at end of file"}, {"sha": "5bfb8a6d01cca54566c891a326bb6df316953dd4", "filename": "src/libcore/int-template/i32b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fi32b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fi32b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi32b.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = i32;\n+    pub const bits: uint = u32::bits;\n+}"}, {"sha": "86552b2ccedc62719d5eb112dd69d22043f83c7f", "filename": "src/libcore/int-template/i64b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fi64b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fi64b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi64b.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = i64;\n+    pub const bits: uint = u64::bits;\n+}\n\\ No newline at end of file"}, {"sha": "2cf7ed2983fba36ff558c8bcb35e16ca31725e53", "filename": "src/libcore/int-template/i8b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fi8b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fi8b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi8b.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = i8;\n+    pub const bits: uint = u8::bits;\n+}\n\\ No newline at end of file"}, {"sha": "c1f2ca944dd636505d7ecacca07fe5e4ba99c38f", "filename": "src/libcore/int-template/intb.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fintb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fint-template%2Fintb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fintb.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,45 @@\n+pub use inst::pow;\n+\n+mod inst {\n+    pub type T = int;\n+    pub const bits: uint = uint::bits;\n+\n+    /// Returns `base` raised to the power of `exponent`\n+    pub fn pow(base: int, exponent: uint) -> int {\n+        if exponent == 0u {\n+            //Not mathemtically true if ~[base == 0]\n+            return 1;\n+        }\n+        if base     == 0  { return 0; }\n+        let mut my_pow  = exponent;\n+        let mut acc     = 1;\n+        let mut multiplier = base;\n+        while(my_pow > 0u) {\n+            if my_pow % 2u == 1u {\n+                acc *= multiplier;\n+            }\n+            my_pow     /= 2u;\n+            multiplier *= multiplier;\n+        }\n+        return acc;\n+    }\n+\n+    #[test]\n+    fn test_pow() {\n+        assert (pow(0, 0u) == 1);\n+        assert (pow(0, 1u) == 0);\n+        assert (pow(0, 2u) == 0);\n+        assert (pow(-1, 0u) == 1);\n+        assert (pow(1, 0u) == 1);\n+        assert (pow(-3, 2u) == 9);\n+        assert (pow(-3, 3u) == -27);\n+        assert (pow(4, 9u) == 262144);\n+    }\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert (max_value > 0);\n+        assert (min_value <= 0);\n+        assert (min_value + max_value + 1 == 0);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "2d782b1262b9228fc80175012fd0aeed84e76deb", "filename": "src/libcore/iter-trait/dlistb.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fiter-trait%2Fdlistb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fiter-trait%2Fdlistb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlistb.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,38 @@\n+mod inst {\n+    #[allow(non_camel_case_types)]\n+    pub type IMPL_T<A> = dlist::DList<A>;\n+\n+    /**\n+    * Iterates through the current contents.\n+    *\n+    * Attempts to access this dlist during iteration are allowed (to\n+    * allow for e.g. breadth-first search with in-place enqueues), but\n+    * removing the current node is forbidden.\n+    */\n+    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n+        let mut link = self.peek_n();\n+        while option::is_some(&link) {\n+            let nobe = option::get(link);\n+            assert nobe.linked;\n+            if !f(&nobe.data) { break; }\n+            // Check (weakly) that the user didn't do a remove.\n+            if self.size == 0 {\n+                fail ~\"The dlist became empty during iteration??\"\n+            }\n+            if !nobe.linked ||\n+                (!((nobe.prev.is_some()\n+                    || box::ptr_eq(*self.hd.expect(~\"headless dlist?\"),\n+                                   *nobe))\n+                   && (nobe.next.is_some()\n+                    || box::ptr_eq(*self.tl.expect(~\"tailless dlist?\"),\n+                                   *nobe)))) {\n+                fail ~\"Removing a dlist node during iteration is forbidden!\"\n+            }\n+            link = nobe.next_link();\n+        }\n+    }\n+\n+    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n+        Some(self.len())\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "b30c1372a2e2b0de3116c2477ae9ab198cb5a36a", "filename": "src/libcore/iter-trait/dvecb.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fiter-trait%2Fdvecb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fiter-trait%2Fdvecb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvecb.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,22 @@\n+mod inst {\n+    #[allow(non_camel_case_types)]\n+    pub type IMPL_T<A> = dvec::DVec<A>;\n+\n+    /**\n+    * Iterates through the current contents.\n+    *\n+    * Attempts to access this dvec during iteration will fail.\n+    */\n+    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n+        unsafe {\n+            do self.swap |v| {\n+                v.each(f);\n+                move v\n+            }\n+        }\n+    }\n+\n+    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n+        Some(self.len())\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "680893eb95b3ab0976cbd43a99267221fab635c2", "filename": "src/libcore/iter-trait/optionb.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fiter-trait%2Foptionb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fiter-trait%2Foptionb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foptionb.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,18 @@\n+mod inst {\n+    #[allow(non_camel_case_types)]\n+    pub type IMPL_T<A> = Option<A>;\n+\n+    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n+        match *self {\n+            None => (),\n+            Some(ref a) => { f(a); }\n+        }\n+    }\n+\n+    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n+        match *self {\n+            None => Some(0),\n+            Some(_) => Some(1)\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "887983e8b6c8b2db982919c5b43ab82bbe9dbffa", "filename": "src/libcore/task/mod.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,8 @@\n+\n+mod local_data_priv;\n+\n+pub mod local_data;\n+\n+pub mod rt;\n+\n+pub mod spawn;"}, {"sha": "aafd46f845b0a513274c4620b117d8d8f27899f5", "filename": "src/libcore/uint-template/u16b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fu16b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fu16b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu16b.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = u16;\n+    pub const bits: uint = 16;\n+}"}, {"sha": "8e784bdf22592c5122b99d338e7edffa6772fdf5", "filename": "src/libcore/uint-template/u32b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fu32b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fu32b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu32b.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = u32;\n+    pub const bits: uint = 32;\n+}\n\\ No newline at end of file"}, {"sha": "43a8169f08b45e347e74d2babf3a9bf231b47669", "filename": "src/libcore/uint-template/u64b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fu64b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fu64b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu64b.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = u64;\n+    pub const bits: uint = 64;\n+}\n\\ No newline at end of file"}, {"sha": "a3e750861e57347c18013dc2fe1162ac9191cf4a", "filename": "src/libcore/uint-template/u8b.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fu8b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fu8b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu8b.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,11 @@\n+pub use inst::is_ascii;\n+\n+mod inst {\n+    pub type T = u8;\n+    pub const bits: uint = 8;\n+\n+    // Type-specific functions here. These must be reexported by the\n+    // parent module so that they appear in core::u8 and not core::u8::u8;\n+\n+    pub pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n+}"}, {"sha": "68054d47e1f988da7add538761a4420742e20a99", "filename": "src/libcore/uint-template/uintb.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fuintb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fuint-template%2Fuintb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuintb.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,160 @@\n+pub use inst::{\n+    div_ceil, div_round, div_floor, iterate,\n+    next_power_of_two\n+};\n+\n+mod inst {\n+    pub type T = uint;\n+\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    pub const bits: uint = 32;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub const bits: uint = 64;\n+\n+    /**\n+    * Divide two numbers, return the result, rounded up.\n+    *\n+    * # Arguments\n+    *\n+    * * x - an integer\n+    * * y - an integer distinct from 0u\n+    *\n+    * # Return value\n+    *\n+    * The smallest integer `q` such that `x/y <= q`.\n+    */\n+    pub pure fn div_ceil(x: uint, y: uint) -> uint {\n+        let div = x / y;\n+        if x % y == 0u { div }\n+        else { div + 1u }\n+    }\n+\n+    /**\n+    * Divide two numbers, return the result, rounded to the closest integer.\n+    *\n+    * # Arguments\n+    *\n+    * * x - an integer\n+    * * y - an integer distinct from 0u\n+    *\n+    * # Return value\n+    *\n+    * The integer `q` closest to `x/y`.\n+    */\n+    pub pure fn div_round(x: uint, y: uint) -> uint {\n+        let div = x / y;\n+        if x % y * 2u  < y { div }\n+        else { div + 1u }\n+    }\n+\n+    /**\n+    * Divide two numbers, return the result, rounded down.\n+    *\n+    * Note: This is the same function as `div`.\n+    *\n+    * # Arguments\n+    *\n+    * * x - an integer\n+    * * y - an integer distinct from 0u\n+    *\n+    * # Return value\n+    *\n+    * The smallest integer `q` such that `x/y <= q`. This\n+    * is either `x/y` or `x/y + 1`.\n+    */\n+    pub pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n+\n+    /**\n+    * Iterate over the range [`lo`..`hi`), or stop when requested\n+    *\n+    * # Arguments\n+    *\n+    * * lo - The integer at which to start the loop (included)\n+    * * hi - The integer at which to stop the loop (excluded)\n+    * * it - A block to execute with each consecutive integer of the range.\n+    *        Return `true` to continue, `false` to stop.\n+    *\n+    * # Return value\n+    *\n+    * `true` If execution proceeded correctly, `false` if it was interrupted,\n+    * that is if `it` returned `false` at any point.\n+    */\n+    pub pure fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n+        let mut i = lo;\n+        while i < hi {\n+            if (!it(i)) { return false; }\n+            i += 1u;\n+        }\n+        return true;\n+    }\n+\n+    /// Returns the smallest power of 2 greater than or equal to `n`\n+    #[inline(always)]\n+    pub fn next_power_of_two(n: uint) -> uint {\n+        let halfbits: uint = sys::size_of::<uint>() * 4u;\n+        let mut tmp: uint = n - 1u;\n+        let mut shift: uint = 1u;\n+        while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n+        return tmp + 1u;\n+    }\n+\n+    #[test]\n+    fn test_next_power_of_two() {\n+        assert (uint::next_power_of_two(0u) == 0u);\n+        assert (uint::next_power_of_two(1u) == 1u);\n+        assert (uint::next_power_of_two(2u) == 2u);\n+        assert (uint::next_power_of_two(3u) == 4u);\n+        assert (uint::next_power_of_two(4u) == 4u);\n+        assert (uint::next_power_of_two(5u) == 8u);\n+        assert (uint::next_power_of_two(6u) == 8u);\n+        assert (uint::next_power_of_two(7u) == 8u);\n+        assert (uint::next_power_of_two(8u) == 8u);\n+        assert (uint::next_power_of_two(9u) == 16u);\n+        assert (uint::next_power_of_two(10u) == 16u);\n+        assert (uint::next_power_of_two(11u) == 16u);\n+        assert (uint::next_power_of_two(12u) == 16u);\n+        assert (uint::next_power_of_two(13u) == 16u);\n+        assert (uint::next_power_of_two(14u) == 16u);\n+        assert (uint::next_power_of_two(15u) == 16u);\n+        assert (uint::next_power_of_two(16u) == 16u);\n+        assert (uint::next_power_of_two(17u) == 32u);\n+        assert (uint::next_power_of_two(18u) == 32u);\n+        assert (uint::next_power_of_two(19u) == 32u);\n+        assert (uint::next_power_of_two(20u) == 32u);\n+        assert (uint::next_power_of_two(21u) == 32u);\n+        assert (uint::next_power_of_two(22u) == 32u);\n+        assert (uint::next_power_of_two(23u) == 32u);\n+        assert (uint::next_power_of_two(24u) == 32u);\n+        assert (uint::next_power_of_two(25u) == 32u);\n+        assert (uint::next_power_of_two(26u) == 32u);\n+        assert (uint::next_power_of_two(27u) == 32u);\n+        assert (uint::next_power_of_two(28u) == 32u);\n+        assert (uint::next_power_of_two(29u) == 32u);\n+        assert (uint::next_power_of_two(30u) == 32u);\n+        assert (uint::next_power_of_two(31u) == 32u);\n+        assert (uint::next_power_of_two(32u) == 32u);\n+        assert (uint::next_power_of_two(33u) == 64u);\n+        assert (uint::next_power_of_two(34u) == 64u);\n+        assert (uint::next_power_of_two(35u) == 64u);\n+        assert (uint::next_power_of_two(36u) == 64u);\n+        assert (uint::next_power_of_two(37u) == 64u);\n+        assert (uint::next_power_of_two(38u) == 64u);\n+        assert (uint::next_power_of_two(39u) == 64u);\n+    }\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert (uint::max_value > 0u);\n+        assert (uint::min_value <= 0u);\n+        assert (uint::min_value + uint::max_value + 1u == 0u);\n+    }\n+\n+    #[test]\n+    fn test_div() {\n+        assert(uint::div_floor(3u, 4u) == 0u);\n+        assert(uint::div_ceil(3u, 4u)  == 1u);\n+        assert(uint::div_round(3u, 4u) == 1u);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "805e7b7d82311ea86249a05357a7349532369c01", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 629, "deletions": 0, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -24,6 +24,635 @@ extern mod syntax(vers = \"0.5\");\n \n use core::*;\n \n+use io::WriterUtil;\n+\n+use syntax::{ast, ast_util, fold, visit, codemap};\n+use syntax::parse;\n+use syntax::print::pprust;\n+use syntax::diagnostic;\n+\n+enum test_mode { tm_converge, tm_run, }\n+type context = { mode: test_mode }; // + rng\n+\n+#[cfg(stage0)]\n+impl test_mode : cmp::Eq {\n+    pure fn eq(other: &test_mode) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &test_mode) -> bool { !self.eq(other) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl test_mode : cmp::Eq {\n+    pure fn eq(&self, other: &test_mode) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(&self, other: &test_mode) -> bool { !(*self).eq(other) }\n+}\n+\n+fn write_file(filename: &Path, content: ~str) {\n+    result::get(\n+        &io::file_writer(filename, ~[io::Create, io::Truncate]))\n+        .write_str(content);\n+}\n+\n+fn contains(haystack: ~str, needle: ~str) -> bool {\n+    str::contains(haystack, needle)\n+}\n+\n+fn find_rust_files(files: &mut ~[Path], path: &Path) {\n+    if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n+        // ignoring \"utf8\" tests because something is broken\n+        files.push(*path);\n+    } else if os::path_is_dir(path)\n+        && !contains(path.to_str(), ~\"compile-fail\")\n+        && !contains(path.to_str(), ~\"build\") {\n+        for os::list_dir_path(path).each |p| {\n+            find_rust_files(files, *p);\n+        }\n+    }\n+}\n+\n+\n+fn common_exprs() -> ~[ast::expr] {\n+    fn dse(e: ast::expr_) -> ast::expr {\n+        { id: 0, callee_id: -1, node: e, span: ast_util::dummy_sp() }\n+    }\n+\n+    fn dsl(l: ast::lit_) -> ast::lit {\n+        { node: l, span: ast_util::dummy_sp() }\n+    }\n+\n+    ~[dse(ast::expr_break(option::None)),\n+     dse(ast::expr_again(option::None)),\n+     dse(ast::expr_fail(option::None)),\n+     dse(ast::expr_fail(option::Some(\n+         @dse(ast::expr_lit(@dsl(ast::lit_str(@~\"boo\"))))))),\n+     dse(ast::expr_ret(option::None)),\n+     dse(ast::expr_lit(@dsl(ast::lit_nil))),\n+     dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n+     dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n+     dse(ast::expr_unary(ast::box(ast::m_imm),\n+                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n+     dse(ast::expr_unary(ast::uniq(ast::m_imm),\n+                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n+    ]\n+}\n+\n+pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n+    safe_to_use_expr(*e, tm)\n+}\n+\n+pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n+    match tm {\n+      tm_converge => {\n+        match e.node {\n+          // If the fuzzer moves a block-ending-in-semicolon into callee\n+          // position, the pretty-printer can't preserve this even by\n+          // parenthesizing!!  See email to marijn.\n+          ast::expr_if(*) | ast::expr_block(*)\n+          | ast::expr_match(*) | ast::expr_while(*)  => { false }\n+\n+          // https://github.com/mozilla/rust/issues/929\n+          ast::expr_cast(*) | ast::expr_assert(*) |\n+          ast::expr_binary(*) | ast::expr_assign(*) |\n+          ast::expr_assign_op(*) => { false }\n+\n+          ast::expr_fail(option::None) |\n+          ast::expr_ret(option::None) => { false }\n+\n+          // https://github.com/mozilla/rust/issues/953\n+          ast::expr_fail(option::Some(_)) => { false }\n+\n+          // https://github.com/mozilla/rust/issues/928\n+          //ast::expr_cast(_, _) { false }\n+\n+          // https://github.com/mozilla/rust/issues/1458\n+          ast::expr_call(_, _, _) => { false }\n+\n+          _ => { true }\n+        }\n+      }\n+      tm_run => { true }\n+    }\n+}\n+\n+fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n+    // Restrictions happen to be the same.\n+    safe_to_replace_ty(t.node, tm)\n+}\n+\n+// Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n+fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n+                 es: @mut ~[ast::expr],\n+                 e: @ast::expr,\n+                 tm: test_mode) {\n+    if c(e, tm) {\n+        *es += ~[*e];\n+    } else {/* now my indices are wrong :( */ }\n+}\n+\n+fn stash_ty_if(c: fn@(@ast::Ty, test_mode)->bool,\n+               es: @mut ~[ast::Ty],\n+               e: @ast::Ty,\n+               tm: test_mode) {\n+    if c(e, tm) {\n+        es.push(*e);\n+    } else {/* now my indices are wrong :( */ }\n+}\n+\n+type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::Ty]};\n+\n+fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n+    let exprs = @mut ~[];\n+    let tys = @mut ~[];\n+    let v = visit::mk_simple_visitor(@{\n+        visit_expr: |a| stash_expr_if(safe_to_steal_expr, exprs, a, tm),\n+        visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n+        .. *visit::default_simple_visitor()\n+    });\n+    visit::visit_crate(crate, (), v);\n+    {exprs: *exprs, tys: *tys}\n+}\n+\n+\n+fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n+    match e {\n+      // https://github.com/mozilla/rust/issues/652\n+      ast::expr_if(*) => { false }\n+      ast::expr_block(_) => { false }\n+\n+      // expr_call is also missing a constraint\n+      ast::expr_fn_block(*) => { false }\n+\n+      _ => { true }\n+    }\n+}\n+\n+fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n+    match t {\n+      ast::ty_infer => { false } // always implicit, always top level\n+      ast::ty_bot => { false }   // in source, can only appear\n+                              // as the out type of a function\n+      ast::ty_mac(_) => { false }\n+      _ => { true }\n+    }\n+}\n+\n+// Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n+fn replace_expr_in_crate(crate: ast::crate, i: uint,\n+                         newexpr: ast::expr, tm: test_mode) ->\n+   ast::crate {\n+    let j: @mut uint = @mut 0u;\n+    fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n+                     original: ast::expr_, fld: fold::ast_fold,\n+                     tm_: test_mode) ->\n+       ast::expr_ {\n+        *j_ += 1u;\n+        if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n+            newexpr_\n+        } else {\n+            fold::noop_fold_expr(original, fld)\n+        }\n+    }\n+    let afp = @{\n+        fold_expr: fold::wrap(|a,b| {\n+            fold_expr_rep(j, i, newexpr.node, a, b, tm)\n+        }),\n+        .. *fold::default_ast_fold()\n+    };\n+    let af = fold::make_fold(afp);\n+    let crate2: @ast::crate = @af.fold_crate(crate);\n+    *crate2\n+}\n+\n+\n+// Replace the |i|th ty (in fold order) of |crate| with |newty|.\n+fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n+                       tm: test_mode) -> ast::crate {\n+    let j: @mut uint = @mut 0u;\n+    fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n+                   original: ast::ty_, fld: fold::ast_fold,\n+                   tm_: test_mode) ->\n+       ast::ty_ {\n+        *j_ += 1u;\n+        if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n+            newty_\n+        } else { fold::noop_fold_ty(original, fld) }\n+    }\n+    let afp = @{\n+        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, newty.node, a, b, tm) ),\n+        .. *fold::default_ast_fold()\n+    };\n+    let af = fold::make_fold(afp);\n+    let crate2: @ast::crate = @af.fold_crate(crate);\n+    *crate2\n+}\n+\n+fn under(n: uint, it: fn(uint)) {\n+    let mut i: uint = 0u;\n+    while i < n { it(i); i += 1u; }\n+}\n+\n+fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n+    io::with_str_writer(f)\n+}\n+\n+fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n+                         filename: &Path, cx: context) {\n+    let stolen = steal(crate, cx.mode);\n+    let extra_exprs = vec::filter(common_exprs(),\n+                                  |a| safe_to_use_expr(*a, cx.mode) );\n+    check_variants_T(crate, codemap, filename, ~\"expr\",\n+                     extra_exprs + stolen.exprs, pprust::expr_to_str,\n+                     replace_expr_in_crate, cx);\n+    check_variants_T(crate, codemap, filename, ~\"ty\", stolen.tys,\n+                     pprust::ty_to_str, replace_ty_in_crate, cx);\n+}\n+\n+fn check_variants_T<T: Copy>(\n+  crate: ast::crate,\n+  codemap: @codemap::CodeMap,\n+  filename: &Path,\n+  thing_label: ~str,\n+  things: ~[T],\n+  stringifier: fn@(@T, @syntax::parse::token::ident_interner) -> ~str,\n+  replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n+  cx: context\n+  ) {\n+    error!(\"%s contains %u %s objects\", filename.to_str(),\n+           things.len(), thing_label);\n+\n+    // Assuming we're not generating any token_trees\n+    let intr = syntax::parse::token::mk_fake_ident_interner();\n+\n+    let L = things.len();\n+\n+    if L < 100 {\n+        do under(uint::min(L, 20)) |i| {\n+            log(error, ~\"Replacing... #\" + uint::str(i));\n+            let fname = str::from_slice(filename.to_str());\n+            do under(uint::min(L, 30)) |j| {\n+                log(error, ~\"With... \" + stringifier(@things[j], intr));\n+                let crate2 = @replacer(crate, i, things[j], cx.mode);\n+                // It would be best to test the *crate* for stability, but\n+                // testing the string for stability is easier and ok for now.\n+                let handler = diagnostic::mk_handler(None);\n+                let str3 = do io::with_str_reader(\"\") |rdr| {\n+                    @as_str(|a|pprust::print_crate(\n+                        codemap,\n+                        intr,\n+                        diagnostic::mk_span_handler(handler, codemap),\n+                        crate2,\n+                        fname,\n+                        rdr, a,\n+                        pprust::no_ann(),\n+                        false))\n+                };\n+                match cx.mode {\n+                  tm_converge => {\n+                    check_roundtrip_convergence(str3, 1u);\n+                  }\n+                  tm_run => {\n+                    let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n+                                          last_part(filename.to_str()),\n+                                          thing_label, i, j);\n+                    let safe_to_run = !(content_is_dangerous_to_run(*str3)\n+                                        || has_raw_pointers(*crate2));\n+                    check_whole_compiler(*str3, &Path(file_label),\n+                                         safe_to_run);\n+                  }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn last_part(filename: ~str) -> ~str {\n+  let ix = option::get(str::rfind_char(filename, '/'));\n+  str::slice(filename, ix + 1u, str::len(filename) - 3u)\n+}\n+\n+enum happiness {\n+    passed,\n+    cleanly_rejected(~str),\n+    known_bug(~str),\n+    failed(~str),\n+}\n+\n+// We'd find more bugs if we could take an AST here, but\n+// - that would find many \"false positives\" or unimportant bugs\n+// - that would be tricky, requiring use of tasks or serialization\n+//   or randomness.\n+// This seems to find plenty of bugs as it is :)\n+fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n+                        allow_running: bool) {\n+    let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n+    write_file(filename, code);\n+\n+    let compile_result = check_compiling(filename);\n+\n+    let run_result = match (compile_result, allow_running) {\n+      (passed, true) => { check_running(suggested_filename_prefix) }\n+      (h, _) => { h }\n+    };\n+\n+    match run_result {\n+      passed | cleanly_rejected(_) | known_bug(_) => {\n+        removeIfExists(suggested_filename_prefix);\n+        removeIfExists(&suggested_filename_prefix.with_filetype(\"rs\"));\n+        removeDirIfExists(&suggested_filename_prefix.with_filetype(\"dSYM\"));\n+      }\n+      failed(s) => {\n+        log(error, ~\"check_whole_compiler failure: \" + s);\n+        log(error, ~\"Saved as: \" + filename.to_str());\n+      }\n+    }\n+}\n+\n+fn removeIfExists(filename: &Path) {\n+    // So sketchy!\n+    assert !contains(filename.to_str(), ~\" \");\n+    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n+}\n+\n+fn removeDirIfExists(filename: &Path) {\n+    // So sketchy!\n+    assert !contains(filename.to_str(), ~\" \");\n+    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n+}\n+\n+fn check_running(exe_filename: &Path) -> happiness {\n+    let p = run::program_output(\n+        ~\"/Users/jruderman/scripts/timed_run_rust_program.py\",\n+        ~[exe_filename.to_str()]);\n+    let comb = p.out + ~\"\\n\" + p.err;\n+    if str::len(comb) > 1u {\n+        log(error, ~\"comb comb comb: \" + comb);\n+    }\n+\n+    if contains(comb, ~\"Assertion failed:\") {\n+        failed(~\"C++ assertion failure\")\n+    } else if contains(comb, ~\"leaked memory in rust main loop\") {\n+        // might also use exit code 134\n+        //failed(\"Leaked\")\n+        known_bug(~\"https://github.com/mozilla/rust/issues/910\")\n+    } else if contains(comb, ~\"src/rt/\") {\n+        failed(~\"Mentioned src/rt/\")\n+    } else if contains(comb, ~\"malloc\") {\n+        failed(~\"Mentioned malloc\")\n+    } else {\n+        match p.status {\n+            0         => { passed }\n+            100       => { cleanly_rejected(~\"running: explicit fail\") }\n+            101 | 247 => { cleanly_rejected(~\"running: timed out\") }\n+            245 | 246 | 138 | 252 => {\n+              known_bug(~\"https://github.com/mozilla/rust/issues/1466\")\n+            }\n+            136 | 248 => {\n+              known_bug(\n+                  ~\"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n+            }\n+            rc => {\n+              failed(~\"Rust program ran but exited with status \" +\n+                     int::str(rc))\n+            }\n+        }\n+    }\n+}\n+\n+fn check_compiling(filename: &Path) -> happiness {\n+    let p = run::program_output(\n+        ~\"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n+         stage1/bin/rustc\",\n+        ~[filename.to_str()]);\n+\n+    //error!(\"Status: %d\", p.status);\n+    if p.status == 0 {\n+        passed\n+    } else if p.err != ~\"\" {\n+        if contains(p.err, ~\"error:\") {\n+            cleanly_rejected(~\"rejected with span_error\")\n+        } else {\n+            log(error, ~\"Stderr: \" + p.err);\n+            failed(~\"Unfamiliar error message\")\n+        }\n+    } else if contains(p.out, ~\"Assertion\") && contains(p.out, ~\"failed\") {\n+        log(error, ~\"Stdout: \" + p.out);\n+        failed(~\"Looks like an llvm assertion failure\")\n+    } else if contains(p.out, ~\"internal compiler error unimplemented\") {\n+        known_bug(~\"Something unimplemented\")\n+    } else if contains(p.out, ~\"internal compiler error\") {\n+        log(error, ~\"Stdout: \" + p.out);\n+        failed(~\"internal compiler error\")\n+\n+    } else {\n+        log(error, p.status);\n+        log(error, ~\"!Stdout: \" + p.out);\n+        failed(~\"What happened?\")\n+    }\n+}\n+\n+\n+fn parse_and_print(code: @~str) -> ~str {\n+    let filename = Path(\"tmp.rs\");\n+    let sess = parse::new_parse_sess(option::None);\n+    write_file(&filename, *code);\n+    let crate = parse::parse_crate_from_source_str(\n+        filename.to_str(), code, ~[], sess);\n+    do io::with_str_reader(*code) |rdr| {\n+        as_str(|a|\n+               pprust::print_crate(\n+                   sess.cm,\n+                   // Assuming there are no token_trees\n+                   syntax::parse::token::mk_fake_ident_interner(),\n+                   sess.span_diagnostic,\n+                   crate,\n+                   filename.to_str(),\n+                   rdr, a,\n+                   pprust::no_ann(),\n+                   false) )\n+    }\n+}\n+\n+fn has_raw_pointers(c: ast::crate) -> bool {\n+    let has_rp = @mut false;\n+    fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n+        match t.node {\n+          ast::ty_ptr(_) => { *flag = true; }\n+          _ => { }\n+        }\n+    }\n+    let v =\n+        visit::mk_simple_visitor(@{visit_ty: |a| visit_ty(has_rp, a),\n+                                      .. *visit::default_simple_visitor()});\n+    visit::visit_crate(c, (), v);\n+    return *has_rp;\n+}\n+\n+fn content_is_dangerous_to_run(code: ~str) -> bool {\n+    let dangerous_patterns =\n+        ~[~\"xfail-test\",\n+         ~\"import\",  // espeically fs, run\n+         ~\"extern\",\n+         ~\"unsafe\",\n+         ~\"log\"];    // python --> rust pipe deadlock?\n+\n+    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n+    return false;\n+}\n+\n+fn content_is_dangerous_to_compile(code: ~str) -> bool {\n+    let dangerous_patterns =\n+        ~[~\"xfail-test\"];\n+\n+    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n+    return false;\n+}\n+\n+fn content_might_not_converge(code: ~str) -> bool {\n+    let confusing_patterns =\n+        ~[~\"xfail-test\",\n+         ~\"xfail-pretty\",\n+         ~\"self\",       // crazy rules enforced by parser not typechecker?\n+         ~\"spawn\",      // precedence issues?\n+         ~\"bind\",       // precedence issues?\n+         ~\" be \",       // don't want to replace its child with a non-call:\n+                       // \"Non-call expression in tail call\"\n+         ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n+        ];\n+\n+    for confusing_patterns.each |p| { if contains(code, *p) { return true; } }\n+    return false;\n+}\n+\n+fn file_might_not_converge(filename: &Path) -> bool {\n+    let confusing_files = ~[\n+      ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n+                     // vs \"a = b = c\" and wrapping\n+      ~\"block-arg-in-ternary.rs\", // wrapping\n+      ~\"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n+      ~\"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n+    ];\n+\n+\n+    for confusing_files.each |f| {\n+        if contains(filename.to_str(), *f) {\n+            return true;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n+\n+    let mut i = 0u;\n+    let mut newv = code;\n+    let mut oldv = code;\n+\n+    while i < maxIters {\n+        oldv = newv;\n+        if content_might_not_converge(*oldv) { return; }\n+        newv = @parse_and_print(oldv);\n+        if oldv == newv { break; }\n+        i += 1u;\n+    }\n+\n+    if oldv == newv {\n+        error!(\"Converged after %u iterations\", i);\n+    } else {\n+        error!(\"Did not converge after %u iterations!\", i);\n+        write_file(&Path(\"round-trip-a.rs\"), *oldv);\n+        write_file(&Path(\"round-trip-b.rs\"), *newv);\n+        run::run_program(~\"diff\",\n+                         ~[~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n+                          ~\"round-trip-b.rs\"]);\n+        fail ~\"Mismatch\";\n+    }\n+}\n+\n+fn check_convergence(files: &[Path]) {\n+    error!(\"pp convergence tests: %u files\", vec::len(files));\n+    for files.each |file| {\n+        if !file_might_not_converge(file) {\n+            let s = @result::get(&io::read_whole_file_str(file));\n+            if !content_might_not_converge(*s) {\n+                error!(\"pp converge: %s\", file.to_str());\n+                // Change from 7u to 2u once\n+                // https://github.com/mozilla/rust/issues/850 is fixed\n+                check_roundtrip_convergence(s, 7u);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_variants(files: &[Path], cx: context) {\n+    for files.each |file| {\n+        if cx.mode == tm_converge &&\n+            file_might_not_converge(file) {\n+            error!(\"Skipping convergence test based on\\\n+                    file_might_not_converge\");\n+            loop;\n+        }\n+\n+        let s = @result::get(&io::read_whole_file_str(file));\n+        if contains(*s, ~\"#\") {\n+            loop; // Macros are confusing\n+        }\n+        if cx.mode == tm_converge && content_might_not_converge(*s) {\n+            loop;\n+        }\n+        if cx.mode == tm_run && content_is_dangerous_to_compile(*s) {\n+            loop;\n+        }\n+\n+        let file_str = file.to_str();\n+\n+        log(error, ~\"check_variants: \" + file_str);\n+        let sess = parse::new_parse_sess(option::None);\n+        let crate =\n+            parse::parse_crate_from_source_str(\n+                file_str,\n+                s, ~[], sess);\n+        io::with_str_reader(*s, |rdr| {\n+            error!(\"%s\",\n+                   as_str(|a| pprust::print_crate(\n+                       sess.cm,\n+                       // Assuming no token_trees\n+                       syntax::parse::token::mk_fake_ident_interner(),\n+                       sess.span_diagnostic,\n+                       crate,\n+                       file_str,\n+                       rdr, a,\n+                       pprust::no_ann(),\n+                       false)))\n+        });\n+        check_variants_of_ast(*crate, sess.cm, file, cx);\n+    }\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    if vec::len(args) != 2u {\n+        error!(\"usage: %s <testdir>\", args[0]);\n+        return;\n+    }\n+    let mut files = ~[];\n+    let root = Path(args[1]);\n+\n+    find_rust_files(&mut files, &root);\n+    error!(\"== check_convergence ==\");\n+    check_convergence(files);\n+    error!(\"== check_variants: converge ==\");\n+    check_variants(files, { mode: tm_converge });\n+    error!(\"== check_variants: run ==\");\n+    check_variants(files, { mode: tm_run });\n+\n+    error!(\"Fuzzer done\");\n+}\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "652837909b14acc2dce98e2e837f0c2a771c43ac", "filename": "src/libfuzzer/fuzzer.rs", "status": "removed", "additions": 0, "deletions": 638, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Flibfuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Flibfuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,638 +0,0 @@\n-#[legacy_exports];\n-\n-use io::WriterUtil;\n-\n-use syntax::{ast, ast_util, fold, visit, codemap};\n-use syntax::parse;\n-use syntax::print::pprust;\n-use syntax::diagnostic;\n-\n-enum test_mode { tm_converge, tm_run, }\n-type context = { mode: test_mode }; // + rng\n-\n-#[cfg(stage0)]\n-impl test_mode : cmp::Eq {\n-    pure fn eq(other: &test_mode) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(other: &test_mode) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-impl test_mode : cmp::Eq {\n-    pure fn eq(&self, other: &test_mode) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &test_mode) -> bool { !(*self).eq(other) }\n-}\n-\n-fn write_file(filename: &Path, content: ~str) {\n-    result::get(\n-        &io::file_writer(filename, ~[io::Create, io::Truncate]))\n-        .write_str(content);\n-}\n-\n-fn contains(haystack: ~str, needle: ~str) -> bool {\n-    str::contains(haystack, needle)\n-}\n-\n-fn find_rust_files(files: &mut ~[Path], path: &Path) {\n-    if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n-        // ignoring \"utf8\" tests because something is broken\n-        files.push(*path);\n-    } else if os::path_is_dir(path)\n-        && !contains(path.to_str(), ~\"compile-fail\")\n-        && !contains(path.to_str(), ~\"build\") {\n-        for os::list_dir_path(path).each |p| {\n-            find_rust_files(files, *p);\n-        }\n-    }\n-}\n-\n-\n-fn common_exprs() -> ~[ast::expr] {\n-    fn dse(e: ast::expr_) -> ast::expr {\n-        { id: 0, callee_id: -1, node: e, span: ast_util::dummy_sp() }\n-    }\n-\n-    fn dsl(l: ast::lit_) -> ast::lit {\n-        { node: l, span: ast_util::dummy_sp() }\n-    }\n-\n-    ~[dse(ast::expr_break(option::None)),\n-     dse(ast::expr_again(option::None)),\n-     dse(ast::expr_fail(option::None)),\n-     dse(ast::expr_fail(option::Some(\n-         @dse(ast::expr_lit(@dsl(ast::lit_str(@~\"boo\"))))))),\n-     dse(ast::expr_ret(option::None)),\n-     dse(ast::expr_lit(@dsl(ast::lit_nil))),\n-     dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n-     dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n-     dse(ast::expr_unary(ast::box(ast::m_imm),\n-                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n-     dse(ast::expr_unary(ast::uniq(ast::m_imm),\n-                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n-    ]\n-}\n-\n-pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n-    safe_to_use_expr(*e, tm)\n-}\n-\n-pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n-    match tm {\n-      tm_converge => {\n-        match e.node {\n-          // If the fuzzer moves a block-ending-in-semicolon into callee\n-          // position, the pretty-printer can't preserve this even by\n-          // parenthesizing!!  See email to marijn.\n-          ast::expr_if(*) | ast::expr_block(*)\n-          | ast::expr_match(*) | ast::expr_while(*)  => { false }\n-\n-          // https://github.com/mozilla/rust/issues/929\n-          ast::expr_cast(*) | ast::expr_assert(*) |\n-          ast::expr_binary(*) | ast::expr_assign(*) |\n-          ast::expr_assign_op(*) => { false }\n-\n-          ast::expr_fail(option::None) |\n-          ast::expr_ret(option::None) => { false }\n-\n-          // https://github.com/mozilla/rust/issues/953\n-          ast::expr_fail(option::Some(_)) => { false }\n-\n-          // https://github.com/mozilla/rust/issues/928\n-          //ast::expr_cast(_, _) { false }\n-\n-          // https://github.com/mozilla/rust/issues/1458\n-          ast::expr_call(_, _, _) => { false }\n-\n-          _ => { true }\n-        }\n-      }\n-      tm_run => { true }\n-    }\n-}\n-\n-fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n-    // Restrictions happen to be the same.\n-    safe_to_replace_ty(t.node, tm)\n-}\n-\n-// Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n-fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n-                 es: @mut ~[ast::expr],\n-                 e: @ast::expr,\n-                 tm: test_mode) {\n-    if c(e, tm) {\n-        *es += ~[*e];\n-    } else {/* now my indices are wrong :( */ }\n-}\n-\n-fn stash_ty_if(c: fn@(@ast::Ty, test_mode)->bool,\n-               es: @mut ~[ast::Ty],\n-               e: @ast::Ty,\n-               tm: test_mode) {\n-    if c(e, tm) {\n-        es.push(*e);\n-    } else {/* now my indices are wrong :( */ }\n-}\n-\n-type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::Ty]};\n-\n-fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n-    let exprs = @mut ~[];\n-    let tys = @mut ~[];\n-    let v = visit::mk_simple_visitor(@{\n-        visit_expr: |a| stash_expr_if(safe_to_steal_expr, exprs, a, tm),\n-        visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n-        .. *visit::default_simple_visitor()\n-    });\n-    visit::visit_crate(crate, (), v);\n-    {exprs: *exprs, tys: *tys}\n-}\n-\n-\n-fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n-    match e {\n-      // https://github.com/mozilla/rust/issues/652\n-      ast::expr_if(*) => { false }\n-      ast::expr_block(_) => { false }\n-\n-      // expr_call is also missing a constraint\n-      ast::expr_fn_block(*) => { false }\n-\n-      _ => { true }\n-    }\n-}\n-\n-fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n-    match t {\n-      ast::ty_infer => { false } // always implicit, always top level\n-      ast::ty_bot => { false }   // in source, can only appear\n-                              // as the out type of a function\n-      ast::ty_mac(_) => { false }\n-      _ => { true }\n-    }\n-}\n-\n-// Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-fn replace_expr_in_crate(crate: ast::crate, i: uint,\n-                         newexpr: ast::expr, tm: test_mode) ->\n-   ast::crate {\n-    let j: @mut uint = @mut 0u;\n-    fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n-                     original: ast::expr_, fld: fold::ast_fold,\n-                     tm_: test_mode) ->\n-       ast::expr_ {\n-        *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n-            newexpr_\n-        } else {\n-            fold::noop_fold_expr(original, fld)\n-        }\n-    }\n-    let afp = @{\n-        fold_expr: fold::wrap(|a,b| {\n-            fold_expr_rep(j, i, newexpr.node, a, b, tm)\n-        }),\n-        .. *fold::default_ast_fold()\n-    };\n-    let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n-    *crate2\n-}\n-\n-\n-// Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n-                       tm: test_mode) -> ast::crate {\n-    let j: @mut uint = @mut 0u;\n-    fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n-                   original: ast::ty_, fld: fold::ast_fold,\n-                   tm_: test_mode) ->\n-       ast::ty_ {\n-        *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n-            newty_\n-        } else { fold::noop_fold_ty(original, fld) }\n-    }\n-    let afp = @{\n-        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, newty.node, a, b, tm) ),\n-        .. *fold::default_ast_fold()\n-    };\n-    let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n-    *crate2\n-}\n-\n-fn under(n: uint, it: fn(uint)) {\n-    let mut i: uint = 0u;\n-    while i < n { it(i); i += 1u; }\n-}\n-\n-fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n-    io::with_str_writer(f)\n-}\n-\n-fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n-                         filename: &Path, cx: context) {\n-    let stolen = steal(crate, cx.mode);\n-    let extra_exprs = vec::filter(common_exprs(),\n-                                  |a| safe_to_use_expr(*a, cx.mode) );\n-    check_variants_T(crate, codemap, filename, ~\"expr\",\n-                     extra_exprs + stolen.exprs, pprust::expr_to_str,\n-                     replace_expr_in_crate, cx);\n-    check_variants_T(crate, codemap, filename, ~\"ty\", stolen.tys,\n-                     pprust::ty_to_str, replace_ty_in_crate, cx);\n-}\n-\n-fn check_variants_T<T: Copy>(\n-  crate: ast::crate,\n-  codemap: @codemap::CodeMap,\n-  filename: &Path,\n-  thing_label: ~str,\n-  things: ~[T],\n-  stringifier: fn@(@T, @syntax::parse::token::ident_interner) -> ~str,\n-  replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n-  cx: context\n-  ) {\n-    error!(\"%s contains %u %s objects\", filename.to_str(),\n-           things.len(), thing_label);\n-\n-    // Assuming we're not generating any token_trees\n-    let intr = syntax::parse::token::mk_fake_ident_interner();\n-\n-    let L = things.len();\n-\n-    if L < 100 {\n-        do under(uint::min(L, 20)) |i| {\n-            log(error, ~\"Replacing... #\" + uint::str(i));\n-            let fname = str::from_slice(filename.to_str());\n-            do under(uint::min(L, 30)) |j| {\n-                log(error, ~\"With... \" + stringifier(@things[j], intr));\n-                let crate2 = @replacer(crate, i, things[j], cx.mode);\n-                // It would be best to test the *crate* for stability, but\n-                // testing the string for stability is easier and ok for now.\n-                let handler = diagnostic::mk_handler(None);\n-                let str3 = do io::with_str_reader(\"\") |rdr| {\n-                    @as_str(|a|pprust::print_crate(\n-                        codemap,\n-                        intr,\n-                        diagnostic::mk_span_handler(handler, codemap),\n-                        crate2,\n-                        fname,\n-                        rdr, a,\n-                        pprust::no_ann(),\n-                        false))\n-                };\n-                match cx.mode {\n-                  tm_converge => {\n-                    check_roundtrip_convergence(str3, 1u);\n-                  }\n-                  tm_run => {\n-                    let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n-                                          last_part(filename.to_str()),\n-                                          thing_label, i, j);\n-                    let safe_to_run = !(content_is_dangerous_to_run(*str3)\n-                                        || has_raw_pointers(*crate2));\n-                    check_whole_compiler(*str3, &Path(file_label),\n-                                         safe_to_run);\n-                  }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn last_part(filename: ~str) -> ~str {\n-  let ix = option::get(str::rfind_char(filename, '/'));\n-  str::slice(filename, ix + 1u, str::len(filename) - 3u)\n-}\n-\n-enum happiness {\n-    passed,\n-    cleanly_rejected(~str),\n-    known_bug(~str),\n-    failed(~str),\n-}\n-\n-// We'd find more bugs if we could take an AST here, but\n-// - that would find many \"false positives\" or unimportant bugs\n-// - that would be tricky, requiring use of tasks or serialization\n-//   or randomness.\n-// This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n-                        allow_running: bool) {\n-    let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n-    write_file(filename, code);\n-\n-    let compile_result = check_compiling(filename);\n-\n-    let run_result = match (compile_result, allow_running) {\n-      (passed, true) => { check_running(suggested_filename_prefix) }\n-      (h, _) => { h }\n-    };\n-\n-    match run_result {\n-      passed | cleanly_rejected(_) | known_bug(_) => {\n-        removeIfExists(suggested_filename_prefix);\n-        removeIfExists(&suggested_filename_prefix.with_filetype(\"rs\"));\n-        removeDirIfExists(&suggested_filename_prefix.with_filetype(\"dSYM\"));\n-      }\n-      failed(s) => {\n-        log(error, ~\"check_whole_compiler failure: \" + s);\n-        log(error, ~\"Saved as: \" + filename.to_str());\n-      }\n-    }\n-}\n-\n-fn removeIfExists(filename: &Path) {\n-    // So sketchy!\n-    assert !contains(filename.to_str(), ~\" \");\n-    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n-}\n-\n-fn removeDirIfExists(filename: &Path) {\n-    // So sketchy!\n-    assert !contains(filename.to_str(), ~\" \");\n-    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n-}\n-\n-fn check_running(exe_filename: &Path) -> happiness {\n-    let p = run::program_output(\n-        ~\"/Users/jruderman/scripts/timed_run_rust_program.py\",\n-        ~[exe_filename.to_str()]);\n-    let comb = p.out + ~\"\\n\" + p.err;\n-    if str::len(comb) > 1u {\n-        log(error, ~\"comb comb comb: \" + comb);\n-    }\n-\n-    if contains(comb, ~\"Assertion failed:\") {\n-        failed(~\"C++ assertion failure\")\n-    } else if contains(comb, ~\"leaked memory in rust main loop\") {\n-        // might also use exit code 134\n-        //failed(\"Leaked\")\n-        known_bug(~\"https://github.com/mozilla/rust/issues/910\")\n-    } else if contains(comb, ~\"src/rt/\") {\n-        failed(~\"Mentioned src/rt/\")\n-    } else if contains(comb, ~\"malloc\") {\n-        failed(~\"Mentioned malloc\")\n-    } else {\n-        match p.status {\n-            0         => { passed }\n-            100       => { cleanly_rejected(~\"running: explicit fail\") }\n-            101 | 247 => { cleanly_rejected(~\"running: timed out\") }\n-            245 | 246 | 138 | 252 => {\n-              known_bug(~\"https://github.com/mozilla/rust/issues/1466\")\n-            }\n-            136 | 248 => {\n-              known_bug(\n-                  ~\"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n-            }\n-            rc => {\n-              failed(~\"Rust program ran but exited with status \" +\n-                     int::str(rc))\n-            }\n-        }\n-    }\n-}\n-\n-fn check_compiling(filename: &Path) -> happiness {\n-    let p = run::program_output(\n-        ~\"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n-         stage1/bin/rustc\",\n-        ~[filename.to_str()]);\n-\n-    //error!(\"Status: %d\", p.status);\n-    if p.status == 0 {\n-        passed\n-    } else if p.err != ~\"\" {\n-        if contains(p.err, ~\"error:\") {\n-            cleanly_rejected(~\"rejected with span_error\")\n-        } else {\n-            log(error, ~\"Stderr: \" + p.err);\n-            failed(~\"Unfamiliar error message\")\n-        }\n-    } else if contains(p.out, ~\"Assertion\") && contains(p.out, ~\"failed\") {\n-        log(error, ~\"Stdout: \" + p.out);\n-        failed(~\"Looks like an llvm assertion failure\")\n-    } else if contains(p.out, ~\"internal compiler error unimplemented\") {\n-        known_bug(~\"Something unimplemented\")\n-    } else if contains(p.out, ~\"internal compiler error\") {\n-        log(error, ~\"Stdout: \" + p.out);\n-        failed(~\"internal compiler error\")\n-\n-    } else {\n-        log(error, p.status);\n-        log(error, ~\"!Stdout: \" + p.out);\n-        failed(~\"What happened?\")\n-    }\n-}\n-\n-\n-fn parse_and_print(code: @~str) -> ~str {\n-    let filename = Path(\"tmp.rs\");\n-    let sess = parse::new_parse_sess(option::None);\n-    write_file(&filename, *code);\n-    let crate = parse::parse_crate_from_source_str(\n-        filename.to_str(), code, ~[], sess);\n-    do io::with_str_reader(*code) |rdr| {\n-        as_str(|a|\n-               pprust::print_crate(\n-                   sess.cm,\n-                   // Assuming there are no token_trees\n-                   syntax::parse::token::mk_fake_ident_interner(),\n-                   sess.span_diagnostic,\n-                   crate,\n-                   filename.to_str(),\n-                   rdr, a,\n-                   pprust::no_ann(),\n-                   false) )\n-    }\n-}\n-\n-fn has_raw_pointers(c: ast::crate) -> bool {\n-    let has_rp = @mut false;\n-    fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n-        match t.node {\n-          ast::ty_ptr(_) => { *flag = true; }\n-          _ => { }\n-        }\n-    }\n-    let v =\n-        visit::mk_simple_visitor(@{visit_ty: |a| visit_ty(has_rp, a),\n-                                      .. *visit::default_simple_visitor()});\n-    visit::visit_crate(c, (), v);\n-    return *has_rp;\n-}\n-\n-fn content_is_dangerous_to_run(code: ~str) -> bool {\n-    let dangerous_patterns =\n-        ~[~\"xfail-test\",\n-         ~\"import\",  // espeically fs, run\n-         ~\"extern\",\n-         ~\"unsafe\",\n-         ~\"log\"];    // python --> rust pipe deadlock?\n-\n-    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-fn content_is_dangerous_to_compile(code: ~str) -> bool {\n-    let dangerous_patterns =\n-        ~[~\"xfail-test\"];\n-\n-    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-fn content_might_not_converge(code: ~str) -> bool {\n-    let confusing_patterns =\n-        ~[~\"xfail-test\",\n-         ~\"xfail-pretty\",\n-         ~\"self\",       // crazy rules enforced by parser not typechecker?\n-         ~\"spawn\",      // precedence issues?\n-         ~\"bind\",       // precedence issues?\n-         ~\" be \",       // don't want to replace its child with a non-call:\n-                       // \"Non-call expression in tail call\"\n-         ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n-        ];\n-\n-    for confusing_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-fn file_might_not_converge(filename: &Path) -> bool {\n-    let confusing_files = ~[\n-      ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n-                     // vs \"a = b = c\" and wrapping\n-      ~\"block-arg-in-ternary.rs\", // wrapping\n-      ~\"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n-      ~\"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n-    ];\n-\n-\n-    for confusing_files.each |f| {\n-        if contains(filename.to_str(), *f) {\n-            return true;\n-        }\n-    }\n-\n-    return false;\n-}\n-\n-fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n-\n-    let mut i = 0u;\n-    let mut newv = code;\n-    let mut oldv = code;\n-\n-    while i < maxIters {\n-        oldv = newv;\n-        if content_might_not_converge(*oldv) { return; }\n-        newv = @parse_and_print(oldv);\n-        if oldv == newv { break; }\n-        i += 1u;\n-    }\n-\n-    if oldv == newv {\n-        error!(\"Converged after %u iterations\", i);\n-    } else {\n-        error!(\"Did not converge after %u iterations!\", i);\n-        write_file(&Path(\"round-trip-a.rs\"), *oldv);\n-        write_file(&Path(\"round-trip-b.rs\"), *newv);\n-        run::run_program(~\"diff\",\n-                         ~[~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n-                          ~\"round-trip-b.rs\"]);\n-        fail ~\"Mismatch\";\n-    }\n-}\n-\n-fn check_convergence(files: &[Path]) {\n-    error!(\"pp convergence tests: %u files\", vec::len(files));\n-    for files.each |file| {\n-        if !file_might_not_converge(file) {\n-            let s = @result::get(&io::read_whole_file_str(file));\n-            if !content_might_not_converge(*s) {\n-                error!(\"pp converge: %s\", file.to_str());\n-                // Change from 7u to 2u once\n-                // https://github.com/mozilla/rust/issues/850 is fixed\n-                check_roundtrip_convergence(s, 7u);\n-            }\n-        }\n-    }\n-}\n-\n-fn check_variants(files: &[Path], cx: context) {\n-    for files.each |file| {\n-        if cx.mode == tm_converge &&\n-            file_might_not_converge(file) {\n-            error!(\"Skipping convergence test based on\\\n-                    file_might_not_converge\");\n-            loop;\n-        }\n-\n-        let s = @result::get(&io::read_whole_file_str(file));\n-        if contains(*s, ~\"#\") {\n-            loop; // Macros are confusing\n-        }\n-        if cx.mode == tm_converge && content_might_not_converge(*s) {\n-            loop;\n-        }\n-        if cx.mode == tm_run && content_is_dangerous_to_compile(*s) {\n-            loop;\n-        }\n-\n-        let file_str = file.to_str();\n-\n-        log(error, ~\"check_variants: \" + file_str);\n-        let sess = parse::new_parse_sess(option::None);\n-        let crate =\n-            parse::parse_crate_from_source_str(\n-                file_str,\n-                s, ~[], sess);\n-        io::with_str_reader(*s, |rdr| {\n-            error!(\"%s\",\n-                   as_str(|a| pprust::print_crate(\n-                       sess.cm,\n-                       // Assuming no token_trees\n-                       syntax::parse::token::mk_fake_ident_interner(),\n-                       sess.span_diagnostic,\n-                       crate,\n-                       file_str,\n-                       rdr, a,\n-                       pprust::no_ann(),\n-                       false)))\n-        });\n-        check_variants_of_ast(*crate, sess.cm, file, cx);\n-    }\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    if vec::len(args) != 2u {\n-        error!(\"usage: %s <testdir>\", args[0]);\n-        return;\n-    }\n-    let mut files = ~[];\n-    let root = Path(args[1]);\n-\n-    find_rust_files(&mut files, &root);\n-    error!(\"== check_convergence ==\");\n-    check_convergence(files);\n-    error!(\"== check_variants: converge ==\");\n-    check_variants(files, { mode: tm_converge });\n-    error!(\"== check_variants: run ==\");\n-    check_variants(files, { mode: tm_run });\n-\n-    error!(\"Fuzzer done\");\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "1d2d0c1f77ca689aef972f1be1f3438489880a50", "filename": "src/librustc/alternate_crate.rc", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Falternate_crate.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Falternate_crate.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Falternate_crate.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,501 @@\n+// -*- rust -*-\n+\n+#[link(name = \"rustc\",\n+       vers = \"0.5\",\n+       uuid = \"0ce89b41-2f92-459e-bbc1-8f5fe32f16cf\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/rustc\")];\n+\n+#[comment = \"The Rust compiler\"];\n+#[license = \"MIT\"];\n+#[crate_type = \"lib\"];\n+\n+#[no_core];\n+\n+#[legacy_modes];\n+#[legacy_exports];\n+\n+#[allow(vecs_implicitly_copyable)];\n+#[allow(non_camel_case_types)];\n+#[allow(deprecated_mode)];\n+#[allow(deprecated_pattern)];\n+\n+extern mod core(vers = \"0.5\");\n+extern mod std(vers = \"0.5\");\n+extern mod syntax(vers = \"0.5\");\n+\n+use core::*;\n+\n+/*\n+Alternate names for some modules.\n+\n+I am using this to help extract metadata into its own crate. In metadata.rs\n+it redefines all these modules in order to gate access from metadata to the\n+rest of the compiler, then uses these to access the original implementation.\n+*/\n+use util_ = util;\n+use lib_ = lib;\n+use driver_ = driver;\n+use middle_ = middle;\n+use back_ = back;\n+\n+mod middle {\n+    #[legacy_exports];\n+    mod trans {\n+        #[legacy_exports];\n+        #[legacy_exports]\n+        #[path = \"middle/trans/inline.rs\"]\n+        mod inline;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/monomorphize.rs\"]\n+        mod monomorphize;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/controlflow.rs\"]\n+        mod controlflow;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/glue.rs\"]\n+        mod glue;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/datum.rs\"]\n+        mod datum;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/callee.rs\"]\n+        mod callee;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/expr.rs\"]\n+        mod expr;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/common.rs\"]\n+        mod common;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/consts.rs\"]\n+        mod consts;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/type_of.rs\"]\n+        mod type_of;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/build.rs\"]\n+        mod build;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/base.rs\"]\n+        mod base;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/alt.rs\"]\n+        mod alt;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/uniq.rs\"]\n+        mod uniq;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/closure.rs\"]\n+        mod closure;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/tvec.rs\"]\n+        mod tvec;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/meth.rs\"]\n+        mod meth;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/foreign.rs\"]\n+        mod foreign;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/reflect.rs\"]\n+        mod reflect;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/shape.rs\"]\n+        mod shape;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/debuginfo.rs\"]\n+        mod debuginfo;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/type_use.rs\"]\n+        mod type_use;\n+        #[legacy_exports]\n+        #[path = \"middle/trans/reachable.rs\"]\n+        mod reachable;\n+        #[path = \"middle/trans/machine.rs\"]\n+        mod machine;\n+        #[path = \"middle/trans/deriving.rs\"]\n+        mod deriving;\n+    }\n+    #[legacy_exports]\n+    #[path = \"middle/ty.rs\"]\n+    mod ty;\n+    #[legacy_exports]\n+    #[path = \"middle/resolve.rs\"]\n+    mod resolve;\n+    #[path = \"middle/typeck.rs\"]\n+    #[merge = \"middle/typeck/mod.rs\"]\n+    pub mod typeck;\n+    #[legacy_exports]\n+    #[path = \"middle/check_loop.rs\"]\n+    mod check_loop;\n+    #[legacy_exports]\n+    #[path = \"middle/check_alt.rs\"]\n+    mod check_alt;\n+    #[legacy_exports]\n+    #[path = \"middle/check_const.rs\"]\n+    mod check_const;\n+    #[legacy_exports]\n+    #[path = \"middle/lint.rs\"]\n+    mod lint;\n+    #[path = \"middle/borrowck.rs\"]\n+    #[merge = \"middle/borrowck/mod.rs\"]\n+    mod borrowck;\n+    #[legacy_exports]\n+    #[path = \"middle/mem_categorization.rs\"]\n+    mod mem_categorization;\n+    #[legacy_exports]\n+    #[path = \"middle/liveness.rs\"]\n+    mod liveness;\n+    #[legacy_exports]\n+    #[path = \"middle/kind.rs\"]\n+    mod kind;\n+    #[legacy_exports]\n+    #[path = \"middle/freevars.rs\"]\n+    mod freevars;\n+    #[legacy_exports]\n+    #[path = \"middle/capture.rs\"]\n+    mod capture;\n+    #[legacy_exports]\n+    #[path = \"middle/pat_util.rs\"]\n+    mod pat_util;\n+    #[legacy_exports]\n+    #[path = \"middle/region.rs\"]\n+    mod region;\n+    #[legacy_exports]\n+    #[path = \"middle/const_eval.rs\"]\n+    mod const_eval;\n+    #[legacy_exports]\n+    #[path = \"middle/astencode.rs\"]\n+    mod astencode;\n+    #[legacy_exports]\n+    #[path = \"middle/lang_items.rs\"]\n+    mod lang_items;\n+    #[legacy_exports]\n+    #[path = \"middle/privacy.rs\"]\n+    mod privacy;\n+}\n+\n+mod front {\n+    #[legacy_exports];\n+    #[legacy_exports]\n+    #[path = \"front/config.rs\"]\n+    mod config;\n+    #[legacy_exports]\n+    #[path = \"front/test.rs\"]\n+    mod test;\n+    #[legacy_exports]\n+    #[path = \"front/core_inject.rs\"]\n+    mod core_inject;\n+    #[legacy_exports]\n+    #[path = \"front/intrinsic_inject.rs\"]\n+    mod intrinsic_inject;\n+}\n+\n+mod back {\n+    #[legacy_exports];\n+    #[legacy_exports]\n+    #[path = \"back/link.rs\"]\n+    mod link;\n+    #[legacy_exports]\n+    #[path = \"back/abi.rs\"]\n+    mod abi;\n+    #[legacy_exports]\n+    #[path = \"back/upcall.rs\"]\n+    mod upcall;\n+    #[legacy_exports]\n+    #[path = \"back/x86.rs\"]\n+    mod x86;\n+    #[legacy_exports]\n+    #[path = \"back/x86_64.rs\"]\n+    mod x86_64;\n+    #[legacy_exports]\n+    #[path = \"back/rpath.rs\"]\n+    mod rpath;\n+    #[legacy_exports]\n+    #[path = \"back/target_strs.rs\"]\n+    mod target_strs;\n+}\n+\n+#[merge = \"metadata/mod.rs\"]\n+mod metadata;\n+\n+#[merge = \"driver/mod.rs\"]\n+mod driver;\n+\n+mod util {\n+    #[legacy_exports];\n+    #[legacy_exports]\n+    #[path = \"util/common.rs\"]\n+    mod common;\n+    #[legacy_exports]\n+    #[path = \"util/ppaux.rs\"]\n+    mod ppaux;\n+}\n+\n+mod lib {\n+    #[legacy_exports];\n+    #[legacy_exports]\n+    #[path = \"lib/llvm.rs\"]\n+    mod llvm;\n+}\n+\n+use result::{Ok, Err};\n+use io::ReaderUtil;\n+use std::getopts;\n+use std::map::HashMap;\n+use getopts::{opt_present};\n+use getopts::groups;\n+use syntax::codemap;\n+use syntax::diagnostic;\n+use driver::driver::{host_triple, optgroups, early_error,\n+                     str_input, file_input, build_session_options,\n+                     build_session, build_configuration, parse_pretty,\n+                     pp_mode, pretty_print_input, list_metadata,\n+                     compile_input};\n+use driver::session;\n+use middle::lint;\n+\n+fn version(argv0: &str) {\n+    let mut vers = ~\"unknown version\";\n+    let env_vers = env!(\"CFG_VERSION\");\n+    if env_vers.len() != 0 { vers = env_vers; }\n+    io::println(fmt!(\"%s %s\", argv0, vers));\n+    io::println(fmt!(\"host: %s\", host_triple()));\n+}\n+\n+fn usage(argv0: &str) {\n+    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n+    io::println(groups::usage(message, optgroups()) +\n+                ~\"Additional help:\n+    -W help             Print 'lint' options and default settings\n+    -Z help             Print internal options for debugging rustc\n+\");\n+}\n+\n+fn describe_warnings() {\n+    io::println(fmt!(\"\n+Available lint options:\n+    -W <foo>           Warn about <foo>\n+    -A <foo>           Allow <foo>\n+    -D <foo>           Deny <foo>\n+    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n+\"));\n+\n+    let lint_dict = lint::get_lint_dict();\n+    let mut max_key = 0;\n+    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n+    fn padded(max: uint, s: &str) -> ~str {\n+        str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n+    }\n+    io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n+    io::println(fmt!(\"    %s  %7.7s  %s\",\n+                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n+    io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n+                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n+    for lint_dict.each |k, v| {\n+        let k = str::replace(k, ~\"_\", ~\"-\");\n+        io::println(fmt!(\"    %s  %7.7s  %s\",\n+                         padded(max_key, k),\n+                         match v.default {\n+                             lint::allow => ~\"allow\",\n+                             lint::warn => ~\"warn\",\n+                             lint::deny => ~\"deny\",\n+                             lint::forbid => ~\"forbid\"\n+                         },\n+                         v.desc));\n+    }\n+    io::println(~\"\");\n+}\n+\n+fn describe_debug_flags() {\n+    io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n+    for session::debugging_opts_map().each |pair| {\n+        let (name, desc, _) = *pair;\n+        io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n+    }\n+}\n+\n+fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n+    // Don't display log spew by default. Can override with RUST_LOG.\n+    logging::console_off();\n+\n+    let mut args = *args;\n+    let binary = args.shift();\n+\n+    if args.is_empty() { usage(binary); return; }\n+\n+    let matches =\n+        match getopts::groups::getopts(args, optgroups()) {\n+          Ok(m) => m,\n+          Err(f) => {\n+            early_error(demitter, getopts::fail_str(f))\n+          }\n+        };\n+\n+    if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n+        usage(binary);\n+        return;\n+    }\n+\n+    let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n+                                 getopts::opt_strs(matches, ~\"warn\"));\n+    if lint_flags.contains(&~\"help\") {\n+        describe_warnings();\n+        return;\n+    }\n+\n+    if getopts::opt_strs(matches, ~\"Z\").contains(&~\"help\") {\n+        describe_debug_flags();\n+        return;\n+    }\n+\n+    if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n+        version(binary);\n+        return;\n+    }\n+    let input = match vec::len(matches.free) {\n+      0u => early_error(demitter, ~\"no input filename given\"),\n+      1u => {\n+        let ifile = matches.free[0];\n+        if ifile == ~\"-\" {\n+            let src = str::from_bytes(io::stdin().read_whole_stream());\n+            str_input(src)\n+        } else {\n+            file_input(Path(ifile))\n+        }\n+      }\n+      _ => early_error(demitter, ~\"multiple input filenames provided\")\n+    };\n+\n+    let sopts = build_session_options(binary, matches, demitter);\n+    let sess = build_session(sopts, demitter);\n+    let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n+    let odir = odir.map(|o| Path(*o));\n+    let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n+    let ofile = ofile.map(|o| Path(*o));\n+    let cfg = build_configuration(sess, binary, input);\n+    let pretty =\n+        option::map(&getopts::opt_default(matches, ~\"pretty\",\n+                                         ~\"normal\"),\n+                    |a| parse_pretty(sess, *a) );\n+    match pretty {\n+      Some::<pp_mode>(ppm) => {\n+        pretty_print_input(sess, cfg, input, ppm);\n+        return;\n+      }\n+      None::<pp_mode> => {/* continue */ }\n+    }\n+    let ls = opt_present(matches, ~\"ls\");\n+    if ls {\n+        match input {\n+          file_input(ifile) => {\n+            list_metadata(sess, &ifile, io::stdout());\n+          }\n+          str_input(_) => {\n+            early_error(demitter, ~\"can not list metadata for stdin\");\n+          }\n+        }\n+        return;\n+    }\n+\n+    compile_input(sess, cfg, input, &odir, &ofile);\n+}\n+\n+enum monitor_msg {\n+    fatal,\n+    done,\n+}\n+\n+impl monitor_msg : cmp::Eq {\n+    #[cfg(stage0)]\n+    pure fn eq(other: &monitor_msg) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &monitor_msg) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n+    pure fn ne(other: &monitor_msg) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &monitor_msg) -> bool { !(*self).eq(other) }\n+}\n+\n+/*\n+This is a sanity check that any failure of the compiler is performed\n+through the diagnostic module and reported properly - we shouldn't be calling\n+plain-old-fail on any execution path that might be taken. Since we have\n+console logging off by default, hitting a plain fail statement would make the\n+compiler silently exit, which would be terrible.\n+\n+This method wraps the compiler in a subtask and injects a function into the\n+diagnostic emitter which records when we hit a fatal error. If the task\n+fails without recording a fatal error then we've encountered a compiler\n+bug and need to present an error.\n+*/\n+fn monitor(+f: fn~(diagnostic::emitter)) {\n+    let p = comm::Port();\n+    let ch = comm::Chan(&p);\n+\n+    match do task::try |move f| {\n+\n+        // The 'diagnostics emitter'. Every error, warning, etc. should\n+        // go through this function.\n+        let demitter = fn@(cmsp: Option<(@codemap::CodeMap, codemap::span)>,\n+                           msg: &str, lvl: diagnostic::level) {\n+            if lvl == diagnostic::fatal {\n+                comm::send(ch, fatal);\n+            }\n+            diagnostic::emit(cmsp, msg, lvl);\n+        };\n+\n+        struct finally {\n+            ch: comm::Chan<monitor_msg>,\n+            drop { comm::send(self.ch, done); }\n+        }\n+\n+        let _finally = finally { ch: ch };\n+\n+        f(demitter)\n+    } {\n+        result::Ok(_) => { /* fallthrough */ }\n+        result::Err(_) => {\n+            // Task failed without emitting a fatal diagnostic\n+            if comm::recv(p) == done {\n+                diagnostic::emit(\n+                    None,\n+                    diagnostic::ice_msg(~\"unexpected failure\"),\n+                    diagnostic::error);\n+\n+                for [\n+                    ~\"the compiler hit an unexpected failure path. \\\n+                     this is a bug\",\n+                    ~\"try running with RUST_LOG=rustc=1,::rt::backtrace \\\n+                     to get further details and report the results \\\n+                     to github.com/mozilla/rust/issues\"\n+                ].each |note| {\n+                    diagnostic::emit(None, *note, diagnostic::note)\n+                }\n+            }\n+            // Fail so the process returns a failure code\n+            fail;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut args = os::args();\n+    do monitor |move args, demitter| {\n+        run_compiler(&args, demitter);\n+    }\n+}\n+\n+\n+// Local Variables:\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "7d9a55571d4914c139617d74943b12cd9e7fc67a", "filename": "src/librustc/driver/mod.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,5 @@\n+#[legacy_exports];\n+#[legacy_exports]\n+mod driver;\n+#[legacy_exports]\n+mod session;"}, {"sha": "8115c4d1885771859566865db30f8cab23a15610", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -357,7 +357,6 @@ mod test {\n         if with_bin { attrs += ~[make_crate_type_attr(~\"bin\")]; }\n         if with_lib { attrs += ~[make_crate_type_attr(~\"lib\")]; }\n         @ast_util::respan(ast_util::dummy_sp(), {\n-            directives: ~[],\n             module: {view_items: ~[], items: ~[]},\n             attrs: attrs,\n             config: ~[]"}, {"sha": "a82ad39d412e1575c58f1e71d786a9c5c6824d6f", "filename": "src/librustc/metadata/mod.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,32 @@\n+#[legacy_exports];\n+export encoder;\n+export creader;\n+export cstore;\n+export csearch;\n+export common;\n+export decoder;\n+export tyencode;\n+export tydecode;\n+export loader;\n+export filesearch;\n+\n+#[legacy_exports]\n+mod common;\n+#[legacy_exports]\n+mod tyencode;\n+#[legacy_exports]\n+mod tydecode;\n+#[legacy_exports]\n+mod encoder;\n+#[legacy_exports]\n+mod decoder;\n+#[legacy_exports]\n+mod creader;\n+#[legacy_exports]\n+mod cstore;\n+#[legacy_exports]\n+mod csearch;\n+#[legacy_exports]\n+mod loader;\n+#[legacy_exports]\n+mod filesearch;"}, {"sha": "c44110084048bf880b71e4995f83f22ed5d1e873", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,9 @@\n+#[legacy_exports];\n+#[legacy_exports]\n+mod check_loans;\n+#[legacy_exports]\n+mod gather_loans;\n+#[legacy_exports]\n+mod loan;\n+#[legacy_exports]\n+mod preserve;"}, {"sha": "6e999aeb0af5fc581f68f45a0d28068dd5df1c52", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,14 @@\n+#[legacy_exports]\n+mod alt;\n+#[legacy_exports]\n+mod vtable;\n+#[legacy_exports]\n+mod writeback;\n+#[legacy_exports]\n+mod regionmanip;\n+#[legacy_exports]\n+mod regionck;\n+#[legacy_exports]\n+mod demand;\n+#[legacy_exports]\n+pub mod method;"}, {"sha": "3ce09d454d8114cc5da95fdb91c39d6557c1b3cc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,24 @@\n+#[legacy_exports];\n+#[legacy_exports]\n+mod assignment;\n+#[legacy_exports]\n+mod combine;\n+#[legacy_exports]\n+mod glb;\n+#[legacy_exports]\n+mod integral;\n+mod floating;\n+#[legacy_exports]\n+mod lattice;\n+#[legacy_exports]\n+mod lub;\n+#[legacy_exports]\n+mod region_inference;\n+#[legacy_exports]\n+mod resolve;\n+#[legacy_exports]\n+mod sub;\n+#[legacy_exports]\n+mod to_str;\n+#[legacy_exports]\n+mod unify;"}, {"sha": "11077081d91aab7f33ad9037fb74cedd311970f9", "filename": "src/librustc/middle/typeck/mod.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,16 @@\n+#[legacy_exports];\n+\n+#[legacy_exports]\n+#[merge = \"check/mod.rs\"]\n+pub mod check;\n+#[legacy_exports]\n+mod rscope;\n+#[legacy_exports]\n+mod astconv;\n+#[merge = \"infer/mod.rs\"]\n+mod infer;\n+#[legacy_exports]\n+mod collect;\n+#[legacy_exports]\n+mod coherence;\n+mod deriving;"}, {"sha": "25bf8ab10272d4c64eaeaf41302e9ab0210620e8", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,3 +1,5 @@\n+// DIVERT\n+\n // -*- rust -*-\n \n #[link(name = \"rustc\","}, {"sha": "7eed06c9bf84daf6551bbdef771f498f6f9ab6d5", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -52,3 +52,95 @@ mod page_pass;\n mod sectionalize_pass;\n mod escape_pass;\n mod prune_private_pass;\n+\n+use doc::ItemUtils;\n+use doc::Item;\n+use pass::Pass;\n+use config::Config;\n+\n+fn main() {\n+    let args = os::args();\n+\n+    if args.contains(&~\"-h\") || args.contains(&~\"--help\") {\n+        config::usage();\n+        return;\n+    }\n+\n+    let config = match config::parse_config(args) {\n+      Ok(config) => config,\n+      Err(err) => {\n+        io::println(fmt!(\"error: %s\", err));\n+        return;\n+      }\n+    };\n+\n+    run(config);\n+}\n+\n+/// Runs rustdoc over the given file\n+fn run(config: Config) {\n+\n+    let source_file = config.input_crate;\n+\n+    // Create an AST service from the source code\n+    do astsrv::from_file(source_file.to_str()) |srv| {\n+\n+        // Just time how long it takes for the AST to become available\n+        do time(~\"wait_ast\") {\n+            do astsrv::exec(srv) |_ctxt| { }\n+        };\n+\n+        // Extract the initial doc tree from the AST. This contains\n+        // just names and node ids.\n+        let doc = time(~\"extract\", || {\n+            let default_name = source_file;\n+            extract::from_srv(srv, default_name.to_str())\n+        });\n+\n+        // Refine and publish the document\n+        pass::run_passes(srv, doc, ~[\n+            // Generate type and signature strings\n+            tystr_pass::mk_pass(),\n+            // Record the full paths to various nodes\n+            path_pass::mk_pass(),\n+            // Extract the docs attributes and attach them to doc nodes\n+            attr_pass::mk_pass(),\n+            // Perform various text escaping\n+            escape_pass::mk_pass(),\n+            // Remove things marked doc(hidden)\n+            prune_hidden_pass::mk_pass(),\n+            // Remove things that are private\n+            // XXX enable this after 'export' is removed in favor of 'pub'\n+            // prune_private_pass::mk_pass(),\n+            // Extract brief documentation from the full descriptions\n+            desc_to_brief_pass::mk_pass(),\n+            // Massage the text to remove extra indentation\n+            unindent_pass::mk_pass(),\n+            // Split text into multiple sections according to headers\n+            sectionalize_pass::mk_pass(),\n+            // Trim extra spaces from text\n+            trim_pass::mk_pass(),\n+            // Sort items by name\n+            sort_item_name_pass::mk_pass(),\n+            // Sort items again by kind\n+            sort_item_type_pass::mk_pass(),\n+            // Create indexes appropriate for markdown\n+            markdown_index_pass::mk_pass(config),\n+            // Break the document into pages if required by the\n+            // output format\n+            page_pass::mk_pass(config.output_style),\n+            // Render\n+            markdown_pass::mk_pass(\n+                markdown_writer::make_writer_factory(config)\n+            )\n+        ]);\n+    }\n+}\n+\n+fn time<T>(what: ~str, f: fn() -> T) -> T {\n+    let start = std::time::precise_time_s();\n+    let rv = f();\n+    let end = std::time::precise_time_s();\n+    info!(\"time: %3.3f s    %s\", end - start, what);\n+    move rv\n+}"}, {"sha": "e09f57339a7c6451a3fbef70bdfd2c49616eed80", "filename": "src/librustdoc/rustdoc.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,91 +0,0 @@\n-use doc::ItemUtils;\n-use doc::Item;\n-use pass::Pass;\n-use config::Config;\n-\n-fn main() {\n-    let args = os::args();\n-\n-    if args.contains(&~\"-h\") || args.contains(&~\"--help\") {\n-        config::usage();\n-        return;\n-    }\n-\n-    let config = match config::parse_config(args) {\n-      Ok(config) => config,\n-      Err(err) => {\n-        io::println(fmt!(\"error: %s\", err));\n-        return;\n-      }\n-    };\n-\n-    run(config);\n-}\n-\n-/// Runs rustdoc over the given file\n-fn run(config: Config) {\n-\n-    let source_file = config.input_crate;\n-\n-    // Create an AST service from the source code\n-    do astsrv::from_file(source_file.to_str()) |srv| {\n-\n-        // Just time how long it takes for the AST to become available\n-        do time(~\"wait_ast\") {\n-            do astsrv::exec(srv) |_ctxt| { }\n-        };\n-\n-        // Extract the initial doc tree from the AST. This contains\n-        // just names and node ids.\n-        let doc = time(~\"extract\", || {\n-            let default_name = source_file;\n-            extract::from_srv(srv, default_name.to_str())\n-        });\n-\n-        // Refine and publish the document\n-        pass::run_passes(srv, doc, ~[\n-            // Generate type and signature strings\n-            tystr_pass::mk_pass(),\n-            // Record the full paths to various nodes\n-            path_pass::mk_pass(),\n-            // Extract the docs attributes and attach them to doc nodes\n-            attr_pass::mk_pass(),\n-            // Perform various text escaping\n-            escape_pass::mk_pass(),\n-            // Remove things marked doc(hidden)\n-            prune_hidden_pass::mk_pass(),\n-            // Remove things that are private\n-            // XXX enable this after 'export' is removed in favor of 'pub'\n-            // prune_private_pass::mk_pass(),\n-            // Extract brief documentation from the full descriptions\n-            desc_to_brief_pass::mk_pass(),\n-            // Massage the text to remove extra indentation\n-            unindent_pass::mk_pass(),\n-            // Split text into multiple sections according to headers\n-            sectionalize_pass::mk_pass(),\n-            // Trim extra spaces from text\n-            trim_pass::mk_pass(),\n-            // Sort items by name\n-            sort_item_name_pass::mk_pass(),\n-            // Sort items again by kind\n-            sort_item_type_pass::mk_pass(),\n-            // Create indexes appropriate for markdown\n-            markdown_index_pass::mk_pass(config),\n-            // Break the document into pages if required by the\n-            // output format\n-            page_pass::mk_pass(config.output_style),\n-            // Render\n-            markdown_pass::mk_pass(\n-                markdown_writer::make_writer_factory(config)\n-            )\n-        ]);\n-    }\n-}\n-\n-fn time<T>(what: ~str, f: fn() -> T) -> T {\n-    let start = std::time::precise_time_s();\n-    let rv = f();\n-    let end = std::time::precise_time_s();\n-    info!(\"time: %3.3f s    %s\", end - start, what);\n-    move rv\n-}"}, {"sha": "1b90a227098223e4009cb5180c65aa07c047e3eb", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -31,3 +31,385 @@ use syntax::ast_util::*;\n use parse::token;\n use print::{pp, pprust};\n use std::rl;\n+\n+/**\n+ * A structure shared across REPL instances for storing history\n+ * such as statements and view items. I wish the AST was sendable.\n+ */\n+struct Repl {\n+    prompt: ~str,\n+    binary: ~str,\n+    running: bool,\n+    view_items: ~str,\n+    stmts: ~str\n+}\n+\n+// Action to do after reading a :command\n+enum CmdAction {\n+    action_none,\n+    action_run_line(~str),\n+}\n+\n+/// A utility function that hands off a pretty printer to a callback.\n+fn with_pp(intr: @token::ident_interner,\n+           cb: fn(pprust::ps, io::Writer)) -> ~str {\n+    do io::with_str_writer |writer| {\n+        let pp = pprust::rust_printer(writer, intr);\n+\n+        cb(pp, writer);\n+        pp::eof(pp.s);\n+    }\n+}\n+\n+/**\n+ * The AST (or the rest of rustc) are not sendable yet,\n+ * so recorded things are printed to strings. A terrible hack that\n+ * needs changes to rustc in order to be outed. This is unfortunately\n+ * going to cause the REPL to regress in parser performance,\n+ * because it has to parse the statements and view_items on each\n+ * input.\n+ */\n+fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n+    let view_items = if blk.node.view_items.len() > 0 {\n+        let new_view_items = do with_pp(intr) |pp, writer| {\n+            for blk.node.view_items.each |view_item| {\n+                pprust::print_view_item(pp, *view_item);\n+                writer.write_line(~\"\");\n+            }\n+        };\n+\n+        debug!(\"new view items %s\", new_view_items);\n+\n+        repl.view_items + \"\\n\" + new_view_items\n+    } else { repl.view_items };\n+    let stmts = if blk.node.stmts.len() > 0 {\n+        let new_stmts = do with_pp(intr) |pp, writer| {\n+            for blk.node.stmts.each |stmt| {\n+                match stmt.node {\n+                    ast::stmt_decl(*) => {\n+                        pprust::print_stmt(pp, **stmt);\n+                        writer.write_line(~\"\");\n+                    }\n+                    ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+                        match expr.node {\n+                            ast::expr_assign(*) |\n+                            ast::expr_assign_op(*) |\n+                            ast::expr_swap(*) => {\n+                                pprust::print_stmt(pp, **stmt);\n+                                writer.write_line(~\"\");\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n+        debug!(\"new stmts %s\", new_stmts);\n+\n+        repl.stmts + \"\\n\" + new_stmts\n+    } else { repl.stmts };\n+\n+    Repl{\n+        view_items: view_items,\n+        stmts: stmts,\n+        .. repl\n+    }\n+}\n+\n+/// Run an input string in a Repl, returning the new Repl.\n+fn run(repl: Repl, input: ~str) -> Repl {\n+    let options: @session::options = @{\n+        crate_type: session::unknown_crate,\n+        binary: repl.binary,\n+        addl_lib_search_paths: ~[os::getcwd()],\n+        .. *session::basic_options()\n+    };\n+\n+    debug!(\"building driver input\");\n+    let head = include_str!(\"wrapper.rs\");\n+    let foot = fmt!(\"%s\\nfn main() {\\n%s\\n\\nprint({\\n%s\\n})\\n}\",\n+                    repl.view_items, repl.stmts, input);\n+    let wrapped = driver::str_input(head + foot);\n+\n+    debug!(\"inputting %s\", head + foot);\n+\n+    debug!(\"building a driver session\");\n+    let sess = driver::build_session(options, diagnostic::emit);\n+\n+    debug!(\"building driver configuration\");\n+    let cfg = driver::build_configuration(sess,\n+                                          repl.binary,\n+                                          wrapped);\n+\n+    debug!(\"parsing\");\n+    let mut crate = driver::parse_input(sess, cfg, wrapped);\n+    let mut opt = None;\n+\n+    for crate.node.module.items.each |item| {\n+        match item.node {\n+            ast::item_fn(_, _, _, blk) => {\n+                if item.ident == sess.ident_of(~\"main\") {\n+                    opt = blk.node.expr;\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let blk = match opt.get().node {\n+        ast::expr_call(_, exprs, _) => {\n+            match exprs[0].node {\n+                ast::expr_block(blk) => @blk,\n+                _ => fail\n+            }\n+        }\n+        _ => fail\n+    };\n+\n+    debug!(\"configuration\");\n+    crate = front::config::strip_unconfigured_items(crate);\n+\n+    debug!(\"maybe building test harness\");\n+    crate = front::test::modify_for_testing(sess, crate);\n+\n+    debug!(\"expansion\");\n+    crate = syntax::ext::expand::expand_crate(sess.parse_sess,\n+                                              sess.opts.cfg,\n+                                              crate);\n+\n+    debug!(\"intrinsic injection\");\n+    crate = front::intrinsic_inject::inject_intrinsic(sess, crate);\n+\n+    debug!(\"core injection\");\n+    crate = front::core_inject::maybe_inject_libcore_ref(sess, crate);\n+\n+    debug!(\"building lint settings table\");\n+    lint::build_settings_crate(sess, crate);\n+\n+    debug!(\"ast indexing\");\n+    let ast_map = syntax::ast_map::map_crate(sess.diagnostic(), *crate);\n+\n+    debug!(\"external crate/lib resolution\");\n+    creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n+                         sess.filesearch,\n+                         session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                         sess.opts.static, sess.parse_sess.interner);\n+\n+    debug!(\"language item collection\");\n+    let lang_items = middle::lang_items::collect_language_items(crate, sess);\n+\n+    debug!(\"resolution\");\n+    let {def_map: def_map,\n+         exp_map2: exp_map2,\n+         trait_map: trait_map} = middle::resolve::resolve_crate(sess,\n+                                                                lang_items,\n+                                                                crate);\n+\n+    debug!(\"freevar finding\");\n+    let freevars = freevars::annotate_freevars(def_map, crate);\n+\n+    debug!(\"region_resolution\");\n+    let region_map = middle::region::resolve_crate(sess, def_map, crate);\n+\n+    debug!(\"region paramaterization inference\");\n+    let rp_set = middle::region::determine_rp_in_crate(sess, ast_map,\n+                                                       def_map, crate);\n+\n+    debug!(\"typechecking\");\n+    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n+                            region_map, rp_set, move lang_items, crate);\n+    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map,\n+                                                       crate);\n+\n+    debug!(\"const marking\");\n+    middle::const_eval::process_crate(crate, def_map, ty_cx);\n+\n+    debug!(\"const checking\");\n+    middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+                                     method_map, ty_cx);\n+\n+    debug!(\"privacy checking\");\n+    middle::privacy::check_crate(ty_cx, &method_map, crate);\n+\n+    debug!(\"loop checking\");\n+    middle::check_loop::check_crate(ty_cx, crate);\n+\n+    debug!(\"alt checking\");\n+    middle::check_alt::check_crate(ty_cx, crate);\n+\n+    debug!(\"liveness checking\");\n+    let last_use_map = middle::liveness::check_crate(ty_cx,\n+                                                     method_map, crate);\n+\n+    debug!(\"borrow checking\");\n+    let (root_map, mutbl_map) = middle::borrowck::check_crate(ty_cx,\n+                                                              method_map,\n+                                                              last_use_map,\n+                                                              crate);\n+\n+    debug!(\"kind checking\");\n+    kind::check_crate(ty_cx, method_map, last_use_map, crate);\n+\n+    debug!(\"lint checking\");\n+    lint::check_crate(ty_cx, crate);\n+\n+    let maps = {mutbl_map: mutbl_map,\n+                root_map: root_map,\n+                last_use_map: last_use_map,\n+                method_map: method_map,\n+                vtable_map: vtable_map};\n+\n+    debug!(\"translation\");\n+    let (llmod, _) = trans::base::trans_crate(sess, crate, ty_cx,\n+                                              ~path::from_str(\"<repl>\"),\n+                                              exp_map2, maps);\n+    let pm = llvm::LLVMCreatePassManager();\n+\n+    debug!(\"executing jit\");\n+    back::link::jit::exec(sess, pm, llmod, 0, false);\n+    llvm::LLVMDisposePassManager(pm);\n+\n+    debug!(\"recording input into repl history\");\n+    record(repl, blk, sess.parse_sess.interner)\n+}\n+\n+/// Tries to get a line from rl after outputting a prompt. Returns\n+/// None if no input was read (e.g. EOF was reached).\n+fn get_line(prompt: ~str) -> Option<~str> {\n+    let result = unsafe { rl::read(prompt) };\n+\n+    if result.is_none() {\n+        return None;\n+    }\n+\n+    let line = result.get();\n+\n+    unsafe { rl::add_history(line) };\n+\n+    return Some(line);\n+}\n+\n+/// Run a command, e.g. :clear, :exit, etc.\n+fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n+           cmd: ~str, _args: ~[~str]) -> CmdAction {\n+    let mut action = action_none;\n+    match cmd {\n+        ~\"exit\" => repl.running = false,\n+        ~\"clear\" => {\n+            repl.view_items = ~\"\";\n+            repl.stmts = ~\"\";\n+\n+            // XXX: Win32 version of linenoise can't do this\n+            //rl::clear();\n+        }\n+        ~\"help\" => {\n+            io::println(\n+                ~\":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\" +\n+                ~\":clear - clear the screen\\n\" +\n+                ~\":exit - exit from the repl\\n\" +\n+                ~\":help - show this message\");\n+        }\n+        ~\"{\" => {\n+            let mut multiline_cmd = ~\"\";\n+            let mut end_multiline = false;\n+            while (!end_multiline) {\n+                match get_line(~\"rusti| \") {\n+                    None => fail ~\"unterminated multiline command :{ .. :}\",\n+                    Some(line) => {\n+                        if str::trim(line) == ~\":}\" {\n+                            end_multiline = true;\n+                        } else {\n+                            multiline_cmd += line + ~\"\\n\";\n+                        }\n+                    }\n+                }\n+            }\n+            action = action_run_line(multiline_cmd);\n+        }\n+        _ => io::println(~\"unknown cmd: \" + cmd)\n+    }\n+    return action;\n+}\n+\n+/// Executes a line of input, which may either be rust code or a\n+/// :command. Returns a new Repl if it has changed.\n+fn run_line(repl: &mut Repl, in: io::Reader, out: io::Writer, line: ~str)\n+    -> Option<Repl> {\n+    if line.starts_with(~\":\") {\n+        let full = line.substr(1, line.len() - 1);\n+        let split = str::words(full);\n+        let len = split.len();\n+\n+        if len > 0 {\n+            let cmd = split[0];\n+\n+            if !cmd.is_empty() {\n+                let args = if len > 1 {\n+                    do vec::view(split, 1, len - 1).map |arg| {\n+                        *arg\n+                    }\n+                } else { ~[] };\n+\n+                match run_cmd(repl, in, out, cmd, args) {\n+                    action_none => { }\n+                    action_run_line(multiline_cmd) => {\n+                        if !multiline_cmd.is_empty() {\n+                            return run_line(repl, in, out, multiline_cmd);\n+                        }\n+                    }\n+                }\n+                return None;\n+            }\n+        }\n+    }\n+\n+    let r = *repl;\n+    let result = do task::try |copy r| {\n+        run(r, line)\n+    };\n+\n+    if result.is_ok() {\n+        return Some(result.get());\n+    }\n+    return None;\n+}\n+\n+pub fn main() {\n+    let args = os::args();\n+    let in = io::stdin();\n+    let out = io::stdout();\n+    let mut repl = Repl {\n+        prompt: ~\"rusti> \",\n+        binary: args[0],\n+        running: true,\n+        view_items: ~\"\",\n+        stmts: ~\"\"\n+    };\n+\n+    unsafe {\n+        do rl::complete |line, suggest| {\n+            if line.starts_with(\":\") {\n+                suggest(~\":clear\");\n+                suggest(~\":exit\");\n+                suggest(~\":help\");\n+            }\n+        }\n+    }\n+\n+    while repl.running {\n+        match get_line(repl.prompt) {\n+            None => break,\n+            Some(line) => {\n+                if line.is_empty() {\n+                    io::println(~\"()\");\n+                    loop;\n+                }\n+                match run_line(&mut repl, in, out, line) {\n+                    Some(new_repl) => repl = new_repl,\n+                    None => { }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "79009761467489cd71058d054dbfc574a8d56fb9", "filename": "src/librusti/rusti.rs", "status": "removed", "additions": 0, "deletions": 381, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,381 +0,0 @@\n-/**\n- * A structure shared across REPL instances for storing history\n- * such as statements and view items. I wish the AST was sendable.\n- */\n-struct Repl {\n-    prompt: ~str,\n-    binary: ~str,\n-    running: bool,\n-    view_items: ~str,\n-    stmts: ~str\n-}\n-\n-// Action to do after reading a :command\n-enum CmdAction {\n-    action_none,\n-    action_run_line(~str),\n-}\n-\n-/// A utility function that hands off a pretty printer to a callback.\n-fn with_pp(intr: @token::ident_interner,\n-           cb: fn(pprust::ps, io::Writer)) -> ~str {\n-    do io::with_str_writer |writer| {\n-        let pp = pprust::rust_printer(writer, intr);\n-\n-        cb(pp, writer);\n-        pp::eof(pp.s);\n-    }\n-}\n-\n-/**\n- * The AST (or the rest of rustc) are not sendable yet,\n- * so recorded things are printed to strings. A terrible hack that\n- * needs changes to rustc in order to be outed. This is unfortunately\n- * going to cause the REPL to regress in parser performance,\n- * because it has to parse the statements and view_items on each\n- * input.\n- */\n-fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n-    let view_items = if blk.node.view_items.len() > 0 {\n-        let new_view_items = do with_pp(intr) |pp, writer| {\n-            for blk.node.view_items.each |view_item| {\n-                pprust::print_view_item(pp, *view_item);\n-                writer.write_line(~\"\");\n-            }\n-        };\n-\n-        debug!(\"new view items %s\", new_view_items);\n-\n-        repl.view_items + \"\\n\" + new_view_items\n-    } else { repl.view_items };\n-    let stmts = if blk.node.stmts.len() > 0 {\n-        let new_stmts = do with_pp(intr) |pp, writer| {\n-            for blk.node.stmts.each |stmt| {\n-                match stmt.node {\n-                    ast::stmt_decl(*) => {\n-                        pprust::print_stmt(pp, **stmt);\n-                        writer.write_line(~\"\");\n-                    }\n-                    ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n-                        match expr.node {\n-                            ast::expr_assign(*) |\n-                            ast::expr_assign_op(*) |\n-                            ast::expr_swap(*) => {\n-                                pprust::print_stmt(pp, **stmt);\n-                                writer.write_line(~\"\");\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-\n-        debug!(\"new stmts %s\", new_stmts);\n-\n-        repl.stmts + \"\\n\" + new_stmts\n-    } else { repl.stmts };\n-\n-    Repl{\n-        view_items: view_items,\n-        stmts: stmts,\n-        .. repl\n-    }\n-}\n-\n-/// Run an input string in a Repl, returning the new Repl.\n-fn run(repl: Repl, input: ~str) -> Repl {\n-    let options: @session::options = @{\n-        crate_type: session::unknown_crate,\n-        binary: repl.binary,\n-        addl_lib_search_paths: ~[os::getcwd()],\n-        .. *session::basic_options()\n-    };\n-\n-    debug!(\"building driver input\");\n-    let head = include_str!(\"wrapper.rs\");\n-    let foot = fmt!(\"%s\\nfn main() {\\n%s\\n\\nprint({\\n%s\\n})\\n}\",\n-                    repl.view_items, repl.stmts, input);\n-    let wrapped = driver::str_input(head + foot);\n-\n-    debug!(\"inputting %s\", head + foot);\n-\n-    debug!(\"building a driver session\");\n-    let sess = driver::build_session(options, diagnostic::emit);\n-\n-    debug!(\"building driver configuration\");\n-    let cfg = driver::build_configuration(sess,\n-                                          repl.binary,\n-                                          wrapped);\n-\n-    debug!(\"parsing\");\n-    let mut crate = driver::parse_input(sess, cfg, wrapped);\n-    let mut opt = None;\n-\n-    for crate.node.module.items.each |item| {\n-        match item.node {\n-            ast::item_fn(_, _, _, blk) => {\n-                if item.ident == sess.ident_of(~\"main\") {\n-                    opt = blk.node.expr;\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    let blk = match opt.get().node {\n-        ast::expr_call(_, exprs, _) => {\n-            match exprs[0].node {\n-                ast::expr_block(blk) => @blk,\n-                _ => fail\n-            }\n-        }\n-        _ => fail\n-    };\n-\n-    debug!(\"configuration\");\n-    crate = front::config::strip_unconfigured_items(crate);\n-\n-    debug!(\"maybe building test harness\");\n-    crate = front::test::modify_for_testing(sess, crate);\n-\n-    debug!(\"expansion\");\n-    crate = syntax::ext::expand::expand_crate(sess.parse_sess,\n-                                              sess.opts.cfg,\n-                                              crate);\n-\n-    debug!(\"intrinsic injection\");\n-    crate = front::intrinsic_inject::inject_intrinsic(sess, crate);\n-\n-    debug!(\"core injection\");\n-    crate = front::core_inject::maybe_inject_libcore_ref(sess, crate);\n-\n-    debug!(\"building lint settings table\");\n-    lint::build_settings_crate(sess, crate);\n-\n-    debug!(\"ast indexing\");\n-    let ast_map = syntax::ast_map::map_crate(sess.diagnostic(), *crate);\n-\n-    debug!(\"external crate/lib resolution\");\n-    creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n-                         sess.filesearch,\n-                         session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                         sess.opts.static, sess.parse_sess.interner);\n-\n-    debug!(\"language item collection\");\n-    let lang_items = middle::lang_items::collect_language_items(crate, sess);\n-\n-    debug!(\"resolution\");\n-    let {def_map: def_map,\n-         exp_map2: exp_map2,\n-         trait_map: trait_map} = middle::resolve::resolve_crate(sess,\n-                                                                lang_items,\n-                                                                crate);\n-\n-    debug!(\"freevar finding\");\n-    let freevars = freevars::annotate_freevars(def_map, crate);\n-\n-    debug!(\"region_resolution\");\n-    let region_map = middle::region::resolve_crate(sess, def_map, crate);\n-\n-    debug!(\"region paramaterization inference\");\n-    let rp_set = middle::region::determine_rp_in_crate(sess, ast_map,\n-                                                       def_map, crate);\n-\n-    debug!(\"typechecking\");\n-    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                            region_map, rp_set, move lang_items, crate);\n-    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map,\n-                                                       crate);\n-\n-    debug!(\"const marking\");\n-    middle::const_eval::process_crate(crate, def_map, ty_cx);\n-\n-    debug!(\"const checking\");\n-    middle::check_const::check_crate(sess, crate, ast_map, def_map,\n-                                     method_map, ty_cx);\n-\n-    debug!(\"privacy checking\");\n-    middle::privacy::check_crate(ty_cx, &method_map, crate);\n-\n-    debug!(\"loop checking\");\n-    middle::check_loop::check_crate(ty_cx, crate);\n-\n-    debug!(\"alt checking\");\n-    middle::check_alt::check_crate(ty_cx, crate);\n-\n-    debug!(\"liveness checking\");\n-    let last_use_map = middle::liveness::check_crate(ty_cx,\n-                                                     method_map, crate);\n-\n-    debug!(\"borrow checking\");\n-    let (root_map, mutbl_map) = middle::borrowck::check_crate(ty_cx,\n-                                                              method_map,\n-                                                              last_use_map,\n-                                                              crate);\n-\n-    debug!(\"kind checking\");\n-    kind::check_crate(ty_cx, method_map, last_use_map, crate);\n-\n-    debug!(\"lint checking\");\n-    lint::check_crate(ty_cx, crate);\n-\n-    let maps = {mutbl_map: mutbl_map,\n-                root_map: root_map,\n-                last_use_map: last_use_map,\n-                method_map: method_map,\n-                vtable_map: vtable_map};\n-\n-    debug!(\"translation\");\n-    let (llmod, _) = trans::base::trans_crate(sess, crate, ty_cx,\n-                                              ~path::from_str(\"<repl>\"),\n-                                              exp_map2, maps);\n-    let pm = llvm::LLVMCreatePassManager();\n-\n-    debug!(\"executing jit\");\n-    back::link::jit::exec(sess, pm, llmod, 0, false);\n-    llvm::LLVMDisposePassManager(pm);\n-\n-    debug!(\"recording input into repl history\");\n-    record(repl, blk, sess.parse_sess.interner)\n-}\n-\n-/// Tries to get a line from rl after outputting a prompt. Returns\n-/// None if no input was read (e.g. EOF was reached).\n-fn get_line(prompt: ~str) -> Option<~str> {\n-    let result = unsafe { rl::read(prompt) };\n-\n-    if result.is_none() {\n-        return None;\n-    }\n-\n-    let line = result.get();\n-\n-    unsafe { rl::add_history(line) };\n-\n-    return Some(line);\n-}\n-\n-/// Run a command, e.g. :clear, :exit, etc.\n-fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n-           cmd: ~str, _args: ~[~str]) -> CmdAction {\n-    let mut action = action_none;\n-    match cmd {\n-        ~\"exit\" => repl.running = false,\n-        ~\"clear\" => {\n-            repl.view_items = ~\"\";\n-            repl.stmts = ~\"\";\n-\n-            // XXX: Win32 version of linenoise can't do this\n-            //rl::clear();\n-        }\n-        ~\"help\" => {\n-            io::println(\n-                ~\":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\" +\n-                ~\":clear - clear the screen\\n\" +\n-                ~\":exit - exit from the repl\\n\" +\n-                ~\":help - show this message\");\n-        }\n-        ~\"{\" => {\n-            let mut multiline_cmd = ~\"\";\n-            let mut end_multiline = false;\n-            while (!end_multiline) {\n-                match get_line(~\"rusti| \") {\n-                    None => fail ~\"unterminated multiline command :{ .. :}\",\n-                    Some(line) => {\n-                        if str::trim(line) == ~\":}\" {\n-                            end_multiline = true;\n-                        } else {\n-                            multiline_cmd += line + ~\"\\n\";\n-                        }\n-                    }\n-                }\n-            }\n-            action = action_run_line(multiline_cmd);\n-        }\n-        _ => io::println(~\"unknown cmd: \" + cmd)\n-    }\n-    return action;\n-}\n-\n-/// Executes a line of input, which may either be rust code or a\n-/// :command. Returns a new Repl if it has changed.\n-fn run_line(repl: &mut Repl, in: io::Reader, out: io::Writer, line: ~str)\n-    -> Option<Repl> {\n-    if line.starts_with(~\":\") {\n-        let full = line.substr(1, line.len() - 1);\n-        let split = str::words(full);\n-        let len = split.len();\n-\n-        if len > 0 {\n-            let cmd = split[0];\n-\n-            if !cmd.is_empty() {\n-                let args = if len > 1 {\n-                    do vec::view(split, 1, len - 1).map |arg| {\n-                        *arg\n-                    }\n-                } else { ~[] };\n-\n-                match run_cmd(repl, in, out, cmd, args) {\n-                    action_none => { }\n-                    action_run_line(multiline_cmd) => {\n-                        if !multiline_cmd.is_empty() {\n-                            return run_line(repl, in, out, multiline_cmd);\n-                        }\n-                    }\n-                }\n-                return None;\n-            }\n-        }\n-    }\n-\n-    let r = *repl;\n-    let result = do task::try |copy r| {\n-        run(r, line)\n-    };\n-\n-    if result.is_ok() {\n-        return Some(result.get());\n-    }\n-    return None;\n-}\n-\n-pub fn main() {\n-    let args = os::args();\n-    let in = io::stdin();\n-    let out = io::stdout();\n-    let mut repl = Repl {\n-        prompt: ~\"rusti> \",\n-        binary: args[0],\n-        running: true,\n-        view_items: ~\"\",\n-        stmts: ~\"\"\n-    };\n-\n-    unsafe {\n-        do rl::complete |line, suggest| {\n-            if line.starts_with(\":\") {\n-                suggest(~\":clear\");\n-                suggest(~\":exit\");\n-                suggest(~\":help\");\n-            }\n-        }\n-    }\n-\n-    while repl.running {\n-        match get_line(repl.prompt) {\n-            None => break,\n-            Some(line) => {\n-                if line.is_empty() {\n-                    io::println(~\"()\");\n-                    loop;\n-                }\n-                match run_line(&mut repl, in, out, line) {\n-                    Some(new_repl) => repl = new_repl,\n-                    None => { }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "d5a28a716ecc8b5cda1531042fb7708f6794f844", "filename": "src/libsyntax/alternate_crate.rc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Falternate_crate.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Falternate_crate.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Falternate_crate.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,128 @@\n+#[link(name = \"syntax\",\n+       vers = \"0.5\",\n+       uuid = \"9311401b-d6ea-4cd9-a1d9-61f89499c645\")];\n+\n+\n+\n+#[crate_type = \"lib\"];\n+\n+#[no_core];\n+\n+#[legacy_modes];\n+#[legacy_exports];\n+\n+#[allow(vecs_implicitly_copyable)];\n+#[allow(non_camel_case_types)];\n+#[allow(deprecated_mode)];\n+#[allow(deprecated_pattern)];\n+\n+extern mod core(vers = \"0.5\");\n+extern mod std(vers = \"0.5\");\n+\n+use core::*;\n+\n+#[legacy_exports]\n+mod attr;\n+#[legacy_exports]\n+mod diagnostic;\n+mod codemap;\n+#[legacy_exports]\n+mod ast;\n+#[legacy_exports]\n+mod ast_util;\n+#[legacy_exports]\n+mod ast_map;\n+#[legacy_exports]\n+mod visit;\n+#[legacy_exports]\n+mod fold;\n+#[legacy_exports]\n+mod util {\n+    #[legacy_exports];\n+    #[legacy_exports]\n+    #[path = \"util/interner.rs\"]\n+    mod interner;\n+}\n+\n+#[merge = \"parse/mod.rs\"]\n+mod parse;\n+\n+mod print {\n+    #[legacy_exports];\n+    #[legacy_exports]\n+    #[path = \"print/pp.rs\"]\n+    mod pp;\n+    #[legacy_exports]\n+    #[path = \"print/pprust.rs\"]\n+    mod pprust;\n+}\n+\n+mod ext {\n+    #[legacy_exports];\n+    #[legacy_exports]\n+    #[path = \"ext/base.rs\"]\n+    mod base;\n+    #[legacy_exports]\n+    #[path = \"ext/expand.rs\"]\n+    mod expand;\n+    #[legacy_exports]\n+    #[path = \"ext/qquote.rs\"]\n+    mod qquote;\n+\n+    #[path = \"ext/quote.rs\"]\n+    mod quote;\n+    #[path = \"ext/deriving.rs\"]\n+    mod deriving;\n+\n+    #[legacy_exports]\n+    #[path = \"ext/build.rs\"]\n+    mod build;\n+\n+    mod tt {\n+        #[legacy_exports];\n+        #[legacy_exports]\n+        #[path = \"ext/tt/transcribe.rs\"]\n+        mod transcribe;\n+        #[legacy_exports]\n+        #[path = \"ext/tt/macro_parser.rs\"]\n+        mod macro_parser;\n+        #[legacy_exports]\n+        #[path = \"ext/tt/macro_rules.rs\"]\n+        mod macro_rules;\n+    }\n+\n+\n+    #[legacy_exports]\n+    #[path = \"ext/simplext.rs\"]\n+    mod simplext;\n+    #[legacy_exports]\n+    #[path = \"ext/fmt.rs\"]\n+    mod fmt;\n+    #[legacy_exports]\n+    #[path = \"ext/env.rs\"]\n+    mod env;\n+    #[legacy_exports]\n+    #[path = \"ext/concat_idents.rs\"]\n+    mod concat_idents;\n+    #[legacy_exports]\n+    #[path = \"ext/ident_to_str.rs\"]\n+    mod ident_to_str;\n+    #[legacy_exports]\n+    #[path = \"ext/log_syntax.rs\"]\n+    mod log_syntax;\n+    #[legacy_exports]\n+    #[path = \"ext/auto_serialize.rs\"]\n+    mod auto_serialize;\n+    #[legacy_exports]\n+    #[path = \"ext/source_util.rs\"]\n+    mod source_util;\n+\n+    #[legacy_exports]\n+    #[path = \"ext/pipes.rs\"]\n+    #[merge = \"ext/pipes/mod.rs\"]\n+    mod pipes;\n+\n+    #[legacy_exports]\n+    #[path = \"ext/trace_macros.rs\"]\n+    mod trace_macros;\n+}"}, {"sha": "21ce366e1c40886751d456630eccbed4cb06de6e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -406,25 +406,10 @@ type crate_cfg = ~[@meta_item];\n type crate = spanned<crate_>;\n \n type crate_ =\n-    {directives: ~[@crate_directive],\n-     module: _mod,\n+    {module: _mod,\n      attrs: ~[attribute],\n      config: crate_cfg};\n \n-enum crate_directive_ {\n-    cdir_src_mod(visibility, ident, ~[attribute]),\n-    cdir_dir_mod(visibility, ident, ~[@crate_directive], ~[attribute]),\n-\n-    // NB: cdir_view_item is *not* processed by the rest of the compiler, the\n-    // attached view_items are sunk into the crate's module during parsing,\n-    // and processed (resolved, imported, etc.) there. This enum-variant\n-    // exists only to preserve the view items in order in case we decide to\n-    // pretty-print crates in the future.\n-    cdir_view_item(@view_item),\n-}\n-\n-type crate_directive = spanned<crate_directive_>;\n-\n type meta_item = spanned<meta_item_>;\n \n #[auto_serialize]"}, {"sha": "638ccad0143fc91b881c723a30e6608e700ce458", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,12 @@\n+#[legacy_exports]\n+mod ast_builder;\n+#[legacy_exports]\n+mod parse_proto;\n+#[legacy_exports]\n+mod pipec;\n+#[legacy_exports]\n+mod proto;\n+#[legacy_exports]\n+mod check;\n+#[legacy_exports]\n+mod liveness;"}, {"sha": "7369e47eed390ea0bd3574f56f280a3139b587bb", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -21,7 +21,6 @@ export extensions;\n \n trait ast_fold {\n     fn fold_crate(crate) -> crate;\n-    fn fold_crate_directive(&&v: @crate_directive) -> @crate_directive;\n     fn fold_view_item(&&v: @view_item) -> @view_item;\n     fn fold_foreign_item(&&v: @foreign_item) -> @foreign_item;\n     fn fold_item(&&v: @item) -> Option<@item>;\n@@ -51,8 +50,6 @@ trait ast_fold {\n type ast_fold_precursor = @{\n     //unlike the others, item_ is non-trivial\n     fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n-    fold_crate_directive: fn@(crate_directive_, span,\n-                              ast_fold) -> (crate_directive_, span),\n     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n     fold_foreign_item: fn@(&&v: @foreign_item, ast_fold) -> @foreign_item,\n     fold_item: fn@(&&v: @item, ast_fold) -> Option<@item>,\n@@ -150,29 +147,12 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     return {\n-        directives: vec::map(c.directives, |x| fld.fold_crate_directive(*x)),\n         module: fld.fold_mod(c.module),\n         attrs: vec::map(c.attrs, |x| fold_attribute(*x)),\n         config: vec::map(c.config, |x| fold_meta_item(*x))\n     };\n }\n \n-fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n-   crate_directive_ {\n-    return match cd {\n-          cdir_src_mod(vis, id, attrs) => {\n-            cdir_src_mod(vis, fld.fold_ident(id),\n-                         /* FIXME (#2543) */ copy attrs)\n-          }\n-          cdir_dir_mod(vis, id, cds, attrs) => {\n-            cdir_dir_mod(vis, fld.fold_ident(id),\n-                         vec::map(cds, |x| fld.fold_crate_directive(*x)),\n-                         /* FIXME (#2543) */ copy attrs)\n-          }\n-          cdir_view_item(vi) => cdir_view_item(fld.fold_view_item(vi)),\n-        }\n-}\n-\n fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n     return /* FIXME (#2543) */ copy vi;\n }\n@@ -635,7 +615,6 @@ fn noop_span(sp: span) -> span { return sp; }\n \n fn default_ast_fold() -> ast_fold_precursor {\n     return @{fold_crate: wrap(noop_fold_crate),\n-          fold_crate_directive: wrap(noop_fold_crate_directive),\n           fold_view_item: noop_fold_view_item,\n           fold_foreign_item: noop_fold_foreign_item,\n           fold_item: noop_fold_item,\n@@ -666,12 +645,6 @@ impl ast_fold_precursor: ast_fold {\n         let (n, s) = self.fold_crate(c.node, c.span, self as ast_fold);\n         return {node: n, span: self.new_span(s)};\n     }\n-    fn fold_crate_directive(&&c: @crate_directive) -> @crate_directive {\n-        let (n, s) = self.fold_crate_directive(c.node, c.span,\n-                                               self as ast_fold);\n-        return @{node: n,\n-              span: self.new_span(s)};\n-    }\n     fn fold_view_item(&&x: @view_item) ->\n        @view_item {\n         return @{node: self.fold_view_item(x.node, self as ast_fold),"}, {"sha": "ccca4139c9b2ebf577664be1c4cb48bf92ede6eb", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,5 +1,16 @@\n //! The main parser interface\n \n+#[legacy_exports];\n+\n+export parser;\n+export common;\n+export lexer;\n+export token;\n+export comments;\n+export prec;\n+export classify;\n+export attr;\n+\n export parse_sess;\n export new_parse_sess, new_parse_sess_special_handler;\n export next_node_id;\n@@ -51,40 +62,6 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n \n fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n                          sess: parse_sess) -> @ast::crate {\n-    if input.filetype() == Some(~\".rc\") {\n-        parse_crate_from_crate_file(input, cfg, sess)\n-    } else if input.filetype() == Some(~\".rs\") {\n-        parse_crate_from_source_file(input, cfg, sess)\n-    } else {\n-        sess.span_diagnostic.handler().fatal(~\"unknown input file type: \" +\n-                                             input.to_str())\n-    }\n-}\n-\n-fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n-                               sess: parse_sess) -> @ast::crate {\n-    let p = new_crate_parser_from_file(sess, cfg, input);\n-    let lo = p.span.lo;\n-    let prefix = input.dir_path();\n-    let leading_attrs = p.parse_inner_attrs_and_next();\n-    let { inner: crate_attrs, next: first_cdir_attr } = leading_attrs;\n-    let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);\n-    let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n-    let companionmod = input.filestem().map(|s| Path(*s));\n-    let (m, attrs) = eval::eval_crate_directives_to_mod(\n-        cx, cdirs, &prefix, &companionmod);\n-    let mut hi = p.span.hi;\n-    p.expect(token::EOF);\n-    p.abort_if_errors();\n-    return @ast_util::respan(ast_util::mk_sp(lo, hi),\n-                          {directives: cdirs,\n-                           module: m,\n-                           attrs: vec::append(crate_attrs, attrs),\n-                           config: /* FIXME (#2543) */ copy p.cfg});\n-}\n-\n-fn parse_crate_from_source_file(input: &Path, cfg: ast::crate_cfg,\n-                                sess: parse_sess) -> @ast::crate {\n     let p = new_crate_parser_from_file(sess, cfg, input);\n     let r = p.parse_crate_mod(cfg);\n     return r;"}, {"sha": "a7c5f20fedfe1a8b347c6c8499c941a9eae35a04", "filename": "src/libsyntax/parse/mod.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -0,0 +1,28 @@\n+\n+#[legacy_exports]\n+mod lexer;\n+#[legacy_exports]\n+mod parser;\n+#[legacy_exports]\n+mod token;\n+#[legacy_exports]\n+mod comments;\n+#[legacy_exports]\n+mod attr;\n+#[legacy_exports]\n+\n+/// Common routines shared by parser mods\n+#[legacy_exports]\n+mod common;\n+\n+/// Functions dealing with operator precedence\n+#[legacy_exports]\n+mod prec;\n+\n+/// Routines the parser uses to classify AST nodes\n+#[legacy_exports]\n+mod classify;\n+\n+/// Reporting obsolete syntax\n+#[legacy_exports]\n+mod obsolete;"}, {"sha": "382b572f33e18437991445de229c923d979cebb4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 55, "deletions": 94, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -27,9 +27,8 @@ use ast::{_mod, add, arg, arm, attribute,\n              bind_by_ref, bind_by_implicit_ref, bind_by_value, bind_by_move,\n              bitand, bitor, bitxor, blk, blk_check_mode, box, by_copy,\n              by_move, by_ref, by_val, capture_clause,\n-             capture_item, cdir_dir_mod, cdir_src_mod, cdir_view_item,\n-             class_immutable, class_mutable,\n-             crate, crate_cfg, crate_directive, decl, decl_item, decl_local,\n+             capture_item, class_immutable, class_mutable,\n+             crate, crate_cfg, decl, decl_item, decl_local,\n              default_blk, deref, div, enum_def, enum_variant_kind, expl, expr,\n              expr_, expr_addr_of, expr_match, expr_again, expr_assert,\n              expr_assign, expr_assign_op, expr_binary, expr_block, expr_break,\n@@ -2966,15 +2965,7 @@ impl Parser {\n         let info_ = if self.token == token::SEMI {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n-            let eval_ctx = @{\n-                sess: self.sess,\n-                cfg: self.cfg\n-            };\n-            let prefix = Path(self.sess.cm.span_to_filename(copy self.span));\n-            let prefix = prefix.dir_path();\n-            let (m, attrs) = eval::eval_src_mod(eval_ctx, &prefix,\n-                                                outer_attrs,\n-                                                id, id_span);\n+            let (m, attrs) = self.eval_src_mod(id, outer_attrs, id_span);\n             (id, m, Some(move attrs))\n         } else {\n             self.expect(token::LBRACE);\n@@ -2990,20 +2981,18 @@ impl Parser {\n         // its contents\n         match ::attr::first_attr_value_str_by_name(outer_attrs, ~\"merge\") {\n             Some(path) => {\n-                let eval_ctx = @{\n-                    sess: self.sess,\n-                    cfg: self.cfg\n-                };\n-                let prefix = Path(self.sess.cm.span_to_filename(copy self.span));\n+                let prefix = Path(\n+                    self.sess.cm.span_to_filename(copy self.span));\n                 let prefix = prefix.dir_path();\n                 let path = Path(path);\n-                let (new_mod_item, new_attrs) = eval::eval_src_mod_from_path(\n-                    eval_ctx, &prefix, &path, ~[], id_span);\n+                let (new_mod_item, new_attrs) = self.eval_src_mod_from_path(\n+                    prefix, path, ~[], id_span);\n \n                 let (main_id, main_mod_item, main_attrs) = info_;\n                 let main_attrs = main_attrs.get();\n \n-                let (main_mod, new_mod) = match (main_mod_item, new_mod_item) {\n+                let (main_mod, new_mod) =\n+                    match (main_mod_item, new_mod_item) {\n                     (item_mod(m), item_mod(n)) => (m, n),\n                     _ => self.bug(~\"parsed mod item should be mod\")\n                 };\n@@ -3019,6 +3008,51 @@ impl Parser {\n         }\n     }\n \n+    fn eval_src_mod(id: ast::ident,\n+                    outer_attrs: ~[ast::attribute],\n+                    id_sp: span) -> (ast::item_, ~[ast::attribute]) {\n+        let prefix = Path(self.sess.cm.span_to_filename(copy self.span));\n+        let prefix = prefix.dir_path();\n+        let default_path = self.sess.interner.get(id) + ~\".rs\";\n+        let file_path = match ::attr::first_attr_value_str_by_name(\n+            outer_attrs, ~\"path\") {\n+\n+            Some(d) => d,\n+            None => default_path\n+        };\n+\n+        let file_path = Path(file_path);\n+        self.eval_src_mod_from_path(prefix, file_path,\n+                                    outer_attrs, id_sp)\n+    }\n+\n+    fn eval_src_mod_from_path(prefix: Path, path: Path,\n+                              outer_attrs: ~[ast::attribute],\n+                              id_sp: span\n+                             ) -> (ast::item_, ~[ast::attribute]) {\n+\n+        let full_path = if path.is_absolute {\n+            path\n+        } else {\n+            prefix.push_many(path.components)\n+        };\n+        let p0 =\n+            new_sub_parser_from_file(self.sess, self.cfg,\n+                                     &full_path, id_sp);\n+        let inner_attrs = p0.parse_inner_attrs_and_next();\n+        let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n+        let first_item_outer_attrs = inner_attrs.next;\n+        let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n+        return (ast::item_mod(m0), mod_attrs);\n+\n+        fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n+            match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n+                Some(d) => d,\n+                None => default\n+            }\n+        }\n+    }\n+\n     fn parse_item_foreign_fn( +attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n@@ -3699,8 +3733,7 @@ impl Parser {\n         let first_item_outer_attrs = crate_attrs.next;\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return @spanned(lo, self.span.lo,\n-                     {directives: ~[],\n-                      module: m,\n+                     {module: m,\n                       attrs: crate_attrs.inner,\n                       config: self.cfg});\n     }\n@@ -3711,78 +3744,6 @@ impl Parser {\n           _ =>  self.fatal(~\"expected string literal\")\n         }\n     }\n-\n-    // Logic for parsing crate files (.rc)\n-    //\n-    // Each crate file is a sequence of directives.\n-    //\n-    // Each directive imperatively extends its environment with 0 or more\n-    // items.\n-    fn parse_crate_directive(first_outer_attr: ~[attribute]) ->\n-        crate_directive {\n-\n-        // Collect the next attributes\n-        let outer_attrs = vec::append(first_outer_attr,\n-                                      self.parse_outer_attributes());\n-        // In a crate file outer attributes are only going to apply to mods\n-        let expect_mod = vec::len(outer_attrs) > 0u;\n-\n-        let lo = self.span.lo;\n-        let vis = self.parse_visibility();\n-        if expect_mod || self.is_keyword(~\"mod\") {\n-\n-            self.expect_keyword(~\"mod\");\n-\n-            let id = self.parse_ident();\n-            match self.token {\n-              // mod x = \"foo.rs\";\n-              token::SEMI => {\n-                let mut hi = self.span.hi;\n-                self.bump();\n-                return spanned(lo, hi, cdir_src_mod(vis, id, outer_attrs));\n-              }\n-              // mod x = \"foo_dir\" { ...directives... }\n-              token::LBRACE => {\n-                self.bump();\n-                let inner_attrs = self.parse_inner_attrs_and_next();\n-                let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n-                let next_outer_attr = inner_attrs.next;\n-                let cdirs = self.parse_crate_directives(token::RBRACE,\n-                                                        next_outer_attr);\n-                let mut hi = self.span.hi;\n-                self.expect(token::RBRACE);\n-                return spanned(lo, hi,\n-                            cdir_dir_mod(vis, id, cdirs, mod_attrs));\n-              }\n-              _ => self.unexpected()\n-            }\n-        } else if self.is_view_item() {\n-            let vi = self.parse_view_item(outer_attrs, vis);\n-            return spanned(lo, vi.span.hi, cdir_view_item(vi));\n-        }\n-        return self.fatal(~\"expected crate directive\");\n-    }\n-\n-    fn parse_crate_directives(term: token::Token,\n-                              first_outer_attr: ~[attribute]) ->\n-        ~[@crate_directive] {\n-\n-        // This is pretty ugly. If we have an outer attribute then we can't\n-        // accept seeing the terminator next, so if we do see it then fail the\n-        // same way parse_crate_directive would\n-        if vec::len(first_outer_attr) > 0u && self.token == term {\n-            self.expect_keyword(~\"mod\");\n-        }\n-\n-        let mut cdirs: ~[@crate_directive] = ~[];\n-        let mut first_outer_attr = first_outer_attr;\n-        while self.token != term {\n-            let cdir = @self.parse_crate_directive(first_outer_attr);\n-            cdirs.push(cdir);\n-            first_outer_attr = ~[];\n-        }\n-        return cdirs;\n-    }\n }\n \n impl restriction : cmp::Eq {"}, {"sha": "afd961f22fc713024d4ba6497941a179ac3c2777", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,3 +1,5 @@\n+// DIVERT\n+\n #[link(name = \"syntax\",\n        vers = \"0.5\",\n        uuid = \"9311401b-d6ea-4cd9-a1d9-61f89499c645\")];\n@@ -54,8 +56,6 @@ mod parse {\n     export classify;\n     export attr;\n \n-    #[legacy_exports]\n-    mod eval;\n     #[legacy_exports]\n     mod lexer;\n     #[legacy_exports]"}, {"sha": "afd928a9fbc4e3924c3983af650d7a84d6a17ead", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -93,16 +93,6 @@ fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n     v.visit_mod(c.node.module, c.span, crate_node_id, e, v);\n }\n \n-fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n-    match cd.node {\n-      cdir_src_mod(_, _, _) => (),\n-      cdir_dir_mod(_, _, cdirs, _) => for cdirs.each |cdir| {\n-        visit_crate_directive(*cdir, e, v);\n-      },\n-      cdir_view_item(vi) => v.visit_view_item(vi, e, v),\n-    }\n-}\n-\n fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n     for m.view_items.each |vi| { v.visit_view_item(*vi, e, v); }\n     for m.items.each |i| { v.visit_item(*i, e, v); }"}, {"sha": "8d1d15138fdcd4c18bca8ab95b85cf0f8037d898", "filename": "src/test/compile-fail/attr-bad-crate-attr.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: expected `mod`\n+// error-pattern: expected item\n \n #[attr = \"val\"];\n #[attr = \"val\"] // Unterminated"}, {"sha": "e4350ab4ee707da6765b9c3046c80827febeb4ed", "filename": "src/test/run-pass/companionmod-src/b.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,2 +0,0 @@\n-use g = x::f;\n-export g;\n\\ No newline at end of file"}, {"sha": "d81ff2ba9a50751021f2ea0d671584f1520d2b9c", "filename": "src/test/run-pass/companionmod-src/b/x.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb%2Fx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb%2Fx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb%2Fx.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-fn f() -> ~str { ~\"ralph\" }\n\\ No newline at end of file"}, {"sha": "e4350ab4ee707da6765b9c3046c80827febeb4ed", "filename": "src/test/run-pass/companionmod-src/d.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,2 +0,0 @@\n-use g = x::f;\n-export g;\n\\ No newline at end of file"}, {"sha": "b27e39327f172c0d51b1b6ee38895fc77f0f7c76", "filename": "src/test/run-pass/companionmod-src/d/x.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd%2Fx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd%2Fx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd%2Fx.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-fn f() -> ~str { ~\"nelson\" }\n\\ No newline at end of file"}, {"sha": "8736345c9827c8bbd6bad48462ce77ea1c5e6e1f", "filename": "src/test/run-pass/companionmod.rc", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod.rc?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,19 +0,0 @@\n-// xfail-win32 don't understand what's wrong\n-// Test that crates and directory modules can contain code\n-#[legacy_exports];\n-\n-#[path = \"companionmod-src\"]\n-mod a {\n-    #[legacy_exports];\n-    mod b {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod x;\n-    }\n-    #[path = \"d\"]\n-    mod c {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod x;\n-    }\n-}"}, {"sha": "ff15fe580567aed921d2adc43a02cefd3a03a1ff", "filename": "src/test/run-pass/companionmod.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcompanionmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,8 +0,0 @@\n-// This isn't really xfailed; it's used by the companionmod.rc test\n-// xfail-test\n-\n-#[legacy_exports];\n-fn main() {\n-    assert a::b::g() == ~\"ralph\";\n-    assert a::c::g() == ~\"nelson\";\n-}\n\\ No newline at end of file"}, {"sha": "7086ebf2ea8733cad205ce0612894d2c4c71cd30", "filename": "src/test/run-pass/crate-attributes-src/foo.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcrate-attributes-src%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcrate-attributes-src%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-attributes-src%2Ffoo.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,9 +0,0 @@\n-// These are attributes of the foo module\n-#[legacy_exports];\n-#[attr1 = \"val\"];\n-#[attr2 = \"val\"];\n-\n-// Attributes of the following function\n-#[attr1 = \"val\"]\n-#[attr2 = \"val\"]\n-fn main() { }"}, {"sha": "2ee41913f40d14fbcb167f60e1daac94a108bc26", "filename": "src/test/run-pass/crate-attributes.rc", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,13 +0,0 @@\n-#[name = \"crate-attributes\"];\n-#[vers = \"1.0\"];\n-\n-#[attr1]\n-#[path = \"crate-attributes-src\"]\n-mod m {\n-    #[legacy_exports];\n-  #[attr_inner];\n-\n-  #[attr2]\n-    #[legacy_exports]\n-  mod foo;\n-}"}, {"sha": "ea7d8fd77a0762efb03751e7cc6d7d69cbcb39c3", "filename": "src/test/run-pass/module-polymorphism-files/inst_f32.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f32.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = f32;\n\\ No newline at end of file"}, {"sha": "8811863b27c55ba7fa3bc7e6b265a2d01bef6679", "filename": "src/test/run-pass/module-polymorphism-files/inst_f64.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f64.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = f64;\n\\ No newline at end of file"}, {"sha": "5726ccf7ad068f09c469a68cae0e7ba531012f43", "filename": "src/test/run-pass/module-polymorphism-files/inst_float.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_float.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = float;\n\\ No newline at end of file"}, {"sha": "c8d52145cab950ce5643344c4101ac9a5238ed87", "filename": "src/test/run-pass/module-polymorphism-files/template.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Ftemplate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Ftemplate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Ftemplate.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,3 +0,0 @@\n-fn plus(x: T, y: T) -> T {\n-    x + y\n-}\n\\ No newline at end of file"}, {"sha": "bce2d80e045a87ac11150a9ded267437d3152319", "filename": "src/test/run-pass/module-polymorphism.rc", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rc?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,51 +0,0 @@\n-#[path = \"module-polymorphism-files\"]\n-mod my_float {\n-    #[legacy_exports];\n-\n-    // The type of the float\n-    use inst::T;\n-\n-    // Define T as float\n-    #[path = \"inst_float.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    // Add in the implementation from a single source file\n-    #[path = \"template.rs\"]\n-    #[legacy_exports]\n-    mod template;\n-\n-}\n-\n-#[path = \"module-polymorphism-files\"]\n-mod my_f64 {\n-    #[legacy_exports];\n-\n-    use inst::T;\n-\n-    // Define T as f64\n-    #[path = \"inst_f64.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    // Use the implementation for the same source file!\n-    #[path = \"template.rs\"]\n-    #[legacy_exports]\n-    mod template;\n-\n-}\n-\n-#[path = \"module-polymorphism-files\"]\n-mod my_f32 {\n-    #[legacy_exports];\n-    use inst::T;\n-\n-    #[path = \"inst_f32.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    #[path = \"template.rs\"]\n-    #[legacy_exports]\n-    mod template;\n-\n-}"}, {"sha": "26c3582d6a635b55b7b05d5b5454e5d25dfbc416", "filename": "src/test/run-pass/module-polymorphism.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,11 +0,0 @@\n-// This isn't really xfailed; it's used by the\n-// module-polymorphism.rc test\n-// xfail-test\n-\n-fn main() {\n-    // All of these functions are defined by a single module\n-    // source file but instantiated for different types\n-    assert my_float::template::plus(1.0f, 2.0f) == 3.0f;\n-    assert my_f64::template::plus(1.0f64, 2.0f64) == 3.0f64;\n-    assert my_f32::template::plus(1.0f32, 2.0f32) == 3.0f32;\n-}\n\\ No newline at end of file"}, {"sha": "ea7d8fd77a0762efb03751e7cc6d7d69cbcb39c3", "filename": "src/test/run-pass/module-polymorphism2-files/float-template/inst_f32.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f32.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = f32;\n\\ No newline at end of file"}, {"sha": "8811863b27c55ba7fa3bc7e6b265a2d01bef6679", "filename": "src/test/run-pass/module-polymorphism2-files/float-template/inst_f64.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f64.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = f64;\n\\ No newline at end of file"}, {"sha": "5726ccf7ad068f09c469a68cae0e7ba531012f43", "filename": "src/test/run-pass/module-polymorphism2-files/float-template/inst_float.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_float.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = float;\n\\ No newline at end of file"}, {"sha": "c8d52145cab950ce5643344c4101ac9a5238ed87", "filename": "src/test/run-pass/module-polymorphism2-files/float-template/template.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Ftemplate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Ftemplate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Ftemplate.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,3 +0,0 @@\n-fn plus(x: T, y: T) -> T {\n-    x + y\n-}\n\\ No newline at end of file"}, {"sha": "49cd60fc0a93a2a00c5dfccdfbb7b6133b89fdc0", "filename": "src/test/run-pass/module-polymorphism2.rc", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rc?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,68 +0,0 @@\n-#[path = \"module-polymorphism2-files\"]\n-mod mystd {\n-    #[legacy_exports];\n-\n-    #[path = \"float-template\"]\n-    mod float {\n-        #[legacy_exports];\n-        // The type of the float\n-        use inst::T;\n-\n-        // Unfortunate\n-        use template::*;\n-        export plus;\n-\n-        // Define T as float\n-        #[path = \"inst_float.rs\"]\n-        #[legacy_exports]\n-        mod inst;\n-\n-        // Add in the implementation from a single source file\n-        #[path = \"template.rs\"]\n-        #[legacy_exports]\n-        mod template;\n-    }\n-\n-\n-    #[path = \"float-template\"]\n-    mod f64 {\n-        #[legacy_exports];\n-\n-        use inst::T;\n-\n-        // Unfortunate\n-        use template::*;\n-        export plus;\n-\n-        // Define T as f64\n-        #[path = \"inst_f64.rs\"]\n-        #[legacy_exports]\n-        mod inst;\n-\n-        // Use the implementation for the same source file!\n-        #[path = \"template.rs\"]\n-        #[legacy_exports]\n-        mod template;\n-\n-    }\n-\n-    #[path = \"float-template\"]\n-    mod f32 {\n-        #[legacy_exports];\n-        use inst::T;\n-\n-        // Unfortunate\n-        use template::*;\n-        export plus;\n-\n-        #[path = \"inst_f32.rs\"]\n-        #[legacy_exports]\n-        mod inst;\n-\n-        #[path = \"template.rs\"]\n-        #[legacy_exports]\n-        mod template;\n-\n-    }\n-\n-}\n\\ No newline at end of file"}, {"sha": "7bb55c454306dcb514bfce95bd85c6768004f0b4", "filename": "src/test/run-pass/module-polymorphism2.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,11 +0,0 @@\n-// This isn't really xfailed; it's used by the\n-// module-polymorphism.rc test\n-// xfail-test\n-\n-fn main() {\n-    // All of these functions are defined by a single module\n-    // source file but instantiated for different types\n-    assert mystd::float::plus(1.0f, 2.0f) == 3.0f;\n-    assert mystd::f64::plus(1.0f64, 2.0f64) == 3.0f64;\n-    assert mystd::f32::plus(1.0f32, 2.0f32) == 3.0f32;\n-}\n\\ No newline at end of file"}, {"sha": "c8d52145cab950ce5643344c4101ac9a5238ed87", "filename": "src/test/run-pass/module-polymorphism3-files/float-template.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,3 +0,0 @@\n-fn plus(x: T, y: T) -> T {\n-    x + y\n-}\n\\ No newline at end of file"}, {"sha": "ea7d8fd77a0762efb03751e7cc6d7d69cbcb39c3", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_f32.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = f32;\n\\ No newline at end of file"}, {"sha": "8811863b27c55ba7fa3bc7e6b265a2d01bef6679", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_f64.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = f64;\n\\ No newline at end of file"}, {"sha": "5726ccf7ad068f09c469a68cae0e7ba531012f43", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_float.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1 +0,0 @@\n-type T = float;\n\\ No newline at end of file"}, {"sha": "27d9753d9d520fb9bcb353daedbce0eeeff4f239", "filename": "src/test/run-pass/module-polymorphism3.rc", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rc?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,41 +0,0 @@\n-// Use one template module to specify in a single file the implementation\n-// of functions for multiple types\n-\n-#[path = \"module-polymorphism3-files\"]\n-mod mystd {\n-    #[legacy_exports];\n-\n-    // The template is specified in float-template.rs\n-    #[path = \"float-template\"]\n-    mod float {\n-        #[legacy_exports];\n-        // The type of the float\n-        use inst::T;\n-\n-        // Define T as appropriate for platform\n-        #[path = \"inst_float.rs\"]\n-        mod inst;\n-    }\n-\n-    // Use the same template\n-    #[path = \"float-template\"]\n-    mod f64 {\n-        #[legacy_exports];\n-\n-        use inst::T;\n-\n-        // Define T as f64\n-        #[path = \"inst_f64.rs\"]\n-        mod inst;\n-    }\n-\n-    #[path = \"float-template\"]\n-    mod f32 {\n-        #[legacy_exports];\n-        use inst::T;\n-\n-        #[path = \"inst_f32.rs\"]\n-        mod inst;\n-    }\n-\n-}\n\\ No newline at end of file"}, {"sha": "7bb55c454306dcb514bfce95bd85c6768004f0b4", "filename": "src/test/run-pass/module-polymorphism3.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,11 +0,0 @@\n-// This isn't really xfailed; it's used by the\n-// module-polymorphism.rc test\n-// xfail-test\n-\n-fn main() {\n-    // All of these functions are defined by a single module\n-    // source file but instantiated for different types\n-    assert mystd::float::plus(1.0f, 2.0f) == 3.0f;\n-    assert mystd::f64::plus(1.0f64, 2.0f64) == 3.0f64;\n-    assert mystd::f32::plus(1.0f32, 2.0f32) == 3.0f32;\n-}\n\\ No newline at end of file"}, {"sha": "f19b72ed18176fa5775f63c7a8f7ed08c87695fb", "filename": "src/test/run-pass/module-polymorphism4-files/cat.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,14 +0,0 @@\n-type T = cat;\n-\n-enum cat {\n-    howlycat,\n-    meowlycat\n-}\n-\n-fn animal() -> ~str { ~\"cat\" }\n-fn talk(c: cat) -> ~str {\n-    match c {\n-      howlycat =>  { ~\"howl\" }\n-      meowlycat => { ~\"meow\" }\n-    }\n-}"}, {"sha": "4fd212deb8d7f7a658aebf5531bd5db7ae45701e", "filename": "src/test/run-pass/module-polymorphism4-files/dog.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fdog.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fdog.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fdog.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,9 +0,0 @@\n-type T = dog;\n-\n-enum dog {\n-    dog\n-}\n-\n-fn animal() -> ~str { ~\"dog\" }\n-fn talk(_d: dog) -> ~str { ~\"woof\" }\n-"}, {"sha": "983a4039eeb2e284acc4860a94f8bd20377230ee", "filename": "src/test/run-pass/module-polymorphism4-files/trait_.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait_.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,13 +0,0 @@\n-trait says {\n-    fn says() -> ~str;\n-}\n-\n-impl T: says {\n-\n-    // 'animal' and 'talk' functions are implemented by the module\n-    // instantiating the talky trait. They are 'abstract'\n-    fn says() -> ~str {\n-        animal() + ~\" says '\" + talk(self) + ~\"'\"\n-    }\n-\n-}"}, {"sha": "4cb7acf8f03b7e5de5ab4c600f2f8dd6359f3bcd", "filename": "src/test/run-pass/module-polymorphism4.rc", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rc?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,32 +0,0 @@\n-\n-#[path = \"module-polymorphism4-files\"]\n-mod cat {\n-    #[legacy_exports];\n-\n-    use inst::*;\n-\n-    #[path = \"cat.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    #[path = \"trait_.rs\"]\n-    #[legacy_exports]\n-    mod trait_;\n-\n-}\n-\n-#[path = \"module-polymorphism4-files\"]\n-mod dog {\n-    #[legacy_exports];\n-\n-    use inst::*;\n-\n-    #[path = \"dog.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    #[path = \"trait_.rs\"]\n-    #[legacy_exports]\n-    mod trait_;\n-\n-}"}, {"sha": "0824e5b49bb479272c176f8ef2b540ed363cc4ce", "filename": "src/test/run-pass/module-polymorphism4.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,12 +0,0 @@\n-// This isn't really xfailed; it's used by the\n-// module-polymorphism.rc test\n-// xfail-test\n-\n-fn main() {\n-    let cat1 = cat::inst::meowlycat;\n-    let cat2 = cat::inst::howlycat;\n-    let dog = dog::inst::dog;\n-    assert cat1.says() == ~\"cat says 'meow'\";\n-    assert cat2.says() == ~\"cat says 'howl'\";\n-    assert dog.says() == ~\"dog says 'woof'\";\n-}\n\\ No newline at end of file"}, {"sha": "33699ac4f849a91bbdc2bd681df4e5c25b2b4b1c", "filename": "src/test/run-pass/multi-src/bar.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,3 +0,0 @@\n-\n-\n-fn other() { debug!(\"yes\"); }"}, {"sha": "466b6b9be56781f12708ed8e88da95ef7f595291", "filename": "src/test/run-pass/multi-src/foo.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,3 +0,0 @@\n-\n-\n-fn main() { debug!(\"hello, multi-file world.\"); bar::other(); }"}, {"sha": "61c81030bbabf5d846e0d114c04b8035d2c1a55e", "filename": "src/test/run-pass/multi.rc", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmulti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Fmulti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti.rc?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,11 +0,0 @@\n-#[path = \"multi-src\"]\n-mod multi {\n-    #[legacy_exports];\n-  // implicitly #[path = \"foo.rs\"]\n-  #[legacy_exports]\n-  mod foo;\n-\n-  #[path  = \"bar.rs\"]\n-  #[legacy_exports]\n-  mod bar;\n-}"}, {"sha": "818f41de262f7e1ec726a2e11faa89731bb4553c", "filename": "src/test/run-pass/trait-mix.rc", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Ftrait-mix.rc", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Ftrait-mix.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-mix.rc?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,8 +0,0 @@\n-mod trait_mix {\n-    #[legacy_exports];\n-    #[path = \"trait-mix.rs\"]\n-    #[legacy_exports]\n-    mod trait_mix;\n-    #[legacy_exports]\n-    mod u_trait_mix;\n-}"}, {"sha": "800fb4f90063a8a921cf2923ad93949d1b1a751b", "filename": "src/test/run-pass/trait_mix/trait-mix.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Ftrait_mix%2Ftrait-mix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Ftrait_mix%2Ftrait-mix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait_mix%2Ftrait-mix.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,27 +0,0 @@\n-\n-impl f32: u_trait_mix::num {\n-    pure fn add(&&other: f32)    -> f32 { return self + other; }\n-    pure fn sub(&&other: f32)    -> f32 { return self - other; }\n-    pure fn mul(&&other: f32)    -> f32 { return self * other; }\n-    pure fn div(&&other: f32)    -> f32 { return self / other; }\n-    pure fn modulo(&&other: f32) -> f32 { return self % other; }\n-    pure fn neg()                -> f32 { return -self;        }\n-\n-    pure fn to_int()         -> int { return self as int; }\n-    static pure fn from_int(n: int) -> f32 { return n as f32;    }\n-}\n-\n-/*\n-It seems that this will fail if I try using it from another crate.\n-\n-*/\n-\n-/*\n-\n-// ICEs if I put this in num -- ???\n-trait from_int {\n-\n-}\n-*/\n-\n-fn main() {}"}, {"sha": "260955e687a1bb2aeb545689eb002aea129c7386", "filename": "src/test/run-pass/trait_mix/u_trait_mix.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Ftrait_mix%2Fu_trait_mix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a79603c0c9c2425d0a8475d29b4ef77fae8607/src%2Ftest%2Frun-pass%2Ftrait_mix%2Fu_trait_mix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait_mix%2Fu_trait_mix.rs?ref=81a79603c0c9c2425d0a8475d29b4ef77fae8607", "patch": "@@ -1,13 +0,0 @@\n-trait num {\n-    // FIXME: Trait composition. (#2616)\n-    pure fn add(&&other: self) -> self;\n-    pure fn sub(&&other: self) -> self;\n-    pure fn mul(&&other: self) -> self;\n-    pure fn div(&&other: self) -> self;\n-    pure fn modulo(&&other: self) -> self;\n-    pure fn neg() -> self;\n-\n-    pure fn to_int() -> int;\n-    static pure fn from_int(n: int) -> self;\n-}\n-"}]}