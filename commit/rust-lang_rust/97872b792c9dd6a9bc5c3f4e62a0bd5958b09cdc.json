{"sha": "97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "node_id": "C_kwDOAAsO6NoAKDk3ODcyYjc5MmM5ZGQ2YTliYzVjM2Y0ZTYyYTBiZDU5NThiMDljZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-02T12:01:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-02T12:01:17Z"}, "message": "Auto merge of #107478 - compiler-errors:anon-enum-tys-are-ambiguous, r=estebank\n\nRevert \"Teach parser to understand fake anonymous enum syntax\" and related commits\n\nanonymous enum types are currently ambiguous in positions like:\n\n* `|` operator: `a as fn() -> B | C`\n* closure args: `|_: as fn() -> A | B`\n\nI first tried to thread around `RecoverAnonEnum` into all these positions, but the resulting complexity in the compiler is IMO not worth it, or at least worth a bit more thinking time. In the mean time, let's revert this syntax for now, so we can go back to the drawing board.\n\nFixes #107461\n\ncc: `@estebank` `@cjgillot` #106960\n\n---\n### Squashed revert commits:\n\nRevert \"review comment: Remove AST AnonTy\"\n\nThis reverts commit 020cca8d36cb678e3ddc2ead41364be314d19e93.\n\nRevert \"Ensure macros are not affected\"\n\nThis reverts commit 12d18e403139eeeeb339e8611b2bed4910864edb.\n\nRevert \"Emit fewer errors on patterns with possible type ascription\"\n\nThis reverts commit c847a01a3b1f620c4fdb98c75805033e768975d1.\n\nRevert \"Teach parser to understand fake anonymous enum syntax\"\n\nThis reverts commit 2d824206655bfb26cb5eed43490ee396542b153e.", "tree": {"sha": "ac382c6f916b98074fe5ce756d3778d5d3f0d407", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac382c6f916b98074fe5ce756d3778d5d3f0d407"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "html_url": "https://github.com/rust-lang/rust/commit/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9985cf172e7cb8ab5c58ce2818752c3572754fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9985cf172e7cb8ab5c58ce2818752c3572754fc", "html_url": "https://github.com/rust-lang/rust/commit/a9985cf172e7cb8ab5c58ce2818752c3572754fc"}, {"sha": "39db65c526ae3b97f0ee90642242c8c07865707e", "url": "https://api.github.com/repos/rust-lang/rust/commits/39db65c526ae3b97f0ee90642242c8c07865707e", "html_url": "https://github.com/rust-lang/rust/commit/39db65c526ae3b97f0ee90642242c8c07865707e"}], "stats": {"total": 337, "additions": 72, "deletions": 265}, "files": [{"sha": "bdb1879ec201d9c74fea9483e7ff19d3a8abf5eb", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "patch": "@@ -403,8 +403,8 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Ref);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(tys) => {\n-            walk_list!(visitor, visit_ty, tys);\n+        TyKind::Tup(tuple_element_types) => {\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n         TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);"}, {"sha": "16d5edfd303a3fc0b58202e608e11499dfd46128", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "patch": "@@ -2394,7 +2394,7 @@ impl<'a> Parser<'a> {\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    pub(crate) fn maybe_recover_colon_colon_in_pat_typo_or_anon_enum(\n+    pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n         &mut self,\n         mut first_pat: P<Pat>,\n         expected: Option<Expected>,\n@@ -2405,41 +2405,26 @@ impl<'a> Parser<'a> {\n         if !matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n             || !self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n         {\n-            let mut snapshot_type = self.create_snapshot_for_diagnostic();\n-            snapshot_type.bump(); // `:`\n-            match snapshot_type.parse_ty() {\n-                Err(inner_err) => {\n-                    inner_err.cancel();\n-                }\n-                Ok(ty) => {\n-                    let Err(mut err) = self.expected_one_of_not_found(&[], &[]) else {\n-                        return first_pat;\n-                    };\n-                    err.span_label(ty.span, \"specifying the type of a pattern isn't supported\");\n-                    self.restore_snapshot(snapshot_type);\n-                    let span = first_pat.span.to(ty.span);\n-                    first_pat = self.mk_pat(span, PatKind::Wild);\n-                    err.emit();\n-                }\n-            }\n             return first_pat;\n         }\n         // The pattern looks like it might be a path with a `::` -> `:` typo:\n         // `match foo { bar:baz => {} }`\n-        let colon_span = self.token.span;\n+        let span = self.token.span;\n         // We only emit \"unexpected `:`\" error here if we can successfully parse the\n         // whole pattern correctly in that case.\n-        let mut snapshot_pat = self.create_snapshot_for_diagnostic();\n-        let mut snapshot_type = self.create_snapshot_for_diagnostic();\n+        let snapshot = self.create_snapshot_for_diagnostic();\n \n         // Create error for \"unexpected `:`\".\n         match self.expected_one_of_not_found(&[], &[]) {\n             Err(mut err) => {\n-                snapshot_pat.bump(); // Skip the `:`.\n-                snapshot_type.bump(); // Skip the `:`.\n-                match snapshot_pat.parse_pat_no_top_alt(expected) {\n+                self.bump(); // Skip the `:`.\n+                match self.parse_pat_no_top_alt(expected) {\n                     Err(inner_err) => {\n+                        // Carry on as if we had not done anything, callers will emit a\n+                        // reasonable error.\n                         inner_err.cancel();\n+                        err.cancel();\n+                        self.restore_snapshot(snapshot);\n                     }\n                     Ok(mut pat) => {\n                         // We've parsed the rest of the pattern.\n@@ -2503,33 +2488,22 @@ impl<'a> Parser<'a> {\n                             _ => {}\n                         }\n                         if show_sugg {\n-                            err.span_suggestion_verbose(\n-                                colon_span.until(self.look_ahead(1, |t| t.span)),\n+                            err.span_suggestion(\n+                                span,\n                                 \"maybe write a path separator here\",\n                                 \"::\",\n                                 Applicability::MaybeIncorrect,\n                             );\n                         } else {\n                             first_pat = self.mk_pat(new_span, PatKind::Wild);\n                         }\n-                        self.restore_snapshot(snapshot_pat);\n+                        err.emit();\n                     }\n                 }\n-                match snapshot_type.parse_ty() {\n-                    Err(inner_err) => {\n-                        inner_err.cancel();\n-                    }\n-                    Ok(ty) => {\n-                        err.span_label(ty.span, \"specifying the type of a pattern isn't supported\");\n-                        self.restore_snapshot(snapshot_type);\n-                        let new_span = first_pat.span.to(ty.span);\n-                        first_pat = self.mk_pat(new_span, PatKind::Wild);\n-                    }\n-                }\n-                err.emit();\n             }\n             _ => {\n                 // Carry on as if we had not done anything. This should be unreachable.\n+                self.restore_snapshot(snapshot);\n             }\n         };\n         first_pat"}, {"sha": "e75554ba124b39d850c24d2c4777cc374042223b", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "patch": "@@ -148,8 +148,7 @@ impl<'a> Parser<'a> {\n \n             // Check if the user wrote `foo:bar` instead of `foo::bar`.\n             if ra == RecoverColon::Yes {\n-                first_pat =\n-                    self.maybe_recover_colon_colon_in_pat_typo_or_anon_enum(first_pat, expected);\n+                first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, expected);\n             }\n \n             if let Some(leading_vert_span) = leading_vert_span {"}, {"sha": "646e2f45e640cb8a6a233bf01170f5cba002afc8", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 62, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "patch": "@@ -17,7 +17,6 @@ use rustc_ast::{\n     self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n };\n-use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -50,24 +49,17 @@ pub(super) enum AllowPlus {\n     No,\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n+#[derive(PartialEq)]\n pub(super) enum RecoverQPath {\n     Yes,\n     No,\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n pub(super) enum RecoverQuestionMark {\n     Yes,\n     No,\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n-pub(super) enum RecoverAnonEnum {\n-    Yes,\n-    No,\n-}\n-\n /// Signals whether parsing a type should recover `->`.\n ///\n /// More specifically, when parsing a function like:\n@@ -100,7 +92,7 @@ impl RecoverReturnSign {\n }\n \n // Is `...` (`CVarArgs`) legal at this level of type parsing?\n-#[derive(PartialEq, Clone, Copy)]\n+#[derive(PartialEq)]\n enum AllowCVariadic {\n     Yes,\n     No,\n@@ -125,7 +117,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -140,7 +131,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             Some(ty_params),\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -155,7 +145,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::Yes,\n         )\n     }\n \n@@ -173,7 +162,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -187,7 +175,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::No,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -199,7 +186,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::No,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -212,7 +198,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::OnlyFatArrow,\n             None,\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -232,7 +217,6 @@ impl<'a> Parser<'a> {\n                 recover_return_sign,\n                 None,\n                 RecoverQuestionMark::Yes,\n-                RecoverAnonEnum::Yes,\n             )?;\n             FnRetTy::Ty(ty)\n         } else if recover_return_sign.can_recover(&self.token.kind) {\n@@ -247,7 +231,6 @@ impl<'a> Parser<'a> {\n                 recover_return_sign,\n                 None,\n                 RecoverQuestionMark::Yes,\n-                RecoverAnonEnum::Yes,\n             )?;\n             FnRetTy::Ty(ty)\n         } else {\n@@ -263,7 +246,6 @@ impl<'a> Parser<'a> {\n         recover_return_sign: RecoverReturnSign,\n         ty_generics: Option<&Generics>,\n         recover_question_mark: RecoverQuestionMark,\n-        recover_anon_enum: RecoverAnonEnum,\n     ) -> PResult<'a, P<Ty>> {\n         let allow_qpath_recovery = recover_qpath == RecoverQPath::Yes;\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n@@ -347,50 +329,9 @@ impl<'a> Parser<'a> {\n             AllowPlus::Yes => self.maybe_recover_from_bad_type_plus(&ty)?,\n             AllowPlus::No => self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty),\n         }\n-        if RecoverQuestionMark::Yes == recover_question_mark {\n+        if let RecoverQuestionMark::Yes = recover_question_mark {\n             ty = self.maybe_recover_from_question_mark(ty);\n         }\n-        if recover_anon_enum == RecoverAnonEnum::Yes\n-            && self.check_noexpect(&token::BinOp(token::Or))\n-            && self.look_ahead(1, |t| t.can_begin_type())\n-        {\n-            let mut pipes = vec![self.token.span];\n-            let mut types = vec![ty];\n-            loop {\n-                if !self.eat(&token::BinOp(token::Or)) {\n-                    break;\n-                }\n-                pipes.push(self.prev_token.span);\n-                types.push(self.parse_ty_common(\n-                    allow_plus,\n-                    allow_c_variadic,\n-                    recover_qpath,\n-                    recover_return_sign,\n-                    ty_generics,\n-                    recover_question_mark,\n-                    RecoverAnonEnum::No,\n-                )?);\n-            }\n-            let mut err = self.struct_span_err(pipes, \"anonymous enums are not supported\");\n-            for ty in &types {\n-                err.span_label(ty.span, \"\");\n-            }\n-            err.help(&format!(\n-                \"create a named `enum` and use it here instead:\\nenum Name {{\\n{}\\n}}\",\n-                types\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, t)| format!(\n-                        \"    Variant{}({}),\",\n-                        i + 1, // Lets not confuse people with zero-indexing :)\n-                        pprust::to_string(|s| s.print_type(&t)),\n-                    ))\n-                    .collect::<Vec<_>>()\n-                    .join(\"\\n\"),\n-            ));\n-            err.emit();\n-            return Ok(self.mk_ty(lo.to(self.prev_token.span), TyKind::Err));\n-        }\n         if allow_qpath_recovery { self.maybe_recover_from_bad_qpath(ty) } else { Ok(ty) }\n     }\n "}, {"sha": "b0173cf98e0a6781f73b8aa58b6e35a2b87a6d83", "filename": "tests/ui/parser/anon-enums-are-ambiguous.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/tests%2Fui%2Fparser%2Fanon-enums-are-ambiguous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/tests%2Fui%2Fparser%2Fanon-enums-are-ambiguous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fanon-enums-are-ambiguous.rs?ref=97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+\n+macro_rules! test_expr {\n+    ($expr:expr) => {};\n+}\n+\n+macro_rules! test_ty {\n+    ($a:ty | $b:ty) => {};\n+}\n+\n+fn main() {\n+    test_expr!(a as fn() -> B | C);\n+    // Do not break the `|` operator.\n+\n+    test_expr!(|_: fn() -> B| C | D);\n+    // Do not break `-> Ret` in closure args.\n+\n+    test_ty!(A | B);\n+    // We can't support anon enums in arbitrary positions.\n+\n+    test_ty!(fn() -> A | B);\n+    // Don't break fn ptrs.\n+\n+    test_ty!(impl Fn() -> A | B);\n+    // Don't break parenthesized generics.\n+}"}, {"sha": "56b8a3d43bedf674eb4a879fea8252e8f2f9273e", "filename": "tests/ui/parser/anon-enums.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a9985cf172e7cb8ab5c58ce2818752c3572754fc/tests%2Fui%2Fparser%2Fanon-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9985cf172e7cb8ab5c58ce2818752c3572754fc/tests%2Fui%2Fparser%2Fanon-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fanon-enums.rs?ref=a9985cf172e7cb8ab5c58ce2818752c3572754fc", "patch": "@@ -1,17 +0,0 @@\n-fn foo(x: bool | i32) -> i32 | f64 {\n-//~^ ERROR anonymous enums are not supported\n-//~| ERROR anonymous enums are not supported\n-    match x {\n-        x: i32 => x, //~ ERROR expected\n-        true => 42.,\n-        false => 0.333,\n-    }\n-}\n-\n-fn main() {\n-    match foo(true) {\n-        42: i32 => (), //~ ERROR expected\n-        _: f64 => (), //~ ERROR expected\n-        x: i32 => (), //~ ERROR expected\n-    }\n-}"}, {"sha": "841582256609121d41403607a0fe2d2a1b43c65c", "filename": "tests/ui/parser/anon-enums.stderr", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a9985cf172e7cb8ab5c58ce2818752c3572754fc/tests%2Fui%2Fparser%2Fanon-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9985cf172e7cb8ab5c58ce2818752c3572754fc/tests%2Fui%2Fparser%2Fanon-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fanon-enums.stderr?ref=a9985cf172e7cb8ab5c58ce2818752c3572754fc", "patch": "@@ -1,68 +0,0 @@\n-error: anonymous enums are not supported\n-  --> $DIR/anon-enums.rs:1:16\n-   |\n-LL | fn foo(x: bool | i32) -> i32 | f64 {\n-   |           ---- ^ ---\n-   |\n-   = help: create a named `enum` and use it here instead:\n-           enum Name {\n-               Variant1(bool),\n-               Variant2(i32),\n-           }\n-\n-error: anonymous enums are not supported\n-  --> $DIR/anon-enums.rs:1:30\n-   |\n-LL | fn foo(x: bool | i32) -> i32 | f64 {\n-   |                          --- ^ ---\n-   |\n-   = help: create a named `enum` and use it here instead:\n-           enum Name {\n-               Variant1(i32),\n-               Variant2(f64),\n-           }\n-\n-error: expected one of `@` or `|`, found `:`\n-  --> $DIR/anon-enums.rs:5:10\n-   |\n-LL |         x: i32 => x,\n-   |          ^ --- specifying the type of a pattern isn't supported\n-   |          |\n-   |          expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         x::i32 => x,\n-   |          ~~\n-\n-error: expected one of `...`, `..=`, `..`, or `|`, found `:`\n-  --> $DIR/anon-enums.rs:13:11\n-   |\n-LL |         42: i32 => (),\n-   |           ^ --- specifying the type of a pattern isn't supported\n-   |           |\n-   |           expected one of `...`, `..=`, `..`, or `|`\n-\n-error: expected `|`, found `:`\n-  --> $DIR/anon-enums.rs:14:10\n-   |\n-LL |         _: f64 => (),\n-   |          ^ --- specifying the type of a pattern isn't supported\n-   |          |\n-   |          expected `|`\n-\n-error: expected one of `@` or `|`, found `:`\n-  --> $DIR/anon-enums.rs:15:10\n-   |\n-LL |         x: i32 => (),\n-   |          ^ --- specifying the type of a pattern isn't supported\n-   |          |\n-   |          expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         x::i32 => (),\n-   |          ~~\n-\n-error: aborting due to 6 previous errors\n-"}, {"sha": "38fe8dee2382915c6b3d0f02bb8867046a2bced5", "filename": "tests/ui/parser/fake-anon-enums-in-macros.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9985cf172e7cb8ab5c58ce2818752c3572754fc/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9985cf172e7cb8ab5c58ce2818752c3572754fc/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs?ref=a9985cf172e7cb8ab5c58ce2818752c3572754fc", "patch": "@@ -1,20 +0,0 @@\n-// build-pass\n-macro_rules! check_ty {\n-    ($Z:ty) => { compile_error!(\"triggered\"); };\n-    ($X:ty | $Y:ty) => { $X };\n-}\n-\n-macro_rules! check {\n-    ($Z:ty) => { compile_error!(\"triggered\"); };\n-    ($X:ty | $Y:ty) => { };\n-}\n-\n-check! { i32 | u8 }\n-\n-fn foo(x: check_ty! { i32 | u8 }) -> check_ty! { i32 | u8 } {\n-    x\n-}\n-fn main() {\n-    let x: check_ty! { i32 | u8 } = 42;\n-    let _: check_ty! { i32 | u8 } = foo(x);\n-}"}, {"sha": "0b7b67496d6f32df39107feb43e1c957a029ae21", "filename": "tests/ui/parser/issues/issue-87086-colon-path-sep.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs?ref=97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "patch": "@@ -68,6 +68,7 @@ fn main() {\n         Foo:Bar::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n+        //~| ERROR: failed to resolve: `Bar` is a variant, not a module\n     }\n     match myfoo {\n         Foo::Bar => {}"}, {"sha": "2050a16beb34983c63e96f847a82c1d23f3f16d5", "filename": "tests/ui/parser/issues/issue-87086-colon-path-sep.stderr", "status": "modified", "additions": 26, "deletions": 55, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr?ref=97872b792c9dd6a9bc5c3f4e62a0bd5958b09cdc", "patch": "@@ -2,118 +2,89 @@ error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:17:12\n    |\n LL |         Foo:Bar => {}\n-   |            ^--- specifying the type of a pattern isn't supported\n+   |            ^\n    |            |\n    |            expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         Foo::Bar => {}\n-   |            ~~\n+   |            help: maybe write a path separator here: `::`\n \n error: expected one of `!`, `(`, `...`, `..=`, `..`, `::`, `{`, or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:23:17\n    |\n LL |         qux::Foo:Bar => {}\n-   |                 ^--- specifying the type of a pattern isn't supported\n+   |                 ^\n    |                 |\n    |                 expected one of 8 possible tokens\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         qux::Foo::Bar => {}\n-   |                 ~~\n+   |                 help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:29:12\n    |\n LL |         qux:Foo::Baz => {}\n-   |            ^-------- specifying the type of a pattern isn't supported\n+   |            ^\n    |            |\n    |            expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         qux::Foo::Baz => {}\n-   |            ~~\n+   |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:35:12\n    |\n LL |         qux: Foo::Baz if true => {}\n-   |            ^ -------- specifying the type of a pattern isn't supported\n+   |            ^\n    |            |\n    |            expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         qux::Foo::Baz if true => {}\n-   |            ~~\n+   |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:40:15\n    |\n LL |     if let Foo:Bar = f() {\n-   |               ^--- specifying the type of a pattern isn't supported\n+   |               ^\n    |               |\n    |               expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |     if let Foo::Bar = f() {\n-   |               ~~\n+   |               help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:48:16\n    |\n LL |         ref qux: Foo::Baz => {}\n-   |                ^ -------- specifying the type of a pattern isn't supported\n+   |                ^\n    |                |\n    |                expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         ref qux::Foo::Baz => {}\n-   |                ~~\n+   |                help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:57:16\n    |\n LL |         mut qux: Foo::Baz => {}\n-   |                ^ -------- specifying the type of a pattern isn't supported\n+   |                ^\n    |                |\n    |                expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         mut qux::Foo::Baz => {}\n-   |                ~~\n+   |                help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:68:12\n    |\n LL |         Foo:Bar::Baz => {}\n-   |            ^-------- specifying the type of a pattern isn't supported\n+   |            ^\n    |            |\n    |            expected one of `@` or `|`\n-   |\n-help: maybe write a path separator here\n-   |\n-LL |         Foo::Bar::Baz => {}\n-   |            ~~\n+   |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:74:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:75:12\n    |\n LL |         Foo:Bar => {}\n-   |            ^--- specifying the type of a pattern isn't supported\n+   |            ^\n    |            |\n    |            expected one of `@` or `|`\n+   |            help: maybe write a path separator here: `::`\n+\n+error[E0433]: failed to resolve: `Bar` is a variant, not a module\n+  --> $DIR/issue-87086-colon-path-sep.rs:68:13\n    |\n-help: maybe write a path separator here\n-   |\n-LL |         Foo::Bar => {}\n-   |            ~~\n+LL |         Foo:Bar::Baz => {}\n+   |             ^^^ `Bar` is a variant, not a module\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n \n+For more information about this error, try `rustc --explain E0433`."}]}