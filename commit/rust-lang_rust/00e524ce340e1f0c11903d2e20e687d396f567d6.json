{"sha": "00e524ce340e1f0c11903d2e20e687d396f567d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZTUyNGNlMzQwZTFmMGMxMTkwM2QyZTIwZTY4N2QzOTZmNTY3ZDY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-10-25T16:23:09Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-08T13:52:02Z"}, "message": "Move `Pointer` to its own module", "tree": {"sha": "ca6f280b6ad9750ec375aee9f9b3ea94531c2148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca6f280b6ad9750ec375aee9f9b3ea94531c2148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00e524ce340e1f0c11903d2e20e687d396f567d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00e524ce340e1f0c11903d2e20e687d396f567d6", "html_url": "https://github.com/rust-lang/rust/commit/00e524ce340e1f0c11903d2e20e687d396f567d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00e524ce340e1f0c11903d2e20e687d396f567d6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99ed98b1ff42cbe883b67ef70137013345fbdea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/99ed98b1ff42cbe883b67ef70137013345fbdea1", "html_url": "https://github.com/rust-lang/rust/commit/99ed98b1ff42cbe883b67ef70137013345fbdea1"}], "stats": {"total": 302, "additions": 155, "deletions": 147}, "files": [{"sha": "40daf78f546fbf2eb7a234f96446c37f35b8586b", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 4, "deletions": 147, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/00e524ce340e1f0c11903d2e20e687d396f567d6/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00e524ce340e1f0c11903d2e20e687d396f567d6/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=00e524ce340e1f0c11903d2e20e687d396f567d6", "patch": "@@ -18,6 +18,7 @@ macro_rules! err {\n mod error;\n mod value;\n mod allocation;\n+mod pointer;\n \n pub use self::error::{\n     EvalError, EvalResult, EvalErrorKind, AssertMessage, ConstEvalErr, struct_error,\n@@ -31,11 +32,13 @@ pub use self::allocation::{\n     Relocations, UndefMask,\n };\n \n+pub use self::pointer::{Pointer, PointerArithmetic};\n+\n use std::fmt;\n use mir;\n use hir::def_id::DefId;\n use ty::{self, TyCtxt, Instance};\n-use ty::layout::{self, HasDataLayout, Size};\n+use ty::layout::{self, Size};\n use middle::region;\n use std::io;\n use std::hash::Hash;\n@@ -80,152 +83,6 @@ pub struct GlobalId<'tcx> {\n     pub promoted: Option<mir::Promoted>,\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Pointer arithmetic\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub trait PointerArithmetic: layout::HasDataLayout {\n-    // These are not supposed to be overridden.\n-\n-    #[inline(always)]\n-    fn pointer_size(&self) -> Size {\n-        self.data_layout().pointer_size\n-    }\n-\n-    //// Trunace the given value to the pointer size; also return whether there was an overflow\n-    #[inline]\n-    fn truncate_to_ptr(&self, val: u128) -> (u64, bool) {\n-        let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n-        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n-    }\n-\n-    #[inline]\n-    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n-    }\n-\n-    #[inline]\n-    fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n-        let (res, over1) = val.overflowing_add(i);\n-        let (res, over2) = self.truncate_to_ptr(u128::from(res));\n-        (res, over1 || over2)\n-    }\n-\n-    #[inline]\n-    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n-    }\n-\n-    // Overflow checking only works properly on the range from -u64 to +u64.\n-    #[inline]\n-    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n-        // FIXME: is it possible to over/underflow here?\n-        if i < 0 {\n-            // trickery to ensure that i64::min_value() works fine\n-            // this formula only works for true negative values, it panics for zero!\n-            let n = u64::max_value() - (i as u64) + 1;\n-            val.overflowing_sub(n)\n-        } else {\n-            self.overflowing_offset(val, i as u64)\n-        }\n-    }\n-}\n-\n-impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n-\n-\n-/// Pointer is generic over the type that represents a reference to Allocations,\n-/// thus making it possible for the most convenient representation to be used in\n-/// each context.\n-///\n-/// Defaults to the index based and loosely coupled AllocId.\n-///\n-/// Pointer is also generic over the `Tag` associated with each pointer,\n-/// which is used to do provenance tracking during execution.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub struct Pointer<Tag=(),Id=AllocId> {\n-    pub alloc_id: Id,\n-    pub offset: Size,\n-    pub tag: Tag,\n-}\n-\n-/// Produces a `Pointer` which points to the beginning of the Allocation\n-impl From<AllocId> for Pointer {\n-    #[inline(always)]\n-    fn from(alloc_id: AllocId) -> Self {\n-        Pointer::new(alloc_id, Size::ZERO)\n-    }\n-}\n-\n-impl<'tcx> Pointer<()> {\n-    #[inline(always)]\n-    pub fn new(alloc_id: AllocId, offset: Size) -> Self {\n-        Pointer { alloc_id, offset, tag: () }\n-    }\n-\n-    #[inline(always)]\n-    pub fn with_default_tag<Tag>(self) -> Pointer<Tag>\n-        where Tag: Default\n-    {\n-        Pointer::new_with_tag(self.alloc_id, self.offset, Default::default())\n-    }\n-}\n-\n-impl<'tcx, Tag> Pointer<Tag> {\n-    #[inline(always)]\n-    pub fn new_with_tag(alloc_id: AllocId, offset: Size, tag: Tag) -> Self {\n-        Pointer { alloc_id, offset, tag }\n-    }\n-\n-    #[inline]\n-    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new_with_tag(\n-            self.alloc_id,\n-            Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n-            self.tag\n-        ))\n-    }\n-\n-    #[inline]\n-    pub fn overflowing_offset(self, i: Size, cx: &impl HasDataLayout) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n-        (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n-    }\n-\n-    #[inline(always)]\n-    pub fn wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n-        self.overflowing_offset(i, cx).0\n-    }\n-\n-    #[inline]\n-    pub fn signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new_with_tag(\n-            self.alloc_id,\n-            Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n-            self.tag,\n-        ))\n-    }\n-\n-    #[inline]\n-    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n-        (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n-    }\n-\n-    #[inline(always)]\n-    pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n-        self.overflowing_signed_offset(i128::from(i), cx).0\n-    }\n-\n-    #[inline(always)]\n-    pub fn erase_tag(self) -> Pointer {\n-        Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n-    }\n-}\n-\n-\n #[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n pub struct AllocId(pub u64);\n "}, {"sha": "1001f078e28b54faf0eb7a0905643094fd3155c3", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/00e524ce340e1f0c11903d2e20e687d396f567d6/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00e524ce340e1f0c11903d2e20e687d396f567d6/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=00e524ce340e1f0c11903d2e20e687d396f567d6", "patch": "@@ -0,0 +1,151 @@\n+ use mir;\n+use ty::layout::{self, HasDataLayout, Size};\n+\n+use super::{\n+    AllocId, EvalResult,\n+};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Pointer arithmetic\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub trait PointerArithmetic: layout::HasDataLayout {\n+    // These are not supposed to be overridden.\n+\n+    #[inline(always)]\n+    fn pointer_size(&self) -> Size {\n+        self.data_layout().pointer_size\n+    }\n+\n+    //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    #[inline]\n+    fn truncate_to_ptr(&self, val: u128) -> (u64, bool) {\n+        let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n+        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n+    }\n+\n+    #[inline]\n+    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+    }\n+\n+    #[inline]\n+    fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n+        let (res, over1) = val.overflowing_add(i);\n+        let (res, over2) = self.truncate_to_ptr(u128::from(res));\n+        (res, over1 || over2)\n+    }\n+\n+    #[inline]\n+    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+    }\n+\n+    // Overflow checking only works properly on the range from -u64 to +u64.\n+    #[inline]\n+    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n+        // FIXME: is it possible to over/underflow here?\n+        if i < 0 {\n+            // trickery to ensure that i64::min_value() works fine\n+            // this formula only works for true negative values, it panics for zero!\n+            let n = u64::max_value() - (i as u64) + 1;\n+            val.overflowing_sub(n)\n+        } else {\n+            self.overflowing_offset(val, i as u64)\n+        }\n+    }\n+}\n+\n+impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n+\n+\n+/// Pointer is generic over the type that represents a reference to Allocations,\n+/// thus making it possible for the most convenient representation to be used in\n+/// each context.\n+///\n+/// Defaults to the index based and loosely coupled AllocId.\n+///\n+/// Pointer is also generic over the `Tag` associated with each pointer,\n+/// which is used to do provenance tracking during execution.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+pub struct Pointer<Tag=(),Id=AllocId> {\n+    pub alloc_id: Id,\n+    pub offset: Size,\n+    pub tag: Tag,\n+}\n+\n+/// Produces a `Pointer` which points to the beginning of the Allocation\n+impl From<AllocId> for Pointer {\n+    #[inline(always)]\n+    fn from(alloc_id: AllocId) -> Self {\n+        Pointer::new(alloc_id, Size::ZERO)\n+    }\n+}\n+\n+impl<'tcx> Pointer<()> {\n+    #[inline(always)]\n+    pub fn new(alloc_id: AllocId, offset: Size) -> Self {\n+        Pointer { alloc_id, offset, tag: () }\n+    }\n+\n+    #[inline(always)]\n+    pub fn with_default_tag<Tag>(self) -> Pointer<Tag>\n+        where Tag: Default\n+    {\n+        Pointer::new_with_tag(self.alloc_id, self.offset, Default::default())\n+    }\n+}\n+\n+impl<'tcx, Tag> Pointer<Tag> {\n+    #[inline(always)]\n+    pub fn new_with_tag(alloc_id: AllocId, offset: Size, tag: Tag) -> Self {\n+        Pointer { alloc_id, offset, tag }\n+    }\n+\n+    #[inline]\n+    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+        Ok(Pointer::new_with_tag(\n+            self.alloc_id,\n+            Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n+            self.tag\n+        ))\n+    }\n+\n+    #[inline]\n+    pub fn overflowing_offset(self, i: Size, cx: &impl HasDataLayout) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n+        (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n+    }\n+\n+    #[inline(always)]\n+    pub fn wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n+        self.overflowing_offset(i, cx).0\n+    }\n+\n+    #[inline]\n+    pub fn signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+        Ok(Pointer::new_with_tag(\n+            self.alloc_id,\n+            Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n+            self.tag,\n+        ))\n+    }\n+\n+    #[inline]\n+    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n+        (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n+    }\n+\n+    #[inline(always)]\n+    pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n+        self.overflowing_signed_offset(i128::from(i), cx).0\n+    }\n+\n+    #[inline(always)]\n+    pub fn erase_tag(self) -> Pointer {\n+        Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n+    }\n+}\n\\ No newline at end of file"}]}